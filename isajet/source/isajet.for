CDECK  ID>, AMASS.  
      FUNCTION AMASS(ID)
C
C          Returns the mass of the particle with IDENT code ID.
C          Quark-based IDENT code.
C          Ver 7.10: Update masses and split B baryon degeneracy.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QLMASS/AMLEP(100),NQLEP,NMES,NBARY
      SAVE /QLMASS/
      INTEGER   NQLEP,NMES,NBARY
      REAL      AMLEP
      INTEGER ID
      REAL AMASS
      REAL AMMES0(10),AMMES1(10),AMBAR0(30),AMBAR1(30)
      INTEGER IFL1,IFL2,IFL3,JSPIN,INDEX,IFL1A,IFL2A,IFL3A,IDA
C
C          0- meson mass table
C          pi0, pi+, eta, k+, k0, etap, ad0, d-, ds-, etac
C
      DATA AMMES0/.13496,.13957,.54745,.49367,.49767,.95775,1.8645
     $,1.8693,1.9688,2.9788/
C
C          1- meson mass table
C          rho0, rho+, omega, k*+, k*0, phi, ad*0, d*-, d*s-, jpsi
C
      DATA AMMES1/.7681,.7681,.78195,.89159,.89610,1.0194,2.0071
     $,2.0101,2.1103,3.0969/
C
C          1/2+ baryon mass table
C          x,p,n,-,-,s+,s0,s-,l,xi0,xi-,x,x,x
C          sc++,sc+,sc0,lc+,usc.,dsc.,ssc.,sdc.,suc.,ucc.,dcc.,scc.
C
      DATA AMBAR0/-1.,.93828,.93957,2*-1.,1.1894,1.1925,1.1974
     $,1.1156,1.3149,1.3213,3*-1.,2.4527,2.4529,2.4525,2.2849
     $,2.50,2.50,2.60,2.40,2.40,3.55,3.55,3.70,4*-1./
C
C          3/2+ baryon mass table
C          dl++,dl+,dl0,dl-,-,s*+,s*0,s*-,x,xi*0,xi*-,om-,x,x
C          uuc*,udc*,ddc*,x,usc*,dsc*,ssc*,x,x,,ucc*,dcc*,scc*,ccc*
C
      DATA AMBAR1/1.232,1.232,1.232,1.232,-1.,1.3823,1.3820
     $,1.3875,-1.,1.5318,1.5350,1.6722,2*-1.
     $,2.63,2.63,2.63,-1.,2.70,2.70,2.80,2*-1.,3.75,3.75
     $,3.90,4.80,3*-1./
C
C          Entry
C
      AMASS=-1.
      CALL FLAVOR(ID,IFL1,IFL2,IFL3,JSPIN,INDEX)
      IDA=IABS(ID)
      IFL1A=IABS(IFL1)
      IFL2A=IABS(IFL2)
      IFL3A=IABS(IFL3)
      IF(IDA.GT.10000.OR.JSPIN.GT.1) GO TO 500
C
C          Diquarks
C
      IF(ID.NE.0.AND.MOD(ID,100).EQ.0) THEN
        AMASS=AMLEP(IFL1A)+AMLEP(IFL2A)
C
C          b and t particles. Only a few b masses are known, but we
C          guess a few others to make sure decays are allowed:
C
      ELSEIF(IFL3A.GT.4) THEN
        IF(IDA.EQ.150.OR.IDA.EQ.250) THEN
          AMASS=5.2786
        ELSEIF(IDA.EQ.151.OR.IDA.EQ.251) THEN
          AMASS=5.3246
        ELSEIF(IDA.EQ.350) THEN
          AMASS=5.3693
        ELSEIF(IDA.EQ.351) THEN
          AMASS=5.3693+0.04
        ELSEIF(IDA.EQ.2150) THEN
          AMASS=5.641
        ELSEIF(IDA.EQ.1150.OR.IDA.EQ.1250.OR.IDA.EQ.2250) THEN
          AMASS=5.641+0.171
        ELSEIF(IDA.EQ.2151) THEN
          AMASS=5.641+.04
        ELSEIF(IDA.EQ.1151.OR.IDA.EQ.1251.OR.IDA.EQ.2251) THEN
          AMASS=5.641+0.171+0.04
        ELSE
          AMASS=AMLEP(IFL2A)+AMLEP(IFL3A)-.03+.04*JSPIN
          IF(IFL1.NE.0) AMASS=AMASS+AMLEP(IFL1A)
        ENDIF
C
C          Quarks and leptons
C
      ELSEIF(IFL2.EQ.0) THEN
        AMASS=AMLEP(INDEX)
C
C          Mesons
C
      ELSEIF(IFL1.EQ.0) THEN
        INDEX=INDEX-36*JSPIN-NQLEP
        INDEX=INDEX-12
        AMASS=(1-JSPIN)*AMMES0(INDEX)+JSPIN*AMMES1(INDEX)
C
C          Baryons
C
      ELSE
        INDEX=INDEX-109*JSPIN-36*NMES-NQLEP
        INDEX=INDEX-12
        AMASS=(1-JSPIN)*AMBAR0(INDEX)+JSPIN*AMBAR1(INDEX)
      ENDIF
      RETURN
C
C          Special hadrons - used only in B decays
C
500   IF(IDA.EQ.10121.OR.IDA.EQ.10111) THEN
        AMASS=1.230
      ELSEIF(IDA.EQ.10131.OR.IDA.EQ.10231) THEN
        AMASS=1.273
      ELSEIF(IDA.EQ.30131.OR.IDA.EQ.30231) THEN
        AMASS=1.412
      ELSEIF(IDA.EQ.132) THEN
        AMASS=1.4254
      ELSEIF(IDA.EQ.232) THEN
        AMASS=1.4324
      ELSEIF(IDA.EQ.10110) THEN
        AMASS=0.980+0.020
      ELSEIF(IDA.EQ.112) THEN
        AMASS=1.275
      ELSEIF(IDA.EQ.10441) THEN
        AMASS=3.686
      ELSEIF(IDA.EQ.20440) THEN
        AMASS=3.4151
      ELSEIF(IDA.EQ.20441) THEN
        AMASS=3.51053
      ELSEIF(IDA.EQ.20442) THEN
        AMASS=3.56617
      ELSE
        AMASS=0
      ENDIF
      RETURN
      END
CDECK  ID>, CHARGE. 
      FUNCTION CHARGE(ID)
C
C          COMPUTE CHARGE OF PARTICLE WITH IDENT CODE ID
C          ICHRG MUST BE DIMENSIONED NQLEP+12
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      DIMENSION ICHRG(74),IFL(3)
C          3 * charge
      DATA ICHRG/0
     $,2,-1,-1,2,-1,2,-1,2,0,0, 0,-3,0,-3,0,-3,0,-3,0,0,0
     $,2,-1,-1,2,-1,2,-1,2,0,0, 0,-3,0,-3,0,-3,0,-3,3,0
     $,2,-1,-1,2,-1,2,-1,2,3,0, 0,-3,0,-3,0,-3,0,-3,3,0
     $,3,0,0,0,0,0,3,3,6,6,0,0/
C
      IDABS=IABS(ID)
      CALL FLAVOR(ID,IFL(1),IFL(2),IFL(3),JSPIN,INDEX)
      IF(IDABS.LT.100) GO TO 200
C
      ISUM=0
      DO 100 I=1,3
        ISUM=ISUM+ICHRG(IABS(IFL(I))+1)*ISIGN(1,IFL(I))
  100 CONTINUE
      CHARGE=ISUM/3.
      RETURN
C
200   CHARGE=ICHRG(INDEX+1)*ISIGN(1,ID)
      CHARGE=CHARGE/3.
      RETURN
      END
CDECK  ID>, CTXC2I. 
      SUBROUTINE CTXC2I(CVAL,IVAL,NSIZE)
C-----------------------------------------------------------------------
C          Convert character variable CVAL to integer array IVAL
C-----------------------------------------------------------------------
      IMPLICIT NONE
      CHARACTER*(*) CVAL
      INTEGER I,NSIZE
      INTEGER IVAL(NSIZE)
C
      DO 100 I=1,NSIZE
100   IVAL(I)=ICHAR(CVAL(I:I))
C
      RETURN
      END
CDECK  ID>, CTXI2C. 
      SUBROUTINE CTXI2C(IVAL,CVAL,NSIZE)
C-----------------------------------------------------------------------
C          Convert integer array IVAL to character variable CVAL
C-----------------------------------------------------------------------
      IMPLICIT NONE
      CHARACTER*(*) CVAL
      INTEGER I,NSIZE
      INTEGER IVAL(NSIZE)
C
      DO 100 I=1,NSIZE
100   CVAL(I:I)=CHAR(IVAL(I))
C
      RETURN
      END
CDECK  ID>, CTXIN.  
      SUBROUTINE CTXIN(NVC,VC,MXVC)
C-----------------------------------------------------------------------
C  Purpose:
C          Restore the context for an ISAJET job:
C          Restore NVC words of VC all common blocks NOT associated only
C          with a single event. Call CTXOUT and this to generate mixed
C          events.
C          PARAMETER (MXVC=20000)
C          REAL    VC(MXVC)
C          ...
C          CALL CTXIN(NVC,VC,MXVC)
C
C          Note that the MSSM common blocks are not saved, so different
C          SUSY runs cannot be mixed.
C
C          Ver. 7.02: Equivalenced dummy variables to avoid mixed
C                     arguments in MOVLEV or multiple EQUIVALENCEd
C                     arguments to CTXIN/CTXOUT.
C
C  Author:
C          F.E. Paige, April 1992
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          LOOK MUST BE DIMENSIONED TO THE MAXIMUM VALUE OF INDEX.
      INTEGER   MXLOOK
      PARAMETER (MXLOOK=500)
      INTEGER   MXDKY
      PARAMETER (MXDKY=3000)
      COMMON/DKYTAB/LOOK(MXLOOK),CBR(MXDKY),MODE(5,MXDKY)
      SAVE /DKYTAB/
      INTEGER   LOOK,MODE
      REAL      CBR
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/DYPAR/FLW,RNU2(3),ANORM(3),QPOW(3),PTPOW(3)
      SAVE /DYPAR/
      LOGICAL FLW
      REAL      RNU2,ANORM,QPOW,PTPOW
      COMMON/EEPAR/SGMXEE,PLEP,PLEM
      SAVE /EEPAR/
      REAL      SGMXEE,PLEP,PLEM
      COMMON/FINAL/NKINF,SIGF,ALUM,ACCEPT,NRECS
      SAVE /FINAL/
      INTEGER   NKINF,NRECS
      REAL      SIGF,ALUM,ACCEPT
      INTEGER   MXFORC
      PARAMETER (MXFORC=40)
      COMMON/FORCE/NFORCE,IFORCE(MXFORC),MFORCE(5,MXFORC)
     $,LOOK2(2,MXFORC),LOOKST(MXFORC)
      SAVE /FORCE/
      INTEGER   NFORCE,IFORCE,MFORCE,LOOK2,LOOKST
      COMMON/FRGPAR/PUD,PBARY,SIGQT,PEND,XGEN(8),PSPIN1(8),
     $PMIX1(3,2),PMIX2(3,2),XGENSS(9)
      SAVE /FRGPAR/
      EQUIVALENCE (PMIX1(1,1),PMIXX1(1))
      EQUIVALENCE (PMIX2(1,1),PMIXX2(1))
      EQUIVALENCE(FRPAR(1),PUD)
      REAL      PUD,PBARY,SIGQT,PEND,XGEN,PSPIN1,PMIX1,PMIX2,XGENSS,
     +          PMIXX1(6),PMIXX2(6),FRPAR(32)
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/ISLOOP/NEVOLV,NFRGMN,IEVOL,IFRG
      SAVE /ISLOOP/
      INTEGER NEVOLV,NFRGMN,IEVOL,IFRG
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON /LIMEVL/ ETTHRS,CONCUT,USELIM
      SAVE /LIMEVL/
      REAL ETTHRS,CONCUT
      LOGICAL USELIM
      COMMON/LSTPRT/LSTPRT
      SAVE /LSTPRT/
      INTEGER   LSTPRT
      INTEGER   LIMPOM
      PARAMETER (LIMPOM=20)
      COMMON/MBGEN/POMWT(LIMPOM),POMGEN(LIMPOM),MNPOM,MXPOM,PDIFFR,
     $NPOM,XBARY(2),DXBARY(2),XPOM(LIMPOM,2)
      SAVE /MBGEN/
      INTEGER   MNPOM,MXPOM,NPOM
      REAL      POMWT,POMGEN,PDIFFR,XBARY,DXBARY,XPOM
      COMMON/MBPAR/PUD0,PJSPN,PISPN,SIGQT0,XGEN0(2),PMIX01(3,2)
     1,PMIX02(3,2),PBARY0
      SAVE /MBPAR/
      REAL      PUD0,PJSPN,PISPN,SIGQT0,XGEN0,PMIX01,PMIX02,PBARY0
      COMMON/NODCAY/NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      SAVE /NODCAY/
      LOGICAL NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/PRTOUT/NEVPRT,NJUMP
      SAVE /PRTOUT/
      INTEGER   NEVPRT,NJUMP
      COMMON/PTPAR/PTFUN1,PTFUN2,PTGEN1,PTGEN2,PTGEN3,SIGMAX
      SAVE /PTPAR/
      REAL      PTFUN1,PTFUN2,PTGEN1,PTGEN2,PTGEN3,SIGMAX
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/QLMASS/AMLEP(100),NQLEP,NMES,NBARY
      SAVE /QLMASS/
      INTEGER   NQLEP,NMES,NBARY
      REAL      AMLEP
      COMMON/TCPAR/TCMRHO,TCGRHO
      SAVE /TCPAR/
      REAL TCMRHO,TCGRHO
      COMMON/TIMES/TIME1,TIME2
      SAVE /TIMES/
      REAL      TIME1,TIME2
      COMMON/TOTALS/NKINPT,NWGEN,NKEEP,SUMWT,WT
      SAVE /TOTALS/
      INTEGER   NKINPT,NWGEN,NKEEP
      REAL      SUMWT,WT
      COMMON/TYPES/LOC(100),NTYP,NJTTYP(3),NWWTYP(2),NWMODE(3)
      COMMON/XTYPES/PARTYP(40),TITLE(10),JETYP(30,3),WWTYP(30,2)
     $,WMODES(30,3)
      SAVE /TYPES/,/XTYPES/
      CHARACTER*8 JETYP,WWTYP,TITLE,PARTYP,WMODES
      INTEGER   LOC,NTYP,NJTTYP,NWWTYP,NWMODE
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
C
      INTEGER NVC,MXVC,NC,NN,I
      REAL VC(MXVC)
      CHARACTER*8 CLIST(290)
      EQUIVALENCE (CLIST(1),PARTYP(1))
C
C          Dummy real variables for integers
      REAL VLOOK(MXLOOK+6*MXDKY)
      EQUIVALENCE (VLOOK(1),LOOK(1))
      REAL VNKINF(5)
      EQUIVALENCE (VNKINF(1),NKINF)
      REAL VFORCE(9*MXFORC+1)
      EQUIVALENCE (VFORCE(1),NFORCE)
      REAL VIDVER(5)
      EQUIVALENCE (VIDVER(1),IDVER)
      REAL VEVOLV(4)
      EQUIVALENCE (VEVOLV(1),NEVOLV)
      REAL VITDKY(4)
      EQUIVALENCE (VITDKY(1),ITDKY)
      REAL VIKEYS(12)
      EQUIVALENCE (VIKEYS(1),IKEYS)
      REAL VSTPRT
      EQUIVALENCE (VSTPRT,LSTPRT)
      REAL VNJET(9)
      EQUIVALENCE (VNJET(1),NJET)
      REAL VEVPRT(2)
      EQUIVALENCE (VEVPRT(1),NEVPRT)
      REAL VKINPT(5)
      EQUIVALENCE (VKINPT(1),NKINPT)
      REAL VLOC(100)
      EQUIVALENCE (VLOC(1),LOC(1))
C          Dummy real variables for logicals
      REAL VFLW(13)
      EQUIVALENCE (VFLW(1),FLW)
      REAL VNODCY(6)
      EQUIVALENCE (VNODCY(1),NODCAY)
      REAL VGOQ(3*MXGOQ+135)
      EQUIVALENCE (VGOQ(1),GOQ(1,1))
C
      NC=0
C          DKYTAB
      NN=MXLOOK+6*MXDKY
      CALL MOVLEV(VC(NC+1),VLOOK(1),NN)
      NC=NC+NN
C          DYLIM
      CALL MOVLEV(VC(NC+1),QMIN,24)
      NC=NC+24
C          DYPAR
      CALL MOVLEV(VC(NC+1),VFLW(1),13)
      NC=NC+13
C          EEPAR
      CALL MOVLEV(VC(NC+1),SGMXEE,1)
      NC=NC+1
C          FINAL
      CALL MOVLEV(VC(NC+1),VNKINF(1),5)
      NC=NC+5
C          FORCE
      NN=9*MXFORC+1
      CALL MOVLEV(VC(NC+1),VFORCE(1),NN)
      NC=NC+NN
C          FRGPAR
      CALL MOVLEV(VC(NC+1),PUD,41)
      NC=NC+41
C          HCON
      CALL MOVLEV(VC(NC+1),HMASS,69)
      NC=NC+69
C          IDRUN
      CALL MOVLEV(VC(NC+1),VIDVER(1),5)
      NC=NC+5
C          ISLOOP
      CALL MOVLEV(VC(NC+1),VEVOLV(1),4)
      NC=NC+4
C          ITAPES
      CALL MOVLEV(VC(NC+1),VITDKY(1),4)
      NC=NC+4
C          JETLIM
      CALL MOVLEV(VC(NC+1),PMIN(1),72)
      NC=NC+72
C          KEYS
      CALL MOVLEV(VC(NC+1),VIKEYS(1),12)
      NC=NC+12
      CALL CTXI2C(VC(NC+1),REAC,8)
      NC=NC+8
C          LIMEVL
      CALL MOVLEV(VC(NC+1),ETTHRS,3)
      NC=NC+3
C          LSTPRT
      CALL MOVLEV(VC(NC+1),VSTPRT,1)
      NC=NC+1
C          MBGEN
      NN=4*LIMPOM+8
      CALL MOVLEV(VC(NC+1),POMWT(1),NN)
      NC=NC+NN
C          MBPAR
      CALL MOVLEV(VC(NC+1),PUD0,19)
      NC=NC+19
C          NODCAY
      CALL MOVLEV(VC(NC+1),VNODCY(1),6)
      NC=NC+6
C          PRIMAR
      CALL MOVLEV(VC(NC+1),VNJET(1),9)
      NC=NC+9
C          PRTOUT
      CALL MOVLEV(VC(NC+1),VEVPRT(1),2)
      NC=NC+2
C          PTPAR
      CALL MOVLEV(VC(NC+1),PTFUN1,6)
      NC=NC+6
C          Q1Q2
      CALL MOVLEV(VC(NC+1),VGOQ(1),3*MXGOQ+135)
      NC=NC+3*MXGOQ+135
C          QCDPAR
      CALL MOVLEV(VC(NC+1),ALAM,4)
      NC=NC+4
C          QLMASS
      CALL MOVLEV(VC(NC+1),AMLEP(1),55)
      NC=NC+55
C          TCPAR
      CALL MOVLEV(VC(NC+1),TCMRHO,2)
      NC=NC+2
C          TIMES
      CALL MOVLEV(VC(NC+1),TIME1,2)
      NC=NC+2
C          TOTALS
      CALL MOVLEV(VC(NC+1),VKINPT(1),5)
      NC=NC+5
C          TYPES
      CALL MOVLEV(VC(NC+1),VLOC(1),100)
      NC=NC+100
      DO 100 I=1,290
        CALL CTXI2C(VC(NC+1),CLIST(I),8)
        NC=NC+8
100   CONTINUE
C          WCON
      NN=514+97
      CALL MOVLEV(VC(NC+1),SIN2W,NN)
      NC=NC+NN
C
      NVC=NC
      RETURN
      END
CDECK  ID>, CTXOUT. 
      SUBROUTINE CTXOUT(NVC,VC,MXVC)
C-----------------------------------------------------------------------
C  Purpose:
C          Save the context for an ISAJET job:
C          Save in NVC words of VC all common blocks NOT associated only
C          with a single event. Call this and CTXIN to generate mixed
C          events.
C          PARAMETER (MXVC=20000)
C          REAL    VC(MXVC)
C          ...
C          CALL CTXIN(NVC,VC,MXVC)
C
C          Note that the MSSM common blocks are not saved, so different
C          SUSY runs cannot be mixed.
C
C          Ver. 7.02: Equivalenced dummy variables to avoid mixed
C                     arguments in MOVLEV or multiple EQUIVALENCEd
C                     arguments to CTXIN/CTXOUT.
C
C  Author:
C          F.E. Paige, April 1992
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          LOOK MUST BE DIMENSIONED TO THE MAXIMUM VALUE OF INDEX.
      INTEGER   MXLOOK
      PARAMETER (MXLOOK=500)
      INTEGER   MXDKY
      PARAMETER (MXDKY=3000)
      COMMON/DKYTAB/LOOK(MXLOOK),CBR(MXDKY),MODE(5,MXDKY)
      SAVE /DKYTAB/
      INTEGER   LOOK,MODE
      REAL      CBR
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/DYPAR/FLW,RNU2(3),ANORM(3),QPOW(3),PTPOW(3)
      SAVE /DYPAR/
      LOGICAL FLW
      REAL      RNU2,ANORM,QPOW,PTPOW
      COMMON/EEPAR/SGMXEE,PLEP,PLEM
      SAVE /EEPAR/
      REAL      SGMXEE,PLEP,PLEM
      COMMON/FINAL/NKINF,SIGF,ALUM,ACCEPT,NRECS
      SAVE /FINAL/
      INTEGER   NKINF,NRECS
      REAL      SIGF,ALUM,ACCEPT
      INTEGER   MXFORC
      PARAMETER (MXFORC=40)
      COMMON/FORCE/NFORCE,IFORCE(MXFORC),MFORCE(5,MXFORC)
     $,LOOK2(2,MXFORC),LOOKST(MXFORC)
      SAVE /FORCE/
      INTEGER   NFORCE,IFORCE,MFORCE,LOOK2,LOOKST
      COMMON/FRGPAR/PUD,PBARY,SIGQT,PEND,XGEN(8),PSPIN1(8),
     $PMIX1(3,2),PMIX2(3,2),XGENSS(9)
      SAVE /FRGPAR/
      EQUIVALENCE (PMIX1(1,1),PMIXX1(1))
      EQUIVALENCE (PMIX2(1,1),PMIXX2(1))
      EQUIVALENCE(FRPAR(1),PUD)
      REAL      PUD,PBARY,SIGQT,PEND,XGEN,PSPIN1,PMIX1,PMIX2,XGENSS,
     +          PMIXX1(6),PMIXX2(6),FRPAR(32)
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/ISLOOP/NEVOLV,NFRGMN,IEVOL,IFRG
      SAVE /ISLOOP/
      INTEGER NEVOLV,NFRGMN,IEVOL,IFRG
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON /LIMEVL/ ETTHRS,CONCUT,USELIM
      SAVE /LIMEVL/
      REAL ETTHRS,CONCUT
      LOGICAL USELIM
      COMMON/LSTPRT/LSTPRT
      SAVE /LSTPRT/
      INTEGER   LSTPRT
      INTEGER   LIMPOM
      PARAMETER (LIMPOM=20)
      COMMON/MBGEN/POMWT(LIMPOM),POMGEN(LIMPOM),MNPOM,MXPOM,PDIFFR,
     $NPOM,XBARY(2),DXBARY(2),XPOM(LIMPOM,2)
      SAVE /MBGEN/
      INTEGER   MNPOM,MXPOM,NPOM
      REAL      POMWT,POMGEN,PDIFFR,XBARY,DXBARY,XPOM
      COMMON/MBPAR/PUD0,PJSPN,PISPN,SIGQT0,XGEN0(2),PMIX01(3,2)
     1,PMIX02(3,2),PBARY0
      SAVE /MBPAR/
      REAL      PUD0,PJSPN,PISPN,SIGQT0,XGEN0,PMIX01,PMIX02,PBARY0
      COMMON/NODCAY/NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      SAVE /NODCAY/
      LOGICAL NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/PRTOUT/NEVPRT,NJUMP
      SAVE /PRTOUT/
      INTEGER   NEVPRT,NJUMP
      COMMON/PTPAR/PTFUN1,PTFUN2,PTGEN1,PTGEN2,PTGEN3,SIGMAX
      SAVE /PTPAR/
      REAL      PTFUN1,PTFUN2,PTGEN1,PTGEN2,PTGEN3,SIGMAX
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/QLMASS/AMLEP(100),NQLEP,NMES,NBARY
      SAVE /QLMASS/
      INTEGER   NQLEP,NMES,NBARY
      REAL      AMLEP
      COMMON/TCPAR/TCMRHO,TCGRHO
      SAVE /TCPAR/
      REAL TCMRHO,TCGRHO
      COMMON/TIMES/TIME1,TIME2
      SAVE /TIMES/
      REAL      TIME1,TIME2
      COMMON/TOTALS/NKINPT,NWGEN,NKEEP,SUMWT,WT
      SAVE /TOTALS/
      INTEGER   NKINPT,NWGEN,NKEEP
      REAL      SUMWT,WT
      COMMON/TYPES/LOC(100),NTYP,NJTTYP(3),NWWTYP(2),NWMODE(3)
      COMMON/XTYPES/PARTYP(40),TITLE(10),JETYP(30,3),WWTYP(30,2)
     $,WMODES(30,3)
      SAVE /TYPES/,/XTYPES/
      CHARACTER*8 JETYP,WWTYP,TITLE,PARTYP,WMODES
      INTEGER   LOC,NTYP,NJTTYP,NWWTYP,NWMODE
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
C
      INTEGER NVC,MXVC,NC,NN,I
      REAL VC(MXVC)
      CHARACTER*8 CLIST(290)
      EQUIVALENCE (CLIST(1),PARTYP(1))
C
C          Dummy real variables for integers
      REAL VLOOK(MXLOOK+6*MXDKY)
      EQUIVALENCE (VLOOK(1),LOOK(1))
      REAL VNKINF(5)
      EQUIVALENCE (VNKINF(1),NKINF)
      REAL VFORCE(9*MXFORC+1)
      EQUIVALENCE (VFORCE(1),NFORCE)
      REAL VIDVER(5)
      EQUIVALENCE (VIDVER(1),IDVER)
      REAL VEVOLV(4)
      EQUIVALENCE (VEVOLV(1),NEVOLV)
      REAL VITDKY(4)
      EQUIVALENCE (VITDKY(1),ITDKY)
      REAL VIKEYS(12)
      EQUIVALENCE (VIKEYS(1),IKEYS)
      REAL VSTPRT
      EQUIVALENCE (VSTPRT,LSTPRT)
      REAL VNJET(9)
      EQUIVALENCE (VNJET(1),NJET)
      REAL VEVPRT(2)
      EQUIVALENCE (VEVPRT(1),NEVPRT)
      REAL VKINPT(5)
      EQUIVALENCE (VKINPT(1),NKINPT)
      REAL VLOC(100)
      EQUIVALENCE (VLOC(1),LOC(1))
C          Dummy real variables for logicals
      REAL VFLW(13)
      EQUIVALENCE (VFLW(1),FLW)
      REAL VNODCY(6)
      EQUIVALENCE (VNODCY(1),NODCAY)
      REAL VGOQ(3*MXGOQ+135)
      EQUIVALENCE (VGOQ(1),GOQ(1,1))
C
      NC=0
C          DKYTAB
      NN=MXLOOK+6*MXDKY
      CALL MOVLEV(VLOOK(1),VC(NC+1),NN)
      NC=NC+NN
C          DYLIM
      CALL MOVLEV(QMIN,VC(NC+1),24)
      NC=NC+24
C          DYPAR
      CALL MOVLEV(VFLW(1),VC(NC+1),13)
      NC=NC+13
C          EEPAR
      CALL MOVLEV(SGMXEE,VC(NC+1),1)
      NC=NC+1
C          FINAL
      CALL MOVLEV(VNKINF(1),VC(NC+1),5)
      NC=NC+5
C          FORCE
      NN=9*MXFORC+1
      CALL MOVLEV(VFORCE(1),VC(NC+1),NN)
      NC=NC+NN
C          FRGPAR
      CALL MOVLEV(PUD,VC(NC+1),41)
      NC=NC+41
C          HCON
      CALL MOVLEV(HMASS,VC(NC+1),69)
      NC=NC+69
C          IDRUN
      CALL MOVLEV(VIDVER(1),VC(NC+1),5)
      NC=NC+5
C          ISLOOP
      CALL MOVLEV(VEVOLV(1),VC(NC+1),4)
      NC=NC+4
C          ITAPES
      CALL MOVLEV(VITDKY(1),VC(NC+1),4)
      NC=NC+4
C          JETLIM
      CALL MOVLEV(PMIN(1),VC(NC+1),72)
      NC=NC+72
C          KEYS
      CALL MOVLEV(VIKEYS(1),VC(NC+1),12)
      NC=NC+12
      CALL CTXC2I(REAC,VC(NC+1),8)
      NC=NC+8
C          LIMEVL
      CALL MOVLEV(ETTHRS,VC(NC+1),3)
      NC=NC+3
C          LSTPRT
      CALL MOVLEV(VSTPRT,VC(NC+1),1)
      NC=NC+1
C          MBGEN
      NN=4*LIMPOM+8
      CALL MOVLEV(POMWT(1),VC(NC+1),NN)
      NC=NC+NN
C          MBPAR
      CALL MOVLEV(PUD0,VC(NC+1),19)
      NC=NC+19
C          NODCAY
      CALL MOVLEV(VNODCY(1),VC(NC+1),6)
      NC=NC+6
C          PRIMAR
      CALL MOVLEV(VNJET(1),VC(NC+1),9)
      NC=NC+9
C          PRTOUT
      CALL MOVLEV(VEVPRT(1),VC(NC+1),2)
      NC=NC+2
C          PTPAR
      CALL MOVLEV(PTFUN1,VC(NC+1),6)
      NC=NC+6
C          Q1Q2
      CALL MOVLEV(VGOQ(1),VC(NC+1),3*MXGOQ+135)
      NC=NC+3*MXGOQ+135
C          QCDPAR
      CALL MOVLEV(ALAM,VC(NC+1),4)
      NC=NC+4
C          QLMASS
      CALL MOVLEV(AMLEP(1),VC(NC+1),55)
      NC=NC+55
C          TCPAR
      CALL MOVLEV(TCMRHO,VC(NC+1),2)
      NC=NC+2
C          TIMES
      CALL MOVLEV(TIME1,VC(NC+1),2)
      NC=NC+2
C          TOTALS
      CALL MOVLEV(VKINPT(1),VC(NC+1),5)
      NC=NC+5
C          TYPES
      CALL MOVLEV(VLOC(1),VC(NC+1),100)
      NC=NC+100
      DO 100 I=1,290
        CALL CTXC2I(CLIST(I),VC(NC+1),8)
        NC=NC+8
100   CONTINUE
C          WCON
      NN=514+97
      CALL MOVLEV(SIN2W,VC(NC+1),NN)
      NC=NC+NN
C
      IF(NC.LE.MXVC) THEN
        NVC=NC
        RETURN
      ELSE
        WRITE(ITLIS,9000) NC
9000    FORMAT(//' ERROR IN CTXOUT, NC = ',I5)
        STOP99
      ENDIF
      END
CDECK  ID>, DATIME. 
      SUBROUTINE DATIME(ID,IT)
C          CALL VAX DATE AND TIME.
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      CHARACTER*8 BUF
      CALL IDATE(IMON,IDAY,IYR)
      CALL TIME(BUF)
      ID=10000*IYR+100*IMON+IDAY
      READ(BUF,'(I2,1X,I2,1X,I2)') K1,K2,K3
      IT=10000*K1+100*K2+K3
      RETURN
      END
CDECK  ID>, DBLPCM. 
      FUNCTION DBLPCM(A,B,C)
C          Calculate com momentum for A-->B+C with double precision.
C          Needed to fix bug on 32-bit machines at high energy.
C          Ver. 7.27: Rewrite order and then take abs value to be sure.
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      DOUBLE PRECISION DA,DB,DC,DVAL
C          Convert to double precision
      DA=A
      DB=B
      DC=C
      DVAL=(DA-(DB+DC))*(DA+(DB+DC))*(DA-(DB-DC))*(DA+(DB-DC))
C          Convert back to single precision
      VAL=DVAL
      DBLPCM=SQRT(ABS(VAL))/(2.*A)
      RETURN
      END
CDECK  ID>, DBLVEC. 
      SUBROUTINE DBLVEC(P,DP)
C
C          Calculate double precision vector DP for 5-vector P.
C          Exact components are 1,2,5 and larger of +,-
C          Ver 6.44: Always use this, even if IF=SINGLE.
C
      IMPLICIT NONE
      REAL P(5)
      DOUBLE PRECISION DP(5),DPPL,DPMN
      INTEGER K
C
      DO 100 K=1,5
100   DP(K)=P(K)
      IF(DP(4)+ABS(DP(3)).EQ.0.) RETURN
      IF(DP(3).GT.0.) THEN
        DPPL=DP(4)+DP(3)
        DPMN=(DP(1)**2+DP(2)**2+DP(5)**2)/DPPL
      ELSE
        DPMN=DP(4)-DP(3)
        DPPL=(DP(1)**2+DP(2)**2+DP(5)**2)/DPMN
      ENDIF
      DP(3)=0.5D0*(DPPL-DPMN)
      DP(4)=0.5D0*(DPPL+DPMN)
      RETURN
      END
CDECK  ID>, DBOOST. 
      SUBROUTINE DBOOST(ISIGN,F,P)
C
C          DOUBLE PRECISION BOOST OF 5-VECTOR P BY 5-VECTOR F WITH SIGN
C          OF ISIGN. EXACT COMPONENTS ARE 1,2,5 AND LARGER OF +,-
C
      DIMENSION F(5),P(5)
      DOUBLE PRECISION DF(5),DFPL,DFMN,DP(5),DPPL,DPMN,DBP,DSIGN
C          COPY TO DOUBLE PRECISION
      DO 100 K=1,5
      DF(K)=F(K)
100   DP(K)=P(K)
      IF(ISIGN.GT.0) THEN
        DSIGN=1.D0
      ELSE
        DSIGN=-1.D0
      ENDIF
C          PUT ON DOUBLE PRECISION SHELL
      CALL DBLVEC(P,DP)
C          BOOST
      DBP=0.D0
      DO 110 K=1,3
110   DBP=DBP+DF(K)*DP(K)
      DBP=DBP/DF(5)
      DO 120 K=1,3
120   DP(K)=DP(K)+DSIGN*DF(K)*DP(4)/DF(5)+DF(K)*DBP/(DF(4)+DF(5))
      DP(4)=DF(4)*DP(4)/DF(5)+DSIGN*DBP
C          COPY BACK
      DO 130 K=1,4
130   P(K)=DP(K)
      RETURN
      END
CDECK  ID>, DECAY.  
      SUBROUTINE DECAY(IP)
C
C          Decay particle IP from /PARTCL/ using /DKYTAB/ branching
C          ratios and add decay products to /PARTCL/ with IORIG=IP.
C          Forced decay modes are flagged by LOOK<0.
C
C          Auxiliary routines:
C          DECME: Calculate and test matrix element for special decays.
C          DECJET: Hadronize partons from decay.
C
C          Matrix element for Dalitz decays and W mass for TP -> W BT
C          are generated explicitly. W width is included.
C
C          Requirements for decay modes:
C          (1) For Dalitz decays, particle 1 must be GM.
C          (2) For V-A quark or lepton decays, particles 1 and 2 must
C              be from (virtual) W.
C          (3) For any decay into quarks, they must appear last.
C
C          VEr 7.30: Decay top quark rather than hadron.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
C          LOOK MUST BE DIMENSIONED TO THE MAXIMUM VALUE OF INDEX.
      INTEGER   MXLOOK
      PARAMETER (MXLOOK=500)
      INTEGER   MXDKY
      PARAMETER (MXDKY=3000)
      COMMON/DKYTAB/LOOK(MXLOOK),CBR(MXDKY),MODE(5,MXDKY)
      SAVE /DKYTAB/
      INTEGER   LOOK,MODE
      REAL      CBR
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      INTEGER   MXFORC
      PARAMETER (MXFORC=40)
      COMMON/FORCE/NFORCE,IFORCE(MXFORC),MFORCE(5,MXFORC)
     $,LOOK2(2,MXFORC),LOOKST(MXFORC)
      SAVE /FORCE/
      INTEGER   NFORCE,IFORCE,MFORCE,LOOK2,LOOKST
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C
      REAL PGEN(5,5),RND(5),U(3),BETA(3),IDQK(3),ROT(3,3),PSAVE(3)
     1,REDUCE(5),WPROP,Z,TRY,RANF,AMASS,TWOME,CHARGE
      REAL PSUM(5),POLD(4),PNEW(4),SUM,WTMAX,SUM1,SUM2
      REAL PREST(4,6),PWREST(5),BETAW(3),DOT,PCM
      REAL AMEE,REE,WTEE,SWAP,RNEW,WT,QCM,PHI,S12,S12MAX,GAMMAW,BP
      REAL PJET,CTHQK,STHQK,CPHIQK,SPHIQK,SUMQ,A,B,C,GAMMA
      REAL SMAX,SMIN,SVAL,TANMAX,TANMIN,TANVAL
      LOGICAL WDECAY,DECME,DECJET
      INTEGER IDLV1,IFL1,IFL2,IFL3,JSPIN,INDEX,IPOINT,ID1,I1,I2,I3
      INTEGER NADD,NSTART,NEW,NADD1,J,IP,I,IDABS(5),NEXT,NPLTV1
      INTEGER JJ1,II,K1,K,NJSAVE,NJSAV1,NJSAV2,NJ1,NPRTN,KK,NPRTN1
      INTEGER IFAIL,JSAVE,JETIP,JET,NJADD,NPTLV1,IDANTI,NPASS,NPASS1
      REAL DBLPCM
      DATA REDUCE/1.,1.,2.,5.,15./
      DATA PSUM/5*0./
      DATA TWOME/1.022006E-3/
      DATA PREST/24*0./
C
C          Function definitions.
C          Use double precision for PCM on 32-bit machines
      PCM(A,B,C)=DBLPCM(A,B,C)
      DOT(I1,I2)=PREST(4,I1)*PREST(4,I2)-PREST(1,I1)*PREST(1,I2)
     $-PREST(2,I1)*PREST(2,I2)-PREST(3,I1)*PREST(3,I2)
C          Charged W propagator.
      WPROP(Z)=(Z-WMASS(2)**2)**2+(WMASS(2)*WGAM(2))**2
C
C          Select decay mode. Note IDENT(NPTCL+1)...IDENT(NPTCL+5)
C          are always defined even if zero.
C
      IF(IDCAY(IP).NE.0) RETURN
      IDLV1=IDENT(IP)
      CALL FLAVOR(IDLV1,IFL1,IFL2,IFL3,JSPIN,INDEX)
C          FLAVOR returns 0 for quark, but want IFL3=6 for top
      IF(IABS(IDLV1).LT.10) IFL3=IDLV1
      NPASS=0
      NPASS1=0
1     CONTINUE
      NPASS=NPASS+1
      IF(NPASS.GT.NTRIES) GO TO 9998
      WDECAY=.FALSE.
      IPOINT=LOOK(INDEX)
      IF(IPOINT.EQ.0) RETURN
C          IPOINT<0 flags a forced decay.
      IF(IPOINT.LT.0) THEN
        I=1
        IF(IDENT(IP).LT.0) I=2
        IPOINT=LOOK2(I,IABS(IPOINT))
      ENDIF
C          Select mode.
      TRY=RANF()
      IPOINT=IPOINT-1
100   IPOINT=IPOINT+1
      IF(TRY.GT.CBR(IPOINT)) GO TO 100
      NADD=0
      SUM=0.
      NSTART=NPTCL+1
      IF(NPTCL+5.GT.MXPTCL) GO TO 9999
C          Set up masses and IDENT codes.
      DO 110 I=1,5
        NEW=NPTCL+I
        IDENT(NEW)=MODE(I,IPOINT)
        IDABS(I)=IABS(IDENT(NEW))
        IF(MODE(I,IPOINT).EQ.0) GO TO 110
        NADD=NADD+1
        IDLV1=IDENT(NEW)
        PPTCL(5,NEW)=AMASS(IDLV1)
        SUM=SUM+PPTCL(5,NEW)
110   CONTINUE
      NADD1=NADD-1
      DO 120 J=1,5
        PGEN(J,1)=PPTCL(J,IP)
120   CONTINUE
      PGEN(5,NADD)=PPTCL(5,NPTCL+NADD)
C
C          1-body and 2-body decays.
C
      IF(NADD.EQ.1) THEN
        DO 130 J=1,5
          PPTCL(J,NPTCL+1)=PPTCL(J,IP)
130     CONTINUE
        GO TO 600
      ELSEIF(NADD.EQ.2) THEN
        GO TO 400
      ENDIF
C
C          Calculate maximum phase-space weight.
C
      WTMAX=1./REDUCE(NADD)
      SUM1=PGEN(5,1)
      SUM2=SUM-PPTCL(5,NPTCL+1)
      DO 140 I=1,NADD1
        WTMAX=WTMAX*PCM(SUM1,SUM2,PPTCL(5,NPTCL+I))
        SUM1=SUM1-PPTCL(5,NPTCL+I)
        SUM2=SUM2-PPTCL(5,NPTCL+I+1)
140   CONTINUE
C
C          Generate PGEN masses for special decays ...
C
      NPASS1=0
200   CONTINUE
      NPASS1=NPASS1+1
      IF(NPASS1.GT.NTRIES) GO TO 9998
      WDECAY=.FALSE.
C          Kroll-Wada distribution for Dalitz decays.
      IF(IDENT(IP).EQ.110.OR.IDENT(IP).EQ.220.OR.IDENT(IP).EQ.ISZ1)
     $THEN
        IF((IDABS(1).EQ.10.OR.IDABS(1).EQ.ISGRAV).AND.IDABS(2).EQ.12
     $  .AND.IDABS(3).EQ.12) THEN
210       AMEE=TWOME*(PPTCL(5,IP)/TWOME)**RANF()
          REE=(TWOME/AMEE)**2
          WTEE=(1.-(AMEE/PPTCL(5,IP))**2)**3*SQRT(1.-REE)*(1.+.5*REE)
          IF(WTEE.LT.RANF()) GO TO 210
          PGEN(5,2)=AMEE
          GO TO 400
        ENDIF
      ENDIF
C          Generate mass for TP -> W BT with Breit-Wigner.
C          W couples to 1+2 so swap 1<->3. Then m2+m3 < m < m0-m1.
C          V-A matrix element is in DECME.
      IF(IABS(IFL3).GE.6.AND.NADD.EQ.3) THEN
        IF((IDABS(3).LT.10.OR.MOD(IDABS(3),100).EQ.0)) THEN
          WDECAY=.TRUE.
          SWAP=PPTCL(5,NPTCL+1)
          PPTCL(5,NPTCL+1)=PPTCL(5,NPTCL+3)
          PPTCL(5,NPTCL+3)=SWAP
          SMAX=(PPTCL(5,IP)-PPTCL(5,NPTCL+1))**2
          SMIN=(PPTCL(5,NPTCL+2)+PPTCL(5,NPTCL+3))**2
          TANMAX=ATAN((SMAX-WMASS(2)**2)/(WMASS(2)*WGAM(2)))
          TANMIN=ATAN((SMIN-WMASS(2)**2)/(WMASS(2)*WGAM(2)))
220       TANVAL=RANF()*(TANMAX-TANMIN)+TANMIN
          SVAL=WMASS(2)**2+WMASS(2)*WGAM(2)*TAN(TANVAL)
          IF(SVAL.LT.SMIN.OR.SVAL.GT.SMAX) GO TO 220
          PGEN(5,2)=SQRT(SVAL)
          PGEN(5,3)=PPTCL(5,NPTCL+3)
          GO TO 400
        ENDIF
      ENDIF
C
C          ... or generate uniform NADD-body phase space.
C
300   CONTINUE
      RND(1)=1.
      DO 310 I=2,NADD1
        RNEW=RANF()
        I1=I-1
        DO 320 JJ1=1,I1
          J=I-JJ1
          JSAVE=J+1
          IF(RNEW.LE.RND(J)) GO TO 310
          RND(JSAVE)=RND(J)
320     CONTINUE
310   RND(JSAVE)=RNEW
      RND(NADD)=0.
      WT=1.
      SUM1=SUM
      DO 330 I=2,NADD
        SUM1=SUM1-PPTCL(5,NPTCL+I-1)
        PGEN(5,I)=SUM1+RND(I)*(PGEN(5,1)-SUM)
        IF(PGEN(5,I-1).LE.PGEN(5,I)+PPTCL(5,NPTCL+I-1)) GO TO 300
        WT=WT*PCM(PGEN(5,I-1),PGEN(5,I),PPTCL(5,NPTCL+I-1))
330   CONTINUE
      IF(WT.LT.RANF()*WTMAX) GO TO 300
C
C          Carry out two-body decays in PGEN frames.
C
400   CONTINUE
      DO 410 I=1,NADD1
        QCM=PCM(PGEN(5,I),PGEN(5,I+1),PPTCL(5,NPTCL+I))
        U(3)=2.*RANF()-1.
        PHI=2.*PI*RANF()
        U(1)=SQRT(1.-U(3)**2)*COS(PHI)
        U(2)=SQRT(1.-U(3)**2)*SIN(PHI)
        DO 420 J=1,3
          PPTCL(J,NPTCL+I)=QCM*U(J)
          PGEN(J,I+1)=-PPTCL(J,NPTCL+I)
420     CONTINUE
        PPTCL(4,NPTCL+I)=SQRT(QCM**2+PPTCL(5,NPTCL+I)**2)
        PGEN(4,I+1)=SQRT(QCM**2+PGEN(5,I+1)**2)
410   CONTINUE
      DO 430 J=1,4
        PPTCL(J,NPTCL+NADD)=PGEN(J,NADD)
430   CONTINUE
C
C          Boost PGEN frames to lab frame, saving momenta in rest frame.
C
      DO 500 II=1,NADD1
        I=NADD-II
        DO 510 J=1,3
          BETA(J)=PGEN(J,I)/PGEN(4,I)
510     CONTINUE
        GAMMA=PGEN(4,I)/PGEN(5,I)
        DO 520 K=I,NADD
          K1=NPTCL+K
          BP=BETA(1)*PPTCL(1,K1)+BETA(2)*PPTCL(2,K1)+BETA(3)*PPTCL(3,K1)
          DO 530 J=1,3
            PREST(J,K)=PPTCL(J,K1)
            PPTCL(J,K1)=PPTCL(J,K1)+GAMMA*BETA(J)*(PPTCL(4,K1)
     $      +BP*GAMMA/(GAMMA+1.))
530       CONTINUE
          PREST(4,K)=PPTCL(4,K1)
          PPTCL(4,K1)=GAMMA*(PPTCL(4,K1)+BP)
520     CONTINUE
500   CONTINUE
C
C          Swap back 1<->3 for W decay
      IF(WDECAY) THEN
        DO 540 K=1,5
          SWAP=PPTCL(K,NPTCL+1)
          PPTCL(K,NPTCL+1)=PPTCL(K,NPTCL+3)
          PPTCL(K,NPTCL+3)=SWAP
540     CONTINUE
        PGEN(5,3)=PPTCL(5,NPTCL+3)
        DO 550 K=1,4
          SWAP=PREST(K,1)
          PREST(K,1)=PREST(K,3)
          PREST(K,3)=SWAP
550     CONTINUE
      ENDIF
C
C          Check matrix elements.
C
      IF(.NOT.DECME(IP,NADD,IDABS,PREST)) GO TO 200
C
C          Swap particles and antiparticles if IDENT(IP)<0
C          Note forced modes for antiparticles are conjugated in table.
C
600   CONTINUE
      IF(IDENT(IP).LT.0.AND.IDENT(IP).NE.-20) THEN
          DO 610 I=1,NADD
            ID1=IDENT(NPTCL+I)
            IDENT(NPTCL+I)=IDANTI(ID1)
610       CONTINUE
      ENDIF
C
C          Set IORIG and IDCAY.
C
      NPTCL=NPTCL+NADD
      IDCAY(IP)=IPACK*NSTART+NPTCL
      JETIP=IABS(IORIG(IP))/IPACK
      DO 620 I=NSTART,NPTCL
        IORIG(I)=IP
        IDCAY(I)=0
620   CONTINUE
C
C          Evolve and hadronize partons. If it fails, start over.
C
      IF(IDABS(NADD).LT.10.OR.MOD(IDENT(NPTCL),100).EQ.0) THEN
        IF(.NOT.DECJET(IP,NADD,IDABS,PREST,WDECAY,BETA,GAMMA))
     $  GO TO 1
      ENDIF
C
      RETURN
C
C          Error messages.
C
9999  CALL PRTEVT(0)
      WRITE(ITLIS,99990) NPTCL
99990 FORMAT(//5X,'ERROR IN DECAY...NPTCL > ',I6)
      RETURN
9998  CALL PRTEVT(0)
      WRITE(ITLIS,99980) IP
99980 FORMAT(//5X,'ERROR IN DECAY...NO DECAY FOUND FOR PARTICLE',I6)
      RETURN
      END
CDECK  ID>, DECJET. 
      LOGICAL FUNCTION DECJET(IP,NADD,IDABS,PREST,WDECAY,BETA,GAMMA)
C
C          Auxiliary routine for DECAY. Evolve and hadronize partons.
C          Check conservation laws. Return TRUE if OK, FALSE otherwise.
C
C          IP = particle to be decayed.
C          NADD = number of products (NPTCL+1, ..., NPTCL+NADD).
C          IDABS = absolute values of decay IDENT's.
C          PREST = 4-momenta in rest frame.
C          WDECAY = logical flag for real W decay.
C          BETA,GAMMA = boost parameters.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
C          LOOK MUST BE DIMENSIONED TO THE MAXIMUM VALUE OF INDEX.
      INTEGER   MXLOOK
      PARAMETER (MXLOOK=500)
      INTEGER   MXDKY
      PARAMETER (MXDKY=3000)
      COMMON/DKYTAB/LOOK(MXLOOK),CBR(MXDKY),MODE(5,MXDKY)
      SAVE /DKYTAB/
      INTEGER   LOOK,MODE
      REAL      CBR
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
C
      REAL PGEN(5,5),RND(5),U(3),BETA(3),IDQK(3),ROT(3,3),PSAVE(3)
     1,REDUCE(5),WPROP,Z,TRY,RANF,AMASS,TWOME,CHARGE
      REAL PSUM(5),POLD(4),PNEW(4),SUM,WTMAX,SUM1,SUM2
      REAL PREST(4,6),PWREST(5),BETAW(3),DOT,PCM
      REAL AMEE,REE,WTEE,SWAP,RNEW,WT,QCM,PHI,S12,S12MAX,GAMMAW,BP
      REAL PJET,CTHQK,STHQK,CPHIQK,SPHIQK,SUMQ,A,B,C,GAMMA
      REAL CHARGW
      LOGICAL WDECAY
      INTEGER IDLV1,IFL1,IFL2,IFL3,JSPIN,INDEX,IPOINT,ID1,I1,I2,I3
      INTEGER NADD,NSTART,NEW,NADD1,J,IP,I,IDABS(5),NEXT
      INTEGER JJ1,II,K1,K,NJSAVE,NJSAV1,NJSAV2,NJ1,NPRTN,KK,NHDRN1
      INTEGER IFAIL,JSAVE,JETIP,JET,NJADD,NPTLV1,IDANTI,NPJET(5)
      INTEGER NHDRN,NPJET3,NPTCLW,NPBEG(5)
C
C          Copy decay products into /JETSET/ and do QCD evolution.
C
      IF(NJSET+NADD.GT.MXJSET) GO TO 9998
      NJSAVE=NJSET
      NSTART=NPTCL-NADD+1
      NPTCL=NSTART-1
      DO 100 I=1,NADD
        NJSET=NJSET+1
        DO 110 K=1,4
110     PJSET(K,NJSET)=PREST(K,I)
        PJSET(5,NJSET)=PPTCL(5,NPTCL+I)
        JORIG(NJSET)=JPACK*I
        JTYPE(NJSET)=IDENT(NPTCL+I)
        JDCAY(NJSET)=0
        JMATCH(NJSET)=JPACK*(NJSAVE+1)+NJSAVE+NADD
100   CONTINUE
C
C          For heavy quarks match 1+2 and 3+(1+2). Boost 1+2 to rest.
C
      IF(WDECAY) THEN
        JMATCH(NJSAVE+1)=NJSAVE+2
        JMATCH(NJSAVE+2)=NJSAVE+1
        NJSET=NJSET+1
        DO 120 K=1,4
          PWREST(K)=PJSET(K,NJSAVE+1)+PJSET(K,NJSAVE+2)
          PJSET(K,NJSET)=PWREST(K)
120     CONTINUE
        PWREST(5)=SQRT(PWREST(4)**2-PWREST(1)**2-PWREST(2)**2
     $  -PWREST(3)**2)
        PJSET(5,NJSET)=PWREST(5)
        JMATCH(NJSAVE+3)=NJSAVE+4
        JMATCH(NJSAVE+4)=NJSAVE+3
        JORIG(NJSAVE+4)=-1
        IDLV1=JTYPE(NJSAVE+1)
        CHARGW=CHARGE(IDLV1)
        IDLV1=JTYPE(NJSAVE+2)
        CHARGW=CHARGW+CHARGE(IDLV1)
        JTYPE(NJSAVE+4)=80*SIGN(1.,CHARGW)
        JDCAY(NJSAVE+4)=0
C          Boost W vectors to rest.
        DO 130 K=1,3
130     BETAW(K)=PWREST(K)/PWREST(4)
        GAMMAW=PWREST(4)/PWREST(5)
        NJSAV1=NJSAVE+1
        NJSAV2=NJSAVE+2
        DO 140 J=NJSAV1,NJSAV2
          BP=BETAW(1)*PJSET(1,J)+BETAW(2)*PJSET(2,J)+BETAW(3)*PJSET(3,J)
          DO 141 K=1,3
141       PJSET(K,J)=PJSET(K,J)-GAMMAW*BETAW(K)*(PJSET(4,J)
     $    -BP*GAMMAW/(GAMMAW+1.))
          PJSET(4,J)=GAMMAW*(PJSET(4,J)-BP)
140     CONTINUE
      ENDIF
C
C          Do evolution and save new W momentum. Start from parent
C          mass or NADD*energy.
      NJSAV1=NJSAVE+1
      DO 150 J=NJSAV1,NJSET
        IF(IABS(JTYPE(J)).LT.10.OR.MOD(JTYPE(J),100).EQ.0) THEN
          JDCAY(J)=-1
          PJSET(5,J)=AMIN1(PPTCL(5,IP),NADD*PJSET(4,J))
        ENDIF
150   CONTINUE
C
      CALL QCDJET(NJSAVE+1)
C
      IF(WDECAY) THEN
        PWREST(4)=PJSET(4,NJSAVE+4)
        GAMMAW=PWREST(4)/PWREST(5)
        DO 200 K=1,3
          PWREST(K)=PJSET(K,NJSAVE+4)
          BETAW(K)=PWREST(K)/PWREST(4)
200     CONTINUE
      ENDIF
C
C          Put final partons in particle table - temporary IORIG.
C          Also include virtual or real W momentum for quark decays.
C
      NJ1=NJSAVE+1
      IF(WDECAY) THEN
C          Real or virtual W.
        NPTCL=NPTCL+1
        NPTCLW=NPTCL
        DO 210 K=1,5
210     PPTCL(K,NPTCL)=PJSET(K,NJSAVE+4)
        IORIG(NPTCL)=IP
        IDENT(NPTCL)=JTYPE(NJSAVE+4)
        IDCAY(NPTCL)=0
C          Jet 3
        NPBEG(3)=NPTCL+1
        DO 220 J=NJ1,NJSET
          IF(JDCAY(J).NE.0) GO TO 220
          IF(JORIG(J)/JPACK.NE.3) GO TO 220
          NPTCL=NPTCL+1
          DO 221 K=1,5
221       PPTCL(K,NPTCL)=PJSET(K,J)
          IORIG(NPTCL)=3*IPACK+IP
          IDENT(NPTCL)=JTYPE(J)
          IDCAY(NPTCL)=0
220     CONTINUE
C          Jets 1 and 2
        NPJET3=NPTCL
        DO 230 JET=1,2
          NPBEG(JET)=NPTCL+1
          DO 240 J=NJ1,NJSET
            IF(JDCAY(J).NE.0) GO TO 240
            IF(JORIG(J)/JPACK.NE.JET) GO TO 240
            NPTCL=NPTCL+1
            BP=BETAW(1)*PJSET(1,J)+BETAW(2)*PJSET(2,J)
     $      +BETAW(3)*PJSET(3,J)
            DO 241 K=1,3
241         PPTCL(K,NPTCL)=PJSET(K,J)+GAMMAW*BETAW(K)*(PJSET(4,J)
     $      +BP*GAMMAW/(GAMMAW+1.))
            PPTCL(4,NPTCL)=GAMMAW*(PJSET(4,J)+BP)
            PPTCL(5,NPTCL)=PJSET(5,J)
            IORIG(NPTCL)=IPACK*(JORIG(J)/JPACK)+NPTCLW
            IDENT(NPTCL)=JTYPE(J)
            IDCAY(NPTCL)=0
240       CONTINUE
230     CONTINUE
C          Quark decays to W plus jet 3; then W decays.
        IDCAY(IP)=IPACK*NPTCLW+NPJET3
        IDCAY(NPTCLW)=IPACK*(NPJET3+1)+NPTCL
      ELSE
C          Not quark decay, so just copy partons.
        DO 250 JET=1,NADD
          NPBEG(JET)=NPTCL+1
          DO 260 J=NJ1,NJSET
            IF(JDCAY(J).NE.0) GO TO 260
            IF(JORIG(J)/JPACK.NE.JET) GO TO 260
            NPTCL=NPTCL+1
            DO 261 K=1,5
261         PPTCL(K,NPTCL)=PJSET(K,J)
            IORIG(NPTCL)=IPACK*(JORIG(J)/JPACK)+IP
            IDENT(NPTCL)=JTYPE(J)
            IDCAY(NPTCL)=0
260       CONTINUE
250     CONTINUE
        IDCAY(IP)=NSTART*IPACK+NPTCL
      ENDIF
      NHDRN=NPTCL
C
C          Hadronize quarks and rotate to proper angles.
C
      DO 300 JET=1,NADD
        NPRTN=NPBEG(JET)-1
        DO 310 I=NJ1,NJSET
          IF(JDCAY(I).NE.0) GO TO 310
          IF(JORIG(I)/JPACK.NE.JET) GO TO 310
          NPRTN=NPRTN+1
          IF(IABS(JTYPE(I)).GE.10.AND.MOD(JTYPE(I),100).NE.0)
     $    GO TO 330
C
C          Fragment parton:
          NEXT=NPTCL+1
          PJET=SQRT(PJSET(1,I)**2+PJSET(2,I)**2+PJSET(3,I)**2)
          CTHQK=PJSET(3,I)/PJET
          STHQK=SQRT(1.-CTHQK**2)
          CPHIQK=PJSET(1,I)/(PJET*STHQK)
          SPHIQK=PJSET(2,I)/(PJET*STHQK)
          CALL JETGEN(I)
          IF(NEXT.GT.NPTCL) GO TO 310
          ROT(1,1)=CPHIQK*CTHQK
          ROT(2,1)=SPHIQK*CTHQK
          ROT(3,1)=-STHQK
          ROT(1,2)=-SPHIQK
          ROT(2,2)=CPHIQK
          ROT(3,2)=0.
          ROT(1,3)=CPHIQK*STHQK
          ROT(2,3)=SPHIQK*STHQK
          ROT(3,3)=CTHQK
C
          DO 320 II=NEXT,NPTCL
            DO 321 K=1,3
              PSAVE(K)=PPTCL(K,II)
              PPTCL(K,II)=0.
321         CONTINUE
            DO 322 K=1,3
            DO 322 KK=1,3
322         PPTCL(K,II)=PPTCL(K,II)+ROT(K,KK)*PSAVE(KK)
            IORIG(II)=IPACK*JET+NPRTN
            IDCAY(II)=0
320       CONTINUE
          IDCAY(NPRTN)=NEXT*IPACK+NPTCL
          GO TO 310
C
C          or add lepton:
330       NPTCL=NPTCL+1
          DO 331 K=1,5
331       PPTCL(K,NPTCL)=PJSET(K,I)
          IORIG(NPTCL)=IPACK*JET+NPRTN
          IDENT(NPTCL)=JTYPE(I)
          IDCAY(NPTCL)=0
          IDCAY(NPRTN)=NPTCL*IPACK+NPTCL
310     CONTINUE
        NPJET(JET)=NPTCL
300   CONTINUE
C
C          Reset NJSET so decay jets do not appear in /JETSET/
      NJADD=NJSET
      NJSET=NJSAVE
C
C          Check for at least two particles
      IF(NPTCL.LT.NHDRN+2) THEN
        NPTCL=NSTART-1
        DECJET=.FALSE.
        RETURN
      ENDIF
C
C          Conserve charge
C
      SUMQ=0.
      NHDRN1=NHDRN+1
      DO 400 I=NHDRN1,NPTCL
        IDLV1=IDENT(I)
        SUMQ=SUMQ+CHARGE(IDLV1)
400   CONTINUE
      IDLV1=IDENT(IP)
      SUMQ=SUMQ-CHARGE(IDLV1)
C
      IF(SUMQ.EQ.0.) GO TO 500
C
C          Charge wrong--fix it by swapping UP and DN quarks.
      DO 410 I=NHDRN1,NPTCL
        ID1=IDENT(I)
        IF(IABS(ID1).GT.1000) GO TO 410
        I1=MOD(IABS(ID1)/100,10)
        I2=MOD(IABS(ID1)/10,10)
        I3=MOD(IABS(ID1),10)
        IF(I1.EQ.1.AND.I2.GT.2.AND.SUMQ*ID1.GT.0.) THEN
          IDENT(I)=ISIGN(200+10*I2+I3,ID1)
        ELSEIF(I1.EQ.2.AND.I2.GT.2.AND.SUMQ*ID1.LT.0.) THEN
          IDENT(I)=ISIGN(100+10*I2+I3,ID1)
        ELSEIF(I1.EQ.1.AND.I2.EQ.2.AND.SUMQ*ID1.GT.0.) THEN
          IDENT(I)=110+I3
        ELSEIF(I1.EQ.1.AND.I2.EQ.1) THEN
          IDENT(I)=(120+I3)*(-SIGN(1.,SUMQ))
        ELSE
          GO TO 410
        ENDIF
        SUMQ=SIGN(ABS(SUMQ)-1.,SUMQ)
        IDLV1=IDENT(I)
        PPTCL(5,I)=AMASS(IDLV1)
        PPTCL(4,I)=SQRT(PPTCL(1,I)**2+PPTCL(2,I)**2+PPTCL(3,I)**2
     $  +PPTCL(5,I)**2)
C          Sum cannot vanish for fractionally charged initial particle.
        IF(ABS(SUMQ).LT.1.) GO TO 500
410   CONTINUE
C          Failed to conserve charge.
      NPTCL=NSTART-1
      DECJET=.FALSE.
      RETURN
C
C          Rescale momenta for correct mass
C
500   CONTINUE
      IF(WDECAY) THEN
C          Quark decay. First rescale jet3 + W
        DO 510 K=1,5
510     PPTCL(K,NPTCL+1)=PPTCL(K,NPTCLW)
        NPTLV1=NPTCL+1
        DO 520 K=1,3
520     PSUM(K)=0.
        PSUM(4)=PPTCL(5,IP)
        PSUM(5)=PSUM(4)
        CALL RESCAL(NPJET(2)+1,NPTLV1,PSUM,IFAIL)
        IF(IFAIL.NE.0) THEN
          NPTCL=NSTART-1
          DECJET=.FALSE.
          RETURN
        ENDIF
        DO 530 K=1,3
530     BETAW(K)=PPTCL(K,NPTCL+1)/PPTCL(4,NPTCL+1)
        GAMMAW=PPTCL(4,NPTCL+1)/PPTCL(5,NPTCL+1)
C          Then rescale W
        PSUM(4)=PPTCL(5,NPTCLW)
        PSUM(5)=PSUM(4)
        CALL RESCAL(NHDRN1,NPJET(2),PSUM,IFAIL)
        IF(IFAIL.NE.0) THEN
          NPTCL=NSTART-1
          DECJET=.FALSE.
          RETURN
        ENDIF
      ELSE
C          General decay with no W.
        DO 550 K=1,3
550     PSUM(K)=0.
        PSUM(4)=PPTCL(5,IP)
        PSUM(5)=PSUM(4)
        NPTLV1=NPTCL
        CALL RESCAL(NHDRN1,NPTLV1,PSUM,IFAIL)
        IF(IFAIL.NE.0) THEN
          NPTCL=NSTART-1
          DECJET=.FALSE.
          RETURN
        ENDIF
      ENDIF
C
C          Boost back to lab frame. Reset IORIG.
C
      IF(WDECAY) THEN
        DO 600 I=NHDRN1,NPTCL
          JET=IORIG(I)/IPACK
          IF(JET.NE.1.AND.JET.NE.2) GO TO 600
          BP=BETAW(1)*PPTCL(1,I)+BETAW(2)*PPTCL(2,I)+BETAW(3)*PPTCL(3,I)
          DO 610 J=1,3
610       PPTCL(J,I)=PPTCL(J,I)+GAMMAW*BETAW(J)*(PPTCL(4,I)
     $    +BP*GAMMAW/(GAMMAW+1.))
          PPTCL(4,I)=GAMMAW*(PPTCL(4,I)+BP)
600     CONTINUE
      ENDIF
C
      DO 620 I=NSTART,NPTCL
        IORIG(I)=MOD(IORIG(I),IPACK)
        BP=BETA(1)*PPTCL(1,I)+BETA(2)*PPTCL(2,I)+BETA(3)*PPTCL(3,I)
        DO 621 J=1,3
          PPTCL(J,I)=PPTCL(J,I)+GAMMA*BETA(J)*(PPTCL(4,I)
     $    +BP*GAMMA/(GAMMA+1.))
621     CONTINUE
        PPTCL(4,I)=GAMMA*(PPTCL(4,I)+BP)
620   CONTINUE
C
C          Normal exit
C
      DECJET=.TRUE.
      RETURN
C
C          Error messages.
C
9998  DECJET=.FALSE.
      CALL PRTEVT(0)
      WRITE(ITLIS,99980) NJSET
99980 FORMAT(//5X,'ERROR IN DECJET...NJSET > ',I5)
      RETURN
      END
CDECK  ID>, DECME.  
      LOGICAL FUNCTION DECME(IP,NADD,IDABS,PREST)
C
C          Auxiliary routine for DECAY. Compute matrix element for
C          selected decay and reject if improbable.
C          Return TRUE if accepted, FALSE if not.
C
C          IP = particle to be decayed.
C          NADD = number of products (NPTCL+1, ..., NPTCL+NADD).
C          IDABS = absolute values of decay IDENT's
C          PREST = 4-momenta in rest frame.
C
C          Include polarization of TAU from W+- and top decays. Ignore
C          small polarization from Z0 and bottom decays.
C
C          Ignore BT and TP polarization since hadronization occurs
C          before decay. May be wrong for m(TP) >> m(W).
C
C          Ver 6.25: Fix TAU+ -> E+ NUE ANUT. Old version forgot DECME
C          is called with TAU- modes, so odd fermion is always the one
C          with IDENT<0.
C
C          Ver 6.35: Use V-A for B -> e nu D, etc.
C
C          Ver 7.02: Use +1 helicity for tau's from H+ decay.
C
C          Ver 7.30: Decay top quark rather than hadron.
C
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
C          LOOK MUST BE DIMENSIONED TO THE MAXIMUM VALUE OF INDEX.
      INTEGER   MXLOOK
      PARAMETER (MXLOOK=500)
      INTEGER   MXDKY
      PARAMETER (MXDKY=3000)
      COMMON/DKYTAB/LOOK(MXLOOK),CBR(MXDKY),MODE(5,MXDKY)
      SAVE /DKYTAB/
      INTEGER   LOOK,MODE
      REAL      CBR
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C          Polarizations in SUSY decays
C          PTAUj(i)  = P_tau for tauj -> ziss tau
C          PTAUZi(j) = P_tau for ziss -> tauj tau
C          PTAUZZ    = P_tau for z2ss -> z1ss tau tau
C          PTAUWZ    = P_tau for w1ss -> z1ss tau nutau
      COMMON/SSPOLS/PTAU1(4),PTAU2(4),PTAUZ2(2),PTAUZ3(2),PTAUZ4(2),
     $PTAUZZ,PTAUWZ
      SAVE /SSPOLS/
      REAL PTAU1,PTAU2,PTAUZ2,PTAUZ3,PTAUZ4,PTAUZZ,PTAUWZ
C
      REAL PREST(4,6),WT,TAUHEL,S12,S12MAX,PIP,CTHNU,PSUM(4),AMV2,WT1
      REAL DOT,DOT3,RANF,Z
      INTEGER IP,NADD,IDABS(5),IPAR,IDPAR,JET,INU,I,K,I1,I2,IDSIB
      INTEGER IDLV1,IFL1,IFL2,IFL3,JSPIN,INDEX,IDIPA
      LOGICAL LEPQK(3)
C
      DOT(I1,I2)=PREST(4,I1)*PREST(4,I2)-PREST(1,I1)*PREST(1,I2)
     $-PREST(2,I1)*PREST(2,I2)-PREST(3,I1)*PREST(3,I2)
      DOT3(I1,I2)=PREST(1,I1)*PREST(1,I2)+PREST(2,I1)*PREST(2,I2)
     $+PREST(3,I1)*PREST(3,I2)
C
      IDIPA=IABS(IDENT(IP))
C
C          OMEG and PHI decay.
C
      IF(NADD.EQ.3.AND.(IDENT(IP).EQ.221.OR.IDENT(IP).EQ.331)) THEN
        WT=(PPTCL(5,NPTCL+1)*PPTCL(5,NPTCL+2)*PPTCL(5,NPTCL+3))**2
     $  -(PPTCL(5,NPTCL+1)*DOT(2,3))**2
     $  -(PPTCL(5,NPTCL+2)*DOT(1,3))**2
     $  -(PPTCL(5,NPTCL+3)*DOT(1,2))**2
     $  +2.*DOT(1,2)*DOT(2,3)*DOT(1,3)
        IF(WT.LT.RANF()*PPTCL(5,IP)**6/108.) THEN
          DECME=.FALSE.
        ELSE
          DECME=.TRUE.
        ENDIF
        RETURN
C
C          TAU decays including polarization.
C          Take helicity TAUHEL=0 unless TAU parent is TP, W+-, H+-,
C          or some SUSY particles.
C
      ELSEIF(IDIPA.EQ.16) THEN
C          Use PREST(K,6) for spin vector
        PIP=SQRT(PPTCL(1,IP)**2+PPTCL(2,IP)**2+PPTCL(3,IP)**2)
        DO 110 K=1,3
110     PREST(K,6)=PPTCL(K,IP)/PIP
        PREST(4,6)=0.
        TAUHEL=0.
C
        IF(IORIG(IP).GT.0) THEN
          IPAR=MOD(IORIG(IP),IPACK)
          IDPAR=IABS(IDENT(IPAR))
          IDSIB=0
C          W/top parent
          IF(IDPAR.GT.100.AND.MOD(IDPAR/10,10).GE.6) THEN
            TAUHEL=-1.
          ELSEIF(IDPAR.EQ.80) THEN
            TAUHEL=-1.
C          Charged Higgs parent
          ELSEIF(IDPAR.EQ.86) THEN
            TAUHEL=+1.
C          SUSY parent - polarization also depends on sibling IDSIB
          ELSEIF(GOMSSM.AND.IDPAR.GT.20.AND.IDPAR.LT.80) THEN
            I1=IDCAY(IPAR)/IPACK
            I2=MOD(IDCAY(IPAR),IPACK)
            DO 120 I=I1,I2
              IF(IABS(IDENT(I)).GT.20.AND.IABS(IDENT(I)).LT.80)
     $        IDSIB=IABS(IDENT(I))
120         CONTINUE
            IF (IDPAR.EQ.35) THEN
              TAUHEL=-1.
            ELSEIF (IDPAR.EQ.36) THEN
              IF (IDSIB.EQ.30) TAUHEL=PTAU1(1)
              IF (IDSIB.EQ.40) TAUHEL=PTAU1(2)
              IF (IDSIB.EQ.50) TAUHEL=PTAU1(3)
              IF (IDSIB.EQ.60) TAUHEL=PTAU1(4)
            ELSEIF (IDPAR.EQ.56) THEN
              IF (IDSIB.EQ.30) TAUHEL=PTAU2(1)
              IF (IDSIB.EQ.40) TAUHEL=PTAU2(2)
              IF (IDSIB.EQ.50) TAUHEL=PTAU2(3)
              IF (IDSIB.EQ.60) TAUHEL=PTAU2(4)
            ELSEIF (IDPAR.EQ.39) THEN
              IF(IDSIB.EQ.35) TAUHEL=-1.
              IF(IDSIB.EQ.30) TAUHEL=PTAUWZ
            ELSEIF (IDPAR.EQ.49.AND.IDSIB.EQ.35) THEN
              TAUHEL=-1.
            ELSEIF (IDPAR.EQ.40) THEN
              IF(IDSIB.EQ.36) TAUHEL=PTAUZ2(1)
              IF(IDSIB.EQ.56) TAUHEL=PTAUZ2(2)
              IF(IDSIB.EQ.30) TAUHEL=PTAUZZ
            ELSEIF (IDPAR.EQ.50) THEN
              IF(IDSIB.EQ.36) TAUHEL=PTAUZ3(1)
              IF(IDSIB.EQ.56) TAUHEL=PTAUZ3(2)
            ELSEIF (IDPAR.EQ.60) THEN
              IF(IDSIB.EQ.36) TAUHEL=PTAUZ4(1)
              IF(IDSIB.EQ.56) TAUHEL=PTAUZ4(2)
            ENDIF
          END IF
        ELSE
          IF(KEYS(3)) THEN
            IF(IABS(IDENTW).EQ.80) TAUHEL=-1.
          ELSE
            JET=IABS(IORIG(IP))/IPACK
            IF(IDJETS(JET).EQ.80) TAUHEL=-1.
          ENDIF
        ENDIF
C
C          Leptonic decays. DECME is always called for TAU- decay
C          products, so selection is independent of IDENT(IP).
        IF(NADD.EQ.3.AND.
     $  IDABS(1).LT.20.AND.IDABS(1).NE.10.AND.
     $  IDABS(2).LT.20.AND.IDABS(2).NE.10.AND.
     $  IDABS(3).LT.20.AND.IDABS(3).NE.10)
     $  THEN
          IF(IDENT(NPTCL+1).LT.0) THEN
            WT=PPTCL(5,IP)*(PREST(4,1)-TAUHEL*DOT(1,6))*DOT(2,3)
          ELSEIF(IDENT(NPTCL+2).LT.0) THEN
            WT=PPTCL(5,IP)*(PREST(4,2)-TAUHEL*DOT(2,6))*DOT(1,3)
          ELSE
            WT=PPTCL(5,IP)*(PREST(4,3)-TAUHEL*DOT(3,6))*DOT(1,2)
          ENDIF
          IF(WT.LT.RANF()*PPTCL(5,IP)**4/8.) THEN
            DECME=.FALSE.
          ELSE
            DECME=.TRUE.
          ENDIF
          RETURN
C
C          Decay to PI + NUT, K + NUT
        ELSEIF(NADD.EQ.2.AND.((IDABS(1).EQ.120.OR.IDABS(2).EQ.120).OR.
     $  (IDABS(1).EQ.130.OR.IDABS(2).EQ.130))) THEN
          INU=1
          IF(IDABS(2).EQ.15) INU=2
          CTHNU=DOT3(INU,6)/SQRT(DOT3(INU,INU))
          WT=1.-TAUHEL*CTHNU
          IF(WT.LT.RANF()*2.) THEN
            DECME=.FALSE.
          ELSE
            DECME=.TRUE.
          ENDIF
          RETURN
C
C          Decay to RHO + NUT, A1 + NUT, K* + NUT
        ELSE
          DO 210 I=1,NADD
210       IF(IDABS(I).EQ.15) INU=I
          DO 220 K=1,4
            PSUM(K)=0.
            DO 221 I=1,NADD
              IF(I.EQ.INU) GO TO 221
              PSUM(K)=PSUM(K)+PREST(K,I)
221         CONTINUE
220       CONTINUE
          AMV2=PSUM(4)**2-PSUM(1)**2-PSUM(2)**2-PSUM(3)**2
          WT1=2.*AMV2/(2.*AMV2+PPTCL(5,IP)**2)
          CTHNU=DOT3(INU,6)/SQRT(DOT3(INU,INU))
          WT=WT1*(1.+TAUHEL*CTHNU)+(1.-WT1)*(1-TAUHEL*CTHNU)
          IF(WT.LT.RANF()*2.) THEN
            DECME=.FALSE.
          ELSE
            DECME=.TRUE.
          ENDIF
          RETURN
        ENDIF
C
C          Hadronic V-A semileptonic and quark decays. Note V-A decay
C          dots initial fermion with final antifermion.
C          W propagator generated in DECAY.
C
      ELSEIF(NADD.EQ.3.AND.((IDIPA.GT.100.AND.MOD(IDIPA/10,10).GE.4)
     $.OR.(IDIPA.GE.6.AND.IDIPA.LE.8))) THEN
        DO 310 K=1,3
310     LEPQK(K)=IDABS(K).LT.20.AND.IDABS(K).NE.10
C          At least 2 leptons/quarks
        IF((LEPQK(1).AND.LEPQK(2)).OR.(LEPQK(1).AND.LEPQK(3)).OR.
     $  (LEPQK(2).AND.LEPQK(3))) THEN
          IDLV1=IDENT(IP)
          CALL FLAVOR(IDLV1,IFL1,IFL2,IFL3,JSPIN,INDEX)
          IF(IFL3.EQ.0) IFL3=IDENT(IP)
          IF(IFL3*IDENT(IP)*IDENT(NPTCL+1).LT.0) THEN
            WT=PPTCL(5,IP)*PREST(4,1)*DOT(2,3)
          ELSEIF(IFL3*IDENT(IP)*IDENT(NPTCL+2).LT.0) THEN
            WT=PPTCL(5,IP)*PREST(4,2)*DOT(1,3)
          ELSE
            WT=PPTCL(5,IP)*PREST(4,3)*DOT(1,2)
          ENDIF
          IF(WT.LT.RANF()*PPTCL(5,IP)**4/16.) THEN
            DECME=.FALSE.
          ELSE
            DECME=.TRUE.
          ENDIF
        ELSE
          DECME=.TRUE.
        ENDIF
        RETURN
C
C          All other particles
C
      ELSE
        DECME=.TRUE.
        RETURN
      ENDIF
      END
CDECK  ID>, DOMSSM. 
      SUBROUTINE DOMSSM
C-----------------------------------------------------------------------
C          Initialize MSSM masses and decay modes from ISASUSY.
C          Check for validity with ISAJET masses.
C          Decay modes are transfered to /DKYTAB/ by /SETDKY/.
C
C          F.E. Paige, November, 1992
C
C          Ver. 7.01: Add test so that AMASS is not called if ID = 0
C          Ver. 7.07: Add checking for LEP bounds.
C          Ver. 7.10: Add SUGRA interface
C          Ver. 7.32: Extend to large tanb solution
C          Ver. 7.33: Add gauge-mediated SUSY model
C
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          ISAJET common blocks
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QLMASS/AMLEP(100),NQLEP,NMES,NBARY
      SAVE /QLMASS/
      INTEGER   NQLEP,NMES,NBARY
      REAL      AMLEP
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

      COMMON/NODCAY/NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      SAVE /NODCAY/
      LOGICAL NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
C          ISASUSY common blocks
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          MXSS                 = maximum number of modes
C          NSSMOD               = number of modes
C          ISSMOD               = initial particle
C          JSSMOD               = final particles
C          GSSMOD               = width
C          BSSMOD               = branching ratio
      INTEGER MXSS
      PARAMETER (MXSS=1000)
      COMMON/SSMODE/NSSMOD,ISSMOD(MXSS),JSSMOD(5,MXSS),GSSMOD(MXSS)
     $,BSSMOD(MXSS)
      INTEGER NSSMOD,ISSMOD,JSSMOD
      REAL GSSMOD,BSSMOD
      SAVE /SSMODE/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C          Frozen couplings from RG equations:
C     GSS( 1) = g_1        GSS( 2) = g_2        GSS( 3) = g_3
C     GSS( 4) = y_tau      GSS( 5) = y_b        GSS( 6) = y_t
C     GSS( 7) = M_1        GSS( 8) = M_2        GSS( 9) = M_3
C     GSS(10) = A_tau      GSS(11) = A_b        GSS(12) = A_t
C     GSS(13) = M_h1^2     GSS(14) = M_h2^2     GSS(15) = M_er^2
C     GSS(16) = M_el^2     GSS(17) = M_dnr^2    GSS(18) = M_upr^2
C     GSS(19) = M_upl^2    GSS(20) = M_taur^2   GSS(21) = M_taul^2
C     GSS(22) = M_btr^2    GSS(23) = M_tpr^2    GSS(24) = M_tpl^2
C     GSS(25) = mu         GSS(26) = B
C          Masses:
C     MSS( 1) = glss     MSS( 2) = upl      MSS( 3) = upr
C     MSS( 4) = dnl      MSS( 5) = dnr      MSS( 6) = stl
C     MSS( 7) = str      MSS( 8) = chl      MSS( 9) = chr
C     MSS(10) = b1       MSS(11) = b2       MSS(12) = t1
C     MSS(13) = t2       MSS(14) = nuel     MSS(15) = numl
C     MSS(16) = nutl     MSS(17) = el-      MSS(18) = er-
C     MSS(19) = mul-     MSS(20) = mur-     MSS(21) = tau1
C     MSS(22) = tau2     MSS(23) = z1ss     MSS(24) = z2ss
C     MSS(25) = z3ss     MSS(26) = z4ss     MSS(27) = w1ss
C     MSS(28) = w2ss     MSS(29) = hl0      MSS(30) = hh0
C     MSS(31) = ha0      MSS(32) = h+
C          Unification:
C     MGUTSS  = M_GUT    GGUTSS  = g_GUT    AGUTSS  = alpha_GUT
      COMMON /SUGMG/ MSS(32),GSS(26),MGUTSS,GGUTSS,AGUTSS
      REAL MSS,GSS,MGUTSS,GGUTSS,AGUTSS
      SAVE /SUGMG/
      COMMON /SUGPAS/ XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,NOGOOD,
     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ
      REAL XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,
     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ
      INTEGER NOGOOD
      SAVE /SUGPAS/
C     XSUGIN contains the inputs to SUGRA:
C     XSUGIN(1) = M_0        XSUGIN(2) = M_(1/2)  XSUGIN(3) = A_0
C     XSUGIN(4) = tan(beta)  XSUGIN(5) = sgn(mu)  XSUGIN(6) = M_t
C     XGMIN(1) = LAM         XGMIN(2)  = M_MES    XGMIN(3)  = XN5
C     XISAIN contains the MSSMi inputs in natural order.
      COMMON /SUGXIN/ XISAIN(24),XSUGIN(6),XGMIN(7)
      REAL XISAIN,XSUGIN,XGMIN
      SAVE /SUGXIN/
C
      INTEGER NOUT
      PARAMETER (NOUT=33)
      INTEGER IDOUT(NOUT)
      REAL AMASS,AMPL
      REAL AMI,SUMGAM,SUMMJ
      INTEGER I,J,K,IFL1,IFL2,IFL3,JSPIN,INDEX,IALLOW,IITEST
C
      DATA IDOUT/
     $IDTP,ISGL,ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1,ISUPR,ISDNR,
     $ISSTR,ISCHR,ISBT2,ISTP2,ISEL,ISMUL,ISTAU1,ISNEL,ISNML,ISNTL,
     $ISER,ISMUR,ISTAU2,ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,
     $ISHL,ISHH,ISHA,ISHC/
      DATA AMPL/2.4E18/
C
C          Generate masses and decays
C
      IF (XMGVTO.LT.1.E19) AMGVSS=XMGVTO
      IF(.NOT.GOMSSM) RETURN
      LOUT=ITLIS
      IF(GOSUG) THEN
C          SUGRA input
C          First solve renormalization group equations
        CALL SUGRA(XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU,AMASS(6),1)
        IF (NOGOOD.EQ.1) THEN
          WRITE(LOUT,*) 'SUGRA BAD POINT: TACHYONIC PARTICLES!'
        ELSE IF (NOGOOD.EQ.2) THEN
          WRITE(LOUT,*) 'SUGRA BAD POINT: NO EW SYMMETRY BREAKING!'
        ELSE IF (NOGOOD.EQ.3) THEN
          WRITE(LOUT,*) 'SUGRA BAD POINT: M(H_P)^2<0!'
        ELSE IF (NOGOOD.EQ.4) THEN
          WRITE(LOUT,*) 'SUGRA BAD POINT: YUKAWA>100!'
        ELSE IF (NOGOOD.EQ.5) THEN
          WRITE(LOUT,*) 'SUGRA BAD POINT: Z1SS NOT LSP!'
        ELSE IF (NOGOOD.EQ.7) THEN
          WRITE(LOUT,*) 'SUGRA BAD POINT: XT EWSB IS BAD!'
        ELSE IF (NOGOOD.EQ.8) THEN
          WRITE(LOUT,*) 'SUGRA BAD POINT: MHL^2<0!'
        END IF
        IF(NOGOOD.NE.0) STOP99
C          Then calculate masses and decays
        CALL SSMSSM(XISAIN(1),XISAIN(2),XISAIN(3),
     $ XISAIN(4),XISAIN(5),XISAIN(6),XISAIN(7),XISAIN(8),XISAIN(9),
     $ XISAIN(10),XISAIN(11),XISAIN(12),XISAIN(13),XISAIN(14),
     $ XISAIN(15),XISAIN(16),XISAIN(17),XISAIN(18),XISAIN(19),
     $ XISAIN(20),XISAIN(21),XISAIN(22),XISAIN(23),XISAIN(24),
     $ AMASS(6),IALLOW,1)
      ELSE IF(GOGMSB) THEN
C          GMSB input
C          First solve renormalization group equations
        CALL SUGRA(XLAMGM,XMESGM,XN5GM,XTGBSU,XSMUSU,AMASS(6),2)
        IF (NOGOOD.EQ.1) THEN
          WRITE(LOUT,*) 'GMSB BAD POINT: TACHYONIC PARTICLES!'
        ELSE IF (NOGOOD.EQ.2) THEN
          WRITE(LOUT,*) 'GMSB BAD POINT: NO EW SYMMETRY BREAKING!'
        ELSE IF (NOGOOD.EQ.3) THEN
          WRITE(LOUT,*) 'GMSB BAD POINT: M(H_P)^2<0!'
        ELSE IF (NOGOOD.EQ.4) THEN
          WRITE(LOUT,*) 'GMSB BAD POINT: YUKAWA>100!'
        ELSE IF (NOGOOD.EQ.7) THEN
          WRITE(LOUT,*) 'GMSB BAD POINT: XT EWSB IS BAD!'
        ELSE IF (NOGOOD.EQ.8) THEN
          WRITE(LOUT,*) 'GMSB BAD POINT: MHL^2<0!'
        END IF
        IF(NOGOOD.NE.0) STOP99
C          Then calculate masses and decays
        AMGVSS=XLAMGM*XMESGM*XCMGV/SQRT(3.)/AMPL
        CALL SSMSSM(XISAIN(1),XISAIN(2),XISAIN(3),
     $  XISAIN(4),XISAIN(5),XISAIN(6),XISAIN(7),XISAIN(8),XISAIN(9),
     $  XISAIN(10),XISAIN(11),XISAIN(12),XISAIN(13),XISAIN(14),
     $  XISAIN(15),XISAIN(16),XISAIN(17),XISAIN(18),XISAIN(19),
     $  XISAIN(20),XISAIN(21),XISAIN(22),XISAIN(23),XISAIN(24),
     $  AMASS(6),IALLOW,2)
      ELSE
C          Weak scale input
C          Values of 1.E20 indicate that SSMASS should calculate
C          M_1 and M_2 from M_3
        CALL SSMSSM(XGLSS,XMUSS,XHASS,XTBSS,XQ1SS,XDRSS,XURSS,XL1SS,
     $  XERSS,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS,XQ3SS,XBRSS,XTRSS,XL3SS,
     $  XTARSS,XATSS,XABSS,XATASS,XM1SS,XM2SS,AMASS(6),IALLOW,1)
      ENDIF
C
C          Test parameters
C
      IF(IALLOW.NE.0) THEN
        WRITE(LOUT,1000)
1000    FORMAT(//' MSSM WARNING: Z1SS IS NOT LSP')
      ENDIF
      CALL SSTEST(IALLOW)
      IITEST=IALLOW/2
      IF(MOD(IITEST,2).NE.0) THEN
        WRITE(LOUT,1002)
1002    FORMAT(' MSSM WARNING: Z -> Z1SS Z1SS TOO BIG')
      ENDIF
      IITEST=IITEST/2
      IF(MOD(IITEST,2).NE.0) THEN
        WRITE(LOUT,1004)
1004    FORMAT(' MSSM WARNING: Z -> CHARGINOS ALLOWED')
      ENDIF
      IITEST=IITEST/2
      IF(MOD(IITEST,2).NE.0) THEN
        WRITE(LOUT,1008)
1008    FORMAT(' MSSM WARNING: Z -> Z1SS Z2SS TOO BIG')
      ENDIF
      IITEST=IITEST/2
      IF(MOD(IITEST,2).NE.0) THEN
        WRITE(LOUT,1008)
1016    FORMAT(' MSSM WARNING: Z -> SQUARKS OR SLEPTONS')
      ENDIF
      IITEST=IITEST/2
      IF(MOD(IITEST,2).NE.0) THEN
        WRITE(LOUT,1032)
1032    FORMAT(' MSSM WARNING: Z -> Z* HL0 TOO BIG')
      ENDIF
      IITEST=IITEST/2
      IF(MOD(IITEST,2).NE.0) THEN
        WRITE(LOUT,1064)
1064    FORMAT(' MSSM WARNING: Z -> HL0 HA0 ALLOWED')
      ENDIF
      IITEST=IITEST/2
      IF(MOD(IITEST,2).NE.0) THEN
        WRITE(LOUT,1128)
1128    FORMAT(' MSSM WARNING: Z -> H+ H- ALLOWED')
      ENDIF
C
C          Store masses in /QLMASS/
C
      CALL FLAVOR(ISUPL,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMULSS
      CALL FLAVOR(ISDNL,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMDLSS
      CALL FLAVOR(ISSTL,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMSLSS
      CALL FLAVOR(ISCHL,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMCLSS
      CALL FLAVOR(ISBT1,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMB1SS
      CALL FLAVOR(ISTP1,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMT1SS
      CALL FLAVOR(ISUPR,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMURSS
      CALL FLAVOR(ISDNR,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMDRSS
      CALL FLAVOR(ISSTR,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMSRSS
      CALL FLAVOR(ISCHR,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMCRSS
      CALL FLAVOR(ISBT2,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMB2SS
      CALL FLAVOR(ISTP2,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMT2SS
C
      CALL FLAVOR(ISNEL,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMN1SS
      CALL FLAVOR(ISEL,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMELSS
      CALL FLAVOR(ISNML,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMN2SS
      CALL FLAVOR(ISMUL,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMMLSS
      CALL FLAVOR(ISNTL,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMN3SS
      CALL FLAVOR(ISTAU1,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AML1SS
      CALL FLAVOR(ISER,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMERSS
      CALL FLAVOR(ISMUR,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AMMRSS
      CALL FLAVOR(ISTAU2,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=AML2SS
C
      CALL FLAVOR(ISGL,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=ABS(AMGLSS)
      CALL FLAVOR(ISZ1,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=ABS(AMZ1SS)
      CALL FLAVOR(ISZ2,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=ABS(AMZ2SS)
      CALL FLAVOR(ISZ3,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=ABS(AMZ3SS)
      CALL FLAVOR(ISZ4,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=ABS(AMZ4SS)
      CALL FLAVOR(ISW1,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=ABS(AMW1SS)
      CALL FLAVOR(ISW2,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=ABS(AMW2SS)
C
      CALL FLAVOR(ISHL,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=ABS(AMHL)
      CALL FLAVOR(ISHH,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=ABS(AMHH)
      CALL FLAVOR(ISHA,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=ABS(AMHA)
      CALL FLAVOR(ISHC,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=ABS(AMHC)
C
C          Check decays with ISAJET masses
C          Turn off gravitino decays with extra mass if NOGRAV=.TRUE.
C          (Yes, it is a kluge, but it saves another rescaling of the
C          branching ratios in SETDKY.)
C
      DO 100 I=1,NOUT
        SUMGAM=0
        AMI=AMASS(IDOUT(I))
        DO 110 J=1,NSSMOD
          IF(IDOUT(I).NE.ISSMOD(J)) GO TO 110
          SUMMJ=0
          DO 111 K=1,5
            IF(JSSMOD(K,J).NE.0) SUMMJ=SUMMJ+AMASS(JSSMOD(K,J))
            IF(NOGRAV.AND.(JSSMOD(K,J).EQ.ISGRAV)) SUMMJ=SUMMJ+AMI+1
111       CONTINUE
          IF(SUMMJ.GE.AMI) GSSMOD(J)=0
          SUMGAM=SUMGAM+GSSMOD(J)
110     CONTINUE
        DO 120 J=1,NSSMOD
          IF(IDOUT(I).NE.ISSMOD(J)) GO TO 120
          IF(SUMGAM.NE.0) THEN
            BSSMOD(J)=GSSMOD(J)/SUMGAM
          ELSE
            BSSMOD(J)=0
          ENDIF
120     CONTINUE
100   CONTINUE
C
      RETURN
      END
CDECK  ID>, DRLLYN. 
      SUBROUTINE DRLLYN
C
C          Generate QMW (and QTW) for DRELLYAN or HIGGS event using
C          integrated cross section. Then generate decay -- for HIGGS,
C          the mode must be chosen using the integrated cross sections
C          because of interference with W+W->W+W scattering.
C
C          Note that NOGOOD calls the cross section.
C
C          Ver. 6.40: Add technicolor resonances. Use logs for QDEN,
C          PTDEN, WTFAC, etc. Also scale QMW generation by QMAX.
C
C          Ver. 7.01: Correct QDEN to correspond to correct fit form:
C          SIGMA = ANOMR(K)*(QMAX**2/Q**2)**QPOW
C          See QFUNC.
C
C          Ver. 7.14: Add SUSY Higgs
C          Ver. 7.15: Fix bug with THETAW limits by adding epsilon to
C          allowed range. Check for possible invalid Higgs decays.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/TOTALS/NKINPT,NWGEN,NKEEP,SUMWT,WT
      SAVE /TOTALS/
      INTEGER   NKINPT,NWGEN,NKEEP
      REAL      SUMWT,WT
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PINITS/PINITS(5,2),IDINIT(2)
      SAVE /PINITS/
      INTEGER   IDINIT
      REAL      PINITS
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/WGEN/PTGN(3,3),QGEN(3,3),PTSEL(3),QSEL(3),SIGSL(3),NKL,NKH
     1,EMSQ,EMGAM,KSEL,QSELWT(3)
      SAVE /WGEN/
      INTEGER   NKL,NKH,KSEL
      REAL      PTGN,QGEN,PTSEL,QSEL,SIGSL,EMSQ,EMGAM,QSELWT
      COMMON/DYPAR/FLW,RNU2(3),ANORM(3),QPOW(3),PTPOW(3)
      SAVE /DYPAR/
      LOGICAL FLW
      REAL      RNU2,ANORM,QPOW,PTPOW
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
      COMMON/ISLOOP/NEVOLV,NFRGMN,IEVOL,IFRG
      SAVE /ISLOOP/
      INTEGER NEVOLV,NFRGMN,IEVOL,IFRG
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C          LISTSS IDENT and JETTYPE codes
C       ISGL  ISUPL -ISUPL  ISDNL -ISDNL  ISSTL -ISSTL  ISCHL -ISCHL
C          1      2      3      4      5      6      7      8      9
C      ISBT1 -ISBT1  ISTP1 -ISTP1  ISUPR -ISUPR  ISDNR -ISDNR  ISSTR
C         10     11     12     13     14     15     16     17     18
C     -ISSTR  ISCHR -ISCHR  ISBT2 -ISBT2  ISTP2 -ISTP2   ISW1  -ISW1
C         19     20     21     22     23     24     25     26     27
C       ISW2  -ISW2   ISZ1   ISZ2   ISZ3   ISZ4  ISNEL -ISNEL   ISEL
C         28     29     30     31     32     33     34     35     36
C      -ISEL  ISNML -ISNML  ISMUL -ISMUL  ISNTL -ISNTL ISTAU1-ISTAU1
C         37     38     39     40     41     42     43     44     45
C       ISER  -ISER  ISMUR -ISMUR ISTAU2-ISTAU2      9      1     -1
C         46     47     48     49     50     51     52     53     54
C          2     -2      3     -3      4     -4      5     -5      6
C         55     56     57     58     59     60     61     62     63
C         -6     11    -11     12    -12     13    -13     14    -14
C         64     65     66     67     68     69     70     71     72
C         15    -15     16    -16     10     80    -80     90   ISHL
C         73     74     75     76     77     78     79     80     81
C       ISHH   ISHA   ISHC  -ISHC
C         82     83     84     85
      COMMON/LISTSS/LISTSS(85)
      INTEGER LISTSS
      SAVE /LISTSS/
C
      DIMENSION X(2)
      EQUIVALENCE (X(1),X1)
      DIMENSION PREST(5),PL(5),EL(3),EML(3),EMSQL(3)
      DIMENSION WTFAC(3)
      LOGICAL NOGOOD
      LOGICAL YGENJ
      DIMENSION BRANCH(29),LISTJ(29),LISTW(4)
      REAL ACOSH,XXX,ASINH,CHOOSE,RANF,SUM,WTFAC,PTDEN,QDEN,ETA,QPW,
     $S12,BRANCH,SUMBR,BRMODE,AMASS,BRINV,TRY,EMSQL,EL,PL12,PREST,
     $COSTHL,THL,PHL,PTL,SGN,PL,BP,PLPL,PLMN,AMINI,AMFIN,PINI,PFIN,
     $ QPL,QMN,AM1SQ,AM2SQ,ROOT,P1PL,P1MN,P2PL,P2MN,X,EML
      INTEGER NTRY,K,IQ1,IQ2,IFL1,IFL2,LISTJ,IQ,NTRY2,IFL,LISTW,I
      REAL ZZSTAR
      INTEGER IZSTAR,JVIR
C
      DATA LISTJ/
     $9,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,
     $11,-11,12,-12,13,-13,14,-14,15,-15,16,-16,
     $10,80,-80,90/
      DATA LISTW/10,80,-80,90/
      ACOSH(XXX)=ALOG(XXX+SQRT(XXX**2-1.))
      ASINH(XXX)=ALOG(XXX+SQRT(XXX**2+1.))
C
C          Entry
C
      NPTCL=0
      NTRY=0
200   CONTINUE
      SIGMA=0.
      WT=1.
    1 CONTINUE
      NTRY=NTRY+1
      IF(NTRY.GT.NTRIES) GO TO 999
      SUMWT=SUMWT+SIGMA*WT/(NEVOLV*NFRGMN)
      NKINPT=NKINPT+1
      SIGMA=0.
      WT=1.
      DO 2 K=1,3
    2 SIGSL(K)=0
C            Choose interval for cross section calculation
      CHOOSE=RANF()
      SUM=0.
      DO 3 K=NKL,NKH
        SUM=SUM+QSELWT(K)
        IF(CHOOSE.LE.SUM) GO TO 30
3     CONTINUE
30    KSEL=K
C          Generate QTW in selected region
      IF(.NOT.FIXQT) THEN
        ETA=(PTGN(1,K)+PTGN(2,K)*RANF())**PTGN(3,K)
        PTSEL(K)=SQRT(ETA-RNU2(K))
        PTDEN=ALOG(ETA)*PTPOW(K)
        WTFAC(1)=ALOG(ABS(PTGN(2,K)))+ALOG(ABS(PTGN(3,K)))
     1  +ALOG(ABS(PTSEL(K)**2+RNU2(K)))*((PTGN(3,K)-1.)/PTGN(3,K))
        PT(3)=PTSEL(K)
      ELSE
        PTDEN=0.
        WTFAC(1)=-1000.
      ENDIF
C          Generate QMW
      IF(.NOT.FIXQM) THEN
        IF(.NOT.K.EQ.2) THEN
          QSEL(K)=QMAX**2*(QGEN(1,K)+QGEN(2,K)*RANF())**QGEN(3,K)
          QDEN=ALOG(QSEL(K)/QMAX**2)*QPOW(K)
          WTFAC(2)=ALOG(ABS(QGEN(2,K)))+ALOG(ABS(QGEN(3,K)))
     1    +ALOG(QSEL(K)/QMAX**2)*((QGEN(3,K)-1.)/QGEN(3,K))
     2    +ALOG(QMAX**2)
          QSEL(K)=SQRT(QSEL(K))
          QMW=QSEL(K)
        ELSE
          ETA=QGEN(3,K)*TAN(QGEN(1,K)+QGEN(2,K)*RANF())
          QSEL(K)=SQRT(ETA+EMSQ)
          WTFAC(2)=ALOG(QGEN(2,K))+ALOG(QGEN(3,K))
     1    +ALOG((ETA/QGEN(3,K))**2+1.)
          QMW=QSEL(K)
          QDEN=ALOG((QMW**2-EMSQ)**2+EMGAM**2)
        ENDIF
      ELSE
        QDEN=0.
        WTFAC(2)=-1000.
      ENDIF
      SIGSL(K)=EXP(ANORM(K)-PTDEN-QDEN)
C
      IF(STDDY) THEN
        WT=EXP(WTFAC(2)-ALOG(QSELWT(K)))
      ELSE
        WT=EXP(WTFAC(1)+WTFAC(2)-ALOG(QSELWT(K)))
      ENDIF
      QTW=PT(3)
      YW=YWMIN+(YWMAX-YWMIN)*RANF()
      WT=WT*(YWMAX-YWMIN)
      PHIW=PHWMIN+(PHWMAX-PHWMIN)*RANF()
      PHI(3)=AMOD(PHIW+PI,2.*PI)
      QPW=SQRT(QTW**2+QMW**2)*SINH(YW)
      QW=SQRT(QTW**2+QPW**2)
      THW=QPW/QW
      IF(ABS(THW).GT.1.) THW=SIGN(1.,THW)
      THW=ACOS(THW)
      IF(THW.LT.THWMIN-1.E-6.OR.THW.GT.THWMAX+1.E-6) GOTO 1
      XW=QPW/HALFE
      IF(XW.LT.XWMIN.OR.XW.GT.XWMAX) GOTO 1
      IF(.NOT.STDDY) THEN
        IF(.NOT.YGENJ(3)) GOTO 1
        P(3)=PT(3)/STH(3)
        XJ(3)=P(3)*CTH(3)/HALFE
        IF(XJ(3).LT.XJMIN(3).OR.XJ(3).GT.XJMAX(3)) GOTO 1
      ENDIF
C
C          Check integrated cross section
C
      IF(NOGOOD(2)) GO TO 1
      SUMWT=SUMWT+SIGMA*WT/(NEVOLV*NFRGMN)
      NWGEN=NWGEN+1
      S12=QMW**2
C
C          Select W decay mode
C          QMW dependence neglected in branching ratios
C          BRANCH is cum. br. with heavy modes subtracted.
C
      IF(KEYS(3)) THEN
        BRANCH(1)=0.
        SUMBR=0.
        DO 105 IQ1=2,25
          IQ2=MATCH(IQ1,JWTYP)
          IF(IQ2.EQ.0) THEN
            BRMODE=0.
          ELSE
            BRMODE=WCBR(IQ1,JWTYP)-WCBR(IQ1-1,JWTYP)
            IFL1=LISTJ(IQ1)
            IFL2=LISTJ(IQ2)
            IF(S12.LE.(AMASS(IFL1)+AMASS(IFL2))**2) BRMODE=0.
          ENDIF
          BRANCH(IQ1)=BRANCH(IQ1-1)+BRMODE
          SUMBR=SUMBR+BRMODE
105     CONTINUE
        BRINV=1./SUMBR
C
        TRY=RANF()
        DO 110 IQ=1,25
          IF(TRY.LT.BRANCH(IQ)*BRINV.AND.MATCH(IQ,JWTYP).NE.0) THEN
            JETTYP(1)=IQ
            JETTYP(2)=MATCH(IQ,JWTYP)
            GO TO 120
          ENDIF
110     CONTINUE
      ENDIF
C
120   IF(GOMSSM) THEN
        IFL1=LISTSS(JETTYP(1))
        IFL2=LISTSS(JETTYP(2))
      ELSE
        IFL1=LISTJ(JETTYP(1))
        IFL2=LISTJ(JETTYP(2))
      ENDIF
C
C          Select masses of decay products. These are just normal masses
C          except for Z Z* decay of Higgs, where one is virtual.
C
      EML(1)=AMASS(IFL1)
      EML(2)=AMASS(IFL2)
      IF(KEYS(7).AND.EML(1)+EML(2).GT.QMW) THEN
C          WW* or ZZ* decay - generate/check W* or Z* mass
        IF((IABS(IFL1).EQ.80.AND.IABS(IFL2).EQ.80)
     $  .OR.(IFL1.EQ.90.AND.IFL2.EQ.90)) THEN
          IZSTAR=3-2*RANF()
          IF(GOMSSM) THEN
            JVIR=JETTYP(IZSTAR)-76
          ELSE
            JVIR=JETTYP(IZSTAR)-25
          ENDIF
          EML(IZSTAR)=ZZSTAR(QMW,JVIR)
          IF(EML(IZSTAR).LT.ZSTARS(JVIR,IZSTAR)) GO TO 200
C          Other decay - invalid for this QMW
        ELSE
          GO TO 200
        ENDIF
      ENDIF
C
C          Generate W decay in its rest frame and compare with SIGDY2.
C          First set up momenta of decay products:
C
      EMSQL(1)=EML(1)**2
      EMSQL(2)=EML(2)**2
      EL(1)=(S12+EMSQL(1)-EMSQL(2))/(2.*QMW)
      EL(2)=(S12+EMSQL(2)-EMSQL(1))/(2.*QMW)
      PL12=SQRT((S12-(EML(1)+EML(2))**2)*(S12-(EML(1)-EML(2))**2))
     $/(2.*QMW)
C          W momentum
      PREST(1)=QTW*COS(PHIW)
      PREST(2)=QTW*SIN(PHIW)
      PREST(3)=QPW
      PREST(4)=SQRT(QW**2+QMW**2)
      PREST(5)=QMW
      NTRY2=0
C          Generate next W decay
20    CONTINUE
      NTRY2=NTRY2+1
      IF(NTRY2.GT.NTRIES) GO TO 999
      COSTHL=2.*RANF()-1.
      THL=ACOS(COSTHL)
      PHL=2.*PI*RANF()
      PTL=PL12*SIN(THL)
C
      DO 300 I=1,2
        SGN=3-2*I
        PL(1)=SGN*PTL*COS(PHL)
        PL(2)=SGN*PTL*SIN(PHL)
        PL(3)=SGN*PL12*COSTHL
        PL(4)=EL(I)
        PL(5)=EML(I)
C          Boost with W momentum
        BP=0.
        DO 310 K=1,3
310     BP=BP+PL(K)*PREST(K)
        BP=BP/PREST(5)
        DO 320 K=1,3
320     PL(K)=PL(K)+PREST(K)*PL(4)/PREST(5)
     $  +PREST(K)*BP/(PREST(4)+PREST(5))
        PL(4)=PL(4)*PREST(4)/PREST(5)+BP
C          Fill common blocks
        PT(I)=SQRT(PL(1)**2+PL(2)**2)
        P(I)=SQRT(PT(I)**2+PL(3)**2)
        IF(PT(I).GT.0.) THEN
          PHI(I)=ATAN2(PL(2),PL(1))
        ELSE
          PHI(I)=(I-1)*PI
        ENDIF
        IF(PHI(I).LT.0.) PHI(I)=PHI(I)+2.*PI
        CTH(I)=PL(3)/P(I)
        STH(I)=PT(I)/P(I)
        TH(I)=ACOS(CTH(I))
        XJ(I)=PL(3)/HALFE
        IF(CTH(I).GT.0.) THEN
          PLPL=PL(4)+PL(3)
          PLMN=(PT(I)**2+EMSQL(I))/PLPL
        ELSE
          PLMN=PL(4)-PL(3)
          PLPL=(PT(I)**2+EMSQL(I))/PLMN
        ENDIF
        YJ(I)=.5*ALOG(PLPL/PLMN)
300   CONTINUE
C
C          Test cross section
C          Extra kinematics for W+W->W+W
C
      IF(KEYS(7).OR.KEYS(9)) THEN
        SHAT=S12
        IF(GOMSSM) THEN
          AMINI=AMASS(LISTSS(INITYP(1)))
        ELSE
          AMINI=AMASS(LISTJ(INITYP(1)))
        ENDIF
        AMFIN=EML(1)
        PINI=.5*SQRT(S12-4.*AMINI**2)
        PFIN=PL12
        THAT=AMINI**2+AMFIN**2-.5*S12+2.*PINI*PFIN*COSTHL
        UHAT=AMINI**2+AMFIN**2-.5*S12-2.*PINI*PFIN*COSTHL
      ENDIF
C
C          Check W decay
C
      IF(NOGOOD(3)) GO TO 20
C
C          Check W decay with kinematic limits
C
      IF(NOGOOD(4)) GO TO 200
      NKEEP=NKEEP+1
C
C            Set PBEAM
C
      PBEAM(1)=(1.-X1)*HALFE
      PBEAM(2)=(1.-X2)*HALFE
      IF(NJET.LT.3) GO TO 502
      IFL=LISTJ(JETTYP(3))
      EMSQL(3)=AMASS(IFL)**2
502   CONTINUE
C
C          Set PJETS
C
      DO 501 I=1,NJET
        PJETS(3,I)=P(I)*CTH(I)
        PJETS(1,I)=PT(I)*COS(PHI(I))
        PJETS(2,I)=PT(I)*SIN(PHI(I))
        PJETS(4,I)=SQRT(P(I)**2+EMSQL(I))
        PJETS(5,I)=SQRT(EMSQL(I))
        IF(KEYS(7).AND.GOMSSM) THEN
          IDJETS(I)=LISTSS(JETTYP(I))
        ELSE
          IDJETS(I)=LISTJ(JETTYP(I))
        ENDIF
501   CONTINUE
C          No technicolor IDENT's defined, so...
      IF(KEYS(3)) THEN
        IDENTW=LISTW(JWTYP)
      ELSEIF(KEYS(7).AND..NOT.GOMSSM) THEN
        IDENTW=81
      ELSEIF(KEYS(7).AND.GOMSSM) THEN
        IDENTW=IHTYPE
      ELSE
        IDENTW=0
      ENDIF
      DO 503 K=1,4
503   QWJET(K)=PJETS(K,1)+PJETS(K,2)
      QWJET(5)=QMW
C          Set PINITS
      DO 504 I=1,2
        IF(KEYS(7).AND.GOMSSM) THEN
          IDINIT(I)=LISTSS(INITYP(I))
        ELSE
          IDINIT(I)=LISTJ(INITYP(I))
        ENDIF
        PINITS(5,I)=AMASS(IDINIT(I))
        PINITS(1,I)=0.
        PINITS(2,I)=0.
504   CONTINUE
C          Calculate total momentum
      QPL=QWJET(4)+QWJET(3)
      QMN=QWJET(4)-QWJET(3)
      IF(NJET.EQ.3) THEN
        QPL=QPL+PJETS(4,3)+PJETS(3,3)
        QMN=QMN+PJETS(4,3)-PJETS(3,3)
      ENDIF
C          and solve initial kinematics
      AM1SQ=PINITS(5,1)**2
      AM2SQ=PINITS(5,2)**2
      ROOT=SQRT((QPL*QMN-AM1SQ-AM2SQ)**2-4.*AM1SQ*AM2SQ)
      P1PL=(QPL*QMN+AM1SQ-AM2SQ+ROOT)/(2.*QMN)
      P1MN=AM1SQ/P1PL
      P2MN=(QPL*QMN+AM2SQ-AM1SQ+ROOT)/(2.*QPL)
      P2PL=AM2SQ/P2MN
      PINITS(3,1)=.5*(P1PL-P1MN)
      PINITS(4,1)=.5*(P1PL+P1MN)
      PINITS(3,2)=.5*(P2PL-P2MN)
      PINITS(4,2)=.5*(P2PL+P2MN)
      RETURN
C
999   CALL PRTEVT(0)
      WRITE(ITLIS,9999) NTRIES
9999  FORMAT(//' IT IS TAKING MORE THAN',I5,' TRIES TO GENERATE AN',
     C' EVENT. CHECK LIMITS OR INCREASE NTRIES')
      STOP 99
      END
CDECK  ID>, EEBEG.  
      SUBROUTINE EEBEG
C          INITIALIZE E+E- EVENTS FOR DOLOG
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      DO 100 I=1,2
      PMIN(I)=HALFE
      PMAX(I)=-1.E9
100   CONTINUE
      QSQ=SCM
      IDIN(1)=-12
      IDIN(2)=12
      RETURN
      END
CDECK  ID>, EEMAX.  
      SUBROUTINE EEMAX
C          FIND UPPER BOUND FOR E+E- CROSS SECTION SUMMED OVER ALLOWED
C          TYPES.
C          VER 7.17: ENSURE XJMIN < XX < XJMAX
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/EEPAR/SGMXEE,PLEP,PLEM
      SAVE /EEPAR/
      REAL      SGMXEE,PLEP,PLEM
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

      SGMXEE=0.
      NX=50
      IF(FIXYJ(1)) NX=1
      NX1=NX+1
      DX=(XJMAX(1)-XJMIN(1))/NX
C          SCAN IN X=COS(THETA)
      DO 100 IX=1,NX1
      XX=XJMIN(1)+DX*(IX-1)
      IF(XX.LT.XJMIN(1)) XX=XJMIN(1)
      IF(XX.GT.XJMAX(1)) XX=XJMAX(1)
      CTH(1)=XX
      CTH(2)=-XX
      DO 110 I=1,2
      XJ(I)=CTH(I)
      TH(I)=ACOS(CTH(I))
      STH(I)=SIN(TH(I))
      PT(I)=HALFE*STH(I)
      IF(IX.EQ.1) YJ(I)=YJMIN(I)
      IF(IX.EQ.NX1) YJ(I)=YJMAX(I)
      IF(IX.GT.1.AND.IX.LT.NX1)
     1YJ(I)=.5*ALOG((1.+CTH(I))/(1.-CTH(I)))
110   CONTINUE
C          COMPUTE CROSS SECTION
      IF (GOMSSM) THEN
        CALL SIGSSE
      ELSE
        CALL SIGEE
      END IF
      IF(SIGMA.GT.SGMXEE) SGMXEE=SIGMA
100   CONTINUE
C          REQUIRE CROSS SECTION BE POSITIVE
      WRITE(ITLIS,1000) SGMXEE
1000  FORMAT(///' MAXIMUM D(SIGMA)/D(COS THETA) = ',E12.4)
      IF(SGMXEE.GT.0) RETURN
      STOP 99
      END
CDECK  ID>, ELCTRN. 
      SUBROUTINE ELCTRN
C          GENERATE E+ E- ----> QK QB EVENT USING SIGEE CROSS SECTION.
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/EEPAR/SGMXEE,PLEP,PLEM
      SAVE /EEPAR/
      REAL      SGMXEE,PLEP,PLEM
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PINITS/PINITS(5,2),IDINIT(2)
      SAVE /PINITS/
      INTEGER   IDINIT
      REAL      PINITS
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/TOTALS/NKINPT,NWGEN,NKEEP,SUMWT,WT
      SAVE /TOTALS/
      INTEGER   NKINPT,NWGEN,NKEEP
      REAL      SUMWT,WT
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
      REAL AMQ(2),SSXLAM
      INTEGER MSUPL,MSDNL,MSSTL,MSCHL,MSBT1,MSTP1,
     $MSUPR,MSDNR,MSSTR,MSCHR,MSBT2,MSTP2,MSW1,MSW2,
     $MSNEL,MSEL,MSNML,MSMUL,MSNTL,MSTAU1,MSER,MSMUR,MSTAU2,IDSS(85)
      PARAMETER (MSUPL=-ISUPL)
      PARAMETER (MSDNL=-ISDNL)
      PARAMETER (MSSTL=-ISSTL)
      PARAMETER (MSCHL=-ISCHL)
      PARAMETER (MSBT1=-ISBT1)
      PARAMETER (MSTP1=-ISTP1)
      PARAMETER (MSUPR=-ISUPR)
      PARAMETER (MSDNR=-ISDNR)
      PARAMETER (MSSTR=-ISSTR)
      PARAMETER (MSCHR=-ISCHR)
      PARAMETER (MSBT2=-ISBT2)
      PARAMETER (MSTP2=-ISTP2)
      PARAMETER (MSW1=-ISW1)
      PARAMETER (MSW2=-ISW2)
      PARAMETER (MSNEL=-ISNEL)
      PARAMETER (MSEL=-ISEL)
      PARAMETER (MSNML=-ISNML)
      PARAMETER (MSMUL=-ISMUL)
      PARAMETER (MSNTL=-ISNTL)
      PARAMETER (MSTAU1=-ISTAU1)
      PARAMETER (MSER=-ISER)
      PARAMETER (MSMUR=-ISMUR)
      PARAMETER (MSTAU2=-ISTAU2)
      DIMENSION LISTJ(29)
      DATA LISTJ/9,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,
     111,-11,12,-12,13,-13,14,-14,15,-15,16,-16,10,80,-80,90/
      DATA IDSS/0,
     $ISUPL,MSUPL,ISDNL,MSDNL,ISSTL,MSSTL,ISCHL,MSCHL,ISBT1,MSBT1,
     $ISTP1,MSTP1,
     $ISUPR,MSUPR,ISDNR,MSDNR,ISSTR,MSSTR,ISCHR,MSCHR,ISBT2,MSBT2,
     $ISTP2,MSTP2,ISW1,MSW1,ISW2,MSW2,ISZ1,ISZ2,ISZ3,ISZ4,
     $ISNEL,MSNEL,ISEL,MSEL,ISNML,MSNML,ISMUL,MSMUL,
     $ISNTL,MSNTL,ISTAU1,MSTAU1,ISER,MSER,ISMUR,MSMUR,
     $ISTAU2,MSTAU2,
     $9,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,11,-11,12,-12,13,-13,
     $14,-14,15,-15,16,-16,10,80,-80,90,82,83,84,86,-86/
C          ENTRY
      NPTCL=0
      NREJ=-1
      SIGMA=0.
      NSIGS=0
      DO 10 I=1,MXSIGS
10    SIGS(I)=0.
      WT=1.
C          GENERATE NEXT KINEMATIC POINT
100   CONTINUE
      NREJ=NREJ+1
      IF(NREJ.GT.NTRIES) GO TO 9999
      NKINPT=NKINPT+1
      SUMWT=SUMWT+SIGMA*WT
      PHI(1)=PHIMIN(1)+(PHIMAX(1)-PHIMIN(1))*RANF()
      PHI(2)=AMOD(PHI(1)+PI,2.*PI)
      CTH(1)=XJMIN(1)+(XJMAX(1)-XJMIN(1))*RANF()
      CTH(2)=-CTH(1)
      DO 110 I=1,2
      TH(I)=ACOS(CTH(I))
      STH(I)=SIN(TH(I))
      PT(I)=HALFE*STH(I)
      YJ(I)=.5*ALOG((1+CTH(I))/(1-CTH(I)))
      XJ(I)=CTH(I)
110   CONTINUE
C          CALCULATE CROSS SECTION
      IF (GOMSSM) THEN
        CALL SIGSSE
      ELSE
        CALL SIGEE
      END IF
      WT=XJMAX(1)-XJMIN(1)
C          TEST CROSS SECTION
      IF(SIGMA.LT.SGMXEE*RANF()) GO TO 100
      SUMWT=SUMWT+SIGMA*WT
      NKEEP=NKEEP+1
C          SELECT JET TYPES
      SIGINV=1./SIGMA
      TRY=RANF()
      SUM=0.
      DO 200 I=1,NSIGS
      SUM=SUM+SIGS(I)*SIGINV
      IF(SUM.LT.TRY) GO TO 200
C          FIND REACTION
      ISIGS=I
      SIGEVT=SIGS(ISIGS)
      II=INOUT(I)/IOPAK**2
      JETTYP(1)=MOD(II,IOPAK)
      II=II/IOPAK
      JETTYP(2)=MOD(II,IOPAK)
      GO TO 210
200   CONTINUE
      GO TO 9998
C          SET PJETS. RESET P AND PT INCLUDING MASSES.
210   CONTINUE
      IF (GOMSSM) THEN
        AMQ(1)=AMASS(IDSS(JETTYP(1)))
        AMQ(2)=AMASS(IDSS(JETTYP(2)))
      ELSE
        AMQ(1)=AMASS(LISTJ(JETTYP(1)))
        AMQ(2)=AMASS(LISTJ(JETTYP(2)))
      END IF
      PCM=SQRT(SSXLAM(SCM,AMQ(1)**2,AMQ(2)**2))/2./ECM
      DO 220 I=1,2
      PJETS(1,I)=PCM*STH(I)*COS(PHI(I))
      PJETS(2,I)=PCM*STH(I)*SIN(PHI(I))
      PJETS(3,I)=PCM*CTH(I)
      PJETS(4,I)=SQRT(PCM**2+AMQ(I)**2)
      PJETS(5,I)=AMQ(I)
      IF (GOMSSM) THEN
        IDJETS(I)=IDSS(JETTYP(I))
      ELSE
        IDJETS(I)=LISTJ(JETTYP(I))
      END IF
      P(I)=PCM
      PT(I)=P(I)*STH(I)
220   CONTINUE
      RETURN
C          ERROR MESSAGES
9998  CONTINUE
      CALL PRTEVT(0)
      WRITE(ITLIS,1010)
1010  FORMAT(//' ERROR IN ELCTRN...NO GOOD JET TYPES FOUND')
      STOP 99
9999  CONTINUE
      CALL PRTEVT(0)
      WRITE(ITLIS,1020) NTRIES
1020  FORMAT(//' IT IS TAKING MORE THAN',I5,' TRIES TO GENERATE AN',
     $' EVENT. CHECK LIMITS OR INCREASE NTRIES.')
      STOP 99
      END
CDECK  ID>, EPF.
      FUNCTION EPF(A,B,C,D)
C          CALCULATE TOTALLY ANTISYMMETRIC TENSOR EPSILON CONTRACTED
C          WITH FOUR 4-VECTORS.
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      DIMENSION A(4),B(4),C(4),D(4)
      DOUBLE PRECISION EPF
      DOUBLE PRECISION A,B,C,D,CD,BCD
      CD(I,J)=C(I)*D(J)-C(J)*D(I)
      BCD(I,J,K)=B(I)*CD(J,K)-B(J)*CD(I,K)+B(K)*CD(I,J)
      EPF=A(1)*BCD(2,3,4)-A(2)*BCD(1,3,4)+A(3)*BCD(1,2,4)
     1-A(4)*BCD(1,2,3)
      RETURN
      END
CDECK  ID>, EVOL01. 
      SUBROUTINE EVOL01
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-        Setup for process 1 (TWOJET)
C-        Lorentz frames and perform initial and final QCD jet
C-        evolution in leading-log approximation.
C-
C-   Created  13-AUG-1991   Frank E. Paige,Serban D. Protopopescu
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/JWORK2/JVIR(2),PFINAL(5),SGN,ZMIN,ZMAX,DZMAX,JET,GLFORC(2),
     $ZGOOD,JIN(400),FXTEST(MXJSET)
      SAVE /JWORK2/
      LOGICAL GLFORC,ZGOOD
      INTEGER   JVIR,JET,JIN
      REAL      PFINAL,SGN,ZMIN,ZMAX,DZMAX,FXTEST
      COMMON/FRAME/FRAME(5,3),N0JETS,N0W,N0PAIR
      SAVE /FRAME/
      INTEGER   N0JETS,N0W,N0PAIR
      REAL      FRAME
      REAL    EVOLMS
      INTEGER I,K,J,NJSAVE,NJFINL
C----------------------------------------------------------------------
C
C          Copy momenta from /PJETS/ to /JETSET/
      N0JETS=NJSET+1
      CALL IPJSET
      NJSAVE=NJSET
C
C          Set flags and maximum off-shell masses and generate
C          initial QCD parton shower.
C
      CALL ISTRAD(1.0)
C
      IF(NJSET.LT.0) RETURN
C
C          Final state evolution.
C          Define Lorentz frames and JMATCH pointers for jet evolution
C          and fragmentation.
C
      CALL IFRAMS(N0JETS,NJSAVE,1,.FALSE.)
C
C          Set maximum off-shell masses and JDCAY flags.
C
      NJFINL=N0JETS
      DO 310 J=N0JETS,NJSAVE
        IF(IABS(JTYPE(J)).LT.10) THEN
          PJSET(5,J)=EVOLMS(J,1.0)
          JDCAY(J)=-1
        ENDIF
310   CONTINUE
C
C          Produce final-state QCD parton cascade
C
      CALL QCDJET(NJFINL)
C
      RETURN
      END
CDECK  ID>, EVOL02. 
      SUBROUTINE EVOL02
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-        Setup for process 2 (E+E-)
C-        Lorentz frames and perform initial and final QCD jet
C-        evolution in leading-log approximation.
C-
C-   Created  13-AUG-1991   Frank E. Paige,Serban D. Protopopescu
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/JWORK2/JVIR(2),PFINAL(5),SGN,ZMIN,ZMAX,DZMAX,JET,GLFORC(2),
     $ZGOOD,JIN(400),FXTEST(MXJSET)
      SAVE /JWORK2/
      LOGICAL GLFORC,ZGOOD
      INTEGER   JVIR,JET,JIN
      REAL      PFINAL,SGN,ZMIN,ZMAX,DZMAX,FXTEST
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/FRAME/FRAME(5,3),N0JETS,N0W,N0PAIR
      SAVE /FRAME/
      INTEGER   N0JETS,N0W,N0PAIR
      REAL      FRAME
      REAL    EVOLMS
      INTEGER I,K,J,NJSAVE,NJFINL
C----------------------------------------------------------------------
C
C          Copy momenta from /PJETS/ to /JETSET/
      N0JETS=NJSET+1
      CALL IPJSET
      NJSAVE=NJSET
C
C          Final state evolution.
C          Define Lorentz frames and JMATCH pointers for jet evolution
C          and fragmentation.
C
      CALL IFRAMS(N0JETS,NJSAVE,1,.FALSE.)
C
C          Set maximum off-shell masses and JDCAY flags.
C
      NJFINL=N0JETS
      DO 310 J=N0JETS,NJSAVE
        IF((IABS(JTYPE(J)).LT.10).OR.
     $     (IABS(JTYPE(J)).GE.21.AND.IABS(JTYPE(J)).LE.29).OR.
     $     (IABS(JTYPE(J)).GE.41.AND.IABS(JTYPE(J)).LE.46))THEN
          PJSET(5,J)=EVOLMS(J,1.0)
          JDCAY(J)=-1
        ENDIF
310   CONTINUE
C
C          Produce final-state QCD parton cascade
C
      CALL QCDJET(NJFINL)
C
      RETURN
      END
CDECK  ID>, EVOL03. 
      SUBROUTINE EVOL03
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-        Setup for process 3 (DRELLYAN)
C-        Lorentz frames and perform initial and final QCD jet
C-        evolution in leading-log approximation.
C-
C-   Created  13-AUG-1991   Frank E. Paige,Serban D. Protopopescu
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/JWORK2/JVIR(2),PFINAL(5),SGN,ZMIN,ZMAX,DZMAX,JET,GLFORC(2),
     $ZGOOD,JIN(400),FXTEST(MXJSET)
      SAVE /JWORK2/
      LOGICAL GLFORC,ZGOOD
      INTEGER   JVIR,JET,JIN
      REAL      PFINAL,SGN,ZMIN,ZMAX,DZMAX,FXTEST
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/FRAME/FRAME(5,3),N0JETS,N0W,N0PAIR
      SAVE /FRAME/
      INTEGER   N0JETS,N0W,N0PAIR
      REAL      FRAME
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      REAL    EVOLMS,BP
      INTEGER I,K,J,NJFINL
C----------------------------------------------------------------------
C
C          Add W momentum and recoil jets
      N0JETS=NJSET+1
      IF(.NOT.STDDY) THEN
        DO 101 I=3,NJET
          NJSET=NJSET+1
          JORIG(NJSET)=JPACK*I
          JTYPE(NJSET)=IDJETS(I)
          JDCAY(NJSET)=0
          DO 105 K=1,5
105       PJSET(K,NJSET)=PJETS(K,I)
          IFRAME(I)=1
101     CONTINUE
        NJSET=NJSET+1
        N0W=NJSET
        JORIG(NJSET)=0
        JTYPE(NJSET)=IDENTW
        JDCAY(NJSET)=(N0W+1)*JPACK+N0W+2
        DO 120 K=1,5
120     PJSET(K,NJSET)=QWJET(K)
      ENDIF
C
C          Add W decays
      DO 110 I=1,2
        NJSET=NJSET+1
        JORIG(NJSET)=JPACK*I
        JTYPE(NJSET)=IDJETS(I)
        JDCAY(NJSET)=0
        DO 115 K=1,5
115     PJSET(K,NJSET)=PJETS(K,I)
        IFRAME(I)=2
        IF(STDDY) IFRAME(I)=1
110   CONTINUE
C
C          Set flags and maximum off-shell masses and generate
C          initial QCD parton shower.
C
      CALL ISTRAD(WFUDGE)
C
      IF(NJSET.LT.0) RETURN
C
C          Final state evolution.
C          Define Lorentz frames and JMATCH pointers for jet evolution
C          and fragmentation.
C
      IF(STDDY) THEN
        CALL IFRAMS(3,4,1,.FALSE.)
      ELSE
        CALL IFRAMS(N0W+1,N0W+2,2,.FALSE.)
        CALL IFRAMS(N0JETS,N0W,1,.FALSE.)
      ENDIF
C
C          Set maximum off-shell masses and JDCAY flags.
C
      IF(STDDY) THEN
        NJFINL=3
        DO 310 J=3,4
          IF(IABS(JTYPE(J)).LT.10) THEN
            PJSET(5,J)=QMW
            JDCAY(J)=-1
          ENDIF
310     CONTINUE
      ELSE
        NJFINL=N0JETS
        DO 320 J=N0W+1,N0W+2
          IF(IABS(JTYPE(J)).LT.10) THEN
            PJSET(5,J)=QMW
            JDCAY(J)=-1
          ENDIF
320     CONTINUE
C          Need fudge factor for DRELLYAN
        DO 321 J=N0JETS,N0W
          IF(IABS(JTYPE(J)).LT.10) THEN
            PJSET(5,J)=EVOLMS(J,WFUDGE)
            JDCAY(J)=-1
          ENDIF
321     CONTINUE
      ENDIF
C
C          Produce final-state QCD parton cascade
C
      CALL QCDJET(NJFINL)
C
C          Reset FRAME using W momentum modified by evolution
      IF(.NOT.STDDY) THEN
        BP=0.
        DO 400 K=1,3
400     BP=BP+FRAME(K,1)*PJSET(K,N0W)
        BP=BP/FRAME(5,1)
        DO 410 K=1,3
          FRAME(K,2)=PJSET(K,N0W)+FRAME(K,1)*PJSET(4,N0W)/FRAME(5,1)
     $    +FRAME(K,1)*BP/(FRAME(4,1)+FRAME(5,1))
410     CONTINUE
        FRAME(4,2)=FRAME(4,1)*PJSET(4,N0W)/FRAME(5,1)+BP
      ENDIF
C
      RETURN
      END
CDECK  ID>, EVOL05. 
      SUBROUTINE EVOL05
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-        Setup for process 5 (SUPERSYM)
C-        Lorentz frames and perform initial and final QCD jet
C-        evolution in leading-log approximation.
C-
C-   Created  13-AUG-1991   Frank E. Paige,Serban D. Protopopescu
C-
C----------------------------------------------------------------------
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/JWORK2/JVIR(2),PFINAL(5),SGN,ZMIN,ZMAX,DZMAX,JET,GLFORC(2),
     $ZGOOD,JIN(400),FXTEST(MXJSET)
      SAVE /JWORK2/
      LOGICAL GLFORC,ZGOOD
      INTEGER   JVIR,JET,JIN
      REAL      PFINAL,SGN,ZMIN,ZMAX,DZMAX,FXTEST
      COMMON/FRAME/FRAME(5,3),N0JETS,N0W,N0PAIR
      SAVE /FRAME/
      INTEGER   N0JETS,N0W,N0PAIR
      REAL      FRAME
      REAL    EVOLMS
      INTEGER I,K,J,NJSAVE,NJFINL,JTABS
C----------------------------------------------------------------------
C
C          Copy momenta from /PJETS/ to /JETSET/
      N0JETS=NJSET+1
      CALL IPJSET
      NJSAVE=NJSET
C
C          Set flags and maximum off-shell masses and generate
C          initial QCD parton shower.
C
      CALL ISTRAD(1.0)
C
      IF(NJSET.LT.0) RETURN
C
C
C          Final state evolution.
C          Define Lorentz frames and JMATCH pointers for jet evolution
C          and fragmentation.
C
      CALL IFRAMS(N0JETS,NJSAVE,1,.FALSE.)
C
C          Set maximum off-shell masses and JDCAY flags.
C
        NJFINL=N0JETS
        DO 325 J=N0JETS,NJSAVE
          JTABS=IABS(JTYPE(J))
          IF(JTABS.GT.20.AND.JTABS.LT.30) THEN
          PJSET(5,J)=EVOLMS(J,1.0)
          JDCAY(J)=-1
        ENDIF
325   CONTINUE
C
C          Produce final-state QCD parton cascade
C
      CALL QCDJET(NJFINL)
C
      RETURN
      END
CDECK  ID>, EVOL06. 
      SUBROUTINE EVOL06
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-        Setup for process 6 (WPAIR)
C-        Lorentz frames and perform initial and final QCD jet
C-        evolution in leading-log approximation.
C-
C-   Created  13-AUG-1991   Frank E. Paige,Serban D. Protopopescu
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/JWORK2/JVIR(2),PFINAL(5),SGN,ZMIN,ZMAX,DZMAX,JET,GLFORC(2),
     $ZGOOD,JIN(400),FXTEST(MXJSET)
      SAVE /JWORK2/
      LOGICAL GLFORC,ZGOOD
      INTEGER   JVIR,JET,JIN
      REAL      PFINAL,SGN,ZMIN,ZMAX,DZMAX,FXTEST
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/FRAME/FRAME(5,3),N0JETS,N0W,N0PAIR
      SAVE /FRAME/
      INTEGER   N0JETS,N0W,N0PAIR
      REAL      FRAME
      REAL    OFF,BP
      INTEGER I,K,J,NJSAVE,NJFINL,JTRUE
C----------------------------------------------------------------------
C
C          Copy momenta from /PJETS/ to /JETSET/
      N0JETS=NJSET+1
      CALL IPJSET
C
C          Add extra momenta for WPAIR
      N0PAIR=NJSET+1
      DO 130 J=1,NPAIR
        NJSET=NJSET+1
        JORIG(NJSET)=JPACK*JPAIR(J)
        JTYPE(NJSET)=IDPAIR(J)
        JDCAY(NJSET)=0
        DO 135 K=1,5
135     PJSET(K,NJSET)=PPAIR(K,J)
130   CONTINUE
      DO 140 J=1,NPAIR,2
        JET=JPAIR(J)
        JTRUE=N0PAIR+J-1
        JDCAY(N0JETS+JET-1)=JTRUE*JPACK+JTRUE+1
140   CONTINUE
      NJSAVE=NJSET
C
C          Set flags and maximum off-shell masses and generate
C          initial QCD parton shower.
C
      CALL ISTRAD(1.0)
C
      IF(NJSET.LT.0) RETURN
C
C          Final state evolution.
C          Define Lorentz frames and JMATCH pointers for jet evolution
C          and fragmentation.
C
      DO 200 I=3,NJSAVE,2
        JMATCH(I)=I+1
200   JMATCH(I+1)=I
      DO 230 I=1,2
        DO 231 K=1,5
231     FRAME(K,I)=PJSET(K,N0JETS+I-1)
        IFRAME(I)=I
230   CONTINUE
C
C          Set up and generate final state QCD parton shower.
C          Boost PJSET with -FRAME.
C
      DO 240 J=1,NJSAVE
        JET=JORIG(J)/JPACK
        IF(JET.EQ.0) JET=3
        IF(JET.GT.10) GO TO 240
        IF(IDJETS(JET).EQ.10) GO TO 240
C          Do this boost in double precision for 32-bit machines
        CALL DBOOST(-1,FRAME(1,JET),PJSET(1,J))
240   CONTINUE
C
C          Set maximum off-shell masses and JDCAY flags.
C
      NJFINL=N0PAIR
      DO 330 J=1,NPAIR
        IF(IABS(JTYPE(N0PAIR+J-1)).LT.10) THEN
          PJSET(5,N0PAIR+J-1)=PJETS(5,JPAIR(J))
          JDCAY(N0PAIR+J-1)=-1
        ENDIF
330   CONTINUE
C
C          Produce final-state QCD parton cascade
C
      CALL QCDJET(NJFINL)
C
      RETURN
      END
CDECK  ID>, EVOL07. 
      SUBROUTINE EVOL07
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-        Setup for process 7 (HIGGS)
C-        Lorentz frames and perform initial and final QCD jet
C-        evolution in leading-log approximation.
C-
C-   Created  13-AUG-1991   Frank E. Paige,Serban D. Protopopescu
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PINITS/PINITS(5,2),IDINIT(2)
      SAVE /PINITS/
      INTEGER   IDINIT
      REAL      PINITS
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/JWORK2/JVIR(2),PFINAL(5),SGN,ZMIN,ZMAX,DZMAX,JET,GLFORC(2),
     $ZGOOD,JIN(400),FXTEST(MXJSET)
      SAVE /JWORK2/
      LOGICAL GLFORC,ZGOOD
      INTEGER   JVIR,JET,JIN
      REAL      PFINAL,SGN,ZMIN,ZMAX,DZMAX,FXTEST
      COMMON/FRAME/FRAME(5,3),N0JETS,N0W,N0PAIR
      SAVE /FRAME/
      INTEGER   N0JETS,N0W,N0PAIR
      REAL      FRAME
      REAL    EVOLMS,BP
      INTEGER I,K,J,NJSAVE,NJFINL,JTRUE
      DOUBLE PRECISION DPASS(5),DSUM(5)
      INTEGER IDABS1,IDABS2
C----------------------------------------------------------------------
C
C          Copy momenta from /PJETS/ to /JETSET/
      N0JETS=NJSET+1
      CALL IPJSET
C
C          Add extra momenta for WPAIR
      IDABS1=IABS(IDJETS(1))
      IDABS2=IABS(IDJETS(2))
      IF(IDABS1.EQ.80.OR.IDABS1.EQ.90.OR.IDABS2.EQ.80.OR.
     $IDABS2.EQ.90) THEN
        N0PAIR=NJSET+1
        DO 130 J=1,NPAIR
          NJSET=NJSET+1
          JORIG(NJSET)=JPACK*JPAIR(J)
          JTYPE(NJSET)=IDPAIR(J)
          JDCAY(NJSET)=0
          DO 135 K=1,5
135       PJSET(K,NJSET)=PPAIR(K,J)
130     CONTINUE
        DO 140 J=1,NPAIR,2
          JET=JPAIR(J)
          JTRUE=N0PAIR+J-1
          JDCAY(N0JETS+JET-1)=JTRUE*JPACK+JTRUE+1
140     CONTINUE
      ENDIF
      NJSAVE=NJSET
C
C          Set flags and maximum off-shell masses and generate
C          initial QCD parton shower.
C
      IF(IABS(IDINIT(1)).LT.80) THEN
        CALL ISTRAD(1.0)
        IF(NJSET.LT.0) RETURN
C
C
C          Special initial state evolution for W-W fusion.
      ELSE
        CALL HEVOLV
        IF(NJSET.LT.0) RETURN
        DO 141 J=1,NJSET
141     JMATCH(J)=0
        DO 142 JET=1,2
          J=NJSET+1-2*JET
          PJSET(5,J)=-PJSET(5,JET)
142     JDCAY(J)=-2
        CALL QCDINI(NJSET-3,NJSET-1)
        IF(NJSET.LT.0) RETURN
      ENDIF
C
C
C          Final state evolution.
C          Define Lorentz frames and JMATCH pointers for jet evolution
C          and fragmentation.
C
      DO 200 I=3,NJSAVE,2
        JMATCH(I)=I+1
        JMATCH(I+1)=I
200   CONTINUE
      IF(NPAIR.EQ.0) THEN
        CALL DBLVEC(PJSET(1,N0JETS),DSUM)
        CALL DBLVEC(PJSET(1,N0JETS+1),DPASS)
        DO 231 K=1,4
231     DSUM(K)=DSUM(K)+DPASS(K)
        DSUM(5)=DSQRT(DSUM(4)**2-DSUM(1)**2-DSUM(2)**2-DSUM(3)**2)
        DO 232 K=1,5
          FRAME(K,1)=DSUM(K)
          FRAME(K,2)=FRAME(K,1)
232     CONTINUE
      ELSE
        DO 233 I=1,2
          DO 234 K=1,5
            FRAME(K,I)=PJSET(K,N0JETS+I-1)
234       CONTINUE
          IFRAME(I)=I
233     CONTINUE
      ENDIF
C
C          Set up and generate final state QCD parton shower.
C          Boost PJSET with -FRAME.
C
      DO 240 J=1,NJSAVE
        JET=JORIG(J)/JPACK
        IF(JET.EQ.0) JET=3
        IF(JET.GT.10) GO TO 240
C          Do this boost in double precision for 32-bit machines
        CALL DBOOST(-1,FRAME(1,JET),PJSET(1,J))
240   CONTINUE
C
C          Set maximum off-shell masses and JDCAY flags.
C
      IF(NPAIR.EQ.0) THEN
        NJFINL=N0JETS
        DO 340 J=N0JETS,NJSAVE
          IF(IABS(JTYPE(J)).LT.10) THEN
            PJSET(5,J)=EVOLMS(J,1.0)
            JDCAY(J)=-1
          ENDIF
340     CONTINUE
      ELSE
        NJFINL=N0PAIR
        DO 341 J=1,NPAIR
          IF(IABS(JTYPE(N0PAIR+J-1)).LT.10) THEN
            PJSET(5,N0PAIR+J-1)=PJETS(5,JPAIR(J))
            JDCAY(N0PAIR+J-1)=-1
          ENDIF
341     CONTINUE
      ENDIF
C
C          Produce final-state QCD parton cascade
C
      CALL QCDJET(NJFINL)
C
      RETURN
      END
CDECK  ID>, EVOLMS. 
      FUNCTION EVOLMS(J,FUDGE)
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-     Set evolution mass scale for parton J
C-
C-   Returned value  : maximum mass
C-
C-   Inputs  :
C-     J    = index to PJSET array
C-     FUDGE= fudge factor
C-
C-   Created  16-AUG-1991   Serban D. Protopopescu
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      REAL    EVOLMS,FUDGE
      INTEGER J
      COMMON /LIMEVL/ ETTHRS,CONCUT,USELIM
      SAVE /LIMEVL/
      REAL ETTHRS,CONCUT
      LOGICAL USELIM
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
C----------------------------------------------------------------------
C
      IF ( USELIM ) THEN
        EVOLMS=SQRT(PJSET(1,J)**2+PJSET(2,J)**2)*CONCUT
      ELSE
        EVOLMS=FUDGE*SQRT(QSQ)
      ENDIF
  999 RETURN
      END
CDECK  ID>, EVOLVE. 
      SUBROUTINE EVOLVE
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-        Call for each process a subroutine to set up
C-        Lorentz frames and perform initial and final QCD jet
C-        evolution in leading-log approximation.
C-
C-   Created  13-AUG-1991   Frank E. Paige,Serban D. Protopopescu
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PINITS/PINITS(5,2),IDINIT(2)
      SAVE /PINITS/
      INTEGER   IDINIT
      REAL      PINITS
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/JWORK2/JVIR(2),PFINAL(5),SGN,ZMIN,ZMAX,DZMAX,JET,GLFORC(2),
     $ZGOOD,JIN(400),FXTEST(MXJSET)
      SAVE /JWORK2/
      LOGICAL GLFORC,ZGOOD
      INTEGER   JVIR,JET,JIN
      REAL      PFINAL,SGN,ZMIN,ZMAX,DZMAX,FXTEST
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/FRAME/FRAME(5,3),N0JETS,N0W,N0PAIR
      SAVE /FRAME/
      INTEGER   N0JETS,N0W,N0PAIR
      REAL      FRAME
      REAL BP,PINCOM
      INTEGER I,K,J,JJET,IFR
C----------------------------------------------------------------------
C          Initialize
      NJSET=0
      N0JETS=0
      N0W=0
      N0PAIR=0
C
C          Copy momenta from /PINITS/ to /JETSET/
      IF(.NOT.KEYS(2)) THEN
        DO 100 I=1,2
          NJSET=NJSET+1
          JORIG(NJSET)=JPACK*(10+I)
          JTYPE(NJSET)=IDINIT(I)
          JDCAY(NJSET)=JPACK*I+I
          DO 105 K=1,5
105       PJSET(K,NJSET)=PINITS(K,I)
100     CONTINUE
      ENDIF
C
C       Handle each process separately
C
      IF(KEYS(1).OR.KEYS(8)) THEN
        CALL EVOL01
      ELSEIF(KEYS(2)) THEN
        CALL EVOL02
      ELSEIF(KEYS(3)) THEN
        CALL EVOL03
      ELSEIF(KEYS(5)) THEN
        CALL EVOL05
      ELSEIF(KEYS(6)) THEN
        CALL EVOL06
      ELSEIF(KEYS(7).OR.KEYS(9)) THEN
        CALL EVOL07
      ENDIF
C
      IF(NJSET.LT.0) RETURN
C
C          Boost /JETSET/ partons back to PP COM
C
      DO 500 J=1,NJSET
        JJET=JORIG(J)/JPACK
        IF ( JJET.EQ.0 ) THEN
          IFR=1
        ELSE
          IF(JJET.GT.10) GO TO 500
          IF(IDJETS(JJET).EQ.10.AND.KEYS(6)) GO TO 500
          IFR=IFRAME(JJET)
        ENDIF
        BP=0.
        DO 505 K=1,3
505     BP=BP+FRAME(K,IFR)*PJSET(K,J)
        BP=BP/FRAME(5,IFR)
        DO 510 K=1,3
510     PJSET(K,J)=PJSET(K,J)+FRAME(K,IFR)*PJSET(4,J)/FRAME(5,IFR)
     1  +FRAME(K,IFR)*BP/(FRAME(4,IFR)+FRAME(5,IFR))
        PJSET(4,J)=FRAME(4,IFR)*PJSET(4,J)/FRAME(5,IFR)+BP
500   CONTINUE
C
C          Reset PBEAM
      DO 530 J=1,NJSET
        IF(JDCAY(J).EQ.JPACK*J+J) THEN
          JJET=JORIG(J)/JPACK-10
          PINCOM=.5*(PJSET(4,J)+ABS(PJSET(3,J)))
          PBEAM(JJET)=HALFE-PINCOM
        ENDIF
530   CONTINUE
C
C          Check for zero energy partons
      CALL IRMOV0
C
      RETURN
      END
CDECK  ID>, FLAVOR. 
      SUBROUTINE FLAVOR(ID,IFL1,IFL2,IFL3,JSPIN,INDEX)
C
C          This subroutine unpacks the IDENT code ID=+/-IJKL
C
C          Mesons--
C          I=0, J<=K, +/- is sign for J
C          ID=110 for PI0, ID=220 for ETA, etc.
C
C          Baryons--
C          I<=J<=K in general
C          J<I<K for second state antisymmetric in (I,J), eg. L = 2130
C
C          Other--
C          ID=1,...,6 for quarks
C          ID=9 for gluon
C          ID=10 for photon
C          ID=11,...,16 for leptons
C          ID=20 for KS, ID=-20 for KL
C
C          I=21...26 for left scalar quarks
C          I=29 for gluino
C          I=30 for Z1SS
C          I=31...36 for left scalar leptons
C          I=39 for W1SS
C          I=40 for Z2SS
C          I=41...46 for right scalar quarks
C          I=49 for W2SS
C          I=50 for Z3SS
C          I=51...56 for right scalar leptons
C          I=60 for Z4SS
C
C          ID=80 for W+
C          ID=81,...,89 for Higgs mesons
C          ID=90 for Z0
C
C          Incomplete meson multiplets used in b decays:
C          ID=10121     A1+(1260)
C          ID=10111     A10(1260)
C          ID=10131     K1+(1270)
C          ID=10231     K10(1270)
C          ID=30131     K1*+(1400)
C          ID=30231     K1*0(1400)
C          ID=132       K2*+(1430)
C          ID=232       K2*0(1430)
C          ID=10110     F0(980)     (mass = 1000 to allow K+K- decay)
C          ID=112       F2(1270)
C          ID=10441     PSI(2S)
C          ID=20440     CHI0
C          ID=20441     CHI1
C          ID=20442     CHI2
C
C          Diquarks--
C          ID=+/-IJ00, I<J for diquark composed of I,J.
C
C          INDEX is a sequence number used internally
C
C          Ver. 7.03: Make more robust by returning INDEX = 0 for
C          bad ID codes. Does not check for valid baryons, e.g.,
C          uuu with J = 1/2. Test on LABEL(1:3) = 'ERR' for this.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QLMASS/AMLEP(100),NQLEP,NMES,NBARY
      SAVE /QLMASS/
      INTEGER   NQLEP,NMES,NBARY
      REAL      AMLEP
      INTEGER ID,IFL1,IFL2,IFL3,JSPIN,INDEX
      INTEGER I,J,K,IDABS,INDXSP
C
      IDABS=IABS(ID)
C
C          Select case
C
      IF(IDABS.GT.NQLEP-1.AND.IDABS.LT.80) GO TO 400
      IF(IDABS.GT.91.AND.IDABS.LE.100) GO TO 400
C          Quarks: ID < 100
      IF(IDABS.LT.100) GO TO 200
      I=MOD(IDABS/1000,10)
      J=MOD(IDABS/100,10)
      K=MOD(IDABS/10,10)
      JSPIN=MOD(IDABS,10)
C          Special hadrons
      IF(IDABS.GT.10000.OR.JSPIN.GT.1) GO TO 500
      IF(I.EQ.9.OR.J.EQ.9.OR.K.EQ.9) GO TO 400
C          Mesons: 100 < ID < 1000
      IF(IDABS.LT.1000) GO TO 100
C          Diquarks: ID > 1000 but K = 0
      IF(K.EQ.0.AND.JSPIN.EQ.0) GO TO 300
C
C          Baryons
C          Only X,Y baryons are QQX, QQY, Q=U,D,S.
C
      IF(I.GT.K.OR.J.GT.K.OR.J.EQ.0) GO TO 400
      IF(K.GT.6.AND.(I.GT.3.OR.J.GT.3)) GO TO 400
      IFL1=ISIGN(I,ID)
      IFL2=ISIGN(J,ID)
      IFL3=ISIGN(K,ID)
      IF(K.LE.6) THEN
        INDEX=MAX0(I-1,J-1)**2+I+MAX0(I-J,0)+(K-1)*K*(2*K-1)/6
     1  +109*JSPIN+36*NMES+NQLEP+12
      ELSE
        INDEX=MAX0(I-1,J-1)**2+I+MAX0(I-J,0)+9*(K-7)+91
     1  +109*JSPIN+36*NMES+NQLEP+12
      ENDIF
      RETURN
C
C          Mesons
C
100   CONTINUE
      IF(J.GT.K) GO TO 400
      IF(J.EQ.K.AND.ID.LT.0) GO TO 400
      IFL1=0
      IFL2=ISIGN(J,ID)
      IFL3=ISIGN(K,-ID)
      INDEX=J+K*(K-1)/2+36*JSPIN+NQLEP
      INDEX=INDEX+12
      RETURN
C
C          Quarks, leptons, etc
C
200   CONTINUE
      IFL1=0
      IFL2=0
      IFL3=0
      JSPIN=0
      INDEX=IDABS
      IF(IDABS.LT.20) RETURN
C          Define INDEX=20 for KS, INDEX=21 for KL
      INDEX=IDABS+1
      IF(ID.EQ.20) INDEX=20
C          INDEX=NQLEP+1,...,NQLEP+12 for W+, Higgs, Z0, GVSS
      IF(IDABS.LT.80) RETURN
      INDEX=NQLEP+IDABS-79
      RETURN
C
C          Diquarks
C
300   IF(JSPIN.GT.0.OR.I.GT.J) GO TO 400
      IF(I.GT.6.OR.J.GT.6) GO TO 400
      IFL1=ISIGN(I,ID)
      IFL2=ISIGN(J,ID)
      IFL3=0
      JSPIN=0
      INDEX=109*NBARY+36*NMES+NQLEP+12+I+J*(J-1)/2
      RETURN
C
C          Error
C
400   CONTINUE
      IFL1=0
      IFL2=0
      IFL3=0
      JSPIN=0
      INDEX=0
      RETURN
C
C          Special mesons - used only for B decays
C
500   INDXSP=400
      IF(IDABS.EQ.10121) THEN
        INDEX=INDXSP+1
      ELSEIF(IDABS.EQ.10111) THEN
        INDEX=INDXSP+2
      ELSEIF(IDABS.EQ.10131) THEN
        INDEX=INDXSP+3
      ELSEIF(IDABS.EQ.10231) THEN
        INDEX=INDXSP+4
      ELSEIF(IDABS.EQ.30131) THEN
        INDEX=INDXSP+5
      ELSEIF(IDABS.EQ.30231) THEN
        INDEX=INDXSP+6
      ELSEIF(IDABS.EQ.132) THEN
        INDEX=INDXSP+7
      ELSEIF(IDABS.EQ.232) THEN
        INDEX=INDXSP+8
      ELSEIF(IDABS.EQ.10110) THEN
        INDEX=INDXSP+9
      ELSEIF(IDABS.EQ.112) THEN
        INDEX=INDXSP+10
      ELSEIF(IDABS.EQ.10441) THEN
        INDEX=INDXSP+11
      ELSEIF(IDABS.EQ.20440) THEN
        INDEX=INDXSP+12
      ELSEIF(IDABS.EQ.20441) THEN
        INDEX=INDXSP+13
      ELSEIF(IDABS.EQ.20442) THEN
        INDEX=INDXSP+14
      ELSE
        INDEX=0
      ENDIF
      IF(INDEX.GT.0) THEN
        IFL1=0
        IFL2=ISIGN(J,ID)
        IFL3=ISIGN(K,-ID)
      ELSE
        IFL1=0
        IFL2=0
        IFL3=0
      ENDIF
C
      RETURN
      END
CDECK  ID>, FORTOP. 
      SUBROUTINE FORTOP
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-     add to force list forced decays for all heavy q particles
C-     if there was a request to force a heavy q decay
C-     Zero IFORCE after use
C-
C-   Created  15-DEC-1989   Serban D. Protopopescu
C-
C    Ver 7.30: Decay top quark rather than hadron, so no longer needed.
C----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXFORC
      PARAMETER (MXFORC=40)
      COMMON/FORCE/NFORCE,IFORCE(MXFORC),MFORCE(5,MXFORC)
     $,LOOK2(2,MXFORC),LOOKST(MXFORC)
      SAVE /FORCE/
      INTEGER   NFORCE,IFORCE,MFORCE,LOOK2,LOOKST
C----------------------------------------------------------------------
      RETURN
      END
CDECK  ID>, FRGJET. 
      SUBROUTINE FRGJET(JET)
C
C          Hadronize all partons in /JETSET/ corresponding to jet JET.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PINITS/PINITS(5,2),IDINIT(2)
      SAVE /PINITS/
      INTEGER   IDINIT
      REAL      PINITS
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/FRAME/FRAME(5,3),N0JETS,N0W,N0PAIR
      SAVE /FRAME/
      INTEGER   N0JETS,N0W,N0PAIR
      REAL      FRAME
C
      REAL ROT(3,3),POLD(5),PNEW(5),PSUM(5)
      REAL CPHI,SPHI,AMSUM,ESUM,PJ,CTHJ,STHJ,PTJ
      INTEGER K,K1,K2,IP,NPLV1,IFAIL,NBEGIN,JET,NFRAG,NFRGMX,JETJ,
     $JTABS,NFIRST,J
C
      DATA PSUM/5*0./
C
C          NFRAG counter protects against possible infinite loop.
C
      NFRAG=0
      NFRGMX=10*MXJSET
201   NBEGIN=NPTCL+1
      NFRAG=NFRAG+1
C
C          Loop over partons
C
      ESUM=0.
      DO 220 J=1,NJSET
        IF(JDCAY(J).NE.0) GO TO 220
        JETJ=JORIG(J)/JPACK
        IF(JETJ.NE.JET) GO TO 220
        ESUM=ESUM+PJSET(4,J)
C
C          Generate Field-Feynman jet for each quark or gluon, or...
C
        JTABS = IABS(JTYPE(J))
        IF(JTABS.LT.10) THEN
          NFIRST=NPTCL+1
          CALL JETGEN(J)
          IF(NPTCL.LT.NFIRST) GO TO 220
C
C          Rotate hadrons to parton direction
C
          PTJ=PJSET(1,J)**2+PJSET(2,J)**2
          PJ=SQRT(PTJ+PJSET(3,J)**2)
          PTJ=SQRT(PTJ)
C          Following is to fix occasional bug on 32-bit machines
          IF(PJ.GT.0.) THEN
            CTHJ=PJSET(3,J)/PJ
            STHJ=PTJ/PJ
          ELSE
            CTHJ=1.
            STHJ=0.
          ENDIF
          IF(PTJ.GT.0.) THEN
            CPHI=PJSET(1,J)/PTJ
            SPHI=PJSET(2,J)/PTJ
          ELSE
            CPHI=SIGN(1.,PJSET(3,J))
            SPHI=0.
          ENDIF
          ROT(1,1)=CPHI*CTHJ
          ROT(2,1)=SPHI*CTHJ
          ROT(3,1)=-STHJ
          ROT(1,2)=-SPHI
          ROT(2,2)=CPHI
          ROT(3,2)=0.
          ROT(1,3)=CPHI*STHJ
          ROT(2,3)=SPHI*STHJ
          ROT(3,3)=CTHJ
          DO 230 IP=NFIRST,NPTCL
            DO 235 K=1,3
              POLD(K)=PPTCL(K,IP)
              PPTCL(K,IP)=0
235         CONTINUE
            DO 240 K1=1,3
            DO 240 K2=1,3
240         PPTCL(K1,IP)=PPTCL(K1,IP)+ROT(K1,K2)*POLD(K2)
230       CONTINUE
C
C          ... hadronize all other partons with delta function.
C
        ELSE
          IF((IABS(JTYPE(J)).EQ.80.OR.IABS(JTYPE(J)).EQ.90).AND.
     $    .NOT.KEYS(2)) GO TO 210
          IF(NPTCL.GE.MXPTCL) GO TO 9999
          NPTCL=NPTCL+1
          DO 255 K=1,5
            PPTCL(K,NPTCL)=PJSET(K,J)
255       CONTINUE
          IORIG(NPTCL)=-J
          IDENT(NPTCL)=JTYPE(J)
          IDCAY(NPTCL)=0
        ENDIF
220   CONTINUE
C
C          Sum masses and insert jet label
C
      AMSUM=0.
      DO 260 IP=NBEGIN,NPTCL
        AMSUM=AMSUM+PPTCL(5,IP)
        IORIG(IP)=ISIGN(IABS(IORIG(IP))+IPACK*JET,IORIG(IP))
260   CONTINUE
C
C          Require sum of masses less than jet energy.
C
      IF(AMSUM.GT.ESUM.AND.NBEGIN.NE.NPTCL.AND.NFRAG.LT.NFRGMX) THEN
        NPTCL=NBEGIN-1
        GO TO 201
      ENDIF
C
C          For WPAIR events rescale jet to W mass.
C
      IF((KEYS(6).OR.KEYS(7).OR.KEYS(9)).AND.JET.LT.10) THEN
        IF(IABS(JTYPE(JET+N0JETS-1)).LT.80) RETURN
        IF(AMSUM.GE.PJSET(5,JET+N0JETS-1)) THEN
          IF(NFRAG.GT.NFRGMX) RETURN
          NPTCL=NBEGIN-1
          GO TO 201
        ENDIF
        PSUM(4)=PJSET(5,JET+N0JETS-1)
        PSUM(5)=PSUM(4)
        NPLV1=NPTCL
        CALL RESCAL(NBEGIN,NPLV1,PSUM,IFAIL)
      ENDIF
C
210   RETURN
C
C          Error
C
9999  CALL PRTEVT(0)
      WRITE(ITLIS,9998) NPTCL
9998  FORMAT(//' ERROR IN FRGJET ... NPTCL > ',I6)
      RETURN
      END
CDECK  ID>, FRGMNT. 
      SUBROUTINE FRGMNT
C
C          Control jet fragmentation.  Boost to frames defined in
C          EVOLVE and call JETGEN.
C
C          EVOLVE initializes /PJSET/ as follows--
C          1      - 2            = PINITS (except for E+E-)
C          N0W    - N0W          = QWJET  (for DRELLYAN, NJET=3)
C          N0JETS - N0JETS+NJET  = PJETS
C          N0PAIR - N0PAIR+NPAIR = PPAIR  (for WPAIR)
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PINITS/PINITS(5,2),IDINIT(2)
      SAVE /PINITS/
      INTEGER   IDINIT
      REAL      PINITS
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/FRAME/FRAME(5,3),N0JETS,N0W,N0PAIR
      SAVE /FRAME/
      INTEGER   N0JETS,N0W,N0PAIR
      REAL      FRAME
C
      REAL PSUM(5),PALLJ(5),P12(5),PIN(5,2),PWREST(5),PADD(5)
      REAL POLD(5),PNEW(5)
      REAL PINPL,PINMN,BP,PT2AVE,PTADD,RANF,PHIADD,PALLPL,PALLMN
      REAL PALLX,PALLY
      INTEGER K,J,JJET,NZERO,IB,NPTCL1,NPTCL2,IFAIL,JET,NPJET1,NPLV1
      INTEGER NPJET3,IP,NP1,NP2,NFIRST,IP1,IFR,NLJ
      DOUBLE PRECISION DSUM(5),DPASS(5)
C
C          Initialize
      DO 100 K=1,5
100   DSUM(K)=0.
      NLJ=NJET
      IF(KEYS(3)) NLJ=NJET+1
      DO 101 J=1,NLJ
        JJET=N0JETS+J-1
        IF(JJET.EQ.N0W) GOTO 101
        CALL DBLVEC(PJSET(1,JJET),DPASS)
        DO 102 K=1,4
102     DSUM(K)=DSUM(K)+DPASS(K)
101   CONTINUE
      DSUM(5)=DSQRT(DSUM(4)**2-DSUM(1)**2-DSUM(2)**2-DSUM(3)**2)
      DO 103 K=1,5
103   PALLJ(K)=DSUM(K)
C
      NZERO=NPTCL+1
C
C          Fragment partons from initial state shower
C
      IF(.NOT.KEYS(2)) THEN
        DO 110 J=1,NJSET
          IF(JDCAY(J).EQ.JPACK*J+J) THEN
            IB=JORIG(J)/JPACK-10
            DO 120 K=1,5
120         PIN(K,IB)=PJSET(K,J)
          ENDIF
110     CONTINUE
C
        CALL FRGJET(11)
        CALL FRGJET(12)
C
        NPTCL1=NPTCL+1
        NPTCL2=NPTCL1+1
        IF(NPTCL1.GT.MXPTCL) GO TO 9999
        PINPL=.5*(PIN(4,1)+PIN(3,1)+PIN(4,2)+PIN(3,2))
        PINMN=.5*(PIN(4,1)-PIN(3,1)+PIN(4,2)-PIN(3,2))
        PPTCL(1,NPTCL1)=0.
        PPTCL(2,NPTCL1)=0.
        PPTCL(3,NPTCL1)=HALFE-PINPL
        PPTCL(4,NPTCL1)=HALFE-PINPL
        PPTCL(5,NPTCL1)=0.
        PPTCL(1,NPTCL2)=0.
        PPTCL(2,NPTCL2)=0.
        PPTCL(3,NPTCL2)=-(HALFE-PINMN)
        PPTCL(4,NPTCL2)=HALFE-PINMN
        PPTCL(5,NPTCL2)=0.
        DO 130 K=1,4
130     PSUM(K)=-PALLJ(K)
        PSUM(4)=PSUM(4)+ECM
        PSUM(5)=PSUM(4)**2-PSUM(1)**2-PSUM(2)**2-PSUM(3)**2
        IF(PSUM(5).GE.0.) THEN
          PSUM(5)=SQRT(PSUM(5))
          CALL RESCAL(NZERO,NPTCL2,PSUM,IFAIL)
        ENDIF
C
        DO 140 K=1,4
140     PBEAMS(K)=PPTCL(K,NPTCL1)+PPTCL(K,NPTCL2)
        PBEAMS(5)=SQRT(PBEAMS(4)**2-PBEAMS(1)**2-PBEAMS(2)**2
     $  -PBEAMS(3)**2)
      ENDIF
C
C          Boost partons from final jets with -FRAME
C
200   DO 210 J=1,NJSET
        JET=JORIG(J)/JPACK
        IF ( JET.EQ.0 ) THEN
          IFR=1
        ELSE
          IF(JET.GT.10) GO TO 210
          IF(IDJETS(JET).EQ.10.AND.KEYS(6)) GO TO 210
          IFR=IFRAME(JET)
        ENDIF
C
C          Do this boost in double precision for 32-bit machines
        CALL DBOOST(-1,FRAME(1,IFR),PJSET(1,J))
210   CONTINUE
C
C          Fragment partons from final jets
C
      NPJET1=NPTCL+1
      DO 220 K=1,4
220   PSUM(K)=0
C
C          Conserve mass of 1+2 for DRELLYAN (automatic for WPAIR)
C
      IF(KEYS(3)) THEN
        CALL FRGJET(1)
        CALL FRGJET(2)
        IF(STDDY) THEN
          DO 230 K=1,4
            PSUM(K)=PJSET(K,3)+PJSET(K,4)
  230     CONTINUE
        ELSE
          DO 240 K=1,4
            PSUM(K)=PJSET(K,N0W+1)+PJSET(K,N0W+2)
  240     CONTINUE
        ENDIF
        PSUM(5)=SQRT(PSUM(4)**2-PSUM(1)**2-PSUM(2)**2-PSUM(3)**2)
        NPLV1=NPTCL
        CALL RESCAL(NPJET1,NPLV1,PSUM,IFAIL)
      ELSE
        DO 242 J=1,NJET
          JJET=N0JETS+J-1
          CALL FRGJET(J)
          DO 243 K=1,4
  243     PSUM(K)=PSUM(K)+PJSET(K,JJET)
  242   CONTINUE
        PSUM(5)=SQRT(PSUM(4)**2-PSUM(1)**2-PSUM(2)**2-PSUM(3)**2)
        NPLV1=NPTCL
        CALL RESCAL(NPJET1,NPLV1,PSUM,IFAIL)
      ENDIF
C
C           Add extra jets for DRELLYAN
      IF(KEYS(3).AND..NOT.STDDY) THEN
        NPJET3=NPTCL+1
        DO 245 J=3,NJET
245     CALL FRGJET(J)
        NPTCL1=NPTCL+1
        IF(NPTCL1.GT.MXPTCL) GO TO 9999
        DO 250 K=1,4
          PPTCL(K,NPTCL1)=PJSET(K,N0W)
250     PSUM(K)=PJSET(K,N0W)
        PPTCL(5,NPTCL1)=PJSET(5,N0W)
        DO 246 J=3,NJET
          JJET=N0JETS+J-3
          DO 246 K=1,4
            PSUM(K)=PSUM(K)+PJSET(K,JJET)
  246   CONTINUE
        PSUM(5)=SQRT(PSUM(4)**2-PSUM(1)**2-PSUM(2)**2-PSUM(3)**2)
        CALL RESCAL(NPJET3,NPTCL1,PSUM,IFAIL)
        DO 260 K=1,5
260     PWREST(K)=PPTCL(K,NPTCL1)
      ENDIF
C
C          Boost partons back to PP COM
C
      DO 300 J=1,NJSET
        JET=JORIG(J)/JPACK
        IF ( JET.EQ.0 ) THEN
          IFR=1
        ELSE
          IF(JET.GT.10) GO TO 300
          IF(IDJETS(JET).EQ.10.AND.KEYS(6)) GO TO 300
          IFR=IFRAME(JET)
        ENDIF
        BP=0.
        DO 305 K=1,3
305     BP=BP+FRAME(K,IFR)*PJSET(K,J)
        BP=BP/FRAME(5,IFR)
        DO 310 K=1,3
310     PJSET(K,J)=PJSET(K,J)+FRAME(K,IFR)*PJSET(4,J)/FRAME(5,IFR)
     $  +FRAME(K,IFR)*BP/(FRAME(4,IFR)+FRAME(5,IFR))
        PJSET(4,J)=FRAME(4,IFR)*PJSET(4,J)/FRAME(5,IFR)+BP
300   CONTINUE
C
C          Reset FRAME to boost hadrons to PP COM
C
      IF(KEYS(1).OR.KEYS(2).OR.(KEYS(3).AND.NJET.EQ.2).OR.KEYS(5)
     $.OR.(KEYS(7).AND.NPAIR.EQ.0).OR.KEYS(8)) THEN
        DO 410 K=1,5
          FRAME(K,1)=PALLJ(K)
410     CONTINUE
      ELSEIF(KEYS(3).AND.NJET.GT.2) THEN
        DO 420 K=1,5
420     FRAME(K,1)=PALLJ(K)
        BP=0.
        DO 430 K=1,3
430     BP=BP+FRAME(K,1)*PWREST(K)
        BP=BP/FRAME(5,1)
        DO 440 K=1,3
          FRAME(K,2)=PWREST(K)+FRAME(K,1)*PWREST(4)/FRAME(5,1)
     $    +FRAME(K,1)*BP/(FRAME(4,1)+FRAME(5,1))
440     CONTINUE
        FRAME(4,2)=FRAME(4,1)*PWREST(4)/FRAME(5,1)+BP
      ENDIF
C
C          Boost hadrons back to PP COM
C
      DO 500 IP=NZERO,NPTCL
        JET=IABS(IORIG(IP))/IPACK
        IF(JET.GT.10) GO TO 500
        IF(IDJETS(JET).EQ.10.AND.KEYS(6)) GO TO 500
        IFR=IFRAME(JET)
        BP=0.
        DO 510 K=1,3
510     BP=BP+FRAME(K,IFR)*PPTCL(K,IP)
        BP=BP/FRAME(5,IFR)
        DO 520 K=1,3
520     PPTCL(K,IP)=PPTCL(K,IP)+FRAME(K,IFR)*PPTCL(4,IP)/FRAME(5,IFR)
     $  +FRAME(K,IFR)*BP/(FRAME(4,IFR)+FRAME(5,IFR))
        PPTCL(4,IP)=FRAME(4,IFR)*PPTCL(4,IP)/FRAME(5,IFR)+BP
500   CONTINUE
C
C          Add intrinsic PT
C
      IF(.NOT.KEYS(2)) THEN
        PT2AVE=.1*SQRT(QSQ)
        PTADD=SQRT(-PT2AVE*ALOG(RANF()))
        PHIADD=2.*PI*RANF()
        PADD(1)=2.*PTADD*COS(PHIADD)
        PADD(2)=2.*PTADD*SIN(PHIADD)
C          Must use large and small components carefully to calculate
C          mass on 32-bit machines.
        PALLPL=0.
        PALLMN=0.
        PALLX=0.
        PALLY=0.
        DO 525 IP=NZERO,NPTCL
          PALLX=PALLX+PPTCL(1,IP)
          PALLY=PALLY+PPTCL(2,IP)
          IF(PPTCL(3,IP).GT.0.) THEN
            PALLPL=PALLPL+(PPTCL(4,IP)+PPTCL(3,IP))
            PALLMN=PALLMN+(PPTCL(1,IP)**2+PPTCL(2,IP)**2+PPTCL(5,IP)**2)
     $      /(PPTCL(4,IP)+PPTCL(3,IP))
          ELSE
            PALLMN=PALLMN+(PPTCL(4,IP)-PPTCL(3,IP))
            PALLPL=PALLPL+(PPTCL(1,IP)**2+PPTCL(2,IP)**2+PPTCL(5,IP)**2)
     $      /(PPTCL(4,IP)-PPTCL(3,IP))
          ENDIF
525     CONTINUE
        POLD(1)=PALLX
        POLD(2)=PALLY
        POLD(3)=.5*(PALLPL-PALLMN)
        POLD(4)=.5*(PALLPL+PALLMN)
        POLD(5)=SQRT(PALLPL*PALLMN-PALLX**2-PALLY**2)
        PNEW(1)=PADD(1)+POLD(1)
        PNEW(2)=PADD(2)+POLD(2)
        PNEW(3)=POLD(3)
        PNEW(4)=SQRT(PNEW(1)**2+PNEW(2)**2+PNEW(3)**2+POLD(5)**2)
        PNEW(5)=POLD(5)
C
        DO 530 IP=NZERO,NPTCL
          BP=0.
          DO 531 K=1,3
531       BP=BP+POLD(K)*PPTCL(K,IP)
          BP=BP/POLD(5)
          DO 532 K=1,3
532       PPTCL(K,IP)=PPTCL(K,IP)-POLD(K)*PPTCL(4,IP)/POLD(5)
     $    +POLD(K)*BP/(POLD(4)+POLD(5))
          PPTCL(4,IP)=PPTCL(4,IP)*POLD(4)/POLD(5)-BP
C
          BP=0.
          DO 533 K=1,3
533       BP=BP+PNEW(K)*PPTCL(K,IP)
          BP=BP/PNEW(5)
          DO 534 K=1,3
534       PPTCL(K,IP)=PPTCL(K,IP)+PNEW(K)*PPTCL(4,IP)/PNEW(5)
     $    +PNEW(K)*BP/(PNEW(4)+PNEW(5))
          PPTCL(4,IP)=PPTCL(4,IP)*PNEW(4)/PNEW(5)+BP
530     CONTINUE
C
C            Add opposite PT to beam jets
        DO 541 K=1,4
541     PBEAMS(K)=-PNEW(K)
        PBEAMS(4)=PBEAMS(4)+ECM
        PBEAMS(5)=PBEAMS(4)**2-PBEAMS(1)**2-PBEAMS(2)**2 -PBEAMS(3)**2
        IF ( PBEAMS(5).GT.0 ) THEN
          PBEAMS(5)=SQRT(PBEAMS(5))
        ELSE
          PBEAMS(4)=SQRT(PBEAMS(4)**2-PBEAMS(5)+4.)
          PBEAMS(5)=2.
        ENDIF
      ENDIF
C
C          Decay hadrons
C
      NP1=NZERO
600   NP2=NPTCL
      DO 610 IP=NP1,NP2
        NFIRST=NPTCL+1
        JET=IABS(IORIG(IP))/IPACK
        CALL DECAY(IP)
        DO 620 IP1=NFIRST,NPTCL
620     IORIG(IP1)=ISIGN(IABS(IORIG(IP1))+IPACK*JET,IORIG(IP1))
610   CONTINUE
      NP1=NP2+1
      IF(NP1.LE.NPTCL) GO TO 600
      RETURN
C
C          Error
C
9999  CALL PRTEVT(0)
      WRITE(ITLIS,9998) NPTCL
9998  FORMAT(//' ERROR IN FRGMNT ... NPTCL > ',I6)
      RETURN
      END
CDECK  ID>, GAMMA.  
      FUNCTION GAMMA(X)
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      DIMENSION C(13)
      DATA C
     1/ 0.00053 96989 58808, 0.00261 93072 82746, 0.02044 96308 23590,
     2  0.07309 48364 14370, 0.27964 36915 78538, 0.55338 76923 85769,
     3  0.99999 99999 99998,-0.00083 27247 08684, 0.00469 86580 79622,
     4  0.02252 38347 47260,-0.17044 79328 74746,-0.05681 03350 86194,
     5  1.13060 33572 86556/
      Z=X
      IF(X .GT. 0.0) GO TO 1
      IF(X .EQ. AINT(X)) GO TO 5
      Z=1.0-Z
    1 F=1.0/Z
      IF(Z .LE. 1.0) GO TO 4
      F=1.0
    2 IF(Z .LT. 2.0) GO TO 3
      Z=Z-1.0
      F=F*Z
      GO TO 2
    3 Z=Z-1.0
    4 GAMMA=
     1 F*((((((C(1)*Z+C(2))*Z+C(3))*Z+C(4))*Z+C(5))*Z+C(6))*Z+C(7))/
     2   ((((((C(8)*Z+C(9))*Z+C(10))*Z+C(11))*Z+C(12))*Z+C(13))*Z+1.0)
      IF(X .GT. 0.0) RETURN
      GAMMA=3.141592653589793/(SIN(3.141592653589793*X)*GAMMA)
      RETURN
    5 GAMMA=0.
      WRITE(ITLIS,10) X
      RETURN
   10 FORMAT(1X,'GAMMA ... ARGUMENT IS NON-POSITIVE INTEGER = ',E20.5)
      END
CDECK  ID>, GETPT.  
      SUBROUTINE GETPT(PT0,PTMEAN)
C          GENERATE PT WITH 1/(1+B*PT**2)**4 DISTRIBUTION
C          (APPROXIMATELY AN EXPONENTIAL FOR PT < 2 GEV.)
C          CON1=16/(3*PI)
C          CON2=-1/3
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      DATA CON1/1.697652726/,CON2/-.3333333333/
      R=RANF()
      ARG=AMAX1(R**CON2-1.,0.)
      PT0=PTMEAN*CON1*SQRT(ARG)
      RETURN
      END
CDECK  ID>, GETTOT. 
      SUBROUTINE GETTOT(PRFLAG)
C
C          Calculate total cross section within jet limits.
C          If PRFLAG=.TRUE. print summary.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/FINAL/NKINF,SIGF,ALUM,ACCEPT,NRECS
      SAVE /FINAL/
      INTEGER   NKINF,NRECS
      REAL      SIGF,ALUM,ACCEPT
      COMMON/TIMES/TIME1,TIME2
      SAVE /TIMES/
      REAL      TIME1,TIME2
      COMMON/TOTALS/NKINPT,NWGEN,NKEEP,SUMWT,WT
      SAVE /TOTALS/
      INTEGER   NKINPT,NWGEN,NKEEP
      REAL      SUMWT,WT
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/TYPES/LOC(100),NTYP,NJTTYP(3),NWWTYP(2),NWMODE(3)
      COMMON/XTYPES/PARTYP(40),TITLE(10),JETYP(30,3),WWTYP(30,2)
     $,WMODES(30,3)
      SAVE /TYPES/,/XTYPES/
      CHARACTER*8 JETYP,WWTYP,TITLE,PARTYP,WMODES
      INTEGER   LOC,NTYP,NJTTYP,NWWTYP,NWMODE
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/SEED/XSEED
      SAVE /SEED/
      CHARACTER*24 XSEED
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/ISLOOP/NEVOLV,NFRGMN,IEVOL,IFRG
      SAVE /ISLOOP/
      INTEGER NEVOLV,NFRGMN,IEVOL,IFRG
C
      REAL DELPHI,SIGF2,FRAC,TMEAN,ALUM2,SIGF3
      LOGICAL PRFLAG
C
C          Calculate jet cross sections
C
      SIGF=0.
      ALUM=0.
      ACCEPT=0.
      NKINF=NKINPT
      IF(NKINPT.GT.0) THEN
        SIGF=SUMWT/NKINPT
        DELPHI=2.*PI
        IF(KEYS(1).OR.KEYS(2).OR.KEYS(5).OR.KEYS(6).OR.KEYS(8)
     $  .OR.KEYS(9)) THEN
          DELPHI=PHIMAX(1)-PHIMIN(1)
        ELSEIF(KEYS(3).AND..NOT.STDDY) THEN
          DELPHI=PHWMAX-PHWMIN
        ENDIF
        SIGF=SIGF*DELPHI/(2.*PI)
      ENDIF
C
C          Print summary if desired
C
      IF(.NOT.PRFLAG) RETURN
C
C          Print header and title
      WRITE(ITLIS,100)
100   FORMAT('1',30('*')/' *',28X,'*'/
     1' *',5X,'ISAJET RUN SUMMARY',5X,'*'/
     2' *',28X,'*'/1X,30('*')//)
      WRITE(ITLIS,101) TITLE
101   FORMAT(//11X,10A8)
      IF(NKINPT.EQ.0) GO TO 300
C
C          Print cross section
      WRITE(ITLIS,102) NKINPT
102   FORMAT(//' NO. KINEMATIC POINTS GENERATED          =',I13)
      SIGF2=SIGF*NEVOLV*NFRGMN
      WRITE(ITLIS,103) SIGF2
103   FORMAT(//' MONTE CARLO JET CROSS SECTION           =',E13.4,' MB')
      IF(SIGF.EQ.0.) WRITE(ITLIS,111)
111   FORMAT(' CROSS SECTION IS ZERO IF VARIABLES ARE FIXED')
C
C          Print W decay acceptance
      IF(KEYS(3)) THEN
        ACCEPT=FLOAT(NKEEP)/FLOAT(NWGEN)
        WRITE(ITLIS,105) ACCEPT
105     FORMAT(//' ACCEPTANCE FOR W DECAYS                 =',E13.4)
      ELSEIF(KEYS(7)) THEN
        ACCEPT=FLOAT(NKEEP)/FLOAT(NWGEN)
        WRITE(ITLIS,106) ACCEPT
106     FORMAT(//' ACCEPTANCE FOR H DECAYS                 =',E13.4)
      ENDIF
C
C          Print luminosity
      IF(SIGF.GT.0.) THEN
        ALUM=NEVENT/SIGF
        IF(KEYS(4)) ALUM=NKINPT/SIGF
        WRITE(ITLIS,104) ALUM
104     FORMAT(//' EQUIVALENT INTEGRAL LUMINOSITY          =',E13.4,
     $  ' /MB')
      ENDIF
C
C          Print statistics for multiple evolution and fragmentation
      IF(NEVOLV.GT.1.OR.NFRGMN.GT.1) THEN
        FRAC=FLOAT(IEVGEN)/FLOAT(IEVT)
        WRITE(ITLIS,201) IEVGEN
201     FORMAT(//' NUMBER OF ACCEPTED EVENTS               =',I13)
        WRITE(ITLIS,202) FRAC
202     FORMAT(' FRACTION OF ACCEPTED EVENTS             =',E13.4)
        SIGF3=SIGF2*FRAC
        WRITE(ITLIS,203) SIGF3
203     FORMAT(' CROSS SECTION FOR ACCEPTED EVENTS       =',E13.4)
      ENDIF
C
C          Print mean time per event
300   TMEAN=(TIME2-TIME1)/NEVENT
      WRITE(ITLIS,301) TMEAN
301   FORMAT(//' MEAN TIME PER GENERATED EVENT           =',E13.4,
     $' SEC')
C
C          Print final seed
      CALL RANFMT
      WRITE(ITLIS,302) XSEED
302   FORMAT(//' FINAL RANDOM NUMBER SEED                =',A24)
C
C          Print run identifier
      WRITE(ITLIS,303) IDG
303   FORMAT(//' END OF ISAJET RUN                       =',2I9)
      RETURN
      END
CDECK  ID>, HEAVYX. 
      SUBROUTINE HEAVYX(X,EPS)
C
C          GENERATE X FOR HEAVY PARTICLE FRAGMENTATION ACCORDING TO
C          THE PETERSON FORM
C          D(X)=1/(X*(1-1/X-EPS/(1-X))**2)
C              =D0(X)*D1(X)*D2(X)
C          D0(X)=(1-X)**2/((1-X)**2+EPS)**2
C          D1(X)=X
C          D2(X)=(((1-X)**2+EPS)/((1-X)**2+EPS*X))**2
C          USING X=1-Y**POW
C
      DATA ALN4/1.3863/
C
C          CHOOSE POW FOR X=1-Y**POW.
C          GENERATE FLAT IN X IF EPS>1.
      IF(EPS.LT.1.) THEN
        POW=ALOG((3.+EPS)/EPS)/ALN4
        YMX=(EPS*(3.*POW-1.)/(POW+1.))**(.5/POW)
        ZMX=1-YMX**POW
        D0MX=(1-ZMX)**2/((1.-ZMX)**2+EPS)**2*POW*YMX**(POW-1.)
        D2MX=2./(2.-SQRT(EPS))
      ELSE
        POW=1.
        ZMX=0.
        D0MX=(1.-ZMX)**2/((1.-ZMX)**2+EPS)**2
        D2MX=1.+EPS
      ENDIF
C
C          GENERATE Z ACCORDING TO (1-Z)**2/((1-Z)**2+EPS*Z)**2
1     CONTINUE
      Y=RANF()
      Z=1.-Y**POW
C
      D0Z=(1.-Z)**2/((1.-Z)**2+EPS)**2*POW*Y**(POW-1.)
      IF(D0Z.LT.RANF()*D0MX) GO TO 1
C
C          CHECK REMAINING FACTORS
      D1=Z
      D2=(((1.-Z)**2+EPS)/((1.-Z)**2+EPS*Z))**2
      IF(D1*D2.LT.RANF()*D2MX) GO TO 1
C
C          GOOD X
      X=Z
      RETURN
      END
CDECK  ID>, HEVOLV. 
      SUBROUTINE HEVOLV
C
C          CARRY OUT BACKWARDS EVOLUTION QK --> QK + W FOR LONGITUDINAL
C          W-W FUSION, GENERATING Z AND KT**2 FROM RELATION OF W AND
C          QUARK STRUCTURE FUNCTIONS.
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
C
      DIMENSION X(2)
      EQUIVALENCE (X1,X(1))
      DIMENSION FZIQ(13),IWPICK(2),PFINAL(5),BST1(5),BST2(5),B2B1(5)
      DIMENSION PSAVE(5,2)
C          LAMBDA FUNCTION
      ALAMF(A,B,C)=SQRT((A-B-C)**2-4.*B*C)
C
      NJSAVE=NJSET
      NREJ2=-1
C
C          INITIALIZE
      DO 10 I=1,2
      DO 10 K=1,5
10    PSAVE(K,I)=PJSET(K,I)
20    CONTINUE
      DO 30 I=1,2
      DO 30 K=1,5
30    PJSET(K,I)=PSAVE(K,I)
      DO 40 K=1,5
40    PFINAL(K)=QWJET(K)
      NJSET=NJSAVE
C
C          CHOOSE A W AND DO BACKWARDS EVOLUTION FOR QK -> QK + W.
C
      IF(RANF().LT..5) THEN
        IWPICK(1)=1
        IWPICK(2)=2
        SGN=+1.
      ELSE
        IWPICK(1)=2
        IWPICK(2)=1
        SGN=-1.
      ENDIF
      DO 100 JJ=1,2
C
C          OTHER PARTICLE IS W FOR JJ=1, QUARK FOR JJ=2:
      IF(JJ.EQ.1) THEN
        J1=IWPICK(1)
        J2=IWPICK(2)
      ELSE
        J1=IWPICK(2)
        J2=NJSAVE+1
        SGN=-SGN
      ENDIF
      JTLV1=JTYPE(J1)
      IF(JTLV1.EQ.10) THEN
        IW=1
      ELSEIF(JTLV1.EQ.80) THEN
        IW=2
      ELSEIF(JTLV1.EQ.-80) THEN
        IW=3
      ELSEIF(JTLV1.EQ.90) THEN
        IW=4
      ENDIF
      XV=(PJSET(4,J1)+ABS(PJSET(3,J1)))/ECM
      AMV=AMASS(JTLV1)
C
C          GENERATE VARIABLES FOR BRANCHING
C          FIND MAXIMUM OF INTEGRAND USING 20 POINTS IN LOG(Z)
      FMAX=0.
      ZMULT=(1./XV)**.05
      ZIZ=XV
      DO 110 IZ=1,19
      ZIZ=ZIZ*ZMULT
      FSUM=0.
      DO 115 IQ=2,13
      IF(MATCH(IQ,IW).NE.0) THEN
        IFL=IQ/2
        CIQ=AQ(IFL,IW)**2+BQ(IFL,IW)**2
        FSUM=FSUM+CIQ*(1.-ZIZ)/ZIZ*STRUC(XV/ZIZ,AMV**2,IQ,IDIN(J1))
      ENDIF
115   CONTINUE
      FMAX=AMAX1(FMAX,FSUM)
110   CONTINUE
C          GENERATE Z UNIFORMLY IN (XV,1) AND TEST
      NREJ1=-1
120   ZV=XV+(1.-XV)*RANF()
      FZ=0.
      DO 130 IQ=2,13
      IF(MATCH(IQ,IW).NE.0) THEN
        IFL=IQ/2
        CIQ=AQ(IFL,IW)**2+BQ(IFL,IW)**2
        FZIQ(IQ)=CIQ*(1.-ZV)/ZV*STRUC(XV/ZV,AMV**2,IQ,IDIN(J1))
      ELSE
        FZIQ(IQ)=0.
      ENDIF
130   FZ=FZ+FZIQ(IQ)
      IF(FZ.LT.FMAX*RANF()) THEN
        NREJ1=NREJ1+1
        IF(NREJ1.GT.NTRIES) GO TO 9999
        GO TO 120
      ENDIF
C          DETERMINE QUARK TYPE
      TRY=RANF()
      SUM=0.
      DO 140 IQ=2,13
      IQ1=IQ
      SUM=SUM+FZIQ(IQ)/FZ
140   IF(SUM.GT.TRY) GO TO 150
150   IQ3=MATCH(IQ1,IW)
      IQ3=MATCH(IQ3,4)
C          GENERATE T=-K**2 AND UNIFORM PHI
      T=AMV**2*(1./RANF()-1.)
      PHIK=2.*PI*RANF()
C
C          SOLVE KINEMATICS FOR THIS SIDE
      S=(PJSET(4,J1)+PJSET(4,J2))**2-(PJSET(1,J1)+PJSET(1,J2))**2
     $-(PJSET(2,J1)+PJSET(2,J2))**2-(PJSET(3,J1)+PJSET(3,J2))**2
      SP=S/ZV
      IFL1=IQ1/2
      IFL2=JTYPE(J2)
      IFL3=IQ3/2
      AM1=AMASS(IFL1)
      AM2=PJSET(5,J2)
      AM3=AMASS(IFL3)
      AM1SQ=AM1**2
      AM2SQ=AM2**2
      AM3SQ=AM3**2
      IF(SGN.LT.0.) THEN
        P2PL=PJSET(4,J2)+PJSET(3,J2)
        P2MN=AM2SQ/P2PL
      ELSE
        P2MN=PJSET(4,J2)-PJSET(3,J2)
        P2PL=AM2SQ/P2MN
      ENDIF
C          STEP 1: SOLVE FOR PP1=PJSET(K,NEWV)
      IF(SGN.GT.0.) THEN
        PP1PL=(SP-AM1SQ-AM2SQ+ALAMF(SP,AM1SQ,AM2SQ))/(2.*P2MN)
        PP1MN=AM1SQ/PP1PL
      ELSE
        PP1MN=(SP-AM1SQ-AM2SQ+ALAMF(SP,AM1SQ,AM2SQ))/(2.*P2PL)
        PP1PL=AM1SQ/PP1MN
      ENDIF
C          STEP 2: SOLVE FOR K = VIRTUAL W MOMENTUM
      DEN=PP1PL*P2MN-PP1MN*P2PL
      AKPL=(+PP1PL*(S+T-AM2SQ)+P2PL*(T+AM3SQ-AM1SQ))/DEN
      AKMN=(-PP1MN*(S+T-AM2SQ)-P2MN*(T+AM3SQ-AM1SQ))/DEN
      WPL=PP1PL-AKPL
      WMN=PP1MN-AKMN
      AKT2=T+AKPL*AKMN
C          STEP 3: START OVER IF AKT2 UNPHYSICAL
      IF(AKT2.LE.0..OR.PP1PL.GE.ECM.OR.PP1MN.GE.ECM.OR.
     $P2PL.GE.ECM.OR.P2MN.GE.ECM) THEN
        NREJ2=NREJ2+1
        IF(NREJ2.GT.NTRIES) GO TO 9999
        GO TO 20
      ENDIF
C
C          SAVE NEW VECTORS
      NJ1=NJSET+1
      NJ2=NJSET+2
      AKT=SQRT(AKT2)
      AKX=AKT*COS(PHIK)
      AKY=AKT*SIN(PHIK)
      PJSET(1,J1)=AKX
      PJSET(2,J1)=AKY
      PJSET(3,J1)=.5*(AKPL-AKMN)
      PJSET(4,J1)=.5*(AKPL+AKMN)
      PJSET(5,J1)=-SQRT(T)
      JDCAY(J1)=JPACK*NJ1+NJ2
      JET=IABS(JORIG(J1))/JPACK
C
      PJSET(1,NJ1)=0.
      PJSET(2,NJ1)=0.
      PJSET(3,NJ1)=.5*(PP1PL-PP1MN)
      PJSET(4,NJ1)=.5*(PP1PL+PP1MN)
      PJSET(5,NJ1)=AM1
      JORIG(NJ1)=JPACK*JET+J1
      JTYPE(NJ1)=IFL1
      JDCAY(NJ1)=0
C
      PJSET(1,NJ2)=-AKX
      PJSET(2,NJ2)=-AKY
      PJSET(3,NJ2)=.5*(WPL-WMN)
      PJSET(4,NJ2)=.5*(WPL+WMN)
      PJSET(5,NJ2)=AM3
      JORIG(NJ2)=JPACK*JET+J1
      JTYPE(NJ2)=IFL3
      JDCAY(NJ2)=0
C
C          BOOST OTHER VECTORS TO NEW FRAME GIVEN BY DIFFERENCE OF
C          OLD AND NEW FINAL MOMENTA.
      DO 200 K=1,4
      BST1(K)=PFINAL(K)
200   BST2(K)=PJSET(K,J1)+PJSET(K,J2)
      BMASS=PFINAL(5)
      BST1(5)=BMASS
      BST2(5)=BMASS
C
C          PARAMETERS FOR COMBINED BOOSTS.
      BDOTB=BST1(4)*BST2(4)-BST1(1)*BST2(1)-BST1(2)*BST2(2)
     $-BST1(3)*BST2(3)
      DO 210 K=1,4
210   B2B1(K)=BST2(K)-BST1(K)
C
      B44=BDOTB/BMASS**2
      BI41=1./BMASS
      BI42=(BDOTB-BMASS**2-B2B1(4)*BMASS)/(BMASS**2*(BST2(4)+BMASS))
      B4K1=BI41
      B4K2=(BMASS**2-BDOTB-B2B1(4)*BMASS)/(BMASS**2*(BST1(4)+BMASS))
      BIK1=-1./(BMASS*(BST1(4)+BMASS))
      BIK2=1./(BMASS*(BST2(4)+BMASS))
      BIK3=(BMASS**2-BDOTB)/(BMASS**2*(BST1(4)+BMASS)
     $*(BST2(4)+BMASS))
C
C          BOOST FINAL JETS
      DO 220 J=1,NJSET
      IF(J.EQ.J1.OR.J.EQ.J2) GO TO 220
      IF(PJSET(5,J).LT.0.) GO TO 220
      BP1=0.
      BP21=0.
      DO 221 K=1,3
      BP1=BP1+BST1(K)*PJSET(K,J)
221   BP21=BP21+B2B1(K)*PJSET(K,J)
      DO 222 K=1,3
222   PJSET(K,J)=PJSET(K,J)
     $+(B2B1(K)*BI41+BST2(K)*BI42)*PJSET(4,J)
     $+B2B1(K)*BP1*BIK1+BST2(K)*BP21*BIK2+BST2(K)*BP1*BIK3
      PJSET(4,J)=B44*PJSET(4,J)+BP21*B4K1+BP1*B4K2
220   CONTINUE
C
C          RESET VIRTUAL MOMENTA
      DO 230 J=1,NJSET
      IF(J.EQ.J1.OR.J.EQ.J2) GO TO 230
      IF(PJSET(5,J).GE.0.) GO TO 230
      JX1=JDCAY(J)/JPACK
      JX2=JDCAY(J)-JPACK*JX1
      DO 231 K=1,4
231   PJSET(K,J)=PJSET(K,JX1)-PJSET(K,JX2)
      AMJ=PJSET(4,J)**2-PJSET(1,J)**2-PJSET(2,J)**2-PJSET(3,J)**2
      PJSET(5,J)=-SQRT(ABS(AMJ))
230   CONTINUE
C
C          RESET PFINAL AND NJSET
      DO 240 K=1,4
240   PFINAL(K)=PJSET(K,J2)+PJSET(K,NJ1)
      PFINAL(5)=SQRT(SP)
      NJSET=NJSET+2
100   CONTINUE
      RETURN
C
9999  CONTINUE
      WRITE(ITLIS,9998) IEVT
9998  FORMAT(/' ***** ERROR IN HEVOLV ... EVENT',I8,' DISCARDED *****')
      NJSET=-1
      RETURN
      END
CDECK  ID>, HIGGS.  
      SUBROUTINE HIGGS
C
C          FINISH HIGGS GENERATION STARTED BY DRLLYN FOR DECAY
C          HIGGS --> W W.
C
C          VER 7.14: TEST BOTH JET1 AND JET2 FOR W,Z FOR SAFETY
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/QSAVE/QSAVE(29,2)
      SAVE /QSAVE/
      REAL      QSAVE
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
C
      DIMENSION X(2)
      EQUIVALENCE (X(1),X1)
C
      IDABS1=IABS(IDJETS(1))
      IDABS2=IABS(IDJETS(2))
      IF(IDABS1.NE.80.AND.IDABS1.NE.90.AND.
     $IDABS2.NE.80.AND.IDABS2.NE.90) THEN
        NPAIR=0
        DO 100 I=1,4
        IDPAIR(I)=0
        JPAIR(I)=0
        DO 110 K=1,5
110     PPAIR(K,I)=0.
100     CONTINUE
      ELSE
        CALL WPAIR
      ENDIF
      RETURN
      END
CDECK  ID>, IDANTI. 
      INTEGER FUNCTION IDANTI(ID)
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-     Return value of antiparticle id
C-
C-   Inputs  :
C-   ID = particle id
C-
C-   Created   1-JUN-1988   Serban D. Protopopescu
C-   3-Jan-1993: Expand self-conjugate list for MSSM and simplify
C                structure.  FEP
C    17-Mar-1997: Correctly handle mesons with IDENT>10000
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER ID,IFL1,IFL2,IFL3,IDABS
      INTEGER NSELF,I
      PARAMETER (NSELF=14)
      INTEGER IDSELF(NSELF)
      SAVE IDSELF
      DATA IDSELF/9,10,20,29,30,40,50,60,81,82,83,84,90,91/
C----------------------------------------------------------------------
      IDABS=IABS(ID)
      IFL1=MOD(IDABS/1000,10)
C
C          Baryons and diquarks
C
      IF(IFL1.NE.0) THEN
        IDANTI=-ID
        RETURN
      ENDIF
C
C          Mesons
C
      IF(IDABS.GT.100.AND.IFL1.EQ.0) THEN
        IFL2=MOD(IDABS/100,10)
        IFL3=MOD(IDABS/10,10)
        IF(IFL2.EQ.IFL3) THEN
          IDANTI=+ID
        ELSE
          IDANTI=-ID
        ENDIF
        RETURN
      ENDIF
C
C          Other particles
C
      DO 100 I=1,NSELF
        IF(IDABS.EQ.IDSELF(I)) THEN
          IDANTI=+ID
          RETURN
        ENDIF
100   CONTINUE
      IDANTI=-ID
      RETURN
      END
CDECK  ID>, IDGEN.  
      SUBROUTINE IDGEN
C
C          Call system date and time routines (non-standard) to set up
C          run identification:
C          IDVER=100*VERSN     (integer ISAJET version number)
C          IDG(1)=YYMMDD       (integer year-month-day)
C          IDG(2)=HHMMSS       (integer hour-minute-second)
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
C          Default run id is zero.
      IYMD=0.
      IHMS=0.
C          Call DATIME for date and time. (In Cern library)
      CALL DATIME(IYMD,IHMS)
      IDG(1)=IYMD
      IDG(2)=IHMS
      RETURN
      END
CDECK  ID>, IFRAMS. 
      SUBROUTINE IFRAMS(N1,N2,IFR,PAIR)
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-     Initialize a center of mass frame for partons N1 to N2
C-     partons must be consecutive unless PAIR is true
C-
C-   Inputs  :
C-   N1  = first parton
C-   N2  = last parton
C-   IFR = index of frame
C-   PAIR= if false N1, N2 denote a range
C-      if true N1 and N2 form a pair
C-
C-   Created  14-AUG-1991   Serban D. Protopopescu
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/FRAME/FRAME(5,3),N0JETS,N0W,N0PAIR
      SAVE /FRAME/
      INTEGER   N0JETS,N0W,N0PAIR
      REAL      FRAME
      INTEGER I,J,K,JADD,N1,N2,IFR
      DOUBLE PRECISION DPASS(5),DSUM(5)
      LOGICAL PAIR
C----------------------------------------------------------------------
C
      IF ( N2-N1.EQ.1.OR.PAIR ) THEN
        JMATCH(N1)=N2
        JMATCH(N2)=N1
        JADD=N2-N1
      ELSE
        JADD=1
        DO 201 I=N1,N2
          JMATCH(I)=JPACK*N1+N2
201     CONTINUE
      ENDIF
C          Need double precision boosts
      CALL DBLVEC(PJSET(1,N1),DSUM)
      DO 211 I=N1+JADD,N2
        CALL DBLVEC(PJSET(1,I),DPASS)
        DO 210 K=1,4
210     DSUM(K)=DSUM(K)+DPASS(K)
        DSUM(5)=DSQRT(DSUM(4)**2-DSUM(1)**2-DSUM(2)**2-DSUM(3)**2)
211   CONTINUE
      DO 212 K=1,5
        FRAME(K,IFR)=DSUM(K)
212   CONTINUE
C
C          Set up and generate final state QCD parton shower.
C          Boost PJSET with -FRAME.
C
      DO 240 J=N1,N2,JADD
        CALL DBOOST(-1,FRAME(1,IFR),PJSET(1,J))
240   CONTINUE
C
999   RETURN
      END
CDECK  ID>, INISAP. 
      SUBROUTINE INISAP(CMSE,XREAC,BEAMS,WZ,NDCAYS,DCAYS,
     $  ETMIN,RCONE,OK)
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-     initialize ISAJET for externally supplied partons
C-   Inputs  :
C-   CMSE     = center of mass energy
C-   XREAC    = reaction
C-   BEAMS(2) = chose 'P ' or 'AP'
C-   ETMIN    = minimum ET of supplied partons
C-   RCONE    = minimum cone (R) between supplied partons
C-   WZ = option 'W' or 'Z', ' ' no W's or Z's
C-   NDCAYS= number of decay options
C-   DCAYS= list of particles W or Z are allowed to decay into
C-
C-   Controls:
C-   OK   = true if initialization is possible
C-   Created   8-OCT-1991   Serban D. Protopopescu
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON /LIMEVL/ ETTHRS,CONCUT,USELIM
      SAVE /LIMEVL/
      REAL ETTHRS,CONCUT
      LOGICAL USELIM
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/TYPES/LOC(100),NTYP,NJTTYP(3),NWWTYP(2),NWMODE(3)
      COMMON/XTYPES/PARTYP(40),TITLE(10),JETYP(30,3),WWTYP(30,2)
     $,WMODES(30,3)
      SAVE /TYPES/,/XTYPES/
      CHARACTER*8 JETYP,WWTYP,TITLE,PARTYP,WMODES
      INTEGER   LOC,NTYP,NJTTYP,NWWTYP,NWMODE
C
      REAL CMSE
      CHARACTER*8 XREAC
      CHARACTER*2 BEAMS(2)
      REAL    ETMIN,RCONE
      CHARACTER*1 WZ
      INTEGER NDCAYS
      CHARACTER*4 DCAYS(*)
      LOGICAL OK
      LOGICAL DUMY,SETTYP
      INTEGER I
C----------------------------------------------------------------------
      OK=.TRUE.
      CALL RESET
      IEVT=0
      ECM=CMSE
      SCM=ECM**2
      HALFE=ECM/2.
      ETTHRS=ETMIN
C          fudge factor 1.5 to approximate ET distributions and widths
      CONCUT=SIN(RCONE)/1.5
      IF(RCONE.GT.1.5) CONCUT=1.0
      USELIM=.TRUE.
      IKEYS=0
      DO 18 I=1,8
18    KEYS(I)=.FALSE.
      KEYON=.FALSE.
      REAC=XREAC
C
      IF(XREAC.EQ.'TWOJET  ') THEN
        KEYS(1)=.TRUE.
        IKEYS=1
C
      ELSEIF(XREAC.EQ.'DRELLYAN') THEN
        KEYS(3)=.TRUE.
        IKEYS=3
        IF(WZ.EQ.'Z') GODY(4)=.TRUE.
        IF(WZ.EQ.'W') THEN
          GODY(2)=.TRUE.
          GODY(3)=.TRUE.
        ENDIF
        NJTTYP(1)=NDCAYS
        NJTTYP(2)=0
        NJTTYP(3)=0
        DO 21 I=1,NDCAYS
          JETYP(I,1)=DCAYS(I)
   21   CONTINUE
C
      ELSEIF(XREAC.EQ.'MINBIAS ') THEN
        KEYS(4)=.TRUE.
        IKEYS=4
C
      ELSEIF(XREAC.EQ.'SUPERSYM'.OR.XREAC.EQ.'SUSY    ') THEN
        KEYS(5)=.TRUE.
        IKEYS=5
C
      ELSEIF(XREAC.EQ.'WPAIR   ') THEN
        KEYS(6)=.TRUE.
        IKEYS=6
C
      ELSEIF(XREAC.EQ.'HIGGS   ') THEN
        KEYS(7)=.TRUE.
        IKEYS=7
C
      ELSEIF(XREAC.EQ.'PHOTON  ') THEN
        KEYS(8)=.TRUE.
        IKEYS=8
      ENDIF
C
      IF(IKEYS.EQ.0) THEN
        OK=.FALSE.
        GOTO 999
      ENDIF
C
      CALL SETCON
      IDIN(1)=1120
      IDIN(2)=-1120
      IF (BEAMS(1).EQ.'P ') IDIN(1)=1120
      IF (BEAMS(2).EQ.'P ') IDIN(2)=1120
      IF (BEAMS(1).EQ.'AP') IDIN(1)=-1120
      IF (BEAMS(2).EQ.'AP') IDIN(2)=-1120
      DUMY=SETTYP(0)
      CALL SETW
      CALL IDGEN
      CALL SETDKY(.FALSE.)
      CALL MBSET
      CALL PRTLIM
      CALL TIMER(1)
  999 RETURN
      END
CDECK  ID>, IPJSET. 
      SUBROUTINE IPJSET
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-       Initialize PJSET starting from PJETS
C-
C-   Created  14-AUG-1991   Serban D. Protopopescu
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      INTEGER I,K
C----------------------------------------------------------------------
      DO 110 I=1,NJET
        NJSET=NJSET+1
        JORIG(NJSET)=JPACK*I
        JTYPE(NJSET)=IDJETS(I)
        JDCAY(NJSET)=0
        DO 115 K=1,5
115     PJSET(K,NJSET)=PJETS(K,I)
        IFRAME(I)=1
110   CONTINUE
  999 RETURN
      END
CDECK  ID>, IPRTNS. 
      SUBROUTINE IPRTNS(NPRTNS,PRTNS,IDQ)
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-      Fill PINITS common block
C-   Inputs  :
C-     IDQ(2)= id's of partons starting reaction
C-
C-   Created  10-OCT-1991   Serban D. Protopopescu
C-   Renamed from IPINIT to avoid name clash with Cern Library
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER NPRTNS,IDQ(2)
      REAL    PRTNS(4,NPRTNS)
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/PINITS/PINITS(5,2),IDINIT(2)
      SAVE /PINITS/
      INTEGER   IDINIT
      REAL      PINITS
      REAL AMASS, AM1SQ,AM2SQ,ROOT,QPL,QMN,P1PL,P1MN,P2PL,P2MN
      INTEGER I
C----------------------------------------------------------------------
C          sum P+ and P-, shat
C          assumes sum of transverse momenta is zero
      QPL=0
      QMN=0
      DO 1 I=1,NPRTNS
        QPL=QPL+PRTNS(4,I)+PRTNS(3,I)
        QMN=QMN+PRTNS(4,I)-PRTNS(3,I)
    1 CONTINUE
      SHAT=QPL*QMN
C
C          fill PINITS
      DO 2 I=1,2
        IDINIT(I)=IDQ(I)
        PINITS(5,I)=AMASS(IDQ(I))
        PINITS(1,I)=0.
        PINITS(2,I)=0.
    2 CONTINUE
C          and solve initial kinematics
      AM1SQ=PINITS(5,1)**2
      AM2SQ=PINITS(5,2)**2
      ROOT=SQRT((QPL*QMN-AM1SQ-AM2SQ)**2-4.*AM1SQ*AM2SQ)
      P1PL=(QPL*QMN+AM1SQ-AM2SQ+ROOT)/(2.*QMN)
      P1MN=AM1SQ/P1PL
      P2MN=(QPL*QMN+AM2SQ-AM1SQ+ROOT)/(2.*QPL)
      P2PL=AM2SQ/P2MN
      PINITS(3,1)=.5*(P1PL-P1MN)
      PINITS(4,1)=.5*(P1PL+P1MN)
      PINITS(3,2)=.5*(P2PL-P2MN)
      PINITS(4,2)=.5*(P2PL+P2MN)
  999 RETURN
      END
CDECK  ID>, IRMOV0. 
      SUBROUTINE IRMOV0
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-      remove 0's from PJSET
C-
C-   Created  15-OCT-1991   Serban D. Protopopescu
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      INTEGER NCOUNT,I,J,K
C----------------------------------------------------------------------
C
C         remove zeroes
      NCOUNT=NJSET
      DO 160 I=3,NJSET
  151   IF (PJSET(4,I).EQ.0.AND.I.LT.NCOUNT) THEN
          DO 155 K=I+1,NCOUNT
            DO 154 J=1,5
              PJSET(J,K-1)=PJSET(J,K)
  154       CONTINUE
            JORIG(K-1)=JORIG(K)
            JTYPE(K-1)=JTYPE(K)
            JDCAY(K-1)=JDCAY(K)
            ZZC(K-1)=ZZC(K)
            JMATCH(K-1)=JMATCH(K)
            IF(JMATCH(K-1).GT.I) JMATCH(K-1)=JMATCH(K-1)-1
  155     CONTINUE
          NCOUNT=NCOUNT-1
          GOTO 151
        ENDIF
  160 CONTINUE
      NJSET=NCOUNT
C          remove last one if 0
      IF(PJSET(4,NJSET).EQ.0) NJSET=NJSET-1
  999 RETURN
      END
CDECK  ID>, ISABEG. 
      SUBROUTINE ISABEG(IFL)
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-       Initialize a process before event generation
C-
C-   Created   5-FEB-1988   Serban D. Protopopescu
C-
C    Ver 7.14: Do logic after setting physics parameters
C----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/NODCAY/NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      SAVE /NODCAY/
      LOGICAL NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/ISLOOP/NEVOLV,NFRGMN,IEVOL,IFRG
      SAVE /ISLOOP/
      INTEGER NEVOLV,NFRGMN,IEVOL,IFRG
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C          ISAPW1 is used to check whether ALDATA is loaded
      COMMON/ISAPW/ISAPW1
      CHARACTER*30 ISAPW1
      SAVE /ISAPW/
C
      INTEGER IFL,I
      LOGICAL FIRST
      SAVE FIRST
      CHARACTER*30 ISAPW2
      SAVE ISAPW2
      DATA FIRST/.TRUE./
C          ISAPW2 is used to check whether ALDATA is loaded
      DATA ISAPW2/'ALDATA REQUIRED BY FORTRAN G,H'/
C
C          Initialize
C
      IF(ISAPW1.NE.ISAPW2) THEN
        PRINT*, ' ISABEG ERROR: BLOCK DATA ALDATA HAS NOT BEEN LOADED.'
        PRINT*, ' ISAJET CANNOT RUN WITHOUT IT.'
        PRINT*, ' PLEASE READ THE FINE MANUAL FOR ISAJET.'
        STOP99
      ENDIF
C
      IF (FIRST) THEN
        FIRST=.FALSE.
      ELSE
        CALL SETNXT
      ENDIF
      IEVT=0
      IEVGEN=0
      NEVENT=0
      IEVOL=1
      IFRG=1
C
C          Read in user data and decay table
C
      CALL READIN(IFL)
      IF(IFL.NE.0) GOTO 999
      CALL IDGEN
      IF(GOMSSM) THEN
        CALL DOMSSM
      ENDIF
      CALL SETDKY(.FALSE.)
C
C          Generate NSIGMA unevolved events for SIGF calculation
C
C          TWOJET events
      IF(KEYS(1)) THEN
        CALL MBSET
        CALL SETW
        CALL LOGIC
        CALL PRTLIM
        CALL PTFUN
        DO 105 I=1,NSIGMA
105     CALL TWOJET
        CALL TIMER(1)
C
C          E+E- events
      ELSE IF(KEYS(2)) THEN
        CALL SETW
        CALL LOGIC
        CALL PRTLIM
        CALL EEBEG
        CALL EEMAX
        DO 205 I=1,NSIGMA
205     CALL ELCTRN
        CALL TIMER(1)
C
C          DRELLYAN events
      ELSE IF(KEYS(3)) THEN
        CALL SETW
        CALL MBSET
        CALL LOGIC
        CALL PRTLIM
        CALL QFUNC
        DO 305 I=1,NSIGMA
305     CALL DRLLYN
        CALL TIMER(1)
C
C          MINBIAS events
      ELSE IF(KEYS(4)) THEN
        PBEAM(1)=HALFE
        PBEAM(2)=HALFE
        CALL PRTLIM
        CALL MBSET
        CALL TIMER(1)
C
C          SUPERSYM events
      ELSE IF(KEYS(5)) THEN
        CALL SETW
        CALL MBSET
        CALL LOGIC
        CALL PRTLIM
        CALL PTFUN
        DO 505 I=1,NSIGMA
505     CALL TWOJET
        CALL TIMER(1)
C
C          WPAIR events
      ELSE IF(KEYS(6)) THEN
        CALL SETW
        CALL MBSET
        CALL LOGIC
        CALL PRTLIM
        CALL PTFUN
        DO 605 I=1,NSIGMA
        CALL TWOJET
605     CALL WPAIR
        CALL TIMER(1)
C
C          HIGGS events
      ELSE IF(KEYS(7)) THEN
        CALL SETW
        IF(GOMSSM) THEN
          CALL SETHSS
        ELSE
          CALL SETH
        ENDIF
        CALL MBSET
        CALL LOGIC
        CALL PRTLIM
        CALL QFUNC
        DO 705 I=1,NSIGMA
705     CALL DRLLYN
        CALL TIMER(1)
C
C          PHOTON events
      ELSEIF(KEYS(8)) THEN
        CALL MBSET
        CALL SETW
        CALL LOGIC
        CALL PRTLIM
        CALL PTFUN
        DO 805 I=1,NSIGMA
805     CALL TWOJET
        CALL TIMER(1)
C
C          TCOLOR events
      ELSE IF(KEYS(9)) THEN
        CALL SETW
        CALL MBSET
        CALL LOGIC
        CALL PRTLIM
        CALL QFUNC
        DO 905 I=1,NSIGMA
905     CALL DRLLYN
        CALL TIMER(1)
C
      ELSE
        STOP 99
      ENDIF
999   RETURN
      END
CDECK  ID>, ISAEND. 
      SUBROUTINE ISAEND
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-       Terminate an ISAJET run
C-
C-   Created   4-FEB-1988   Serban D. Protopopescu
C-
C----------------------------------------------------------------------
      CALL TIMER(2)
      CALL GETTOT(.TRUE.)
  999 RETURN
      END
CDECK  ID>, ISAEVT. 
      SUBROUTINE ISAEVT(I,OK,DONE)
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-
C-         Normal operation:
C-    Generate one ISAJET event and return.
C-
C-         "ISALEP" generation:
C-    Generate a TWOJET or DRELLYAN hard scattering. Then make NEVOLVE
C-    evolutions and NHADRON fragmentations, rejecting events which
C-    fail the desired cuts using logical functions
C-         REJJET()   tests the QCD evolution stage, e.g. by requiring
C-                    a heavy quark.
C-         REJFRG()   tests the fragmentation stage, e.g. by requiring
C-                    a high-pt lepton.
C-    These functions default to .FALSE.; i.e. they do not reject any
C-    events. Note that one hard scattering can give more than one
C-    event. You must choose NEVOLVE and NHADRON carefully.
C-         IEVT   = event number. This is incremented NEVOLVE * NHADRON
C-                  times for each hard scattering; i.e. it counts the
C-                  number of potential events.
C-         IEVGEN = counter for generated events.
C-         NEVENT = maximum value of hard scatterings. Hence the limit
C-                  for IEVT is NEVENT * NEVOLVE * NHADRON.
C-    The cross section SIGF contains an extra factor of
C-         1 / (NEVOLVE * NHADRON)
C-    to produce the correct final cross section using the weight
C-         SIGF / NEVENT
C-
C-   Input:
C-    I      = number used to control printout
C-   Output:
C-    OK     = logical flag for good event.
C-    DONE   = logical flag for job completion.
C-
C-   Created   3-FEB-1988   Serban D. Protopopescu
C-   Updated  17-APR-1990 Serban D. Protopopescu (add ISALEP option)
C-   22-JUL-1992: Move PRTEVT and GETTOT statements to end so they
C-                work for TWOJET and DRELLYAN with NOVOLVE. (FEP)
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/NODCAY/NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      SAVE /NODCAY/
      LOGICAL NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/ISLOOP/NEVOLV,NFRGMN,IEVOL,IFRG
      SAVE /ISLOOP/
      INTEGER NEVOLV,NFRGMN,IEVOL,IFRG
C
      LOGICAL REJJET,REJFRG,OK,DONE
      INTEGER NPASS,I,NLIMIT
C
      NPASS=0
      OK=.TRUE.
      DONE=.FALSE.
      NLIMIT=NEVENT*NEVOLV*NFRGMN
C
C          Twojet or Drell-Yan events. The evolution and fragmentation
C          loops are done with GO TO statements so that we can exit
C          the loops with a good event and reenter them.
C
      IF(KEYS(1).OR.KEYS(3)) THEN
100     CONTINUE
        IF(IEVOL.EQ.1.AND.IFRG.EQ.1) THEN
          NPASS=NPASS+1
          IF(NPASS.GT.NTRIES) THEN
            WRITE(ITLIS,1001) NTRIES
1001        FORMAT(//' IT IS TAKING MORE THAN',I6,' TRIES TO MAKE',
     $      ' AN EVENT IN ISAEVT.'/
     $      ' CHECK YOUR LIMITS OR OR INCREASE NTRIES.'/
     $      ' CHECK NEVOLVE, NHADRON, AND YOUR REJJET AND REJFRG',
     $      ' FUNCTIONS IF ANY.'/
     $      ' JOB TERMINATED.')
            STOP 99
          ENDIF
          CALL RANFMT
C          Generate appropriate hard scattering
          IF(KEYS(1)) THEN
            CALL TWOJET
          ELSE
            CALL DRLLYN
          ENDIF
        ENDIF
C          QCD evolution
        IF(NOEVOL) THEN
          IEVT=IEVT+NEVOLV*NFRGMN
          GOTO 9999
        ENDIF
C          Continue if in fragmentation loop
        IF(IFRG.NE.1) GO TO 120
C          Begin multiple evolution loop
110       CONTINUE
          NJSET=0
          IEVT=IEVT+1
          CALL EVOLVE
          IEVT=IEVT-1
          IF(NJSET.LT.0) THEN
            IEVT=IEVT+NFRGMN
            GO TO 111
          ENDIF
          IF(REJJET()) THEN
            IEVT=IEVT+NFRGMN
            GO TO 111
          ENDIF
          IF(NOHADR) THEN
            IEVT=IEVT+NFRGMN
            GO TO 9999
          ENDIF
C          Begin multiple fragmentation loop
120         CONTINUE
            NPTCL=0
            CALL FRGMNT
            IEVT=IEVT+1
            IF(REJFRG()) GO TO 121
C          Finish good event
            CALL MBIAS
            IFRG=IFRG+1
            IF(IFRG.GT.NFRGMN) IFRG=1
            IF(IFRG.EQ.1) THEN
              IEVOL=IEVOL+1
              IF(IEVOL.GT.NEVOLV) IEVOL=1
            ENDIF
            GOTO 9999
C          Fragmentation failed - increment counter and loop
121         IFRG=IFRG+1
            IF(IFRG.GT.NFRGMN) THEN
              IFRG=1
            ELSE
              GO TO 120
            ENDIF
C          End of multiple fragmentation loop
C          Evolution failed - increment counter and loop
111       IEVOL=IEVOL+1
          IF(IEVOL.GT.NEVOLV) THEN
            IEVOL=1
            IFRG=1
            GO TO 100
          ELSE
            GO TO 110
          ENDIF
C
C          E+E- events
C
      ELSE IF(KEYS(2)) THEN
        IEVT=IEVT+1
        CALL RANFMT
        CALL ELCTRN
        IF(.NOT.NOEVOL) THEN
          CALL EVOLVE
          IF(.NOT.NOHADR) CALL FRGMNT
        ENDIF
C
C          MINBIAS events
C
      ELSE IF(KEYS(4)) THEN
        IEVT=IEVT+1
        CALL RANFMT
        NPTCL=0
        IF(.NOT.(NOEVOL.OR.NOHADR)) CALL MBIAS
C
C          SUPERSYM events
C
      ELSE IF(KEYS(5)) THEN
        IEVT=IEVT+1
        CALL RANFMT
        CALL TWOJET
        IF(.NOT.NOEVOL) THEN
          CALL EVOLVE
          IF(NJSET.LT.0) GO TO 9999
          IF(.NOT.NOHADR) THEN
            CALL FRGMNT
            CALL MBIAS
          ENDIF
        ENDIF
C
C          WPAIR events
C
      ELSE IF(KEYS(6)) THEN
        IEVT=IEVT+1
        CALL RANFMT
        CALL TWOJET
        CALL WPAIR
C
        IF(.NOT.NOEVOL) THEN
          CALL EVOLVE
          IF(NJSET.LT.0) GO TO 9999
          IF(.NOT.NOHADR) THEN
            CALL FRGMNT
            CALL MBIAS
          ENDIF
        ENDIF
C
C          HIGGS events
C
      ELSE IF(KEYS(7)) THEN
        IEVT=IEVT+1
        CALL RANFMT
        CALL DRLLYN
        CALL HIGGS
        IF(.NOT.NOEVOL) THEN
          CALL EVOLVE
          IF(NJSET.LT.0) GOTO 9999
          IF(.NOT.NOHADR) THEN
            CALL FRGMNT
            CALL MBIAS
          ENDIF
        ENDIF
C
C          PHOTON events
C
      ELSEIF(KEYS(8)) THEN
        IEVT=IEVT+1
        CALL RANFMT
        CALL TWOJET
        IF(.NOT.NOEVOL) THEN
          CALL EVOLVE
          IF(NJSET.LT.0) GOTO 9999
          IF(.NOT.NOHADR) THEN
            CALL FRGMNT
            CALL MBIAS
          ENDIF
        ENDIF
C
C          TCOLOR events, e.g. techni-rho
C
      ELSEIF(KEYS(9)) THEN
        IEVT=IEVT+1
        CALL RANFMT
        CALL DRLLYN
        CALL HIGGS
        IF(.NOT.NOEVOL) THEN
          CALL EVOLVE
          IF(NJSET.LT.0) GOTO 9999
          IF(.NOT.NOHADR) THEN
            CALL FRGMNT
            CALL MBIAS
          ENDIF
        ENDIF
      ENDIF
C
C          Event complete
C
 9999 IEVGEN=IEVGEN+1
      IF(NJSET.LT.0) OK=.FALSE.
      IF(IEVT.GT.NLIMIT) THEN
        OK=.FALSE.
        DONE=.TRUE.
      ELSEIF(IEVT.EQ.NLIMIT) THEN
        DONE=.TRUE.
      ENDIF
      IF(OK) THEN
        CALL PRTEVT(I)
        CALL GETTOT(.FALSE.)
      ENDIF
      RETURN
      END
CDECK  ID>, ISAINI. 
      SUBROUTINE ISAINI(JTDKY,JTEVT,JTCOM,JTLIS)
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-         INITIALIZE PROCESSES
C-
C-   Inputs  :
C          JTDKY = +/- UNIT NUMBER FOR DECAY TABLE FILE.
C                      IF IT IS NEGATIVE, DECAY TABLE IS NOT PRINTED.
C          JTEVT = +/- UNIT NUMBER FOR OUTPUT EVENT FILE.
C                      IF IT IS NEGATIVE, ONLY STABLE PARTICLES ARE
C                      WRITTEN ON IT.
C          JTCOM =     UNIT NUMBER FOR COMMAND FILE.
C          JTLIS =     UNIT NUMBER FOR LISTING.
C-
C-   Created   3-FEB-1988   Serban D. Protopopescu
C-
C----------------------------------------------------------------------
C
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
C
C          ENTRY.
      ITDKY=IABS(JTDKY)
      ITEVT=JTEVT
      ITCOM=IABS(JTCOM)
      ITLIS=IABS(JTLIS)
C
      IEVT=0
      CALL SETCON
      CALL RESET
      IF(JTDKY.GT.0) THEN
        CALL SETDKY(.TRUE.)
      ELSE
        CALL SETDKY(.FALSE.)
      ENDIF
C
  999 RETURN
      END
CDECK  ID>, ISAJET. 
      SUBROUTINE ISAJET(JTDKY,JTEVT,JTCOM,JTLIS)
C
C          Main subroutine for ISAJET, a Monte Carlo event generator
C          for  P P ,  AP P , and  E+ E-  interactions at high energy.
C
C          Frank E. Paige and Serban D. Protopopescu
C          Brookhaven National Laboratory
C          Upton, New York, USA
C
C          JTDKY = +/- unit number for decay table file.
C                      If it is negative, decay table is not printed.
C          JTEVT = +/- unit number for output event file.
C                      If it is negative, only stable particles are
C                      written on it.
C          JTCOM =     unit number for command file.
C          JTLIS =     unit number for listing.
C
C          Instead of calling this subroutine the user may wish to
C          control the program himself using:
C          ISAINI      overall initialization
C          ISABEG      run initialization
C          ISAEVT      generation of one event
C          ISAEND      run termination
C          ISAWBG      initial record writing
C          ISAWEV      event record writing
C          ISAWND      end record writing
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/ISLOOP/NEVOLV,NFRGMN,IEVOL,IFRG
      SAVE /ISLOOP/
      INTEGER NEVOLV,NFRGMN,IEVOL,IFRG
C
      INTEGER JTDKY,JTEVT,JTCOM,JTLIS,IFL,ILOOP
      LOGICAL OK,DONE
      SAVE ILOOP
C
C          Initialize ISAJET
C
      CALL ISAINI(JTDKY,JTEVT,JTCOM,JTLIS)
C
C          Read instructions; terminate for STOP command or error.
C
    1 IFL=0
      CALL ISABEG(IFL)
      IF(IFL.NE.0) RETURN
C          Write begin-run record
      CALL ISAWBG
C
C          Event loop
C
      ILOOP=0
  101 CONTINUE
        ILOOP=ILOOP+1
C          Generate one event - discard if .NOT.OK
        CALL ISAEVT(ILOOP,OK,DONE)
C          Write event record
        IF(OK) CALL ISAWEV
      IF(.NOT.DONE) GO TO 101
C
C          Calculate cross section and luminosity
C
      CALL ISAEND
C          Write end-of-run record
      CALL ISAWND
      GO TO 1
C
C          Entry point for error recovery.
C          CALL RSTART will continue generation on next event.
C
      ENTRY RSTART
      IF(IEVT.EQ.0) RETURN
      IF(IEVT.GE.NEVENT*NEVOLV*NFRGMN) GO TO 1
      GO TO 101
      END
CDECK  ID>, ISASRT. 
      SUBROUTINE ISASRT(X,NCH,IMAP)
C----------------------------------------------------------------------
C-
C-   Purpose and Methods : Sorts a floating point array X into ascending order.
C-                         The array IMAP contains ordered list of pointers
C-
C-   Inputs  : X - Floating point array
C-             NCH  - Number of elements in X
C-   Outputs : IMAP - pointer to ordered list in X
C-   Controls: None
C-
C-   Created   3-OCT-1988   Rajendran Raja
C-   Based on the Algorithm of D.L.Shell, High speed sorting
C-   procedure , Communications of the ACM, Vol 2, July 1959, PP 30-32
C----------------------------------------------------------------------
      IMPLICIT NONE
      REAL X(*)
      REAL TEMP
      INTEGER IMAP(*),NCH,M,I,J,K,IM,IT
C----------------------------------------------------------------------
      M=NCH
   10 M=M/2       !binary chop
      IF(M.EQ.0)GO TO 999
      K=NCH-M
      J=1
   20 I=J
   30 IM=I+M
      IF(X(I).LE.X(IM))GO TO 40
      TEMP = X(I)
      X(I) = X(IM)
      X(IM) = TEMP
      IT = IMAP(I)
      IMAP(I)=IMAP(IM)
      IMAP(IM)=IT
      I = I-M
      IF(I.GE.1)GO TO 30
   40 J=J+1
      IF(J.GT.K)GO TO 10
      GO TO 20
  999 RETURN
      END
CDECK  ID>, ISTRAD. 
      SUBROUTINE ISTRAD(FUDGE)
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-      Set parameters and call QCDINI to generate initial
C-      state radiation
C-   Inputs  :
C-     FUDGE= fudge factor
C-
C-   Created  16-AUG-1991   Serban D. Protopopescu
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      REAL    FUDGE
      COMMON /LIMEVL/ ETTHRS,CONCUT,USELIM
      SAVE /LIMEVL/
      REAL ETTHRS,CONCUT
      LOGICAL USELIM
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      REAL    OFF
      INTEGER I
C----------------------------------------------------------------------
C
      IF ( USELIM.AND.CONCUT.LT.1.0 ) THEN
        OFF=ETTHRS
      ELSEIF( .NOT.USELIM) THEN
        OFF=SQRT(QSQ)*FUDGE
      ELSE
        OFF=SQRT(QSQ)
      ENDIF
      DO 150 I=1,2
        PJSET(5,I)=-OFF
150   JDCAY(I)=-2
      JMATCH(1)=0
      JMATCH(2)=0
C
      CALL QCDINI(1,2)
  999 RETURN
      END
CDECK  ID>, ISWDKY. 
      SUBROUTINE ISWDKY
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-       decay W's and Z's as done in ISAJET
C-
C-   Created   6-MAY-1991   Serban D. Protopopescu
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/FRAME/FRAME(5,3),N0JETS,N0W,N0PAIR
      SAVE /FRAME/
      INTEGER   N0JETS,N0W,N0PAIR
      REAL      FRAME
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      REAL X(2)
      EQUIVALENCE (X(1),X1)
      REAL PREST(5),PL(5),EL(3),EML(3),EMSQL(3)
      REAL WTFAC(3)
      REAL BRANCH(29)
      INTEGER LISTJ(29),LISTW(4)
      REAL RANF,SUM,PTDEN,QDEN,ETA,
     $S12,SUMBR,BRMODE,AMASS,BRINV,TRY,PL12,
     $COSTHL,THL,PHL,PTL,SGN,BP,PLPL,PLMN,AMINI,AMFIN,PINI,PFIN,
     $ QPL,QMN,AM1SQ,AM2SQ,ROOT,P1PL,P1MN,P2PL,P2MN
      INTEGER NADD,K,IQ1,IQ2,IFL1,IFL2,IQ,IFL,I
      REAL EY
      REAL QWPL,QWMN
C
      DATA LISTJ/
     $9,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,
     $11,-11,12,-12,13,-13,14,-14,15,-15,16,-16,
     $10,80,-80,90/
      DATA LISTW/10,80,-80,90/
C----------------------------------------------------------------------
C
C          Entry
C
      NPTCL=0
C
C          Kinematics. Note that YW is the true rapidity and QW is
C          the true 3-momentum. See DRLLYN.
C
      QMW=QWJET(5)
      QTW=SQRT(QWJET(1)**2+QWJET(2)**2)
      QW=SQRT(QWJET(1)**2+QWJET(2)**2+QWJET(3)**2)
      IF(QTW.NE.0) THEN
        PHIW=ATAN2(QWJET(2),QWJET(1))
        IF(PHIW.LT.0) PHIW=PHIW+2*PI
      ELSE
        PHIW=0
      ENDIF
      QWPL=QWJET(4)+QWJET(3)
      QWMN=QWJET(4)-QWJET(3)
      IF(QWPL.GT.0..AND.QWMN.GT.0.) THEN
        YW=0.5*ALOG(QWPL/QWMN)
      ELSE
        YW=999.*SIGN(1.,QWJET(3))
      ENDIF
      IF(QW.NE.0.) THEN
        THW=ACOS(QWJET(3)/QW)
      ELSE
        THW=0.
      ENDIF
C
C          Select W decay mode
C          QMW dependence neglected in branching ratios
C          BRANCH is cum. br. with heavy modes subtracted.
C
      S12=QMW**2
      BRANCH(1)=0.
      SUMBR=0.
      DO 105 IQ1=2,25
        IQ2=MATCH(IQ1,JWTYP)
        IF(IQ2.EQ.0) THEN
          BRMODE=0.
        ELSE
          BRMODE=WCBR(IQ1,JWTYP)-WCBR(IQ1-1,JWTYP)
          IFL1=LISTJ(IQ1)
          IFL2=LISTJ(IQ2)
          IF(S12.LE.(AMASS(IFL1)+AMASS(IFL2))**2) BRMODE=0.
        ENDIF
        BRANCH(IQ1)=BRANCH(IQ1-1)+BRMODE
        SUMBR=SUMBR+BRMODE
105   CONTINUE
      BRINV=1./SUMBR
C
      TRY=RANF()
      DO 110 IQ=1,25
        IF(TRY.LT.BRANCH(IQ)*BRINV.AND.MATCH(IQ,JWTYP).NE.0) THEN
          JETTYP(1)=IQ
          JETTYP(2)=MATCH(IQ,JWTYP)
          GO TO 120
        ENDIF
110   CONTINUE
C
120   IFL1=LISTJ(JETTYP(1))
      IFL2=LISTJ(JETTYP(2))
C
C          Select masses of decay products.
C
      EML(1)=AMASS(IFL1)
      EML(2)=AMASS(IFL2)
C
C          Generate W decay in its rest frame
C          First set up momenta of decay products:
C
      EMSQL(1)=EML(1)**2
      EMSQL(2)=EML(2)**2
      EL(1)=(S12+EMSQL(1)-EMSQL(2))/(2.*QMW)
      EL(2)=(S12+EMSQL(2)-EMSQL(1))/(2.*QMW)
      PL12=SQRT((S12-(EML(1)+EML(2))**2)*(S12-(EML(1)-EML(2))**2))
     $/(2.*QMW)
C          W momentum
      DO 140 K=1,5
140   PREST(K)=QWJET(K)
C          Generate next W decay
20    CONTINUE
      COSTHL=2.*RANF()-1.
      THL=ACOS(COSTHL)
      PHL=2.*PI*RANF()
      PTL=PL12*SIN(THL)
C
      DO 300 I=1,2
        SGN=3-2*I
        PL(1)=SGN*PTL*COS(PHL)
        PL(2)=SGN*PTL*SIN(PHL)
        PL(3)=SGN*PL12*COSTHL
        PL(4)=EL(I)
        PL(5)=EML(I)
C          Boost with W momentum
        BP=0.
        DO 310 K=1,3
310     BP=BP+PL(K)*PREST(K)
        BP=BP/PREST(5)
        DO 320 K=1,3
320     PL(K)=PL(K)+PREST(K)*PL(4)/PREST(5)
     $  +PREST(K)*BP/(PREST(4)+PREST(5))
        PL(4)=PL(4)*PREST(4)/PREST(5)+BP
C          Fill common blocks
        PT(I)=SQRT(PL(1)**2+PL(2)**2)
        P(I)=SQRT(PT(I)**2+PL(3)**2)
        IF(PT(I).GT.0.) THEN
          PHI(I)=ATAN2(PL(2),PL(1))
        ELSE
          PHI(I)=(I-1)*PI
        ENDIF
        IF(PHI(I).LT.0.) PHI(I)=PHI(I)+2.*PI
        CTH(I)=PL(3)/P(I)
        STH(I)=PT(I)/P(I)
        TH(I)=ACOS(CTH(I))
        XJ(I)=PL(3)/HALFE
        IF(CTH(I).GT.0.) THEN
          PLPL=PL(4)+PL(3)
          PLMN=(PT(I)**2+EMSQL(I))/PLPL
        ELSE
          PLMN=PL(4)-PL(3)
          PLPL=(PT(I)**2+EMSQL(I))/PLMN
        ENDIF
        YJ(I)=.5*ALOG(PLPL/PLMN)
300   CONTINUE
C
C          Set PJETS
C
      DO 501 I=1,2
        PJETS(3,I)=P(I)*CTH(I)
        PJETS(1,I)=PT(I)*COS(PHI(I))
        PJETS(2,I)=PT(I)*SIN(PHI(I))
        PJETS(4,I)=SQRT(P(I)**2+EMSQL(I))
        PJETS(5,I)=SQRT(EMSQL(I))
        IDJETS(I)=LISTJ(JETTYP(I))
501   CONTINUE
  999 RETURN
      END
CDECK  ID>, JETGEN. 
      SUBROUTINE JETGEN(J)
C
C          FRAGMENT JET J IN /JETSET/ INTO PRIMARY HADRONS USING THE
C          ALGORITHM OF FIELD AND FEYNMAN WITH
C          F(X)=1-XGEN(1)+XGEN(1)*(XGEN(2)+1)*(1-X)**XGEN(2)
C          FOR LIGHT QUARKS AND THE PETERSON F(X) WITH
C          EPSILON=XGEN(I)*AMASS(I)**2
C          FOR HEAVY QUARKS.
C          INCLUDE BARYONS USING DIQUARKS WITH PROBABILITY PBARY.
C          PROBABILITY PSPIN1 FOR SPIN 1 DEPENDS ON HEAVIEST FLAVOR.
C          FRAGMENT A GLUON LIKE A RANDOM QUARK.
C
C          Ver 7.30: Use delta function fragmentation for top quark.
C
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      COMMON/FRGPAR/PUD,PBARY,SIGQT,PEND,XGEN(8),PSPIN1(8),
     $PMIX1(3,2),PMIX2(3,2),XGENSS(9)
      SAVE /FRGPAR/
      EQUIVALENCE (PMIX1(1,1),PMIXX1(1))
      EQUIVALENCE (PMIX2(1,1),PMIXX2(1))
      EQUIVALENCE(FRPAR(1),PUD)
      REAL      PUD,PBARY,SIGQT,PEND,XGEN,PSPIN1,PMIX1,PMIX2,XGENSS,
     +          PMIXX1(6),PMIXX2(6),FRPAR(32)
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/MBPAR/PUD0,PJSPN,PISPN,SIGQT0,XGEN0(2),PMIX01(3,2)
     1,PMIX02(3,2),PBARY0
      SAVE /MBPAR/
      REAL      PUD0,PJSPN,PISPN,SIGQT0,XGEN0,PMIX01,PMIX02,PBARY0
C
      LOGICAL HEAVY
      NBEGIN=NPTCL+1
      PSUM=0.
      IFLBEG=JTYPE(J)
      HEAVY=.FALSE.
      IF(IABS(IFLBEG).GT.3.AND.IFLBEG.NE.9) HEAVY=.TRUE.
      PBEG=SQRT(PJSET(1,J)**2+PJSET(2,J)**2+PJSET(3,J)**2)
C          TOP QUARK...
      IF(IABS(IFLBEG).GE.6.AND.IABS(IFLBEG).LE.8) THEN
        NPTCL=NPTCL+1
        PPTCL(1,NPTCL)=0
        PPTCL(2,NPTCL)=0
        PPTCL(3,NPTCL)=PBEG
        PPTCL(4,NPTCL)=PJSET(4,J)
        PPTCL(5,NPTCL)=PJSET(5,J)
        IORIG(NPTCL)=-J
        IDCAY(NPTCL)=0
        IDENT(NPTCL)=JTYPE(J)
        RETURN
      ENDIF
C          EQUIVALENT QUARK FOR GLUON
      IF(IFLBEG.NE.9) GO TO 200
      IFLBEG=INT(RANF()/PUD)+1
      IF(RANF().GT..5) IFLBEG=-IFLBEG
C          CONSTRUCT FIRST QUARK
200   LOOP=0
      IFL1=IFLBEG
      CALL GETPT(PT1,SIGQT)
      PHI1=2.*PI*RANF()
      PX1=PT1*COS(PHI1)
      PY1=PT1*SIN(PHI1)
      PPLUS=PBEG+PJSET(4,J)
      PTRUE=PPLUS
935   CONTINUE
C          CONSTRUCT NEXT QUARK
300   LOOP=LOOP+1
      IF(PPLUS.LT.PEND.OR.LOOP.GT.10000) RETURN
C          IFL2 CAN BE DIQUARK ONLY IF IFL1 IS NOT
      IF(MOD(IFL1,100).EQ.0) GO TO 305
      IF(RANF().LT.PBARY) GO TO 310
      IFL2=ISIGN(INT(RANF()/PUD)+1,-IFL1)
      GO TO 320
305   IFL2=ISIGN(INT(RANF()/PUD)+1,+IFL1)
      GO TO 320
310   IQ1=INT(RANF()/PUD)+1
      IQ2=INT(RANF()/PUD)+1
      IF(IQ1.LE.IQ2) GO TO 315
      ISWAP=IQ1
      IQ1=IQ2
      IQ2=ISWAP
315   IFL2=ISIGN(1000*IQ1+100*IQ2,IFL1)
320   CONTINUE
      CALL GETPT(PT2,SIGQT)
      PHI2=2.*PI*RANF()
      PX2=PT2*COS(PHI2)
      PY2=PT2*SIN(PHI2)
C          CONSTRUCT MESON WITH FLAVOR MIXING
C          SPECIAL CASE - SUPERSYM
      IFLABS=IABS(IFL1)
      IF(IFLABS.GT.20.AND.IFLABS.LT.30) THEN
        IDHAD=IFL1
        GOTO 470
      ENDIF
      IF(MOD(IFL1,100).EQ.0) GO TO 420
      IF(MOD(IFL2,100).EQ.0) GO TO 425
      IHIGH=MAX0(IABS(IFL1),IABS(IFL2))
      JSPIN=INT(RANF()+PSPIN1(IHIGH))
      ID1=IFL1
      ID2=IFL2
      IF(ID1+ID2.NE.0) GO TO 400
      RND=RANF()
      ID1=IABS(ID1)
      ID1=INT(PMIX1(ID1,JSPIN+1)+RND)+INT(PMIX2(ID1,JSPIN+1)+RND)+1
      ID2=-ID1
400   IF(IABS(ID1).LE.IABS(ID2)) GO TO 410
      ISAVE=ID1
      ID1=ID2
      ID2=ISAVE
410   IDHAD=ISIGN(100*IABS(ID1)+10*IABS(ID2)+JSPIN,ID1)
      GO TO 470
C          CONSTRUCT BARYON IDENT.
420   ID3=MOD(IFL1/100,10)
      ID2=IFL1/1000
      ID1=IFL2
      GO TO 430
425   ID3=MOD(IFL2/100,10)
      ID2=IFL2/1000
      ID1=IFL1
430   IF(IABS(ID1).LE.IABS(ID2)) GO TO 431
      ISWAP=ID1
      ID1=ID2
      ID2=ISWAP
431   IF(IABS(ID2).LE.IABS(ID3)) GO TO 432
      ISWAP=ID2
      ID2=ID3
      ID3=ISWAP
432   IF(IABS(ID1).LE.IABS(ID2)) GO TO 440
      ISWAP=ID1
      ID1=ID2
      ID2=ISWAP
440   JSPIN=1
      IF(ID1.EQ.ID2.AND.ID2.EQ.ID3) GO TO 450
      IHIGH=IABS(ID3)
      JSPIN=INT(RANF()+PSPIN1(IHIGH))
450   IF(JSPIN.EQ.1.OR.ID1.EQ.ID2.OR.ID2.EQ.ID3) GO TO 460
      IF(RANF().GT.PISPN) GO TO 460
      ISWAP=ID1
      ID1=ID2
      ID2=ISWAP
460   IDHAD=1000*IABS(ID1)+100*IABS(ID2)+10*IABS(ID3)+JSPIN
      IDHAD=ISIGN(IDHAD,IFL1)
470   CONTINUE
      AM=AMASS(IDHAD)
      PX=PX1+PX2
      PY=PY1+PY2
      AMT2=PX**2+PY**2+AM**2
C          IF LEADING PARTICLE, FIND MINIMUM X
      XMIN=0.
      IF(LOOP.EQ.1) XMIN=AMIN1(SQRT(AMT2)/PPLUS,1.)
C          SELECT X
C          USE FIELD-FEYNMAN FUNCTION FOR LIGHT QUARKS.
C          USE PETERSON FRAGMENTATION FOR HEAVY QUARKS.
C          USE DISTRIBUTION FOR HEAVIER QUARK FOR DIQUARKS.
      II1=IABS(IFL1)
      IF(MOD(II1,100).EQ.0) II1=MOD(II1/100,10)
      IF(II1.LE.3) THEN
        X=RANF()
        IF(RANF().LT.XGEN(1)) X=1.-X**(1./(XGEN(2)+1.))
      ELSEIF(II1.LE.9) THEN
        CALL HEAVYX(X,XGEN(II1)/AM**2)
      ELSEIF(II1.GT.20.AND.II1.LT.30) THEN
        CALL HEAVYX(X,XGENSS(II1-20)/AM**2)
      ENDIF
      X=XMIN+(1.-XMIN)*X
      QPLUS=X*PPLUS
      QPLUS=AMAX1(QPLUS,1.E-6)
      QMINUS=AMT2/QPLUS
      P0=.5*(QPLUS+QMINUS)
      PZ=.5*(QPLUS-QMINUS)
C          DISCARD PARTICLE IF PZ<0
      IF(PZ.LT.0..AND..NOT.(HEAVY.AND.LOOP.EQ.1)) GO TO 500
C          ADD PARTICLE TO /PARTCL/
      IF(NPTCL.GE.MXPTCL) GO TO 9999
      NPTCL=NPTCL+1
      PPTCL(1,NPTCL)=PX
      PPTCL(2,NPTCL)=PY
      PPTCL(3,NPTCL)=PZ
      PPTCL(4,NPTCL)=P0
      PPTCL(5,NPTCL)=AM
      IORIG(NPTCL)=-J
      IDCAY(NPTCL)=0
      IDENT(NPTCL)=IDHAD
      PSUM=PSUM+QPLUS
C          SWAP QUARKS AND CONTINUE IF SUFFICIENT PPLUS
500   CONTINUE
      PX1=-PX2
      PY1=-PY2
      IFL1=-IFL2
      PPLUS=(1.-X)*PPLUS
      GO TO 300
C
9999  CALL PRTEVT(0)
      WRITE(ITLIS,10) NPTCL
10    FORMAT(//5X,'ERROR IN JETGEN...NPTCL >',I5)
      RETURN
      END
CDECK  ID>, LABEL.  
      FUNCTION LABEL(ID)
C
C          Return the CHARACTER*8 label for the particle ID.
C          Quark-based IDENT code.
C          MSSM names for squarks, sleptons, Higgs bosons.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QLMASS/AMLEP(100),NQLEP,NMES,NBARY
      SAVE /QLMASS/
      INTEGER   NQLEP,NMES,NBARY
      REAL      AMLEP
C
      INTEGER ID
      CHARACTER*8 LABEL
      CHARACTER*8 LLEP,LMES0,LMES1,LBAR0,LABAR0,LBAR1,LABAR1
      CHARACTER*8 LQQ,LAQQ
      DIMENSION LLEP(147)
      DIMENSION LMES0(64),LMES1(64)
      DIMENSION LBAR0(109),LABAR0(109),LBAR1(109),LABAR1(109)
      DIMENSION LQQ(21),LAQQ(21)
      INTEGER IFL1,IFL2,IFL3,JSPIN,INDEX,I,J,IDABS
C
C          Diquark labels
C
      DATA LQQ/
     1'UU0. ','UD0. ','DD0. ','US0. ','DS0. ','SS0. ','UC0. ','DC0. ',
     2'SC0. ','CC0. ','UB0. ','DB0. ','SB0. ','CB0. ','BB0. ','UT0. ',
     3'DT0. ','ST0. ','CT0. ','BT0. ','TT0. '/
      DATA LAQQ/
     1'AUU0.','AUD0.','ADD0.','AUS0.','ADS0.','ASS0.','AUC0.','ADC0.',
     2'ASC0.','ACC0.','AUB0.','ADB0.','ASB0.','ACB0.','ABB0.','AUT0.',
     3'ADT0.','AST0.','ACT0.','ABT0.','ATT0.'/
C
C          Quark and lepton labels
C
      DATA LLEP/
     $'     ','UP   ','UB   ','DN   ','DB   ','ST   ','SB   ','CH   ',
     $'CB   ','BT   ','BB   ','TP   ','TB   ','Y    ','YB   ','X    ',
     $'XB   ','GL   ','ERR  ','GM   ','ERR  ','NUE  ','ANUE ','E-   ',
     $'E+   ','NUM  ','ANUM ','MU-  ','MU+  ','NUT  ','ANUT ','TAU- ',
     $'TAU+ ','ERR  ','ERR  ','ERR  ','ERR  ','ERR  ','ERR  ','KS   ',
     $'ERR  ','ERR  ','KL   ',
     $'UPL  ','UBL  ','DNL  ','DBL  ','STL  ','SBL  ','CHL  ','CBL  ',
     $'BT1  ','BB1  ','TP1  ','TB1  ','ERR  ','ERR  ','ERR  ','ERR  ',
     $'GLSS ','ERR  ','Z1SS ','ERR  ','NUEL ','ANUEL','EL-  ','EL+  ',
     $'NUML ','ANUML','MUL- ','MUL+ ','NUTL ','ANUTL','TAU1-','TAU1+',
     $'ERR  ','ERR  ','ERR  ','ERR  ','W1SS+','W1SS-','Z2SS ','ERR  ',
     $'UPR  ','UBR  ','DNR  ','DBR  ','STR  ','SBR  ','CHR  ','CBR  ',
     $'BT2  ','BB2  ','TP2  ','TB2  ','ERR  ','ERR  ','ERR  ','ERR  ',
     $'W2SS+','W2SS-','Z3SS ','ERR  ','NUER ','ANUER','ER-  ','ER+  ',
     $'NUMR ','ANUMR','MUR- ','MUR+ ','NUTR ','ANUTR','TAU2-','TAU2+',
     $'ERR  ','ERR  ','ERR  ','ERR  ','ERR  ','ERR  ','Z4SS ','ERR  ',
     $'W+   ','W-   ','HIGGS','ERR  ','HL0  ','ERR  ','HH0  ','ERR  ',
     $'HA0  ','ERR  ','H40  ','AH40 ','H+   ','H-   ','H2+  ','H2-  ',
     $'H1++ ','H1-- ','H2++ ','H2-- ','Z0   ','ERR  ','GVSS ','ERR  '/
C
C          0- meson labels
C
      DATA LMES0/
     1'PI0  ','PI+  ','ETA  ','PI-  ','K+   ','K0   ','ETAP ','AK0  ',
     2'K-   ','AD0  ','D-   ','DS-  ','ETAC ','DS+  ','D+   ','D0   ',
     2'B+   ','B0   ','BS   ','BC   ','ETAB ','ABC  ','ABS  ','AB0  ',
     3'B-   ','UT.  ','DT.  ','ST.  ','CT.  ','BT.  ','TT.  ','TB.  ',
     4'TC.  ','TS.  ','TD.  ','TU.  ','UY.  ','DY.  ','SY.  ','CY.  ',
     5'BY.  ','TY.  ','YY.  ','YT.  ','YB.  ','YC.  ','YS.  ','YD.  ',
     6'YU.  ','UX.  ','DX.  ','SX.  ','CX.  ','BX.  ','TX.  ','YX.  ',
     7'XX.  ','XY.  ','XT.  ','XB.  ','XC.  ','XS.  ','XD.  ','XU.  '/
C
C          1- meson labels
C
      DATA LMES1/
     1'RHO0 ','RHO+ ','OMEG ','RHO- ','K*+  ','K*0  ','PHI  ','AK*0 ',
     2'K*-  ','AD*0 ','D*-  ','DS*- ','JPSI ','DS*+ ','D*+  ','D*0  ',
     3'B*+  ','B*0  ','BS*  ','BC*  ','UPSL ','ABC* ','ABS* ','AB0* ',
     4'B*-  ','UT*  ','DT*  ','ST*  ','CT*  ','BT*  ','TT*  ','TB*  ',
     5'TC*  ','TS*  ','TD*  ','TU*  ','UY*  ','DY*  ','SY*  ','CY*  ',
     6'BY*  ','TY*  ','YY*  ','YT*  ','YB*  ','YC*  ','YS*  ','YD*  ',
     7'YU*  ','UX*  ','DX*  ','SX*  ','CX*  ','BX*  ','TX*  ','YX*  ',
     8'XX*  ','XY*  ','XT*  ','XB*  ','XC*  ','XS*  ','XD*  ','XU*  '/
C
C          1/2+ baryon labels
C
      DATA LBAR0/
     1'ERR  ','P    ','N    ','ERR  ','ERR  ','S+   ','S0   ','S-   ',
     2'L    ','XI0  ','XI-  ','ERR  ','ERR  ','ERR  ','SC++ ','SC+  ',
     3'SC0  ','LC+  ','USC. ','DSC. ','SSC. ','SDC. ','SUC. ','UCC. ',
     4'DCC. ','SCC. ','ERR  ','ERR  ','ERR  ','ERR  ','UUB. ','UDB. ',
     5'DDB. ','DUB. ','USB. ','DSB. ','SSB. ','SDB. ','SUB. ','UCB. ',
     6'DCB. ','SCB. ','CCB. ','CSB. ','CDB. ','CUB. ','UBB. ','DBB. ',
     7'SBB. ','CBB. ','ERR  ','ERR  ','ERR  ','ERR  ','ERR  ','UUT. ',
     8'UDT. ','DDT. ','DUT. ','UST. ','DST. ','SST. ','SDT. ','SUT. ',
     9'UCT. ','DCT. ','SCT. ','CCT. ','CST. ','CDT. ','CUT. ','UBT. ',
     1'DBT. ','SBT. ','CBT. ','BBT. ','BCT. ','BST. ','BDT. ','BUT. ',
     2'UTT. ','DTT. ','STT. ','CTT. ','BTT. ','ERR  ','ERR  ','ERR  ',
     3'ERR  ','ERR  ','ERR  ','UUY. ','UDY. ','DDY. ','DUY. ','USY. ',
     4'DSY. ','SSY. ','SDY. ','SUY. ','UUX. ','UDX. ','DDX. ','DUX. ',
     5'USX. ','DSX. ','SSX. ','SDX. ','SUX. '/
      DATA LABAR0/
     1'ERR  ','AP   ','AN   ','ERR  ','ERR  ','AS-  ','AS0  ','AS+  ',
     2'AL   ','AXI0 ','AXI+ ','ERR  ','ERR  ','ERR  ','ASC--','ASC- ',
     3'ASC0 ','ALC- ','AUSC.','ADSC.','ASSC.','ASDC.','ASUC.','AUCC.',
     4'ADCC.','ASCC.','ERR  ','ERR  ','ERR  ','ERR  ','AUUB.','AUDB.',
     5'ADDB.','ADUB.','AUSB.','ADSB.','ASSB.','ASDB.','ASUB.','AUCB.',
     6'ADCB.','ASCB.','ACCB.','ACSB.','ACDB.','ACUB.','AUBB.','ADBB.',
     7'ASBB.','ACBB.','ERR  ','ERR  ','ERR  ','ERR  ','ERR  ','AUUT.',
     8'AUDT.','ADDT.','ADUT.','AUST.','ADST.','ASST.','ASDT.','ASUT.',
     9'AUCT.','ADCT.','ASCT.','ACCT.','ACST.','ACDT.','ACUT.','AUBT.',
     1'ADBT.','ASBT.','ACBT.','ABBT.','ABCT.','ABST.','ABDT.','ABUT.',
     2'AUTT.','ADTT.','ASTT.','ACTT.','ABTT.','ERR  ','ERR  ','ERR  ',
     3'ERR  ','ERR  ','ERR  ','AUUY.','AUDY.','ADDY.','ADUY.','AUSY.',
     4'ADSY.','ASSY.','ASDY.','ASUY.','AUUX.','AUDX.','ADDX.','ADUX.',
     5'AUSX.','ADSX.','ASSX.','ASDX.','ASUX.'/
C
C          3/2+ baryon labels
C
      DATA LBAR1/
     1'DL++ ','DL+  ','DL0  ','DL-  ','ERR  ','S*+  ','S*0  ','S*-  ',
     2'ERR  ','XI*0 ','XI*- ','OM-  ','ERR  ','ERR  ','UUC* ','UDC* ',
     3'DDC* ','ERR  ','USC* ','DSC* ','SSC* ','ERR  ','ERR  ','UCC* ',
     4'DCC* ','SCC* ','CCC* ','ERR  ','ERR  ','ERR  ','UUB* ','UDB* ',
     5'DDB* ','ERR  ','USB* ','DSB* ','SSB* ','ERR  ','ERR  ','UCB* ',
     6'DCB* ','SCB* ','CCB* ','ERR  ','ERR  ','ERR  ','UBB* ','DBB* ',
     7'SBB* ','CBB* ','BBB* ','ERR  ','ERR  ','ERR  ','ERR  ','UUT* ',
     8'UDT* ','DDT* ','ERR  ','UST* ','DST* ','SST* ','ERR  ','ERR  ',
     9'UCT* ','DCT* ','SCT* ','CCT* ','ERR  ','ERR  ','ERR  ','UBT* ',
     1'DBT* ','SBT* ','CBT* ','BBT* ','ERR  ','ERR  ','ERR  ','ERR  ',
     2'UTT* ','DTT* ','STT* ','CTT* ','BTT* ','TTT* ','ERR  ','ERR  ',
     3'ERR  ','ERR  ','ERR  ','UUY* ','UDY* ','DDY* ','ERR  ','USY* ',
     4'DSY* ','SSY* ','ERR  ','ERR  ','UUX* ','UDX* ','DDX* ','ERR  ',
     5'USX* ','DSX* ','SSX* ','ERR  ','ERR  '/
      DATA LABAR1/
     1'ADL--','ADL- ','ADL0 ','ADL+ ','ERR  ','AS*- ','AS*0 ','AS*+ ',
     2'ERR  ','AXI*0','AXI*+','AOM+ ','ERR  ','ERR  ','AUUC*','AUDC*',
     3'ADDC*','ERR  ','AUSC*','ADSC*','ASSC*','ERR  ','ERR  ','AUCC*',
     4'ADCC*','ASCC*','ACCC*','ERR  ','ERR  ','ERR  ','AUUB*','AUDB*',
     5'ADDB*','ERR  ','AUSB*','ADSB*','ASSB*','ERR  ','ERR  ','AUCB*',
     6'ADCB*','ASCB*','ACCB*','ERR  ','ERR  ','ERR  ','AUBB*','ADBB*',
     7'ASBB*','ACBB*','ABBB*','ERR  ','ERR  ','ERR  ','ERR  ','AUUT*',
     8'AUDT*','ADDT*','ERR  ','AUST*','ADST*','ASST*','ERR  ','ERR  ',
     9'AUCT*','ADCT*','ASCT*','ACCT*','ERR  ','ERR  ','ERR  ','AUBT*',
     1'ADBT*','ASBT*','ACBT*','ABBT*','ERR  ','ERR  ','ERR  ','ERR  ',
     2'AUTT*','ADTT*','ASTT*','ACTT*','ABTT*','ATTT*','ERR  ','ERR  ',
     3'ERR  ','ERR  ','ERR  ','AUUY*','AUDY*','ADDY*','ERR  ','AUSY*',
     4'ADSY*','ASSY*','ERR  ','ERR  ','AUUX*','AUDX*','ADDX*','ERR  ',
     5'AUSX*','ADSX*','ASSX*','ERR  ','ERR  '/
C
C          Entry
C
      LABEL='ERR'
      IDABS=IABS(ID)
      IF(IDABS.EQ.0) THEN
        LABEL='     '
        RETURN
      ENDIF
      CALL FLAVOR(ID,IFL1,IFL2,IFL3,JSPIN,INDEX)
      IF(INDEX.LE.0) RETURN
      IF(IDABS.GT.10000.OR.JSPIN.GT.1) GO TO 500
      IF(IDABS.LT.100) GO TO 200
      IF(IDABS.LT.1000) GO TO 100
      IF(ID.NE.0.AND.MOD(ID,100).EQ.0) GO TO 300
C
C          Baryons
C
      INDEX=INDEX-109*JSPIN-36*NMES-NQLEP
      INDEX=INDEX-12
      IF(JSPIN.EQ.0.AND.ID.GT.0) LABEL=LBAR0(INDEX)
      IF(JSPIN.EQ.0.AND.ID.LT.0) LABEL=LABAR0(INDEX)
      IF(JSPIN.EQ.1.AND.ID.GT.0) LABEL=LBAR1(INDEX)
      IF(JSPIN.EQ.1.AND.ID.LT.0) LABEL=LABAR1(INDEX)
      GO TO 999
C
C          Mesons
C
100   CONTINUE
      I=MAX0(IFL2,IFL3)
      J=-MIN0(IFL2,IFL3)
      INDEX=MAX0(I-1,J-1)**2+I+MAX0(I-J,0)
      IF(JSPIN.EQ.0) LABEL=LMES0(INDEX)
      IF(JSPIN.EQ.1) LABEL=LMES1(INDEX)
      GO TO 999
C
C          Quarks, leptons, etc.
C
200   CONTINUE
      INDEX=2*INDEX
      IF(ID.LE.0) INDEX=INDEX+1
      LABEL=LLEP(INDEX)
      GO TO 999
300   I=IABS(IFL1)
      J=IABS(IFL2)
      INDEX=I+J*(J-1)/2
      IF(ID.GT.0) LABEL=LQQ(INDEX)
      IF(ID.LT.0) LABEL=LAQQ(INDEX)
      RETURN
C
C          Special hadrons - used only in B decays
C
500   CONTINUE
      IF(ID.EQ.10121) THEN
        LABEL='A1+'
      ELSEIF(ID.EQ.-10121) THEN
        LABEL='A1-'
      ELSEIF(ID.EQ.10111) THEN
        LABEL='A10'
      ELSEIF(ID.EQ.10131) THEN
        LABEL='K1+'
      ELSEIF(ID.EQ.-10131) THEN
        LABEL='K1-'
      ELSEIF(ID.EQ.10231) THEN
        LABEL='K10'
      ELSEIF(ID.EQ.-10231) THEN
        LABEL='AK10'
      ELSEIF(ID.EQ.30131) THEN
        LABEL='K1*+'
      ELSEIF(ID.EQ.-30131) THEN
        LABEL='K1*-'
      ELSEIF(ID.EQ.30231) THEN
        LABEL='K1*0'
      ELSEIF(ID.EQ.-30231) THEN
        LABEL='AK1*0'
      ELSEIF(ID.EQ.132) THEN
        LABEL='K2*+'
      ELSEIF(ID.EQ.-132) THEN
        LABEL='K2*-'
      ELSEIF(ID.EQ.232) THEN
        LABEL='K2*0'
      ELSEIF(ID.EQ.-232) THEN
        LABEL='AK2*0'
      ELSEIF(ID.EQ.10110) THEN
        LABEL='F0'
      ELSEIF(ID.EQ.112) THEN
        LABEL='F2'
      ELSEIF(ID.EQ.10441) THEN
        LABEL='PSI2'
      ELSEIF(ID.EQ.20440) THEN
        LABEL='CHI0'
      ELSEIF(ID.EQ.20441) THEN
        LABEL='CHI1'
      ELSEIF(ID.EQ.20442) THEN
        LABEL='CHI2'
      ELSE
        LABEL='ERR'
      ENDIF
999   RETURN
      END
CDECK  ID>, LBOOST. 
      SUBROUTINE LBOOST(PREST,N,P1,P2)
C
C            BOOST 4-VECTORS P1 TO PREST REST FRAME
C            PUT RESULTING 4-VECTORS IN P2
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      DIMENSION PREST(4),P1(4,N),P2(4,N)
      DO 1 I=1,N
      WCN=SQRT(PREST(4)**2-PREST(1)**2-PREST(2)**2-PREST(3)**2)
      II=(I-1)*4
      P2(4,I)=(P1(4,I)*PREST(4)-P1(1,I)*PREST(1)-P1(2,I)*PREST(2)
     1         -P1(3,I)*PREST(3))/WCN
      FACT=(P2(4,I)+P1(4,I))/(WCN+PREST(4))
      DO 2 K=1,3
    2 P2(K,I)=P1(K,I)-FACT*PREST(K)
    1 CONTINUE
      RETURN
      END
CDECK  ID>, LOGERR. 
      SUBROUTINE LOGERR(IMSG,I,IERR)
C
C          ERROR MESSAGES
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD

C
C        ERRORS IN JET PARAMETERS
C
      IERR=IERR+1
      IF(IMSG.EQ.0) WRITE(ITLIS,81)
81    FORMAT(//5X,'DEFAULT LIMITS HAVE BEEN SET')
      IF(IMSG.EQ.1) WRITE(ITLIS,1001) I,PMIN(I),PMAX(I)
 1001 FORMAT(//10X,'BAD LIMITS FOR P(',I2,')=',2E12.4)
      IF(IMSG.EQ.2) WRITE(ITLIS,1002) I,PTMIN(I),PTMAX(I)
 1002 FORMAT(//10X,'BAD LIMITS FOR PT(',I2,')=',2E12.4)
      IF(IMSG.EQ.3) WRITE(ITLIS,1003) I,THMIN(I),THMAX(I)
 1003 FORMAT(//10X,'BAD LIMITS FOR THETA(',I2,')=',2E12.4)
      IF(IMSG.EQ.4) WRITE(ITLIS,1004) I,XJMIN(I),XJMAX(I)
 1004 FORMAT(//10X,'BAD LIMITS FOR X(',I2,')=',2E12.4)
      IF(IMSG.EQ.5) WRITE(ITLIS,1005) I,XJ(I),P(I)
 1005 FORMAT(//5X,'X AND P FOR JET',I2,' ARE INCOMPATIBLE',2E12.4)
      IF(IMSG.EQ.6) WRITE(ITLIS,1006) I,THMIN(I),THMAX(I)
 1006 FORMAT(//10X,'LIMITS FOR THETA MUST BE .GT.0 AND .LT.PI. PRESENT'
     C  ,' LIMITS FOR JET NO.',I3,' ARE',2E12.4)
      IF(IMSG.EQ.7) WRITE(ITLIS,1007) I,XJ(I),X1,X2
 1007 FORMAT(//5X,'FIXED X VALUE FOR JET NO.',I3,' IS',E12.4,2X,
     C  'THIS IS INCOMPATIBLE WITH ALLOWED X LIMITS',2E12.4)
C
C           ERRORS IN W(Z0) PARAMETERS
C
      IF(IMSG.EQ.101) WRITE(ITLIS,901) XW,XWMIN,XWMAX
  901 FORMAT(//5X,'CHOICE OF PARAMETERS GIVES A FIXED XW',E12.4,
     C  ' ,THIS VALUE IS INCOMPATIBLE WITH THE LIMITS',2E12.4)
      IF(IMSG.EQ.102) WRITE(ITLIS,902) YW,YWMIN,YWMAX
  902 FORMAT(//5X,'CHOICE OF PARAMETERS GIVES A FIXED YW',
     C  E12.4,' ,THIS VALUE IS INCOMPATIBLE WITH THE LIMITS ')
      IF(IMSG.EQ.103) WRITE(ITLIS,903) QMW,QMIN,QMAX
  903 FORMAT(//5X,'CHOICE OF PARAMETERS GIVES A FIXED QMW',
     C  E12.4,' ,THIS VALUE IS INCOMPATIBLE WITH THE LIMITS',
     C  E12.4)
      IF(IMSG.EQ.104) WRITE(ITLIS,904) XW,YW,QTW
  904 FORMAT(//5X,'FIXED VALUES FOR XW,YW,AND QTW',3E12.4,
     C  ' ARE UNPHYSICAL')
      IF(IMSG.EQ.105) WRITE(ITLIS,905) QTW,QTMIN,QTMAX
  905 FORMAT(//5X,'CHOICE OF PARAMETERS GIVES A FIXED QTW',E12.4
     C  ,' ,THIS VALUE IS INCOMPATIBLE WITH THE LIMITS',2E12.4)
      IF(IMSG.EQ.106) WRITE(ITLIS,906) XW,YW,QMW
  906 FORMAT(//5X,'FIXED VALUS FOR XW,YW,AND QMW',3E12.4,
     C  ' ARE UNPHYSICAL')
      IF(IMSG.EQ.107) WRITE(ITLIS,907) QTMIN,QTMAX
  907 FORMAT(//5X,'BAD LIMITS FOR QTW',2E12.4)
      IF(IMSG.EQ.108) WRITE(ITLIS,908) QMIN,QMAX
  908 FORMAT(//5X,'BAD LIMITS FOR QMW',2E12.4)
      IF(IMSG.EQ.109) WRITE(ITLIS,909) THWMIN,THWMAX
  909 FORMAT(//5X,'BAD LIMITS FOR THW',2E12.4,2X,' REMEMBER TH MUST',
     C  ' BE IN RADIANS AND LIE BETWEEN 0 AND PI')
      IF(IMSG.EQ.110) WRITE(ITLIS,910) PHWMIN,PHWMAX
  910 FORMAT(//5X,'BAD LIMITS FOR PHW',2E12.4,' ,REMEMBER PHW MUST',
     C  ' BE IN RADIANS AND PHMAX-PHMIN MUST BE LESS THAN 2PI')
      IF(IMSG.EQ.111) WRITE(ITLIS,911) XWMIN,XWMAX
  911 FORMAT(//5X,'BAD LIMITS FOR XW',2E12.4)
      IF(IMSG.EQ.112) WRITE(ITLIS,912) YWMIN,YWMAX
  912 FORMAT(//5X,'BAD LIMITS FOR YW',2E12.4)
      IF(IMSG.EQ.113) WRITE(ITLIS,913)
  913 FORMAT(//5X,'SORRY, BUT YOU CANNOT FIX THETA FOR DRELLYAN EVENTS.'
     C,'  THINK OF SOMETHING ELSE.')
      IF(IMSG.EQ.114) WRITE(ITLIS,914)
  914 FORMAT(//5X,'YOU CANNOT FIX PARAMETERS FOR THE DECAY OF A',
     C  ' DRELL YAN JET')
      IF(IMSG.EQ.115) WRITE(ITLIS,915)
  915 FORMAT(//5X,'YOU CANNOT FIX QTW,QMW,YW AND XW SIMULTANEUOSLY')
C
C       ERRORS IN E+E- PARAMETERS
C
      IF(IMSG.EQ.116)
     1WRITE(ITLIS,631) THMIN(1),THMAX(1),THMIN(2),THMAX(2)
631   FORMAT(//10X,'THETA LIMITS',2E12.4,' FOR JET 1 AND',2E12.4
     C  ,' FOR JET 2 ARE INCOMPATIBLE')
C
      RETURN
      END
CDECK  ID>, LOGIC.  
      SUBROUTINE LOGIC
C
C                            10/ 3/80
C            STARTING FROM USER DATA FIND OUT WHICH PARAMETERS SHOULD
C            BE FIXED AND WHICH LIMITS SHOULD BE SET
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      LOGICAL COMB(8)
      DIMENSION DELPH(3)
C
C        LOGICAL FUNCTIONS
C
      LOGICAL LOGP,LOGPT,LOGYTH,LOGX,LOGPHI
      LOGICAL LOGQM,LOGQT,LOGYW,LOGTHW,LOGPHW,LOGXW
      DATA UNDEF/-.9E9/
      DATA ZERO/.00001/,ONE/.99999/
C
C            INVERSE HYPERBOLIC COSINE FUNCTION
      ACOSH(X)=ALOG(X+SQRT(X**2-1.0))
C            INVERSE HYPERBOLIC SINE FUNCTION
      ASINH(X)=ALOG(X+SQRT(X**2+1.0))
C
C          INITIALIZE CONSTANTS
C
      HALFPI=PI/2.
      IFATAL=0
      IERR=0
      DO 1 I=1,36
      SETLMJ(I)=.TRUE.
      IF(BLIMS(I).GT.UNDEF) SETLMJ(I)=.FALSE.
    1 CONTINUE
      DO 2 I=1,12
      SETLMQ(I)=.TRUE.
      IF(BLIM1(I).GT.UNDEF) SETLMQ(I)=.FALSE.
    2 CONTINUE
C
C          SET STANDARD DRELL-YAN IF FIXED QTW=0.
      IF(KEYS(3)) THEN
        IF(QTMIN.EQ.0..AND.QTMAX.LT.UNDEF) THEN
          STDDY=.TRUE.
        ELSE
          STDDY=.FALSE.
        ENDIF
      ELSEIF(KEYS(7).OR.KEYS(9)) THEN
        STDDY=.TRUE.
      ENDIF
C
      IF(STDDY) THEN
        NJET=2
        FIXPT(3)=.TRUE.
        PT(3)=0.
        PTMIN(3)=0.
        PTMAX(3)=0.
        FIXPHI(3)=.FALSE.
        PHIMIN(3)=0.
        PHIMAX(3)=2.*PI
        DELPH(3)=2.*PI
        FIXPHW=.TRUE.
        PHWMIN=0.
        PHWMAX=-1.E9
        PHIW=0.
        QTMIN=0.
        QTMAX=-1.E9
        QTW=0.
        FIXQT=.FALSE.
      ENDIF
C
C      CHECK THAT PARAMETER RANGES MAKE SENSE
C
C            DO LOGIC FOR P
      IF(.NOT.LOGP(IERR)) IFATAL=IFATAL+1
C            DO LOGIC FOR PT
      IF(.NOT.LOGPT(IERR)) IFATAL=IFATAL+1
C            DO LOGIC FOR THETA AND YJ(RAPIDITY)
      IF(.NOT.LOGYTH(IERR)) IFATAL=IFATAL+1
C            DO LOGIC FOR XJ(FEYNMAN X)
C            XJ LIMITS DO NOT REDEFINE PT LIMITS
      IF(.NOT.LOGX(IERR)) IFATAL=IFATAL+1
C            DO LOGIC FOR PHI
C            NOTE THAT PHI INTERVAL IS DEFINED BY PHIMAX-PHIMIN
      IF(.NOT.LOGPHI(IERR,DELPH)) IFATAL=IFATAL+1
C
C          SET DEFAULT PT LIMITS IF NONE WERE SET
      IF((KEYS(1).OR.KEYS(5).OR.KEYS(6)).AND.
     $(PTMAX(1).GT..99*HALFE).AND.(PTMAX(2).GT..99*HALFE)) THEN
        PTMIN(1)=0.1*HALFE
        PTMIN(2)=PTMIN(1)
        PTMAX(1)=0.4*HALFE
        PTMAX(2)=PTMAX(1)
        CALL LOGERR(0,1,IERR)
      ENDIF
C
C          CHECK Y LIMITS WITH FINAL PT LIMITS.
      IF(KEYS(1).OR.KEYS(5).OR.KEYS(6)) THEN
        YMXPT=ALOG(ECM/PTMIN(1))
        DO 11 I=1,2
        YJMAX(I)=AMIN1(YJMAX(I),YMXPT)
11      YJMIN(I)=AMAX1(YJMIN(I),-YMXPT)
      ENDIF
C
C            DO LOGIC FOR DRELL YAN VARIABLES
      IF(KEYS(3).OR.KEYS(7).OR.KEYS(9)) THEN
C            DO LOGIC FOR QM
        IF(.NOT.LOGQM(IERR)) IFATAL=IFATAL+1
C            DO LOGIC FOR QT
        IF(.NOT.LOGQT(IERR)) IFATAL=IFATAL+1
C            DO LOGIC FOR YW
        IF(.NOT.LOGYW(IERR)) IFATAL=IFATAL+1
C            DO LOGIC FOR THETA
        IF(.NOT.LOGTHW(IERR)) IFATAL=IFATAL+1
C            DO LOGIC FOR PHW
C            NOTE THAT PHW INTERVAL DEFINED BY PHWMAX-PHWMIN
        IF(.NOT.LOGPHW(IERR,DELPH)) IFATAL=IFATAL+1
C            DO LOGIC FOR XW
        IF(.NOT.LOGXW(IERR)) IFATAL=IFATAL+1
C
      ENDIF
C
C            CHECK FOR INCONSISTENCIES
      DO 21 I=1,NJET
      SMIN=SIN(THMIN(I))
      SMAX=SIN(THMAX(I))
      IF(SMAX.LT.SMIN) SMIN=SMAX
      PT1=PMIN(I)*SMIN
      IF(PT1.GT.PTMIN(I)) PTMIN(I)=PT1
      SMAX=1.0
      IF(THMAX(I).LT.ONE*HALFPI) SMAX=SIN(ONE*THMAX(I))
      IF(THMIN(I).GT.ONE*HALFPI) SMAX=SIN(ONE*THMIN(I))
      PT1=PMAX(I)*SMAX
      IF(PT1.LT.ONE*PTMAX(I)) PTMAX(I)=PT1
      IF(PTMAX(I).LT.ONE*PTMIN(I)) CALL LOGERR(2,I,IFATAL)
      IF(PMAX(I).LT.ONE*PMIN(I)) CALL LOGERR(1,I,IFATAL)
      IF(THMAX(I).LT.ONE*THMIN(I)) CALL LOGERR(3,I,IFATAL)
      IF(XJMAX(I).LT.ONE*XJMIN(I)) CALL LOGERR(4,I,IFATAL)
      IF(ABS(XJMAX(I)).GT.1.0+ZERO.OR.ABS(XJMIN(I)).GT.1.0+ZERO)
     1    CALL LOGERR(4,I,IFATAL)
      IF(THMIN(I).LT.-ZERO.OR.THMAX(I).GT.PI+ZERO)
     $CALL LOGERR(6,I,IFATAL)
C
      IF(FIXXJ(I)) THEN
        X1=PMAX(I)*COS(THMIN(I))/HALFE
        X2=PMIN(I)*COS(THMAX(I))/HALFE
        X3=PMAX(I)*COS(THMIN(I))/HALFE
        IF(X3.LT.X2) X2=X3
        IF(X1.EQ.X2) XJ(I)=X1
        IF(XJ(I).LT.ONE*X2.OR.XJ(I).GT.X1/ONE) CALL LOGERR(7,I,IFATAL)
      ENDIF
C
   21 CONTINUE
C
C            CHECK THAT PARAMETERS FOR DRELL YAN ARE CONSISTENT
C
      IF(KEYS(3)) THEN
        COMB(1)=.FALSE.
        DO 31 I=1,2
        COMB(1)=COMB(1).OR.FIXP(I).OR.FIXPT(I).OR.FIXYJ(I).OR.FIXPHI(I)
     1  .OR.FIXXJ(I)
   31   CONTINUE
        IF(COMB(1)) CALL LOGERR(114,1,IFATAL)
        COMB(1)=FIXQT.AND.FIXQM
        COMB(2)=FIXQT.AND.FIXYW
        COMB(3)=FIXQM.AND.FIXYW
        COMB(4)=COMB(1).AND.FIXYW
        COMB(5)=COMB(1).AND.FIXXW
        COMB(6)=COMB(2).AND.FIXXW
        COMB(7)=COMB(3).AND.FIXXW
        IF(COMB(4).AND.FIXXW) CALL LOGERR(115,1,IFATAL)
        IF(COMB(4)) FIXXW=.TRUE.
C
        IF(COMB(4)) THEN
          FIXXW=.TRUE.
          XW=SQRT(QTW**2+QMW**2)*SINH(YW)/HALFE
          IF(XW.LT.XWMIN-ZERO.OR.XW.GT.XWMAX+ZERO)
     $     CALL LOGERR(101,1,IFATAL)
          XWMIN=XW
          XWMAX=XW
        ENDIF
C
        IF(COMB(5)) THEN
          FIXYW=.TRUE.
          YW=ASINH(HALFE*XW/SQRT(QTW**2+QMW**2))
      IF(YW.LT.YWMIN-ZERO.OR.YW.GT.YWMAX+ZERO)
     $CALL LOGERR(102,1,IFATAL)
          YWMIN=YW
          YWMAX=YW
        ENDIF
C
        IF(COMB(6)) THEN
        IF(XW.NE.0.) THEN
          QMW2=((XW*HALFE)/SINH(YW))**2-QTW**2
          IF(QMW2.GE.0) THEN
            QMW=SQRT(QMW2)
      IF(QMW.LT.ONE*QMIN.OR.QMW.GT.QMAX/ONE)
     $CALL LOGERR(103,1,IFATAL)
          ENDIF
          CALL LOGERR(104,1,IFATAL)
        ENDIF
        ENDIF
C
        IF(COMB(7).AND.(YW.NE.0)) THEN
          FIXQT=.TRUE.
          FIXPT(3)=.TRUE.
          QTW2=((XW*HALFE)/SINH(YW))**2-QMW**2
          IF(QTW2.GE.0) THEN
            QTW=SQRT(QTW2)
            PT(3)=QTW
      IF(QTW.LT.ONE*QTMIN.OR.QTW.GT.QTMAX/ONE)
     $CALL LOGERR(105,1,IFATAL)
          ENDIF
          CALL LOGERR(106,1,IFATAL)
        ENDIF
C
        IF(QTMIN.GT.QTMAX/ONE) CALL LOGERR(107,1,IFATAL)
        IF(QMIN.GT.QMAX/ONE) CALL LOGERR(108,1,IFATAL)
        IF(THWMIN.GT.THWMAX/ONE) CALL LOGERR(109,1,IFATAL)
        IF(PHWMIN.GT.PHWMAX/ONE) CALL LOGERR(110,1,IFATAL)
        IF(XWMIN.GT.XWMAX/ONE) CALL LOGERR(111,1,IFATAL)
        IF(YWMIN.GT.YWMAX+ZERO) CALL LOGERR(112,1,IFATAL)
        IF(ABS(XWMIN).GT.1.0+ZERO.OR.ABS(XWMAX).GT.1.0+ZERO)
     1  CALL LOGERR(111,1,IFATAL)
      IF(THWMIN.LT.-ZERO.OR.THWMAX.GT.PI+ZERO)
     $CALL LOGERR(109,1,IFATAL)
      ENDIF
C
C          SPECIAL LOGIC FOR E+E- EVENTS
C
      IF(KEYS(2)) THEN
        THLOW=AMAX1(THMIN(1),PI-THMAX(2))
        THHIGH=AMAX1(THMAX(1),PI-THMIN(2))
        IF(THHIGH-THLOW.LT.ZERO.AND..NOT.(FIXYJ(1).OR.FIXYJ(2))) THEN
          CALL LOGERR(116,1,IFATAL)
        ELSE
          DO 61 I=1,2
          FIXYJ(I)=FIXYJ(1).OR.FIXYJ(2)
          FIXXJ(I)=FIXXJ(1).OR.FIXXJ(2)
          FIXPT(I)=FIXPT(1).OR.FIXPT(2)
          THMIN(I)=THLOW
          THMAX(I)=THHIGH
          IF(FIXYJ(I)) THMAX(I)=THMIN(I)
          XJMIN(I)=COS(THMAX(I))
          XJMAX(I)=COS(THMIN(I))
          PTMIN(I)=HALFE*AMIN1(SIN(THMIN(I)),SIN(THMAX(I)))
          IF(ABS(XJMAX(I)).LT.1.) YJMAX(I)=
     1    .5*ALOG((1.+XJMAX(I))/(1.-XJMAX(I)))
          IF(ABS(XJMIN(I)).LT.1.) YJMIN(I)=
     1    .5*ALOG((1.+XJMIN(I))/(1.-XJMIN(I)))
   61     CONTINUE
        ENDIF
      ENDIF
C
C
      IF(IFATAL.NE.0) THEN
        WRITE(ITLIS,1020) IFATAL
 1020   FORMAT(////10X,I10,' FATAL ERRORS, JOB TERMINATED')
        STOP 99
      ENDIF
C
C
      RETURN
      END
CDECK  ID>, LOGP.   
      LOGICAL FUNCTION LOGP(IERR)
C
C       SET AND CHECK LIMITS FOR JET MOMENTA
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      DATA PLOW/1.0/
      DATA UNDEF/-.9E9/
C
      LOGP=.TRUE.
      DO 10 I=1,NJET
      FIXP(I)=.FALSE.
      IF(PMIN(I).LT.UNDEF.AND.PMAX(I).LT.UNDEF)  PMAX(I)=HALFE
      IF(PMAX(I).GT.HALFE) PMAX(I)=HALFE
      IF(PMAX(I).LT.UNDEF) FIXP(I)=.TRUE.
      IF(PMIN(I).LT.UNDEF) PMIN(I)=PLOW
      IF(FIXP(I)) THEN
        PMAX(I)=PMIN(I)
        P(I)=PMIN(I)
      ENDIF
      IF(KEYS(3).AND.I.EQ.3.AND.QTMIN.GT.0) PMIN(I)=QTMIN
   10 CONTINUE
C
      RETURN
      END
CDECK  ID>, LOGPHI. 
      LOGICAL FUNCTION LOGPHI(IERR,DELPH)
C
C        SET AND CHECK LIMITS FOR JET PHI
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      DIMENSION DELPH(3)
      DATA UNDEF/-.9E9/
C
      LOGPHI=.TRUE.
C
C
      DO 50 I=1,NJET
      FIXPHI(I)=.FALSE.
C
      IF(PHIMAX(I).LT.UNDEF.AND.PHIMIN(I).LT.UNDEF) THEN
        PHIMIN(I)=0.
        PHIMAX(I)=2.*PI
        DELPH(I)=PHIMAX(I)
      ELSE
        IF(PHIMAX(I).LT.UNDEF) FIXPHI(I)=.TRUE.
C
        IF(FIXPHI(I)) THEN
          PHI(I)=PHIMIN(I)
          PHIMAX(I)=PHIMIN(I)
          IF(KEYS(3).AND.I.LT.3) THEN
            LOGPHI=.FALSE.
            CALL LOGERR(105,I,IERR)
          ENDIF
          IF(I.EQ.2) THEN
            FIXPHI(1)=.TRUE.
            PHIMIN(1)=PHIMIN(2)
            PHIMAX(1)=PHIMIN(1)
          ENDIF
        ENDIF
C
        DELPH(I)=PHIMAX(I)-PHIMIN(I)
C
        IF(DELPH(I).GT.2.*PI.OR.DELPH(I).LT.0) THEN
          LOGPHI=.FALSE.
          CALL LOGERR(8,I,IERR)
        ENDIF
C
      ENDIF
C
   50 CONTINUE
C
C
      IF(KEYS(1).AND.DELPH(1).GT.DELPH(2)) THEN
        PHIMIN(1)=PHIMIN(2)+PI
        PHIMAX(1)=PHIMIN(1)+DELPH(2)
      ENDIF
C
      RETURN
      END
CDECK  ID>, LOGPHW. 
      LOGICAL FUNCTION LOGPHW(IERR,DELPH)
C
C       SET AND CHECK LIMITS FOR W(Z0) PHI
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      DIMENSION DELPH(3)
      DATA UNDEF/-.9E9/
C
      LOGPHW=.TRUE.
      FIXPHW=.FALSE.
C
      IF(FIXPHI(3)) THEN
          FIXPHW=.TRUE.
          PHIW=AMOD(PHI(3)+PI,2.*PI)
      ELSEIF(PHWMIN.LT.UNDEF.AND.PHWMAX.LT.UNDEF) THEN
          PHWMIN=0.
          PHWMAX=2.*PI
      ELSEIF(PHWMAX.LT.UNDEF) THEN
          FIXPHW=.TRUE.
          PHW=PHWMIN
          FIXPHI(3)=.TRUE.
          PHWMAX=PHWMIN
          PHI(3)=PHIW+PI
          PHIMIN(3)=PHIW
          PHIMAX(3)=PHIW
      ENDIF
C
      DELPHW=PHWMAX-PHWMIN
C
      IF(DELPHW.LT.0.OR.DELPHW.GT.2.*PI) THEN
        CALL LOGERR(110,1,IERR)
        LOGPHW=.FALSE.
      ENDIF
C
      IF(DELPHW.LE.DELPH(3)) THEN
        PHIMIN(3)=PHWMIN+PI
        PHIMAX(3)=PHIMIN(3)+DELPHW
      ELSE
        PHWMIN=PHIMIN(3)+PI
        PHWMAX=PHWMIN+DELPH(3)
      ENDIF
C
      RETURN
      END
CDECK  ID>, LOGPT.  
      LOGICAL FUNCTION LOGPT(IERR)
C
C       SET AND CHECK LIMITS FOR JET PT
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      DATA PTLOW/1.0/
      DATA UNDEF/-.9E9/
C
      LOGPT=.TRUE.
      DO 20 I=1,NJET
      FIXPT(I)=.FALSE.
C
      IF(PTMIN(I).LT.UNDEF.AND.PTMAX(I).LT.UNDEF) THEN
        PTMAX(I)=PMAX(I)
        PTMIN(I)=PTLOW
        IF(KEYS(3).AND.I.EQ.3.AND.QTMIN.GT.0.) PTMIN(I)=QTMIN
        IF(PMIN(I).LT.PTMIN(I)) PMIN(I)=PTMIN(I)
      ELSEIF(PTMAX(I).LT.UNDEF) THEN
        FIXPT(I)=.TRUE.
        PTMAX(I)=PTMIN(I)
      ELSEIF(PTMIN(I).LT.UNDEF) THEN
        PTMIN(I)=PTLOW
        IF(KEYS(3).AND.I.EQ.3.AND.QTMIN.GT.0.) PTMIN(I)=QTMIN
      ENDIF
C
      IF(FIXPT(I)) PTMAX(I)=PTMIN(I)
      IF(FIXPT(I)) PT(I)=PTMIN(I)
      IF(PTMAX(I).GT.PMAX(I)) PTMAX(I)=PMAX(I)
      IF(PMIN(I).LT.PTMIN(I)) PMIN(I)=PTMIN(I)
C
   20 CONTINUE
C
      RETURN
      END
CDECK  ID>, LOGQM.  
      LOGICAL FUNCTION LOGQM(IERR)
C
C     Set and check limits for gamma*/W/Z0/Higgs mass range
C     Ver 7.14: Use HMASS+-5*HGAM for MSSM default range
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C
      REAL UNDEF
      INTEGER IERR
      DATA UNDEF/-.9E9/
C
      LOGQM=.TRUE.
      FIXQM=.FALSE.
      IF(QMIN.LT.UNDEF.AND.QMAX.LT.UNDEF) THEN
        IF(KEYS(7).AND.GOMSSM) THEN
C          For MSSM Higgs, set default limits around Higgs
          QMAX=HMASS+5*HGAM
          QMIN=HMASS-5*HGAM
        ELSE
C          Set default QMW limits if none were set.
          QMAX=0.2*ECM
          QMIN=0.05*ECM
        ENDIF
        CALL LOGERR(0,1,IERR)
      ENDIF
      IF(QMAX.LT.UNDEF) FIXQM=.TRUE.
      IF(FIXQM) THEN
        QMW=QMIN
        QMAX=QMIN
      ENDIF
C
      RETURN
      END
CDECK  ID>, LOGQT.  
      LOGICAL FUNCTION LOGQT(IERR)
C
C      SET AND CHECK W(Z0) PT RANGE
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      DATA UNDEF/-.9E9/
C
      LOGQT=.TRUE.
      FIXQT=.FALSE.
      IF(QTMIN.LT.UNDEF.AND.QTMAX.LT.UNDEF) THEN
        QTMAX=PTMAX(3)
        QTMIN=PTMIN(3)
C          SET DEFAULT QTW LIMITS IF NONE WERE SET
        IF(QTMAX.GT.0.99*HALFE) THEN
          NJET=2
          QTMIN=0.
          QTMAX=0.
          QTW=0.
          STDDY=.TRUE.
          FIXQT=.TRUE.
          PTMIN(3)=0.
          PTMAX(3)=0.
          FIXPT(3)=.TRUE.
          CALL LOGERR(0,1,IERR)
        ENDIF
      ELSEIF(FIXPT(3)) THEN
        QTW=PT(3)
        QTMIN=PTMIN(3)
        QTMAX=QTMIN
        FIXQT=.TRUE.
      ELSEIF(QTMAX.LT.UNDEF) THEN
        FIXQT=.TRUE.
        QTW=QTMIN
        QTMAX=QTMIN
        FIXPT(3)=.TRUE.
        PT(3)=QTW
        PTMIN(3)=QTMIN
        PTMAX(3)=QTMAX
      ELSE
        IF(QTMAX.LT.PTMAX(3)) PTMAX(3)=QTMAX
        IF(QTMIN.GT.PTMIN(3)) PTMIN(3)=QTMIN
        IF(QTMAX.GT.PTMAX(3)) QTMAX=PTMAX(3)
        IF(QTMIN.LT.PTMIN(3)) QTMIN=PTMIN(3)
      ENDIF
C
      RETURN
      END
CDECK  ID>, LOGTHW. 
      LOGICAL FUNCTION LOGTHW(IERR)
C
C        SET AND CHECK THETA LIMITS FOR W(Z0)
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      DATA UNDEF/-.9E9/
C
C            INVERSE HYPERBOLIC COSINE FUNCTION
      ACOSH(X)=ALOG(X+SQRT(X**2-1.0))
C            INVERSE HYPERBOLIC SINE FUNCTION
      ASINH(X)=ALOG(X+SQRT(X**2+1.0))
C
      HALFPI=PI/2.
      LOGTHW=.TRUE.
C
      IF(THWMIN.LT.UNDEF.AND.THWMAX.LT.UNDEF) THEN
          THWMIN=2.*ATAN(EXP(-YWMAX))
          THWMAX=2.*ATAN(EXP(-YWMIN))
      ELSEIF(THWMIN.GT.UNDEF) THEN
        IF(THWMAX.GT.UNDEF) THEN
          LOGTHW=.FALSE.
          CALL LOGERR(113,1,IERR)
        ELSE
          TAMIN=TAN(THWMIN)
          TAMAX=TAN(THWMAX)
          IF(THWMIN.LT.HALFPI)
     1    YWMX=ASINH(QTMAX/SQRT(QTMAX**2+QMIN**2)/TAMIN)
          IF(THWMIN.GE.HALFPI)
     1    YWMX=ASINH(QTMIN/SQRT(QTMIN**2+QMAX**2)/TAMIN)
          IF(THWMAX.GT.HALFPI)
     1    YWMN=ASINH(QTMAX/SQRT(QTMAX**2+QMIN**2)/TAMAX)
          IF(THWMAX.LT.HALFPI)
     1    YWMN=ASINH(QTMIN/SQRT(QTMIN**2+QMAX**2)/TAMAX)
          IF(YWMIN.LT.YWMN) YWMIN=YWMN
          IF(YWMAX.GT.YWMX) YWMAX=YWMX
          IF(FIXYW.AND.(YW.LT.YWMIN.OR.YW.GT.YWMAX)) THEN
            CALL LOGERR(102,1,IERR)
            LOGTHW=.FALSE.
          ENDIF
        ENDIF
      ENDIF
C
      IF(YWMIN.LT.0) THWMAX=ATAN2(QTMIN,SQRT(QTMIN**2+QMAX**2)*
     1              SINH(YWMIN))
      IF(YWMIN.GE.0) THWMAX=ATAN2(QTMAX,SQRT(QTMAX**2+QMIN**2)*
     1               SINH(YWMIN))
      IF(YWMAX.GE.0) THWMIN=ATAN2(QTMIN,SQRT(QTMIN**2+QMAX**2)*
     U               SINH(YWMAX))
      IF(YWMAX.LT.0) THWMIN=ATAN2(QTMAX,SQRT(QTMAX**2+QMIN**2)*
     1               SINH(YWMAX))
C
      RETURN
      END
CDECK  ID>, LOGX.   
      LOGICAL FUNCTION LOGX(IERR)
C
C         SET AND CHECK LIMITS FOR JET FEYNMAN X
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      DATA UNDEF/-.9E9/
C
      HALFPI=PI/2.
      LOGX=.TRUE.
C
      DO 40 I=1,NJET
      FIXXJ(I)=.FALSE.
      IF(FIXYJ(I).AND.(FIXP(I).OR.FIXPT(I)))FIXXJ(I)=.TRUE.
      IF(FIXXJ(I)) GOTO 40
C
      IF(XJMIN(I).LT.UNDEF.AND.XJMAX(I).LT.UNDEF) THEN
        XJMAX(I)=1.0
        XJMIN(I)=-1.0
      ENDIF
C
      IF(XJMAX(I).LT.UNDEF) FIXXJ(I)=.TRUE.
      IF(FIXXJ(I)) XJMAX(I)=XJMIN(I)
C
      IF(.NOT.FIXXJ(I)) THEN
        IF(THMIN(I).LT.HALFPI) X1=PMAX(I)*COS(THMIN(I))/HALFE
        IF(THMIN(I).GE.HALFPI) X1=PMIN(I)*COS(THMIN(I))/HALFE
        IF(THMAX(I).GT.HALFPI) X2=PMAX(I)*COS(THMAX(I))/HALFE
        IF(THMAX(I).LT.HALFPI) X2=PMIN(I)*COS(THMAX(I))/HALFE
        IF(X1.LT.XJMAX(I)) XJMAX(I)=X1
        IF(X2.GT.XJMIN(I)) XJMIN(I)=X2
      ELSE
C
        XJ(I)=XJMIN(I)
C
        IF(FIXP(I)) THEN
          CTH(I)=XJ(I)*HALFE/P(I)
          IF(ABS(CTH(I)).LE.1.0) THEN
            STH(I)=SQRT(1.-CTH(I)**2)
            TH(I)=ATAN2(STH(I),CTH(I))
            YJ(I)=-ALOG(TAN(TH(I)/2.))
            FIXYJ(I)=.TRUE.
            PT(I)=P(I)*STH(I)
            FIXPT(I)=.TRUE.
            YJMIN(I)=YJ(I)
            YJMAX(I)=YJ(I)
            PTMIN(I)=PT(I)
            PTMAX(I)=PT(I)
          ELSE
            LOGX=.FALSE.
            CALL LOGERR(5,I,IERR)
          ENDIF
        ENDIF
C
        IF(FIXPT(I)) THEN
          TH(I)=ATAN(PT(I)/XJ(I)/HALFE)
          FIXYJ(I)=.TRUE.
          YJ(I)=-ALOG(TAN(TH(I)/2.))
          CTH(I)=COS(TH(I))
          STH(I)=SIN(TH(I))
          P(I)=PT(I)/STH(I)
          FIXP(I)=.TRUE.
          YJMIN(I)=YJ(I)
          YJMAX(I)=YJ(I)
          PMAX(I)=P(I)
          PMIN(I)=P(I)
        ENDIF
C
        IF(FIXYJ(I)) THEN
          FIXPT(I)=.TRUE.
          P(I)=XJ(I)*HALFE/CTH(I)
          PT(I)=P(I)*STH(I)
          FIXP(I)=.TRUE.
          PTMIN(I)=PT(I)
          PTMAX(I)=PT(I)
          PMAX(I)=P(I)
          PMIN(I)=P(I)
        ENDIF
C
      ENDIF
C
   40 CONTINUE
C
      RETURN
      END
CDECK  ID>, LOGXW.  
      LOGICAL FUNCTION LOGXW(IERR)
C
C       SET AND CHECK X LIMITS FOR W(Z0)
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      DATA UNDEF/-.9E9/
C
      LOGXW=.TRUE.
      FIXXW=.FALSE.
C
      IF(XWMIN.LT.UNDEF.AND.XWMAX.LT.UNDEF) THEN
        XWMIN=-1.0
        XWMAX=1.0
      ELSEIF(XWMAX.GT.UNDEF) THEN
        FIXXW=.TRUE.
        XW=XWMIN
        XWMAX=XW
C            IF XW=0 THEN YW=0
        IF(XW.NE.0) THEN
          FIXYW=.TRUE.
          YW=0
          YWMIN=0
          YWMAX=0
        ENDIF
      ENDIF
C
C            IF YW=0 THAN XW=0
      IF(YW.EQ.0) THEN
        FIXXW=.TRUE.
        XW=0
        XWMAX=0
      ENDIF
C
      RETURN
      END
CDECK  ID>, LOGYTH. 
      LOGICAL FUNCTION LOGYTH(IERR)
C
C       SET AND CHECK LIMITS FOR JET Y AND THETA
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      DATA UNDEF/-.9E9/
C
C            INVERSE HYPERBOLIC COSINE FUNCTION
      ACOSH(X)=ALOG(X+SQRT(X**2-1.0))
C            INVERSE HYPERBOLIC SINE FUNCTION
      ASINH(X)=ALOG(X+SQRT(X**2+1.0))
C
      HALFPI=PI/2.
      LOGYTH=.TRUE.
C
      DO 30 I=1,NJET
      FIXYJ(I)=.FALSE.
C
      IF(FIXP(I).AND.FIXPT(I)) THEN
        STH(I)=PT(I)/P(I)
        CTHS(1,I)=SQRT(1.-STH(I)**2)
        CTHS(2,I)=-CTHS(1,I)
        THS(1,I)=ATAN2(STH(I),CTHS(1,I))
        THS(2,I)=ATAN2(STH(I),CTHS(2,I))
        YJS(1,I)=-ALOG(TAN(THS(1,I)/2.))
        YJS(2,I)=-ALOG(TAN(THS(2,I)/2.))
        XJS(1,I)=P(I)*CTHS(1,I)/HALFE
        XJS(2,I)=P(I)*CTHS(2,I)/HALFE
        YJMAX(I)=YJS(2,I)
        THMAX(I)=THS(1,I)
        THMIN(I)=THS(2,I)
        IF(YJMIN(I).EQ.YJMAX(I)) FIXYJ(I)=.TRUE.
      ENDIF
C
C
      IF(YJMIN(I).LT.UNDEF.AND.YJMAX(I).LT.UNDEF) THEN
C
        IF(THMIN(I).LT.UNDEF.AND.THMAX(I).LT.UNDEF) THEN
          YJMAX(I)=ACOSH(HALFE/PTMIN(I))
          YJMIN(I)=-YJMAX(I)
          THMIN(I)=2.*ATAN(EXP(-YJMAX(I)))
          THMAX(I)=2.*ATAN(EXP(-YJMIN(I)))
        ENDIF
C
        IF(THMAX(I).LT.UNDEF) FIXYJ(I)=.TRUE.
        IF(THMIN(I).LT.UNDEF) THMIN(I)=.001
        IF(FIXYJ(I)) THMAX(I)=THMIN(I)
        YJMIN(I)=-ALOG(TAN(THMAX(I)/2.))
        YJMAX(I)=-ALOG(TAN(THMIN(I)/2.))
        THMIN(I)=2.*ATAN(EXP(-YJMAX(I)))
        THMAX(I)=2.*ATAN(EXP(-YJMIN(I)))
      ENDIF
C
C
      IF(YJMAX(I).LT.UNDEF) FIXYJ(I)=.TRUE.
      IF(YJMIN(I).LT.UNDEF) YJMIN(I)=-YJMAX(I)
      IF(FIXYJ(I)) YJMAX(I)=YJMIN(I)
      THMIN(I)=2.*ATAN(EXP(-YJMAX(I)))
      THMAX(I)=2.*ATAN(EXP(-YJMIN(I)))
C
      IF(FIXYJ(I)) THEN
        YJ(I)=YJMIN(I)
        TH(I)=THMIN(I)
        STH(I)=SIN(TH(I))
        CTH(I)=COS(TH(I))
        IF(FIXPT(I)) P(I)=PT(I)/STH(I)
        IF(FIXP(I)) PT(I)=P(I)*STH(I)
C
        IF((FIXP(I).OR.FIXPT(I))) THEN
          XJ(I)=P(I)*CTH(I)/HALFE
          XJMIN(I)=XJ(I)
          XJMAX(I)=XJ(I)
        ENDIF
C
      ENDIF
C
C          CHECK PT LIMITS WITH P AND THETA LIMITS
      IF(.NOT.FIXPT(I)) THEN
        THETA1=AMIN1(THMIN(I),PI-THMAX(I))
        THETA2=HALFPI
        IF(THMAX(I).LT.HALFPI) THETA2=THMAX(I)
        IF(THMIN(I).GT.HALFPI) THETA2=THMIN(I)
        PT1=PMIN(I)*SIN(THETA1)
        PTMIN(I)=AMAX1(PTMIN(I),PT1)
        PT2=PMAX(I)*SIN(THETA2)
        PTMAX(I)=AMIN1(PTMAX(I),PT2)
      ENDIF
C
   30 CONTINUE
C
      RETURN
      END
CDECK  ID>, LOGYW.  
      LOGICAL FUNCTION LOGYW(IERR)
C
C       SET AND CHECK Y LIMITS FOR W(Z0)
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      LOGICAL COMB(2)
      DATA UNDEF/-.9E9/
C
C            INVERSE HYPERBOLIC COSINE FUNCTION
      ACOSH(X)=ALOG(X+SQRT(X**2-1.0))
C            INVERSE HYPERBOLIC SINE FUNCTION
      ASINH(X)=ALOG(X+SQRT(X**2+1.0))
      YW=1.0
      LOGYW=.TRUE.
      FIXYW=.FALSE.
C
      IF(YWMIN.LT.UNDEF.AND.YWMAX.LT.UNDEF) THEN
        YWMAX=ACOSH(HALFE/SQRT(QTMIN**2+QMIN**2))
        YWMIN=-YWMAX
      ENDIF
C
      IF(YWMAX.LT.UNDEF) THEN
        FIXYW=.TRUE.
        YW=YWMIN
        YWMAX=YWMIN
      ENDIF
C
      YWMX=ACOSH(HALFE/SQRT(QTMIN**2+QMIN**2))
      YWMN=-YWMX
      COMB(1)=YWMX.LT.YWMAX
      COMB(2)=YWMN.GT.YWMIN
C
      IF(FIXYW.AND.(COMB(1).OR.COMB(2))) THEN
        LOGYW=.FALSE.
        CALL LOGERR(102,1,IERR)
      ENDIF
C
      IF(.NOT.FIXYW) THEN
        IF(COMB(1)) YWMAX=YWMX
        IF(COMB(2)) YWMIN=YWMN
      ENDIF
C
      RETURN
      END
CDECK  ID>, LSTSQ.  
      SUBROUTINE LSTSQ(X,Y,NPT,A,B)
C
C          DO LEAST SQUARE FIT TO A STRAIGHT LINE Y=A+B*X
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      DIMENSION X(NPT),Y(NPT)
      SUM1=0
      SUM2=0
      SUM3=0
      SUM4=0
      DO 1 I=1,NPT
      SUM1=SUM1+X(I)
      SUM2=SUM2+Y(I)
      SUM3=SUM3+X(I)**2
      SUM4=SUM4+X(I)*Y(I)
    1 CONTINUE
      B=(SUM2*SUM1-SUM4*NPT)/(SUM1**2-SUM3*NPT)
      A=(SUM2-B*SUM1)/NPT
      RETURN
      END
CDECK  ID>, MBIAS.  
      SUBROUTINE MBIAS
C
C          Generate minbias event or beam jets for high-pt event using
C          parameters set in MBSET:
C
C          (1) Select number NPOM of cut pomerons -- cf cut Reggeon
C              field theory of Abramovskii, Kanchelli, and Gribov.
C          (2) Generate xf for leading baryons including 1/(1-xf)
C              diffractive term and guessed NPOM dependence,
C              F(XF)=(1-XF)**(A+B/NPOM)
C          (3) Select xf for each half of each Pomeron. then fragment
C              each half Pomeron into mesons and baryons independently
C              in the Pomeron-Pomeron center of mass. This avoids
C              making xf=0 a singular point.
C
C          Note that multiple cut Pomerons give approximate KNO scaling.
C          The only short-range correlations are from resonances.
C
C          Ver. 7.09: Add traps on free loops and IMPLICIT NONE.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      INTEGER   LIMPOM
      PARAMETER (LIMPOM=20)
      COMMON/MBGEN/POMWT(LIMPOM),POMGEN(LIMPOM),MNPOM,MXPOM,PDIFFR,
     $NPOM,XBARY(2),DXBARY(2),XPOM(LIMPOM,2)
      SAVE /MBGEN/
      INTEGER   MNPOM,MXPOM,NPOM
      REAL      POMWT,POMGEN,PDIFFR,XBARY,DXBARY,XPOM
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      COMMON/MBPAR/PUD0,PJSPN,PISPN,SIGQT0,XGEN0(2),PMIX01(3,2)
     1,PMIX02(3,2),PBARY0
      SAVE /MBPAR/
      REAL      PUD0,PJSPN,PISPN,SIGQT0,XGEN0,PMIX01,PMIX02,PBARY0
C
      DIMENSION IFL(3),IFLEXC(2),PXEXC(2),PYEXC(2),SIGN(2)
      DIMENSION PSUM(5)
      DIMENSION LDIFFR(2)
      LOGICAL LDIFFR
      REAL RANF,AMASS
      REAL RND,XX,XSUM,P0,PPOM,PXEXC,PSUM,SIGN,PYEXC,GAM,BETA,X,
     $AM,PPLUS,EPSDIF,PEND0,TRY,PX,PY,PX2,PY2,QMINUS,PZ,QPLUS,PT1,
     $PHI1,XBGEN,PT2,PHI2,PX1,PY1,AMT2
      INTEGER ID1,ID2,IFL1,IFL2,IMOD1,IMOD2,ITWIST,IPOM,LOOP,NFIRST,
     $ID3,IFLEXC,IFL,I,NP2,IP,NP1,IFAIL,NPTLV1,IDHAD,IB,NEW,JSPIN,
     $INDEX,NBEGIN,IPASS,MXPASS,N,IDIFF,IPASSB,IFLNEW,ISWAP
      DATA SIGN/1.,-1./,PEND0/.14/
      DATA PSUM/5*0./
      DATA MXPASS/200/
C
C          Start
      NBEGIN=NPTCL+1
      IPASS=1
      IPASSB=1
C
C          Select number of cut Pomerons.
C
1     CONTINUE
      TRY=RANF()
      DO 10 N=MNPOM,MXPOM
        NPOM=N
        IF(POMGEN(N).GT.TRY) GO TO 20
10    CONTINUE
20    CONTINUE
C
C          Decide if diffractive event
      IF(RANF().LT.PDIFFR) THEN
        IDIFF=INT(1.99999*RANF())+1
        LDIFFR(IDIFF)=.TRUE.
        LDIFFR(3-IDIFF)=.FALSE.
      ELSE
        LDIFFR(1)=.FALSE.
        LDIFFR(2)=.FALSE.
      ENDIF
C
C          Generate leading baryons.
C
      DO 100 IB=1,2
        PPLUS=2.*PBEAM(IB)
C
C          Special treatment for diffractive beam.
        IF(LDIFFR(IB)) THEN
          IDHAD=IDIN(IB)
          AM=AMASS(IDHAD)
          CALL FLAVOR(IDIN(IB),IFL(1),IFL(2),IFL(3),JSPIN,INDEX)
          NEW=INT(3.*RANF())+1
          IFLEXC(1)=+IFL(NEW)
          IFLEXC(2)=-IFL(NEW)
          EPSDIF=2./SCM
          DXBARY(IB)=EPSDIF**RANF()
          XBARY(IB)=1.-DXBARY(IB)
          GO TO 115
        ENDIF
C
C          If not diffractive, construct IDENT of leading baryon
        CALL FLAVOR(IDIN(IB),IFL(1),IFL(2),IFL(3),JSPIN,INDEX)
        NEW=INT(3.*RANF())+1
        IFLNEW=ISIGN(INT(RANF()/PUD0)+1,IDIN(IB))
        IFLEXC(1)=IFL(NEW)
        IFLEXC(2)=-IFLNEW
        IFL(NEW)=IFLNEW
        IF(IABS(IFL(1)).GT.IABS(IFL(2))) THEN
          ISWAP=IFL(1)
          IFL(1)=IFL(2)
          IFL(2)=ISWAP
        ENDIF
        IF(IABS(IFL(2)).GT.IABS(IFL(3))) THEN
          ISWAP=IFL(2)
          IFL(2)=IFL(3)
          IFL(3)=ISWAP
        ENDIF
        IF(IABS(IFL(1)).GT.IABS(IFL(2))) THEN
          ISWAP=IFL(1)
          IFL(1)=IFL(2)
          IFL(2)=ISWAP
        ENDIF
        JSPIN=1
        IF(IFL(1).EQ.IFL(2).AND.IFL(2).EQ.IFL(3)) THEN
          JSPIN=1
        ELSE
          JSPIN=INT(RANF()+PJSPN)
        ENDIF
        IF(JSPIN.EQ.0.AND.IFL(1).NE.IFL(2).AND.IFL(2).NE.IFL(3)) THEN
          IF(RANF().GT.PISPN) THEN
            ISWAP=IFL(1)
            IFL(1)=IFL(2)
            IFL(2)=ISWAP
          ENDIF
        ENDIF
        IDHAD=1000*IABS(IFL(1))+100*IABS(IFL(2))+10*IABS(IFL(3))+JSPIN
        IDHAD=ISIGN(IDHAD,IDIN(IB))
        AM=AMASS(IDHAD)
C
C          Select xf for nondiffractive baryon, flat for NPOM=1 and
C          like mesons for NPOM=infinity.
110     XBGEN=XGEN0(2)*(1.-1./NPOM)
        DXBARY(IB)=RANF()**(1./(XBGEN+1.))
        XBARY(IB)=1.-DXBARY(IB)
C
C          Select transverse momentum of baryon
115     CALL GETPT(PT1,SIGQT0)
        PHI1=2.*PI*RANF()
        PX1=PT1*COS(PHI1)
        PY1=PT1*SIN(PHI1)
        PXEXC(1)=PX1
        PYEXC(1)=PY1
        CALL GETPT(PT2,SIGQT0)
        PHI2=2.*PI*RANF()
        PX2=PT2*COS(PHI2)
        PY2=PT2*SIN(PHI2)
        PXEXC(2)=PX2
        PYEXC(2)=PY2
        PX=-PX1-PX2
        PY=-PY1-PY2
        AMT2=PX**2+PY**2+AM**2
C
        QPLUS=XBARY(IB)*PPLUS
        QPLUS=AMAX1(QPLUS,1.E-6)
        QMINUS=AMT2/QPLUS
        PZ=.5*(QPLUS-QMINUS)
        P0=.5*(QPLUS+QMINUS)
C
C          Add baryon to /PARTCL/ if PZ>0.
        IF(NPTCL.GE.MXPTCL) GO TO 9999
        IF(PZ.GE.0.) THEN
          NPTCL=NPTCL+1
          PPTCL(1,NPTCL)=PX
          PPTCL(2,NPTCL)=PY
          PPTCL(3,NPTCL)=PZ*SIGN(IB)
          PPTCL(4,NPTCL)=P0
          PPTCL(5,NPTCL)=AM
          IORIG(NPTCL)=0
          IDCAY(NPTCL)=0
          IDENT(NPTCL)=IDHAD
        ELSE
          IPASSB=IPASSB+1
          IF(IPASSB.LT.MXPASS) GO TO 110
C          Just give up if it fails MXPASS times
          WRITE(ITLIS,998)
998       FORMAT(//5X,'ERROR IN MBIAS ... COULD NOT MAKE BARYON')
          XBARY(IB)=0.
          DXBARY(IB)=1.
        ENDIF
C
C          Having accepted baryon, set up XPOM array for cut Pomerons,
C          rescaling to 1.-XBARY(IB).
        XSUM=0.
        DO 120 N=1,NPOM
          XX=RANF()
          XPOM(N,IB)=XX
          XSUM=XSUM+XX
120     CONTINUE
        XSUM=1./XSUM
        DO 130 N=1,NPOM
          XPOM(N,IB)=XSUM*XPOM(N,IB)*DXBARY(IB)
130     CONTINUE
100   CONTINUE
C
C          Fragment each Pomeron into mesons and baryon pairs in the
C          Pomeron-Pomeron center of mass.
C
      DO 1000 IB=1,2
        DO 2000 IPOM=1,NPOM
          PPOM=SQRT(PBEAM(1)*XPOM(IPOM,1)*PBEAM(2)*XPOM(IPOM,2))
          PPLUS=2.*PPOM
          NFIRST=NPTCL+1
          LOOP=0
C
200       CONTINUE
          ITWIST=INT(1.99999*RANF())+1
          LOOP=LOOP+1
C
C          Select new quark or diquark. Old diquark implies new quark.
C          Old quark implies new diquark with probability PBARY0.
          IFL1=IFLEXC(ITWIST)
          IF(MOD(IFL1,100).EQ.0) THEN
            IFL2=ISIGN(INT(RANF()/PUD0)+1,+IFL1)
          ELSEIF(RANF().GT.PBARY0) THEN
            IFL2=ISIGN(INT(RANF()/PUD0)+1,-IFL1)
          ELSE
            ID1=INT(RANF()/PUD0)+1
            ID2=INT(RANF()/PUD0)+1
            IF(IABS(ID1).GT.IABS(ID2)) THEN
              ISWAP=ID1
              ID1=ID2
              ID2=ISWAP
            ENDIF
            IFL2=ISIGN(1000*ID1+100*ID2,IFL1)
          ENDIF
          IFLEXC(ITWIST)=-IFL2
C          Construct meson from quark+antiquark. Else, construct baryon
C          IDENT from quark+diquark.
          IMOD1=MOD(IFL1,100)
          IMOD2=MOD(IFL2,100)
          IF(IMOD1.NE.0.AND.IMOD2.NE.0) THEN
            JSPIN=INT(RANF()+PJSPN)
            ID1=IFL1
            ID2=IFL2
            IF(ID1+ID2.EQ.0) THEN
              RND=RANF()
              ID1=IABS(ID1)
              ID1=INT(PMIX01(ID1,JSPIN+1)+RND)
     $        +INT(PMIX02(ID1,JSPIN+1)+RND)+1
              ID2=-ID1
            ELSEIF(IABS(ID1).GT.IABS(ID2)) THEN
              ISWAP=ID1
              ID1=ID2
              ID2=ISWAP
            ENDIF
            IDHAD=ISIGN(100*IABS(ID1)+10*IABS(ID2)+JSPIN,ID1)
          ELSE
            IF(IMOD1.EQ.0) THEN
              ID3=MOD(IFL1/100,10)
              ID2=IFL1/1000
              ID1=IFL2
            ELSE
              ID3=MOD(IFL2/100,10)
              ID2=IFL2/1000
              ID1=IFL1
            ENDIF
            IF(IABS(ID1).GT.IABS(ID2)) THEN
              ISWAP=ID1
              ID1=ID2
              ID2=ISWAP
            ENDIF
            IF(IABS(ID2).GT.IABS(ID3)) THEN
              ISWAP=ID2
              ID2=ID3
              ID3=ISWAP
            ENDIF
            IF(IABS(ID1).GT.IABS(ID2)) THEN
              ISWAP=ID1
              ID1=ID2
              ID2=ISWAP
            ENDIF
            IF(ID1.EQ.ID2.AND.ID2.EQ.ID3) THEN
              JSPIN=1
            ELSE
              JSPIN=INT(RANF()+PJSPN)
            ENDIF
            IF(JSPIN.EQ.0.AND.ID1.NE.ID2.AND.ID2.NE.ID3) THEN
              IF(RANF().LT.PISPN) THEN
                ISWAP=ID1
                ID1=ID2
                ID2=ISWAP
              ENDIF
            ENDIF
            IDHAD=1000*IABS(ID1)+100*IABS(ID2)+10*IABS(ID3)+JSPIN
            IDHAD=ISIGN(IDHAD,IFL1)
          ENDIF
C
          AM=AMASS(IDHAD)
          PX1=PXEXC(ITWIST)
          PY1=PYEXC(ITWIST)
          CALL GETPT(PT2,SIGQT0)
          PHI2=2.*PI*RANF()
          PX2=PT2*COS(PHI2)
          PY2=PT2*SIN(PHI2)
          PXEXC(ITWIST)=PX2
          PYEXC(ITWIST)=PY2
          PX=PX1-PX2
          PY=PY1-PY2
          AMT2=PX**2+PY**2+AM**2
C
C          Select x -- same distribution for all particles.
          X=RANF()
          IF(RANF().LT.XGEN0(1)) X=1.-X**(1./(XGEN0(2)+1.))
          QPLUS=X*PPLUS
          QPLUS=AMAX1(QPLUS,1.E-6)
          QMINUS=AMT2/QPLUS
          P0=.5*(QPLUS+QMINUS)
          PZ=.5*(QPLUS-QMINUS)
C
C          Add particle to /PARTCL/ if PZ>0.
          IF(NPTCL.GE.MXPTCL) GO TO 9999
          IF(PZ.GE.0.) THEN
            NPTCL=NPTCL+1
            PPTCL(1,NPTCL)=PX
            PPTCL(2,NPTCL)=PY
            PPTCL(3,NPTCL)=PZ*SIGN(IB)
            PPTCL(4,NPTCL)=P0
            PPTCL(5,NPTCL)=AM
            IORIG(NPTCL)=0
            IDCAY(NPTCL)=0
            IDENT(NPTCL)=IDHAD
          ENDIF
C
C          Continue if sufficient pplus
          PPLUS=(1.-X)*PPLUS
          IF(PPLUS.GT.PEND0.AND.LOOP.LT.MXPTCL) GO TO 200
C
C          Boost hadrons to lab frame.
          IF(NPTCL.LT.NFIRST) GO TO 2000
          BETA=(XPOM(IPOM,1)*PBEAM(1)-XPOM(IPOM,2)*PBEAM(2))/(2.*PPOM)
          GAM=(XPOM(IPOM,1)*PBEAM(1)+XPOM(IPOM,2)*PBEAM(2))/(2.*PPOM)
          DO 400 IP=NFIRST,NPTCL
            P0=GAM*PPTCL(4,IP)+BETA*PPTCL(3,IP)
            PZ=BETA*PPTCL(4,IP)+GAM*PPTCL(3,IP)
            PPTCL(3,IP)=PZ
            PPTCL(4,IP)=P0
400       CONTINUE
C
2000    CONTINUE
1000  CONTINUE
C
C          Rescale hadron momenta for correct four-momentum.
C
      NPTLV1=NPTCL
      IF(KEYS(4)) THEN
        PSUM(4)=ECM
        PSUM(5)=ECM
        CALL RESCAL(NBEGIN,NPTLV1,PSUM,IFAIL)
      ELSE
        CALL RESCAL(NBEGIN,NPTLV1,PBEAMS,IFAIL)
      ENDIF
      IF(IFAIL.NE.0.AND.IPASS.LT.MXPASS) THEN
        IPASS=IPASS+1
        NPTCL=NBEGIN-1
        GO TO 1
      ENDIF
C
C          Decay hadrons
C
      NP1=NBEGIN
500   NP2=NPTCL
      DO 510 I=NP1,NP2
      CALL DECAY(I)
510   CONTINUE
      NP1=NP2+1
      IF(NP1.LE.NPTCL) GO TO 500
      RETURN
C
9999  CALL PRTEVT(0)
      WRITE(ITLIS,999) NPTCL
999   FORMAT(//5X,'ERROR IN MBIAS...NPTCL >',I5)
      RETURN
      END
CDECK  ID>, MBSET.  
      SUBROUTINE MBSET
C
C          SET PARAMETERS FOR GENERATING MINBIAS EVENTS OR BEAM JETS,
C          ALLOWING DIFFERENT PARAMETERS FOR TWO CASES.
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/MBPAR/PUD0,PJSPN,PISPN,SIGQT0,XGEN0(2),PMIX01(3,2)
     1,PMIX02(3,2),PBARY0
      SAVE /MBPAR/
      REAL      PUD0,PJSPN,PISPN,SIGQT0,XGEN0,PMIX01,PMIX02,PBARY0
      INTEGER   LIMPOM
      PARAMETER (LIMPOM=20)
      COMMON/MBGEN/POMWT(LIMPOM),POMGEN(LIMPOM),MNPOM,MXPOM,PDIFFR,
     $NPOM,XBARY(2),DXBARY(2),XPOM(LIMPOM,2)
      SAVE /MBGEN/
      INTEGER   MNPOM,MXPOM,NPOM
      REAL      POMWT,POMGEN,PDIFFR,XBARY,DXBARY,XPOM
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/TOTALS/NKINPT,NWGEN,NKEEP,SUMWT,WT
      SAVE /TOTALS/
      INTEGER   NKINPT,NWGEN,NKEEP
      REAL      SUMWT,WT
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
C
C
C          DN/DY INCREASES WITH LOG(S). INCLUDED IN SPLITTING FUNCTION
C          BECAUSE AVERAGE MULTIPLICITY COMES FROM SINGLE CHAIN GRAPH.
      XGEN0(1)=.9
      XGEN0(2)=1.+0.35*ALOG(ECM/60.)
C
C          POMWT ARE (RELATIVE) PROBABILITIES FOR N CUT POMERONS.
C          PDIFFR IS DIFFRACTIVE PROBABILITY.
C          SIGQT0 IS MEAN PT.
      IF(KEYS(4)) THEN
        PDIFFR=.15
        SIGQT0=.35
        PSUM=0.
        DO 100 I=1,LIMPOM
        POMWT(I)=(1.+4.*I**2)*EXP(-1.8*I)
        PSUM=PSUM+POMWT(I)
100     CONTINUE
      ELSE
        PDIFFR=0.
        SIGQT0=.45
        PSUM=0.
        DO 110 I=1,LIMPOM
        POMWT(I)=(1.+4.*I**2)*EXP(-1.8*I)
        PSUM=PSUM+POMWT(I)
110     CONTINUE
        POMWT(1)=.1*POMWT(1)
        POMWT(2)=.2*POMWT(2)
        POMWT(3)=.5*POMWT(3)
      ENDIF
C
C          RENORMALIZE POMWT.
      PSUM=1./PSUM
      DO 200 I=1,LIMPOM
      POMWT(I)=PSUM*POMWT(I)
200   CONTINUE
      PSUM=0.
      DO 210 I=MNPOM,MXPOM
      PSUM=PSUM+POMWT(I)
210   CONTINUE
C
C          POMGEN IS USED TO SELECT NUMBER OF POMERONS.
      PGEN=0.
      PSUM=1./PSUM
      DO 300 I=1,LIMPOM
      POMGEN(I)=0.
300   CONTINUE
      DO 310 I=MNPOM,MXPOM
      PGEN=PGEN+PSUM*POMWT(I)
      POMGEN(I)=PGEN
310   CONTINUE
      POMGEN(MXPOM)=1.
C
C          SET /TOTALS/ FOR MINBIAS EVENTS USING LOG**2(S) FIT TO
C          TOTAL CROSS SECTION.
      IF(KEYS(4)) THEN
        SIGTOT=25.65*(1.+.0102*ALOG(SCM/1.76)**2)
        SIGTOT=PSUM*SIGTOT
        NKINPT=NEVENT
        SUMWT=SIGTOT*NKINPT
      ENDIF
C
      RETURN
      END
CDECK  ID>, NOGOOD. 
      LOGICAL FUNCTION NOGOOD(KK)
C
C          Insure proper distribution and check kinematics.
C          Select jet types.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/WSIG/SIGLLQ
      SAVE /WSIG/
      REAL      SIGLLQ
      COMMON/WGEN/PTGN(3,3),QGEN(3,3),PTSEL(3),QSEL(3),SIGSL(3),NKL,NKH
     1,EMSQ,EMGAM,KSEL,QSELWT(3)
      SAVE /WGEN/
      INTEGER   NKL,NKH,KSEL
      REAL      PTGN,QGEN,PTSEL,QSEL,SIGSL,EMSQ,EMGAM,QSELWT
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/PTPAR/PTFUN1,PTFUN2,PTGEN1,PTGEN2,PTGEN3,SIGMAX
      SAVE /PTPAR/
      REAL      PTFUN1,PTFUN2,PTGEN1,PTGEN2,PTGEN3,SIGMAX
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C
      REAL RANF,SIGINV,SUM,TRY,BRANCH
      INTEGER KK,I,II,K,IFL
C
      NOGOOD=.TRUE.
      GO TO (1,2,3,4,5,6),KK
C
C          TWOJET, SUPERSYM, WPAIR or PHOTON events
C
1     CONTINUE
      IF(KEYS(1)) THEN
        CALL SIGQCD
      ELSEIF(KEYS(5)) THEN
        CALL SIGSSY
      ELSEIF(KEYS(6)) THEN
        CALL SIGWW
      ELSEIF(KEYS(8)) THEN
        CALL SIGGAM
      ENDIF
      IF(SIGMA.LE.0) RETURN
      IF(SIGMAX*RANF().GT.SIGMA) RETURN
      NOGOOD=.FALSE.
      SIGINV=1./SIGMA
      SUM=0.
      TRY=RANF()
      DO 100 I=1,NSIGS
        SUM=SUM+SIGS(I)*SIGINV
        IF(SUM.LT.TRY) GO TO 100
C          Find reaction
        ISIGS=I
        SIGEVT=SIGS(ISIGS)
        II=INOUT(I)
        DO 110 K=1,2
        INITYP(K)=MOD(II,IOPAK)
110     II=II/IOPAK
        DO 120 K=1,2
        JETTYP(K)=MOD(II,IOPAK)
120     II=II/IOPAK
        RETURN
100   CONTINUE
      RETURN
C
C          DRELLYAN events--test of SIGDY
C
2     CONTINUE
      IF(KEYS(3)) THEN
        CALL SIGDY
      ELSEIF(KEYS(7).AND..NOT.GOMSSM) THEN
        CALL SIGH
      ELSEIF(KEYS(7).AND.GOMSSM) THEN
        CALL SIGHSS
      ELSEIF(KEYS(9)) THEN
        CALL SIGTC
      ENDIF
      IF(SIGMA.LE.0.) RETURN
      IF(SIGSL(KSEL)*RANF().GT.SIGMA) RETURN
      NOGOOD=.FALSE.
      SIGINV=1./SIGMA
      SUM=0.
      TRY=RANF()
C          Find reaction.
      DO 200 I=1,NSIGS
        SUM=SUM+SIGS(I)*SIGINV
        IF(SUM.LT.TRY) GO TO 200
        ISIGS=I
        SIGEVT=SIGS(ISIGS)
        GO TO 210
200   CONTINUE
C          Unpack INOUT to find JETTYP and INITYP
210   IF(KEYS(3)) THEN
        II=INOUT(I)
        DO 220 K=1,2
        INITYP(K)=MOD(II,IOPAK)
220     II=II/IOPAK
        JWTYP=MOD(II,IOPAK)
        II=II/IOPAK
        JETTYP(3)=MOD(II,IOPAK)
      ELSEIF(KEYS(7).OR.KEYS(9)) THEN
        II=INOUT(ISIGS)
        DO 230 I=1,2
        INITYP(I)=MOD(II,IOPAK)
230     II=II/IOPAK
        DO 240 I=1,2
        JETTYP(I)=MOD(II,IOPAK)
240     II=II/IOPAK
      ENDIF
      RETURN
C
C          DRELLYAN events--test of SIGDY2
C
3     CONTINUE
      IF(KEYS(3)) THEN
        CALL SIGDY2
        IFL=JETTYP(1)/2
        BRANCH=(AQ(IFL,JWTYP)**2+BQ(IFL,JWTYP)**2)/COUT(JWTYP)
      ELSEIF(KEYS(7).AND..NOT.GOMSSM) THEN
        CALL SIGH2
        BRANCH=1.
      ELSEIF(KEYS(7).AND.GOMSSM) THEN
        SIGLLQ=SIGMA/(4*PI)
        NOGOOD=.FALSE.
        RETURN
      ELSEIF(KEYS(9)) THEN
        CALL SIGTC2
        BRANCH=1.
      ENDIF
      IF(SIGLLQ.GT.SIGS(ISIGS)*BRANCH*3.*RANF()/(4.*PI))
     1NOGOOD=.FALSE.
      RETURN
C
C          DRELLYAN events--test of kinematics
C
4     CONTINUE
      DO 400 I=1,2
        IF(P(I).LT.PMIN(I).OR.P(I).GT.PMAX(I)) GO TO 410
        IF(PT(I).LT.PTMIN(I).OR.PT(I).GT.PTMAX(I)) GO TO 410
        IF(YJ(I).LT.YJMIN(I).OR.YJ(I).GT.YJMAX(I)) GO TO 410
        IF(PHI(I).LT.PHIMIN(I).OR.PHI(I).GT.PHIMAX(I)) GO TO 410
400   CONTINUE
      NOGOOD=.FALSE.
410   RETURN
C
5     CONTINUE
6     CONTINUE
      RETURN
C
      END
CDECK  ID>, ORDECR. 
      SUBROUTINE ORDECR(IA,IB,N)
C----------------------------------------------------------------------
C-
C-   Purpose and Methods :
C-        return an ordered array (by size of absolute values)
C-        Warning: input array is destroyed
C-
C-   Inputs  :
C-   IA(N) = input array
C-   Outputs :
C-   IB(N) = output ordered array
C-
C-   Created   9-MAY-1988   Serban D. Protopopescu
C-
C----------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER IA(*),IB(*),N,I,J,JSEL
C----------------------------------------------------------------------
      DO 2 I=1,N
        JSEL=0
        IB(I)=0
        DO 1 J=1,N
          IF(IABS(IA(J)).GT.IABS(IB(I))) THEN
            IB(I)=IA(J)
            JSEL=J
          ENDIF
    1   CONTINUE
        IF(JSEL.GT.0) IA(JSEL)=0
    2 CONTINUE
  999 RETURN
      END
CDECK  ID>, ORDER.  
      SUBROUTINE ORDER(ID,MODEIN,MODOUT)
C
C          Search for mode MODEIN of particle ID in standard /DKYTAB/.
C          If found, return MODOUT = standard order.
C          Otherwise return MODOUT = MODEIN.
C          If ID<0, use antiparticles instead.
C
      IMPLICIT NONE
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
C          LOOK MUST BE DIMENSIONED TO THE MAXIMUM VALUE OF INDEX.
      INTEGER   MXLOOK
      PARAMETER (MXLOOK=500)
      INTEGER   MXDKY
      PARAMETER (MXDKY=3000)
      COMMON/DKYTAB/LOOK(MXLOOK),CBR(MXDKY),MODE(5,MXDKY)
      SAVE /DKYTAB/
      INTEGER   LOOK,MODE
      REAL      CBR
      INTEGER   MXFORC
      PARAMETER (MXFORC=40)
      COMMON/FORCE/NFORCE,IFORCE(MXFORC),MFORCE(5,MXFORC)
     $,LOOK2(2,MXFORC),LOOKST(MXFORC)
      SAVE /FORCE/
      INTEGER   NFORCE,IFORCE,MFORCE,LOOK2,LOOKST
C
      INTEGER ID,MODEIN(5),MODOUT(5),MODTST(5)
      INTEGER IFL1,IFL2,IFL3,JSPIN,INDEX,LOOK0,IUSE(5),ISAME,I,J,
     $NADD,NADDI,K,K1,K2,IDANTI
C
C          Find standard starting point
C
      CALL FLAVOR(ID,IFL1,IFL2,IFL3,JSPIN,INDEX)
      IF(LOOK(INDEX).GT.0) THEN
        LOOK0=LOOK(INDEX)
      ELSEIF(LOOK(INDEX).LT.0) THEN
        LOOK0=LOOKST(-LOOK(INDEX))
      ELSE
        ISAME=0
        GO TO 300
      ENDIF
C
C          Find NADD
C
      DO 100 I=1,5
100   IF(MODEIN(I).NE.0) NADD=I
C
C          If ID<0, compare antiparticles
C
      IF(ID.GE.0) THEN
        DO 110 K=1,NADD
110     MODTST(K)=MODEIN(K)
      ELSE
        DO 120 K=1,NADD
120     MODTST(K)=IDANTI(MODEIN(K))
      ENDIF
C
C          Scan all modes starting at LOOK0. Check for correct NADD.
C          Then check that particles match in arbitrary order.
C
      DO 200 I=LOOK0,MXDKY
        DO 210 K=1,5
210     IF(MODE(K,I).NE.0) NADDI=K
        IF(NADDI.EQ.NADD) THEN
          DO 220 K=1,5
220       IUSE(K)=0
C
          DO 230 K1=1,NADD
            DO 240 K2=1,NADD
              IF(MODTST(K1).EQ.MODE(K2,I).AND.IUSE(K2).EQ.0) THEN
                IUSE(K2)=K1
                GO TO 230
              ENDIF
240         CONTINUE
            GO TO 201
230       CONTINUE
C
          ISAME=I
          GO TO 300
        ENDIF
201     IF(CBR(I).GE.1.) THEN
          ISAME=0
          GO TO 300
        ENDIF
200   CONTINUE
      STOP 99
C
C          Return matching mode or original mode.
C
300   IF(ISAME.EQ.0) THEN
        WRITE(ITLIS,3001)
3001    FORMAT(' ***** WARNING: NONSTANDARD MODE')
        DO 310 K=1,5
310     MODOUT(K)=MODEIN(K)
      ELSEIF(ID.GT.0) THEN
        DO 320 K=1,5
320     MODOUT(K)=MODE(K,ISAME)
      ELSE
        DO 330 K=1,5
330     MODOUT(K)=IDANTI(MODE(K,ISAME))
      ENDIF
C
      RETURN
      END
CDECK  ID>, PRTEVT. 
      SUBROUTINE PRTEVT(IPRT)
C
C          PRINT THE EVENT STORED IN /PJETS/, /JETSET/, AND /PARTCL/
C          IF IPRT IS SELECTED BY NEVPRT AND NJUMP.
C          IPRT=0 ALWAYS PRINTS EVENT
C          IPRT<0 PRINTS ONLY JET PARAMETERS
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   LIMPOM
      PARAMETER (LIMPOM=20)
      COMMON/MBGEN/POMWT(LIMPOM),POMGEN(LIMPOM),MNPOM,MXPOM,PDIFFR,
     $NPOM,XBARY(2),DXBARY(2),XPOM(LIMPOM,2)
      SAVE /MBGEN/
      INTEGER   MNPOM,MXPOM,NPOM
      REAL      POMWT,POMGEN,PDIFFR,XBARY,DXBARY,XPOM
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PINITS/PINITS(5,2),IDINIT(2)
      SAVE /PINITS/
      INTEGER   IDINIT
      REAL      PINITS
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/LSTPRT/LSTPRT
      SAVE /LSTPRT/
      INTEGER   LSTPRT
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/PRTOUT/NEVPRT,NJUMP
      SAVE /PRTOUT/
      INTEGER   NEVPRT,NJUMP
      COMMON/WSIG/SIGLLQ
      SAVE /WSIG/
      REAL      SIGLLQ
      COMMON/SEED/XSEED
      SAVE /SEED/
      CHARACTER*24 XSEED
C
C          LABELS ARE CHARACTER*8
      CHARACTER*8 LABEL,LW,LJET,LPTCL
C
C          DECIDE WHETHER TO PRINT
      IF(IPRT.GT.NJUMP*NEVPRT) THEN
        IF(NJUMP.GT.0) THEN
          IF(MOD(IPRT,NJUMP).EQ.0) WRITE(ITLIS,5) IDG,IEVT,XSEED
5         FORMAT(/6X,'RUN ID',2I10,5X,'EVENT NO',I8,5X,'SEED',2X,A24)
        ENDIF
        RETURN
      ENDIF
      IF(IPRT.GT.1.AND.MOD(IPRT,NJUMP).NE.0) RETURN
      IF(IEVT.EQ.LSTPRT) RETURN
      PI=4.*ATAN(1.)
      LSTPRT=IEVT
C          PRINT EVENT NUMBER
      WRITE(ITLIS,10) IDG,IEVT,XSEED
10    FORMAT('1',5X,'RUN ID',2I10,5X,'EVENT NO',I8,5X,'SEED',2X,A24)
C
C          PRINT JET PARAMETERS
      IF(NJET.EQ.0) GO TO 300
      WRITE(ITLIS,20)
20    FORMAT(//20X,'JET PARAMETERS'//3X,'JET',4X,'TYPE ',
     18X,'PX',8X,'PY',8X,'PZ',8X,'P0',8X,'PT',
     25X,'THETA',7X,'PHI',9X,'X',9X,'Y')
      IF(KEYS(3).OR.KEYS(7)) THEN
        LW=LABEL(IDENTW)
        WRITE(ITLIS,31) LW,(QWJET(K),K=1,4),QTW,THW,PHIW,XW,YW
31      FORMAT(5X,'-',4X,A5,5F10.2,4F10.4)
      ENDIF
      DO 100 I=1,NJET
      LJET=LABEL(IDJETS(I))
      WRITE(ITLIS,30) I,LJET,(PJETS(K,I),K=1,4),PT(I),TH(I),PHI(I),
     $XJ(I),YJ(I)
30    FORMAT(1X,I5,4X,A5,5F10.2,4F10.4)
100   CONTINUE
C          PRINT WPAIR DECAY PARAMETERS
      IF(KEYS(6).OR.KEYS(7)) THEN
        IF(NPAIR.NE.0) THEN
          WRITE(ITLIS,101)
101       FORMAT(//20X,'WPAIR DECAY PARAMETERS'//3X,'JET',4X,'TYPE ',
     $    8X,'PX',8X,'PY',8X,'PZ',8X,'P0',8X,'PT',
     $    5X,'THETA',7X,'PHI',9X,'X',9X,'Y')
          DO 102 I=1,NPAIR
          JET=JPAIR(I)
          LJET=LABEL(IDPAIR(I))
          PTPRT=SQRT(PPAIR(1,I)**2+PPAIR(2,I)**2)
          THPRT=ACOS(PPAIR(3,I)/SQRT(PTPRT**2+PPAIR(3,I)**2))
          PHIPRT=ATAN2(PPAIR(2,I),PPAIR(1,I))
          XPRT=2*PPAIR(3,I)/ECM
          YPRT=-ALOG(TAN(THPRT/2.))
          WRITE(ITLIS,30) JET,LJET,(PPAIR(K,I),K=1,4),
     $    PTPRT,THPRT,PHIPRT,XPRT,YPRT
102       CONTINUE
        ENDIF
      ENDIF
      IF(IPRT.LT.0) RETURN
C
C          PRINT JET CROSS SECTIONS
201   CONTINUE
      IF(KEYS(1).OR.KEYS(5).OR.KEYS(6)) THEN
        WRITE(ITLIS,39) SIGEVT
39      FORMAT(//5X,'D(SIGMA)/D(PT**2)D(Y1)D(Y2) = ',E12.4)
      ENDIF
      IF(KEYS(3).OR.KEYS(7)) THEN
        IF(NJET.EQ.3) THEN
          WRITE(ITLIS,38) LW,QMW,SIGEVT,SIGLLQ
38      FORMAT(//5X,'MASS OF ',A8,' = ',F10.3//
     C    5X,'D(SIGMA)/D(Q**2)D(QT**2)D(YW)D(YJ) = ',E12.4/
     C    5X,'D(SIGMA)/D(Q**2)D(QT**2)D(YW)D(YJ)D(OMEGA) = ',E12.4)
        ELSE
          WRITE(ITLIS,37) LW,QMW,SIGEVT,SIGLLQ
37      FORMAT(//5X,'MASS OF ',A8,' = ',F10.3//
     1    5X,'D(SIGMA)/D(Q**2)D(YW) =',E12.4/
     2    5X,'D(SIGMA)/D(Q**2)D(YW)D(OMEGA) =',E12.4)
        ENDIF
      ENDIF
      IF(KEYS(2)) THEN
        WRITE(ITLIS,32) SIGEVT
32      FORMAT(//5X,'D(SIGMA)/D(COS THETA) = ',E12.4)
      ENDIF
C
C          PRINT /JETSET/ PARAMETERS
      IF(KEYS(4)) GO TO 300
      IF(NJSET.EQ.0) GO TO 300
      WRITE(ITLIS,70)
70    FORMAT(//20X,'PARTON CASCADE PARAMETERS'//
     C  6X,'I',3X,'JET',4X,'ORIG',4X,'TYPE',9X,'DECAY',
     C  8X,'PX',8X,'PY',8X,'PZ',8X,'P0',6X,'MASS')
      DO 310 I=1,NJSET
      JET=JORIG(I)/JPACK
      I1=MOD(JORIG(I),JPACK)
      JTLV1=JTYPE(I)
      LJET=LABEL(JTLV1)
      J1=JDCAY(I)/JPACK
      J2=MOD(JDCAY(I),JPACK)
      IF(JDCAY(I).EQ.0) THEN
        WRITE(ITLIS,71) I,JET,I1,LJET,(PJSET(K,I),K=1,5)
71      FORMAT(1X,I6,I6,I8,4X,A5,8X,'FINAL',5F10.2)
      ELSEIF(J1.NE.J2) THEN
        WRITE(ITLIS,72) I,JET,I1,LJET,J1,J2,(PJSET(K,I),K=1,5)
72      FORMAT(1X,I6,I6,I8,4X,A5,4X,I4,'-',I4,5F10.2)
      ELSE
        WRITE(ITLIS,73) I,JET,I1,LJET,(PJSET(K,I),K=1,5)
73      FORMAT(1X,I6,I6,I8,4X,A5,6X,'INITIAL',5F10.2)
      ENDIF
310   CONTINUE
C
C          PRINT HADRON PARAMETERS
300   IF(NPTCL.EQ.0) RETURN
      IF(.NOT.KEYS(2)) WRITE(ITLIS,45) NPOM
45    FORMAT(//' NUMBER OF POMERONS =',I5)
      WRITE(ITLIS,40)
40    FORMAT(//20X,'HADRON PARAMETERS'//7X,'I',3X,'JET',5X,'ORIG'
     C  ,4X,'TYPE',11X,'DECAY',8X,'PX',8X,'PY',8X,'PZ',8X,'P0'
     C  ,8X,'PT',5X,'THETA',7X,'PHI')
      DO 200 I=1,NPTCL
      I1=IABS(IORIG(I))
      JET=I1/IPACK
      I1=I1-IPACK*JET
      I1=ISIGN(I1,IORIG(I))
      IDLV1=IDENT(I)
      LPTCL=LABEL(IDLV1)
      J1=IDCAY(I)/IPACK
      J2=MOD(IDCAY(I),IPACK)
      PTHAD=SQRT(PPTCL(1,I)**2+PPTCL(2,I)**2)
      PHAD=SQRT(PPTCL(3,I)**2+PTHAD**2)
      PHIHAD=ATAN2(PPTCL(2,I),PPTCL(1,I))
      IF(PHIHAD.LT.0.) PHIHAD=2.*PI+PHIHAD
      THHAD=ACOS(PPTCL(3,I)/PHAD)
      IF(IDCAY(I).EQ.0) THEN
        WRITE(ITLIS,50) I,JET,I1,LPTCL,(PPTCL(K,I),K=1,4),PTHAD,THHAD,
     $  PHIHAD
50      FORMAT(1X,I7,I6,I9,4X,A5,9X,'STABLE',5F10.2,2F10.4)
      ELSE
        WRITE(ITLIS,60) I,JET,I1,LPTCL,J1,J2,(PPTCL(K,I),K=1,4),
     $  PTHAD,THHAD,PHIHAD
60      FORMAT(1X,I7,I6,I9,4X,A5,4X,I5,'-',I5,5F10.2,2F10.4)
      ENDIF
200   CONTINUE
      RETURN
      END
CDECK  ID>, PRTLIM. 
      SUBROUTINE PRTLIM
C
C          Print initial conditions and limits for generating jets
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXFORC
      PARAMETER (MXFORC=40)
      COMMON/FORCE/NFORCE,IFORCE(MXFORC),MFORCE(5,MXFORC)
     $,LOOK2(2,MXFORC),LOOKST(MXFORC)
      SAVE /FORCE/
      INTEGER   NFORCE,IFORCE,MFORCE,LOOK2,LOOKST
      INTEGER   LIMPOM
      PARAMETER (LIMPOM=20)
      COMMON/MBGEN/POMWT(LIMPOM),POMGEN(LIMPOM),MNPOM,MXPOM,PDIFFR,
     $NPOM,XBARY(2),DXBARY(2),XPOM(LIMPOM,2)
      SAVE /MBGEN/
      INTEGER   MNPOM,MXPOM,NPOM
      REAL      POMWT,POMGEN,PDIFFR,XBARY,DXBARY,XPOM
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/QLMASS/AMLEP(100),NQLEP,NMES,NBARY
      SAVE /QLMASS/
      INTEGER   NQLEP,NMES,NBARY
      REAL      AMLEP
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/FRGPAR/PUD,PBARY,SIGQT,PEND,XGEN(8),PSPIN1(8),
     $PMIX1(3,2),PMIX2(3,2),XGENSS(9)
      SAVE /FRGPAR/
      EQUIVALENCE (PMIX1(1,1),PMIXX1(1))
      EQUIVALENCE (PMIX2(1,1),PMIXX2(1))
      EQUIVALENCE(FRPAR(1),PUD)
      REAL      PUD,PBARY,SIGQT,PEND,XGEN,PSPIN1,PMIX1,PMIX2,XGENSS,
     +          PMIXX1(6),PMIXX2(6),FRPAR(32)
      COMMON/NODCAY/NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      SAVE /NODCAY/
      LOGICAL NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      COMMON/PRTOUT/NEVPRT,NJUMP
      SAVE /PRTOUT/
      INTEGER   NEVPRT,NJUMP
      COMMON/SEED/XSEED
      SAVE /SEED/
      CHARACTER*24 XSEED
      COMMON/TYPES/LOC(100),NTYP,NJTTYP(3),NWWTYP(2),NWMODE(3)
      COMMON/XTYPES/PARTYP(40),TITLE(10),JETYP(30,3),WWTYP(30,2)
     $,WMODES(30,3)
      SAVE /TYPES/,/XTYPES/
      CHARACTER*8 JETYP,WWTYP,TITLE,PARTYP,WMODES
      INTEGER   LOC,NTYP,NJTTYP,NWWTYP,NWMODE
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/PTPAR/PTFUN1,PTFUN2,PTGEN1,PTGEN2,PTGEN3,SIGMAX
      SAVE /PTPAR/
      REAL      PTFUN1,PTFUN2,PTGEN1,PTGEN2,PTGEN3,SIGMAX
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
      COMMON/ISLOOP/NEVOLV,NFRGMN,IEVOL,IFRG
      SAVE /ISLOOP/
      INTEGER NEVOLV,NFRGMN,IEVOL,IFRG
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C
      INTEGER I,II,K,NPRT,I1,I2,I3,J1,INDEX,IQ,KK,KKK,NN
      REAL AMASS
      CHARACTER*8 LSTRUC(6),LMODE(5),STUF(6),IDFMT(2)
      CHARACTER*8 WTITL(4)
      CHARACTER*8 LABEL,L0
      CHARACTER*8 BLANK
      CHARACTER*40 V,VISAJE
      REAL AM(6),AML(6)
      INTEGER NPRSS
      PARAMETER (NPRSS=32)
      INTEGER IDPRSS(NPRSS)
      REAL AMPRSS(NPRSS)
      CHARACTER*8 LPRSS(NPRSS)
      DATA LSTRUC/'OWENS','BAIER','EICHTEN','DUKE','CTEQ2L','CTEQ3L'/
      DATA WTITL/'GM','W+','W-','Z0'/
      DATA BLANK/' '/
      DATA IDPRSS/21,22,23,24,25,26,41,42,43,44,45,46,
     $31,32,33,34,35,36,52,54,56,
     $29,30,40,50,60,39,49,82,83,84,86/
C
C          Print version
      V=VISAJE()
      WRITE(ITLIS,1000) V
1000  FORMAT('1',44('*')/' *',42X,'*'/
     C  ' * ',A40,' *'/
     C  ' *',42X,'*'/' ',44('*')/)
C
C          Print title, reaction, energy, number, run id
      WRITE(ITLIS,1010) TITLE
1010  FORMAT(/11X,10A8)
      WRITE(ITLIS,1020) NJET
1020  FORMAT(/2X,'NUMBER OF JETS TO BE GENERATED PER EVENT',I3)
      DO 100 I=1,2
        IDFMT(I)=LABEL(IDIN(I))
100   CONTINUE
      WRITE(ITLIS,1030) IDFMT(1),IDFMT(2),ECM
1030  FORMAT(/2X,A8,' ON ',A8,' AT COM ENERGY',E15.4)
      WRITE(ITLIS,1040) REAC,NEVENT
1040  FORMAT(/2X,'NUMBER OF ',A8,' EVENTS TO BE GENERATED',I10)
      IF(NEVPRT.GT.0) WRITE(ITLIS,1050) NEVPRT,NJUMP
1050  FORMAT(/2X,'PRINT A MAXIMUM OF ',I6,
     C  ' EVENTS SKIPPING ',I6,' EVENTS AT A TIME')
      WRITE(ITLIS,1060) IDG
1060  FORMAT(/2X,'RUN ID   ',2I10)
C
C          Print W/Higgs parameters
C
      IF(KEYS(3).OR.KEYS(7)) THEN
        IF(KEYS(3)) THEN
          II=0
          DO 200 I=1,4
            IF(.NOT.GODY(I)) GOTO 200
            II=II+1
            STUF(II)=WTITL(I)
200       CONTINUE
        ELSE
          II=1
          STUF(II)='HIGGS'
        ENDIF
        WRITE(ITLIS,2000) (STUF(K),K=1,II)
2000    FORMAT(//10X,'PARAMETERS FOR',4(2X,A8))
        WRITE(ITLIS,2010) QMIN,QMAX
2010    FORMAT(' MASS LIMITS',15X,2E15.4)
        WRITE(ITLIS,3020) QTMIN,QTMAX
        WRITE(ITLIS,3030) THWMIN,THWMAX
        WRITE(ITLIS,3040) PHWMIN,PHWMAX
        WRITE(ITLIS,3050) YWMIN,YWMAX
        WRITE(ITLIS,3060) XWMIN,XWMAX
        NPRT=0
        IF(FIXQT) THEN
          NPRT=NPRT+1
          STUF(NPRT)='QTW     '
        ENDIF
        IF(FIXQM) THEN
          NPRT=NPRT+1
          STUF(NPRT)='QMW     '
        ENDIF
        IF(FIXYW) THEN
          NPRT=NPRT+1
          STUF(NPRT)='YW      '
        ENDIF
        IF(FIXXW) THEN
          NPRT=NPRT+1
          STUF(NPRT)='XW      '
        ENDIF
        IF(FIXPHW) THEN
          NPRT=NPRT+1
          STUF(NPRT)='PHW     '
        ENDIF
        IF(NPRT.NE.0) WRITE(ITLIS,3070) (STUF(K),K=1,NPRT)
      ENDIF
C
C          Print jet parameters
C
      DO 300 I=1,6
300   STUF(I)=BLANK
      DO 310 I=1,NJET
        NPRT=0
        WRITE(ITLIS,3000) I
3000    FORMAT(//10X,'JET NO.',I3,/)
        WRITE(ITLIS,3010) PMIN(I),PMAX(I)
3010    FORMAT(' MOMENTUM LIMITS',11X,2E15.4)
        WRITE(ITLIS,3020) PTMIN(I),PTMAX(I)
3020    FORMAT(' TRANSVERSE MOMENTUM LIMITS',2E15.4)
        WRITE(ITLIS,3030) THMIN(I),THMAX(I)
3030    FORMAT(' THETA LIMITS',14X,2E15.4)
        WRITE(ITLIS,3040) PHIMIN(I),PHIMAX(I)
3040    FORMAT(' PHI LIMITS',16X,2E15.4)
        WRITE(ITLIS,3050) YJMIN(I),YJMAX(I)
3050    FORMAT(' RAPIDITY (Y) LIMITS',7X,2E15.4)
        WRITE(ITLIS,3060) XJMIN(I),XJMAX(I)
3060    FORMAT(' FEYNMAN X LIMITS',10X,2E15.4)
        IF(.NOT.GOALL(I)) WRITE(ITLIS,3070) (JETYP(K,I),K=1,NJTTYP(I))
3070    FORMAT(' JET TYPE',23X,A8,1X,A8,1X,A8,1X,A8,1X,A8)
        IF((KEYS(6).OR.KEYS(7)).AND..NOT.ALLWW(I))
     $  WRITE(ITLIS,3080) (WWTYP(K,I),K=1,NWWTYP(I))
3080    FORMAT(' DECAY MODES',20X,A8,1X,A8,1X,A8,1X,A8,1X,A8)
        IF(FIXP(I)) THEN
          NPRT=NPRT+1
          STUF(NPRT)='P       '
        ENDIF
        IF(FIXPT(I)) THEN
          NPRT=NPRT+1
          STUF(NPRT)='PT      '
        ENDIF
        IF(FIXYJ(I)) THEN
          NPRT=NPRT+1
          STUF(NPRT)='TH      '
          NPRT=NPRT+1
          STUF(NPRT)='Y      '
        ENDIF
        IF(FIXPHI(I)) THEN
          NPRT=NPRT+1
          STUF(NPRT)='PHI     '
        ENDIF
        IF(FIXXJ(I)) THEN
          NPRT=NPRT+1
          STUF(NPRT)='X       '
        ENDIF
        IF(NPRT.EQ.0) GOTO 310
        WRITE(ITLIS,2070) (STUF(K),K=1,NPRT)
2070    FORMAT(/5X,'FOLLOWING PARAMETERS HAVE BEEN FIXED ',6A8)
310   CONTINUE
C
C          Print structure functions, QCD parameters, W parameters,
C          and other parameters changed from their default values.
C
      IF(KEYS(1).OR.KEYS(3).OR.KEYS(5).OR.KEYS(6).OR.KEYS(7)
     $.OR.KEYS(8).OR.KEYS(9)) THEN
        IF(ISTRUC.GT.0) THEN
          WRITE(ITLIS,4000) LSTRUC(ISTRUC)
4000      FORMAT(//1X,A8,' STRUCTURE FUNCTIONS')
        ELSEIF(ISTRUC.EQ.-999) THEN
          WRITE(ITLIS,4001)
4001      FORMAT(//1X,' PDFLIB STRUCTURE FUNCTIONS')
        ENDIF
      ENDIF
      WRITE(ITLIS,4010) ALAM,CUTJET
4010  FORMAT(//' QCD LAMBDA =',F10.4,10X,'JET CUTOFF MASS =',F10.3)
      WRITE(ITLIS,4020) AMLEP(6),AMLEP(7),AMLEP(8)
4020  FORMAT(/' HEAVY QUARK MASSES =',3F8.2)
      IF(LOC(36).NE.0) THEN
        CALL FLAVOR(80,I1,I2,I3,J1,INDEX)
        WRITE(ITLIS,4030) (AMLEP(INDEX+K),K=1,9)
4030    FORMAT(/' HIGGS MASSES =',6F8.2/15X,3F8.2)
      ENDIF
C          Supersymmetry
      IF(KEYS(5).AND..NOT.GOMSSM) THEN
        DO 410 IQ=1,6
          AM(IQ)=AMASS(20+IQ)
          AML(IQ)=AMASS(30+IQ)
410     CONTINUE
        WRITE(ITLIS,4040) (AM(KK),KK=1,6)
4040    FORMAT(//' SQUARK  MASSES ',7F9.2)
        WRITE(ITLIS,4050) (AML(KK),KK=1,6)
4050    FORMAT(' SLEPTON MASSES ',7F9.2)
        AM(1)=AMASS(29)
        AM(2)=AMASS(30)
        AM(3)=AMASS(39)
        AM(4)=AMASS(40)
        WRITE(ITLIS,4060) (AM(KK),KK=1,4)
4060    FORMAT(' GAUGINO MASSES (WITH SIGNS) ',7F9.2)
        IF(LOC(44).NE.0) WRITE(ITLIS,4070) XGENSS(9),
     $  (XGENSS(KK),KK=1,8)
4070    FORMAT(/' FRAG. PARAM. XGENSS = ',9F8.3)
      ENDIF
C          MSSM model
      IF(GOMSSM) THEN
        DO 420 I=1,NPRSS
          LPRSS(I)=LABEL(IDPRSS(I))
          AMPRSS(I)=AMASS(IDPRSS(I))
420     CONTINUE
        WRITE(ITLIS,4100) (LPRSS(I),AMPRSS(I),I=1,NPRSS)
4100    FORMAT(/' MSSM MASSES (WITH SIGNS):'/
     $  10(' M(',A5,') = ',F10.3,5X,'M(',A5,') = ',F10.3,
     $  5X,'M(',A5,') = ',F10.3/),
     $  ' M(',A5,') = ',F10.3,5X,'M(',A5,') = ',F10.3)
        IF(.NOT.GOSUG) THEN
          WRITE(ITLIS,4110) XTBSS,XMUSS,XATSS
4110      FORMAT(/' OTHER MSSM PARAMETERS:'/
     $    ' TAN(BETA) = ',F10.3,5X,'MU = ',F10.3,5X,'A_t = ',F10.3)
        ENDIF
        IF(GOSUG) THEN
          WRITE(ITLIS,4120) XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
4120      FORMAT(/' DETERMINED FROM SUGRA INPUT:'/
     $    ' M_0       =',F10.3,'   M_(1/2) =',F10.3,'   A_0 =',F10.3/
     $    ' TAN(BETA) =',F10.4,'   SGN(MU) =',F6.1)
        ENDIF
      ENDIF
C
C          Other parameters
C
      IF(LOC(30).NE.0) WRITE(ITLIS,4200) XGEN
4200  FORMAT(/' FRAGMENTATION PARAMETER XGEN =',6F8.3)
      IF(LOC(31).NE.0) WRITE(ITLIS,4210) SIGQT
4210  FORMAT(/' FRAGMENTATION PARAMETER SIGQT =',F8.3)
      IF(KEYS(2).OR.KEYS(3).OR.KEYS(6).OR.KEYS(7)) THEN
        WRITE(ITLIS,4220) SIN2W,WMASS(2),WMASS(4),WGAM(2),WGAM(4)
4220    FORMAT(//' WEINBERG MODEL',5X,'SIN**2(THETA-W)=',F8.4/
     $  ' MASSES = ',F8.2,',',F8.2,'   WIDTHS = ',F8.3,',',F8.3)
      ENDIF
      IF(KEYS(3)) THEN
        IF(.NOT.STDDY) WRITE(ITLIS,4230) CUTOFF,CUTPOW
4230    FORMAT(/' CUTOFF FUNCTION IS QT**2=',E11.4,'*Q**',E11.4)
        IF(LOC(50).NE.0) WRITE(ITLIS,4240) WFUDGE
4240    FORMAT(/' W fudge factor (WFUDGE) = ',F8.3)
      ENDIF
      IF(KEYS(7)) THEN
        WRITE(ITLIS,4250) HMASS,HGAM
4250    FORMAT(/' HIGGS MASS = ',F8.2,'  WIDTH = ',F8.3)
      ENDIF
      WRITE(ITLIS,4260) XSEED
4260  FORMAT(/' SEED FOR RANDOM NUMBER GENERATOR = ',A24)
      IF(LOC(13).NE.0) WRITE(ITLIS,4270) FRPAR
4270  FORMAT(//'  FRAGMENTATION PARAMETERS ',8E11.3,2(/,26X,8E11.3))
      IF(LOC(34).NE.0) WRITE(ITLIS,4280) MNPOM,MXPOM
4280  FORMAT(//'  NUMBER OF POMERONS =',I4,' TO',I4)
C
C          Decay switches
C
      IF(LOC(46).NE.0) THEN
        WRITE(ITLIS,4300)
4300    FORMAT(//'  SECONDARY W DECAY MODES:')
        NN=MAX0(NWMODE(1),1)
        WRITE(ITLIS,4310) (WMODES(KKK,1),KKK=1,NN)
4310    FORMAT('  W+ --> '
     $  ,A8,1X,A8,1X,A8,1X,A8,1X,A8,1X,A8,1X,A8,1X,A8)
        NN=MAX0(NWMODE(2),1)
        WRITE(ITLIS,4320) (WMODES(KKK,2),KKK=1,NN)
4320    FORMAT('  W- --> '
     $  ,A8,1X,A8,1X,A8,1X,A8,1X,A8,1X,A8,1X,A8,1X,A8)
        WRITE(ITLIS,4330) (WMODES(KKK,3),KKK=1,NN)
4330    FORMAT('  Z0 --> '
     $  ,A8,1X,A8,1X,A8,1X,A8,1X,A8,1X,A8,1X,A8,1X,A8)
      ENDIF
C
      IF(NODCAY) WRITE(ITLIS,4400)
4400  FORMAT(//'  NO DECAYS OF HADRONS WILL BE GENERATED')
      IF(NOETA) WRITE(ITLIS,4410)
4410  FORMAT(//'  NO DECAYS OF ETAS WILL BE GENERATED')
      IF(NOPI0) WRITE(ITLIS,4420)
4420  FORMAT(//'  NO DECAYS OF PI0S WILL BE GENERATED')
      IF(NONUNU) WRITE(ITLIS,4430)
4430  FORMAT(//'  NO DECAYS Z0---->NU+NU WILL BE GENERATED')
      IF(NOEVOL) WRITE(ITLIS,4440)
4440  FORMAT(//'  NO QCD JET EVOLUTION WILL BE DONE')
      IF(NOHADR) WRITE(ITLIS,4450)
4450  FORMAT(//'  NO JET HADRONIZATION WILL BE DONE')
      IF(GOGMSB.AND.NOGRAV) WRITE(ITLIS,4460)
4460  FORMAT(//'  NO GRAVITINO DECAYS WILL BE GENERATED')
C
C          Print forced decay modes
C
      IF(NFORCE.NE.0) THEN
        WRITE(ITLIS,4500)
4500    FORMAT(//7X,'FORCED DECAY MODES'/2X,'PART',6X,'DECAY MODE')
        DO 450 I=1,NFORCE
          IF(IFORCE(I).EQ.0) GOTO 450
          L0=LABEL(IFORCE(I))
          DO 451 K=1,5
            LMODE(K)=BLANK
            IF(MFORCE(K,I).EQ.0) GO TO 451
            LMODE(K)=LABEL(MFORCE(K,I))
451       CONTINUE
          WRITE(ITLIS,4510) L0,(LMODE(K),K=1,5)
4510      FORMAT(2X,6A10)
450     CONTINUE
      ENDIF
C
C          Print multiple evolution/fragmentation information
C
      IF(NEVOLV.NE.1.OR.NFRGMN.NE.1) THEN
        WRITE(ITLIS,4600) NEVOLV,NFRGMN
4600    FORMAT(//,
     $  '  MULTIPLE EVOLUTION AND FRAGMENTATION VERSION'/
     $  '  EVENTS WILL BE EVOLVED',I6,' TIMES'/
     $  '  AND FRAGMENTED        ',I6,' TIMES'/)
      ENDIF
C
      RETURN
      END
CDECK  ID>, PTFUN.  
      SUBROUTINE PTFUN
C
C          Calculate an envelope
C          D(SIGMA)/D(PT**2)D(Y1)D(Y2) < PTFUN1*PT**PTFUN2
C          used to generate initial PT values.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PTPAR/PTFUN1,PTFUN2,PTGEN1,PTGEN2,PTGEN3,SIGMAX
      SAVE /PTPAR/
      REAL      PTFUN1,PTFUN2,PTGEN1,PTGEN2,PTGEN3,SIGMAX
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
C
      REAL PCPY(24)
      EQUIVALENCE(P(1),PCPY(1))
      REAL PTS(51),SIGSAV(51),STOR(24),DPT,DPTMIN,A,B,DEVMAX,DEV
      REAL DY1,DY2,B1
      INTEGER I,NPT,NDIV1,NDIV2,I1,I2
C
      DATA DPTMIN/0.2/
C
C          Initialize
      DO 89 I=1,24
   89 STOR(I)=PCPY(I)
      YJ(1)=0
      YJ(2)=0
      TH(1)=PI/2.
      TH(2)=PI/2.
      STH(1)=1.
      STH(2)=1.
      CTH(1)=0.
      CTH(2)=0.
      PHI(1)=0.
      PHI(2)=PI
      IF(FIXPT(1).OR.FIXPT(2)) GOTO 300
      DPT=(PTMAX(1)-PTMIN(1))/25.
      IF(DPT.LT.DPTMIN) DPT=DPTMIN
      NPT=(PTMAX(1)-PTMIN(1))/DPT+1
      IF(NPT.GT.51) NPT=50
      IF(NPT.LE.1) NPT=2
C
C          Calculate sigma vs PT at Y1=Y2=0
      DO 100 I=1,NPT
        PT(1)=PTMIN(1)+DPT*(I-1)
        PT(2)=PT(1)
        P(1)=PT(1)
        P(2)=PT(2)
        IF(KEYS(1)) THEN
          CALL SIGQCD
        ELSEIF(KEYS(5)) THEN
          CALL SIGSSY
        ELSEIF(KEYS(6)) THEN
          CALL SIGWW
        ELSEIF(KEYS(8)) THEN
          CALL SIGGAM
        ENDIF
        IF(SIGMA.EQ.0.) GO TO 9999
        SIGSAV(I)=ALOG(SIGMA)
        PTS(I)=ALOG(PT(1))
  100 CONTINUE
C
C          Fit to power and shift to get envelope
C
      CALL LSTSQ(PTS,SIGSAV,NPT,A,B)
      DEVMAX=0.
      DO 101 I=1,NPT
        DEV=SIGSAV(I)-A-B*PTS(I)
        IF(DEV.GT.DEVMAX) DEVMAX=DEV
  101 CONTINUE
C
C        Scan in Y1, Y2 for 3 PT values
C
      DO 104 I=1,3
        IF(I.EQ.1) PT(1)=PTMIN(1)
        IF(I.EQ.2) PT(1)=(PTMIN(1)+PTMAX(1))/2.
        IF(I.EQ.3) PT(1)=PTMAX(1)
        PT(2)=PT(1)
        NDIV1=YJMAX(1)-YJMIN(1)
        IF(NDIV1.GT.20) NDIV1=20
        NDIV2=YJMAX(2)-YJMIN(2)
        IF(NDIV2.GT.20) NDIV2=20
        IF(NDIV1.LE.1) NDIV1=2
        IF(NDIV2.LE.1) NDIV2=2
        DY1=(YJMAX(1)-YJMIN(1))/(NDIV1-1)
        DY2=(YJMAX(2)-YJMIN(2))/(NDIV2-1)
        IF(FIXYJ(1)) NDIV1=1
        IF(FIXYJ(2)) NDIV2=1
C
        DO 103 I1=1,NDIV1
          YJ(1)=YJMIN(1)+(I1-1)*DY1
          CTH(1)=TANH(YJ(1))
          STH(1)=SQRT(1.-CTH(1)**2)
          IF(STH(1).EQ.0) GOTO 103
          TH(1)=ACOS(CTH(1))
          P(1)=PT(1)/STH(1)
C
          DO 102 I2=1,NDIV2
            YJ(2)=YJMIN(2)+(I2-1)*DY2
            CTH(2)=TANH(YJ(2))
            STH(2)=SQRT(1.-CTH(2)**2)
            IF(STH(2).EQ.0) GOTO 103
            TH(2)=ACOS(CTH(2))
            P(2)=PT(2)/STH(2)
            IF(KEYS(1)) THEN
              CALL SIGQCD
            ELSEIF(KEYS(5)) THEN
              CALL SIGSSY
            ELSEIF(KEYS(6)) THEN
              CALL SIGWW
            ELSEIF(KEYS(8)) THEN
              CALL SIGGAM
            ENDIF
            IF(SIGMA.EQ.0.) GO TO 102
            DEV=ALOG(SIGMA)-A-B*ALOG(PT(1))
            IF(DEV.GT.DEVMAX) DEVMAX=DEV
  102     CONTINUE
  103   CONTINUE
  104 CONTINUE
C
      A=A+DEVMAX
      B1=B+2.
      PTFUN1=EXP(A)
      PTFUN2=B
C
C          Use envelope to generate initial PT values
C
      PTGEN1=PTMIN(1)**B1
      PTGEN2=PTMAX(1)**B1-PTGEN1
      PTGEN3=1./B1
      DO 109 I=1,24
  109 PCPY(I)=STOR(I)
C
C          Write envelope parameters on listing
C
      WRITE(ITLIS,200) PTFUN1,PTFUN2,PTGEN1,PTGEN2,PTGEN3
200   FORMAT(//10X,'FIT AT Y1=Y2=0 IS D(SIGMA)/D(PT**2)D(Y1)D(Y2)='
     C  ,E11.5,'*PT**(',E11.5,')'//
     C  10X,'PT FIRST GENERATED BY PT=(',E11.5,'+',E11.5,'*RANF)**(',
     C  E11.5,')')
C
      RETURN
C
C          Fixed PT
C
  300 CONTINUE
      IF(FIXPT(1)) PT(2)=PT(1)
      IF(FIXPT(2)) PT(1)=PT(2)
      P(1)=PT(1)
      P(2)=PT(2)
      IF(KEYS(1)) THEN
        CALL SIGQCD
      ELSEIF(KEYS(5)) THEN
        CALL SIGSSY
      ELSEIF(KEYS(6)) THEN
        CALL SIGWW
      ELSEIF(KEYS(8)) THEN
        CALL SIGGAM
      ENDIF
      SIGMAX=SIGMA
      DO 301 I=1,24
301   PCPY(I)=STOR(I)
C
      RETURN
C
C          Fit fails if SIGMA=0 in specified range
9999  WRITE(ITLIS,1010) PT(1)
1010  FORMAT(//' ERROR IN PTFUN...SIGMA=0 FOR PT = ',E12.4/
     1' CHECK YOUR LIMITS.')
      STOP 99
      END
CDECK  ID>, QCDINI. 
      SUBROUTINE QCDINI(JIN1,JIN2)
C
C          GENERATE INITIAL-STATE QCD CASCADE USING BACKWARDS
C          EVOLUTION OF GOTTSCHALK AND OF SJOSTRAND.
C
C          IF QCDINI FAILS WHEN ATTEMPTING TO FORCE GL-->QK+QB FOR
C          HEAVY QUARKS, THEN RETURN NJSET=-1.
C
C          VER. 6.40: TRAP W1LIM > 0 TO PREVENT ROUNDING ERRORS.
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/PINITS/PINITS(5,2),IDINIT(2)
      SAVE /PINITS/
      INTEGER   IDINIT
      REAL      PINITS
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/JWORK2/JVIR(2),PFINAL(5),SGN,ZMIN,ZMAX,DZMAX,JET,GLFORC(2),
     $ZGOOD,JIN(400),FXTEST(MXJSET)
      SAVE /JWORK2/
      LOGICAL GLFORC,ZGOOD
      INTEGER   JVIR,JET,JIN
      REAL      PFINAL,SGN,ZMIN,ZMAX,DZMAX,FXTEST
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
C
      DIMENSION BOOST1(5),BOOST2(5),B2B1(5),DBL1(5),DBL2(5)
      DIMENSION FXOLD(2),FXNEW(2)
      DIMENSION PJKEEP(5,12),JINS(2),JLIST(16),PFKEEP(5)
      DOUBLE PRECISION DBL1,DBL2,DBLM
C
C          CONVERT IDENT+7 TO JETTYP
      DATA JLIST/13,11,9,7,5,3,0,2,4,6,8,10,12,0,0,1/
      ALAMF(A,B,C)=SQRT((A-B-C)**2-4.*B*C)
C
C          INITIALIZE
C
      JINS(1)=JIN1
      JINS(2)=JIN2
      DO 97 K=1,4
97    PFKEEP(K)=PJSET(K,JIN1)+PJSET(K,JIN2)
C          EXCEPT FOR HIGGS, PFKEEP**2=SHAT
      IF(KEYS(7).OR.KEYS(9)) THEN
        S1KEEP=PFKEEP(4)**2-PFKEEP(1)**2-PFKEEP(2)**2-PFKEEP(3)**2
        PFKEEP(5)=SQRT(S1KEEP)
        PPKEEP=PFKEEP(4)+PFKEEP(3)
        PMKEEP=PFKEEP(4)-PFKEEP(3)
      ELSE
        S1KEEP=SHAT
        PFKEEP(5)=SQRT(S1KEEP)
        IF(PFKEEP(3).GT.0.) THEN
          PPKEEP=PFKEEP(4)+PFKEEP(3)
          PMKEEP=(S1KEEP+PFKEEP(1)**2+PFKEEP(2)**2)/PPKEEP
        ELSE
          PMKEEP=PFKEEP(4)-PFKEEP(3)
          PPKEEP=(S1KEEP+PFKEEP(1)**2+PFKEEP(2)**2)/PMKEEP
        ENDIF
        PFKEEP(4)=.5*(PPKEEP+PMKEEP)
        PFKEEP(3)=.5*(PPKEEP-PMKEEP)
      ENDIF
      DO 98 I=1,NJSET
      DO 98 K=1,5
98    PJKEEP(K,I)=PJSET(K,I)
      NJKEEP=NJSET
      NPASS=0
      NPASS1=0
C
1     CONTINUE
      NPASS1=NPASS1+1
      IF(NPASS1.GT.100) GO TO 9999
      NJSET=NJKEEP
      DO 99 I=1,NJSET
      DO 99 K=1,5
99    PJSET(K,I)=PJKEEP(K,I)
C
      DO 100 K=1,5
100   PFINAL(K)=PFKEEP(K)
      S1=S1KEEP
      PTOTPL=PPKEEP
      PTOTMN=PMKEEP
      TCUT=CUTJET**2
      DO 101 I=1,2
      JI=JINS(I)
      XOLD=(PJSET(4,JI)+ABS(PJSET(3,JI)))/ECM
      JT=JLIST(JTYPE(JI)+7)
      FXOLD(I)=STRUC(XOLD,QSQ,JT,IDIN(I))
101   CONTINUE
C
C          DO FIRST EVOLUTION
      DO 110 I=1,2
      SGN=3-2*I
      JET=10+I
      JI=JINS(I)
      ZMIN=(PJSET(4,JI)+ABS(PJSET(3,JI)))/ECM
      ZMAX=1./(1.+TCUT/S1)
C          DZMAX=1.-ZMAX
      DZMAX=ZMAX*TCUT/S1
      IF(ZMIN.GE.ZMAX) ZMIN=.5*ZMAX
      CALL QCDINT(JI)
      JVIR(I)=JI
110   CONTINUE
C
C          SOLVE INITIAL KINEMATICS
      AM1SQ=PJSET(5,JVIR(1))**2*SIGN(1.,PJSET(5,JVIR(1)))
      AM2SQ=PJSET(5,JVIR(2))**2*SIGN(1.,PJSET(5,JVIR(2)))
      P1PL=(S1+AM1SQ-AM2SQ+ALAMF(S1,AM1SQ,AM2SQ))/(2.*PTOTMN)
      P1MN=AM1SQ/P1PL
      P2MN=(S1+AM2SQ-AM1SQ+ALAMF(S1,AM1SQ,AM2SQ))/(2.*PTOTPL)
      P2PL=AM2SQ/P2MN
      PJSET(3,JVIR(1))=.5*(P1PL-P1MN)
      PJSET(4,JVIR(1))=.5*(P1PL+P1MN)
      PJSET(3,JVIR(2))=.5*(P2PL-P2MN)
      PJSET(4,JVIR(2))=.5*(P2PL+P2MN)
C
C          TEST WHETHER NEW MASS IS PLAUSIBLE
      DO 111 I=1,2
      JI=JINS(I)
      XNEW=(PJSET(4,JI)+ABS(PJSET(3,JI)))/ECM
      IF(XNEW.GE.1.) THEN
        FXNEW(I)=0.
      ELSE
        JT=JLIST(JTYPE(JI)+7)
        FXNEW(I)=STRUC(XNEW,QSQ,JT,IDIN(I))
      ENDIF
111   CONTINUE
      DO 112 I=1,2
      IF(FXNEW(I).LT.FXOLD(I)*RANF()) GO TO 1
112   CONTINUE
C
C          FIND JVIR (SPACE-LIKE PARTON) WITH LARGER (-MASS) FOR NEXT
C          BRANCHING.
10    IF(JDCAY(JVIR(1)).GE.0.AND.JDCAY(JVIR(2)).GE.0) RETURN
      NPASS=NPASS+1
      IF(NPASS.GT.20*NJSET) GO TO 9999
      IF(-PJSET(5,JVIR(1)).GE.-PJSET(5,JVIR(2))) THEN
        IVIR=JVIR(1)
        IVIR2=JVIR(2)
        SGN=+1.
        JET=11
      ELSE
        IVIR=JVIR(2)
        IVIR2=JVIR(1)
        SGN=-1.
        JET=12
      ENDIF
C
      T1=PJSET(5,IVIR)**2
      ZMIN=(PJSET(4,IVIR)+SGN*PJSET(3,IVIR))/ECM
      ZMAX=1./(1.+T1/S1)
      DZMAX=ZMAX*T1/S1
      IF(ZMIN.GE.ZMAX) GO TO 1
C
C          GENERATE Z AND NEW PARTONS.
C          NEWV=SPACELIKE, NEWF=TIMELIKE.
      NEWV=NJSET+1
      NEWF=NJSET+2
      CALL QCDINZ(IVIR)
C
C          IF Z FAILS (BECAUSE OF STRUCTURE FUNCTION) SET NEWV=IVIR,
C          NEWF=NULL AND RE-SOLVE KINEMATICS.
15    IF(.NOT.ZGOOD) THEN
        CALL QCDINT(IVIR)
C
        PP1PL=PJSET(4,IVIR2)+PJSET(3,IVIR2)
        PP1MN=PJSET(4,IVIR2)-PJSET(3,IVIR2)
        AMSQ=PJSET(5,IVIR)**2*SIGN(1.,PJSET(5,IVIR))
        AMPSQ=PJSET(5,IVIR2)**2*SIGN(1.,PJSET(5,IVIR2))
        IF(SGN.GT.0) THEN
          P2PL=(S1-AMSQ-AMPSQ+ALAMF(S1,AMSQ,AMPSQ))/(2.*PP1MN)
          P2MN=AMSQ/P2PL
        ELSE
          P2MN=(S1-AMSQ-AMPSQ+ALAMF(S1,AMSQ,AMPSQ))/(2.*PP1PL)
          P2PL=AMSQ/P2MN
        ENDIF
        PJSET(3,IVIR)=.5*(P2PL-P2MN)
        PJSET(4,IVIR)=.5*(P2PL+P2MN)
C
        NEWV=IVIR
        DO 120 K=1,5
120     PJSET(K,NEWF)=0.
        GO TO 30
      ENDIF
C
C          EVOLVE NEW SPACELIKE PARTON.
      PJSET(5,NEWV)=PJSET(5,IVIR)
      S2=S1/ZZC(IVIR)
      ZMIN=ZMIN/ZZC(IVIR)
      ZMAX=1./(1.+TCUT/S2)
      DZMAX=ZMAX*TCUT/S2
      IF(ZMIN.GE.ZMAX) GO TO 1
      CALL QCDINT(NEWV)
C
C          CALCULATE APPROXIMATE MASS LIMIT AND DO TIMELIKE EVOLUTION.
C          VER. 6.40: TRAP W1LIM < 0 FROM ROUNDING ERRORS.
      W1LIM=T1*(1./(ZZC(IVIR)*(1.+T1/S1))-1.)
      W1LIM=AMIN1(W1LIM,T1)
      PJSET(5,NEWF)=SQRT(ABS(W1LIM))
      JDCAY(NEWF)=-1
20    CALL QCDT(NEWF)
C
C          SOLVE KINEMATICS USING +(PL) AND -(MN) COMPONENTS FOR
C          PJSET(K,NEWV)+PJSET(K,IVIR2)-->PJSET(K,NEWF)+PFINAL
C          STEP 1: SOLVE FOR P2=PJSET(K,NEWV)
      PP1PL=PJSET(4,IVIR2)+PJSET(3,IVIR2)
      PP1MN=PJSET(4,IVIR2)-PJSET(3,IVIR2)
      AMSQ=PJSET(5,NEWV)**2*SIGN(1.,PJSET(5,NEWV))
      AMPSQ=PJSET(5,IVIR2)**2*SIGN(1.,PJSET(5,IVIR2))
      W1=PJSET(5,NEWF)**2
      IF(SGN.GT.0) THEN
        P2PL=(S2-AMSQ-AMPSQ+ALAMF(S2,AMSQ,AMPSQ))/(2.*PP1MN)
        P2MN=AMSQ/P2PL
      ELSE
        P2MN=(S2-AMSQ-AMPSQ+ALAMF(S2,AMSQ,AMPSQ))/(2.*PP1PL)
        P2PL=AMSQ/P2MN
      ENDIF
C
C          STEP 2: SOLVE FOR Q1(K)=PJSET(K,IVIR)
      DEN=P2PL*PP1MN-P2MN*PP1PL
      Q1PL=(+P2PL*(S1+T1-AMPSQ)+PP1PL*(W1+T1-AMSQ))/DEN
      Q1MN=(-P2MN*(S1+T1-AMPSQ)-PP1MN*(W1+T1-AMSQ))/DEN
      WPL=P2PL-Q1PL
      WMN=P2MN-Q1MN
C          CALCULATE TRANSVERSE MOMENTUM AND REJECT IF UNPHYSICAL.
      Q1TR2=T1+Q1PL*Q1MN
      IF(Q1TR2.LT.0.) THEN
        IF(JDCAY(NEWF).EQ.-1) GO TO 20
        ZGOOD=.FALSE.
        GO TO 15
      ENDIF
C
C          DO ONE TIMELIKE BRANCHING TO INSURE CORRECT MASS. MUST FIRST
C          SHIFT NJSET TO PUT DECAY PRODUCTS IN CORRECT PLACE.
      IF(JDCAY(NEWF).EQ.-1) THEN
        NJSET=NJSET+2
        CALL QCDZ(NEWF)
        NJSET=NJSET-2
        Z1=ZZC(NEWF)
        E0=.5*(WPL+WMN)
        P0=SQRT(.25*(WPL-WMN)**2+Q1TR2)
        WM0=PJSET(5,NEWF)
        ZLIM=AMAX1((WM0/(E0+P0))**2,CUTJET/(E0+P0))
        IF(Z1.LE.ZLIM.OR.Z1.GE.1.-ZLIM) GO TO 20
        NEWF1=NEWF+1
        NEWF2=NEWF+2
        JDCAY(NEWF)=NEWF1*JPACK+NEWF2
        CALL QCDT(NEWF1)
        CALL QCDT(NEWF2)
        JORIG(NEWF1)=JPACK*JET+NEWF
        JORIG(NEWF2)=JORIG(NEWF1)
        DO 130 K=1,4
        PJSET(K,NEWF1)=0.
130     PJSET(K,NEWF2)=0.
      ENDIF
C
C          GOOD BRANCHING!
      PHIQ1=2.*PI*RANF()
      Q1TR=SQRT(Q1TR2)

      Q1X=Q1TR*COS(PHIQ1)
      Q1Y=Q1TR*SIN(PHIQ1)
C
      PJSET(1,IVIR)=Q1X
      PJSET(2,IVIR)=Q1Y
      PJSET(3,IVIR)=.5*(Q1PL-Q1MN)
      PJSET(4,IVIR)=.5*(Q1PL+Q1MN)
      JDCAY(IVIR)=JPACK*NEWV+NEWF
C
      PJSET(1,NEWV)=0.
      PJSET(2,NEWV)=0.
      PJSET(3,NEWV)=.5*(P2PL-P2MN)
      PJSET(4,NEWV)=.5*(P2PL+P2MN)
      JORIG(NEWV)=JPACK*JET+IVIR
C
      PJSET(1,NEWF)=-Q1X
      PJSET(2,NEWF)=-Q1Y
      PJSET(3,NEWF)=.5*(WPL-WMN)
      PJSET(4,NEWF)=.5*(WPL+WMN)
      JORIG(NEWF)=JPACK*JET+IVIR
C
C          BOOST ALL FINAL VECTORS (EXCEPT NEW ONES) AND RECALCULATE
C          VIRTUAL MOMENTA.  BOOST IS DETERMINED BY DIFFERENCE OF
C          NEW AND OLD TOTAL FINAL MOMENTA, B2B1=BOOST2-BOOST1.
C
30    CONTINUE
      DO 201 K=1,4
201   BOOST1(K)=PFINAL(K)
      BMASS=PFINAL(5)
      DO 202 K=1,4
202   BOOST2(K)=PJSET(K,NEWV)+PJSET(K,IVIR2)-PJSET(K,NEWF)
C
C          PARAMETERS FOR COMBINED BOOSTS.
C          DOUBLE PRECISION FOR 32-BIT MACHINES USING 3-VECTORS AND MASS
C          AS EXACT.
      DO 204 K=1,3
      DBL1(K)=BOOST1(K)
204   DBL2(K)=BOOST2(K)
      DBLM=BMASS
      DBL1(4)=DSQRT(DBL1(1)**2+DBL1(2)**2+DBL1(3)**2+DBLM**2)
      DBL2(4)=DSQRT(DBL2(1)**2+DBL2(2)**2+DBL2(3)**2+DBLM**2)
      BDOTB=DBL1(4)*DBL2(4)-DBL1(1)*DBL2(1)-DBL1(2)*DBL2(2)
     $-DBL1(3)*DBL2(3)
      DO 205 K=1,4
205   B2B1(K)=DBL2(K)-DBL1(K)
      B44=BDOTB/BMASS**2
      BI41=1./BMASS
      BI42=(BDOTB-BMASS**2-B2B1(4)*BMASS)/(BMASS**2*(BOOST2(4)+BMASS))
      B4K1=BI41
      B4K2=(BMASS**2-BDOTB-B2B1(4)*BMASS)/(BMASS**2*(BOOST1(4)+BMASS))
      BIK1=-1./(BMASS*(BOOST1(4)+BMASS))
      BIK2=1./(BMASS*(BOOST2(4)+BMASS))
      BIK3=(BMASS**2-BDOTB)/(BMASS**2*(BOOST1(4)+BMASS)
     $*(BOOST2(4)+BMASS))
C
C          BOOST FINAL JETS
      DO 210 J=1,NJSET
      IF(J.EQ.IVIR.OR.J.EQ.IVIR2) GO TO 210
      IF(PJSET(5,J).LT.0.) GO TO 210
      IF(JDCAY(J).EQ.-1) GO TO 210
      BP1=0.
      BP21=0.
      DO 215 K=1,3
      BP1=BP1+BOOST1(K)*PJSET(K,J)
215   BP21=BP21+B2B1(K)*PJSET(K,J)
      DO 220 K=1,3
220   PJSET(K,J)=PJSET(K,J)
     $+(B2B1(K)*BI41+BOOST2(K)*BI42)*PJSET(4,J)
     $+B2B1(K)*BP1*BIK1+BOOST2(K)*BP21*BIK2+BOOST2(K)*BP1*BIK3
      PJSET(4,J)=B44*PJSET(4,J)+BP21*B4K1+BP1*B4K2
210   CONTINUE
C
C          SET PFINAL TO BOOST2
      DO 230 K=1,4
230   PFINAL(K)=BOOST2(K)
      PFINAL(5)=BMASS
C
C          RESET REMAINING VECTORS
      DO 240 J=NJSET,1,-1
      IF(J.EQ.IVIR.OR.J.EQ.IVIR2) GO TO 240
      IF(PJSET(5,J).GE.0.) GO TO 240
      JX1=JDCAY(J)/JPACK
      JX2=JDCAY(J)-JPACK*JX1
      DO 250 K=1,4
      PJSET(K,J)=PJSET(K,JX1)-PJSET(K,JX2)
250   DBL1(K)=PJSET(K,J)
      AMJ=DSQRT(ABS(DBL1(4)**2-DBL1(1)**2-DBL1(2)**2-DBL1(3)**2))
      PJSET(5,J)=-AMJ
240   CONTINUE
C
C          RESET PFINAL, ETC.
C          NEED DOUBLE PRECISION ON 32-BIT MACHINES
      CALL DBLVEC(PFINAL,DBL1)
      CALL DBLVEC(PJSET(1,NEWF),DBL2)
      DO 300 K=1,4
      DBL1(K)=DBL1(K)+DBL2(K)
300   PFINAL(K)=DBL1(K)
      S1=DBL1(4)**2-DBL1(1)**2-DBL1(2)**2-DBL1(3)**2
      PFINAL(5)=SQRT(S1)
      IF(S1.LT.0.) GO TO 9999
      PFINAL(5)=SQRT(S1)
      PTOTPL=PJSET(4,NEWV)+PJSET(3,NEWV)+PJSET(4,IVIR2)+PJSET(3,IVIR2)
      PTOTMN=PJSET(4,NEWV)-PJSET(3,NEWV)+PJSET(4,IVIR2)-PJSET(3,IVIR2)
C
C          SET NJSET AND POINTERS IF Z WAS GOOD
      IF(.NOT.ZGOOD) GO TO 10
      NJSET=NJSET+2
      IF(JDCAY(NEWF).GT.0) NJSET=NJSET+2
      JVIR(JET-10)=NEWV
      GO TO 10
C          ERROR -- DISCARD EVENT.
9999  CONTINUE
      WRITE(ITLIS,9998) IEVT
9998  FORMAT(/' ***** ERROR IN QCDINI ... EVENT',I8,' DISCARDED *****')
      NJSET=-1
      RETURN
      END
CDECK  ID>, QCDINT. 
      SUBROUTINE QCDINT(J0)
C
C          AUXILIARY ROUTINE FOR QCDINI.  GENERATE A NEW MASS FOR
C          SPACELIKE PARTON J0.
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/JWORK2/JVIR(2),PFINAL(5),SGN,ZMIN,ZMAX,DZMAX,JET,GLFORC(2),
     $ZGOOD,JIN(400),FXTEST(MXJSET)
      SAVE /JWORK2/
      LOGICAL GLFORC,ZGOOD
      INTEGER   JVIR,JET,JIN
      REAL      PFINAL,SGN,ZMIN,ZMAX,DZMAX,FXTEST
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
C
      DIMENSION GAMS(13),FX0S(13)
      DATA CA/3./,CF/1.333333333/
C
C          FUNCTIONS -- USE DZMAX FOR PRECISION
      GQQ(Z,DZ)=CF*(-2.*ALOG(DZ)+Z*(-1.-.5*Z))
      GQG(Z)=CF*(+2.*ALOG(Z)+Z*(-2.+.5*Z))
      GGQ(Z)=(Z**3-(1.-Z)**3)/6.
      GGG(Z,DZ)=2.*CA*(ALOG(Z/DZ)+Z*(-2.+Z*(.5-Z/3.)))
      GBQQ(RZ,DZ)=CF*(2.*ALOG((1.+RZ)**2/DZ)+RZ*(-2.-2./3.*RZ**2))
      GBQG(RZ)=CF*(-4./RZ+RZ*(-4.+2./3.*RZ**2))
C
      GLFORC(JET-10)=.FALSE.
      IDABS=IABS(JTYPE(J0))
      IF(JTYPE(J0).EQ.9) THEN
        ITYP=1
      ELSEIF(JTYPE(J0).GT.0) THEN
        ITYP=2*IDABS
      ELSE
        ITYP=2.*IDABS+1
      ENDIF
      IBEAM=JET-10
      AM0=ABS(PJSET(5,J0))
1     T0=AM0**2
      X0=ZMIN
      ANF=3
      DO 110 I=4,6
      AMQ2=AMASS(I)**2
110   ANF=ANF+T0/(AMQ2+T0)
      B0=11.-2.*ANF/3.
C
C          SET UP ANOMALOUS DIMENSIONS. ALSO USE THESE TO DETERMINE TYPE
C          OF INCOMING PARTON (TO BE USED IN QCDINZ).
C
C          GLUON
      IF(IDABS.EQ.9) THEN
        AMQ=0.
        GAMG=GGG(ZMAX,DZMAX)-GGG(ZMIN,1.-ZMIN)
        GAMS(1)=GAMG
        FX0=STRUC(X0,T0,1,IDIN(IBEAM))
        FX0S(1)=FX0
        GAMFAC=(GBQG(SQRT(ZMAX))-GBQG(SQRT(ZMIN)))/FX0
        GAMQ=0.
        DO 210 IQ=2,13
        FX0S(IQ)=STRUC(X0,T0,IQ,IDIN(IBEAM))
        GAMS(IQ)=GAMFAC*FX0S(IQ)
210     GAMQ=GAMQ+GAMS(IQ)
        GAM=GAMG+GAMQ
        AM1=CUTJET
C
        TRY=RANF()
        SUM=0.
        DO 220 IQ=1,13
        SUM=SUM+GAMS(IQ)/GAM
        IF(SUM.LT.TRY) GO TO 220
        JIN(J0)=IQ
        FXTEST(J0)=FX0S(IQ)
        GO TO 300
220     CONTINUE
C
C          LIGHT QUARK
      ELSEIF(IDABS.LE.3) THEN
        AMQ=AMASS(IDABS)
        GAMQ=GBQQ(SQRT(ZMAX),DZMAX)-GBQQ(SQRT(ZMIN),1.-ZMIN)
        FX0=STRUC(X0,T0,ITYP,IDIN(IBEAM))
        FXG=STRUC(X0,T0,1,IDIN(IBEAM))
        GAMFAC=FXG/FX0
        GAMG=GAMFAC*(GGQ(ZMAX)-GGQ(ZMIN))
        GAM=GAMQ+GAMG
        AM1=AMQ+CUTJET
C
        IF(GAMQ/GAM.GT.RANF()) THEN
          JIN(J0)=ITYP
          FXTEST(J0)=FX0
        ELSE
          JIN(J0)=1
          FXTEST(J0)=FXG
        ENDIF
C
C          HEAVY QUARK -- SPECIAL TREATMENT NEEDED TO ALWAYS FORCE
C          GL-->QK+QB BEFORE END OF EVOLUTION.
C          USE SMALLER MASS FOR FORCED DECAYS TO PREVENT INFINITE LOOP.
      ELSE
        AMQ=AMASS(IDABS)
        THRESH=4.*AMQ**2*X0/(1.-X0)
        THRESH=(SQRT(THRESH)+CUTJET)**2
        IF(STRUC(X0,T0,ITYP,IDIN(IBEAM)).LE.0..OR.
     $  T0.LE.THRESH) THEN
          PJSET(5,J0)=-AM0*SQRT(RANF())-ALAM
          GLFORC(JET-10)=.TRUE.
          JDCAY(J0)=-2
          JIN(J0)=1
          FXTEST(J0)=1.
          RETURN
        ENDIF
        T1=SQRT(T0*THRESH)
230     AM1=SQRT(T1)
        FX0=STRUC(X0,T1,ITYP,IDIN(IBEAM))
        IF(FX0.LE.0.) THEN
          T1=SQRT(T1*T0)
          GO TO 230
        ENDIF
        FXG=STRUC(X0,T1,1,IDIN(IBEAM))
        GAMFAC=FXG/FX0
        GAMQ=GQQ(ZMAX,DZMAX)-GQQ(ZMIN,1.-ZMIN)
        GAMG=GAMFAC*(GGQ(ZMAX)-GGQ(ZMIN))
        GAM=GAMQ+GAMG
C
        IF(GAMQ/GAM.GT.RANF()) THEN
          JIN(J0)=ITYP
          FXTEST(J0)=FX0
        ELSE
          JIN(J0)=1
          FXTEST(J0)=FXG
        ENDIF
      ENDIF
C
C          LEADING-LOG MASS GENERATION.
C
300   GB=2.*GAM/B0
      IF(AM1.GT.ALAM.AND.AM0.GT.ALAM) THEN
        PROBL=GB*ALOG(ALOG(AM1/ALAM)/ALOG(AM0/ALAM))
      ELSE
        PROBL=0.
      ENDIF
      IF(PROBL.GT.0.) THEN
        PROB=1.
      ELSEIF(PROBL.GT.-50.) THEN
        PROB=EXP(PROBL)
      ELSE
        PROB=0.
      ENDIF
      IF(PROB.GT.RANF()) THEN
        IF(IDABS.LE.3.OR.IDABS.EQ.9) THEN
          PJSET(5,J0)=AMQ
          JDCAY(J0)=JPACK*J0+J0
          RETURN
        ELSEIF(AM0.LT.AM1+CUTJET) THEN
          PJSET(5,J0)=-SQRT(T0)
          GLFORC(JET-10)=.TRUE.
          JDCAY(J0)=-2
          JIN(J0)=1
          FXTEST(J0)=1
          RETURN
        ELSE
          AM0=AM1
          GO TO 1
        ENDIF
      ELSE
        POW=(1.-(1.-PROB)*RANF())**(1./GB)
        AMNEW=ALAM*(AM0/ALAM)**POW
        IF(AMNEW.GE.AM1) THEN
          PJSET(5,J0)=-AMNEW
          JDCAY(J0)=-2
          RETURN
        ELSEIF(IDABS.LE.3.OR.IDABS.EQ.9) THEN
          PJSET(5,J0)=AMQ
          JDCAY(J0)=JPACK*J0+J0
          RETURN
        ELSEIF(AM0.LT.AM1+CUTJET) THEN
          PJSET(5,J0)=-AM0*SQRT(RANF())-ALAM
          GLFORC(JET-10)=.TRUE.
          JDCAY(J0)=-2
          JIN(J0)=1
          FXTEST(J0)=1
          RETURN
        ELSE
          AM0=AM1
          GO TO 1
        ENDIF
      ENDIF
      END
CDECK  ID>, QCDINZ. 
      SUBROUTINE QCDINZ(J0)
C
C          AUXILIARY ROUTINE FOR QCDINI. GENERATE A Z AND TWO DAUGHTER
C          PARTONS FOR SPACELIKE PARTON J0.
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/JWORK2/JVIR(2),PFINAL(5),SGN,ZMIN,ZMAX,DZMAX,JET,GLFORC(2),
     $ZGOOD,JIN(400),FXTEST(MXJSET)
      SAVE /JWORK2/
      LOGICAL GLFORC,ZGOOD
      INTEGER   JVIR,JET,JIN
      REAL      PFINAL,SGN,ZMIN,ZMAX,DZMAX,FXTEST
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
C
      DATA CA/3./,CF/1.333333333/
C          FUNCTIONS.
      PQQ(Z)=CF*(1.+Z**2)/(1.-Z)
      PQG(Z)=CF*(1.+(1.-Z)**2)/Z
      PGQ(Z)=.5*(Z**2+(1.-Z)**2)
      PGG(Z)=2.*CA*(1.-Z*(1.-Z))**2/(Z*(1.-Z))
C
C          INITIALIZE
      IDABS=IABS(JTYPE(J0))
      AM0=ABS(PJSET(5,J0))
      T0=AM0**2
      JIN0=JIN(J0)
      X0=(PJSET(4,J0)+SGN*PJSET(3,J0))/ECM
      ZGOOD=.FALSE.
      IF(ZMIN.GE.ZMAX) RETURN
C
C          SELECT BRANCHING AND GENERATE Z ACCORDING TO ALTARELLI-PARISI
C          FUNCTIONS.  THEN CHECK WITH STRUCTURE FUNCTIONS
C
C          GLUON
C
      IF(IDABS.EQ.9) THEN
C
C          GL->GL+GL
        IF(JIN0.EQ.1) THEN
110       ZGEN=DZMAX/ZMAX*(ZMAX*(1.-ZMIN)/(ZMIN*DZMAX))**RANF()
          Z=1./(1.+ZGEN)
          DZ=ZGEN/(1.+ZGEN)
          GZ=2.*CA/(Z*DZ)
          PGGZ=2.*CA*(1.-Z*(1.-Z))**2/(Z*DZ)
          IF(PGGZ.LT.GZ*RANF()) GO TO 110
          JTYPE(NJSET+1)=9
          JTYPE(NJSET+2)=9
          ZZC(J0)=Z
C
          X1=X0/Z
          FX1=STRUC(X1,T0,1,IDIN(JET-10))
          FX0=FXTEST(J0)
          IF(FX1/FX0.GT.RANF()) ZGOOD=.TRUE.
C
C          QK->GL+QK
        ELSE
120       RZMAX=SQRT(ZMAX)
          RZMIN=SQRT(ZMIN)
          ZGEN=1./RZMAX-RANF()*(1./RZMAX-1./RZMIN)
          Z=1./ZGEN**2
          RZ=SQRT(Z)
          GZ=2.*CF/RZ**3
          IF(PQG(Z)/RZ.LT.GZ*RANF()) GO TO 120
          IFL=JIN0/2
          IF(JIN0.NE.2*IFL) IFL=-IFL
          JTYPE(NJSET+1)=IFL
          JTYPE(NJSET+2)=IFL
          ZZC(J0)=Z
C
          X1=X0/Z
          FX1=STRUC(X1,T0,JIN0,IDIN(JET-10))
          FX0=FXTEST(J0)
          IF(RZ*FX1/FX0.GT.RANF()) ZGOOD=.TRUE.
        ENDIF
C
C          QUARK
C
      ELSE
C
C          GL->QK+QB
        IF(JIN0.EQ.1) THEN
130       Z=ZMIN+(ZMAX-ZMIN)*RANF()
          IF(PGQ(Z).LT..5*RANF()) GO TO 130
          JTYPE(NJSET+1)=9
          JTYPE(NJSET+2)=-JTYPE(J0)
          ZZC(J0)=Z
C
          X1=X0/Z
          FX1=STRUC(X1,T0,1,IDIN(JET-10))
          FX0=FXTEST(J0)
          IF(FX1/FX0.GT.RANF().OR.GLFORC(JET-10)) ZGOOD=.TRUE.
C
C          QK->QK+GL
        ELSE
140       DZ=DZMAX*((1.-ZMIN)/DZMAX)**RANF()
          Z=1.-DZ
          GZ=2.*CF/DZ
          RZ=1.
          IF(IDABS.LE.3) RZ=SQRT(Z)
          PQQZ=CF*(1.+Z**2)/DZ
          IF(PQQZ/RZ.LT.GZ*RANF()) GO TO 140
          JTYPE(NJSET+1)=JTYPE(J0)
          JTYPE(NJSET+2)=9
          ZZC(J0)=Z
C
          X1=X0/Z
          FX1=STRUC(X1,T0,JIN0,IDIN(JET-10))
          FX0=FXTEST(J0)
          IF(RZ*FX1/FX0.GT.RANF()) ZGOOD=.TRUE.
        ENDIF
      ENDIF
      JMATCH(NJSET+1)=0
      JMATCH(NJSET+2)=0
      RETURN
      END
CDECK  ID>, QCDJET. 
      SUBROUTINE QCDJET(NJMIN)
C
C          Carry out final state QCD jet evolution using the algorithm
C          of Fox and Wolfram.  Evolve each parton in T with fixed ZC
C          and iterate as follows--
C
C          (0) Evolve initial partons.
C          (1) Pick I and find matching J>I.
C          (2) Solve kinematics.
C          (3) For K=I,J, generate Z(K) and evolve T(K1), T(K2).  If no
C              good, evolve T(K). Otherwise, add K1 and K2 to /JETSET/.
C          (4) If I or J no good, then (2).
C          (5) Then (1).
C
C          Use Z=(E+P)/(E0+P0) and a large TCUT.
C          JMATCH(J1)=J2 if J1 and J2 match.
C          JMATCH(J)=JPACK*J1+J2 if J1,...,J2 match. Used for multiple
C          initial partons.
C          JMATCH(J)=0 for initial jet partons
C
C          Include W+- and Z0 radiation.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
C
      INTEGER J,NJMIN,JPRNT,JI1,JI2,NJI,JI,NJ1,NJ2,L,K,NPTLV1,IFAIL,J0
      REAL AM0,AM1,AM2,RANF,AMSUM,PCM2,POLD2,RATIO,PSUM,P12CM,E0,P0,Z1,
     $E1MAX,P1MAX,ZMAX,E1MIN,P1MIN,ZMIN,ZEP,E1,P1,CTHCMZ,Z2,E2MAX,P2MAX,
     $E2MIN,P2MIN,P2,E2,CTHCM,STHCM,PHICM,CPHICM,SPHICM,PT0,CTH0,STH0,
     $CPHI0,SPHI0,SGN,BP,ZLIM,ZLIM1
      DIMENSION PSUM(5)
      DATA PSUM/5*0./
C
C          (0) Evolve initial parton masses.
C
      DO 100 J=NJMIN,NJSET
        J1=J
        J2=JMATCH(J)
        IF(J2.GT.JPACK) GO TO 150
        IF(J2.LE.J1) GO TO 100
C          Two partons
        IF(JDCAY(J1).EQ.-1) CALL QCDT(J1)
        IF(JDCAY(J2).EQ.-1) CALL QCDT(J2)
        JPRNT=MOD(JORIG(J),JPACK)
        IF(JPRNT.EQ.0) THEN
          AM0=PJSET(4,J1)+PJSET(4,J2)
        ELSE
          AM0=PJSET(5,JPRNT)
        ENDIF
110     AM1=PJSET(5,J1)
        AM2=PJSET(5,J2)
        IF(AM0.LE.AM1+AM2) THEN
          J3=J1
          IF(RANF().GT..5) J3=J2
          IF(JDCAY(J3).EQ.-1) CALL QCDT(J3)
          GO TO 110
        ENDIF
        GO TO 100
C          More than two partons
150     JI1=JMATCH(J)/JPACK
        IF(J.NE.JI1) GO TO 100
        JI2=JMATCH(J)-JPACK*JI1
        NJI=JI2-JI1+1
        AM0=0.
        AMSUM=0.
        DO 160 JI=JI1,JI2
          IF(JDCAY(JI).EQ.-1) CALL QCDT(JI)
          AM0=AM0+PJSET(4,JI)
          AMSUM=AMSUM+PJSET(5,JI)
160     CONTINUE
170     IF(AM0.LT.AMSUM) THEN
          J3=NJI*RANF()+JI1
          AMSUM=AMSUM-PJSET(5,J3)
          IF(JDCAY(J3).EQ.-1) CALL QCDT(J3)
          AMSUM=AMSUM+PJSET(5,J3)
          GO TO 170
        ENDIF
100   CONTINUE
C
C          (1) Loop over active partons
C
      NJ1=NJMIN
1     NJ2=NJSET
      DO 200 J=NJ1,NJ2
        J1=J
        J2=JMATCH(J1)
        NJI=2
        IF(J2.LE.J1) GO TO 200
C
C          (2) Solve kinematics.
C
C          Initial partons--keep directions fixed.
210     IF(MOD(JORIG(J),JPACK).NE.0) GO TO 230
        IF(JMATCH(J).GT.JPACK) GO TO 400
        AM0=PJSET(4,J1)+PJSET(4,J2)
        AM1=PJSET(5,J1)
        AM2=PJSET(5,J2)
        PJSET(4,J1)=(AM0**2+AM1**2-AM2**2)/(2*AM0)
        PJSET(4,J2)=(AM0**2+AM2**2-AM1**2)/(2*AM0)
        PCM2=((AM0**2-AM1**2-AM2**2)**2-(2*AM1*AM2)**2)/(4*AM0**2)
        DO 220 L=1,2
          POLD2=PJSET(1,JJ(L))**2+PJSET(2,JJ(L))**2+PJSET(3,JJ(L))**2
          RATIO=SQRT(PCM2/POLD2)
          DO 225 K=1,3
225       PJSET(K,JJ(L))=RATIO*PJSET(K,JJ(L))
220     CONTINUE
        GO TO 300
C
C          NJI.LE.5 initial partons
400     CONTINUE
        JI1=JMATCH(J)/JPACK
        IF(J.NE.JI1) GO TO 200
        JI2=JMATCH(J)-JPACK*JI1
        NJI=JI2-JI1+1
        AM0=0.
        DO 410 JI=JI1,JI2
          AM0=AM0+PJSET(4,JI)
          JJ(JI-JI1+1)=JI
          PJSET(4,JI)=SQRT(PJSET(1,JI)**2+PJSET(2,JI)**2+PJSET(3,JI)**2
     1    +PJSET(5,JI)**2)
          DO 420 K=1,5
420       PPTCL(K,NPTCL+JI-JI1+1)=PJSET(K,JI)
410     CONTINUE
        PSUM(4)=AM0
        PSUM(5)=PSUM(4)
        NPTLV1=NPTCL
        CALL RESCAL(NPTLV1+1,NPTLV1+NJI,PSUM,IFAIL)
        DO 430 JI=JI1,JI2
        DO 430 K=1,5
          PJSET(K,JI)=PPTCL(K,NPTCL+JI-JI1+1)
430     CONTINUE
        GO TO 300
C
C          Solve kinematics for general partons.
C
230     J0=MOD(JORIG(J),JPACK)
        AM0=PJSET(5,J0)
        AM1=PJSET(5,J1)
        AM2=PJSET(5,J2)
        E1CM=(AM0**2+AM1**2-AM2**2)/(2*AM0)
        E2CM=(AM0**2+AM2**2-AM1**2)/(2*AM0)
        P12CM=SQRT((AM0**2-AM1**2-AM2**2)**2-(2*AM1*AM2)**2)/(2*AM0)
        NJI=2
C          Determine E1, P1, and COS(THCM) from Z(J0).
C          Occasionally COS(TH)>1.  If so then reset Z.
        E0=PJSET(4,J0)
        P0=SQRT(PJSET(1,J0)**2+PJSET(2,J0)**2+PJSET(3,J0)**2)
        Z1=ZZC(J0)
        IF(Z1.GT.0.5) THEN
          E1MAX=(E0*E1CM+P0*P12CM)/AM0
          P1MAX=(P0*E1CM+E0*P12CM)/AM0
          ZMAX=(E1MAX+P1MAX)/(E0+P0)
          E1MIN=(E0*E1CM-P0*P12CM)/AM0
          P1MIN=(P0*E1CM-E0*P12CM)/AM0
          P1MIN=ABS(P1MIN)
          ZMIN=(E1MIN+P1MIN)/(E0+P0)
          IF(Z1.LT.ZMIN.OR.Z1.GT.ZMAX) Z1=ZMIN+Z1*(ZMAX-ZMIN)
          ZZC(J0)=Z1
          ZEP=Z1*(E0+P0)
          P1=(ZEP**2-AM1**2)/(2.*ZEP)
          E1=(ZEP**2+AM1**2)/(2.*ZEP)
          CTHCM=(E1*AM0-E0*E1CM)/(P0*P12CM)
        ELSE
          Z2=1.-Z1
          E2MAX=(E0*E2CM+P0*P12CM)/AM0
          P2MAX=(P0*E2CM+E0*P12CM)/AM0
          ZMAX=(E2MAX+P2MAX)/(E0+P0)
          E2MIN=(E0*E2CM-P0*P12CM)/AM0
          P2MIN=(P0*E2CM-E0*P12CM)/AM0
          P2MIN=ABS(P2MIN)
          ZMIN=(E2MIN+P2MIN)/(E0+P0)
          IF(Z2.LT.ZMIN.OR.Z2.GT.ZMAX) Z2=ZMIN+Z2*(ZMAX-ZMIN)
          ZZC(J0)=Z2
          ZEP=Z2*(E0+P0)
          P2=(ZEP**2-AM2**2)/(2.*ZEP)
          E2=(ZEP**2+AM2**2)/(2.*ZEP)
          CTHCM=-(E2*AM0-E0*E2CM)/(P0*P12CM)
        ENDIF
C          Avoid disaster
        IF(ABS(CTHCM).GT.1.) CTHCM=SIGN(RANF(),CTHCM)
        STHCM=SQRT(1.-CTHCM**2)
        PHICM=2*PI*RANF()
        CPHICM=COS(PHICM)
        SPHICM=SIN(PHICM)
C
C          Construct cm momenta.
        PT0=SQRT(PJSET(1,J0)**2+PJSET(2,J0)**2)
        CTH0=PJSET(3,J0)/P0
        STH0=PT0/P0
        CPHI0=PJSET(1,J0)/PT0
        SPHI0=PJSET(2,J0)/PT0
        P1CM(1)=P12CM*(CPHI0*(CTH0*CPHICM*STHCM+STH0*CTHCM)
     1  -SPHI0*SPHICM*STHCM)
        P1CM(2)=P12CM*(SPHI0*(CTH0*CPHICM*STHCM+STH0*CTHCM)
     1  +CPHI0*SPHICM*STHCM)
        P1CM(3)=P12CM*(-STH0*CPHICM*STHCM+CTH0*CTHCM)
C          Boost with P0 to get lab momenta
        DO 240 L=1,2
          SGN=3-2*L
          BP=0
          DO 241 K=1,3
241       BP=BP+PJSET(K,J0)*SGN*P1CM(K)
          BP=BP/AM0
          PJSET(4,JJ(L))=PJSET(4,J0)*EE(L)/PJSET(5,J0)+BP
          DO 242 K=1,3
242       PJSET(K,JJ(L))=SGN*P1CM(K)+PJSET(K,J0)*EE(L)/PJSET(5,J0)
     1    +PJSET(K,J0)*BP/(PJSET(4,J0)+PJSET(5,J0))
240     CONTINUE
C
C          (3) Pick Z and decay partons. Check.
C
300     CONTINUE
        TNEW=.FALSE.
        DO 310 L=1,NJI
          IF(JDCAY(JJ(L)).GE.0) GO TO 310
          IF(NJSET+2.GT.MXJSET) GO TO 9999
          CALL QCDZ(JJ(L))
          CALL QCDT(NJSET+1)
          CALL QCDT(NJSET+2)
C
C          Check whether masses allowed.
          AM0=PJSET(5,JJ(L))
          AM1=PJSET(5,NJSET+1)
          AM2=PJSET(5,NJSET+2)
          IF(AM1+AM2.GE.AM0) GO TO 320
C
C          Check whether Z allowed.
          E1CM=(AM0**2+AM1**2-AM2**2)/(2*AM0)
          E2CM=(AM0**2+AM2**2-AM1**2)/(2.*AM0)
          P12CM=SQRT((AM0**2-AM1**2-AM2**2)**2-(2*AM1*AM2)**2)/(2*AM0)
          E0=PJSET(4,JJ(L))
          P0=SQRT(PJSET(1,JJ(L))**2+PJSET(2,JJ(L))**2+PJSET(3,JJ(L))**2)
          IF(ZZC(JJ(L)).GT.0.5) THEN
            ZEP=ZZC(JJ(L))*(E0+P0)
            P1=(ZEP**2-AM1**2)/(2.*ZEP)
            E1=(ZEP**2+AM1**2)/(2.*ZEP)
            CTHCM=(E1*AM0-E0*E1CM)/(P0*P12CM)
            IF((ABS(CTHCM).GE.1..OR.P1.LE.0.).AND.IABS(JTYPE(JJ(L)))
     $      .LT.80) GO TO 320
          ELSE
            ZEP=(1.-ZZC(JJ(L)))*(E0+P0)
            P2=(ZEP**2-AM2**2)/(2.*ZEP)
            E2=(ZEP**2+AM2**2)/(2.*ZEP)
            CTHCM=-(E2*AM0-E0*E2CM)/(P0*P12CM)
            IF((ABS(CTHCM).GE.1..OR.P2.LE.0.).AND.IABS(JTYPE(JJ(L)))
     $      .LT.80) GO TO 320
          ENDIF
C
C          Require Z and 1-Z within kinematic limits.
C
          ZLIM=(AM0/(E0+P0))**2
          ZLIM1=CUTJET/(E0+P0)
          ZLIM=AMAX1(ZLIM,ZLIM1)
          IF((ZZC(JJ(L)).GT.ZLIM.AND.ZZC(JJ(L)).LT.(1.-ZLIM)).OR.
     $    IABS(JTYPE(JJ(L))).GE.80) THEN
C          Add new partons to /JETSET/.
            JDCAY(JJ(L))=JPACK*(NJSET+1)+(NJSET+2)
            NJSET=NJSET+2
            GO TO 310
          ENDIF
C          Discard partons and evolve JJ(L) again.
320       TNEW=.TRUE.
          CALL QCDT(JJ(L))
310     CONTINUE
C
C          (4) Resolve kinematics if any parton mass is changed.
C
        IF(TNEW) GO TO 210
200   CONTINUE
C
C          (5) Iterate entire proceedure.
C
      NJ1=NJ2+1
      IF(NJ1.LE.NJSET) GO TO 1
      RETURN
C
C          Error message
C
9999  CALL PRTEVT(0)
      WRITE(ITLIS,10) NJSET
10    FORMAT(//' ERROR IN QCDJET...NJSET > ',I4)
      RETURN
      END
CDECK  ID>, QCDT.   
      SUBROUTINE QCDT(J)
C
C          Auxiliary routine for QCDJET. Calculate ZC and store in
C          ZZC(J).  Generate new mass with ZC and store in PJSET(5,J).
C
C          Must include 1/2 symmetry factor in GAMGG. No fix is needed
C          in QCDZ since GAMGG+2*GAMQQ is used as the normalization.
C
C          Include GM, W+, W-, and Z0 radiation.
C
C          Ver 7.20: Anomalous dimensions were coded incorrectly!
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
C
      REAL AM0,AM1,AM2,AMASS,T0,T1,T2,ZC,B0,GAMEW,GAMQQ,GAMGG,GAM,GAMZC
      REAL AM1W,AM2W,T1W,T2W,TERM,GB,PROB,RANF,RND,POW,AMNEW,AMOLD
      REAL POWEW
      INTEGER J,JTLV1,NF,IQ,JTABS,IW,JT0,JT1,IFL1,I
      INTEGER JWTYPE(4)
      DATA JWTYPE/10,80,-80,90/
C
C          Set ZC = 0 and return for W+- or Z0
C
      JTABS=IABS(JTYPE(J))
      IF(JTABS.GE.80.AND.JTABS.LE.90) THEN
        ZZC(J)=0.
        RETURN
      ENDIF
C
C          Calculate ZC
C
      AM0=PJSET(5,J)
      JTLV1=JTYPE(J)
      AM1=AMASS(JTLV1)+CUTJET
      AM2=CUTJET
      IF(AM1+AM2.GE.AM0) GO TO 300
      T0=AM0**2
      T1=AM1**2
      T2=AM2**2
      ZC=(T0-T1+T2-SQRT((T0-T1-T2)**2-4*T1*T2))/(2*T0)
      ZZC(J)=ZC
C          Count light fermions
      NF=3
      DO 110 IQ=4,6
      IF(AM0.LT.2*AMASS(IQ)) GO TO 120
      NF=NF+1
110   CONTINUE
120   B0=11.-2.*NF/3.
C
C          Calculate GAMMA(ZC) and GAMEW for quarks
C
      GAMEW=0.
C
C          Initial gluon
      IF(JTABS.EQ.9) THEN
        GAMQQ=(1.-2.*ZC)*(1.-ZC*(1.-ZC))/3.
        GAMGG=12.*ALOG((1.-ZC)/ZC)-9.*(1.-2.*ZC)-6.*GAMQQ
        GAMGG=0.5*GAMGG
        GAM=GAMGG+NF*GAMQQ
C
C          Initial quark
      ELSEIF(JTABS.LT.9) THEN
        GAMZC=2.*ALOG((1-ZC)/ZC)-1.5*(1.-2.*ZC)
        GAM=4./3.*GAMZC
        GAMEW=ALFA/(2.*PI)*AQ(JTABS,1)**2*GAMZC
        IF(AM0.GT.WMASS(4)) THEN
          DO 130 IW=2,4
            JT0=2*IABS(JTYPE(J))
            IF(JTYPE(J).LT.0) JT0=JT0+1
            JT1=MATCH(JT0,IW)
            IF(JT1.EQ.0) GO TO 130
            JT1=MATCH(JT1,4)
            IFL1=JT1/2
            AM1W=AMASS(IFL1)
            AM2W=AMASS(JWTYPE(IW))
            IF(AM1W+AM2W.GE.AM0) GO TO 130
            T1W=AM1W**2
            T2W=AM2W**2
            ZC=(T0-T1W+T2W-SQRT((T0-T1W-T2W)**2-4*T1W*T2W))/(2*T0)
            GAMZC=2.*ALOG((1-ZC)/ZC)-1.5*(1.-2.*ZC)
            TERM=(AQ(JTABS,IW)**2+BQ(JTABS,IW)**2)*GAMZC
            GAMEW=GAMEW+ALFA/(2.*PI)*TERM
130       CONTINUE
        ENDIF
C
C          Initial diquark
      ELSEIF(MOD(JTABS,100).EQ.0) THEN
        GAM=8./3.*ALOG((1-ZC)/ZC)-2.*(1.-2.*ZC)
C
C          Initial gluino
      ELSEIF(JTABS.EQ.29) THEN
        GAM=6.*ALOG((1.-ZC)/ZC)-9./2.*(1.-2.*ZC)
C
C          Initial squark
      ELSEIF(JTABS.GT.20.AND.JTABS.LT.29) THEN
        GAM = 8./3.*(ALOG((1.-ZC)/ZC)-(1.-2.*ZC))
      ENDIF
C
C          Generate new mass
C
      GB=2*GAM/B0
      PROB=(ALOG(AM1/ALAM)/ALOG(AM0/ALAM))**GB
      PROB=PROB*(AM1/AM0)**(2.*GAMEW)
      IF(PROB.GT.RANF()) GO TO 300
      RND=RANF()
      POW=(1.-(1.-PROB)*RND)**(1./GB)
      AMNEW=ALAM*(AM0/ALAM)**POW
C          For quark, add effect of GM, W+-, Z0 radiation
      IF(IABS(JTYPE(J)).LT.9) THEN
        DO 200 I=1,NTRIES
          AMOLD=AMNEW
          POWEW=POW/((AMOLD/AM0)**(2.*GAMEW))**(1./GB)
          AMNEW=ALAM*(AM0/ALAM)**POWEW
          IF(ABS(AMNEW-AMOLD).LT.0.001*AMOLD) GO TO 210
200    CONTINUE
      ENDIF
210   IF(AMNEW.LE.AM1) GO TO 300
      PJSET(5,J)=AMNEW
      RETURN
C
C          Final parton -- set mass to physical value
C
300   PJSET(5,J)=AM1-CUTJET
      JDCAY(J)=0
      RETURN
      END
CDECK  ID>, QCDZ.   
      SUBROUTINE QCDZ(J)
C
C          Auxiliary routine for QCDJET.  Generate Z for parton J and
C          store in ZZC(J). Add possible new partons to /JETSET/.
C
C          Include GM, W+, W-, and Z0 radiation.
C
C          Ver 7.20: Anomalous dimensions were coded incorrectly!
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/JWORK/ZZC(MXJSET),JMATCH(MXJSET),TNEW,P1CM(4),
     1J1,J2,J3,J4,J5,E1CM,E2CM,E3CM,E4CM,E5CM
      SAVE /JWORK/
      LOGICAL TNEW
      EQUIVALENCE (J1,JJ(1)),(E1CM,EE(1))
      INTEGER   JMATCH,J1,J2,J3,J4,J5,JJ(5)
      REAL      ZZC,P1CM,E1CM,E2CM,E3CM,E4CM,E5CM,EE(5)
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
C
      REAL PQQ,PGQ,PQG,PGG,Z,PGSGS,PQSQS,ALFAS,QQ,AM0,ZC,AMASS
      REAL GAMQQ,GAMGG,PROBG,PROBQ,RND,RANF,ZGEN,GZ
      REAL GAMZC,GAMSUM,AM1W,AM2W,T1W,T2W,ZCW,T0,GAMZCW,TERM,SUM
      REAL SUMBR,BRMODE,TRY,HELPL,HELMN,HEL,PZ
      INTEGER NF,J,JTABS,IQ,IFL,IW,JT0,JT1,IFL1,IFL2
      INTEGER IWTYPE,JET,JW,IQ1,IQ2,JPAR,IFLPAR,NJ1,NJ2,IDABS1,IDABS2
      REAL GAMSAV(5),ZCSAV(5),BRANCH(25)
      INTEGER JSAV(5),LISTW(5),LISTJ(25)
      DATA LISTW/9,10,80,-80,90/
      DATA LISTJ/9,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,
     $11,-11,12,-12,13,-13,14,-14,15,-15,16,-16/
C
C          Altarelli-Parisi functions.
      PQQ(Z)=4*(1+Z**2)/(3*(1-Z))
      PGQ(Z)=.5*(Z**2+(1-Z)**2)
      PGG(Z)=6*(1-Z*(1-Z))**2/(Z*(1-Z))
      PGSGS(Z)=3.*(1.+Z**2)/(1.-Z)
      PQSQS(Z)=8./3.*Z/(1.-Z)
      ALFAS(QQ)=12.*PI/((33.-2.*NF)*ALOG(QQ/ALAM2))
C
C          Initialize.
C
      AM0=PJSET(5,J)
      ZC=ZZC(J)
      JTABS=IABS(JTYPE(J))
      NF=3
      DO 110 IQ=4,6
        IF(AM0.LT.2*AMASS(IQ)) GO TO 120
        NF=NF+1
110   CONTINUE
120   CONTINUE
      NJ1=NJSET+1
      NJ2=NJSET+2
C
C          Initial gluon
C
      IF (JTABS.EQ.9) THEN
        GAMQQ=(1-2*ZC)*(1-ZC*(1-ZC))/3.
        GAMGG=12*ALOG((1-ZC)/ZC)-9*(1-2*ZC)-6*GAMQQ
        PROBG=GAMGG/(GAMGG+2*NF*GAMQQ)
        PROBQ=GAMQQ/(GAMGG+2*NF*GAMQQ)
        RND=RANF()
C          GL--->GL+GL
        IF(PROBG.GT.RND) THEN
130       ZGEN=(ZC/(1-ZC))**(1-2*RANF())
          Z=ZGEN/(1.+ZGEN)
          GZ=6./(Z*(1.-Z))
          IF(PGG(Z).LT.GZ*RANF()) GO TO 130
          JTYPE(NJ1)=9
          JTYPE(NJ2)=9
          ZZC(J)=Z
C          GL--->QK+QB
        ELSE
140       Z=RANF()
          IF(PGQ(Z).LT.0.5*RANF()) GO TO 140
          IFL=(RND-PROBG)/PROBQ+1.
          IF(IFL.GT.NF) IFL=NF-IFL
          JTYPE(NJ1)=IFL
          JTYPE(NJ2)=-IFL
          ZZC(J)=Z
        ENDIF
C
C          Initial quark - may radiate GL, GM, W+-, Z0
C
      ELSEIF(JTABS.LT.9) THEN
C          Gluon
        GAMZC=2.*ALOG((1-ZC)/ZC)-1.5*(1.-2.*ZC)
        GAMSAV(1)=4./3.*ALFAS(AM0**2)*GAMZC
        ZCSAV(1)=ZC
        JSAV(1)=JTYPE(J)
C          Photon
        GAMSAV(2)=ALFA*AQ(JTABS,1)**2*GAMZC
        ZCSAV(2)=ZC
        GAMSUM=GAMSAV(1)+GAMSAV(2)
        JSAV(2)=JTYPE(J)
C          W+- and Z0
        IF(AM0.GT.WMASS(4)) THEN
          DO 200 IW=2,4
            GAMSAV(IW+1)=0.
            ZCSAV(IW+1)=.5
            JSAV(IW+1)=0
            JT0=2*IABS(JTYPE(J))
            IF(JTYPE(J).LT.0) JT0=JT0+1
            JT1=MATCH(JT0,IW)
            IF(JT1.EQ.0) GO TO 200
            JT1=MATCH(JT1,4)
            IFL1=JT1/2
            AM1W=AMASS(IFL1)
            AM2W=AMASS(LISTW(IW+1))
            IF(AM1W+AM2W.GE.AM0) GO TO 200
            T0=AM0**2
            T1W=AM1W**2
            T2W=AM2W**2
            ZCW=(T0-T1W+T2W-SQRT((T0-T1W-T2W)**2-4*T1W*T2W))/(2*T0)
            GAMZCW=2.*ALOG((1-ZCW)/ZCW)-2.*(1.-2.*ZCW)
            TERM=(AQ(JTABS,IW)**2+BQ(JTABS,IW)**2)*ALFA*GAMZCW
            GAMSAV(IW+1)=TERM
            ZCSAV(IW+1)=ZCW
            JSAV(IW+1)=IFL1*ISIGN(1,JTYPE(J))
            GAMSUM=GAMSUM+TERM
200       CONTINUE
        ELSE
          DO 210 IW=2,4
            GAMSAV(IW+1)=0.
            ZCSAV(IW+1)=.5
            JSAV(IW+1)=0
210       CONTINUE
        ENDIF
C          Select decay mode
        RND=RANF()
        SUM=0.
        DO 220 IW=1,5
          IWTYPE=IW
          SUM=SUM+GAMSAV(IW)/GAMSUM
          IF(RND.LT.SUM) GO TO 230
220     CONTINUE
C          Generate Z
230     CONTINUE
        Z=1-(ZC/(1-ZC))**RANF()*(1-ZC)
        GZ=8./(3.*(1-Z))
        IF(PQQ(Z).LT.GZ*RANF()) GO TO 230
        IF(Z.LT.ZCSAV(IWTYPE).OR.Z.GT.1.-ZCSAV(IWTYPE)) GO TO 230
        JTYPE(NJ1)=JSAV(IWTYPE)
        JTYPE(NJ2)=LISTW(IWTYPE)
        ZZC(J)=Z
C
C          Initial diquark
C
      ELSEIF(MOD(JTABS,100).EQ.0) THEN
300     CONTINUE
        Z=1-(ZC/(1-ZC))**RANF()*(1-ZC)
        GZ=8./(3.*(1-Z))
        IF(PQQ(Z).LT.GZ*RANF()) GO TO 300
        JTYPE(NJ1)=JTYPE(J)
        JTYPE(NJ2)=9
        ZZC(J)=Z
C
C          Initial gluino
C
       ELSEIF (JTABS.EQ.29) THEN
400      Z=1.-(ZC/(1.-ZC))**RANF()*(1.-ZC)
         GZ=6./(1.-Z)
         IF(PGSGS(Z) .LT. GZ*RANF()) GOTO 400
         JTYPE(NJ1)=JTYPE(J)
         JTYPE(NJ2)=9
         ZZC(J)=Z
C
C          Initial squark
C
      ELSEIF(JTABS.GT.20.AND.JTABS.LT.29) THEN
500     CONTINUE
        Z=1-(ZC/(1-ZC))**RANF()*(1-ZC)
        GZ=8./(3.*(1-Z))
        IF(PQSQS(Z).LT.GZ*RANF()) GO TO 500
        JTYPE(NJ1)=JTYPE(J)
        JTYPE(NJ2)=9
        ZZC(J)=Z
C
C          Initial W+, W-, or Z0
C
      ELSEIF(JTABS.EQ.80.OR.JTABS.EQ.90) THEN
C          Select decay mode
        IF(JTYPE(J).EQ.+80) JW=2
        IF(JTYPE(J).EQ.-80) JW=3
        IF(JTYPE(J).EQ.+90) JW=4
        TRY=RANF()
        DO 610 IQ=2,25
        IF(TRY.LT.CUMWBR(IQ,JW-1)) THEN
          IQ1=IQ
          IQ2=MATCH(IQ,JW)
          GO TO 620
        ENDIF
610     CONTINUE
620     JTYPE(NJ1)=LISTJ(IQ1)
        JTYPE(NJ2)=LISTJ(IQ2)
C          Select W helicity
        JPAR=MOD(JORIG(J),JPACK)
        IFLPAR=IABS(JTYPE(JPAR))
        HELPL=(AQ(IFLPAR,JW)-BQ(IFLPAR,JW))**2
        HELMN=(AQ(IFLPAR,JW)+BQ(IFLPAR,JW))**2
        IF(RANF()*(HELPL+HELMN).LT.HELMN) THEN
          HEL=-ISIGN(1,JTYPE(NJ1))
        ELSE
          HEL=+ISIGN(1,JTYPE(NJ1))
        ENDIF
630     Z=RANF()
        PZ=(1.+HEL*(2.*Z-1.))**2
        IF(PZ.LT.4.*RANF()) GO TO 630
        ZZC(J)=Z
      ENDIF
C
C          Set masses and flags.
C
      JET=IABS(JORIG(J))/JPACK
      JORIG(NJ1)=JPACK*JET+J
      JORIG(NJ2)=JPACK*JET+J
      IDABS1=IABS(JTYPE(NJ1))
      IDABS2=IABS(JTYPE(NJ2))
      JMATCH(NJ1)=NJ2
      JMATCH(NJ2)=NJ1
C          JDCAY=-1 implies further decay
      IF(IDABS1.LE.9.OR.(IDABS1.GT.20.AND.IDABS1.LT.30.).OR.
     $MOD(IDABS1,100).EQ.0) THEN
        PJSET(5,NJ1)=Z*AM0
        JDCAY(NJ1)=-1
      ELSEIF(IDABS1.GE.80.OR.IDABS1.LE.90) THEN
        PJSET(5,NJ1)=AMASS(IDABS1)
        JDCAY(NJ1)=-1
      ELSE
        PJSET(5,NJ1)=AMASS(IDABS1)
        JDCAY(NJ1)=0
      ENDIF
      IF(IDABS2.LE.9.OR.(IDABS2.GT.20.AND.IDABS2.LT.30.).OR.
     $MOD(IDABS2,100).EQ.0) THEN
        PJSET(5,NJ2)=(1.-Z)*AM0
        JDCAY(NJ2)=-1
      ELSEIF(IDABS2.EQ.80.OR.IDABS2.EQ.90) THEN
        PJSET(5,NJ2)=AMASS(IDABS2)
        JDCAY(NJ2)=-1
      ELSE
        PJSET(5,NJ2)=AMASS(IDABS2)
        JDCAY(NJ2)=0
      ENDIF
      RETURN
      END
CDECK  ID>, QFUNC.  
      SUBROUTINE QFUNC
C
C          Find approximate QMW and QTW dependence for DRELLYAN.
C          Set up /WGEN/ to generate QMW and QTW. Fit is
C          Non-resonant:
C            SIGMA=ANORM/(Q2/QMAX**2)**QPOW/(PT**2+RNU2)**PTPOW
C          Resonant:
C            SIGMA=ANORM/((Q**2-M**2)**2+M**2*GAM**2)
C          with appropriate M and GAM.
C
C          Ver. 6.23: Remove extension of region 1 under region 2
C                     to avoid discontinuity in d(sigma)/d(M)
C          Ver. 6.40: Scale Q**2 fit by QMAX**2 to avoid underflow
C                     problems. Must also change DRLLYN
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/DYPAR/FLW,RNU2(3),ANORM(3),QPOW(3),PTPOW(3)
      SAVE /DYPAR/
      LOGICAL FLW
      REAL      RNU2,ANORM,QPOW,PTPOW
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/WGEN/PTGN(3,3),QGEN(3,3),PTSEL(3),QSEL(3),SIGSL(3),NKL,NKH
     1,EMSQ,EMGAM,KSEL,QSELWT(3)
      SAVE /WGEN/
      INTEGER   NKL,NKH,KSEL
      REAL      PTGN,QGEN,PTSEL,QSEL,SIGSL,EMSQ,EMGAM,QSELWT
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
      COMMON/TCPAR/TCMRHO,TCGRHO
      SAVE /TCPAR/
      REAL TCMRHO,TCGRHO
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C
      REAL QT2CUT,DPT,QMN,QMX,EM,GAM,DELM,QSTOR,SUMS,DQ,ETAX,ETA,
     $Q2,XI,ALI,SIGSAV,T1,T2,T3,T4,T5,DET,DEVMAX,PTNU,ALPTNU,ALQ2,FIT,
     $DEV,DY3,DYW,SIG00,FACTOR,FAC1,C1,B1,SUM,AL1,QMAX2
      INTEGER NDIV1,NDIV2,K,I,NQS,J,N,NDIV3,NDIV4,IW,I3,II
      DIMENSION SUMS(9)
      DIMENSION QMN(3),QMX(3)
      DIMENSION SIGSAV(20,20)
C
C          QT cutoff function
      QT2CUT(QMW)=CUTOFF*QMW**CUTPOW
C
C          Entry
C
      IF(FIXQM) THEN
        NDIV1=1
      ELSE
        NDIV1=20
      ENDIF
      IF(FIXQT) THEN
        NDIV2=1
      ELSE
        NDIV2=20
      ENDIF
C
      DPT=(PTMAX(3)-PTMIN(3))/NDIV2
      YJ(3)=0
      YW=0.
      CTH(3)=0.
      STH(3)=1.
      IF(GODY(4)) JWTYP=4
      NKL=1
      NKH=1
      QMN(1)=QMIN
      QMX(1)=QMAX
      QMAX2=QMAX**2
C
C          Define resonance region
C
      IF(KEYS(3)) THEN
        IF(JWTYP.EQ.1) GO TO 99
        EM=WMASS(JWTYP)
        GAM=WGAM(JWTYP)
        DELM=20.
      ELSEIF(KEYS(7)) THEN
        EM=HMASS
        GAM=HGAM
        DELM=.201357*EM
        DELM=AMIN1(DELM,1.5*HGAM)
        DELM=AMAX1(DELM,.1*EM)
      ELSEIF(KEYS(9)) THEN
        EM=TCMRHO
        GAM=TCGRHO
        DELM=.201357*EM
        DELM=AMIN1(DELM,1.5*TCGRHO)
        DELM=AMAX1(DELM,.1*EM)
      ENDIF
      EMGAM=EM*GAM
      EMSQ=EM**2
C          Region limits
      QMN(2)=EM-DELM
      QMN(3)=EM+DELM
      QMX(1)=QMN(2)
      QMX(2)=QMN(3)
      NKL=1
      NKH=3
      IF(QMAX.LE.QMN(3)) NKH=2
      IF(QMAX.LE.QMN(2)) NKH=1
      IF(QMIN.GE.QMN(2)) NKL=2
      IF(QMIN.GE.QMN(3)) NKL=3
      QMX(NKH)=QMAX
      QMN(NKL)=QMIN
   99 CONTINUE
C
C            Fit over regions NKL to NKH
C            Region 1 is below resonance
C            Region 2 is inside resonance
C            Region 3 is above resonance
C            FIT=ANORM/(Q2/QMAX**2)**QPOW/(PT**2+RNU2)**PTPOW
C
      DO 100 K=1,3
        ANORM(K)=0.
        PTPOW(K)=0.
        QPOW(K)=0.
        RNU2(K)=QT2CUT(QMIN)
100   CONTINUE
C
C          Loop over regions
C
      DO 200 K=NKL,NKH
        DO 210 I=1,9
210     SUMS(I)=0
        DQ=(QMX(K)-QMN(K))/NDIV1
        NQS=NDIV1
        DO 220 I=1,NDIV2
          PT(3)=PTMIN(3)+(I-1)*DPT
          QTW=PT(3)
          P(3)=PT(3)
          RNU2(K)=QT2CUT(QMN(K))
          ETAX=PT(3)**2+RNU2(K)
          ETA=ALOG(ETAX)
          DO 230 J=1,NQS
            QMW=QMN(K)+(J-1)*DQ
            Q2=QMW*QMW
            XI=ALOG(Q2/QMAX2)
            SUMS(1)=SUMS(1)+XI
            SUMS(2)=SUMS(2)+ETA
            SUMS(5)=SUMS(5)+ETA*ETA
            SUMS(4)=SUMS(4)+XI**2
            SUMS(7)=SUMS(7)+XI*ETA
C            Cross section
            IF(KEYS(3)) THEN
              CALL SIGDY
            ELSEIF(KEYS(7).AND..NOT.GOMSSM) THEN
              CALL SIGH
            ELSEIF(KEYS(7).AND.GOMSSM) THEN
              CALL SIGHSS
            ELSEIF(KEYS(9)) THEN
              CALL SIGTC
            ENDIF
            IF(SIGMA.EQ.0.) GO TO 999
            AL1=ALOG(SIGMA)
            SIGSAV(I,J)=AL1
            IF(K.EQ.2) AL1=AL1+ALOG((Q2-EM**2)**2+EMGAM**2)
            SUMS(3)=SUMS(3)+AL1
            SUMS(8)=SUMS(8)+AL1*XI
            SUMS(9)=SUMS(9)+AL1*ETA
230         CONTINUE
220      CONTINUE
C
C            Find coefficients minimizing chisq
C
        N=NQS*NDIV2
        T1=N*SUMS(7)-SUMS(1)*SUMS(2)
        T2=N*SUMS(5)-SUMS(2)**2
        T3=N*SUMS(4)-SUMS(1)**2
        T4=N*SUMS(8)-SUMS(1)*SUMS(3)
        T5=N*SUMS(9)-SUMS(2)*SUMS(3)
        IF((FIXQM.OR.K.EQ.2).AND.FIXQT) THEN
          PTPOW(K)=0.
          QPOW(K)=0.
        ELSEIF(FIXQT) THEN
          PTPOW(K)=0.
          QPOW(K)=-T4/T3
        ELSEIF(FIXQM.OR.K.EQ.2) THEN
          PTPOW(K)=-T5/T2
          QPOW(K)=0.
        ELSE
          DET=T1**2-T2*T3
          PTPOW(K)=(T5*T3-T4*T1)/DET
          QPOW(K)=(T4*T2-T1*T5)/DET
        ENDIF
        ANORM(K)=(QPOW(K)*SUMS(1)+PTPOW(K)*SUMS(2)+SUMS(3))/N
C
C          Shift fit to obtain envelope for SIGDY
C
        DEVMAX=0.
        DO 240 I=1,NDIV2
          PT(3)=PTMIN(3)+(I-1)*DPT
          PTNU=PT(3)**2+RNU2(K)
          DO 250 J=1,NDIV1
            QMW=QMN(K)+(J-1)*DQ
            Q2=QMW**2
            ALPTNU=ALOG(PTNU)
            ALQ2=ALOG(Q2/QMAX2)
            IF(K.EQ.2) THEN
              FIT=EXP(ANORM(K)-PTPOW(K)*ALPTNU
     $        -ALOG((Q2-EM**2)**2+EMGAM**2))
            ELSE
              FIT=EXP(ANORM(K)-PTPOW(K)*ALPTNU-QPOW(K)*ALQ2)
            ENDIF
            DEV=SIGSAV(I,J)-ALOG(FIT)
            IF(DEV.GT.DEVMAX) DEVMAX=DEV
250       CONTINUE
240     CONTINUE
        ANORM(K)=ANORM(K)+DEVMAX
200   CONTINUE
C
C          Shift fit to obtain envelope in YW
      NDIV3=20
      IF(STDDY) THEN
        NDIV4=1
        DY3=0.
      ELSE
        NDIV4=20
        DY3=(YJMAX(3)-YJMIN(3))/(NDIV4-1)
      ENDIF
      DYW=(YWMAX-YWMIN)/(NDIV3-1)
C
      DO 300 K=NKL,NKH
        QMW=QMN(K)
        Q2=QMW**2
        QTW=QTMIN
        PT(3)=QTW
        P(3)=PT(3)
        YW=0.
        YJ(3)=0.
        CTH(3)=0.
        STH(3)=1.
        IF(KEYS(3)) THEN
          CALL SIGDY
        ELSEIF(KEYS(7).AND..NOT.GOMSSM) THEN
          CALL SIGH
        ELSEIF(KEYS(7).AND.GOMSSM) THEN
          CALL SIGHSS
        ELSEIF(KEYS(9)) THEN
          CALL SIGTC
        ENDIF
        SIG00=SIGMA
        FACTOR=1.
        DO 310 IW=1,NDIV3
          YW=YWMIN+(IW-1)*DYW
          DO 320 I3=1,NDIV4
            IF(.NOT.STDDY) THEN
              YJ(3)=YJMIN(3)+(I3-1)*DY3
              CTH(3)=TANH(YJ(3))
              STH(3)=SQRT(1.-CTH(3)**2)
              IF(STH(3).EQ.0.) GO TO 320
              TH(3)=ACOS(CTH(3))
              P(3)=PT(3)/STH(3)
            ENDIF
            IF(KEYS(3)) THEN
              CALL SIGDY
            ELSEIF(KEYS(7).AND..NOT.GOMSSM) THEN
              CALL SIGH
            ELSEIF(KEYS(7).AND.GOMSSM) THEN
              CALL SIGHSS
            ELSEIF(KEYS(9)) THEN
              CALL SIGTC
            ENDIF
            FAC1=SIGMA/SIG00
            FACTOR=AMAX1(FACTOR,FAC1)
320       CONTINUE
310     CONTINUE
        ANORM(K)=ALOG(FACTOR)+ANORM(K)
300   CONTINUE
C
C          Set up generating constants for PT**2 and QMW**2
C
      DO 400 K=NKL,NKH
        C1=1.-PTPOW(K)
        PTGN(1,K)=(PTMIN(3)**2+RNU2(K))**C1
        PTGN(2,K)=(PTMAX(3)**2+RNU2(K))**C1-PTGN(1,K)
        PTGN(3,K)=1./C1
        IF(K.EQ.2) THEN
          QGEN(1,2)=ATAN((QMN(2)**2-EMSQ)/EMGAM)
          QGEN(2,2)=ATAN((QMX(2)**2-EMSQ)/EMGAM)-QGEN(1,2)
          QGEN(3,2)=EMGAM
        ELSE
          B1=1.-QPOW(K)
          QGEN(1,K)=(QMN(K)/QMAX)**(2.*B1)
          QGEN(2,K)=(QMX(K)/QMAX)**(2.*B1)-QGEN(1,K)
          QGEN(3,K)=1./B1
        ENDIF
400   CONTINUE
C
      DO 410 K=1,3
410   QSELWT(K)=0.
      SUM=0.
C
      DO 420 K=NKL,NKH
        QSELWT(K)=1.
        IF(.NOT.FIXQT) QSELWT(K)=QSELWT(K)*PTGN(2,K)*PTGN(3,K)
        IF(.NOT.FIXQM) THEN
          IF(K.EQ.2) THEN
            QSELWT(K)=QSELWT(K)*QGEN(2,K)/EMGAM
          ELSE
            QSELWT(K)=QMAX**2*QSELWT(K)*QGEN(2,K)*QGEN(3,K)
          ENDIF
        ENDIF
        QSELWT(K)=EXP(ALOG(QSELWT(K))+ANORM(K))
        SUM=SUM+QSELWT(K)
420   CONTINUE
C
      DO 430 K=1,3
        QSELWT(K)=QSELWT(K)/SUM
430   CONTINUE
C
C          Write fit to output
C
      WRITE(ITLIS,4301)
4301  FORMAT(//10X,' QT AND Q FIRST GENERATED BY--'/)
      DO 440 K=NKL,NKH
        WRITE(ITLIS,4402) K,QMN(K),QMX(K)
4402    FORMAT(//5X,' REGION',I2,5X,E11.4,' < Q < ',E11.5)
        WRITE(ITLIS,4403) (PTGN(II,K),II=1,3),RNU2(K)
4403    FORMAT(/' QT**2 = (',E11.4,' + ',E11.4,' * RANF) ** ',E11.4,
     $  ' - ',E11.4)
        IF(K.NE.2) THEN
          WRITE(ITLIS,4404) QMAX2,(QGEN(II,K),II=1,3)
4404      FORMAT(/' Q**2  = ',E11.4,' * (',E11.4,' + ',E11.4,
     $    ' * RANF) ** ',E11.4)
        ELSE
          WRITE(ITLIS,4505) QGEN(3,K),QGEN(1,K),QGEN(2,K),EMSQ
4505       FORMAT(/' Q**2  = ',E11.4,' * TAN(',E11.4,' + ',E11.4,
     $    ' * RANF) + ',E11.4)
        ENDIF
        WRITE(ITLIS,4506) QSELWT(K)
4506    FORMAT(/' WEIGHT = ',E11.4)
440   CONTINUE
C
C          Set fixed limits if any
C
      IF(FIXQT) THEN
        PTMAX(3)=PTMIN(3)
        PT(3)=PTMIN(3)
        QTW=PT(3)
      ENDIF
      IF(FIXQM) THEN
        QMAX=QMIN
        QMW=QMIN
      ENDIF
      RETURN
C
C          Fit fails if SIGMA=0 in allowed range
C
999   WRITE(ITLIS,9990) QMW,QTW
9990  FORMAT(//' ERROR IN QFUNC...SIGMA=0 FOR QMW = ',E12.4,' , QTW = ',
     1E12.4/' CHECK YOUR LIMITS')
      STOP 99
      END
CDECK  ID>, RANF.   
          REAL FUNCTION RANF()
C
C         KERNLIB ROUTINE G900 IN CERN PROGRAM LIBRARY
C
          DOUBLE PRECISION    DRANF,    G900GT,   G900ST
          DOUBLE PRECISION    DS(2),    DM(2),    DSEED
          DOUBLE PRECISION    DX24,     DX48
          DOUBLE PRECISION    DL,       DC,       DU,       DR
          LOGICAL             SINGLE
          DATA      DS     /  1665 1885.D0, 286 8876.D0  /
          DATA      DM     /  1518 4245.D0, 265 1554.D0  /
          DATA      DX24   /  1677 7216.D0  /
          DATA      DX48   /  281 4749 7671 0656.D0  /
          SINGLE  =  .TRUE.
          GOTO 10
          ENTRY DRANF()
          SINGLE  =  .FALSE.
  10      DL  =  DS(1) * DM(1)
          DC  =  DINT(DL/DX24)
          DL  =  DL - DC*DX24
          DU  =  DS(1)*DM(2) + DS(2)*DM(1) + DC
          DS(2)  =  DU - DINT(DU/DX24)*DX24
          DS(1)  =  DL
          DR     =  (DS(2)*DX24 + DS(1)) / DX48
          IF(SINGLE)  THEN
             RANF  =  SNGL(DR)
          ELSE
             DRANF  =  DR
          ENDIF
          RETURN
          ENTRY G900GT()
          G900GT  =  DS(2)*DX24 + DS(1)
          RETURN
          ENTRY G900ST(DSEED)
          DS(2)  =  DINT(DSEED/DX24)
          DS(1)  =  DSEED - DS(2)*DX24
          G900ST =  DS(1)
          RETURN
          END
          SUBROUTINE RANGET(SEED)
          DOUBLE PRECISION    SEED,     G900GT,   G900ST,   DUMMY
          SEED  =  G900GT()
          RETURN
          ENTRY RANSET(SEED)
          DUMMY  =  G900ST(SEED)
          RETURN
          END
CDECK  ID>, RANFGT. 
      SUBROUTINE RANFGT(SEED)
C
C          Get seed for RANF() in real or double precision SEED.
C
      IMPLICIT NONE
      DOUBLE PRECISION SEED
      CALL RANGET(SEED)
      RETURN
      END
CDECK  ID>, RANFMT. 
      SUBROUTINE RANFMT
C
C          Get RANF seed and translate it to a character variable
C          to ensure exactly the same seed with a formatted read.
C
      IMPLICIT NONE
      COMMON/SEED/XSEED
      SAVE /SEED/
      CHARACTER*24 XSEED
      DOUBLE PRECISION SEED
      CALL RANFGT(SEED)
      WRITE(XSEED,'(E24.15)') SEED
      READ(XSEED,'(E24.15)') SEED
      CALL RANFST(SEED)
      RETURN
      END
CDECK  ID>, RANFST. 
      SUBROUTINE RANFST(SEED)
C
C          Set seed for RANF() from real or double precision SEED
C
      IMPLICIT NONE
      DOUBLE PRECISION SEED
      CALL RANSET(SEED)
      RETURN
      END
CDECK  ID>, READIN. 
      SUBROUTINE READIN(IFL)
C
C       Read in user data and execute SETTYP if appropriate values
C       are set. IFL return values:
C       IFL = 0       Good parameter set
C       IFL = 1001    Stop
C       IFL > 0       Error. Program will continue reading data but
C                     will exit when END or unrecognizable keyword
C                     is found.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   LIMPOM
      PARAMETER (LIMPOM=20)
      COMMON/MBGEN/POMWT(LIMPOM),POMGEN(LIMPOM),MNPOM,MXPOM,PDIFFR,
     $NPOM,XBARY(2),DXBARY(2),XPOM(LIMPOM,2)
      SAVE /MBGEN/
      INTEGER   MNPOM,MXPOM,NPOM
      REAL      POMWT,POMGEN,PDIFFR,XBARY,DXBARY,XPOM
      INTEGER   MXFORC
      PARAMETER (MXFORC=40)
      COMMON/FORCE/NFORCE,IFORCE(MXFORC),MFORCE(5,MXFORC)
     $,LOOK2(2,MXFORC),LOOKST(MXFORC)
      SAVE /FORCE/
      INTEGER   NFORCE,IFORCE,MFORCE,LOOK2,LOOKST
C          LOOK MUST BE DIMENSIONED TO THE MAXIMUM VALUE OF INDEX.
      INTEGER   MXLOOK
      PARAMETER (MXLOOK=500)
      INTEGER   MXDKY
      PARAMETER (MXDKY=3000)
      COMMON/DKYTAB/LOOK(MXLOOK),CBR(MXDKY),MODE(5,MXDKY)
      SAVE /DKYTAB/
      INTEGER   LOOK,MODE
      REAL      CBR
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/EEPAR/SGMXEE,PLEP,PLEM
      SAVE /EEPAR/
      REAL      SGMXEE,PLEP,PLEM
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/FRGPAR/PUD,PBARY,SIGQT,PEND,XGEN(8),PSPIN1(8),
     $PMIX1(3,2),PMIX2(3,2),XGENSS(9)
      SAVE /FRGPAR/
      EQUIVALENCE (PMIX1(1,1),PMIXX1(1))
      EQUIVALENCE (PMIX2(1,1),PMIXX2(1))
      EQUIVALENCE(FRPAR(1),PUD)
      REAL      PUD,PBARY,SIGQT,PEND,XGEN,PSPIN1,PMIX1,PMIX2,XGENSS,
     +          PMIXX1(6),PMIXX2(6),FRPAR(32)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/PRTOUT/NEVPRT,NJUMP
      SAVE /PRTOUT/
      INTEGER   NEVPRT,NJUMP
      COMMON/SEED/XSEED
      SAVE /SEED/
      CHARACTER*24 XSEED
      COMMON/TYPES/LOC(100),NTYP,NJTTYP(3),NWWTYP(2),NWMODE(3)
      COMMON/XTYPES/PARTYP(40),TITLE(10),JETYP(30,3),WWTYP(30,2)
     $,WMODES(30,3)
      SAVE /TYPES/,/XTYPES/
      CHARACTER*8 JETYP,WWTYP,TITLE,PARTYP,WMODES
      INTEGER   LOC,NTYP,NJTTYP,NWWTYP,NWMODE
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/NODCAY/NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      SAVE /NODCAY/
      LOGICAL NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/QLMASS/AMLEP(100),NQLEP,NMES,NBARY
      SAVE /QLMASS/
      INTEGER   NQLEP,NMES,NBARY
      REAL      AMLEP
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/ISLOOP/NEVOLV,NFRGMN,IEVOL,IFRG
      SAVE /ISLOOP/
      INTEGER NEVOLV,NFRGMN,IEVOL,IFRG
      COMMON/TCPAR/TCMRHO,TCGRHO
      SAVE /TCPAR/
      REAL TCMRHO,TCGRHO
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C     XNUSUG contains non-universal GUT scale soft terms for SUGRA:
C     XNUSUG(1)=M1 XNUSUG(2)=M2 XNUSUG(3)=M3
C     XNUSUG(4)=A_tau XNUSUG(5)=A_b XNUSUG(6)=A_t
C     XNUSUG(7)=m_Hd XNUSUG(8)=m_Hu XNUSUG(9)=m_eR XNUSUG(10)=m_eL
C     XNUSUG(11)=m_dR XNUSUG(12)=m_uR XNUSUG(13)=m_uL XNUSUG(14)=m_lR
C     XNUSUG(15)=m_lL XNUSUG(16)=m_bR XNUSUG(17)=m_tR XNUSUG(18)=m_tL
C
      COMMON /SUGNU/ XNUSUG(18)
      REAL XNUSUG
      SAVE /SUGNU/
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
C
      LOGICAL SETTYP,DUMY
      CHARACTER*8 TTL(10),WORD,LSTRUC,BLANK
      CHARACTER*8 WTYP(4),RDID(2)
      CHARACTER*40 V,VISAJE
      INTEGER NLAP(3,17)
      INTEGER IDANTI,ID,IDB
      INTEGER IFL,I1,I2,I3,J1,I,NPROC,IKEY,IJ,J,KK,IDABS
      INTEGER IDXQKL,IDXQKR
      INTEGER NSEL,K,KFORCE(5),INDEX,IDG1,IDG2,IDG3,IDG4,IDXLEP
      REAL AMW,AMZ
      CHARACTER*8 HTYPE
      DOUBLE PRECISION SEED
C
      DATA NPROC/9/
C          Overlapping variable flags.
      DATA NLAP/1,2,3, 1,2,7 ,1,2,8, 1,3,5, 1,3,6, 1,3,7, 1,3,8, 1,5,7,
     X          1,5,8, 1,6,7, 1,6,8, 2,3,7, 2,3,8, 3,5,7, 3,6,7, 3,5,8,
     X          3,6,8/
      DATA BLANK/'        '/
C
C          Entry
      IFL=0
      V=VISAJE()
      WRITE(ITLIS,10) V
10    FORMAT('1',//5X,'*****  ',A40,'  *****')
      WRITE(ITLIS,11)
   11 FORMAT(////30X,' COMMANDS READ BY READIN')
C
C          Read title
C
      READ(ITCOM,1) TTL
    1 FORMAT(10A8)
      WRITE(ITLIS,2) TTL
    2 FORMAT(' ',10A8)
      IF(TTL(1).EQ.'STOP    ') THEN
        IFL=1001
        RETURN
      ENDIF
C
C          Read energy and no. of events
C
      READ(ITCOM,*) ECM,NEVENT,NEVPRT,NJUMP
      WRITE(ITLIS,*) ECM,NEVENT,NEVPRT,NJUMP
C
C          Reset all variables and set process if title is not 'SAME'
C
      IF(TTL(1).NE.'SAME    ') THEN
        DO 20 I=1,10
   20   TITLE(I)=TTL(I)
        CALL RESET
        KEYON=.FALSE.
C          Read reaction
        READ(ITCOM,3) REAC
    3   FORMAT(A8)
        WRITE(ITLIS,4) REAC
   4    FORMAT(1X,A8)
        DO 18 I=1,NPROC
18      KEYS(I)=.FALSE.
        KEYON=.FALSE.
C          Set KEYS and NJET
        IF(REAC.EQ.'TWOJET  ') THEN
          KEYS(1)=.TRUE.
          IKEY=1
          NJET=2
        ELSEIF(REAC.EQ.'E+E-    ') THEN
          KEYS(2)=.TRUE.
          IKEY=2
          NJET=2
        ELSEIF(REAC.EQ.'DRELLYAN') THEN
          KEYS(3)=.TRUE.
          IKEY=3
          NJET=3
        ELSEIF(REAC.EQ.'MINBIAS ') THEN
          KEYS(4)=.TRUE.
          IKEY=4
          NJET=0
        ELSEIF(REAC.EQ.'SUPERSYM'.OR.REAC.EQ.'SUSY    ') THEN
          KEYS(5)=.TRUE.
          IKEY=5
          NJET=2
        ELSEIF(REAC.EQ.'WPAIR   ') THEN
          KEYS(6)=.TRUE.
          IKEY=6
          NJET=2
        ELSEIF(REAC.EQ.'HIGGS   ') THEN
          KEYS(7)=.TRUE.
          IKEY=7
          NJET=2
        ELSEIF(REAC.EQ.'PHOTON  ') THEN
          KEYS(8)=.TRUE.
          IKEY=8
          NJET=2
        ELSEIF(REAC.EQ.'TCOLOR  ') THEN
          KEYS(9)=.TRUE.
          IKEYS=9
          NJET=2
        ELSE
          KEYON=.FALSE.
  890     WRITE(ITLIS,1999)
          IFL=9
          RETURN
        ENDIF
      ENDIF
C
      SCM=ECM**2
      HALFE=ECM/2
      NSEL=0
C
C          Read keyword. For each recognized keyword read corresponding
C          variables and set LOC flag.
C
      NSEL=0
100   CONTINUE
      READ(ITCOM,3) WORD
      WRITE(ITLIS,4) WORD
      NSEL=NSEL+1
C
C          Keyword END
      IF(WORD.EQ.'END     ') THEN
C          Check for previous error
        IF(IFL.NE.0) RETURN
C          Check inconsistent limits
        IF(LOC(2)*LOC(5).NE.0.OR.LOC(2)*LOC(6).NE.0) THEN
          WRITE(ITLIS,2001)
          IFL=11
        ENDIF
C          Set and check jet types
        IF(LOC(15).NE.0.OR.LOC(37).NE.0.OR.LOC(46).NE.0) THEN
          IF(SETTYP(0)) THEN
            WRITE(ITLIS,2006)
            IFL=12
          ENDIF
        ENDIF
C          Check MSSM/SUGRA conflict
        IF((LOC(51).NE.0.OR.LOC(52).NE.0.OR.LOC(53).NE.0).AND.
     $  LOC(55).NE.0) THEN
          WRITE(ITLIS,2007)
          IFL=29
        ENDIF
C          Check overlapping limits
        DO 120 I=1,17
          I1=NLAP(1,I)
          I2=NLAP(2,I)
          I3=NLAP(3,I)
          IF(LOC(I1)*LOC(I2)*LOC(I3).NE.0) WRITE(ITLIS,1001)
  120   CONTINUE
C          Setup PDFLIB
        RETURN
      ENDIF
C
C          Keyword P
      IF(WORD.EQ.'P       ') THEN
        READ(ITCOM,*)  (PMIN(K),PMAX(K),K=1,NJET)
        WRITE(ITLIS,*) (PMIN(K),PMAX(K),K=1,NJET)
        LOC(1)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword Y
      IF(WORD.EQ.'Y       ') THEN
        READ(ITCOM,*)  (YJMIN(K),YJMAX(K),K=1,NJET)
        WRITE(ITLIS,*) (YJMIN(K),YJMAX(K),K=1,NJET)
        LOC(2)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword X
      IF(WORD.EQ.'X       ') THEN
        READ(ITCOM,*)  (XJMIN(K),XJMAX(K),K=1,NJET)
        WRITE(ITLIS,*) (XJMIN(K),XJMAX(K),K=1,NJET)
        LOC(3)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword PHI
      IF(WORD.EQ.'PHI     ') THEN
        READ(ITCOM,*)  (PHIMIN(K),PHIMAX(K),K=1,NJET)
        WRITE(ITLIS,*) (PHIMIN(K),PHIMAX(K),K=1,NJET)
        LOC(4)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword TH
      IF(WORD.EQ.'TH      '.OR.WORD.EQ.'THETA   ') THEN
        READ(ITCOM,*)  (THMIN(K),THMAX(K),K=1,NJET)
        WRITE(ITLIS,*) (THMIN(K),THMAX(K),K=1,NJET)
        LOC(5)=NSEL
        LOC(6)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword PT
      IF(WORD.EQ.'PT      '.OR.WORD.EQ.'PPERP   ') THEN
        READ(ITCOM,*)  (PTMIN(K),PTMAX(K),K=1,NJET)
        WRITE(ITLIS,*) (PTMIN(K),PTMAX(K),K=1,NJET)
        LOC(7)=NSEL
        LOC(8)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NODECAY
      IF(WORD.EQ.'NODECAY ') THEN
        READ(ITCOM,571) NODCAY
571     FORMAT(L1)
        WRITE(ITLIS,572) NODCAY
572     FORMAT(' ',L1)
        LOC(9)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NOETA
      IF(WORD.EQ.'NOETA   ') THEN
        READ(ITCOM,571) NOETA
        WRITE(ITLIS,572) NOETA
        LOC(10)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NOPI0
      IF(WORD.EQ.'NOPI0   ') THEN
        READ(ITCOM,571) NOPI0
        WRITE(ITLIS,572) NOPI0
        LOC(11)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword BEAMS
      IF(WORD.EQ.'BEAMS   ') THEN
        READ(ITCOM,*) RDID(1),RDID(2)
        WRITE(ITLIS,*) RDID(1),RDID(2)
        IDIN(1)=0
        IDIN(2)=0
        DO 583 K=1,2
          IF(RDID(K).EQ.'P       ') IDIN(K)=+1120
          IF(RDID(K).EQ.'AP      ') IDIN(K)=-1120
          IF(RDID(K).EQ.'N       ') IDIN(K)=+1220
          IF(RDID(K).EQ.'AN      ') IDIN(K)=-1220
583     CONTINUE
        IF(IDIN(1)*IDIN(2).EQ.0) THEN
          WRITE(ITLIS,2002)
          IFL=13
        ENDIF
        LOC(12)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword FRAGMENT
      IF(WORD.EQ.'FRAGMENT') THEN
        READ(ITCOM,*)  FRPAR
        WRITE(ITLIS,*)  FRPAR
        LOC(13)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword SEED
      IF(WORD.EQ.'SEED    ') THEN
        READ(ITCOM,*) SEED
        WRITE(ITLIS,*) SEED
        CALL RANFST(SEED)
        WRITE(XSEED,'(E24.15)') SEED
        LOC(14)=NSEL
        GO TO 100
      ENDIF
C
C          Keywords JETTYPE1, JETTYPE2, JETTYPE3
      IF(WORD.EQ.'JETTYPE1'.OR.WORD.EQ.'JETTYPE2'.OR.WORD.EQ.
     $'JETTYPE3') THEN
        IF(WORD.EQ.'JETTYPE1') IJ=1
        IF(WORD.EQ.'JETTYPE2') IJ=2
        IF(WORD.EQ.'JETTYPE3') IJ=3
        READ(ITCOM,*) (JETYP(K,IJ),K=1,25)
        DO 601 K=1,25
601     IF(JETYP(K,IJ).NE.BLANK) NJTTYP(IJ)=NJTTYP(IJ)+1
        WRITE(ITLIS,*) (JETYP(K,IJ),K=1,NJTTYP(IJ))
        LOC(15)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword SIN2W
      IF(WORD.EQ.'SIN2W   ') THEN
        READ(ITCOM,*)  SIN2W
        WRITE(ITLIS,*) SIN2W
        LOC(17)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword TMASS
      IF(WORD.EQ.'TMASS   ') THEN
        READ(ITCOM,*)  AMLEP(6),AMLEP(7),AMLEP(8)
        WRITE(ITLIS,*) AMLEP(6),AMLEP(7),AMLEP(8)
        LOC(18)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword QMH
      IF(WORD.EQ.'QMH     ') THEN
        READ(ITCOM,*) QMIN,QMAX
        WRITE(ITLIS,*) QMIN,QMAX
        LOC(19)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword QMW
      IF(WORD.EQ.'QMW     ') THEN
        READ(ITCOM,*) QMIN,QMAX
        WRITE(ITLIS,*) QMIN,QMAX
        LOC(19)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword QTW
      IF(WORD.EQ.'QTW     ') THEN
        READ(ITCOM,*)  QTMIN,QTMAX
        WRITE(ITLIS,*) QTMIN,QTMAX
        LOC(20)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword YW
      IF(WORD.EQ.'YW      ') THEN
        READ(ITCOM,*)  YWMIN,YWMAX
        WRITE(ITLIS,*) YWMIN,YWMAX
        LOC(21)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword XW
      IF(WORD.EQ.'XW      ') THEN
        READ(ITCOM,*)  XWMIN,XWMAX
        WRITE(ITLIS,*) XWMIN,XWMAX
        LOC(22)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword THW
      IF(WORD.EQ.'THW     ') THEN
        READ(ITCOM,*)  THWMIN,THWMAX
        WRITE(ITLIS,*) THWMIN,THWMAX
        LOC(23)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword PHIW
      IF(WORD.EQ.'PHIW    ') THEN
        READ(ITCOM,*)  PHWMIN,PHWMAX
        WRITE(ITLIS,*) PHWMIN,PHWMAX
        LOC(24)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NONUNU
      IF(WORD.EQ.'NONUNU  ') THEN
        READ(ITCOM,571) NONUNU
        WRITE(ITLIS,572) NONUNU
        LOC(25)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword WTYPE
      IF(WORD.EQ.'WTYPE   ') THEN
        DO 191 J=1,4
          WTYP(J)=BLANK
191     GODY(J)=.FALSE.
        READ(ITCOM,*) WTYP
        WRITE(ITLIS,*) WTYP
        DO 192 K=1,4
          IF(WTYP(K).EQ.'GM      ') GODY(1)=.TRUE.
          IF(WTYP(K).EQ.'W+      ') GODY(2)=.TRUE.
          IF(WTYP(K).EQ.'W-      ') GODY(3)=.TRUE.
          IF(WTYP(K).EQ.'Z0      ') GODY(4)=.TRUE.
  192   CONTINUE
        IF(GODY(1)) JWTYP=1
        IF(GODY(2).OR.GODY(3)) JWTYP=3
        IF(GODY(4)) JWTYP=4
        IF((GODY(2).OR.GODY(3)).AND.(GODY(1).OR.GODY(4))) THEN
          WRITE(ITLIS,2003)
          IFL=13
        ENDIF
        LOC(26)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword LAMBDA
      IF(WORD.EQ.'LAMBDA  ') THEN
        READ(ITCOM,*)  ALAM
        WRITE(ITLIS,*)  ALAM
        ALAM2=ALAM**2
        LOC(27)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NTRIES
      IF(WORD.EQ.'NTRIES  ') THEN
        READ(ITCOM,*) NTRIES
        WRITE(ITLIS,*) NTRIES
        LOC(28)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword CUTOFF
      IF(WORD.EQ.'CUTOFF  ') THEN
        READ(ITCOM,*) CUTOFF,CUTPOW
        WRITE(ITLIS,*) CUTOFF,CUTPOW
        LOC(29)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword XGEN
      IF(WORD.EQ.'XGEN    ') THEN
        READ(ITCOM,*) XGEN
        WRITE(ITLIS,*) XGEN
        LOC(30)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword SIGQT
      IF(WORD.EQ.'SIGQT   ') THEN
        READ(ITCOM,*) SIGQT
        WRITE(ITLIS,*) SIGQT
        LOC(31)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword CUTJET
      IF(WORD.EQ.'CUTJET  ') THEN
        READ(ITCOM,*)  CUTJET
        WRITE(ITLIS,*)  CUTJET
        LOC(32)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword WFUDGE
      IF(WORD.EQ.'WFUDGE  ') THEN
        READ(ITCOM,*)  WFUDGE
        WRITE(ITLIS,*)  WFUDGE
        LOC(50)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword STRUC
      IF(WORD.EQ.'STRUC   ') THEN
        ISTRUC=0
        READ(ITCOM,*) LSTRUC
        WRITE(ITLIS,4) LSTRUC
        IF(LSTRUC.EQ.'OWENS   ') ISTRUC=1
        IF(LSTRUC.EQ.'BAIER   ') ISTRUC=2
        IF(LSTRUC.EQ.'EICHTEN '.OR.LSTRUC.EQ.'EHLQ    ') ISTRUC=3
        IF(LSTRUC.EQ.'DUKE    '.OR.LSTRUC.EQ.'DO      ') ISTRUC=4
        IF(LSTRUC.EQ.'CTEQ2L  ') ISTRUC=5
        IF(LSTRUC.EQ.'CTEQ    '.OR.LSTRUC.EQ.'CTEQ3L  ') ISTRUC=6
        IF(ISTRUC.EQ.0) THEN
          WRITE(ITLIS,2002)
          IFL=13
        ENDIF
        LOC(33)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NPOMERON
      IF(WORD.EQ.'NPOMERON') THEN
        READ(ITCOM,*) MNPOM,MXPOM
        WRITE(ITLIS,*) MNPOM,MXPOM
        IF(MNPOM.LT.1.OR.MNPOM.GT.MXPOM.OR.MXPOM.GT.LIMPOM) THEN
          WRITE(ITLIS,2004)
          IFL=14
        ENDIF
        LOC(34)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword FORCE
      IF(WORD.EQ.'FORCE   ') THEN
        NFORCE=NFORCE+1
        IF(NFORCE.GT.MXFORC-1) THEN
          WRITE(ITLIS,2004)
          IFL=14
        ENDIF
        DO 721 K=1,5
721     KFORCE(K)=0
        READ(ITCOM,*) IFORCE(NFORCE),(KFORCE(K),K=1,5)
        CALL ORDER(IFORCE(NFORCE),KFORCE,MFORCE(1,NFORCE))
        WRITE(ITLIS,*) IFORCE(NFORCE),(MFORCE(K,NFORCE),K=1,5)
        ID=IFORCE(NFORCE)
        IDABS=IABS(ID)
        IF(IDABS.LT.6) THEN
          WRITE(ITLIS,2005)
          IFL=15
        ENDIF
        IDB=IDANTI(ID)
        IF(IDB.NE.ID) THEN
          IFORCE(NFORCE+1)=IDB
          DO 722 K=1,5
  722     MFORCE(K,NFORCE+1)=IDANTI(MFORCE(K,NFORCE))
          NFORCE=NFORCE+1
        ENDIF
        LOC(35)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword FORCE1
      IF(WORD.EQ.'FORCE1  ') THEN
        NFORCE=NFORCE+1
        IF(NFORCE.GT.MXFORC) THEN
          WRITE(ITLIS,2004)
          IFL=14
        ENDIF
        DO 723 K=1,5
723     KFORCE(K)=0
        READ(ITCOM,*) IFORCE(NFORCE),(KFORCE(K),K=1,5)
        CALL ORDER(IFORCE(NFORCE),KFORCE,MFORCE(1,NFORCE))
        WRITE(ITLIS,*) IFORCE(NFORCE),(MFORCE(K,NFORCE),K=1,5)
        IF(IABS(IFORCE(NFORCE)).LT.6) THEN
          WRITE(ITLIS,2005)
          IFL=15
        ENDIF
        LOC(35)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword HMASSES - also see HMASS
      IF(WORD.EQ.'HMASSES ') THEN
        CALL FLAVOR(80,I1,I2,I3,J1,INDEX)
        READ(ITCOM,*) (AMLEP(INDEX+K),K=1,9)
        WRITE(ITLIS,*) (AMLEP(INDEX+K),K=1,9)
        LOC(36)=NSEL
        GO TO 100
      ENDIF
C
C          Keywords WMODE1,WMODE2
      IF(WORD.EQ.'WMODE1  '.OR.WORD.EQ.'WMODE2  ') THEN
        IF(WORD.EQ.'WMODE1  ') IJ=1
        IF(WORD.EQ.'WMODE2  ') IJ=2
        READ(ITCOM,*) (WWTYP(K,IJ),K=1,25)
        DO 602 K=1,25
602     IF(WWTYP(K,IJ).NE.BLANK) NWWTYP(IJ)=NWWTYP(IJ)+1
        WRITE(ITLIS,*) (WWTYP(K,IJ),K=1,NWWTYP(IJ))
        LOC(37)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NOEVOLVE
      IF(WORD.EQ.'NOEVOLVE') THEN
        READ (ITCOM,571) NOEVOL
        WRITE(ITLIS,572) NOEVOL
        LOC(38)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NOHADRON
      IF(WORD.EQ.'NOHADRON') THEN
        READ (ITCOM,571) NOHADR
        WRITE(ITLIS,572) NOHADR
        LOC(39)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword GAUGINO
      IF(WORD.EQ.'GAUGINO ') THEN
        CALL FLAVOR(29,I1,I2,I3,J1,IDG1)
        CALL FLAVOR(30,I1,I2,I3,J1,IDG2)
        CALL FLAVOR(39,I1,I2,I3,J1,IDG3)
        CALL FLAVOR(40,I1,I2,I3,J1,IDG4)
        READ(ITCOM,*) AMLEP(IDG1),AMLEP(IDG2),AMLEP(IDG3),AMLEP(IDG4)
        WRITE(ITLIS,*) AMLEP(IDG1),AMLEP(IDG2),AMLEP(IDG3),AMLEP(IDG4)
        LOC(40)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword SQUARK
      IF(WORD.EQ.'SQUARK  ') THEN
        CALL FLAVOR(21,I1,I2,I3,J1,IDXQKL)
        READ(ITCOM,*) (AMLEP(IDXQKL+K-1),K=1,6)
        WRITE(ITLIS,*) (AMLEP(IDXQKL+K-1),K=1,6)
        CALL FLAVOR(41,I1,I2,I3,J1,IDXQKR)
        DO 21 K=1,6
          AMLEP(IDXQKR+K-1)=AMLEP(IDXQKL+K-1)
21      CONTINUE
        LOC(41)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword SLEPTON
      IF(WORD.EQ.'SLEPTON ') THEN
        CALL FLAVOR(31,I1,I2,I3,J1,IDXLEP)
        READ(ITCOM,*) (AMLEP(IDXLEP+K-1),K=1,6)
        WRITE(ITLIS,*) (AMLEP(IDXLEP+K-1),K=1,6)
        LOC(42)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NSIGMA
      IF(WORD.EQ.'NSIGMA  ') THEN
        READ(ITCOM,*) NSIGMA
        WRITE(ITLIS,*) NSIGMA
        LOC(43)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword XGENSS
      IF(WORD.EQ.'XGENSS  ') THEN
        READ(ITCOM,*) XGENSS(9),(XGENSS(KK),KK=1,8)
        WRITE(ITLIS,*) XGENSS(9),(XGENSS(KK),KK=1,8)
        LOC(44)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword HMASS - just standard Higgs
      IF(WORD.EQ.'HMASS   ') THEN
        CALL FLAVOR(81,I1,I2,I3,J1,INDEX)
        READ(ITCOM,*) AMLEP(INDEX)
        WRITE(ITLIS,*) AMLEP(INDEX)
        LOC(45)=NSEL
        GO TO 100
      ENDIF
C
C          Keywords WPMODE, WMMODE, Z0MODE
      IF(WORD.EQ.'WPMODE  '.OR.WORD.EQ.'WMMODE  '
     $.OR.WORD.EQ.'Z0MODE  ') THEN
        IF(WORD.EQ.'WPMODE  ') IJ=1
        IF(WORD.EQ.'WMMODE  ') IJ=2
        IF(WORD.EQ.'Z0MODE  ') IJ=3
        READ(ITCOM,*) (WMODES(K,IJ),K=1,25)
        DO 603 K=1,25
603     IF(WMODES(K,IJ).NE.BLANK) NWMODE(IJ)=NWMODE(IJ)+1
        WRITE(ITLIS,*) (WMODES(K,IJ),K=1,NWMODE(IJ))
        LOC(46)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword WMASS
      IF(WORD.EQ.'WMASS   ') THEN
        READ(ITCOM,*) AMW,AMZ
        WRITE(ITLIS,*) AMW,AMZ
        WMASS(1)=0.
        WMASS(2)=AMW
        WMASS(3)=AMW
        WMASS(4)=AMZ
        CALL FLAVOR(80,I1,I2,I3,J,INDEX)
        AMLEP(INDEX)=AMW
        CALL FLAVOR(90,I1,I2,I3,J,INDEX)
        AMLEP(INDEX)=AMZ
        LOC(47)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NEVOLVE
      IF(WORD.EQ.'NEVOLVE ') THEN
        READ(ITCOM,*) NEVOLV
        WRITE(ITLIS,*) NEVOLV
        LOC(48)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NHADRON
      IF(WORD.EQ.'NHADRON ') THEN
        READ(ITCOM,*) NFRGMN
        WRITE(ITLIS,*) NFRGMN
        LOC(49)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword TCMASS
      IF(WORD.EQ.'TCMASS  ') THEN
        READ(ITCOM,*) TCMRHO,TCGRHO
        WRITE(ITLIS,*) TCMRHO,TCGRHO
        LOC(50)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword MSSMA: gluino, mu, mha, tanb
      IF(WORD.EQ.'MSSMA   ') THEN
        READ(ITCOM,*) XGLSS,XMUSS,XHASS,XTBSS
        WRITE(ITLIS,*) XGLSS,XMUSS,XHASS,XTBSS
        GOMSSM=.TRUE.
        LOC(51)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword MSSMB: 1st generation soft terms
      IF(WORD.EQ.'MSSMB   ') THEN
        READ(ITCOM,*) XQ1SS,XDRSS,XURSS,XL1SS,XERSS
        WRITE(ITLIS,*) XQ1SS,XDRSS,XURSS,XL1SS,XERSS
        LOC(52)=NSEL
        GOMSSM=.TRUE.
        GO TO 100
      ENDIF
C
C          Keyword MSSMC: 3rd generation soft terms
      IF(WORD.EQ.'MSSMC   ') THEN
        READ(ITCOM,*)XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
       WRITE(ITLIS,*)XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
        LOC(53)=NSEL
        GOMSSM=.TRUE.
        GO TO 100
      ENDIF
C
C          Keyword PDFLIB: parameters for PDFLIB
C
C          Keyword SUGRA
      IF(WORD.EQ.'SUGRA   ') THEN
        READ(ITCOM,*) XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
        WRITE(ITLIS,*) XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
        LOC(55)=NSEL
        GOMSSM=.TRUE.
        GOSUG=.TRUE.
        GO TO 100
      ENDIF
C
C          Keyword HTYPE
      IF(WORD.EQ.'HTYPE   ') THEN
        READ(ITCOM,*) HTYPE
        WRITE(ITLIS,*) HTYPE
        LOC(56)=NSEL
        IHTYPE=0
        IF(HTYPE.EQ.'HL0     ') IHTYPE=82
        IF(HTYPE.EQ.'HH0     ') IHTYPE=83
        IF(HTYPE.EQ.'HA0     ') IHTYPE=84
        IF(IHTYPE.EQ.0) THEN
          WRITE(ITLIS,2000) HTYPE
          IFL=16
        ENDIF
        GO TO 100
      ENDIF
C
C          Keyword EPOL
      IF(WORD.EQ.'EPOL  ') THEN
        READ(ITCOM,*) PLEM,PLEP
        WRITE(ITLIS,*) PLEM,PLEP
        LOC(57)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword MSSMD: optional 2nd geenration soft terms
      IF(WORD.EQ.'MSSMD   ') THEN
        READ(ITCOM,*) XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
        WRITE(ITLIS,*) XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
        LOC(58)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword MSSME: optional U(1) and SU(2) gaugino masses
      IF(WORD.EQ.'MSSME   ') THEN
        READ(ITCOM,*) XM1SS,XM2SS
        WRITE(ITLIS,*) XM1SS,XM2SS
        LOC(59)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword GMSB: gauge-mediated SUSY breaking model
      IF(WORD.EQ.'GMSB    ') THEN
        READ(ITCOM,*) XLAMGM,XMESGM,XN5GM,XTGBSU,XSMUSU,XCMGV
        WRITE(ITLIS,*) XLAMGM,XMESGM,XN5GM,XTGBSU,XSMUSU,XCMGV
        GOMSSM=.TRUE.
        GOGMSB=.TRUE.
        LOC(60)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NUSUG1: optional GUT scale gaugino masses
      IF(WORD.EQ.'NUSUG1   ') THEN
        READ(ITCOM,*) XNUSUG(1),XNUSUG(2),XNUSUG(3)
        WRITE(ITLIS,*) XNUSUG(1),XNUSUG(2),XNUSUG(3)
        LOC(61)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NUSUG2: optional GUT scale A terms
      IF(WORD.EQ.'NUSUG2   ') THEN
        READ(ITCOM,*) XNUSUG(6),XNUSUG(5),XNUSUG(4)
        WRITE(ITLIS,*) XNUSUG(6),XNUSUG(5),XNUSUG(4)
        LOC(62)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NUSUG3: optional GUT scale Higgs masses
      IF(WORD.EQ.'NUSUG3   ') THEN
        READ(ITCOM,*) XNUSUG(7),XNUSUG(8)
        WRITE(ITLIS,*) XNUSUG(7),XNUSUG(8)
        LOC(63)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NUSUG4: optional GUT scale 1st/2nd gen. masses
      IF(WORD.EQ.'NUSUG4   ') THEN
        READ(ITCOM,*) XNUSUG(13),XNUSUG(11),XNUSUG(12),XNUSUG(10)
     $,XNUSUG(9)
        WRITE(ITLIS,*) XNUSUG(13),XNUSUG(11),XNUSUG(12),XNUSUG(10)
     $,XNUSUG(9)
        LOC(64)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NUSUG5: optional GUT scale 3rd gen. masses
      IF(WORD.EQ.'NUSUG5   ') THEN
        READ(ITCOM,*) XNUSUG(18),XNUSUG(16),XNUSUG(17),XNUSUG(15)
     $,XNUSUG(14)
        WRITE(ITLIS,*) XNUSUG(18),XNUSUG(16),XNUSUG(17),XNUSUG(15)
     $,XNUSUG(14)
        LOC(65)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword NOGRAV: No gravitino decays
      IF(WORD.EQ.'NOGRAV  ') THEN
        READ(ITCOM,571) NOGRAV
        WRITE(ITLIS,572) NOGRAV
        LOC(66)=NSEL
        GO TO 100
      ENDIF
C
C          Keyword MGVTNO: Sets the gravitino mass
      IF(WORD.EQ.'MGVTNO  ') THEN
        READ(ITCOM,*) XMGVTO
        WRITE(ITLIS,*) XMGVTO
        LOC(67)=NSEL
        GO TO 100
      ENDIF
C
C          None of the above
C
      WRITE(ITLIS,2000) WORD
      IFL=10
      RETURN
C
C          Error message or warnings
C
 1001     FORMAT(//2X,'YOU HAVE GIVEN LIMITS FOR AN OVERLAPPING SET',
     $  ' OF VARIABLES. SET MINIMIZING PPERP INTERVAL WILL BE USED.')
 1999     FORMAT(//' YOU FORGOT TO SELECT A PROCESS FOR GENERATION.'
     $    /' AVAILABLE AT PRESENT ARE ',
     $    /' TWOJET  E+E-  DRELLYAN  MINBIAS  WPAIR  SUPERSYM,'
     $    /' HIGGS  PHOTON  TCOLOR')
 2000 FORMAT(//2X,A8,' IS NOT A RECOGNIZABLE PARAMETER. JOB TERMINATED')
 2001     FORMAT(//2X,' YOU CANNOT GIVE LIMITS FOR BOTH THETA AND Y.',
     $    ' MAKE UP YOUR MIND. JOB TERMINATED.')
 2002     FORMAT(/'  WHAT IS THAT SUPPOSED TO BE')
 2003     FORMAT(/'  YOU CANNOT RUN WS AND Z0 OR GAMMAS AT THE',
     $    ' SAME TIME. JOB TERMINATED')
 2004 FORMAT(//'  PARAMETER OUT OF RANGE. JOB TERMINATED.')
 2005 FORMAT(//'  YOU CANNOT FORCE DECAY OF A QUARK, YOU MUST CHOSE '
     $,' A PARTICLE')
 2006     FORMAT(//2X,' INVALID JETTYPE VALUES. JOB TERMINATED.')
 2007 FORMAT(//2X,'YOU CANNOT USE MSSM AND SUGRA SIMULTANEOUSLY')
      END
CDECK  ID>, REJFRG. 
      LOGICAL FUNCTION REJFRG()
C-----------------------------------------------------------------------
C-
C-         This is called after FRGMNT for TWOJET and DRELLYAN events
C-         to test the fragmentation. REJFRG=.FALSE. keeps the event.
C-
C-----------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      INTEGER I,ID
      REAL PTL,CUTLEP,CUTNU
      DATA CUTLEP/50./,CUTNU/100./
      REJFRG=.FALSE.
C***************************************
C           Sample REJFRG function which keeps the event if it contains
C           any lepton satisfying
C             PT > CUTLEP (charged lepton)
C             PT > CUTNU  (neutrino)
C           Appropriate values of the cuts must be set by the user.
C      REJFRG=.TRUE.
C      DO 1 I=1,NPTCL
C        IF(IDCAY(I).NE.0) GO TO 1
C        ID=IABS(IDENT(I))
C        IF(ID.LE.10.OR.ID.GE.20) GO TO 1
C        PTL=SQRT(PPTCL(1,I)**2+PPTCL(2,I)**2)
C        IF((ID.EQ.11.OR.ID.EQ.13.OR.ID.EQ.15).AND.PTL.GT.CUTNU) THEN
C          REJFRG=.FALSE.
C          RETURN
C        ELSEIF((ID.EQ.12..OR.ID.EQ.14).AND.PTL.GT.CUTLEP) THEN
C          REJFRG=.FALSE.
C          RETURN
C        ENDIF
C   1  CONTINUE
C***************************************
      RETURN
      END
CDECK  ID>, REJJET. 
      LOGICAL FUNCTION REJJET()
C-----------------------------------------------------------------------
C-
C-         This is called after EVOLVE for TWOJET and DRELLYAN events
C-         to test the partons (jets). REJJET=.FALSE. keeps the event.
C-
C-----------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      INTEGER I,IFLAV
      REJJET=.FALSE.
C***************************************
C           Sample REJJET function which keeps the event if one of the
C           outgoing partons is a heavy quark.
C      REJJET=.TRUE.
C      DO 1 I=1,NJSET
C        IF(JDCAY(I).NE.0) GO TO 1
C        IFLAV=IABS(JTYPE(I))
C        IF(IFLAV.GE.4.AND.IFLAV.LT.9) THEN
C          REJJET=.FALSE.
C          RETURN
C        ENDIF
C  1   CONTINUE
C***************************************
      RETURN
      END
CDECK  ID>, RESCAL. 
      SUBROUTINE RESCAL(N1,N2,PSUM,IFAIL)
C          RESCALE MOMENTA OF PARTICLES N1...N2 TO GIVE TOTAL
C          FOUR-MOMENTUM PSUM.
C          RETURN IFAIL=0 IF OK, IFAIL=1 IF NO GOOD.
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      DIMENSION PSUM(5),PADD(5),BETA(3)
      DATA ERRLIM/.0001/
C          ORIGIONAL MOMENTUM IS PADD.
      IFAIL=1
      IF(N1.GE.N2) RETURN
      DO 100 K=1,5
100   PADD(K)=0.
      DO 110 IP=N1,N2
      DO 110 K=1,5
      PADD(K)=PADD(K)+PPTCL(K,IP)
110   CONTINUE
      IF(PADD(5).GE.PSUM(5)) RETURN
      PADD(5)=PADD(4)**2-PADD(1)**2-PADD(2)**2-PADD(3)**2
      IF(PADD(5).LE.0) RETURN
      PADD(5)=SQRT(PADD(5))
      DO 120 K=1,3
120   BETA(K)=-PADD(K)/PADD(5)
      GAMMA=PADD(4)/PADD(5)
C          BOOST PARTICLES TO REST.
200   CONTINUE
      DO 210 IP=N1,N2
      BP=0.
      DO 220 K=1,3
220   BP=BP+PPTCL(K,IP)*BETA(K)
      DO 230 K=1,3
230   PPTCL(K,IP)=PPTCL(K,IP)+BETA(K)*PPTCL(4,IP)
     $+BETA(K)*BP/(GAMMA+1.)
      PPTCL(4,IP)=GAMMA*PPTCL(4,IP)+BP
210   CONTINUE
      IF(IFAIL.EQ.0) RETURN
C          RESCALE MOMENTA IN REST FRAME.
      SCAL=1.
      DO 301 IPASS=1,200
      SUM=0.
      DO 310 IP=N1,N2
      DO 320 K=1,3
320   PPTCL(K,IP)=SCAL*PPTCL(K,IP)
      PPTCL(4,IP)=SQRT(PPTCL(1,IP)**2+PPTCL(2,IP)**2+PPTCL(3,IP)**2
     $+PPTCL(5,IP)**2)
      SUM=SUM+PPTCL(4,IP)
310   CONTINUE
      SCAL=PSUM(5)/SUM
301   IF(ABS(SCAL-1.).LE.ERRLIM) GO TO 300
300   CONTINUE
C          BOOST BACK WITH PSUM.
      BMAG=0.
      DO 400 K=1,3
      BETA(K)=PSUM(K)/PSUM(5)
      BMAG=BMAG+ABS(BETA(K))
400   CONTINUE
      GAMMA=PSUM(4)/PSUM(5)
      IFAIL=0
      IF(BMAG.EQ.0.) RETURN
      GO TO 200
      END

CDECK  ID>, SETCON. 
      SUBROUTINE SETCON
C          THIS SUBROUTINE SETS THE CONSTANTS IN /CONST/.
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      PI=4.*ATAN(1.)
      SQRT2=SQRT(2.)
      ALFA=1./137.036
      GF=1.16570E-5
      UNITS=1./2.56815
      RETURN
      END
CDECK  ID>, SETDKY. 
      SUBROUTINE SETDKY(LPRINT)
C
C          Read in decay table from tape ITDKY and set up /DKYTAB/.
C          Then append forced decay modes and set LOOK to negative
C          number pointing to LOOK2, which points to table.
C          Forced decays for antiparticles are stored in conjugated
C          form so that DECAY can always conjugate them.
C
C          Logical flag LPRINT controls printing of table.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXFORC
      PARAMETER (MXFORC=40)
      COMMON/FORCE/NFORCE,IFORCE(MXFORC),MFORCE(5,MXFORC)
     $,LOOK2(2,MXFORC),LOOKST(MXFORC)
      SAVE /FORCE/
      INTEGER   NFORCE,IFORCE,MFORCE,LOOK2,LOOKST
C          LOOK MUST BE DIMENSIONED TO THE MAXIMUM VALUE OF INDEX.
      INTEGER   MXLOOK
      PARAMETER (MXLOOK=500)
      INTEGER   MXDKY
      PARAMETER (MXDKY=3000)
      COMMON/DKYTAB/LOOK(MXLOOK),CBR(MXDKY),MODE(5,MXDKY)
      SAVE /DKYTAB/
      INTEGER   LOOK,MODE
      REAL      CBR
      COMMON/NODCAY/NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      SAVE /NODCAY/
      LOGICAL NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
C          MXSS                 = maximum number of modes
C          NSSMOD               = number of modes
C          ISSMOD               = initial particle
C          JSSMOD               = final particles
C          GSSMOD               = width
C          BSSMOD               = branching ratio
      INTEGER MXSS
      PARAMETER (MXSS=1000)
      COMMON/SSMODE/NSSMOD,ISSMOD(MXSS),JSSMOD(5,MXSS),GSSMOD(MXSS)
     $,BSSMOD(MXSS)
      INTEGER NSSMOD,ISSMOD,JSSMOD
      REAL GSSMOD,BSSMOD
      SAVE /SSMODE/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C
      INTEGER IMODE(6),LOOP,IOLD,I,IRES,ITYPE,K,J,IPOINT
      INTEGER IFL1,IFL2,IFL3,JSPIN,INDEX,ID1,IDANTI,KTYPE,IRES2
      REAL    BR
      CHARACTER*8 LABEL,LMODE(6),LRES
      CHARACTER*8 IBLANK,LREAD(10),IQUIT
      LOGICAL LPRINT
      INTEGER NOUT,NTHAD
      PARAMETER (NOUT=33)
      PARAMETER (NTHAD=12)
      INTEGER IDOUT(NOUT),ITHAD(NTHAD)
      REAL SUMBR,SUMBR2
C
      DATA IDOUT/
     $IDTP,ISGL,ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1,ISUPR,ISDNR,
     $ISSTR,ISCHR,ISBT2,ISTP2,ISEL,ISMUL,ISTAU1,ISNEL,ISNML,ISNTL,
     $ISER,ISMUR,ISTAU2,ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,
     $ISHL,ISHH,ISHA,ISHC/
      DATA IQUIT/'////'/,IBLANK/' '/
      DATA ITHAD/-160,-260,-360,
     $  1160,1260,2260,2160,1360,2360,3160,3260,3360/
C
C          Print header for table.
C
      IF(LPRINT) WRITE(ITLIS,10)
10    FORMAT('1',30('*')/' *',28X,'*'/
     1' *',5X,'ISAJET DECAY TABLE',5X,'*'/
     2' *',28X,'*'/' ',30('*')//
     33X,'PART',16X,'DECAY MODE',16X,'CUM BR',10X,'IDENT',18X,
     4'DECAY IDENT'/)
C
C          Initialize. LOOP is the decay mode counter.
C
      LOOP=0
      IOLD=0
      DO 100 I=1,MXLOOK
        LOOK(I)=0
100   CONTINUE
      DO 110 I=1,MXFORC
        LOOK2(1,I)=0
        LOOK2(2,I)=0
110   CONTINUE
C
C          Read in table.
C
      IF(NODCAY.OR.ITDKY.EQ.0) RETURN
      REWIND ITDKY
200   LOOP=LOOP+1
      IF(LOOP.GT.MXDKY) GO TO 9999
220   DO 210 I=1,5
        IMODE(I)=0
        LMODE(I)=IBLANK
210   CONTINUE
      READ(ITDKY,*) IRES,ITYPE,BR,IMODE
C
      IF(IRES.NE.0) THEN
        IF(NOPI0.AND.IRES.EQ.110) GO TO 220
        IF(NOETA.AND.IRES.EQ.220) GO TO 220
        IF(IRES.NE.IOLD) THEN
          CALL FLAVOR(IRES,IFL1,IFL2,IFL3,JSPIN,INDEX)
          LOOK(INDEX)=LOOP
        ENDIF
        IOLD=IRES
        CBR(LOOP)=BR
        DO 240 I=1,5
          MODE(I,LOOP)=IMODE(I)
          IF(IMODE(I).NE.0) LMODE(I)=LABEL(IMODE(I))
240     CONTINUE
        LRES=LABEL(IRES)
        IF(LPRINT) WRITE(ITLIS,20) LRES,(LMODE(K),K=1,5),
     1  BR,IRES,(IMODE(K),K=1,5)
20      FORMAT(3X,A5,4X,5(A5,2X),F8.5,10X,I5,4X,5(I7,2X))
        GO TO 200
      ENDIF
C
C          Add MSSM decay modes if applicable
C
      IF(GOMSSM) THEN
        DO 250 I=1,NOUT
C          Check for modes
          SUMBR=0
          DO 251 J=1,NSSMOD
            IF(ISSMOD(J).EQ.IDOUT(I).AND.BSSMOD(J).GT.0) THEN
              SUMBR=SUMBR+BSSMOD(J)
            ENDIF
251       CONTINUE
C          If modes exist, add them
          IF(SUMBR.LE.0) GO TO 250
          IRES=IDOUT(I)
          LRES=LABEL(IRES)
          CALL FLAVOR(IRES,IFL1,IFL2,IFL3,JSPIN,INDEX)
          LOOK(INDEX)=LOOP+1
          SUMBR2=0
          DO 252 J=1,NSSMOD
            IF(ISSMOD(J).EQ.IDOUT(I).AND.BSSMOD(J).GT.0) THEN
              LOOP=LOOP+1
              SUMBR2=SUMBR2+BSSMOD(J)
              BR=SUMBR2/SUMBR
              CBR(LOOP)=BR
              DO 253 K=1,5
                MODE(K,LOOP)=JSSMOD(K,J)
                LMODE(K)=LABEL(MODE(K,LOOP))
253           CONTINUE
              IF(LPRINT) WRITE(ITLIS,20) LRES,(LMODE(K),K=1,5),
     $        BR,IRES,(MODE(K,LOOP),K=1,5)
            ENDIF
252       CONTINUE
250     CONTINUE
C          Top hadron decays
        DO 260 I=1,NTHAD
C          Check for modes
          SUMBR=0
          DO 261 J=1,NSSMOD
            IF(ISSMOD(J).EQ.6.AND.BSSMOD(J).GT.0) THEN
              SUMBR=SUMBR+BSSMOD(J)
            ENDIF
261       CONTINUE
C          If modes exist, add them -- conjugate for antimesons
          IF(SUMBR.LE.0) GO TO 260
          IRES=IABS(ITHAD(I))
          LRES=LABEL(IRES)
          CALL FLAVOR(IRES,IFL1,IFL2,IFL3,JSPIN,INDEX)
          LOOK(INDEX)=LOOP+1
          SUMBR2=0
          DO 262 J=1,NSSMOD
            IF(ISSMOD(J).EQ.6.AND.BSSMOD(J).GT.0) THEN
              LOOP=LOOP+1
              SUMBR2=SUMBR2+BSSMOD(J)
              BR=SUMBR2/SUMBR
              CBR(LOOP)=BR
              DO 263 K=1,5
                IF(ITHAD(I).GT.0) THEN
                  MODE(K,LOOP)=JSSMOD(K,J)
                ELSE
                  MODE(K,LOOP)=IDANTI(JSSMOD(K,J))
                ENDIF
                LMODE(K)=LABEL(MODE(K,LOOP))
263           CONTINUE
              IF(LPRINT) WRITE(ITLIS,20) LRES,(LMODE(K),K=1,5),
     $        BR,IRES,(MODE(K,LOOP),K=1,5)
            ENDIF
262       CONTINUE
260     CONTINUE
      ENDIF
C
C          Set forced decay modes.
C          LOOK(INDEX) = -IRES, where LOOK2(K,IRES) points to entries in
C          decay table for IDENT>0 and IDENT<0.
C          LOOKST(IRES) = standard LOOK value.
C
      IF(NFORCE.EQ.0) GO TO 400
C          Setup forced decay modes for top
      CALL FORTOP
C          Append each forced decay to table
      IRES=0
      DO 310 I=1,NFORCE
        IF(IFORCE(I).EQ.0) GO TO 310
        LOOP=LOOP+1
        IF(LOOP.GT.MXDKY) GO TO 9999
        CALL FLAVOR(IFORCE(I),IFL1,IFL2,IFL3,JSPIN,INDEX)
        IF(IFORCE(I).GT.0) THEN
          KTYPE=1
        ELSE
          KTYPE=2
        ENDIF
C
        IF(LOOK(INDEX).GE.0) THEN
          IRES=IRES+1
          IF(IRES.GT.MXFORC) GO TO 9998
          LOOKST(IRES)=LOOK(INDEX)
          LOOK2(KTYPE,IRES)=LOOP
          LOOK2(3-KTYPE,IRES)=LOOKST(IRES)
          LOOK(INDEX)=-IRES
        ELSE
          IRES2=-LOOK(INDEX)
          IF(IRES2.GT.MXFORC) GO TO 9998
          LOOK2(KTYPE,IRES2)=LOOP
        ENDIF
C          Set forced decay mode - conjugate if necessary
        IF(KTYPE.EQ.1) THEN
          DO 320 K=1,5
320       MODE(K,LOOP)=MFORCE(K,I)
        ELSE
          DO 330 K=1,5
330       MODE(K,LOOP)=IDANTI(MFORCE(K,I))
        ENDIF
        CBR(LOOP)=1.
310   CONTINUE
C
C          Read and print notes from decay table file.
C
400   IF(LPRINT) THEN
        WRITE(ITLIS,1001)
1001    FORMAT('1',24('*')/' *',22X,'*'/
     1  ' *',5X,'ISAJET NOTES',5X,'*'/
     2  ' *',22X,'*'/' ',24('*')//)
410     READ(ITDKY,1002) LREAD
1002    FORMAT(10A8)
        IF(LREAD(1).EQ.IQUIT) RETURN
        WRITE(ITLIS,1003) LREAD
1003    FORMAT(1X,10A8)
        GO TO 410
      ENDIF
      RETURN
C
C          Errors
C
9999  WRITE(ITLIS,3001) LOOP
3001  FORMAT(//' ***** ERROR IN SETDKY ... DECAY COUNTER LOOP = ',
     $I6,' *****')
      STOP 99
9998  WRITE(ITLIS,3002) IRES
3002  FORMAT(//' ***** ERROR IN SETDKY ... FORCE COUNTER IRES = ',
     $I6,' *****')
      STOP 99
      END
CDECK  ID>, SETH.   
      SUBROUTINE SETH
C
C          Set the standard Weinberg-Salam Higgs parameters in /HCON/.
C          HMASS  = Higgs mass
C          HGAM   = Higgs width
C          HGAMS  = Higgs partial width
C          ZSTARS = minimum allowed mass for Z*
C
C          IQ = 1  2  3  4  5  6  7  8  9  10 11 12 13
C               GL UP UB DN DB ST SB CH CB BT BB TP TB
C          IQ = 14  15   16 17 18   19   20  21  22  23   24   25
C               NUE ANUE E- E+ NUMU ANUM MU- MU+ NUT ANUT TAU- TAU+
C          IQ = 26 27 28 29
C               GM W+ W- Z0
C
C          Ver 6.25: Added H -> GM GM.
C          Ver 6.26: Added H -> Z0 Z* from Keung and Marciano, Phys.
C                    Rev. D30, 248 (1984).
C          Ver 6.30: Fixed sign of FFR in H -> GM GM for TAU<1. Added
C                    H -> W W* to total width but not to partial widths
C                    to get right branching ratios.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/QLMASS/AMLEP(100),NQLEP,NMES,NBARY
      SAVE /QLMASS/
      INTEGER   NQLEP,NMES,NBARY
      REAL      AMLEP
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/NODCAY/NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      SAVE /NODCAY/
      LOGICAL NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
C
      REAL GAMFCN,X,AMASS,AMQ,GAMQ,AML,WM,GAMWW,TAU,FFR,FFI,FR,FI,
     $ROOT,ROOTLN,TM,SUMBR,TERM,ETAR,ETAI,RQ,RQLOG,PHIR,PHII
      REAL EPS,FEPS,AM12
      INTEGER IQ,IQ1,IQ2,I,IW
      INTEGER LISTJ(25),LISTW(4)
      DATA LISTJ/
     $9,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,
     $11,-11,12,-12,13,-13,14,-14,15,-15,16,-16/
      DATA LISTW/10,80,-80,90/
C
      GAMFCN(X)=SQRT(1.-4*X**2)*(1.-4.*X**2+12.*X**4)
C
C          Calculate Higgs mass and width
C
      HMASS=AMASS(81)
      HGAM=0.
      DO 100 IQ=1,29
100   HGAMS(IQ)=0.
C
C          Quarks and leptons
      DO 110 IQ=1,6
        AMQ=AMASS(IQ)
        IF(AMQ.GT.0..AND.AMQ.LT..5*HMASS) THEN
          GAMQ=3.*GF*AMQ**2*HMASS/(4.*PI*SQRT2)
     $    *(SQRT(1.-4.*AMQ**2/HMASS**2))**3
          HGAM=HGAM+GAMQ
          HGAMS(2*IQ)=.5*GAMQ
          HGAMS(2*IQ+1)=.5*GAMQ
        ENDIF
        AML=AMASS(IQ+10)
        IF(AML.GT.0..AND.AML.LT..5*HMASS) THEN
          GAMQ=GF*AML**2*HMASS/(4.*PI*SQRT2)
     $    *(SQRT(1.-4.*AML**2/HMASS**2))**3
          HGAM=HGAM+GAMQ
          HGAMS(2*IQ+12)=.5*GAMQ
          HGAMS(2*IQ+13)=.5*GAMQ
        ENDIF
110   CONTINUE
C
C          W+ W- and Z0 Z0, including W W* and Z Z*.
      WM=WMASS(2)
      IF(HMASS.GT.2.*WM) THEN
        GAMWW=GF*HMASS**3*GAMFCN(WM/HMASS)/(8.*PI*SQRT2)
        HGAM=HGAM+GAMWW
        HGAMS(27)=.5*GAMWW
        HGAMS(28)=.5*GAMWW
      ELSEIF(HMASS.GT.WM) THEN
        EPS=WM/HMASS
        FEPS=3.*(1.-8.*EPS**2+20.*EPS**4)/SQRT(4.*EPS**2-1.)
     $  *ACOS((3.*EPS**2-1.)/(2.*EPS**3))
     $  -(1.-EPS**2)*(47./2.*EPS**2-13./2.+1./EPS**2)
     $  -3.*(1.-6.*EPS**2+4.*EPS**4)*ALOG(EPS)
        GAMWW=3.*ALFA**2*HMASS/(32.*PI*SIN2W**2)*FEPS
        HGAM=HGAM+GAMWW
        HGAMS(27)=.5*GAMWW
        HGAMS(28)=.5*GAMWW
      ENDIF
      WM=WMASS(4)
      IF(HMASS.GT.2.*WM) THEN
        GAMWW=GF*HMASS**3*GAMFCN(WM/HMASS)/(16.*PI*SQRT2)
        HGAM=HGAM+GAMWW
        HGAMS(29)=GAMWW
      ELSEIF(HMASS.GT.WM) THEN
        EPS=WM/HMASS
        FEPS=3.*(1.-8.*EPS**2+20.*EPS**4)/SQRT(4.*EPS**2-1.)
     $  *ACOS((3.*EPS**2-1.)/(2.*EPS**3))
     $  -(1.-EPS**2)*(47./2.*EPS**2-13./2.+1./EPS**2)
     $  -3.*(1.-6.*EPS**2+4.*EPS**4)*ALOG(EPS)
        GAMWW=ALFA**2*HMASS/(128.*PI*SIN2W**2*(1.-SIN2W)**2)
     $  *(7.-40./3.*SIN2W+160./9.*SIN2W**2)*FEPS
        HGAM=HGAM+GAMWW
        HGAMS(29)=GAMWW
      ENDIF
C          W* and Z* mass limits
      DO 120 I=1,2
        ZSTARS(1,I)=0.
        DO 130 IW=2,4
          ZSTARS(IW,I)=AMASS(LISTW(IW))
          DO 140 IQ1=2,25
            IQ2=MATCH(IQ1,IW)
            IF(IQ2.EQ.0) GO TO 140
            IF(GOWW(IQ1,1).AND.GOWW(IQ2,2)) THEN
              AM12=AMASS(LISTJ(IQ1))+AMASS(LISTJ(IQ2))
              ZSTARS(IW,I)=MIN(ZSTARS(IW,I),AM12)
            ENDIF
140       CONTINUE
130     CONTINUE
120   CONTINUE
C
C          GM GM -- W loop term
      WM=WMASS(2)
      TAU=4.*WM**2/HMASS**2
      IF(TAU.GE.1.0) THEN
        FFR=(ASIN(1./SQRT(TAU)))**2
        FFI=0.
      ELSE
        ROOT=SQRT(1.-TAU)
        ROOTLN=ALOG((1.+ROOT)/(1.-ROOT))
        FFR=-0.25*(ROOTLN**2-PI**2)
        FFI=0.5*PI*ROOTLN
      ENDIF
      FR=2.+3.*TAU+3.*TAU*(2.-TAU)*FFR
      FI=3.*TAU*(2.-TAU)*FFI
C          Top loop term
      TM=AMASS(6)
      TAU=4.*TM**2/HMASS**2
      IF(TAU.GE.1.0) THEN
        FFR=(ASIN(1./SQRT(TAU)))**2
        FFI=0.
      ELSE
        ROOT=SQRT(1.-TAU)
        ROOTLN=ALOG((1.+ROOT)/(1.-ROOT))
        FFR=-0.25*(ROOTLN**2-PI**2)
        FFI=0.5*PI*ROOTLN
      ENDIF
      FR=FR-8./3.*TAU*(1.+(1.-TAU)*FFR)
      FI=FI-8./3.*TAU*(1.-TAU)*FFI
C          Total GM GM
      HGAMS(26)=ALFA**3/(256.*PI**2*SIN2W)*HMASS**3/WM**2*(FR**2+FI**2)
      HGAM=HGAM+HGAMS(26)
C
C          Calculate Higgs-gluon-gluon coupling
C
      ETAR=0.
      ETAI=0.
      DO 300 IQ=1,8
        AMQ=AMASS(IQ)
        IF(AMQ.LE.0.) GO TO 300
        RQ=(2.*AMQ/HMASS)**2
        IF(RQ.GE.1.) THEN
          ETAR=ETAR+.5*RQ*(1.+(1.-RQ)*ASIN(1./SQRT(RQ))**2)
        ELSE
          RQLOG=ALOG((1.+SQRT(1.-RQ))/(1.-SQRT(1.-RQ)))
          PHIR=.25*(RQLOG**2-PI**2)
          ETAR=ETAR+.5*RQ*(1.+(RQ-1.)*PHIR)
          PHII=.5*PI*RQLOG
          ETAI=ETAI+.5*RQ*(1.+(RQ-1.)*PHII)
        ENDIF
300   CONTINUE
      ETAHGG=ETAR**2+ETAI**2
C
      RETURN
      END
CDECK  ID>, SETHSS. 
      SUBROUTINE SETHSS
C
C          Set the MSSM Higgs parameters in /HCON/.
C          HMASS  = Higgs mass for HTYPE
C          HGAM   = Higgs width
C          HGAMSS = Higgs partial widths. Note HGAMSS is not
C                   necessarily diagonal for SUSY decays.
C          ZSTARS = minimum allowed mass for Z*
C
C          Note LISTSS(78) => W+, LISTSS(79) => W-, LISTSS(80) => Z0
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
C          LISTSS IDENT and JETTYPE codes
C       ISGL  ISUPL -ISUPL  ISDNL -ISDNL  ISSTL -ISSTL  ISCHL -ISCHL
C          1      2      3      4      5      6      7      8      9
C      ISBT1 -ISBT1  ISTP1 -ISTP1  ISUPR -ISUPR  ISDNR -ISDNR  ISSTR
C         10     11     12     13     14     15     16     17     18
C     -ISSTR  ISCHR -ISCHR  ISBT2 -ISBT2  ISTP2 -ISTP2   ISW1  -ISW1
C         19     20     21     22     23     24     25     26     27
C       ISW2  -ISW2   ISZ1   ISZ2   ISZ3   ISZ4  ISNEL -ISNEL   ISEL
C         28     29     30     31     32     33     34     35     36
C      -ISEL  ISNML -ISNML  ISMUL -ISMUL  ISNTL -ISNTL ISTAU1-ISTAU1
C         37     38     39     40     41     42     43     44     45
C       ISER  -ISER  ISMUR -ISMUR ISTAU2-ISTAU2      9      1     -1
C         46     47     48     49     50     51     52     53     54
C          2     -2      3     -3      4     -4      5     -5      6
C         55     56     57     58     59     60     61     62     63
C         -6     11    -11     12    -12     13    -13     14    -14
C         64     65     66     67     68     69     70     71     72
C         15    -15     16    -16     10     80    -80     90   ISHL
C         73     74     75     76     77     78     79     80     81
C       ISHH   ISHA   ISHC  -ISHC
C         82     83     84     85
      COMMON/LISTSS/LISTSS(85)
      INTEGER LISTSS
      SAVE /LISTSS/
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
C          MXSS                 = maximum number of modes
C          NSSMOD               = number of modes
C          ISSMOD               = initial particle
C          JSSMOD               = final particles
C          GSSMOD               = width
C          BSSMOD               = branching ratio
      INTEGER MXSS
      PARAMETER (MXSS=1000)
      COMMON/SSMODE/NSSMOD,ISSMOD(MXSS),JSSMOD(5,MXSS),GSSMOD(MXSS)
     $,BSSMOD(MXSS)
      INTEGER NSSMOD,ISSMOD,JSSMOD
      REAL GSSMOD,BSSMOD
      SAVE /SSMODE/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
C
      REAL AMASS
      REAL AM12
      INTEGER I,J,N,IQ1,IQ2,IW,K
      INTEGER LISTJ(25),LISTW(4)
C
      DATA LISTJ/9,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,
     $11,-11,12,-12,13,-13,14,-14,15,-15,16,-16/
      DATA LISTW/10,80,-80,90/
C
C          Initialize
C
      IF(IHTYPE.EQ.0) THEN
        WRITE(ITLIS,*) ' YOU MUST SELECT AN HTYPE FOR SUSY HIGGS'
        WRITE(ITLIS,*) ' JOB TERMINATED'
        STOP99
      ENDIF
      HMASS=AMASS(IHTYPE)
      HGAM=0.
      DO 100 I=1,85
        DO 110 J=1,85
          HGAMSS(I,J)=0
110     CONTINUE
100   CONTINUE
C
C          Extract widths from SSMODE common block
C          Note the only 3-body modes are Zff or Wff
C          These are added to the ZZ and WW entries in HCONSS,
C          and the Z* or W* decay is generated later, as for SM Higgs
C
      DO 200 N=1,NSSMOD
        IF(ISSMOD(N).NE.IHTYPE) GO TO 200
        HGAM=HGAM+GSSMOD(N)
        IF(JSSMOD(3,N).NE.0) THEN
C          3-body modes
          IF(IABS(JSSMOD(1,N)).EQ.80) THEN
            HGAMSS(78,79)=HGAMSS(78,79)+0.5*GSSMOD(N)
            HGAMSS(79,78)=HGAMSS(79,78)+0.5*GSSMOD(N)
          ELSEIF(JSSMOD(1,N).EQ.90) THEN
            HGAMSS(80,80)=HGAMSS(80,80)+GSSMOD(N)
          ELSE
            WRITE(ITLIS,1000) ISSMOD(N),(JSSMOD(K,N),K=1,5)
1000        FORMAT(' SETHSS: UNEXPECTED MODE ',I8,' --> ',5I8)
            STOP 99
          ENDIF
          GO TO 200
        ELSE
C          2-body modes
          DO 210 I=1,85
            IF(JSSMOD(1,N).NE.LISTSS(I)) GO TO 210
            DO 220 J=1,85
              IF(JSSMOD(2,N).NE.LISTSS(J)) GO TO 220
              HGAMSS(I,J)=HGAMSS(I,J)+.5*GSSMOD(N)
              HGAMSS(J,I)=HGAMSS(J,I)+.5*GSSMOD(N)
              GO TO 200
220         CONTINUE
210       CONTINUE
        ENDIF
        WRITE(ITLIS,1000) ISSMOD(N),(JSSMOD(K,N),K=1,5)
        STOP99
200   CONTINUE
C
C          W* and Z* mass limits
C
      DO 300 I=1,2
        ZSTARS(1,I)=0.
        DO 310 IW=2,4
          ZSTARS(IW,I)=AMASS(LISTW(IW))
          DO 320 IQ1=2,25
            IQ2=MATCH(IQ1,IW)
            IF(IQ2.EQ.0) GO TO 320
            IF(GOWW(IQ1,I).AND.GOWW(IQ2,I)) THEN
              AM12=AMASS(LISTJ(IQ1))+AMASS(LISTJ(IQ2))+1.0
              ZSTARS(IW,I)=MIN(ZSTARS(IW,I),AM12)
            ENDIF
320       CONTINUE
310     CONTINUE
300   CONTINUE
      RETURN
      END
CDECK  ID>, SETNXT. 
      SUBROUTINE SETNXT
C
C            RESET LIMITS BEFORE NEXT SET
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/LSTPRT/LSTPRT
      SAVE /LSTPRT/
      INTEGER   LSTPRT
      COMMON/TOTALS/NKINPT,NWGEN,NKEEP,SUMWT,WT
      SAVE /TOTALS/
      INTEGER   NKINPT,NWGEN,NKEEP
      REAL      SUMWT,WT
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      DATA UNDEF/-1.E9/
      DO 1 I=1,36
      IF(SETLMJ(I)) BLIMS(I)=UNDEF
    1 CONTINUE
      DO 2 I=1,12
      IF(SETLMQ(I)) BLIM1(I)=UNDEF
    2 CONTINUE
C          RESET /TOTALS/
      NKINPT=0
      NWGEN=0
      NKEEP=0
      SUMWT=0.
C          RESET /LSTPRT/
      LSTPRT=0
C          RESET NJSET AND NPTCL
      NJSET=0
      NPTCL=0
      NPAIR=0
      RETURN
      END
CDECK  ID>, SETTYP. 
      LOGICAL FUNCTION SETTYP(LPRT)
C
C          Set JETTYPE flags and WMODE flags for WPAIR.
C          Set WMODES and ZMODES flags for secondary W+- and Z0.
C          Return .FALSE. if no error, .TRUE. otherwise.
C
C          Ver 7.18: Initialize all GOQ to false (limit = MXGOQ)
C                    Use LISTSS for Higgs if GOMSSM
C          Ver 7.29: SUSY Higgs decays are done in SETHSS and SIGHSS
C                    using LISTSS order, so SUSY list should be used.
C                    I.e., 7.18 fix was wrong.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/TYPES/LOC(100),NTYP,NJTTYP(3),NWWTYP(2),NWMODE(3)
      COMMON/XTYPES/PARTYP(40),TITLE(10),JETYP(30,3),WWTYP(30,2)
     $,WMODES(30,3)
      SAVE /TYPES/,/XTYPES/
      CHARACTER*8 JETYP,WWTYP,TITLE,PARTYP,WMODES
      INTEGER   LOC,NTYP,NJTTYP,NWWTYP,NWMODE
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C
      INTEGER JET,K,I,IW,LPRT
      INTEGER NLIST
      CHARACTER*8 WORD,BLANK,LIST(29),LISTW(4),LISTXY(4),LISTSS(85)
      DATA BLANK/'        '/
      DATA LIST/'GL','UP','UB','DN','DB','ST','SB','CH','CB','BT','BB',
     $'TP','TB','NUE','ANUE','E-','E+','NUM','ANUM','MU-','MU+',
     $'NUT','ANUT','TAU-','TAU+','GM','W+','W-','Z0'/
      DATA LISTW/'GM','W+','W-','Z0'/
      DATA LISTXY/'Y','YB','X','XB'/
      DATA LISTSS/'GLSS',
     $'UPSSL','UBSSL','DNSSL','DBSSL','STSSL','SBSSL','CHSSL','CBSSL',
     $'BTSS1','BBSS1','TPSS1','TBSS1',
     $'UPSSR','UBSSR','DNSSR','DBSSR','STSSR','SBSSR','CHSSR','CBSSR',
     $'BTSS2','BBSS2','TPSS2','TBSS2',
     $'W1SS+','W1SS-','W2SS+','W2SS-','Z1SS','Z2SS','Z3SS','Z4SS',
     $'NUEL','ANUEL','EL-','EL+','NUML','ANUML','MUL-','MUL+',
     $'NUTL','ANUTL','TAU1-','TAU1+','ER-','ER+','MUR-','MUR+',
     $'TAU2-','TAU2+',
     $'GL','UP','UB','DN','DB','ST','SB','CH','CB','BT','BB',
     $'TP','TB','NUE','ANUE','E-','E+','NUM','ANUM','MU-','MU+',
     $'NUT','ANUT','TAU-','TAU+','GM','W+','W-','Z0',
     $'HL0','HH0','HA0','H+','H-'/
C
      SETTYP=.FALSE.
C
      IF(KEYS(5)) GO TO 5
      IF(KEYS(2).AND.GOMSSM) GO TO 5
      IF(KEYS(6).OR.KEYS(9)) GO TO 6
      IF(KEYS(7).AND..NOT.GOMSSM) GO TO 7
      IF(KEYS(7).AND.GOMSSM) GO TO 5
C
C          JETTYPE flags all processes except WPAIR and HIGGS.
C          NJTTYP is set in READIN to number of non-blank values read.
C          Check for legal jet type names and set appropriate flags.
C
      DO 1000 JET=1,3
        IF(NJTTYP(JET).EQ.0) GO TO 1000
C          Initialize everything to .FALSE.
        GOALL(JET)=.FALSE.
        DO 1100 K=1,MXGOQ
          GOQ(K,JET)=.FALSE.
1100    CONTINUE
C          Loop over non-blank JETTYPE entries
        DO 1200 I=1,NJTTYP(JET)
          WORD=JETYP(I,JET)
C          Blank
          IF(WORD.EQ.BLANK) THEN
            GO TO 1200
          ENDIF
C          All
          IF(WORD.EQ.'ALL     ') THEN
            GOALL(JET)=.TRUE.
            DO 1210 K=1,MXGOQ
1210        GOQ(K,JET)=.TRUE.
            GO TO 1000
          ENDIF
C          Quarks
          IF(WORD.EQ.'QUARKS  ') THEN
            DO 1220 K=2,13
1220        GOQ(K,JET)=.TRUE.
            GO TO 1200
          ENDIF
C          Charged leptons
          IF(WORD.EQ.'LEPTONS ') THEN
            DO 1230 K=16,24,4
            GOQ(K,JET)=.TRUE.
1230        GOQ(K+1,JET)=.TRUE.
            GO TO 1200
          ENDIF
C          Neutrinos
          IF(WORD.EQ.'NUS     ') THEN
            DO 1240 K=14,22,4
            GOQ(K,JET)=.TRUE.
1240        GOQ(K+1,JET)=.TRUE.
            GO TO 1200
          ENDIF
C          Explicit types
C          E+E- now also contains W+, W-, Z0
          IF(KEYS(2)) THEN
            NLIST=29
          ELSE
            NLIST=25
          ENDIF
          DO 1250 K=1,NLIST
            IF(WORD.EQ.LIST(K)) THEN
              GOQ(K,JET)=.TRUE.
              GO TO 1200
            ENDIF
1250      CONTINUE
C          Special types for TWOJET
          DO 1270 K=1,4
            IF(KEYS(1).AND.WORD.EQ.LISTXY(K)) THEN
              GOQ(13+K,JET)=.TRUE.
              GO TO 1200
            ENDIF
1270      CONTINUE
C          Special type for PHOTON
          IF(KEYS(8).AND.WORD.EQ.LISTW(1)) THEN
            GOQ(26,JET)=.TRUE.
            GO TO 1200
          ENDIF
C          Error
          WRITE(ITLIS,1300) WORD,JET
1300      FORMAT(1X,A8,' IS NOT RECOGNIZABLE FOR JETTYPE',I1)
          SETTYP=.TRUE.
1200    CONTINUE
1000  CONTINUE
      GO TO 4000
C
C          JETTYPE flags for SUSY
C
5     DO 5000 JET=1,2
        IF(NJTTYP(JET).EQ.0) GO TO 5000
        GOALL(JET)=.FALSE.
        DO 5100 K=1,MXGOQ
5100    GOQ(K,JET)=.FALSE.
        DO 5200 I=1,NJTTYP(JET)
          WORD=JETYP(I,JET)
C          Blank
          IF(WORD.EQ.BLANK) THEN
            GO TO 5200
          ENDIF
C          All
          IF(WORD.EQ.'ALL     ') THEN
            GOALL(JET)=.TRUE.
            DO 5210 K=1,85
5210        GOQ(K,JET)=.TRUE.
            GO TO 5000
          ENDIF
C          Squarks
          IF(WORD.EQ.'SQUARKS ') THEN
            DO 5220 K=2,25
5220        GOQ(K,JET)=.TRUE.
            GO TO 5200
          ENDIF
C           Gauginos
          IF(WORD.EQ.'GAUGINOS') THEN
            DO 5230 K=26,33
5230        GOQ(K,JET)=.TRUE.
            GO TO 5200
          ENDIF
C           Sleptons
          IF(WORD.EQ.'SLEPTONS') THEN
            DO 5240 K=34,51
5240        GOQ(K,JET)=.TRUE.
            GO TO 5200
          ENDIF
C          Explicit susy types
          DO 5300 K=1,85
            IF(WORD.EQ.LISTSS(K)) THEN
              GOQ(K,JET)=.TRUE.
              GO TO 5200
            ENDIF
5300      CONTINUE
5200    CONTINUE
5000  CONTINUE
      GO TO 4000
C
C          JETTYPE and WMODE flags for WPAIR
C          NJTTYP and NWWTYP are the number of non-blank values.
C
6     DO 2000 JET=1,2
        IF(NJTTYP(JET).EQ.0) GO TO 2300
C          Initialize to FALSE
        GOALL(JET)=.FALSE.
        DO 2100 K=1,4
2100    GOQ(K,JET)=.FALSE.
C
C          Loop over non-blank JETTYPE flags
C
        DO 2200 I=1,NJTTYP(JET)
          WORD=JETYP(I,JET)
C          Blank
          IF(WORD.EQ.BLANK) THEN
            GO TO 2200
          ENDIF
C          All
          IF(WORD.EQ.'ALL     ') THEN
            GOALL(JET)=.TRUE.
            DO 2210 K=1,4
2210        GOQ(K,JET)=.TRUE.
            GO TO 2300
          ENDIF
C          Explicit types
          DO 2220 K=1,4
            IF(WORD.EQ.LISTW(K)) THEN
              GOQ(K,JET)=.TRUE.
              GO TO 2200
            ENDIF
2220      CONTINUE
C          Error
          WRITE(ITLIS,1300) WORD,JET
          SETTYP=.TRUE.
2200    CONTINUE
C
C          Loop over nonblank WMODE flags
C
2300    IF(NWWTYP(JET).EQ.0) GO TO 2000
        ALLWW(JET)=.FALSE.
C         Initialize everything to FALSE
        DO 2350 K=1,25
2350    GOWW(K,JET)=.FALSE.
C
        DO 2400 I=1,NWWTYP(JET)
          WORD=WWTYP(I,JET)
          IF(WORD.NE.BLANK) NWWTYP(JET)=I
C          Blank
          IF(WORD.EQ.BLANK) THEN
            GO TO 2400
          ENDIF
C          All
          IF(WORD.EQ.'ALL     ') THEN
            ALLWW(JET)=.TRUE.
            DO 2410 K=1,25
2410        GOWW(K,JET)=.TRUE.
            GO TO 2000
          ENDIF
C          Quarks
          IF(WORD.EQ.'QUARKS  ') THEN
            DO 2420 K=2,13
2420        GOWW(K,JET)=.TRUE.
            GO TO 2400
          ENDIF
C          Charged leptons
          IF(WORD.EQ.'LEPTONS ') THEN
            DO 2430 K=16,24,4
            GOWW(K,JET)=.TRUE.
2430        GOWW(K+1,JET)=.TRUE.
            GO TO 2400
          ENDIF
C          Neutrinos
          IF(WORD.EQ.'NUS     ') THEN
            DO 2440 K=14,22,4
            GOWW(K,JET)=.TRUE.
2440        GOWW(K+1,JET)=.TRUE.
            GO TO 2400
          ENDIF
C          Explicit types
          DO 2450 K=1,25
            IF(WORD.EQ.LIST(K)) THEN
              GOWW(K,JET)=.TRUE.
              GO TO 2400
            ENDIF
2450      CONTINUE
C          Error
          WRITE(ITLIS,2500) WORD,JET
2500      FORMAT(1X,A8,' IS NOT A VALID CODE FOR WMODE',I1)
          SETTYP=.TRUE.
2400    CONTINUE
2000  CONTINUE
      GO TO 4000
C
C          JETTYPE and WMODE flags for HIGGS
C          SUSY HIGGS uses LISTSS order and hence SUSY part
C
7     DO 3000 JET=1,2
        IF(NJTTYP(JET).EQ.0) GO TO 3300
C          Initialize to FALSE
        GOALL(JET)=.FALSE.
        DO 3100 K=1,MXGOQ
3100    GOQ(K,JET)=.FALSE.
C
C          Loop over non-blank JETTYPE flags
C
        DO 3200 I=1,NJTTYP(JET)
          WORD=JETYP(I,JET)
C          Blank
          IF(WORD.EQ.BLANK) THEN
            GO TO 3200
          ENDIF
C          All
          IF(WORD.EQ.'ALL     ') THEN
            GOALL(JET)=.TRUE.
            DO 3210 K=1,MXGOQ
3210        GOQ(K,JET)=.TRUE.
            GO TO 3300
          ENDIF
C          Quarks
          IF(WORD.EQ.'QUARKS  ') THEN
            DO 3220 K=2,13
3220        GOQ(K,JET)=.TRUE.
            GO TO 3200
          ENDIF
C          Charged leptons
          IF(WORD.EQ.'LEPTONS ') THEN
            DO 3240 K=16,24,4
            GOQ(K,JET)=.TRUE.
3240        GOQ(K+1,JET)=.TRUE.
            GO TO 3200
          ENDIF
          DO 3250 K=1,85
            IF(WORD.EQ.LIST(K)) THEN
              GOQ(K,JET)=.TRUE.
              GO TO 3200
            ENDIF
3250      CONTINUE
C          Error
          WRITE(ITLIS,1300) WORD,JET
          SETTYP=.TRUE.
3200    CONTINUE
C
C          Loop over nonblank WMODE flags
C
3300    IF(NWWTYP(JET).EQ.0) GO TO 3000
        ALLWW(JET)=.FALSE.
C         Initialize everything to FALSE
        DO 3350 K=1,25
3350    GOWW(K,JET)=.FALSE.
C
        DO 3400 I=1,NWWTYP(JET)
          WORD=WWTYP(I,JET)
          IF(WORD.NE.BLANK) NWWTYP(JET)=I
C          Blank
          IF(WORD.EQ.BLANK) THEN
            GO TO 3400
          ENDIF
C          All
          IF(WORD.EQ.'ALL     ') THEN
            ALLWW(JET)=.TRUE.
            DO 3410 K=1,25
3410        GOWW(K,JET)=.TRUE.
            GO TO 3000
          ENDIF
C          Quarks
          IF(WORD.EQ.'QUARKS  ') THEN
            DO 3420 K=2,13
3420        GOWW(K,JET)=.TRUE.
            GO TO 3400
          ENDIF
C          Charged leptons
          IF(WORD.EQ.'LEPTONS ') THEN
            DO 3430 K=16,24,4
            GOWW(K,JET)=.TRUE.
3430        GOWW(K+1,JET)=.TRUE.
            GO TO 3400
          ENDIF
C          Neutrinos
          IF(WORD.EQ.'NUS     ') THEN
            DO 3440 K=14,22,4
            GOWW(K,JET)=.TRUE.
3440        GOWW(K+1,JET)=.TRUE.
            GO TO 3400
          ENDIF
C          Explicit types
          DO 3450 K=1,25
            IF(WORD.EQ.LIST(K)) THEN
              GOWW(K,JET)=.TRUE.
              GO TO 3400
            ENDIF
3450      CONTINUE
C          Error
          WRITE(ITLIS,2500) WORD,JET
3500      FORMAT(1X,A8,' IS NOT A VALID CODE FOR WMODE',I1)
          SETTYP=.TRUE.
3400    CONTINUE
3000  CONTINUE
C
C          Set WMODES and ZMODES flags for secondary W+- and Z0
C
4000  DO 4100 IW=1,3
        IF(NWMODE(IW).EQ.0) GO TO 4100
C           Initialize everything to .FALSE.
        DO 4200 K=1,25
4200    GOWMOD(K,IW)=.FALSE.
C          Loop over non-blank WMODE entries
        DO 4300 I=1,NWMODE(IW)
          WORD=WMODES(I,IW)
C          Blank
          IF(WORD.EQ.BLANK) THEN
            GO TO 4300
          ENDIF
C          All
          IF(WORD.EQ.'ALL     ') THEN
            DO 4310 K=1,25
4310        GOWMOD(K,IW)=.TRUE.
            GO TO 4100
          ENDIF
C          Quarks
          IF(WORD.EQ.'QUARKS  ') THEN
            DO 4320 K=2,13
4320        GOWMOD(K,IW)=.TRUE.
            GO TO 4300
          ENDIF
C          Charged leptons
          IF(WORD.EQ.'LEPTONS ') THEN
            DO 4330 K=16,24,4
            GOWMOD(K,IW)=.TRUE.
4330        GOWMOD(K+1,IW)=.TRUE.
            GO TO 4300
          ENDIF
C          Neutrinos
          IF(WORD.EQ.'NUS     ') THEN
            DO 4340 K=14,22,4
            GOWMOD(K,IW)=.TRUE.
4340        GOWMOD(K+1,IW)=.TRUE.
            GO TO 4300
          ENDIF
C          Explicit types
          DO 4350 K=1,25
            IF(WORD.EQ.LIST(K)) THEN
              GOWMOD(K,IW)=.TRUE.
              GO TO 4300
            ENDIF
4350      CONTINUE
C          Error
          WRITE(ITLIS,4380) WORD
4380      FORMAT(1X,A8,' IS NOT RECOGNIZABLE FOR SECONDARY WS')
          SETTYP=.TRUE.
4300    CONTINUE
4100  CONTINUE
      RETURN
      END
CDECK  ID>, SETW.   
      SUBROUTINE SETW
C
C          Set the W parameters in /WCON/.
C          SIN2W         = sin**2(theta-sub-w)
C          AQ, BQ        = vector, axial couplings normalized to ALFA.
C          MATCH(IQ1,IW) = Cabibbo favored type for W --> QK1 + QK2.
C          WCBR(IQ,IW)   = cumulative branching ratio for JETTYP(1)=IQ
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/QLMASS/AMLEP(100),NQLEP,NMES,NBARY
      SAVE /QLMASS/
      INTEGER   NQLEP,NMES,NBARY
      REAL      AMLEP
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/NODCAY/NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      SAVE /NODCAY/
      LOGICAL NODCAY,NOETA,NOPI0,NONUNU,NOEVOL,NOHADR,NOGRAV
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C
      REAL SINW,COSW,AMW,AMZ,AW,FACZ,GAMW,GAMZ,TERM,SUM,AM1,AMASS,AM2
      INTEGER I1,I2,I3,J,INDEX,IFL,NGAM,NUP,IW,IQ1,IQ2,IFL1,JET,IQ,IFL2
      INTEGER IW1
      REAL T3(12),EQ3(12)
      INTEGER NUTYP(25),LISTJ(25)
      DOUBLE PRECISION SIN2WD,SINWD,COSWD,AWD,FACZD
      DATA T3/.5,-.5,-.5,.5,-.5,.5,.5,-.5,.5,-.5,.5,-.5/
      DATA EQ3/2.,-1.,-1.,2.,-1.,2.,0.,-3.,0.,-3.,0.,-3./
      DATA NUTYP/13*0,1,1,0,0,1,1,0,0,1,1,0,0/
      DATA LISTJ/9,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,
     $11,-11,12,-12,13,-13,14,-14,15,-15,16,-16/
C
C          Masses can be changed with WMASS
C
      SINW=SQRT(SIN2W)
      COSW=SQRT(1.-SIN2W)
      AMW=WMASS(2)
      AMZ=WMASS(4)
C
C          Couplings for Weinberg-Salam model
C
      AW=1./(2.*SQRT2*SINW)
      FACZ=1./(2.*SINW*COSW)
      EZ=SQRT((1.-SIN2W)/SIN2W)
      DO 110 IFL=1,12
        AQ(IFL,1)=EQ3(IFL)/3.
        BQ(IFL,1)=0.
        AQ(IFL,2)=AW
        BQ(IFL,2)=AW
        AQ(IFL,3)=AW
        BQ(IFL,3)=AW
        AQ(IFL,4)=FACZ*(T3(IFL)-2.*EQ3(IFL)/3.*SIN2W)
        BQ(IFL,4)=FACZ*T3(IFL)
110   CONTINUE
C          Double precision couplings for 32-bit machines.
      SIN2WD=SIN2W
      SINWD=DSQRT(SIN2WD)
      COSWD=DSQRT(1.-SIN2WD)
      AWD=1./(2.*DSQRT(2.D0)*SINWD)
      FACZD=1./(2.*SINWD*COSWD)
      EZDP=COSWD/SINWD
      DO 120 IFL=1,12
        AQDP(IFL,1)=EQ3(IFL)/3.D0
        BQDP(IFL,1)=0.
        AQDP(IFL,2)=AWD
        BQDP(IFL,2)=AWD
        AQDP(IFL,3)=AWD
        BQDP(IFL,3)=AWD
        AQDP(IFL,4)=FACZD*(T3(IFL)-2.D0*EQ3(IFL)/3.D0*SIN2WD)
        BQDP(IFL,4)=FACZD*T3(IFL)
120   CONTINUE
C
C          Widths
C
      NGAM=12
      IF(AMLEP(5)+AMLEP(6).GT.AMW) NGAM=9
      GAMW=GF*AMW**3/(6.*PI*SQRT2)*NGAM
      NUP=3
      IF(2.*AMLEP(6).GT.AMZ) NUP=2
      GAMZ=NUP*3.*(AQ(1,4)**2+BQ(1,4)**2)+3.*3.*(AQ(2,4)**2+BQ(2,4)**2)
     1+3.*(AQ(7,4)**2+BQ(7,4)**2+AQ(8,4)**2+BQ(8,4)**2)
      GAMZ=GAMZ*2./FACZ**2
      GAMZ=GAMZ*GF*AMZ**3/(12.*PI*SQRT2)
      WGAM(1)=0.
      WGAM(2)=GAMW
      WGAM(3)=GAMW
      WGAM(4)=GAMZ
C
C          Branching ratios for secondary W+- and Z0
C
      DO 210 IW=2,4
        IW1=IW-1
        SUM=0.
        CUMWBR(1,IW1)=0.
        DO 220 IQ1=2,25
          CUMWBR(IQ1,IW1)=CUMWBR(IQ1-1,IW1)
          IQ2=MATCH(IQ1,IW)
          IF(IQ2.EQ.0) GO TO 220
          IF(.NOT.(GOWMOD(IQ1,IW-1).AND.GOWMOD(IQ2,IW-1))) GO TO 220
          IFL1=LISTJ(IQ1)
          IFL2=LISTJ(IQ2)
          AM1=AMASS(IFL1)
          AM2=AMASS(IFL2)
          IF(AM1+AM2.GE.WMASS(IW)) GO TO 220
          TERM=AQ(IQ1/2,IW)**2+BQ(IQ1/2,IW)**2
          IF(IQ1.LE.13) TERM=3.*TERM
          CUMWBR(IQ1,IW1)=CUMWBR(IQ1-1,IW1)+TERM
          SUM=SUM+TERM
220     CONTINUE
        IF(SUM.LE.0.) THEN
          WRITE(ITLIS,2000) IW
2000      FORMAT(//' ***** NO ALLOWED DECAY MODE FOR SECONDARY W TYPE',
     $    I2,' *****')
          STOP 99
        ENDIF
        DO 230 IQ1=2,25
          CUMWBR(IQ1,IW1)=CUMWBR(IQ1,IW1)/SUM
230     CONTINUE
210   CONTINUE
C
C          Decay channels for DRELLYAN
C
      IF(KEYS(3)) THEN
        DO 310 IW=1,4
          COUT(IW)=0.
          IF(.NOT.GODY(IW)) GO TO 310
          DO 320 IQ1=2,25
            IQ2=MATCH(IQ1,IW)
            IF(IQ2.EQ.0) GO TO 320
            IF(.NOT.(GOQ(IQ1,1).AND.GOQ(IQ2,2))) GO TO 320
            IF(NUTYP(IQ1)*NUTYP(IQ2).EQ.1.AND.NONUNU) GO TO 320
            IFL1=IQ1/2
            TERM=.5*(AQ(IFL1,IW)**2+BQ(IFL1,IW)**2)
            IF(IQ1.LE.13) TERM=3.*TERM
            COUT(IW)=COUT(IW)+TERM
320       CONTINUE
          IF(COUT(IW).EQ.0.) THEN
            WRITE(ITLIS,3000) IW
3000        FORMAT(//' ***** ERROR IN SETW ... NO ALLOWED DECAY MODE ',
     $      'FOR W TYPE',I2,' *****')
            STOP 99
          ENDIF
310     CONTINUE
C          W branching ratios
        DO 330 IW=1,4
          IF(.NOT.GODY(IW)) GO TO 330
          SUM=0.
          DO 340 IQ1=1,25
            WCBR(IQ1,IW)=SUM
            IQ2=MATCH(IQ1,IW)
            IF(IQ2.EQ.0) GO TO 340
            IF(.NOT.(GOQ(IQ1,1).AND.GOQ(IQ2,2))) GO TO 340
            IF(NUTYP(IQ1)*NUTYP(IQ2).EQ.1.AND.NONUNU) GO TO 340
            IFL1=IQ1/2
            TERM=.5*(AQ(IFL1,IW)**2+BQ(IFL1,IW)**2)/COUT(IW)
            IF(IQ1.LE.13) TERM=3.*TERM
            SUM=SUM+TERM
            WCBR(IQ1,IW)=SUM
340       CONTINUE
330     CONTINUE
      ENDIF
C
C          Calculate branching ratios for WPAIR events summed over
C          modes allowed by WMODE cards.
C          TBRWW = total allowed branching ratio.
C          RBRWW = relative branching ratios.
C          TBRWW*RBRWW = physical branching ratios.
C
      IF((KEYS(2).AND.(.NOT.GOMSSM)).OR.KEYS(6)
     ,.OR.KEYS(7).OR.KEYS(9)) THEN
        DO 400 JET=1,2
          TBRWW(1,JET)=1.
          DO 410 IW=2,4
            TBRWW(IW,JET)=0.
            IF(KEYS(6).OR.KEYS(9)) THEN
              IF(.NOT.GOQ(IW,JET)) GO TO 410
            ELSEIF(KEYS(2).OR.(KEYS(7).AND..NOT.GOMSSM)) THEN
              IF(.NOT.GOQ(IW+25,JET)) GO TO 410
            ELSEIF(KEYS(7).AND.GOMSSM) THEN
              IF(.NOT.GOQ(IW+76,JET)) GO TO 410
            ENDIF
            SUM=0.
            DO 420 IQ=1,12
              RBRWW(IQ,IW,JET)=0.
              IQ1=2*IQ
              IQ2=MATCH(IQ1,IW)
              IF(IQ2.EQ.0) GO TO 420
              IFL1=IQ1/2
              IF(IQ1.GT.13) IFL1=IFL1+4
              IFL2=IQ2/2
              IF(IQ2.GT.13) IFL2=IFL2+4
              AM1=AMASS(IFL1)
              AM2=AMASS(IFL2)
              IF(AM1+AM2.GE.WMASS(IW)) GO TO 420
              TERM=AQ(IQ1/2,IW)**2+BQ(IQ1/2,IW)**2
              IF(IQ1.LE.13) TERM=3*TERM
              SUM=SUM+TERM
              IF(.NOT.(GOWW(IQ1,JET).AND.GOWW(IQ2,JET))) GO TO 420
              RBRWW(IQ,IW,JET)=TERM
              TBRWW(IW,JET)=TBRWW(IW,JET)+TERM
420         CONTINUE
            TBRWW(IW,JET)=TBRWW(IW,JET)/SUM
            IF(TBRWW(IW,JET).GT.0.) THEN
              DO 430 IQ=1,12
430           RBRWW(IQ,IW,JET)=RBRWW(IQ,IW,JET)/(SUM*TBRWW(IW,JET))
            ELSE
              WRITE(ITLIS,445) IW,JET
445           FORMAT(/' ***** NO ALLOWED MODE FOR W TYPE ',I2,
     $        ' IN JET ',I2,' *****'/)
              STOP 99
            ENDIF
410       CONTINUE
400   CONTINUE
      ENDIF
      RETURN
      END
CDECK  ID>, SIGDY.  
      SUBROUTINE SIGDY
C
C          Compute the Drell-Yan and Drell-Yan plus jet cross sections
C          d(sigma)/d(qmw**2)d(qtw**2)d(yw)d(yj)
C
C          SIGMA    = cross section summed over quark types allowed by
C                     JETTYPE3 and WTYPE cards.
C          SIGS(I)  = partial cross section for I1 + I2 --> I3 + I4.
C          INOUT(I) = IOPAK**3*I4 + IOPAK**2*I3 + IOPAK*I2 + I1
C                     using JETTYPE code.
C
C          QT cutoff for W+JET taken from Parisi and Petronzio,
C          Nucl Phys B154, 427
C          qk + gl --> qk + w suppressed at low QTW by extra factor
C          of qtw**2/(qtw**2+qt2cut(qmw))
C
C          Ver 7.17: include top mass for gb --> Wt and gt --> Zt
C          with no extra qt suppression factor. Note we do NOT include
C          gt --> Wb; while this process makes sense for qt >> m_t,
C          it has a pole in the physical region at low qt from the
C          on-shell decay t --> Wb. We let Q**2 --> Q**2 + m_t**2
C          in the scale for the parton distributions.
C
C          Ver 7.32: Rewrite AJLWT for gb --> Wt, etc., in terms of
C          scaled variables, and restore SWT**5 later to avoid
C          floating errors on VMS.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/QSAVE/QSAVE(29,2)
      SAVE /QSAVE/
      REAL      QSAVE
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
C
      REAL X(2)
      REAL Z,S,T,U,QMW2,QZW,EHAT,Q2SAVE,YHAT,EY,P3Z,P1,P2,AMASS,ANEFF,
     $SIG0,DENOM,QT2CUT,SIGT,SIGU,FAC,PROP,FACTOR,SIG,AMT,AMT2,SWT,
     $P1WT,P2WT,X1WT,X2WT,TWT,UWT,Q2,QFCN,STRUC,XX,ACOSH,ATANH,P2M,P1M
      REAL AMI2,AMF2,EFWT
      REAL AJLWT,AJLZT1,AJLZT2,A2,A2B2,QQ,TM2
      INTEGER I,IQ,IH,IQ1,IFL,IQ2,IW
      INTEGER NZERO(4)
      REAL AMFAC(13)
      EQUIVALENCE (S,SHAT),(T,THAT),(U,UHAT),(X(1),X1)
C
      DATA NZERO/11,9,9,11/
      DATA AMFAC/11*0.,2*1./
C
C          Functions
      ACOSH(Z)=ALOG(Z+SQRT(Z**2-1.))
      ATANH(Z)=.5*ALOG((1.+Z)/(1.-Z))
      PROP(I)=1./((QMW2-WMASS(I)**2)**2+(WMASS(I)*WGAM(I))**2)
C          Qt cutoff function
      QT2CUT(QMW)=CUTOFF*QMW**CUTPOW
C          Parton distributions
      QFCN(XX,IQ,IH)=STRUC(XX,QSQ+AMT2,IQ,IDIN(IH))/XX
C          Integrated matrix elements JLint from FORM
      AJLWT(S,T,QQ,TM2)=
     $ - 32*QQ**3*S*T + 32*QQ**3*S*TM2 + 32*QQ**2*S**2*T
     $ + 32*QQ**2*S*T**2 - 16*QQ**2*S*T*TM2 - 16*QQ**2*S*TM2**2
     $ - 16*QQ*S**3*T + 16*QQ*S**3*TM2 - 16*QQ*S**2*T*TM2
     $ - 16*QQ*S*T**3 + 32*QQ*S*T**2*TM2 - 16*QQ*S*T*TM2**2
     $ - 8*S**3*T*TM2 + 8*S**3*TM2**2 - 16*S**2*T**2*TM2
     $ + 16*S**2*T*TM2**2 - 16*S**2*TM2**3 - 8*S*T**3*TM2
     $ + 8*S*T**2*TM2**2 - 8*S*T*TM2**3 + 8*S*TM2**4
C
      AJLZT1(S,T,QQ,TM2)=
     $ + A2 * ( - 96*QQ**2*S*T*TM2 + 96*QQ**2*S*TM2**2
     $ + 96*QQ**2*T*TM2**2 - 96*QQ**2*TM2**3 + 96*QQ*S**2*T*TM2
     $ + 96*QQ*S*T**2*TM2 - 192*QQ*S*T*TM2**2 - 96*QQ*S*TM2**3
     $ - 96*QQ*T*TM2**3 + 192*QQ*TM2**4 + 16*S**3*T*TM2
     $ - 16*S**3*TM2**2 + 32*S**2*T**2*TM2 - 112*S**2*T*TM2**2
     $ + 80*S**2*TM2**3 + 16*S*T**3*TM2 - 112*S*T**2*TM2**2
     $ + 224*S*T*TM2**3 - 128*S*TM2**4 - 16*T**3*TM2**2
     $ + 80*T**2*TM2**3 - 128*T*TM2**4 + 64*TM2**5 )
      AJLZT2(S,T,QQ,TM2)=
     $ + A2B2 * ( - 16*QQ**3*S*T + 16*QQ**3*S*TM2 + 16*QQ**3*T*TM2
     $ - 16*QQ**3*TM2**2 + 16*QQ**2*S**2*T + 16*QQ**2*S*T**2
     $ + 32*QQ**2*S*T*TM2 - 80*QQ**2*S*TM2**2 - 80*QQ**2*T*TM2**2
     $ + 96*QQ**2*TM2**3 - 8*QQ*S**3*T + 8*QQ*S**3*TM2
     $ - 40*QQ*S**2*T*TM2 - 24*QQ*S**2*TM2**2 - 8*QQ*S*T**3
     $ - 40*QQ*S*T**2*TM2 + 80*QQ*S*T*TM2**2 + 96*QQ*S*TM2**3
     $ + 8*QQ*T**3*TM2 - 24*QQ*T**2*TM2**2 + 96*QQ*T*TM2**3
     $ - 144*QQ*TM2**4 - 16*S**3*T*TM2 + 16*S**3*TM2**2
     $ - 32*S**2*T**2*TM2 + 112*S**2*T*TM2**2 - 80*S**2*TM2**3
     $ - 16*S*T**3*TM2 + 112*S*T**2*TM2**2 - 224*S*T*TM2**3
     $ + 128*S*TM2**4 + 16*T**3*TM2**2 - 80*T**2*TM2**3
     $ + 128*T*TM2**4 - 64*TM2**5 )
C
C          Kinematics
C
      QMW2=QMW**2
      QTMW=SQRT(QMW2+QTW**2)
      Q0W=QTMW*COSH(YW)
      QZW=QTMW*SINH(YW)
      QW=SQRT(QZW**2+QTW**2)
C          Protect against errors
      IF(QW.NE.0.) THEN
        CTHW=QZW/QW
        STHW=QTW/QW
        IF(ABS(CTHW).LT.1.) THEN
          THW=ACOS(CTHW)
        ELSE
          CTHW=0.
          STHW=1.
          THW=.5*PI
        ENDIF
      ELSE
        CTHW=0.
        STHW=1.
        THW=.5*PI
      ENDIF
C
      IF(STDDY) THEN
C          Kinematics for standard Drell-Yan
        EHAT=QMW
        SHAT=QMW**2
        QSQ=SHAT
        Q2SAVE=QSQ
        YHAT=YW
        EY=EXP(YHAT)
        X1=EHAT/ECM*EY
        X2=EHAT/(ECM*EY)
      ELSE
C          Kinematics for Drell-Yan plus jet
        P3Z=P(3)*CTH(3)
        SHAT=QMW2+2.*Q0W*P(3)-2.*QZW*P3Z+2.*PT(3)**2
        P1=.5*(P(3)+P3Z+Q0W+QZW)
        P2=.5*(P(3)-P3Z+Q0W-QZW)
        X1=P1/HALFE
        X2=P2/HALFE
        THAT=-2.*P1*(P(3)-P3Z)
        UHAT=-2.*P2*(P(3)+P3Z)
        QSQ=QTW**2
        QSQ=AMAX1(QSQ,4.)
        ANEFF=4.+QSQ/(QSQ+AMASS(5)**2)+QSQ/(QSQ+AMASS(6)**2)
        ALFQSQ=12.*PI/((33.-2.*ANEFF)*ALOG(QSQ/ALAM2))
        Q2SAVE=QSQ
        QSQ=SHAT
      ENDIF
C
C          Initialize
C
      SIGMA=0.
      NSIGS=0
      DO 100 I=1,MXSIGS
        SIGS(I)=0.
100   CONTINUE
      IF(X1.GE.1..OR.X2.GE.1.) RETURN
C
C          Compute structure functions
C
      DO 110 IH=1,2
        DO 120 IQ=1,11
          QSAVE(IQ,IH)=STRUC(X(IH),QSQ,IQ,IDIN(IH))/X(IH)
120     CONTINUE
        QSAVE(12,IH)=0
        QSAVE(13,IH)=0
110   CONTINUE
      QSQ=Q2SAVE
      IF(STDDY) GO TO 400
C
C          Compute cross section for types allowed by WTYPE and
C          JETTYPE cards.
C
C          qk + gl --> qk + W
C
      SIG0=ALFA**2*ALFQSQ*QMW2/(9.*SCM*S)*UNITS
      DENOM=S**2*EXP(.5*ALOG(QTW**4+QT2CUT(QMW)**2))
      SIGT=SIG0*(S**2+U**2+2.*T*QMW2)*(-T)/DENOM
      SIGU=SIG0*(S**2+T**2+2.*U*QMW2)*(-U)/DENOM
      DO 200 IW=1,4
        IF(.NOT.GODY(IW)) GO TO 200
        FAC=COUT(IW)*PROP(IW)
        DO 210 IQ=2,NZERO(IW)
          IF(.NOT.GOQ(IQ,3)) GO TO 210
          IQ1=MATCH(IQ,4)
          IQ1=MATCH(IQ1,IW)
          IF(IQ1.EQ.0) GO TO 210
          IFL=IQ/2
          FACTOR=FAC*(AQ(IFL,IW)**2+BQ(IFL,IW)**2)
     $    *QTW**2/(QTW**2+QT2CUT(QMW))
          SIG=FACTOR*SIGT*QSAVE(IQ1,1)*QSAVE(1,2)
          CALL SIGFIL(SIG,IQ1,1,IW,IQ)
          SIG=FACTOR*SIGU*QSAVE(IQ1,2)*QSAVE(1,1)
          CALL SIGFIL(SIG,1,IQ1,IW,IQ)
210     CONTINUE
200   CONTINUE
C
C          bt,tp + gl -> bt,tp + W,Z
C
      AMT=AMASS(6)
      AMT2=AMT**2
      Q2=QMW2
      DO 220 IW=2,4
        IF(.NOT.GODY(IW)) GO TO 220
        DO 230 IQ=NZERO(IW)+1,13
          IF(.NOT.GOQ(IQ,3)) GO TO 230
          IQ1=MATCH(IQ,4)
          IQ1=MATCH(IQ1,IW)
          IF(IQ1.EQ.0) GO TO 230
          IF(IQ1.GE.12.AND.IW.NE.4) GO TO 230
C          Assign zero or top masses for initial/final quarks
          AMF2=AMT2*AMFAC(IQ)
          AMI2=AMT2*AMFAC(IQ1)
          EFWT=SQRT(P(3)**2+AMF2)
          SWT=QMW2+AMF2+2.*Q0W*EFWT-2.*QZW*P3Z+2.*PT(3)**2
C
C          qk + gl initial state
C          Do kinematics using p(small) = 0 for gluon
C
          P1WT=EFWT+P3Z+Q0W+QZW
          P1M=AMI2/P1WT
          P2WT=EFWT-P3Z+Q0W-QZW-P1M
          X1WT=.5*P1WT/HALFE
          X2WT=.5*P2WT/HALFE
          TWT=-P1WT*(EFWT-P3Z)-P1M*(EFWT+P3Z)+AMI2+AMF2
          UWT=-P2WT*(EFWT+P3Z)+AMF2
          IF(X1WT.LT.0.OR.X1WT.GT.1.OR.X2WT.LT.0.OR.X2WT.GT.1)
     $    GO TO 240
C          Cross sections
          IF(IW.EQ.2.OR.IW.EQ.3) THEN
            SIG0=ALFA**2*ALFQSQ/(144*SCM*SWT)*UNITS
            SIG0=SIG0*(AQ(5,IW)**2+BQ(5,IW)**2)*COUT(IW)*PROP(IW)
            SIGU=SIG0*AJLWT(SWT/SWT,UWT/SWT,Q2/SWT,AMT2/SWT)*SWT*
     $      (SWT/(SWT-AMI2))**2*(SWT/(UWT-AMF2))**2
            SIG=SIGU*QFCN(X1WT,IQ1,1)*QFCN(X2WT,1,2)
            CALL SIGFIL(SIG,IQ1,1,IW,IQ)
          ELSEIF(IW.EQ.4) THEN
            SIG0=ALFA**2*ALFQSQ/(144*SCM*SWT)*UNITS
            SIG0=SIG0*COUT(IW)*PROP(IW)
            A2=AQ(6,IW)**2
            A2B2=AQ(6,IW)**2+BQ(6,IW)**2
            SIGU=SIG0*(AJLZT1(SWT/SWT,UWT/SWT,Q2/SWT,AMT2/SWT)+
     $      AJLZT2(SWT/SWT,UWT/SWT,Q2/SWT,AMT2/SWT))*SWT*
     $      (SWT/(SWT-AMI2))**2*(SWT/(UWT-AMF2))**2
            SIG=SIGU*QFCN(X1WT,IQ1,1)*QFCN(X2WT,1,2)
            CALL SIGFIL(SIG,IQ1,1,IW,IQ)
          ENDIF
C
C          gl + qk initial state
C          Do kinematics  using p(small) = 0 for gluon
C
240       P2WT=EFWT-P3Z+Q0W-QZW
          P2M=AMI2/P2WT
          P1WT=EFWT+P3Z+Q0W+QZW-P2M
          X1WT=.5*P1WT/HALFE
          X2WT=.5*P2WT/HALFE
          TWT=-P1WT*(EFWT-P3Z)+AMF2
          UWT=-P2WT*(EFWT+P3Z)-P2M*(EFWT-P3Z)+AMI2+AMF2
          IF(X1WT.LT.0.OR.X1WT.GT.1.OR.X2WT.LT.0.OR.X2WT.GT.1)
     $    GO TO 230
C          Cross sections
          IF(IW.EQ.2.OR.IW.EQ.3) THEN
            SIG0=ALFA**2*ALFQSQ/(144*SCM*SWT)*UNITS
            SIG0=SIG0*(AQ(5,IW)**2+BQ(5,IW)**2)*COUT(IW)*PROP(IW)
            SIGT=SIG0*AJLWT(SWT/SWT,TWT/SWT,Q2/SWT,AMT2/SWT)*SWT*
     $      (SWT/(SWT-AMI2))**2*(SWT/(TWT-AMF2)**2)
            SIG=SIGT*QFCN(X1WT,1,1)*QFCN(X2WT,IQ1,2)
            CALL SIGFIL(SIG,1,IQ1,IW,IQ)
          ELSEIF(IW.EQ.4) THEN
            SIG0=ALFA**2*ALFQSQ/(144*SCM*SWT)*UNITS
            SIG0=SIG0*COUT(IW)*PROP(IW)
            A2=AQ(6,IW)**2
            A2B2=AQ(6,IW)**2+BQ(6,IW)**2
            SIGU=SIG0*(AJLZT1(SWT/SWT,TWT/SWT,Q2/SWT,AMT2/SWT)+
     $      AJLZT2(SWT/SWT,TWT/SWT,Q2/SWT,AMT2/SWT))*SWT*
     $      (SWT/(SWT-AMI2))**2*(SWT/(TWT-AMF2))**2
            SIG=SIGU*QFCN(X1WT,1,1)*QFCN(X2WT,IQ1,2)
            CALL SIGFIL(SIG,1,IQ1,IW,IQ)
          ENDIF
230     CONTINUE
220   CONTINUE
C
C          qk + qb --> gl + W
C
      IF(.NOT.GOQ(1,3)) RETURN
      SIG0=8.*ALFA**2*ALFQSQ*QMW2/(27.*SCM*S)*UNITS
      DENOM=S*EXP(.5*ALOG(QTW**4+QT2CUT(QMW)**2))
      SIG0=SIG0*(T**2+U**2+2.*S*QMW2)/DENOM
      DO 300 IW=1,4
        IF(.NOT.GODY(IW)) GO TO 300
        FAC=COUT(IW)*PROP(IW)
        DO 310 IQ1=2,11
          IQ2=MATCH(IQ1,IW)
          IF(IQ2.EQ.0) GO TO 310
          IFL=IQ1/2
          SIG=FAC*SIG0*(AQ(IFL,IW)**2+BQ(IFL,IW)**2)
     $    *QSAVE(IQ1,1)*QSAVE(IQ2,2)
          CALL SIGFIL(SIG,IQ1,IQ2,IW,1)
310     CONTINUE
300   CONTINUE
      RETURN
C
C          Standard Drell-Yan for QT=0.
C
400   CONTINUE
      SIG0=4.*PI*ALFA**2*QMW2/(9.*SCM)*UNITS
      DO 410 IW=1,4
        IF(.NOT.GODY(IW)) GO TO 410
        FAC=COUT(IW)*PROP(IW)
        DO 420 IQ1=2,13
          IQ2=MATCH(IQ1,IW)
          IF(IQ2.EQ.0) GO TO 420
          IFL=IQ1/2
          SIG=FAC*SIG0*(AQ(IFL,IW)**2+BQ(IFL,IW)**2)
     $    *QSAVE(IQ1,1)*QSAVE(IQ2,2)
          CALL SIGFIL(SIG,IQ1,IQ2,IW,0)
420     CONTINUE
410   CONTINUE
C
      RETURN
      END
CDECK  ID>, SIGDY2. 
      SUBROUTINE SIGDY2
C
C          Compute the lepton-lepton-jet cross or quark-antiquark-jet
C          cross section
C          d(sigma)/d(qmw**2)d(qtw**2)d(yw)d(yj)d(omega*)
C          for the specified W and jet types
C
C          Also fix the incoming partons to be the selected types.
C
C          QT cutoff from Parisi and Petronzio, Nucl Phys B154, 427
C          qk+gl-->qk+w suppressed at low QTW
C
C          Ver 6.40: Fix underflow in standard Drell-Yan
C
C          Ver 7.17: include top mass for gb --> Wt and gt --> Zt
C          with no extra qt suppression factor. Note we do NOT include
C          gt --> Wb; while this process makes sense for qt >> m_t,
C          it has a pole in the physical region at low qt from the
C          on-shell decay t --> Wb. We let Q**2 --> Q**2 + m_t**2
C          in the scale for the parton distributions.
C
C          Ver 7.32: Rewrite AJLWT for gb --> Wt, etc., in terms of
C          scaled variables, and restore SWT**5 later to avoid
C          floating errors on VMS.
C
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/WSIG/SIGLLQ
      SAVE /WSIG/
      REAL      SIGLLQ
      COMMON/QSAVE/QSAVE(29,2)
      SAVE /QSAVE/
      REAL      QSAVE
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
C
      REAL PROP,AJLWT,FCDIR,FCINT,QT2CUT,QFCN,AMASS,STRUC
      REAL AJLZT1,AJLZT2,AJLZT3,AJLZT4
      REAL X1WT,X2WT,P1WT,P2WT,SWT,TWT,UWT,QZW,P3Z,
     $S,T,U,S1,T1,U1,TDIR,UDIR,TINT,UINT,COUPL,DENOM,
     $AMT,AMT2,TERM1,TERM2,SIG0,QMW2,Q2,XX,S1WT,T1WT,U1WT,P1M,P2M,
     $AMI2,AMF2,EFWT,A2,A2B2,AB,AL2BL2,ALBL,QQ,TM2
      REAL AMFAC(13)
      INTEGER I,JF,IFLQ,JQK,IQ1,IQ2,IFL1,IQ,IFLL,IH,IQ3
      INTEGER NZERO(4)
      EQUIVALENCE (S,SHAT),(T,THAT),(U,UHAT)
      EQUIVALENCE (S1,SHAT1),(T1,THAT1),(U1,UHAT1)
C
      DATA NZERO/13,9,9,11/
      DATA AMFAC/11*0.,2*1./

C          Functions.  FCDIR and FCINT are direct and interference
C          terms for virtual Compton cross section.
C
      PROP(I)=1./((QMW2-WMASS(I)**2)**2+(WMASS(I)*WGAM(I))**2)
      FCDIR(S,T,U,S1,T1,U1)=COUPL*(S*(2.*S1**2-2.*S1*U1-2.*T1*U1)
     1+T*(-2.*S1*T1-4.*S1*U1-2.*T1*U1)+U*(2.*U1**2-2.*S1*T1-2.*S1*U1)
     2+QMW2*(S**2+U**2+2.*T*QMW2))*(-T)/DENOM
      FCINT(S,T,U,S1,T1,U1)=-COUPL*(S1*(S*T-T*U+T*QMW2+QMW2**2)
     1+T1*(-S**2+U**2+2.*S*QMW2-2.*U*QMW2)+U1*(S*T-T*U-T*QMW2-QMW2**2))
     2*(-T)/DENOM
C          QT cutoff function
      QT2CUT(QMW)=CUTOFF*QMW**CUTPOW
C          Parton distributions for top processes
      QFCN(XX,IQ,IH)=STRUC(XX,QSQ+AMT2,IQ,IDIN(IH))/XX
C          Matrix elements JL/128 from FORM
      AJLWT(S,T,T1,U1,QQ,TM2)=
     $ + 2*QQ**3*S*T - 2*QQ**3*S*TM2 - 2*QQ**2*S**2*TM2
     $ - 2*QQ**2*S*T**2 + 4*QQ**2*S*T*T1 + 2*QQ**2*S*T*U1
     $ - 4*QQ**2*S*T1*TM2 - 2*QQ**2*S*U1*TM2 + 2*QQ**2*S*TM2**2
     $ + QQ*S**2*T*TM2 - 4*QQ*S**2*T1*TM2 + QQ*S**2*TM2**2
     $ + QQ*S*T**3 - 2*QQ*S*T**2*T1 - QQ*S*T**2*TM2 + 2*QQ*S*T*T1**2
     $ + 2*QQ*S*T*T1*U1 - 2*QQ*S*T*T1*TM2 + QQ*S*T*U1**2
     $ - 3*QQ*S*T*U1*TM2 + QQ*S*T*TM2**2 - 2*QQ*S*T1**2*TM2
     $ - 2*QQ*S*T1*U1*TM2 + 4*QQ*S*T1*TM2**2 - QQ*S*U1**2*TM2
     $ + 3*QQ*S*U1*TM2**2 - QQ*S*TM2**3 + S**2*T*T1*TM2
     $ - S**2*T*U1*TM2 - 2*S**2*T1**2*TM2 + S**2*T1*TM2**2
     $ + S**2*U1*TM2**2 + S*T**2*T1*TM2 - 2*S*T*T1**2*TM2
     $ - 2*S*T*T1*U1*TM2 - S*T*U1**2*TM2 + S*T*U1*TM2**2
     $ + 2*S*T1**2*TM2**2 + 2*S*T1*U1*TM2**2 - S*T1*TM2**3
     $ + S*U1**2*TM2**2 - S*U1*TM2**3
C
      AJLZT1(S,T,T1,U1,QQ,TM2)=
     $ + A2*AL2BL2 * ( 8*QQ**2*S*T*TM2 - 8*QQ**2*S*TM2**2
     $ - 8*QQ**2*T*TM2**2 + 8*QQ**2*TM2**3 - 8*QQ*S**2*T*TM2
     $ - 8*QQ*S*T**2*TM2 + 16*QQ*S*T*TM2**2 + 8*QQ*S*TM2**3
     $ + 8*QQ*T*TM2**3 - 16*QQ*TM2**4 + 8*S**2*T*U1*TM2
     $ - 8*S**2*U1*TM2**2 + 8*S*T**2*U1*TM2 + 8*S*T*U1**2*TM2
     $ - 32*S*T*U1*TM2**2 - 8*S*U1**2*TM2**2 + 24*S*U1*TM2**3
     $ - 8*T**2*U1*TM2**2 - 8*T*U1**2*TM2**2 + 24*T*U1*TM2**3
     $ + 8*U1**2*TM2**3 - 16*U1*TM2**4 )/8.
      AJLZT2(S,T,T1,U1,QQ,TM2)=
     $ + A2B2*AL2BL2 * ( 2*QQ**3*S*T - 2*QQ**3*S*TM2
     $ - 2*QQ**3*T*TM2 + 2*QQ**3*TM2**2 - 2*QQ**2*S**2*TM2
     $ - 2*QQ**2*S*T**2 + 4*QQ**2*S*T*T1 + 2*QQ**2*S*T*U1
     $ - 8*QQ**2*S*T*TM2 - 4*QQ**2*S*T1*TM2 - 2*QQ**2*S*U1*TM2
     $ + 14*QQ**2*S*TM2**2 - 4*QQ**2*T*T1*TM2 - 2*QQ**2*T*U1*TM2
     $ + 12*QQ**2*T*TM2**2 + 4*QQ**2*T1*TM2**2 + 2*QQ**2*U1*TM2**2
     $ - 14*QQ**2*TM2**3 + QQ*S**3*T - QQ*S**3*TM2 + 2*QQ*S**2*T*T1
     $ + 2*QQ*S**2*T*U1 - QQ*S**2*T*TM2 - 6*QQ*S**2*T1*TM2
     $ - 2*QQ*S**2*U1*TM2 + 9*QQ*S**2*TM2**2 + QQ*S*T**3
     $ - 2*QQ*S*T**2*T1 + 3*QQ*S*T**2*TM2 + 4*QQ*S*T*T1**2
     $ + 4*QQ*S*T*T1*U1 - 16*QQ*S*T*T1*TM2 + 2*QQ*S*T*U1**2
     $ - 12*QQ*S*T*U1*TM2 + 10*QQ*S*T*TM2**2 - 4*QQ*S*T1**2*TM2
     $ - 4*QQ*S*T1*U1*TM2 + 26*QQ*S*T1*TM2**2 - 2*QQ*S*U1**2*TM2
     $ + 12*QQ*S*U1*TM2**2 - 30*QQ*S*TM2**3 - QQ*T**3*TM2
     $ - 2*QQ*T**2*T1*TM2 - 4*QQ*T**2*U1*TM2 + 5*QQ*T**2*TM2**2
     $ - 4*QQ*T*T1**2*TM2 - 4*QQ*T*T1*U1*TM2 + 22*QQ*T*T1*TM2**2
     $ - 2*QQ*T*U1**2*TM2 + 18*QQ*T*U1*TM2**2 )/8.
      AJLZT3(S,T,T1,U1,QQ,TM2)=
     $ + A2B2*AL2BL2 * ( - 26*QQ*T*TM2**3 + 4*QQ*T1**2*TM2**2
     $ + 4*QQ*T1*U1*TM2**2 - 24*QQ*T1*TM2**3 + 2*QQ*U1**2*TM2**2
     $ - 14*QQ*U1*TM2**3 + 30*QQ*TM2**4 - 8*S**2*T*U1*TM2
     $ - 4*S**2*T1**2*TM2 + 8*S**2*T1*TM2**2 + 8*S**2*U1*TM2**2
     $ - 4*S**2*TM2**3 - 8*S*T**2*U1*TM2 - 8*S*T*T1**2*TM2
     $ - 8*S*T*T1*U1*TM2 + 16*S*T*T1*TM2**2 - 8*S*T*U1**2*TM2
     $ + 40*S*T*U1*TM2**2 - 8*S*T*TM2**3 + 16*S*T1**2*TM2**2
     $ + 8*S*T1*U1*TM2**2 - 32*S*T1*TM2**3 + 8*S*U1**2*TM2**2
     $ - 32*S*U1*TM2**3 + 16*S*TM2**4 - 4*T**2*T1**2*TM2
     $ - 8*T**2*T1*U1*TM2 + 8*T**2*T1*TM2**2 - 4*T**2*U1**2*TM2
     $ + 16*T**2*U1*TM2**2 - 4*T**2*TM2**3 + 16*T*T1**2*TM2**2
     $ + 24*T*T1*U1*TM2**2 - 32*T*T1*TM2**3 + 16*T*U1**2*TM2**2
     $ - 48*T*U1*TM2**3 + 16*T*TM2**4 - 16*T1**2*TM2**3
     $ - 16*T1*U1*TM2**3 + 32*T1*TM2**4 - 12*U1**2*TM2**3
     $ + 32*U1*TM2**4 - 16*TM2**5 )/8.
      AJLZT4(S,T,T1,U1,QQ,TM2)=
     $ + AB*ALBL * ( 8*QQ**3*S*T - 8*QQ**3*S*TM2 - 8*QQ**3*T*TM2
     $ + 8*QQ**3*TM2**2 - 8*QQ**2*S**2*TM2 - 8*QQ**2*S*T**2
     $ + 16*QQ**2*S*T*T1 + 8*QQ**2*S*T*U1 - 16*QQ**2*S*T*TM2
     $ - 16*QQ**2*S*T1*TM2 - 8*QQ**2*S*U1*TM2 + 40*QQ**2*S*TM2**2
     $ - 16*QQ**2*T*T1*TM2 - 8*QQ**2*T*U1*TM2 + 32*QQ**2*T*TM2**2
     $ + 16*QQ**2*T1*TM2**2 + 8*QQ**2*U1*TM2**2 - 40*QQ**2*TM2**3
     $ - 4*QQ*S**3*T + 4*QQ*S**3*TM2 - 8*QQ*S**2*T*T1
     $ - 8*QQ*S**2*T*U1 + 20*QQ*S**2*T*TM2 - 8*QQ*S**2*T1*TM2
     $ + 8*QQ*S**2*U1*TM2 - 4*QQ*S**2*TM2**2 + 4*QQ*S*T**3
     $ - 8*QQ*S*T**2*T1 - 4*QQ*S*T**2*TM2 + 40*QQ*S*T1*TM2**2
     $ - 32*QQ*S*TM2**3 - 4*QQ*T**3*TM2 - 8*QQ*T**2*T1*TM2
     $ - 16*QQ*T**2*U1*TM2 + 20*QQ*T**2*TM2**2 + 40*QQ*T*T1*TM2**2
     $ + 40*QQ*T*U1*TM2**2 - 48*QQ*T*TM2**3 - 48*QQ*T1*TM2**3
     $ - 24*QQ*U1*TM2**3 + 48*QQ*TM2**4 )/8.
C
C          Find whether JETTYP(1) or JETTYP(2) is particle
C
      JF=1
      IF(2*(JETTYP(1)/2).NE.JETTYP(1)) JF=2
C
C          Kinematics
C
      QMW2=QMW**2
      QZW=QTMW*SINH(YW)
      Q0W=QTMW*COSH(YW)
      QW=SQRT(QZW**2+QTW**2)

      T1=-X2*ECM*PT(JF)*EXP(YJ(JF))
      U1=-X1*ECM*PT(JF)*EXP(-YJ(JF))
      S1=-T1-U1-QMW2
      SIGLLQ=0.
      IF(STDDY) GO TO 400
C
C          qk + qb --> gl + w
C
      IF(JETTYP(3).EQ.1) THEN
        IFLL=JETTYP(1)/2
        COUPL=-ALFA**2*ALFQSQ*PROP(JWTYP)/(9.*PI*SCM*S)
        DENOM=S**2*EXP(.5*ALOG(QTW**4+QT2CUT(QMW)**2))
        TDIR=FCDIR(T,S,U,T1,S1,U1)*(AQ(IFLL,JWTYP)**2+BQ(IFLL,JWTYP)**2)
        UDIR=FCDIR(U,S,T,U1,S1,T1)*(AQ(IFLL,JWTYP)**2+BQ(IFLL,JWTYP)**2)
        TINT=FCINT(T,S,U,T1,S1,U1)*2.*AQ(IFLL,JWTYP)*BQ(IFLL,JWTYP)
        UINT=FCINT(U,S,T,U1,S1,T1)*2.*AQ(IFLL,JWTYP)*BQ(IFLL,JWTYP)
        IQ1=INITYP(1)
        IQ2=INITYP(2)
        IFL1=IQ1/2
        IF(2*IFL1.EQ.IQ1) THEN
          TERM1=TDIR*(AQ(IFL1,JWTYP)**2+BQ(IFL1,JWTYP)**2)
     $    *QSAVE(IQ1,1)*QSAVE(IQ2,2)
          TERM2=TINT*2.*AQ(IFL1,JWTYP)*BQ(IFL1,JWTYP)
     $    *QSAVE(IQ1,1)*QSAVE(IQ2,2)
          SIGLLQ=SIGLLQ+TERM1+TERM2
        ELSE
          TERM1=UDIR*(AQ(IFL1,JWTYP)**2+BQ(IFL1,JWTYP)**2)
     $    *QSAVE(IQ1,1)*QSAVE(IQ2,2)
          TERM2=UINT*2.*AQ(IFL1,JWTYP)*BQ(IFL1,JWTYP)
     $    *QSAVE(IQ1,1)*QSAVE(IQ2,2)
          SIGLLQ=SIGLLQ+TERM1+TERM2
        ENDIF
        SIGLLQ=SIGLLQ*UNITS
        IF(JETTYP(1).LE.13) SIGLLQ=3.*SIGLLQ
        RETURN
C
C          qk + gl --> qk + w
C
      ELSEIF(JETTYP(3).LE.NZERO(JWTYP)) THEN
        JQK=MATCH(JETTYP(3),4)
        JQK=MATCH(JQK,JWTYP)
        IF(JQK.EQ.0) RETURN
        COUPL=ALFA**2*ALFQSQ*PROP(JWTYP)/(24.*PI*SCM*S)
        DENOM=S**2*EXP(.5*ALOG(QTW**4+QT2CUT(QMW)**2))
        IFLQ=JQK/2
        IFLL=JETTYP(1)/2
        IF(INITYP(2).EQ.1) THEN
          TDIR=FCDIR(S,T,U,S1,T1,U1)*QSAVE(JQK,1)*QSAVE(1,2)
        ELSE
          TDIR=FCDIR(S,U,T,S1,U1,T1)*QSAVE(JQK,2)*QSAVE(1,1)
        ENDIF
        TDIR=TDIR*(AQ(IFLQ,JWTYP)**2+BQ(IFLQ,JWTYP)**2)
     $  *(AQ(IFLL,JWTYP)**2+BQ(IFLL,JWTYP)**2)
        IF(INITYP(2).EQ.1) THEN
          TINT=FCINT(S,T,U,S1,T1,U1)*QSAVE(JQK,1)*QSAVE(1,2)
        ELSE
          TINT=FCINT(S,U,T,S1,U1,T1)*QSAVE(JQK,2)*QSAVE(1,1)
        ENDIF
        TINT=TINT*4.*AQ(IFLQ,JWTYP)*BQ(IFLQ,JWTYP)*AQ(IFLL,JWTYP)
     $  *BQ(IFLL,JWTYP)
        SIGLLQ=TDIR+TINT
        SIGLLQ=SIGLLQ*UNITS
        IF(JETTYP(1).LE.13) SIGLLQ=3.*SIGLLQ
        SIGLLQ=SIGLLQ*QTW**2/(QTW**2+QT2CUT(QMW))
        RETURN
C
C          bt,tp + gl --> bt,tp + W,Z
C
      ELSEIF(JETTYP(3).GE.NZERO(JWTYP)+1) THEN
        IQ3=JETTYP(3)
        JQK=MATCH(IQ3,4)
        JQK=MATCH(JQK,JWTYP)
        IF(JQK.EQ.0) RETURN
        AMT=AMASS(6)
        AMT2=AMT**2
        Q2=QMW2
        AMF2=AMFAC(IQ3)*AMT2
        AMI2=AMFAC(JQK)*AMT2
        EFWT=SQRT(P(3)**2+AMF2)
        P3Z=P(3)*CTH(3)
        SWT=QMW2+AMF2+2.*Q0W*EFWT-2.*QZW*P3Z+2.*PT(3)**2
C          Kinematics
        IF(INITYP(2).EQ.1) THEN
          P1WT=EFWT+P3Z+Q0W+QZW
          P1M=AMI2/P1WT
          P2WT=EFWT-P3Z+Q0W-QZW-P1M
          X1WT=.5*P1WT/HALFE
          X2WT=.5*P2WT/HALFE
          TWT=-P1WT*(EFWT-P3Z)-P1M*(P(3)+P3Z)+AMI2+AMF2
          UWT=-P2WT*(EFWT+P3Z)+AMF2
          T1WT=-X2WT*ECM*PT(JF)*EXP(YJ(JF))
          U1WT=-X1WT*ECM*PT(JF)*EXP(-YJ(JF))-P1M*PT(JF)*EXP(YJ(JF))
          S1WT=-T1WT-U1WT-QMW2+AMI2+AMF2
        ELSE
          P2WT=EFWT-P3Z+Q0W-QZW
          P2M=AMI2/P2WT
          P1WT=EFWT+P3Z+Q0W+QZW-P2M
          X1WT=.5*P1WT/HALFE
          X2WT=.5*P2WT/HALFE
          TWT=-P1WT*(EFWT-P3Z)+AMF2
          UWT=-P2WT*(EFWT+P3Z)-P2M*(EFWT-P3Z)+AMI2+AMF2
          T1WT=-X2WT*ECM*PT(JF)*EXP(YJ(JF))-P2M*PT(JF)*EXP(-YJ(JF))
          U1WT=-X1WT*ECM*PT(JF)*EXP(-YJ(JF))
          S1WT=-T1WT-U1WT-QMW2+AMI2+AMF2
        ENDIF
C          Cross section
        SIG0=-ALFA**2*ALFQSQ/(12*PI*SCM*SWT)*PROP(JWTYP)*UNITS
        IF(JETTYP(1).LE.13) SIG0=3*SIG0
        IF(JWTYP.EQ.2.OR.JWTYP.EQ.3) THEN
          SIG0=SIG0*(AQ(6,JWTYP)**2+BQ(6,JWTYP)**2)**2
          IF(INITYP(2).EQ.1.AND.(IQ3.EQ.12.OR.IQ3.EQ.13)) THEN
            SIGLLQ=AJLWT(SWT/SWT,TWT/SWT,T1WT/SWT,U1WT/SWT,Q2/SWT,
     $      AMT2/SWT)
            SIGLLQ=SIGLLQ*SWT*(SWT/(SWT-AMI2))**2*(SWT/(TWT-AMF2))**2
            SIGLLQ=SIGLLQ*SIG0*QFCN(X1WT,JQK,1)*QFCN(X2WT,1,2)
          ELSEIF(INITYP(1).EQ.1.AND.(IQ3.EQ.12.OR.IQ3.EQ.13)) THEN
            SIGLLQ=AJLWT(SWT/SWT,UWT/SWT,U1WT/SWT,T1WT/SWT,Q2/SWT,
     $      AMT2/SWT)
            SIGLLQ=SIGLLQ*SWT*(SWT/(SWT-AMI2))**2*(SWT/(TWT-AMF2))**2
            SIGLLQ=SIGLLQ*SIG0*QFCN(X1WT,JQK,2)*QFCN(X2WT,1,1)
          ENDIF
        ELSEIF(JWTYP.EQ.4) THEN
          A2=AQ(6,JWTYP)**2
          A2B2=AQ(6,JWTYP)**2+BQ(6,JWTYP)**2
          AB=AQ(6,JWTYP)*BQ(6,JWTYP)
          AL2BL2=AQ(JETTYP(1)/2,JWTYP)**2+BQ(JETTYP(1)/2,JWTYP)**2
          ALBL=AQ(JETTYP(1)/2,JWTYP)*BQ(JETTYP(1)/2,JWTYP)
          IF(INITYP(2).EQ.1) THEN
            SIGLLQ=AJLZT1(SWT/SWT,TWT/SWT,T1WT/SWT,U1WT/SWT,
     $      Q2/SWT,AMT2/SWT)
            SIGLLQ=SIGLLQ+AJLZT2(SWT/SWT,TWT/SWT,T1WT/SWT,U1WT/SWT,
     $      Q2/SWT,AMT2/SWT)
            SIGLLQ=SIGLLQ+AJLZT3(SWT/SWT,TWT/SWT,T1WT/SWT,U1WT/SWT,
     $      Q2/SWT,AMT2/SWT)
            SIGLLQ=SIGLLQ+AJLZT4(SWT/SWT,TWT/SWT,T1WT/SWT,U1WT/SWT,
     $      Q2/SWT,AMT2/SWT)
            SIGLLQ=SIGLLQ*SWT*(SWT/(SWT-AMI2))**2*(SWT/(TWT-AMF2))**2
            SIGLLQ=SIGLLQ*SIG0*QFCN(X1WT,JQK,1)*QFCN(X2WT,1,2)
          ELSEIF(INITYP(1).EQ.1) THEN
            SIGLLQ=AJLZT1(SWT/SWT,UWT/SWT,U1WT/SWT,T1WT/SWT,
     $      Q2/SWT,AMT2/SWT)
            SIGLLQ=SIGLLQ+AJLZT2(SWT/SWT,UWT/SWT,U1WT/SWT,T1WT/SWT,
     $      Q2/SWT,AMT2/SWT)
            SIGLLQ=SIGLLQ+AJLZT3(SWT/SWT,UWT/SWT,U1WT/SWT,T1WT/SWT,
     $      Q2/SWT,AMT2/SWT)
            SIGLLQ=SIGLLQ+AJLZT4(SWT/SWT,UWT/SWT,U1WT/SWT,T1WT/SWT,
     $      Q2/SWT,AMT2/SWT)
            SIGLLQ=SIGLLQ*SWT*(SWT/(SWT-AMI2))**2*(SWT/(UWT-AMF2))**2
            SIGLLQ=SIGLLQ*SIG0*QFCN(X1WT,JQK,2)*QFCN(X2WT,1,1)
          ENDIF
        ENDIF
      ENDIF
      RETURN
C
C          Standard Drell-Yan with QT=0.
C
400   CONTINUE
      IFLL=JETTYP(1)/2
      COUPL=ALFA**2*PROP(JWTYP)*UNITS
      TDIR=COUPL*(AQ(IFLL,JWTYP)**2+BQ(IFLL,JWTYP)**2)
     $*((U1**2+T1**2)/(6.*SCM*QMW2))
      TINT=COUPL*2.*AQ(IFLL,JWTYP)*BQ(IFLL,JWTYP)
     $*((U1**2-T1**2)/(6.*SCM*QMW2))
      IQ1=INITYP(1)
      IQ2=INITYP(2)
      IFL1=IQ1/2
      TERM1=TDIR*(AQ(IFL1,JWTYP)**2+BQ(IFL1,JWTYP)**2)
     $*QSAVE(IQ1,1)*QSAVE(IQ2,2)
      TERM2=-TINT*2.*AQ(IFL1,JWTYP)*BQ(IFL1,JWTYP)
     $*QSAVE(IQ1,1)*QSAVE(IQ2,2)
      IF(2*IFL1.EQ.IQ1) SIGLLQ=SIGLLQ+TERM1+TERM2
      IF(2*IFL1.NE.IQ1) SIGLLQ=SIGLLQ+TERM1-TERM2
      IF(JETTYP(1).LE.13) SIGLLQ=3.*SIGLLQ
      RETURN
      END
CDECK  ID>, SIGEE.  
      SUBROUTINE SIGEE
C
C          Compute d(sigma)/d(cos theta) with interference
C          and polarization for
C          E+ E- --> GM, Z0 ----> QK QB, L LB, N NB, W+ W-, Z Z
C
C          SIGS(I)  = partial cross section for I1 + I2 --> I3 + I4.
C          INOUT(I) = IOPAK**3*I4 + IOPAK**2*I3 + IOPAK*I2 + I1
C                     USING JETTYPE CODE.
C
C          Extra factor of 1/2 needed because all jets are treated
C          as identical.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/EEPAR/SGMXEE,PLEP,PLEM
      SAVE /EEPAR/
      REAL      SGMXEE,PLEP,PLEM
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
C
      REAL FLEP,FLEM,FREP,FREM,PROPZ,REDZ,EB,SH,E,G,GP,COS2W,
     $TNTHW,CTTHW,ALQ(2),BEQ(2),ALL(2),BEL(2),AE,BE,EQ,AMQ,AMQ2,
     $PCM,Z,AF,BF,PHILRG,PHILRZ,PHILRI,PHIRLG,PHIRLZ,PHIRLI,
     $THT,UH,RSH,UT,PHIRL,PHILR,SIGLR,SIGRL,SIG,AMASS,
     $ALFAEM,AMZ,GAMZ,AMW
      INTEGER I,IQ,IQ2,IFL,ISGN,IQ2EQ(25)
      DATA IQ2EQ/0,2,-2,-1,1,-1,1,2,-2,-1,1,2,-2,0,0,-3,3,
     $0,0,-3,3,0,0,-3,3/
C          Fractional polarizations
      FLEP=(1.+PLEP)/2.
      FLEM=(1.+PLEM)/2.
      FREP=(1.-PLEP)/2.
      FREM=(1.-PLEM)/2.
C          FUNCTIONS
      ALFAEM=1./128.
      AMZ=WMASS(4)
      GAMZ=WGAM(4)
      AMW=WMASS(3)
      PROPZ=(SCM-AMZ**2)**2+AMZ**2*GAMZ**2
      REDZ=(SCM-AMZ**2)/PROPZ
C
C          CONSTANTS
      EB=HALFE
      SH=SCM
      RSH=SQRT(SH)
      E=SQRT(4*PI*ALFAEM)
      G=SQRT(4*PI*ALFAEM/SIN2W)
      GP=G*SQRT(SIN2W/(1.-SIN2W))
      COS2W=1.-SIN2W
      TNTHW=SQRT(SIN2W/COS2W)
      CTTHW=1./TNTHW
      ALQ(1)=CTTHW/4.-5*TNTHW/12.
      BEQ(1)=-(CTTHW+TNTHW)/4.
      ALQ(2)=TNTHW/12.-CTTHW/4.
      BEQ(2)=-BEQ(1)
      ALL(1)=(CTTHW+TNTHW)/4.
      BEL(1)=-(CTTHW+TNTHW)/4.
      ALL(2)=(3*TNTHW-CTTHW)/4.
      BEL(2)=-BEL(1)
      AE=ALL(2)
      BE=BEL(2)
C
C          ENTRY
      SIGMA=0
      NSIGS=0
      DO 10 I=1,MXSIGS
10    SIGS(I)=0.
C
C          Sum over allowed jet types. IQ labels JETTYPE1.
C
      DO 100 IQ=2,25
        IQ2=MATCH(IQ,4)
        IF(.NOT.(GOQ(IQ,1).AND.GOQ(IQ2,2))) GO TO 100
        IFL=IQ/2
        EQ=ABS(FLOAT(IQ2EQ(IQ))/3.)
        IF (EQ.LT..5.OR.EQ.GT..8) EQ=-EQ
        ISGN=1
        IF(2*IFL.NE.IQ) ISGN=2
        AMQ=AMASS(IFL)
        AMQ2=AMQ**2
        IF(2.*AMQ.GE.ECM) GO TO 100
        PCM=.5*SQRT(SCM-4.*AMQ2)
        Z=CTH(ISGN)
        IF (IQ.LE.13.AND.ABS(EQ).GT..5) THEN
          AF=ALQ(1)
          BF=BEQ(1)
        ELSE IF (IQ.LE.13.AND.ABS(EQ).LT..5) THEN
          AF=ALQ(2)
          BF=BEQ(2)
        ELSE IF (IQ.GT.13.AND.ABS(EQ).EQ.0.) THEN
          AF=ALL(1)
          BF=BEL(1)
        ELSE
          AF=ALL(2)
          BF=BEL(2)
        END IF
        PHILRG=EQ**2/SCM**2*(EB**2*(1.+Z**2)+AMQ2*(1.-Z**2))
        PHILRZ=(AE-BE)**2/PROPZ*((AF**2+BF**2)*(EB**2+PCM**2*Z**2)-
     ,     4*AF*BF*EB*PCM*Z+(AF**2-BF**2)*AMQ2)
        PHILRI=-2*EQ*(AE-BE)*REDZ/SCM*
     ,     (AF*(EB**2*(1.+Z**2)+AMQ2*(1.-Z**2))-2*BF*EB*PCM*Z)
        PHILR=E**4*(PHILRG+PHILRZ+PHILRI)
        PHIRLG=PHILRG
        PHIRLZ=(AE+BE)**2/PROPZ*((AF**2+BF**2)*(EB**2+PCM**2*Z**2)+
     ,     4*AF*BF*EB*PCM*Z+(AF**2-BF**2)*AMQ2)
        PHIRLI=-2*EQ*(AE+BE)*REDZ/SCM*
     ,     (AF*(EB**2*(1.+Z**2)+AMQ2*(1.-Z**2))+2*BF*EB*PCM*Z)
        PHIRL=E**4*(PHIRLG+PHIRLZ+PHIRLI)
        SIGLR=4*PCM*PHILR/16./PI/EB
        SIGRL=4*PCM*PHIRL/16./PI/EB
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        IF (IQ.LE.13) SIG=3*SIG
        CALL SIGFIL(SIG,0,0,IQ,IQ2)
100   CONTINUE
C           Z Z Cross section
      IF(.NOT.(GOQ(29,1).AND.GOQ(29,2))) GO TO 200
        PCM=.5*SQRT(SCM-4.*AMZ**2)
        THT=AMZ**2-SH/2.+RSH*PCM*CTH(1)
        UH=2*AMZ**2-SH-THT
        SIGLR=4*E**4*(AE-BE)**4*PCM/16./PI/SH/RSH*
     ,   (UH/THT+THT/UH+4*AMZ**2*SH/UH/THT-AMZ**4*(1./THT**2+1./UH**2))
        SIGRL=4*E**4*(AE+BE)**4*PCM/16./PI/SH/RSH*
     ,   (UH/THT+THT/UH+4*AMZ**2*SH/UH/THT-AMZ**4*(1./THT**2+1./UH**2))
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        CALL SIGFIL(SIG,0,0,29,29)
200   CONTINUE
C           W W Cross section
      IF(.NOT.(GOQ(27,1).AND.GOQ(28,2))) GO TO 300
        PCM=.5*SQRT(SCM-4.*AMW**2)
        THT=AMW**2-SH/2.+RSH*PCM*CTH(2)
        UH=2*AMW**2-SH-THT
        UT=UH*THT-AMW**4
        PHIRL=4*(AE+BE)**2*TNTHW**2/SH/SH/PROPZ*
     ,        (UT*(PCM**2*SH+3*AMW**4)+4*AMW**2*PCM**2*SH*SH)
        PHILR=UT/SH/SH*(3.+2*(AE-BE)*TNTHW*(SH-6*AMW**2)*REDZ+
     ,      4*(AE-BE)**2*TNTHW**2*(PCM**2*SH+3*AMW**4)/PROPZ)+
     ,      8*(AE-BE)*TNTHW*AMW**2*REDZ+16*(AE-BE)**2*TNTHW**2*
     ,      AMW**2*PCM**2/PROPZ+2*(1.-2*(AE-BE)*TNTHW*AMW**2*REDZ)*
     ,      (UT/SH/THT-2*AMW**2/THT)+UT/THT**2
        SIGLR=4*E**4*PCM/64./PI/SH/RSH/SIN2W**2*PHILR
        SIGRL=4*E**4*PCM/64./PI/SH/RSH/SIN2W**2*PHIRL
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        CALL SIGFIL(SIG,0,0,27,28)
300   CONTINUE
      IF(.NOT.(GOQ(28,1).AND.GOQ(27,2))) GO TO 400
        PCM=.5*SQRT(SCM-4.*AMW**2)
        THT=AMW**2-SH/2.+RSH*PCM*CTH(1)
        UH=2*AMW**2-SH-THT
        UT=UH*THT-AMW**4
        PHIRL=4*(AE+BE)**2*TNTHW**2/SH/SH/PROPZ*
     ,        (UT*(PCM**2*SH+3*AMW**4)+4*AMW**2*PCM**2*SH*SH)
        PHILR=UT/SH/SH*(3.+2*(AE-BE)*TNTHW*(SH-6*AMW**2)*REDZ+
     ,      4*(AE-BE)**2*TNTHW**2*(PCM**2*SH+3*AMW**4)/PROPZ)+
     ,      8*(AE-BE)*TNTHW*AMW**2*REDZ+16*(AE-BE)**2*TNTHW**2*
     ,      AMW**2*PCM**2/PROPZ+2*(1.-2*(AE-BE)*TNTHW*AMW**2*REDZ)*
     ,      (UT/SH/THT-2*AMW**2/THT)+UT/THT**2
        SIGLR=4*E**4*PCM/64./PI/SH/RSH/SIN2W**2*PHILR
        SIGRL=4*E**4*PCM/64./PI/SH/RSH/SIN2W**2*PHIRL
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        CALL SIGFIL(SIG,0,0,28,27)
400   CONTINUE
C-----------------------------------------------------------------------
      RETURN
      END
CDECK  ID>, SIGFIL. 
      SUBROUTINE SIGFIL(SIG,I1,I2,I3,I4)
C          Fill /JETSIG/ arrays if SIG > 0
C          Write error message if SIG < 0
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
C
      IF(SIG.GT.0) THEN
        NSIGS=NSIGS+1
        SIGMA=SIGMA+SIG
        SIGS(NSIGS)=SIG
        INOUT(NSIGS)=I1+IOPAK*(I2+IOPAK*(I3+IOPAK*I4))
      ELSEIF(SIG.LT.0.) THEN
        WRITE(ITLIS,1010) SIG,I1,I2,I3,I4
1010    FORMAT(' ERROR IN SIGFIL ... SIG = ',E12.5,' FOR ',4I6)
      ENDIF
      RETURN
      END
CDECK  ID>, SIGGAM. 
      SUBROUTINE SIGGAM
C
C          Compute D(SIGMA)/D(PT**2)D(Y1)D(Y2) for gamma + jet and
C          gamma + gamma.
C
C          SIGMA    = cross section summed over quark types allowed by
C                     JETTYPE card.
C          SIGS(I)  = partial cross section for I1 + I2 --> I3 + I4.
C          INOUT(I) = IOPAK**3*I4 + IOPAK**2*I3 + IOPAK*I2 + I1
C                     using JETTYPE code.
C
C          Cross sections from Berger, Bratten, and Field, Nucl. Phys.
C          B239, 52 (1984), Table 2. Masses are neglected.
C
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
C
      REAL BBF1,BBF2,BBF3,S,T,U,FJAC,STRUC,SIG0,SIG,BBF3TU,BBF3UT
      INTEGER I,IH,IQ,IFL
      REAL X(2),QSAVE(13,2)
      INTEGER LISTJ(13)
      EQUIVALENCE (X(1),X1),(S,SHAT),(T,THAT),(U,UHAT)
      DATA LISTJ/9,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6/
C
C          Cross sections with couplings and Jacobean removed.
      BBF1(S,T,U)=8./9.*(U/T+T/U)
      BBF2(S,T,U)=2./3.*(U/T+T/U)
      BBF3(S,T,U)=-1./3.*(U/S+S/U)
C
C          Initialize cross sections.
C
      SIGMA=0.
      NSIGS=0
      DO 100 I=1,MXSIGS
      SIGS(I)=0.
100   CONTINUE
C
C          Kinematics and structure functions for CH and lighter quarks
C
      CALL TWOKIN(0.,0.,0.,0.)
      FJAC=SHAT/SCM*UNITS*PI/SHAT**2
      IF(X1.GE.1.0.OR.X2.GE.1.0) RETURN
      DO 110 IH=1,2
      DO 110 IQ=1,9
        QSAVE(IQ,IH)=STRUC(X(IH),QSQ,IQ,IDIN(IH))/X(IH)
110   CONTINUE
C
C          Compute cross sections summed over all types allowed by
C          JETTYPE card.
C
      IF(.NOT.(GOQ(26,1).OR.GOQ(26,2))) RETURN
C
C          Gluon-photon
C
      IF((GOQ(1,1).AND.GOQ(26,2)).OR.(GOQ(26,1).AND.GOQ(1,2))) THEN
        SIG0=.5*FJAC*ALFQSQ*ALFA*BBF1(S,T,U)
        DO 210 I=1,4
          IFL=LISTJ(2*I)
          SIG=SIG0*AQ(IFL,1)**2*QSAVE(2*I,1)*QSAVE(2*I+1,2)
          IF(GOQ(26,1).AND.GOQ(1,2)) CALL SIGFIL(SIG,2*I,2*I+1,26,1)
          IF(GOQ(1,1).AND.GOQ(26,2)) CALL SIGFIL(SIG,2*I,2*I+1,1,26)
          SIG=SIG0*AQ(IFL,1)**2*QSAVE(2*I+1,1)*QSAVE(2*I,2)
          IF(GOQ(26,1).AND.GOQ(1,2)) CALL SIGFIL(SIG,2*I+1,2*I,26,1)
          IF(GOQ(1,1).AND.GOQ(26,2)) CALL SIGFIL(SIG,2*I+1,2*I,1,26)
210     CONTINUE
      ENDIF
C
C          Photon-photon
C
      IF(GOQ(26,1).AND.GOQ(26,2)) THEN
        SIG0=.5*FJAC*ALFA**2*BBF2(S,T,U)
        DO 220 I=1,4
          IFL=LISTJ(2*I)
          SIG=SIG0*AQ(IFL,1)**4*QSAVE(2*I,1)*QSAVE(2*I+1,2)
          CALL SIGFIL(SIG,2*I,2*I+1,26,26)
          SIG=SIG0*AQ(IFL,1)**4*QSAVE(2*I+1,1)*QSAVE(2*I,2)
          CALL SIGFIL(SIG,2*I+1,2*I,26,26)
220     CONTINUE
      ENDIF
C
C          Quark-photon
C
      BBF3TU=.5*FJAC*ALFA*ALFQSQ*BBF3(S,T,U)
      BBF3UT=.5*FJAC*ALFA*ALFQSQ*BBF3(S,U,T)
      DO 230 I=2,9
        IFL=IABS(LISTJ(I))
        IF(GOQ(26,1).AND.GOQ(I,2)) THEN
          SIG=BBF3TU*AQ(IFL,1)**2*QSAVE(I,1)*QSAVE(1,2)
          CALL SIGFIL(SIG,I,1,26,I)
          SIG=BBF3UT*AQ(IFL,1)**2*QSAVE(1,1)*QSAVE(I,2)
          CALL SIGFIL(SIG,1,I,26,I)
        ENDIF
        IF(GOQ(I,1).AND.GOQ(26,2)) THEN
          SIG=BBF3UT*AQ(IFL,1)**2*QSAVE(I,1)*QSAVE(1,2)
          CALL SIGFIL(SIG,I,1,I,26)
          SIG=BBF3TU*AQ(IFL,1)**2*QSAVE(1,1)*QSAVE(I,2)
          CALL SIGFIL(SIG,1,I,I,26)
        ENDIF
230   CONTINUE
C
      RETURN
      END
CDECK  ID>, SIGH.   
      SUBROUTINE SIGH
C
C          COMPUTE THE INTEGRATED WEINBERG-SALAM HIGGS CROSS SECTION
C          D(SIGMA)/D(QMW**2)D(YW)
C
C          SIGMA    = CROSS SECTION SUMMED OVER QUARK TYPES ALLOWED BY
C                     JETTYPE3 AND WTYPE CARDS.
C          SIGS(I)  = PARTIAL CROSS SECTION FOR I1 + I2 --> I3 + I4.
C          INOUT(I) = IOPAK**3*I4 + IOPAK**2*I3 + IOPAK*I2 + I1
C                     USING JETTYPE CODE.
C
C          VER. 7.14: CHECK INITIAL QUARK MASS IS ALLOWED
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/QSAVE/QSAVE(29,2)
      SAVE /QSAVE/
      REAL      QSAVE
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
C
      DIMENSION AMQCUR(6),LISTW(4),WTHELI(4),FINT(9)
      DIMENSION X(2)
      EQUIVALENCE (S,SHAT),(T,THAT),(U,UHAT),(X(1),X1)
      DOUBLE PRECISION C,TERM,SUM,FINT,ZLIM
      DATA AMQCUR/.005,.009,.175,1.25,4.50,30./
      DATA LISTW/10,80,-80,90/
C          WTHELI ARE WEIGHTS OF HELICITY AMPLITUDES IN SIGMA.
      DATA WTHELI/1.,2.,2.,4./
C
C          FUNCTIONS
      ACOSH(Z)=ALOG(Z+SQRT(Z**2-1.))
      ATANH(Z)=.5*ALOG((1.+Z)/(1.-Z))
C
C          KINEMATICS (IDENTICAL TO DRELL-YAN)
C
      AMQCUR(6)=AMASS(6)
      QMW2=QMW**2
      QTMW=SQRT(QMW2+QTW**2)
      Q0W=QTMW*COSH(YW)
      QZW=QTMW*SINH(YW)
      QW=SQRT(QZW**2+QTW**2)
      IF(QW.NE.0.) THEN
        CTHW=QZW/QW
        STHW=QTW/QW
        IF(ABS(CTHW).LT.1.) THEN
          THW=ACOS(CTHW)
        ELSE
          CTHW=0.
          STHW=1.
          THW=.5*PI
        ENDIF
      ELSE
        CTHW=0.
        STHW=1.
        THW=.5*PI
      ENDIF
      EHAT=QMW
      SHAT=QMW**2
      QSQ=SHAT
      ANEFF=4.+QSQ/(QSQ+AMASS(5)**2)+QSQ/(QSQ+AMASS(6)**2)
      ALFQSQ=12.*PI/((33.-ANEFF)*ALOG(QSQ/ALAM2))
      Q2SAVE=QSQ
      YHAT=YW
      EY=EXP(YHAT)
      X1=EHAT/ECM*EY
      X2=EHAT/(ECM*EY)
C
C          INITIALIZE
C
      SIGMA=0.
      NSIGS=0
      DO 100 I=1,MXSIGS
100   SIGS(I)=0
C
      IF(X1.GE.1..OR.X2.GE.1.) RETURN
C
C          COMPUTE STRUCTURE FUNCTIONS
      DO 110 IH=1,2
      DO 120 IQ=1,13
120   QSAVE(IQ,IH)=STRUC(X(IH),QSQ,IQ,IDIN(IH))/X(IH)
      DO 130 IQ=14,26
130   QSAVE(IQ,IH)=0.
      DO 140 IW=2,4
      AMW=AMASS(LISTW(IW))
      IF(QMW.GT.2.*AMW) THEN
        QSAVE(25+IW,IH)=STRUCW(X(IH),IW,IDIN(IH))/X(IH)
      ELSE
        QSAVE(25+IW,IH)=0.
      ENDIF
140   CONTINUE
110   CONTINUE
C
C          CALCULATE HIGGS-GLUON-GLUON COUPLING FOR GIVEN Q**2
      ETAR=0.
      ETAI=0.
      DO 150 IQ=1,8
      AMQ=AMASS(IQ)
      IF(AMQ.LE.0.) GO TO 150
      RQ=(2.*AMQ/HMASS)**2
      IF(RQ.GE.1.) THEN
        ETAR=ETAR+.5*RQ*(1.+(1.-RQ)*ASIN(1./SQRT(RQ))**2)
      ELSE
        RQLOG=ALOG((1.+SQRT(1.-RQ))/(1.-SQRT(1.-RQ)))
        PHIR=.25*(RQLOG**2-PI**2)
        ETAR=ETAR+.5*RQ*(1.+(RQ-1.)*PHIR)
        PHII=.5*PI*RQLOG
        ETAI=ETAI+.5*RQ*(RQ-1.)*PHII
      ENDIF
150   CONTINUE
      ETAHGG=ETAR**2+ETAI**2
C
C          GL + GL --> HIGGS
C
      SIG0=GF*ALFQSQ**2/(32.*PI*SQRT2)*ETAHGG*X1*X2*UNITS
      SIG0=SIG0*S/(PI*HMASS*((S-HMASS**2)**2+(HMASS*HGAM)**2))
      SIG0=SIG0*QSAVE(1,1)*QSAVE(1,2)
      DO 160 IQ1=2,29
      IQ2=MATCHH(IQ1)
      IF(GOQ(IQ1,1).AND.GOQ(IQ2,2)) THEN
        SIG=SIG0*HGAMS(IQ1)
        IF(IQ1.GT.25) SIG=SIG*TBRWW(IQ1-25,1)*TBRWW(IQ2-25,2)
        CALL SIGFIL(SIG,1,1,IQ1,IQ2)
      ENDIF
160   CONTINUE
C
C          QK + QB --> HIGGS
C
      SIG0=PI*GF/(3.*SQRT2*HMASS**2)*X1*X2*UNITS
      SIG0=SIG0*S/(PI*HMASS*((S-HMASS**2)**2+(HMASS*HGAM)**2))
      DO 210 IQ1=2,13
      IQ2=MATCHH(IQ1)
      AMQ=AMQCUR(IQ1/2)
      IF(QMW.LE.2*AMQ) GO TO 210
      SIG1=SIG0*AMQ**2*QSAVE(IQ1,1)*QSAVE(IQ2,2)
      DO 220 IQ3=2,29
      IQ4=MATCHH(IQ3)
      IF(GOQ(IQ3,1).AND.GOQ(IQ4,2)) THEN
        SIG=SIG1*HGAMS(IQ3)
        IF(IQ3.GT.25) SIG=SIG*TBRWW(IQ3-25,1)*TBRWW(IQ4-25,2)
        CALL SIGFIL(SIG,IQ1,IQ2,IQ3,IQ4)
      ENDIF
220   CONTINUE
210   CONTINUE
C
C          W+W FUSION AND W+W->W+W IN EFFECTIVE W APPROXIMATION WITH
C          ANGULAR DISTRIBUTION CUT OFF BY PTMIN.
C          Z0 Z0 FINAL STATE HAS SYMMETRY FACTOR OF .5
C
      IF(QMW.LE.2.*AMASS(80)) GO TO 500
C
C          W+ W- --> W+ W-
C
      IF(.NOT.((GOQ(27,1).AND.GOQ(28,2)).OR.(GOQ(28,1).AND.GOQ(27,2))))
     $GO TO 400
      WM=AMASS(80)
      PWWCM=.5*SQRT(QMW**2-4.*WM**2)
      STHLIM=PTMIN(1)/PWWCM
      IF(STHLIM.LE.1) THEN
        ZLIM=SQRT(1.-STHLIM**2)
      ELSE
        GO TO 400
      ENDIF
C          SET UP AMPLITUDES
      CALL XWWWW
C          SUM CROSS SECTION TERMS. I,J RUN OVER AMPLITUDE TERMS.
C          L RUNS OVER HELICITY STATES. N RUNS OVER POWERS.
C          REMEMBER THAT L=4 IS MISSING SIN(THETA)/SQRT(2)
      SUM=0.
      DO 311 I=1,4
      DO 311 J=I,4
      CALL SIGINT(FINT,ZLIM,ADWWWW(1,I),ADWWWW(2,I),ADWWWW(1,J),
     $ADWWWW(2,J))
        DO 312 L=1,4
        TERM=0.
          DO 313 N=0,6
          C=0.
          N1=MAX(N-3,0)
          N2=MIN(3,N)
          DO 314 K=N1,N2
314       C=C+ANWWWW(K+1,I,L)*ANWWWW(N-K+1,J,L)
          C=C*WTHELI(L)
          IF(J.NE.I) C=2.*C
          IF(L.EQ.4) THEN
            TERM=TERM+.5*C*FINT(N+1)-.5*C*FINT(N+3)
          ELSE
            TERM=TERM+C*FINT(N+1)
          ENDIF
313       CONTINUE
        SUM=SUM+TERM
312     CONTINUE
311   CONTINUE
C          ADD INTEGRAL OF IMAGINARY PART SQUARED.
      SUM=SUM+2.*ZLIM*(WTHELI(1)*AIWWWW(1)**2+WTHELI(2)*AIWWWW(2)**2
     $+WTHELI(3)*AIWWWW(3)**2+WTHELI(4)*AIWWWW(4)**2)
C          CROSS SECTION
      SIG0=SUM/(32.*PI*S*SCM)*UNITS
      SIG1=.5*SIG0*QSAVE(27,1)*QSAVE(28,2)
      IF(GOQ(27,1).AND.GOQ(28,2)) THEN
        SIG=SIG1*TBRWW(2,1)*TBRWW(3,2)
        CALL SIGFIL(SIG,27,28,27,28)
      ENDIF
      IF(GOQ(28,1).AND.GOQ(27,2)) THEN
        SIG=SIG1*TBRWW(3,1)*TBRWW(2,2)
        CALL SIGFIL(SIG,27,28,28,27)
      ENDIF
      SIG1=.5*SIG0*QSAVE(28,1)*QSAVE(27,2)
      IF(GOQ(27,1).AND.GOQ(28,2)) THEN
        SIG=SIG1*TBRWW(2,1)*TBRWW(3,2)
        CALL SIGFIL(SIG,28,27,27,28)
      ENDIF
      IF(GOQ(28,1).AND.GOQ(27,2)) THEN
        SIG=SIG1*TBRWW(3,1)*TBRWW(2,2)
        CALL SIGFIL(SIG,28,27,28,27)
      ENDIF
C
C          Z0 Z0 --> W+ W-
C
C          SET UP AMPLITUDES
      IF(QMW.LE.2.*AMASS(90)) GO TO 500
      CALL XZZWW
C          SUM CROSS SECTION TERMS. I,J RUN OVER AMPLITUDE TERMS.
C          L RUNS OVER HELICITY STATES. N RUNS OVER POWERS.
C          REMEMBER THAT L=4 IS MISSING SIN(THETA)/SQRT(2)
      SUM=0.
      DO 321 I=1,4
      DO 321 J=I,4
      CALL SIGINT(FINT,ZLIM,ADWWWW(1,I),ADWWWW(2,I),ADWWWW(1,J),
     $ADWWWW(2,J))
        DO 322 L=1,4
        TERM=0.
          DO 323 N=0,6
          C=0.
          N1=MAX(N-3,0)
          N2=MIN(3,N)
          DO 324 K=N1,N2
324       C=C+ANWWWW(K+1,I,L)*ANWWWW(N-K+1,J,L)
          C=C*WTHELI(L)
          IF(J.NE.I) C=2.*C
          IF(L.EQ.4) THEN
            TERM=TERM+.5*C*FINT(N+1)-.5*C*FINT(N+3)
          ELSE
            TERM=TERM+C*FINT(N+1)
          ENDIF
323       CONTINUE
        SUM=SUM+TERM
322     CONTINUE
321   CONTINUE
C          ADD INTEGRAL OF IMAGINARY PART SQUARED.
      SUM=SUM+2.*ZLIM*(WTHELI(1)*AIWWWW(1)**2+WTHELI(2)*AIWWWW(2)**2
     $+WTHELI(3)*AIWWWW(3)**2+WTHELI(4)*AIWWWW(4)**2)
C          CROSS SECTION
      SIG0=SUM/(32.*PI*S*SCM)*UNITS
      SIG1=.5*SIG0*QSAVE(29,1)*QSAVE(29,2)
      IF(GOQ(27,1).AND.GOQ(28,2)) THEN
        SIG=SIG1*TBRWW(2,1)*TBRWW(3,2)
        CALL SIGFIL(SIG,29,29,27,28)
      ENDIF
      IF(GOQ(28,1).AND.GOQ(27,2)) THEN
        SIG=SIG1*TBRWW(3,1)*TBRWW(2,2)
        CALL SIGFIL(SIG,29,29,28,27)
      ENDIF
C
C          W+ W- --> Z0 Z0
C
400   IF(QMW.LE.2.*AMASS(90)) GO TO 500
      IF(.NOT.(GOQ(29,1).AND.GOQ(29,2))) GO TO 500
      WM=AMASS(90)
      PWWCM=.5*SQRT(QMW**2-4.*WM**2)
      STHLIM=PTMIN(1)/PWWCM
      IF(STHLIM.LE.1) THEN
        ZLIM=SQRT(1.-STHLIM**2)
      ELSE
        GO TO 500
      ENDIF
C          SET UP AMPLITUDES
      CALL XWWZZ
C          SUM CROSS SECTION TERMS. I,J RUN OVER AMPLITUDE TERMS.
C          L RUNS OVER HELICITY STATES. N RUNS OVER POWERS.
C          REMEMBER THAT L=4 IS MISSING SIN(THETA)/SQRT(2)
      SUM=0.
      DO 411 I=1,4
      DO 411 J=I,4
      CALL SIGINT(FINT,ZLIM,ADWWWW(1,I),ADWWWW(2,I),ADWWWW(1,J),
     $ADWWWW(2,J))
        DO 412 L=1,4
        TERM=0.
          DO 413 N=0,6
          C=0.
          N1=MAX(N-3,0)
          N2=MIN(3,N)
          DO 414 K=N1,N2
414       C=C+ANWWWW(K+1,I,L)*ANWWWW(N-K+1,J,L)
          C=C*WTHELI(L)
          IF(J.NE.I) C=2.*C
          IF(L.EQ.4) THEN
            TERM=TERM+.5*C*FINT(N+1)-.5*C*FINT(N+3)
          ELSE
            TERM=TERM+C*FINT(N+1)
          ENDIF
413       CONTINUE
        SUM=SUM+TERM
412     CONTINUE
411   CONTINUE
C          ADD INTEGRAL OF IMAGINARY PART SQUARED.
      SUM=SUM+2.*ZLIM*(WTHELI(1)*AIWWWW(1)**2+WTHELI(2)*AIWWWW(2)**2
     $+WTHELI(3)*AIWWWW(3)**2+WTHELI(4)*AIWWWW(4)**2)
C          CROSS SECTION
      SIG0=SUM/(32.*PI*S*SCM)*UNITS
      SIG0=.5*SIG0
      SIG0=SIG0*TBRWW(4,1)*TBRWW(4,2)
      SIG=SIG0*QSAVE(27,1)*QSAVE(28,2)
      CALL SIGFIL(SIG,27,28,29,29)
      SIG=SIG0*QSAVE(28,1)*QSAVE(27,2)
      CALL SIGFIL(SIG,28,27,29,29)
C
C          Z0 Z0 --> Z0 Z0
C
C          SET UP AMPLITUDES
      CALL XZZZZ
C          SUM CROSS SECTION TERMS. I,J RUN OVER AMPLITUDE TERMS.
C          L RUNS OVER HELICITY STATES. N RUNS OVER POWERS.
C          REMEMBER THAT L=4 IS MISSING SIN(THETA)/SQRT(2)
      SUM=0.
      DO 421 I=1,4
      DO 421 J=I,4
      CALL SIGINT(FINT,ZLIM,ADWWWW(1,I),ADWWWW(2,I),ADWWWW(1,J),
     $ADWWWW(2,J))
        DO 422 L=1,4
        TERM=0.
          DO 423 N=0,6
          C=0.
          N1=MAX(N-3,0)
          N2=MIN(3,N)
          DO 424 K=N1,N2
424       C=C+ANWWWW(K+1,I,L)*ANWWWW(N-K+1,J,L)
          C=C*WTHELI(L)
          IF(J.NE.I) C=2.*C
          IF(L.EQ.4) THEN
            TERM=TERM+.5*C*FINT(N+1)-.5*C*FINT(N+3)
          ELSE
            TERM=TERM+C*FINT(N+1)
          ENDIF
423       CONTINUE
        SUM=SUM+TERM
422     CONTINUE
421   CONTINUE
C          ADD INTEGRAL OF IMAGINARY PART SQUARED.
      SUM=SUM+2.*ZLIM*(WTHELI(1)*AIWWWW(1)**2+WTHELI(2)*AIWWWW(2)**2
     $+WTHELI(3)*AIWWWW(3)**2+WTHELI(4)*AIWWWW(4)**2)
C          CROSS SECTION
      SIG0=SUM/(32.*PI*S*SCM)*UNITS
      SIG0=.5*SIG0
      SIG0=SIG0*TBRWW(4,1)*TBRWW(4,2)
      SIG=SIG0*QSAVE(29,1)*QSAVE(29,2)
      CALL SIGFIL(SIG,29,29,29,29)
C
500   RETURN
      END
CDECK  ID>, SIGH2.  
      SUBROUTINE SIGH2
C
C          COMPUTE THE WEINBERG-SALAM HIGGS CROSS SECTION
C          D(SIGMA)/D(QMW**2)D(YW)D(OMEGA)
C          FOR THE SPECIFIED JET TYPES. TRIVIAL EXCEPT FOR W W FUSION,
C          WHICH HAS INTERFERENCE WITH W W SCATTERING.
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/WSIG/SIGLLQ
      SAVE /WSIG/
      REAL      SIGLLQ
      COMMON/QSAVE/QSAVE(29,2)
      SAVE /QSAVE/
      REAL      QSAVE
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
C
      DIMENSION X(2),LISTJ(29),WTHELI(4)
      EQUIVALENCE (S,SHAT),(T,THAT),(U,UHAT),(X(1),X1)
      DOUBLE PRECISION C,TERM,SUM,DENOM,ZCM
C
C          WTHELI ARE WEIGHTS OF HELICITY AMPLITUDES IN SIGMA.
      DATA WTHELI/1.,2.,2.,4./
      DATA LISTJ/
     $9,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,
     $11,-11,12,-12,13,-13,14,-14,15,-15,16,-16,
     $10,80,-80,90/
C
C          QUARK OR GLUON FUSION TO HIGGS
C
      IF(INITYP(1).LE.25) THEN
        SIGLLQ=SIGEVT/(4.*PI)
        RETURN
      ENDIF
C
C          W+W FUSION AND W+W->W+W IN EFFECTIVE W APPROXIMATION.
C
C          KINEMATICS
      IFL1=LISTJ(JETTYP(1))
      IFL2=LISTJ(JETTYP(2))
      IFIN1=LISTJ(INITYP(1))
      IFIN2=LISTJ(INITYP(2))
      WMF=AMASS(IFL1)
      WMI=AMASS(IFIN1)
      PINPF=SQRT((S-4.*WMI**2)*(S-4.*WMF**2))
      ZCM=(.5*S+T-WMI**2-WMF**2)/(.5*PINPF)
C          RESET COEFFICIENTS FOR SELECTED PROCESS
      IABSI=IABS(IFIN1)
      IABSF=IABS(IFL1)
      IF(IABSI.EQ.80) THEN
        IF(IABSF.EQ.80) THEN
          CALL XWWWW
        ELSE
          CALL XWWZZ
        ENDIF
      ELSE
        IF(IABSF.EQ.80) THEN
          CALL XZZWW
        ELSE
          CALL XZZZZ
        ENDIF
      ENDIF
C          SUM CROSS SECTION TERMS. I,J RUN OVER AMPLITUDE TERMS.
C          L RUNS OVER HELICITY STATES. N RUNS OVER POWERS.
C          REMEMBER THAT L=4 IS MISSING SIN(THETA)/SQRT(2)
      SUM=0.
      DO 111 I=1,4
      DO 111 J=I,4
      DENOM=1./((ADWWWW(1,I)+ADWWWW(2,I)*ZCM)
     $*(ADWWWW(1,J)+ADWWWW(2,J)*ZCM))
        DO 112 L=1,4
        TERM=0.
          DO 113 N=0,6
          C=0.
          N1=MAX(N-3,0)
          N2=MIN(3,N)
          DO 114 K=N1,N2
114       C=C+ANWWWW(K+1,I,L)*ANWWWW(N-K+1,J,L)
          C=C*WTHELI(L)
          IF(J.NE.I) C=2.*C
          TERM=TERM+C*ZCM**N
113       CONTINUE
        IF(L.EQ.4) TERM=TERM*(1.-ZCM**2)/2.
        TERM=TERM*DENOM
        SUM=SUM+TERM
112     CONTINUE
111   CONTINUE
C          ADD IMAGINARY PART SQUARED.
      SUM=SUM+WTHELI(1)*AIWWWW(1)**2+WTHELI(2)*AIWWWW(2)**2
     $+WTHELI(3)*AIWWWW(3)**2+WTHELI(4)*AIWWWW(4)**2
C          CROSS SECTION. NOTE D(OMEGA)=2.*PI*D(Z)
      SIG0=SUM/(64.*PI**2*S*SCM)*UNITS
      SIG0=SIG0*TBRWW(JETTYP(1)-25,1)*TBRWW(JETTYP(2)-25,2)
C          SYMMETRY FACTOR
      IF(IABSF.EQ.90) SIG0=.5*SIG0
      SIGLLQ=SIG0*QSAVE(INITYP(1),1)*QSAVE(INITYP(2),2)
      RETURN
      END
CDECK  ID>, SIGH3.  
      SUBROUTINE SIGH3
C
C          Calculate angular distributions for W decays from Higgs,
C          d(sigma)/d(qmw**2)d(yw)d(omega)d(omega1)d(omega2)
C
C          Ver 7.14: Only modification needed for MSSM is to check
C          GOMSSM flag instead of INITYP
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/WSIG/SIGLLQ
      SAVE /WSIG/
      REAL      SIGLLQ
      COMMON/WWSIG/WWSIG
      SAVE /WWSIG/
      REAL      WWSIG
      COMMON/QSAVE/QSAVE(29,2)
      SAVE /QSAVE/
      REAL      QSAVE
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/WWPAR/SWW,TWW,UWW,WM2,ZM2,P1WW(5),P2WW(5),P3WW(5),P4WW(5)
     $,PZERO(4,4),S13,P3(5),Q1(5),Q3(5),JQWW(2)
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      SAVE /WWPAR/
      DOUBLE PRECISION SWW,TWW,UWW,WM2,ZM2,P1WW,P2WW,P3WW,P4WW
     $,PZERO,S13,P3,Q1,Q3
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      INTEGER   JQWW
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C
      EQUIVALENCE (S,SHAT),(T,THAT),(U,UHAT)
      DIMENSION IDADDR(4),IW(2),LAM(3),LISTJ(29)
     $,T12(3,3),T34(3,3),FTERM(4),FR(3,3),FI(3,3)
     $,CPHI12(3),SPHI12(3),CPHI34(3),SPHI34(3)
      DIMENSION PFCM(5,4),PWCM(5,2)
      DOUBLE PRECISION TERM,FTERM,ZCM
      DATA LAM/0,1,-1/
      DATA LISTJ/
     $9,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,
     $11,-11,12,-12,13,-13,14,-14,15,-15,16,-16,
     $10,80,-80,90/
C
C          FUNCTIONS
      DOTP(I,J)=PPAIR(4,I)*PPAIR(4,J)-PPAIR(1,I)*PPAIR(1,J)
     $-PPAIR(2,I)*PPAIR(2,J)-PPAIR(3,I)*PPAIR(3,J)
C
C          ENTRY
      IF(NPAIR.NE.4) RETURN
C
C          RECONSTRUCT W-->FF DECAY ANGLES
C
C          INITIALIZE PFCM AND PWCM
      DO 10 I=1,4
      DO 10 K=1,5
10    PFCM(K,I)=PPAIR(K,I)
      DO 11 I=1,2
      DO 11 K=1,5
11    PWCM(K,I)=PJETS(K,I)
C
C          Z BOOST TO WW CENTER OF MASS
      CHWW=QWJET(4)/QWJET(5)
      SHWW=QWJET(3)/QWJET(5)
      DO 20 I=1,4
      TMP=CHWW*PFCM(4,I)-SHWW*PFCM(3,I)
      PFCM(3,I)=-SHWW*PFCM(4,I)+CHWW*PFCM(3,I)
20    PFCM(4,I)=TMP
      DO 21 I=1,2
      TMP=CHWW*PWCM(4,I)-SHWW*PWCM(3,I)
      PWCM(3,I)=-SHWW*PWCM(4,I)+CHWW*PWCM(3,I)
21    PWCM(4,I)=TMP
C
C          ROTATE W1 TO +Z AXIS
      PTW1=SQRT(PWCM(1,1)**2+PWCM(2,1)**2)
      CPHIW1=PWCM(1,1)/PTW1
      SPHIW1=PWCM(2,1)/PTW1
      PW1=SQRT(PTW1**2+PWCM(3,1)**2)
      CTHW1=PWCM(3,1)/PW1
      STHW1=PTW1/PW1
C          Z ROTATION
      DO 30 I=1,4
      TMP=CPHIW1*PFCM(1,I)+SPHIW1*PFCM(2,I)
      PFCM(2,I)=-SPHIW1*PFCM(1,I)+CPHIW1*PFCM(2,I)
30    PFCM(1,I)=TMP
C          Y ROTATION
      DO 31 I=1,4
      TMP=CTHW1*PFCM(1,I)-STHW1*PFCM(3,I)
      PFCM(3,I)=STHW1*PFCM(1,I)+CTHW1*PFCM(3,I)
31    PFCM(1,I)=TMP
C
C          BOOST TO W REST FRAMES
      CHW1=PWCM(4,1)/PWCM(5,1)
      SHW1=PW1/PWCM(5,1)
      DO 40 I=1,4
      IF(I.LE.2) THEN
        SHWI=SHW1
      ELSE
        SHWI=-SHW1
      ENDIF
      TMP=CHW1*PFCM(4,I)-SHWI*PFCM(3,I)
      PFCM(3,I)=-SHWI*PFCM(4,I)+CHW1*PFCM(3,I)
40    PFCM(4,I)=TMP
C
C          COMPUTE ANGLES
      TH12=ACOS(PFCM(3,1)/SQRT(PFCM(1,1)**2+PFCM(2,1)**2+PFCM(3,1)**2))
      PHI12=ATAN2(PFCM(2,1),PFCM(1,1))
      TH34=ACOS(PFCM(3,3)/SQRT(PFCM(1,3)**2+PFCM(2,3)**2+PFCM(3,3)**2))
      PHI34=ATAN2(PFCM(2,3),PFCM(1,3))
C
C          COMPUTE DECAY ANGULAR DISTRIBUTIONS.
C
      DO 100 I=1,4
      IDADDR(I)=IABS(IDPAIR(I))
100   IF(IDADDR(I).GE.11) IDADDR(I)=IDADDR(I)-4
      IF(GOMSSM) THEN
        IW(1)=JETTYP(1)-76
        IW(2)=JETTYP(2)-76
      ELSE
        IW(1)=JETTYP(1)-25
        IW(2)=JETTYP(2)-25
      ENDIF
C
      AMV=PJETS(5,1)
      GAMV=WGAM(IW(1))
      QMH=QMW
C          COUPLINGS
      A12=AQ(IDADDR(1),IW(1))
      B12=BQ(IDADDR(1),IW(1))
      A34=AQ(IDADDR(3),IW(2))
      B34=BQ(IDADDR(3),IW(2))
C          DECAY DISTRIBUTIONS
      TVV12=8.*PI*ALFA*(A12**2+B12**2)
      TVA12=16.*PI*ALFA*A12*B12
      COS12=COS(TH12)
      SIN12=SIN(TH12)
      T12(1,1)=TVV12*SIN12**2
      T12(1,2)=TVV12*SIN12*COS12/SQRT2+TVA12*SIN12/SQRT2
      T12(1,3)=-TVV12*SIN12*COS12/SQRT2+TVA12*SIN12/SQRT2
      T12(2,1)=T12(1,2)
      T12(2,2)=TVV12*(.5+.5*COS12**2)+TVA12*COS12
      T12(2,3)=TVV12*.5*SIN12**2
      T12(3,1)=T12(1,3)
      T12(3,2)=T12(2,3)
      T12(3,3)=TVV12*(.5+.5*COS12**2)-TVA12*COS12
C
      TVV34=8.*PI*ALFA*(A34**2+B34**2)
      TVA34=16.*PI*ALFA*A34*B34
      COS34=COS(TH34)
      SIN34=SIN(TH34)
      T34(1,1)=TVV34*SIN34**2
      T34(1,2)=TVV34*SIN34*COS34/SQRT2+TVA34*SIN34/SQRT2
      T34(1,3)=-TVV34*SIN34*COS34/SQRT2+TVA34*SIN34/SQRT2
      T34(2,1)=T34(1,2)
      T34(2,2)=TVV34*(.5+.5*COS34**2)+TVA34*COS34
      T34(2,3)=TVV34*.5*SIN34**2
      T34(3,1)=T34(1,3)
      T34(3,2)=T34(2,3)
      T34(3,3)=TVV34*(.5+.5*COS34**2)-TVA34*COS34
C
      CPHI12(1)=1.
      CPHI12(2)=COS(PHI12)
      CPHI12(3)=COS(2.*PHI12)
      SPHI12(1)=0.
      SPHI12(2)=SIN(PHI12)
      SPHI12(3)=SIN(2.*PHI12)
      CPHI34(1)=1.
      CPHI34(2)=COS(PHI34)
      CPHI34(3)=COS(2.*PHI34)
      SPHI34(1)=0.
      SPHI34(2)=SIN(PHI34)
      SPHI34(3)=SIN(2.*PHI34)
C
      TCPHI=CPHI12(2)*CPHI34(2)-SPHI12(2)*SPHI34(2)
      TSPHI=SPHI12(2)*CPHI34(2)+CPHI12(2)*SPHI34(2)
      TC2PHI=CPHI12(3)*CPHI34(3)-SPHI12(3)*SPHI34(3)
      TS2PHI=SPHI12(3)*CPHI34(3)+CPHI12(3)*SPHI34(3)
C
C          PURE HIGGS --> W W. CALCULATE ANGULAR DISTRIBUTION FOR
C          HIGGS DECAY AND MULTIPLY BY CROSS SECTION.
C
      IF(INITYP(1).LE.25.OR.GOMSSM) THEN
        F0=.5*QMH**2/AMV**2-1.
        F1=1.
        TOTAL=(8.*PI/3.)**2*TVV12*TVV34*(F0**2+2.*F1**2)
        DIFF=F0**2*T12(1,1)*T34(1,1)
     $  +F0*F1*(2.*T12(1,2)*T34(1,2)+2.*T12(1,3)*T34(1,3))*TCPHI
     $  +F1**2*(T12(2,2)*T34(1,2)+T12(3,3)*T34(3,3)
     $    +2.*T12(2,3)*T34(2,3)*TC2PHI)
        WWSIG=SIGLLQ*DIFF/TOTAL
        RETURN
      ENDIF
C
C          W W FUSION. CALCULATE ANGULAR DISTRIUBTION FOR DECAY
C          INCLUDING ALL GRAPHS.
C
C          KINEMATICS
      IFL1=LISTJ(JETTYP(1))
      IFL2=LISTJ(JETTYP(2))
      IFIN1=LISTJ(INITYP(1))
      IFIN2=LISTJ(INITYP(2))
      WMF=AMASS(IFL1)
      WMI=AMASS(IFIN1)
      PINPF=SQRT((S-4.*WMI**2)*(S-4.*WMF**2))
      ZCM=(.5*S+T-WMI**2-WMF**2)/(.5*PINPF)
C          PRODUCTION AMPLITUDES. REMEMBER MISSING SIN(THETA)/SQRT(2)
      DO 110 L=1,4
      FTERM(L)=0.
      DO 120 J=1,4
      TERM=0.
      DO 130 I=1,4
130   TERM=TERM+ANWWWW(I,J,L)*ZCM**(I-1)
      TERM=TERM/(ADWWWW(1,J)+ADWWWW(2,J)*ZCM)
120   FTERM(L)=FTERM(L)+TERM
110   CONTINUE
      FTERM(4)=FTERM(4)*SQRT(ABS(1.-ZCM**2))/SQRT2
C          HELICITY AMPLITUDES. NOTATION IS 0,+,-
      FR(1,1)=FTERM(1)
      FI(1,1)=AIWWWW(1)
      FR(1,2)=FTERM(4)
      FI(1,2)=AIWWWW(4)
      FR(2,2)=FTERM(3)
      FI(2,2)=AIWWWW(3)
      FR(2,3)=FTERM(2)
      FI(2,3)=AIWWWW(2)
C
      FR(1,3)=FR(1,2)
      FI(1,3)=FI(1,2)
      FR(3,1)=FR(1,3)
      FI(3,1)=FI(1,3)
      FR(2,1)=FR(1,2)
      FI(2,1)=FI(1,2)
C
      FR(3,3)=FR(2,2)
      FI(3,3)=FI(2,2)
      FR(3,2)=FR(2,3)
      FI(3,2)=FI(2,3)
C
C          DIFFERENTIAL DISTRIBUTION FROM DENSITY MATRIX
      DIFF=0.
      DO 140 I1=1,3
      L1=LAM(I1)
      DO 140 I2=1,3
      L2=LAM(I2)
      DO 140 I3=1,3
      L3=LAM(I3)
      DO 140 I4=1,3
      L4=LAM(I4)
      L12=L1-L2
      I12=IABS(L12)+1
      IF(I12.EQ.0) I12=3
      L34=L3-L4
      I34=IABS(L34)+1
      IF(I34.EQ.0) I34=3
      C1234=CPHI12(I12)*CPHI34(I34)
     $-SPHI12(I12)*ISIGN(1,L12)*SPHI34(I34)*ISIGN(1,L34)
      S1234=SPHI12(I12)*ISIGN(1,L12)*CPHI34(I34)
     $+CPHI12(I12)*SPHI34(I34)*ISIGN(1,L34)
      DIFF=DIFF+(FR(I1,I2)*FR(I3,I4)+FI(I1,I2)*FI(I3,I4))
     $*T12(I3,I1)*T34(I4,I2)*C1234
     $+(FR(I1,I2)*FI(I3,I4)-FI(I1,I2)*FR(I3,I4))
     $*T12(I3,I1)*T34(I4,I2)*S1234
140   CONTINUE
C          INTEGRATED DISTRIBUTION
      TOTAL=0.
      DO 150 I1=1,3
      DO 150 I2=1,3
      TOTAL=TOTAL+FR(I1,I2)**2+FI(I1,I2)**2
150   CONTINUE
      FAC=(16.*PI/3.*4.*PI*ALFA)**2
      FAC=FAC*(A12**2+B12**2)*(A34**2+B34**2)
      TOTAL=TOTAL*FAC
      WWSIG=DIFF/TOTAL*SIGLLQ
      RETURN
      END
CDECK  ID>, SIGHSS. 
      SUBROUTINE SIGHSS
C
C          Compute the integrated MSSM Higgs cross section
C          d(sigma)/d(QMW**2)d(YW)
C          Since SUSY Higgs are always narrow, can use the widths to
C          determine couplings and ignore interference with continuum.
C
C          SIGMA    = cross section summed over quark types allowed by
C                     JETTYPE and WTYPE cards.
C          SIGS(I)  = partial cross section for I1 + I2 --> I3 + I4.
C          INOUT(I) = IOPAK**3*I4 + IOPAK**2*I3 + IOPAK*I2 + I1
C                     using JETTYPE code from LISTSS.
C
C          Ver 7.18: Correct GOQ's and include TBRWW for W/Z modes.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/QSAVE/QSAVE(29,2)
      SAVE /QSAVE/
      REAL      QSAVE
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
C
      REAL X(2)
      REAL AMASS,STRUC
      REAL AM1,AM2,S,T,U,Q2SAVE,YHAT,EY,ANEFF,QMW2,QZW,EHAT,SIG0,SIG,
     $AMW
      INTEGER JT1,JT2,I,J,IH,IQ,I1,I2,JTGL,JTOFF
      EQUIVALENCE (S,SHAT),(T,THAT),(U,UHAT),(X(1),X1)
C
C          Kinematics (identical to Drell-Yan)
C
      QMW2=QMW**2
      QTMW=SQRT(QMW2+QTW**2)
      Q0W=QTMW*COSH(YW)
      QZW=QTMW*SINH(YW)
      QW=SQRT(QZW**2+QTW**2)
      IF(QW.NE.0.) THEN
        CTHW=QZW/QW
        STHW=QTW/QW
        IF(ABS(CTHW).LT.1.) THEN
          THW=ACOS(CTHW)
        ELSE
          CTHW=0.
          STHW=1.
          THW=.5*PI
        ENDIF
      ELSE
        CTHW=0.
        STHW=1.
        THW=.5*PI
      ENDIF
      EHAT=QMW
      SHAT=QMW**2
      QSQ=SHAT
      ANEFF=4.+QSQ/(QSQ+AMASS(5)**2)+QSQ/(QSQ+AMASS(6)**2)
      ALFQSQ=12.*PI/((33.-ANEFF)*ALOG(QSQ/ALAM2))
      Q2SAVE=QSQ
      YHAT=YW
      EY=EXP(YHAT)
      X1=EHAT/ECM*EY
      X2=EHAT/(ECM*EY)
C
C          Initialize
C
      SIGMA=0.
      NSIGS=0
      DO 100 I=1,MXSIGS
100   SIGS(I)=0
      IF(X1.GE.1..OR.X2.GE.1.) RETURN
C
C          Compute structure functions
C
      DO 110 IH=1,2
        DO 120 IQ=1,13
120     QSAVE(IQ,IH)=STRUC(X(IH),QSQ,IQ,IDIN(IH))/X(IH)
        DO 130 IQ=14,26
130     QSAVE(IQ,IH)=0.
110   CONTINUE
C
C          gl + gl -> Higgs
C
      JTGL=52
      SIG0=PI*HMASS**2/(8*S**2)*HGAMSS(JTGL,JTGL)*X1*X2*UNITS
     $/((S-HMASS**2)**2+(HMASS*HGAM)**2)
      SIG0=SIG0*QSAVE(1,1)*QSAVE(1,2)
      DO 200 I=1,85
        DO 210 J=1,85
          IF(HGAMSS(I,J).EQ.0) GO TO 210
          IF(.NOT.(GOQ(I,1).AND.GOQ(J,2))) GO TO 210
          SIG=SIG0*HGAMSS(I,J)
C          Include W/Z branching ratios
          IF((I.GE.78.AND.I.LE.80).AND.(J.GE.78.AND.J.LE.80)) THEN
            SIG=SIG*TBRWW(I-76,1)*TBRWW(J-76,2)
          ENDIF
          CALL SIGFIL(SIG,JTGL,JTGL,I,J)
210     CONTINUE
200   CONTINUE
C
C          qk + qb -> Higgs
C
      JTOFF=51
C          Note I1,I2 run over quarks; JT1,JT2,I,J over LISTSS
      DO 300 I1=2,13
        AM1=AMASS(I1/2)
        JT1=I1+JTOFF
        DO 310 I2=2,13
          AM2=AMASS(I2/2)
          JT2=I2+JTOFF
          IF(HGAMSS(JT1,JT2).LE.0) GO TO 310
          SIG0=4*PI*HMASS**2/(9*S**2)*HGAMSS(JT1,JT2)*X1*X2*UNITS
     $    /((S-HMASS**2)**2+(HMASS*HGAM)**2)
          SIG0=SIG0*QSAVE(I1,1)*QSAVE(I2,2)
C          Decay partial cross sections
          DO 320 I=1,85
            DO 330 J=1,85
              IF(HGAMSS(I,J).EQ.0) GO TO 330
              IF(.NOT.(GOQ(I,1).AND.GOQ(J,2))) GO TO 330
              SIG=SIG0*HGAMSS(I,J)
C          Include W/Z branching ratios
              IF((I.GE.78.AND.I.LE.80).AND.(J.GE.78.AND.J.LE.80)) THEN
                SIG=SIG*TBRWW(I-76,1)*TBRWW(J-76,2)
              ENDIF
              CALL SIGFIL(SIG,JT1,JT2,I,J)
330         CONTINUE
320       CONTINUE
310     CONTINUE
300   CONTINUE
C
      RETURN
      END
CDECK  ID>, SIGINT. 
      SUBROUTINE SIGINT(F,Z,A1S,B1S,A2S,B2S)
C
C          F(N+1) = INT(-Z,Z)(DX X**N/((A1+B1*X)*A2+B2*X)))
C          F(8) = F(9) = 0 (DUMMY VALUES)
C
      DIMENSION F(9)
      DOUBLE PRECISION A1,B1,A2,B2,A,B,C,Z,F,A1S,B1S,A2S,B2S
C
      A1=A1S
      B1=B1S
      A2=A2S
      B2=B2S
      F(8)=0.
      F(9)=0.
C
C          SPECIAL CASE: X**N/(A1*A2)
      IF(B1.EQ.0..AND.B2.EQ.0.) THEN
        F(1)=2.*Z/(A1*A2)
        F(2)=0.
        F(3)=2.*Z**3/(3.*A1*A2)
        F(4)=0.
        F(5)=2.*Z**5/(5.*A1*A2)
        F(6)=0.
        F(7)=2.*Z**7/(7.*A1*A2)
        RETURN
      ENDIF
C
C          SPECIAL CASE: X**N/(A+BX)
      IF(B1.EQ.0..OR.B2.EQ.0.) THEN
        IF(B1.EQ.0.) THEN
          A=A2/B2
          C=1./(A1*B2)
        ELSE
          A=A1/B1
          C=1./(A2*B1)
        ENDIF
        F(1)=LOG((A+Z)/(A-Z))
        F(1)=F(1)*C
        F(2)=-A*LOG((A+Z)/(A-Z))+2.*Z
        F(2)=F(2)*C
        F(3)=A**2*LOG((A+Z)/(A-Z))-2.*A*Z
        F(3)=F(3)*C
        F(4)=-A**3*LOG((A+Z)/(A-Z))+2.*A**2*Z+2.*Z**3/3.
        F(4)=F(4)*C
        F(5)=A**4*LOG((A+Z)/(A-Z))-2.*A**3*Z-2.*A*Z**3/3.
        F(5)=F(5)*C
        F(6)=-A**5*LOG((A+Z)/(A-Z))+2.*A**4*Z+2.*A**2*Z**3/3.+2.*Z**5/5.
        F(6)=F(6)*C
        F(7)=A**6*LOG((A+Z)/(A-Z))-2.*A**5*Z-2.*A**3*Z**3/3.
     $  -2.*A*Z**5/5.
        F(7)=F(7)*C
        RETURN
      ENDIF
C
C          B1 AND B2 NONZERO
      A1=A1/B1
      A2=A2/B2
      C=1./(B1*B2)
C
C          SPECIAL CASE: X**N/(A+B*X)**2
      IF(A1.EQ.A2) THEN
        A=A1
        F(1)=2.*Z/(A**2-Z**2)
        F(1)=F(1)*C
        F(2)=-2.*A*Z/(A**2-Z**2)+LOG((A+Z)/(A-Z))
        F(2)=F(2)*C
        F(3)=(4.*A**2*Z-2.*Z**3)/(A**2-Z**2)-2.*A*LOG((A+Z)/(A-Z))
        F(3)=F(3)*C
        F(4)=(4.*A*Z**3-6.*A**3*Z)/(A**2-Z**2)+3.*A**2*LOG((A+Z)/(A-Z))
        F(4)=F(4)*C
        F(5)=(-16.*A**2*Z**3/3.+8.*A**4*Z-2.*Z**5/3.)/(A**2-Z**2)
     $  -4.*A**3*LOG((A+Z)/(A-Z))
        F(5)=F(5)*C
        F(6)=(4.*A*Z**5/3.+20.*A**3*Z**3/3.-10.*A**5*Z)/(A**2-Z**2)
     $  +5*A**4*LOG((A+Z)/(A-Z))
        F(6)=F(6)*C
        F(7)=(-8.*A**2*Z**5/5.-8.*A**4*Z**3+12.*A**6*Z-2.*Z**7/5.)
     $  /(A**2-Z**2)-6.*A**5*LOG((A+Z)/(A-Z))
        F(7)=F(7)*C
        RETURN
      ENDIF
C
C          GENERAL CASE
      F(1)=(-LOG((A1+Z)/(A1-Z))+LOG((A2+Z)/(A2-Z)))/(A1-A2)
      F(1)=F(1)*C
      F(2)=(A1*LOG((A1+Z)/(A1-Z))-A2*LOG((A2+Z)/(A2-Z)))/(A1-A2)
      F(2)=F(2)*C
      F(3)=(-A1**2*LOG((A1+Z)/(A1-Z))+A2**2*LOG((A2+Z)/(A2-Z)))/(A1-A2)
     $+2.*Z
      F(3)=F(3)*C
      F(4)=(A1**3*LOG((A1+Z)/(A1-Z))-A2**3*LOG((A2+Z)/(A2-Z)))/(A1-A2)
     $+2.*Z*(-A1-A2)
      F(4)=F(4)*C
      F(5)=(-A1**4*LOG((A1+Z)/(A1-Z))+A2**4*LOG((A2+Z)/(A2-Z)))/(A1-A2)
     $+2.*Z*(A1*A2+A1**2+A2**2)+2.*Z**3/3.
      F(5)=F(5)*C
      F(6)=(A1**5*LOG((A1+Z)/(A1-Z))-A2**5*LOG((A2+Z)/(A2-Z)))/(A1-A2)
     $+2.*Z*(-A1*A2**2-A1**2*A2-A1**3-A2**3)+2.*Z**3/3.*(-A1-A2)
      F(6)=F(6)*C
      F(7)=(-A1**6*LOG((A1+Z)/(A1-Z))+A2**6*LOG((A2+Z)/(A2-Z)))/(A1-A2)
     $+2.*Z*(A1*A2**3+A1**2*A2**2+A1**3*A2+A1**4+A2**4)
     $+2.*Z**3/3.*(A1*A2+A1**2+A2**2)+2.*Z**5/5.
      F(7)=F(7)*C
      RETURN
      END
CDECK  ID>, SIGQCD. 
      SUBROUTINE SIGQCD
C
C          Compute D(SIGMA)/D(PT**2)D(Y1)D(Y2)
C          Include quark masses for ch, bt, and tp and 4th generation.
C          Note ch is now treated as heavy.
C
C          SIGMA    = cross section summed over quark types allowed by
C                     JETTYPE card.
C          SIGS(I)  = partial cross section for I1 + I2 --> I3 + I4.
C          INOUT(I) = IOPAK**3*I4 + IOPAK**2*I3 + IOPAK*I2 + I1
C                     using JETTYPE code.
C
C          Cross sections from Feynman, Field and Fox, P.R. D18, 3320
C          Massive cross sections from B. Combridge, N.P. B151, 429.
C          Extra factor of 1/2 needed for  non-identical jets since all
C          all jets are treated as identical.
C
C          Ver 6.35: Fix kinematics for gl + tp -> gl + tp, etc.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
C
      REAL    X(2),QSAVE(13,2),EBT(2)
      EQUIVALENCE (X(1),X1),(S,SHAT),(T,THAT),(U,UHAT)
      REAL    FFF1,FFF2,FFF3,FFF4,FFF5,FFF6,FFF7,S,T,U,FGQ,AM2,FQQ,
     $        QFCN,STRUC,FJAC,SIG,AMASS,SIG1,AMQ,FJACBT,SIG2,QQ,XQMIN,
     $        E1,E2
      INTEGER IQ,IH,I,J,IFL,JTYP1,JTYP2,IQ1,IQ2
C
C          Elementary cross sections from Feynman, Field, and Fox.
C
      FFF1(S,T,U)=4./9.*(S**2+U**2)/T**2
      FFF2(S,T,U)=4./9.*((S**2+U**2)/T**2+(S**2+T**2)/U**2)
     1-8./27.*S**2/(U*T)
      FFF3(S,T,U)=4./9.*((S**2+U**2)/T**2+(T**2+U**2)/S**2)
     1-8./27.*U**2/(S*T)
      FFF4(S,T,U)=32./27.*(U**2+T**2)/(U*T)-8./3.*(U**2+T**2)/S**2
      FFF5(S,T,U)=1./6.*(U**2+T**2)/(U*T)-3./8.*(U**2+T**2)/S**2
      FFF6(S,T,U)=-4./9.*(U**2+S**2)/(U*S)+(U**2+S**2)/T**2
      FFF7(S,T,U)=9./2.*(3.-U*T/S**2-U*S/T**2-S*T/U**2)
C          Heavy quark cross sections from Combridge
      FGQ(S,T,U)=2.*(S-AM2)*(AM2-U)/T**2
     1+4./9.*((S-AM2)*(AM2-U)+2.*AM2*(S+AM2))/(S-AM2)**2
     2+4./9.*((S-AM2)*(AM2-U)+2.*AM2*(AM2+U))/(AM2-U)**2
     3+1./9.*AM2*(4.*AM2-T)/((S-AM2)*(AM2-U))
     4+((S-AM2)*(AM2-U)+AM2*(S-U))/(T*(S-AM2))
     5-((S-AM2)*(AM2-U)-AM2*(S-U))/(T*(AM2-U))
      FQQ(S,T,U)=4./9.*((AM2-U)**2+(S-AM2)**2+2.*AM2*T)/T**2
      QFCN(IQ,IH)=STRUC(X(IH),QSQ,IQ,IDIN(IH))/X(IH)
C
C          Use massless kinematics for ch and lighter quarks.
C
      CALL TWOKIN(0.,0.,0.,0.)
      FJAC=SHAT/SCM*UNITS
      FJAC=FJAC*PI*ALFQSQ**2/SHAT**2
C
C          Initialize cross sections.
C
      SIGMA=0.
      NSIGS=0
      DO 100 I=1,MXSIGS
        SIGS(I)=0.
100   CONTINUE
      IF(X1.GE.1.0.OR.X2.GE.1.0) RETURN
C          Compute structure functions
      DO 110 IH=1,2
      DO 110 IQ=1,7
        QSAVE(IQ,IH)=STRUC(X(IH),QSQ,IQ,IDIN(IH))/X(IH)
110   CONTINUE
C
C          Compute cross sections summed over quark types allowed by
C          JETTYPE card.
C
C          Gluon-gluon
      IF(.NOT.(GOQ(1,1).AND.GOQ(1,2))) GO TO 210
      SIG=.5*FJAC*QSAVE(1,1)*QSAVE(1,2)*FFF7(S,T,U)
      CALL SIGFIL(SIG,1,1,1,1)
C
      DO 201 I=1,3
        SIG=.5*FJAC*QSAVE(2*I,1)*QSAVE(2*I+1,2)*FFF4(S,T,U)
        CALL SIGFIL(SIG,2*I,2*I+1,1,1)
        SIG=.5*FJAC*QSAVE(2*I+1,1)*QSAVE(2*I,2)*FFF4(S,U,T)
        CALL SIGFIL(SIG,2*I+1,2*I,1,1)
201   CONTINUE
C
C          Quark-gluon
210   CONTINUE
      DO 211 I=2,7
        IF(.NOT.(GOQ(I,1).AND.GOQ(1,2))) GO TO 212
        SIG=.5*FJAC*QSAVE(I,1)*QSAVE(1,2)*FFF6(S,T,U)
        CALL SIGFIL(SIG,I,1,I,1)
        SIG=.5*FJAC*QSAVE(1,1)*QSAVE(I,2)*FFF6(S,U,T)
        CALL SIGFIL(SIG,1,I,I,1)
212     CONTINUE
        IF(.NOT.(GOQ(1,1).AND.GOQ(I,2))) GO TO 211
        SIG=.5*FJAC*QSAVE(1,1)*QSAVE(I,2)*FFF6(S,T,U)
        CALL SIGFIL(SIG,1,I,1,I)
        SIG=.5*FJAC*QSAVE(I,1)*QSAVE(1,2)*FFF6(S,U,T)
        CALL SIGFIL(SIG,I,1,1,I)
211   CONTINUE
C
C          Identical quark-quark
      DO 220 I=2,7
        IF(.NOT.(GOQ(I,1).AND.GOQ(I,2))) GO TO 220
        SIG=.5*FJAC*QSAVE(I,1)*QSAVE(I,2)*FFF2(S,T,U)
        CALL SIGFIL(SIG,I,I,I,I)
220   CONTINUE
C
C          Identical quark-antiquark
      DO 230 I=1,3
        IF(SHAT.LT.4.*AMASS(I)**2) GO TO 230
        IF(.NOT.(GOQ(2*I,1).AND.GOQ(2*I+1,2))) GO TO 235
        SIG=.5*FJAC*QSAVE(1,1)*QSAVE(1,2)*FFF5(S,T,U)
        CALL SIGFIL(SIG,1,1,2*I,2*I+1)
        DO 231 J=1,3
          IF(J.EQ.I) GO TO 231
          SIG=.5*FJAC*QSAVE(2*J,1)*QSAVE(2*J+1,2)*FFF1(T,S,U)
          CALL SIGFIL(SIG,2*J,2*J+1,2*I,2*I+1)
          SIG=.5*FJAC*QSAVE(2*J+1,1)*QSAVE(2*J,2)*FFF1(T,S,U)
          CALL SIGFIL(SIG,2*J+1,2*J,2*I,2*I+1)
231     CONTINUE
        SIG=.5*FJAC*QSAVE(2*I,1)*QSAVE(2*I+1,2)*FFF3(S,T,U)
        CALL SIGFIL(SIG,2*I,2*I+1,2*I,2*I+1)
        SIG=.5*FJAC*QSAVE(2*I+1,1)*QSAVE(2*I,2)*FFF3(S,U,T)
        CALL SIGFIL(SIG,2*I+1,2*I,2*I,2*I+1)
C
235     CONTINUE
        IF(.NOT.(GOQ(2*I+1,1).AND.GOQ(2*I,2))) GO TO 230
        SIG=.5*FJAC*QSAVE(1,1)*QSAVE(1,2)*FFF5(S,T,U)
        CALL SIGFIL(SIG,1,1,2*I+1,2*I)
        DO 236 J=1,3
          IF(J.EQ.I) GO TO 236
          SIG=.5*FJAC*QSAVE(2*J,1)*QSAVE(2*J+1,2)*FFF1(T,S,U)
          CALL SIGFIL(SIG,2*J,2*J+1,2*I+1,2*I)
          SIG=.5*FJAC*QSAVE(2*J+1,1)*QSAVE(2*J,2)*FFF1(T,S,U)
          CALL SIGFIL(SIG,2*J+1,2*J,2*I+1,2*I)
236     CONTINUE
        SIG1=.5*FJAC*QSAVE(2*I,1)*QSAVE(2*I+1,2)*FFF3(S,U,T)
        CALL SIGFIL(SIG1,2*I,2*I+1,2*I+1,2*I)
        SIG=.5*FJAC*QSAVE(2*I+1,1)*QSAVE(2*I,2)*FFF3(S,T,U)
        CALL SIGFIL(SIG,2*I+1,2*I,2*I+1,2*I)
230   CONTINUE
C
C          General massless quark-quark
      DO 240 I=2,7
        DO 241 J=2,7
          IF(.NOT.(GOQ(I,1).AND.GOQ(J,2))) GO TO 241
          IF((I/2).EQ.(J/2)) GO TO 241
          SIG=.5*FJAC*QSAVE(I,1)*QSAVE(J,2)*FFF1(S,T,U)
          CALL SIGFIL(SIG,I,J,I,J)
          SIG=.5*FJAC*QSAVE(J,1)*QSAVE(I,2)*FFF1(S,U,T)
          CALL SIGFIL(SIG,I,J,J,I)
241     CONTINUE
240   CONTINUE
C
C          CH+CB, BT+BB, and TP+TB cross sections.
C          Y=-log(tan(theta/2)), so Jacobean contains P1*P2/E1*E2.
C          Also fourth generation.
C
      DO 250 IQ=1,5
        IFL=IQ+3
        JTYP1=2*IFL
        JTYP2=JTYP1+1
        IF(.NOT.((GOQ(JTYP1,1).AND.GOQ(JTYP2,2)).OR.
     1  (GOQ(JTYP2,1).AND.GOQ(JTYP1,2)))) GO TO 250
        AMQ=AMASS(IFL)
        IF(AMQ.LT.0.) GO TO 250
        AM2=AMQ**2
        CALL TWOKIN(0.,0.,AMQ,AMQ)
        IF(X(1).GE.1..OR.X(2).GE.1.) GO TO 250
        EBT(1)=SQRT(P(1)**2+AM2)
        EBT(2)=SQRT(P(2)**2+AM2)
        FJACBT=.5*S/SCM*UNITS*P(1)*P(2)/(EBT(1)*EBT(2))
        SIG1=12.*(AM2-T)*(AM2-U)/S**2
     1  +8./3.*((AM2-T)*(AM2-U)-2.*AM2*(AM2+T))/(AM2-T)**2
     2  +8./3.*((AM2-T)*(AM2-U)-2.*AM2*(AM2+U))/(AM2-U)**2
     3  -2./3.*AM2*(S-4.*AM2)/((AM2-T)*(AM2-U))
     4  -6.*((AM2-T)*(AM2-U)+AM2*(U-T))/(S*(AM2-T))
     5  -6.*((AM2-T)*(AM2-U)+AM2*(T-U))/(S*(AM2-U))
        SIG1=SIG1*PI**2*ALFQSQ**2/(16.*PI*S**2)
        SIG=FJACBT*SIG1*STRUC(X(1),QSQ,1,IDIN(1))/X(1)
     1  *STRUC(X(2),QSQ,1,IDIN(2))/X(2)
        IF(GOQ(JTYP1,1).AND.GOQ(JTYP2,2))
     $  CALL SIGFIL(SIG,1,1,JTYP1,JTYP2)
        IF(GOQ(JTYP2,1).AND.GOQ(JTYP1,2))
     $  CALL SIGFIL(SIG,1,1,JTYP2,JTYP1)
C
        SIG2=((AM2-T)**2+(AM2-U)**2+2.*S*AM2)/S**2
        SIG2=FJACBT*SIG2*64.*PI**2*ALFQSQ**2/(9.*16.*PI*S**2)
        DO 255 I=1,3
          QQ=STRUC(X(1),QSQ,2*I,IDIN(1))*STRUC(X(2),QSQ,2*I+1,IDIN(2))
          SIG=SIG2*QQ/(X(1)*X(2))
          IF(GOQ(JTYP1,1).AND.GOQ(JTYP2,2))
     $    CALL SIGFIL(SIG,2*I,2*I+1,JTYP1,JTYP2)
          IF(GOQ(JTYP2,1).AND.GOQ(JTYP1,2))
     $    CALL SIGFIL(SIG,2*I,2*I+1,JTYP2,JTYP1)
          QQ=STRUC(X(1),QSQ,2*I+1,IDIN(1))*STRUC(X(2),QSQ,2*I,IDIN(2))
          SIG=SIG2*QQ/(X(1)*X(2))
          IF(GOQ(JTYP1,1).AND.GOQ(JTYP2,2))
     $    CALL SIGFIL(SIG,2*I+1,2*I,JTYP1,JTYP2)
          IF(GOQ(JTYP2,1).AND.GOQ(JTYP1,2))
     $    CALL SIGFIL(SIG,2*I+1,2*I,JTYP2,JTYP1)
255     CONTINUE
250   CONTINUE
C
C          Gluon + heavy quark
      DO 300 IQ=8,13.
        IF(.NOT.(GOQ(1,1).AND.GOQ(IQ,2))) GO TO 310
        AMQ=AMASS(IQ/2)
        AM2=AMQ**2
        XQMIN=AMQ/ECM
        E1=P(1)
        E2=SQRT(P(2)**2+AM2)
        FJAC=.5*S/SCM*UNITS*PI*ALFQSQ**2/S**2
        CALL TWOKIN(0.,AMQ,0.,AMQ)
        IF(X(1).LT.1..AND.X(2).LT.1..AND.X(2).GT.XQMIN) THEN
          SIG=FJAC*P(1)*P(2)/(E1*E2)*FGQ(S,T,U)*QFCN(1,1)*QFCN(IQ,2)
          CALL SIGFIL(SIG,1,IQ,1,IQ)
        ENDIF
        CALL TWOKIN(AMQ,0.,0.,AMQ)
        IF(X(1).LT.1..AND.X(2).LT.1..AND.X(1).GT.XQMIN) THEN
          SIG=FJAC*P(1)*P(2)/(E1*E2)*FGQ(S,U,T)*QFCN(IQ,1)*QFCN(1,2)
          CALL SIGFIL(SIG,IQ,1,1,IQ)
        ENDIF
C
310     IF(.NOT.(GOQ(IQ,1).AND.GOQ(1,2))) GO TO 300
        AMQ=AMASS(IQ/2)
        AM2=AMQ**2
        XQMIN=AMQ/ECM
        E1=SQRT(P(1)**2+AM2)
        E2=P(2)
        FJAC=.5*S/SCM*UNITS*PI*ALFQSQ**2/S**2
        CALL TWOKIN(0.,AMQ,AMQ,0.)
        IF(X(1).LT.1..AND.X(2).LT.1..AND.X(2).GT.XQMIN) THEN
          SIG=FJAC*P(1)*P(2)/(E1*E2)*FGQ(S,U,T)*QFCN(1,1)*QFCN(IQ,2)
          CALL SIGFIL(SIG,1,IQ,IQ,1)
        ENDIF
        CALL TWOKIN(AMQ,0.,AMQ,0.)
        IF(X(1).LT.1..AND.X(2).LT.1..AND.X(1).GT.XQMIN) THEN
          SIG=FJAC*P(1)*P(2)/(E1*E2)*FGQ(S,T,U)*QFCN(IQ,1)*QFCN(1,2)
          CALL SIGFIL(SIG,IQ,1,IQ,1)
        ENDIF
300   CONTINUE
C
C          Light quark + heavy quark
      DO 320 IQ1=2,7
        DO 330 IQ2=8,13
          IF(.NOT.(GOQ(IQ1,1).AND.GOQ(IQ2,2))) GO TO 340
          AMQ=AMASS(IQ2/2)
          AM2=AMQ**2
          XQMIN=AMQ/ECM
          E1=P(1)
          E2=SQRT(P(2)**2+AM2)
          FJAC=.5*S/SCM*UNITS*PI*ALFQSQ**2/S**2
          CALL TWOKIN(0.,AMQ,0.,AMQ)
          IF(X(1).LT.1..AND.X(2).LT.1..AND.X(2).GT.XQMIN) THEN
            SIG=FJAC*P(1)*P(2)/(E1*E2)*FQQ(S,T,U)*QFCN(IQ1,1)
     $      *QFCN(IQ2,2)
            CALL SIGFIL(SIG,IQ1,IQ2,IQ1,IQ2)
          ENDIF
          CALL TWOKIN(AMQ,0.,0.,AMQ)
          IF(X(1).LT.1..AND.X(2).LT.1..AND.X(1).GT.XQMIN) THEN
            SIG=FJAC*P(1)*P(2)/(E1*E2)*FQQ(S,U,T)*QFCN(IQ1,2)
     $      *QFCN(IQ2,1)
            CALL SIGFIL(SIG,IQ2,IQ1,IQ1,IQ2)
          ENDIF
C
340       IF(.NOT.(GOQ(IQ1,2).AND.GOQ(IQ2,1))) GO TO 330
          AMQ=AMASS(IQ2/2)
          AM2=AMQ**2
          XQMIN=AMQ/ECM
          E1=SQRT(P(1)**2+AM2)
          E2=P(2)
          FJAC=.5*S/SCM*UNITS*PI*ALFQSQ**2/S**2
          CALL TWOKIN(0.,AMQ,AMQ,0.)
          IF(X(1).LT.1..AND.X(2).LT.1..AND.X(2).GT.XQMIN) THEN
            SIG=FJAC*P(1)*P(2)/(E1*E2)*FQQ(S,U,T)*QFCN(IQ1,1)
     $      *QFCN(IQ2,2)
            CALL SIGFIL(SIG,IQ1,IQ2,IQ2,IQ1)
          ENDIF
          CALL TWOKIN(AMQ,0.,AMQ,0.)
          IF(X(1).LT.1..AND.X(2).LT.1..AND.X(1).GT.XQMIN) THEN
            SIG=FJAC*P(1)*P(2)/(E1*E2)*FQQ(S,T,U)*QFCN(IQ1,2)
     $      *QFCN(IQ2,1)
            CALL SIGFIL(SIG,IQ2,IQ1,IQ2,IQ1)
          ENDIF
330     CONTINUE
320   CONTINUE
C
      RETURN
      END
CDECK  ID>, SIGSSE. 
      SUBROUTINE SIGSSE
C
C          Compute d(sigma)/d(cos theta) for
C          e+ e- ----> SUSY particles
C          See Baer et. al., IJMP A4, 4111 (1989) for sigma's
C          Polarized cross sections added 9/18/95 hb
C          Mixed sbottoms and staus included 10/23/96 hb
C
C          SIGMA    = cross section summed over quark types allowed by
C                     JETTYPE and WTYPE cards.
C          SIGS(I)  = partial cross section for I1 + I2 --> I3 + I4.
C          INOUT(I) = IOPAK**3*I4 + IOPAK**2*I3 + IOPAK*I2 + I1
C                     using JETTYPE code.
C
C          Extra factor of 1/2 needed because all jets are treated
C          as identical.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/EEPAR/SGMXEE,PLEP,PLEM
      SAVE /EEPAR/
      REAL      SGMXEE,PLEP,PLEM
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
      REAL ALQ(2),BEQ(2),E,CS2THW,TNTHW,CTTHW,AE,BE,AM1,AM2,
     $EQ,ALR,EB,Z,PHIZ,PROPZ,SIG,PCM,AMASS,ALL(2),BEL(2),
     $G,MSNE,TM2,TM3,TM4,TM5,TM6,AZJ,AZI,MEL,MER,
     $AEZS,BEZS,SR2,GP,AN,BN,AEZJS,BEZJS,SSXLAM,
     $TGG,TNN,TGN,TZN,AMWI,XS,YS,XC,YC,SINGL,SINGR,
     $COSGL,COSGR,XM,YM,THX,THY,XI,DEL,AMWISS(2),KK,
     $AMZIZ1,AMZIZ2,SIGLL,SIGRR,SIGLZ,SIGRZ,SSGT,SSGST,
     $FAC1,EZ0,BETA,EEL,EER,
     $FLEP,FLEM,FREP,FREM,SIGLR,SIGRL,PHIZLR,PHIZRL,
     $TM1LR,TM1RL,TZZRL,TZZLR,TGZLR,TGZRL,SIGZZL,SIGZZR,
     $FACLR,FACRL
      COMPLEX AEZ(4),BEZ(4),ZI,ZONE,WIJ
      INTEGER IS2UD(25),IUD(13),JS2JT(25),IQ1,IQ2,IFL1,IFL2,
     $IFLQ,IFM,I,IDQSS(25),MATCHL(18),IL2JS(18),IS2LN(18),
     $I1,I2,IL1,IL2,IDL1,IDL2,IZ,IZ1,IP,ITHZ(4),IDLSS(18),
     $IW2JS(4),IW1,JW1,JTW1,JTW2,IZ2JS(4),
     $IZ2,JTYPZ1,JTYPZ2
      INTEGER MSUPL,MSDNL,MSSTL,MSCHL,MSBT1,MSTP1,
     $MSUPR,MSDNR,MSSTR,MSCHR,MSBT2,MSTP2,MSW1,MSW2,
     $MSNEL,MSEL,MSNML,MSMUL,MSNTL,MSTAU1,MSER,MSMUR,MSTAU2
      PARAMETER (MSUPL=-ISUPL)
      PARAMETER (MSDNL=-ISDNL)
      PARAMETER (MSSTL=-ISSTL)
      PARAMETER (MSCHL=-ISCHL)
      PARAMETER (MSBT1=-ISBT1)
      PARAMETER (MSTP1=-ISTP1)
      PARAMETER (MSUPR=-ISUPR)
      PARAMETER (MSDNR=-ISDNR)
      PARAMETER (MSSTR=-ISSTR)
      PARAMETER (MSCHR=-ISCHR)
      PARAMETER (MSBT2=-ISBT2)
      PARAMETER (MSTP2=-ISTP2)
      PARAMETER (MSW1=-ISW1)
      PARAMETER (MSW2=-ISW2)
      PARAMETER (MSNEL=-ISNEL)
      PARAMETER (MSEL=-ISEL)
      PARAMETER (MSNML=-ISNML)
      PARAMETER (MSMUL=-ISMUL)
      PARAMETER (MSNTL=-ISNTL)
      PARAMETER (MSTAU1=-ISTAU1)
      PARAMETER (MSER=-ISER)
      PARAMETER (MSMUR=-ISMUR)
      PARAMETER (MSTAU2=-ISTAU2)
      DATA IDQSS/0,
     $ISUPL,MSUPL,ISDNL,MSDNL,ISSTL,MSSTL,ISCHL,MSCHL,ISBT1,MSBT1,
     $ISTP1,MSTP1,
     $ISUPR,MSUPR,ISDNR,MSDNR,ISSTR,MSSTR,ISCHR,MSCHR,ISBT2,MSBT2,
     $ISTP2,MSTP2/
      DATA IDLSS/ISNEL,MSNEL,ISEL,MSEL,ISNML,MSNML,ISMUL,MSMUL,
     $ISNTL,MSNTL,ISTAU1,MSTAU1,ISER,MSER,ISMUR,MSMUR,
     $ISTAU2,MSTAU2/
      DATA IS2UD/0,1,1,2,2,2,2,1,1,2,2,1,1,1,1,2,2,2,2,1,1,2,2,1,1/
      DATA IUD/0,1,-1,2,-2,2,-2,1,-1,2,-2,1,-1/
      DATA JS2JT/1,
     $2,3,4,5,6,7,8,9,10,11,12,13,2,3,4,5,6,7,8,9,10,11,12,13/
      DATA MATCHL/2,1,4,3,6,5,8,7,10,9,12,11,14,13,16,15,18,17/
      DATA IL2JS/34,35,36,37,38,39,40,41,42,43,44,45,46,47,
     $48,49,50,51/
      DATA IS2LN/1,1,2,2,1,1,2,2,1,1,2,2,2,2,2,2,2,2/
      DATA IW2JS/26,27,28,29/
      DATA IZ2JS/30,31,32,33/
      DATA ZONE,ZI/(1.,0.),(0.,1.)/
C
C          FUNCTIONS
      PROPZ=(SCM-AMZ**2)**2+AMZ**2*GAMZ**2
C
C          CONSTANTS
      EB=HALFE
      E=SQRT(4*PI*ALFAEM)
      G=SQRT(4*PI*ALFAEM/SN2THW)
      GP=G*SQRT(SN2THW/(1.-SN2THW))
      BETA=ATAN(1./RV2V1)
      SR2=SQRT(2.)
      CS2THW=1.-SN2THW
      TNTHW=SQRT(SN2THW/CS2THW)
      CTTHW=1./TNTHW
      ALQ(1)=CTTHW/4.-5*TNTHW/12.
      BEQ(1)=-(CTTHW+TNTHW)/4.
      ALQ(2)=TNTHW/12.-CTTHW/4.
      BEQ(2)=-BEQ(1)
      ALL(1)=(CTTHW+TNTHW)/4.
      BEL(1)=-(CTTHW+TNTHW)/4.
      ALL(2)=(3*TNTHW-CTTHW)/4.
      BEL(2)=-BEL(1)
      AE=ALL(2)
      BE=BEL(2)
      AN=ALL(1)
      BN=BEL(1)
      FLEP=(1.+PLEP)/2.
      FLEM=(1.+PLEM)/2.
      FREP=(1.-PLEP)/2.
      FREM=(1.-PLEM)/2.
      MEL=AMASS(ISEL)
      MER=AMASS(ISER)
      MSNE=AMASS(ISNEL)
      XM=1./TAN(GAMMAL)
      YM=1./TAN(GAMMAR)
      THX=SIGN(1.,XM)
      THY=SIGN(1.,YM)
      AMWISS(1)=ABS(AMW1SS)
      AMWISS(2)=ABS(AMW2SS)
      DO 5 IZ=1,4
        ITHZ(IZ)=0
        IF (AMZISS(IZ).LT.0.) ITHZ(IZ)=1
        AEZ(IZ)=-1*ZI**(ITHZ(IZ)-1)*(-1)**(ITHZ(IZ)+1)*
     $      (G*ZMIXSS(3,IZ)+GP*ZMIXSS(4,IZ))/SR2
        BEZ(IZ)=-1*ZI**(ITHZ(IZ)-1)*SR2*GP*ZMIXSS(4,IZ)
5     CONTINUE
C
C          ENTRY
      SIGMA=0
      NSIGS=0
      DO 10 I=1,MXSIGS
        SIGS(I)=0.
10    CONTINUE
C
C          First do squark pairs: IQ1 labels JETTYPE1.
C
      DO 100 IQ1=2,25
        IQ2=MATCH(IQ1,4)
        IF(.NOT.(GOQ(IQ1,1).AND.GOQ(IQ2,2))) GO TO 100
        IFL1=IDQSS(IQ1)
        IFL2=IDQSS(IQ2)
        AM1=AMASS(IFL1)
        AM2=AMASS(IFL2)
        IF((AM1+AM2).GE.ECM) GO TO 100
        IFLQ=IS2UD(IQ1)
        IF (IFLQ.EQ.1) THEN
          EQ=2./3.
        ELSE
          EQ=-1./3.
        END IF
C          Left squarks
        IF(IQ1.LE.9) THEN
          ALR=2*(ALQ(IFLQ)-BEQ(IFLQ))
C          Right squarks
        ELSEIF(IQ1.GE.14.AND.IQ1.LE.21) THEN
          ALR=2*(ALQ(IFLQ)+BEQ(IFLQ))
C          Mixed stops and sbottoms
        ELSEIF(IQ1.EQ.10.OR.IQ1.EQ.11) THEN
          ALR=2*(ALQ(IFLQ)-BEQ(IFLQ)*COS(2*THETAB))
        ELSEIF(IQ1.EQ.12.OR.IQ1.EQ.13) THEN
          ALR=2*(ALQ(IFLQ)-BEQ(IFLQ)*COS(2*THETAT))
        ELSEIF(IQ1.EQ.22.OR.IQ1.EQ.23) THEN
          ALR=2*(ALQ(IFLQ)+BEQ(IFLQ)*COS(2*THETAB))
        ELSEIF(IQ1.EQ.24.OR.IQ1.EQ.25) THEN
          ALR=2*(ALQ(IFLQ)+BEQ(IFLQ)*COS(2*THETAT))
        END IF
        PCM=.5*SQRT(SCM-4.*AM1**2)
        IFM=ISIGN(1,IUD(JS2JT(IQ1)))
        IF (IFM.GT.0) THEN
          Z=CTH(1)
        ELSE
          Z=-CTH(1)
        END IF
C          Calculate d(sigma)/d(cos theta) in mb
        PHIZLR=2*E**4*(1.-Z**2)*(8*EQ**2/SCM+(2*ALR**2*(AE-BE)**2*
     $   SCM-8*(AE-BE)*EQ*ALR*(SCM-AMZ**2))/PROPZ)
        PHIZRL=2*E**4*(1.-Z**2)*(8*EQ**2/SCM+(2*ALR**2*(AE+BE)**2*
     $   SCM-8*(AE+BE)*EQ*ALR*(SCM-AMZ**2))/PROPZ)
        SIGLR=3*PCM**3/512./PI/EB**3*PHIZLR
        SIGRL=3*PCM**3/512./PI/EB**3*PHIZRL
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        CALL SIGFIL(SIG,0,0,IQ1,IQ2)
100   CONTINUE
C        Mixed sbottom_1 and sbottom_2 production
      IF ((AMB1SS+AMB2SS).LT.ECM) THEN
        Z=CTH(1)
        PCM=SQRT(SSXLAM(SCM,AMB1SS**2,AMB2SS**2))/2./ECM
        SIGLR=2*3*8*PI*ALFAEM**2*BEQ(2)**2*COS(THETAB)**2*
     $   SIN(THETAB)**2*(AE-BE)**2*PCM**3*(1.-Z**2)/ECM/PROPZ
        SIGRL=2*3*8*PI*ALFAEM**2*BEQ(2)**2*COS(THETAB)**2*
     $   SIN(THETAB)**2*(AE+BE)**2*PCM**3*(1.-Z**2)/ECM/PROPZ
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        IF(GOQ(10,1).AND.GOQ(23,2)) THEN
          CALL SIGFIL(SIG,0,0,10,23)
        END IF
        IF(GOQ(23,1).AND.GOQ(10,2)) THEN
          CALL SIGFIL(SIG,0,0,23,10)
        END IF
        IF(GOQ(11,1).AND.GOQ(22,2)) THEN
          CALL SIGFIL(SIG,0,0,11,22)
        END IF
        IF(GOQ(22,1).AND.GOQ(11,2)) THEN
          CALL SIGFIL(SIG,0,0,22,11)
        END IF
      ENDIF
C        Mixed stop_1 and stop_2 production
      IF ((AMT1SS+AMT2SS).LT.ECM) THEN
        Z=CTH(1)
        PCM=SQRT(SSXLAM(SCM,AMT1SS**2,AMT2SS**2))/2./ECM
        SIGLR=2*3*8*PI*ALFAEM**2*BEQ(1)**2*COS(THETAT)**2*
     $   SIN(THETAT)**2*(AE-BE)**2*PCM**3*(1.-Z**2)/ECM/PROPZ
        SIGRL=2*3*8*PI*ALFAEM**2*BEQ(1)**2*COS(THETAT)**2*
     $   SIN(THETAT)**2*(AE+BE)**2*PCM**3*(1.-Z**2)/ECM/PROPZ
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        IF(GOQ(12,1).AND.GOQ(25,2)) THEN
          CALL SIGFIL(SIG,0,0,12,25)
        END IF
        IF(GOQ(25,1).AND.GOQ(12,2)) THEN
          CALL SIGFIL(SIG,0,0,25,12)
        END IF
        IF(GOQ(13,1).AND.GOQ(24,2)) THEN
          CALL SIGFIL(SIG,0,0,13,24)
        END IF
        IF(GOQ(24,1).AND.GOQ(13,2)) THEN
          CALL SIGFIL(SIG,0,0,24,13)
        END IF
      ENDIF
C
C          2nd and 3rd generation sleptons: IL1 labels JETTYPE1.
C
      DO 200 I=5,16
        I1=I
        IF (I1.GE.13) I1=I1+2
        I2=MATCHL(I1)
        IL1=IL2JS(I1)
        IL2=IL2JS(I2)
        IF(.NOT.(GOQ(IL1,1).AND.GOQ(IL2,2))) GO TO 200
        IDL1=IDLSS(I1)
        IDL2=IDLSS(I2)
        AM1=AMASS(IDL1)
        AM2=AMASS(IDL2)
        IF((AM1+AM2).GE.ECM) GO TO 200
        IFL1=IS2LN(I1)
        IFL2=IS2LN(I2)
        IF (IFL1.EQ.1) THEN
          EQ=0.
        ELSE
          EQ=-1.
        END IF
        IF (I1.EQ.15.OR.I1.EQ.16)  THEN
          ALR=2*(ALL(IFL1)+BEL(IFL1))
        ELSE IF (I1.GE.5.AND.I1.LE.10) THEN
          ALR=2*(ALL(IFL1)-BEL(IFL1))
        ELSE IF (I1.EQ.11.OR.I1.EQ.12) THEN
          ALR=2*(ALL(IFL1)-BEL(IFL1)*COS(2*THETAL))
        ELSE IF (I1.EQ.17.OR.I1.EQ.18) THEN
          ALR=2*(ALL(IFL1)+BEL(IFL1)*COS(2*THETAL))
        END IF
        PCM=.5*SQRT(SCM-4.*AM1**2)
        IFM=ISIGN(1,IDL1)
        IF (IFM.GT.0) THEN
          Z=CTH(1)
         ELSE
          Z=-CTH(1)
        END IF
C          Calculate d(sigma)/d(cos theta) in mb
        PHIZLR=2*E**4*(1.-Z**2)*(8*EQ**2/SCM+(2*ALR**2*(AE-BE)**2*
     $   SCM-8*(AE-BE)*EQ*ALR*(SCM-AMZ**2))/PROPZ)
        PHIZRL=2*E**4*(1.-Z**2)*(8*EQ**2/SCM+(2*ALR**2*(AE+BE)**2*
     $   SCM-8*(AE+BE)*EQ*ALR*(SCM-AMZ**2))/PROPZ)
        SIGLR=PCM**3/512./PI/EB**3*PHIZLR
        SIGRL=PCM**3/512./PI/EB**3*PHIZRL
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        CALL SIGFIL(SIG,0,0,IL1,IL2)
200   CONTINUE
C        Mixed stau_1 and stau_2 production
      IF ((AML1SS+AML2SS).LT.ECM) THEN
        Z=CTH(1)
        PCM=SQRT(SSXLAM(SCM,AML1SS**2,AML2SS**2))/2./ECM
        SIGLR=2*8*PI*ALFAEM**2*BEL(2)**2*COS(THETAL)**2*
     $   SIN(THETAL)**2*(AE-BE)**2*PCM**3*(1.-Z**2)/ECM/PROPZ
        SIGRL=2*8*PI*ALFAEM**2*BEL(2)**2*COS(THETAL)**2*
     $   SIN(THETAL)**2*(AE+BE)**2*PCM**3*(1.-Z**2)/ECM/PROPZ
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        IF(GOQ(44,1).AND.GOQ(51,2)) THEN
          CALL SIGFIL(SIG,0,0,44,51)
        END IF
        IF(GOQ(51,1).AND.GOQ(44,2)) THEN
          CALL SIGFIL(SIG,0,0,51,44)
        END IF
        IF(GOQ(45,1).AND.GOQ(50,2)) THEN
          CALL SIGFIL(SIG,0,0,45,50)
        END IF
        IF(GOQ(50,1).AND.GOQ(45,2)) THEN
          CALL SIGFIL(SIG,0,0,50,45)
        END IF
      ENDIF
C
C         Next do 1st generation sleptons
C
C         Sneutrino_e pairs
      DO 210 I1=1,2
        I2=MATCHL(I1)
        IL1=IL2JS(I1)
        IL2=IL2JS(I2)
        IF(.NOT.(GOQ(IL1,1).AND.GOQ(IL2,2))) GO TO 210
        MSNE=AMASS(ISNEL)
        IF((2*MSNE).GE.ECM) GO TO 210
        IF (I1.EQ.1) THEN
          Z=CTH(1)
        ELSE
          Z=-CTH(1)
        END IF
        PCM=.5*SQRT(SCM-4*MSNE**2)
        TM1LR=32*E**4*(AN-BN)**2*(AE-BE)**2/PROPZ
        TM1RL=32*E**4*(AN-BN)**2*(AE+BE)**2/PROPZ
        TM2=8*G**4*SIN(GAMMAR)**4/(2*EB*(EB-PCM*Z)+AMW1SS**2-MSNE**2)**2
        TM3=8*G**4*COS(GAMMAR)**4/(2*EB*(EB-PCM*Z)+AMW2SS**2-MSNE**2)**2
        TM4=-32*E**2*(AN-BN)*G**2*SIN(GAMMAR)**2*(SCM-AMZ**2)*(AE-BE)/
     $  PROPZ/(2*EB*(EB-PCM*Z)+AMW1SS**2-MSNE**2)
        TM5=-32*E**2*(AN-BN)*G**2*COS(GAMMAR)**2*(SCM-AMZ**2)*(AE-BE)/
     $  PROPZ/(2*EB*(EB-PCM*Z)+AMW2SS**2-MSNE**2)
        TM6=16*G**4*SIN(GAMMAR)**2*COS(GAMMAR)**2/
     $  (2*EB*(EB-PCM*Z)+AMW1SS**2-MSNE**2)/
     $  (2*EB*(EB-PCM*Z)+AMW2SS**2-MSNE**2)
        SIGLR=2*PCM**3*EB*(1.-Z**2)/128./PI/SCM*
     $   (TM1LR+TM2+TM3+TM4+TM5+TM6)
        SIGRL=2*PCM**3*EB*(1.-Z**2)/128./PI/SCM*TM1RL
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        CALL SIGFIL(SIG,0,0,IL1,IL2)
210   CONTINUE
C         E_L~ pairs
      DO 220 I1=3,4
        I2=MATCHL(I1)
        IL1=IL2JS(I1)
        IL2=IL2JS(I2)
        IF(.NOT.(GOQ(IL1,1).AND.GOQ(IL2,2))) GO TO 220
        IF(2*MEL.GE.ECM) GO TO 220
        PCM=.5*SQRT(SCM-4.*MEL**2)
        EQ=-1.
        ALR=2*(AE-BE)
        IF (I1.EQ.3) THEN
          Z=CTH(1)
        ELSE
          Z=-CTH(1)
        END IF
        PHIZLR=E**4*(1.-Z**2)*(8*EQ**2/SCM+(2*ALR**2*(AE-BE)**2*
     $   SCM-8*(AE-BE)*EQ*ALR*(SCM-AMZ**2))/PROPZ)
        PHIZRL=E**4*(1.-Z**2)*(8*EQ**2/SCM+(2*ALR**2*(AE+BE)**2*
     $   SCM-8*(AE+BE)*EQ*ALR*(SCM-AMZ**2))/PROPZ)
        DO 221 IZ1=1,4
          AEZS=AEZ(IZ1)*CONJG(AEZ(IZ1))
          PHIZLR=PHIZLR+2*AEZS**2*SCM*(1.-Z**2)/(2*EB*(EB-PCM*Z)-
     $    MEL**2+AMZISS(IZ1)**2)**2-4*E**2*(1.-Z**2)*AEZS/
     $    (2*EB*(EB-PCM*Z)-MEL**2+AMZISS(IZ1)**2)*(2.+(AE-BE)*ALR*
     $    SCM*(SCM-AMZ**2)/PROPZ)
          IF (IZ1.LE.3) THEN
            DO 222 IP=IZ1+1,4
              AEZJS=AEZ(IP)*CONJG(AEZ(IP))
              PHIZLR=PHIZLR+4*AEZS*AEZJS*SCM*(1.-Z**2)/
     $        (2*EB*(EB-PCM*Z)-MEL**2+AMZISS(IZ1)**2)/
     $        (2*EB*(EB-PCM*Z)-MEL**2+AMZISS(IP)**2)
222         CONTINUE
          END IF
221     CONTINUE
        SIGLR=2*PCM**3/512./PI/EB**3*PHIZLR
        SIGRL=2*PCM**3/512./PI/EB**3*PHIZRL
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        CALL SIGFIL(SIG,0,0,IL1,IL2)
220   CONTINUE
C         E_R~ pairs
      DO 230 I1=13,14
        I2=MATCHL(I1)
        IL1=IL2JS(I1)
        IL2=IL2JS(I2)
        IF(.NOT.(GOQ(IL1,1).AND.GOQ(IL2,2))) GO TO 230
        IF(2*MER.GE.ECM) GO TO 230
        PCM=.5*SQRT(SCM-4.*MER**2)
        EQ=-1.
        ALR=2*(AE+BE)
        IF (I1.EQ.13) THEN
          Z=CTH(1)
        ELSE
          Z=-CTH(1)
        END IF
        PHIZLR=E**4*(1.-Z**2)*(8*EQ**2/SCM+(2*ALR**2*(AE-BE)**2*
     $   SCM-8*(AE-BE)*EQ*ALR*(SCM-AMZ**2))/PROPZ)
        PHIZRL=E**4*(1.-Z**2)*(8*EQ**2/SCM+(2*ALR**2*(AE+BE)**2*
     $   SCM-8*(AE+BE)*EQ*ALR*(SCM-AMZ**2))/PROPZ)
        DO 231 IZ1=1,4
          BEZS=BEZ(IZ1)*CONJG(BEZ(IZ1))
          PHIZRL=PHIZRL+2*BEZS**2*SCM*(1.-Z**2)/(2*EB*(EB-PCM*Z)-
     $    MER**2+AMZISS(IZ1)**2)**2-4*E**2*(1.-Z**2)*BEZS/
     $    (2*EB*(EB-PCM*Z)-MER**2+AMZISS(IZ1)**2)*(2.+(AE+BE)*ALR*
     $    SCM*(SCM-AMZ**2)/PROPZ)
          IF (IZ1.LE.3) THEN
            DO 232 IP=IZ1+1,4
              BEZJS=BEZ(IP)*CONJG(BEZ(IP))
              PHIZRL=PHIZRL+4*BEZS*BEZJS*SCM*(1.-Z**2)/
     $        (2*EB*(EB-PCM*Z)-MER**2+AMZISS(IZ1)**2)/
     $        (2*EB*(EB-PCM*Z)-MER**2+AMZISS(IP)**2)
232         CONTINUE
          END IF
231     CONTINUE
        SIGLR=2*PCM**3/512./PI/EB**3*PHIZLR
        SIGRL=2*PCM**3/512./PI/EB**3*PHIZRL
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        CALL SIGFIL(SIG,0,0,IL1,IL2)
230   CONTINUE
C         E_L~+E_R~bar and E_R~+E_L~bar pairs; now has MEL =/ MER !
      IF((MEL+MER).GE.ECM) GO TO 270
      IF(GOQ(36,1).AND.GOQ(47,2)) THEN
        PCM=SQRT(SSXLAM(SCM,MEL**2,MER**2))/4./EB
        EEL=SQRT(PCM**2+MEL**2)
        Z=CTH(1)
        PHIZ=0.
        DO 241 IZ1=1,4
          BEZS=BEZ(IZ1)*CONJG(BEZ(IZ1))
          AEZS=AEZ(IZ1)*CONJG(AEZ(IZ1))
          AZI=(AMZISS(IZ1)**2-MEL**2)/2./EB
          PHIZ=PHIZ+AEZS*BEZS*AMZISS(IZ1)**2/(EEL-PCM*Z+AZI)**2
          IF (IZ1.LE.3) THEN
            DO 242 IP=IZ1+1,4
              AZJ=(AMZISS(IP)**2-MEL**2)/2./EB
              PHIZ=PHIZ+2*ABS(AMZISS(IZ1)*AMZISS(IP))*
     $        REAL(AEZ(IZ1)*CONJG(AEZ(IP))*CONJG(BEZ(IZ1))*BEZ(IP))/
     $        (EEL-PCM*Z+AZI)/(EEL-PCM*Z+AZJ)
242         CONTINUE
          END IF
241     CONTINUE
        SIG=4*PCM/128./PI/SCM/EB*PHIZ
        SIG=FLEM*FLEP*SIG*UNITS/2.
        CALL SIGFIL(SIG,0,0,36,47)
      ENDIF
      IF(GOQ(46,1).AND.GOQ(37,2)) THEN
        PCM=SQRT(SSXLAM(SCM,MEL**2,MER**2))/4./EB
        EER=SQRT(PCM**2+MER**2)
        Z=CTH(1)
        PHIZ=0.
        DO 243 IZ1=1,4
          BEZS=BEZ(IZ1)*CONJG(BEZ(IZ1))
          AEZS=AEZ(IZ1)*CONJG(AEZ(IZ1))
          AZI=(AMZISS(IZ1)**2-MER**2)/2./EB
          PHIZ=PHIZ+AEZS*BEZS*AMZISS(IZ1)**2/(EER-PCM*Z+AZI)**2
          IF (IZ1.LE.3) THEN
            DO 244 IP=IZ1+1,4
              AZJ=(AMZISS(IP)**2-MER**2)/2./EB
              PHIZ=PHIZ+2*ABS(AMZISS(IZ1)*AMZISS(IP))*
     $        REAL(AEZ(IZ1)*CONJG(AEZ(IP))*CONJG(BEZ(IZ1))*BEZ(IP))/
     $        (EER-PCM*Z+AZI)/(EER-PCM*Z+AZJ)
244         CONTINUE
          END IF
243     CONTINUE
        SIG=4*PCM/128./PI/SCM/EB*PHIZ
        SIG=FREM*FREP*SIG*UNITS/2.
        CALL SIGFIL(SIG,0,0,46,37)
      ENDIF
C         E_R~bar+E_L~ and E_L~bar+E_R~ pairs; now assumes MEL =/ MER !
      IF(GOQ(47,1).AND.GOQ(36,2)) THEN
        PCM=SQRT(SSXLAM(SCM,MEL**2,MER**2))/4./EB
        EEL=SQRT(PCM**2+MEL**2)
        Z=-CTH(1)
        PHIZ=0.
        DO 251 IZ1=1,4
          BEZS=BEZ(IZ1)*CONJG(BEZ(IZ1))
          AEZS=AEZ(IZ1)*CONJG(AEZ(IZ1))
          AZI=(AMZISS(IZ1)**2-MEL**2)/2./EB
          PHIZ=PHIZ+AEZS*BEZS*AMZISS(IZ1)**2/(EEL-PCM*Z+AZI)**2
          IF (IZ1.LE.3) THEN
            DO 252 IP=IZ1+1,4
              AZJ=(AMZISS(IP)**2-MEL**2)/2./EB
              PHIZ=PHIZ+2*ABS(AMZISS(IZ1)*AMZISS(IP))*
     $        REAL(AEZ(IZ1)*CONJG(AEZ(IP))*CONJG(BEZ(IZ1))*BEZ(IP))/
     $        (EEL-PCM*Z+AZI)/(EEL-PCM*Z+AZJ)
252         CONTINUE
          END IF
251     CONTINUE
        SIG=4*PCM/128./PI/SCM/EB*PHIZ
        SIG=FLEM*FLEP*SIG*UNITS/2.
        CALL SIGFIL(SIG,0,0,47,36)
      ENDIF
      IF(GOQ(37,1).AND.GOQ(46,2)) THEN
        PCM=SQRT(SSXLAM(SCM,MEL**2,MER**2))/4./EB
        EER=SQRT(PCM**2+MER**2)
        Z=-CTH(1)
        PHIZ=0.
        DO 253 IZ1=1,4
          BEZS=BEZ(IZ1)*CONJG(BEZ(IZ1))
          AEZS=AEZ(IZ1)*CONJG(AEZ(IZ1))
          AZI=(AMZISS(IZ1)**2-MER**2)/2./EB
          PHIZ=PHIZ+AEZS*BEZS*AMZISS(IZ1)**2/(EER-PCM*Z+AZI)**2
          IF (IZ1.LE.3) THEN
            DO 254 IP=IZ1+1,4
              AZJ=(AMZISS(IP)**2-MER**2)/2./EB
              PHIZ=PHIZ+2*ABS(AMZISS(IZ1)*AMZISS(IP))*
     $        REAL(AEZ(IZ1)*CONJG(AEZ(IP))*CONJG(BEZ(IZ1))*BEZ(IP))/
     $        (EER-PCM*Z+AZI)/(EER-PCM*Z+AZJ)
254         CONTINUE
          END IF
253     CONTINUE
        SIG=4*PCM/128./PI/SCM/EB*PHIZ
        SIG=FREM*FREP*SIG*UNITS/2.
        CALL SIGFIL(SIG,0,0,37,46)
      ENDIF
270   CONTINUE
C
C          Chargino pair production
C
      DO 300 IW1=1,4
        JW1=(IW1+1)/2
        AMWI=ABS(AMWISS(JW1))
        JTW1=IW2JS(IW1)
        JTW2=IW2JS(MATCHL(IW1))
        IF (.NOT.(GOQ(JTW1,1).AND.GOQ(JTW2,2))) GO TO 300
        IF((2*AMWI).GE.ECM) GO TO 300
        PCM=SQRT(SSXLAM(SCM,AMWI**2,AMWI**2))/4./EB
        Z=CTH(1)
        IF (IW1.EQ.1.OR.IW1.EQ.3) Z=-CTH(1)
        SINGR=SIN(GAMMAR)
        COSGR=COS(GAMMAR)
        SINGL=SIN(GAMMAL)
        COSGL=COS(GAMMAL)
        XC=1.-(COSGL**2+COSGR**2)/4./CS2THW
        YC=(COSGR**2-COSGL**2)/4./CS2THW
        XS=1.-(SINGL**2+SINGR**2)/4./CS2THW
        YS=(SINGR**2-SINGL**2)/4./CS2THW
        IF (IW1.GE.3) THEN
          XC=XS
          YC=YS
          SINGR=COSGR
        END IF
        TGG=16*E**4/SCM*(EB**2*(1.+Z**2)+AMWI**2*(1.-Z**2))
        TZZLR=16*E**4*CTTHW**2*SCM/PROPZ*((XC**2+YC**2)*(AE-BE)**2*
     $  (EB**2*(1.+Z**2)+AMWI**2*(1.-Z**2))-
     $  2*YC**2*(AE-BE)**2*AMWI**2+4*XC*YC*(AE-BE)**2*EB*PCM*Z)
        TZZRL=16*E**4*CTTHW**2*SCM/PROPZ*((XC**2+YC**2)*(AE+BE)**2*
     $  (EB**2*(1.+Z**2)+AMWI**2*(1.-Z**2))-
     $  2*YC**2*(AE+BE)**2*AMWI**2-4*XC*YC*(AE+BE)**2*EB*PCM*Z)
        TGZLR=-32*E**4*CTTHW*(SCM-AMZ**2)/PROPZ*((AE-BE)*XC*
     $  (EB**2*(1.+Z**2)+AMWI**2*(1.-Z**2))-2*(BE-AE)*YC*EB*PCM*Z)
        TGZRL=-32*E**4*CTTHW*(SCM-AMZ**2)/PROPZ*((AE+BE)*XC*
     $  (EB**2*(1.+Z**2)+AMWI**2*(1.-Z**2))-2*(BE+AE)*YC*EB*PCM*Z)
        TNN=2*E**4*SINGR**4*SCM*(EB-PCM*Z)**2/SN2THW**2/
     $  (EB**2+PCM**2-2*EB*PCM*Z+MSNE**2)**2
        TGN=-8*E**4*SINGR**2*((EB-PCM*Z)**2+AMWI**2)/SN2THW/
     $  (EB**2+PCM**2-2*EB*PCM*Z+MSNE**2)
        TZN=8*E**4*CTTHW*SINGR**2*(SCM-AMZ**2)*(AE-BE)*SCM/
     $  SN2THW/PROPZ*((XC-YC)*((EB-PCM*Z)**2+AMWI**2)+2*YC*AMWI**2)/
     $  (EB**2+PCM**2-2*EB*PCM*Z+MSNE**2)
        SIGLR=2*PCM/128./PI/SCM/EB*(TGG+TZZLR+TGZLR+TNN+TGN+TZN)
        SIGRL=2*PCM/128./PI/SCM/EB*(TGG+TZZRL+TGZRL)
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        CALL SIGFIL(SIG,0,0,JTW1,JTW2)
300   CONTINUE
C
C     Chargino_1 + chargino_2 pair production
      IF((ABS(AMW1SS)+ABS(AMW2SS)).GE.ECM) GO TO 340
      PCM=SQRT(SSXLAM(SCM,AMW1SS**2,AMW2SS**2))/4./EB
      XC=(THX*SIN(GAMMAL)*COS(GAMMAL)-THY*SIN(GAMMAR)*COS(GAMMAR))/2.
      YC=(THX*SIN(GAMMAL)*COS(GAMMAL)+THY*SIN(GAMMAR)*COS(GAMMAR))/2.
      DEL=(AMW2SS**2-AMW1SS**2)/4./EB
      XI=-1.*SIGN(1.,AMWISS(1))*SIGN(1.,AMWISS(2))
      IF (.NOT.(GOQ(27,1).AND.GOQ(28,2))) GO TO 310
        Z=CTH(1)
        TZZLR=4*(CTTHW+TNTHW)**2/PROPZ*((XC**2+YC**2)*(AE-BE)**2*
     $  (EB**2+PCM**2*Z**2-DEL**2-XI*ABS(AMW1SS*AMW2SS))+
     $  2*XC**2*XI*(AE-BE)**2*ABS(AMW1SS*AMW2SS)+
     $  4*XC*YC*(AE-BE)**2*EB*PCM*Z)
        TZZRL=4*(CTTHW+TNTHW)**2/PROPZ*((XC**2+YC**2)*(AE+BE)**2*
     $  (EB**2+PCM**2*Z**2-DEL**2-XI*ABS(AMW1SS*AMW2SS))+
     $  2*XC**2*XI*(AE+BE)**2*ABS(AMW1SS*AMW2SS)-
     $  4*XC*YC*(AE+BE)**2*EB*PCM*Z)
        TNN=2*SIN(GAMMAR)**2*COS(GAMMAR)**2*((EB-PCM*Z)**2-DEL**2)/
     $  SN2THW**2/(2*EB*(EB-DEL)-2*EB*PCM*Z+MSNE**2-AMW1SS**2)**2
        TZN=-4*THY*(CTTHW+TNTHW)*SIN(GAMMAR)*COS(GAMMAR)*(SCM-AMZ**2)
     $  *(AE-BE)/SN2THW/PROPZ*((XC-YC)*((EB-PCM*Z)**2-DEL**2-
     $  XI*ABS(AMW1SS*AMW2SS))+2*XC*XI*ABS(AMW1SS*AMW2SS))/
     $  (2*EB*(EB-DEL)-2*EB*PCM*Z+MSNE**2-AMW1SS**2)
        SIGLR=2*E**4*PCM/128./PI/EB*(TZZLR+TNN+TZN)
        SIGRL=2*E**4*PCM/128./PI/EB*TZZRL
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        CALL SIGFIL(SIG,0,0,27,28)
310   CONTINUE
      IF (.NOT.(GOQ(28,1).AND.GOQ(27,2))) GO TO 320
        Z=-CTH(1)
        TZZLR=4*(CTTHW+TNTHW)**2/PROPZ*((XC**2+YC**2)*(AE-BE)**2*
     $  (EB**2+PCM**2*Z**2-DEL**2-XI*ABS(AMW1SS*AMW2SS))+
     $  2*XC**2*XI*(AE-BE)**2*ABS(AMW1SS*AMW2SS)+
     $  4*XC*YC*(AE-BE)**2*EB*PCM*Z)
        TZZRL=4*(CTTHW+TNTHW)**2/PROPZ*((XC**2+YC**2)*(AE+BE)**2*
     $  (EB**2+PCM**2*Z**2-DEL**2-XI*ABS(AMW1SS*AMW2SS))+
     $  2*XC**2*XI*(AE+BE)**2*ABS(AMW1SS*AMW2SS)-
     $  4*XC*YC*(AE+BE)**2*EB*PCM*Z)
        TNN=2*SIN(GAMMAR)**2*COS(GAMMAR)**2*((EB-PCM*Z)**2-DEL**2)/
     $  SN2THW**2/(2*EB*(EB-DEL)-2*EB*PCM*Z+MSNE**2-AMW1SS**2)**2
        TZN=-4*THY*(CTTHW+TNTHW)*SIN(GAMMAR)*COS(GAMMAR)*(SCM-AMZ**2)
     $  *(AE-BE)/SN2THW/PROPZ*((XC-YC)*((EB-PCM*Z)**2-DEL**2-
     $  XI*ABS(AMW1SS*AMW2SS))+2*XC*XI*ABS(AMW1SS*AMW2SS))/
     $  (2*EB*(EB-DEL)-2*EB*PCM*Z+MSNE**2-AMW1SS**2)
        SIGLR=2*E**4*PCM/128./PI/EB*(TZZLR+TNN+TZN)
        SIGRL=2*E**4*PCM/128./PI/EB*TZZRL
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        CALL SIGFIL(SIG,0,0,28,27)
320   CONTINUE
      IF (.NOT.(GOQ(29,1).AND.GOQ(26,2))) GO TO 330
        Z=CTH(1)
        TZZLR=4*(CTTHW+TNTHW)**2/PROPZ*((XC**2+YC**2)*(AE-BE)**2*
     $  (EB**2+PCM**2*Z**2-DEL**2-XI*ABS(AMW1SS*AMW2SS))+
     $  2*XC**2*XI*(AE-BE)**2*ABS(AMW1SS*AMW2SS)+
     $  4*XC*YC*(AE-BE)**2*EB*PCM*Z)
        TZZRL=4*(CTTHW+TNTHW)**2/PROPZ*((XC**2+YC**2)*(AE+BE)**2*
     $  (EB**2+PCM**2*Z**2-DEL**2-XI*ABS(AMW1SS*AMW2SS))+
     $  2*XC**2*XI*(AE+BE)**2*ABS(AMW1SS*AMW2SS)-
     $  4*XC*YC*(AE+BE)**2*EB*PCM*Z)
        TNN=2*SIN(GAMMAR)**2*COS(GAMMAR)**2*((EB-PCM*Z)**2-DEL**2)/
     $  SN2THW**2/(2*EB*(EB-DEL)-2*EB*PCM*Z+MSNE**2-AMW1SS**2)**2
        TZN=-4*THY*(CTTHW+TNTHW)*SIN(GAMMAR)*COS(GAMMAR)*(SCM-AMZ**2)
     $  *(AE-BE)/SN2THW/PROPZ*((XC-YC)*((EB-PCM*Z)**2-DEL**2-
     $  XI*ABS(AMW1SS*AMW2SS))+2*XC*XI*ABS(AMW1SS*AMW2SS))/
     $  (2*EB*(EB-DEL)-2*EB*PCM*Z+MSNE**2-AMW1SS**2)
        SIGLR=2*E**4*PCM/128./PI/EB*(TZZLR+TNN+TZN)
        SIGRL=2*E**4*PCM/128./PI/EB*TZZRL
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        CALL SIGFIL(SIG,0,0,29,26)
330   CONTINUE
      IF (.NOT.(GOQ(26,1).AND.GOQ(29,2))) GO TO 340
        Z=-CTH(1)
        TZZLR=4*(CTTHW+TNTHW)**2/PROPZ*((XC**2+YC**2)*(AE-BE)**2*
     $  (EB**2+PCM**2*Z**2-DEL**2-XI*ABS(AMW1SS*AMW2SS))+
     $  2*XC**2*XI*(AE-BE)**2*ABS(AMW1SS*AMW2SS)+
     $  4*XC*YC*(AE-BE)**2*EB*PCM*Z)
        TZZRL=4*(CTTHW+TNTHW)**2/PROPZ*((XC**2+YC**2)*(AE+BE)**2*
     $  (EB**2+PCM**2*Z**2-DEL**2-XI*ABS(AMW1SS*AMW2SS))+
     $  2*XC**2*XI*(AE+BE)**2*ABS(AMW1SS*AMW2SS)-
     $  4*XC*YC*(AE+BE)**2*EB*PCM*Z)
        TNN=2*SIN(GAMMAR)**2*COS(GAMMAR)**2*((EB-PCM*Z)**2-DEL**2)/
     $  SN2THW**2/(2*EB*(EB-DEL)-2*EB*PCM*Z+MSNE**2-AMW1SS**2)**2
        TZN=-4*THY*(CTTHW+TNTHW)*SIN(GAMMAR)*COS(GAMMAR)*(SCM-AMZ**2)
     $  *(AE-BE)/SN2THW/PROPZ*((XC-YC)*((EB-PCM*Z)**2-DEL**2-
     $  XI*ABS(AMW1SS*AMW2SS))+2*XC*XI*ABS(AMW1SS*AMW2SS))/
     $  (2*EB*(EB-DEL)-2*EB*PCM*Z+MSNE**2-AMW1SS**2)
        SIGLR=2*E**4*PCM/128./PI/EB*(TZZLR+TNN+TZN)
        SIGRL=2*E**4*PCM/128./PI/EB*TZZRL
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        CALL SIGFIL(SIG,0,0,26,29)
340   CONTINUE
C
C         Neutralino pair production
C
      DO 400 IZ1=1,4
        AMZIZ1=ABS(AMZISS(IZ1))
        JTYPZ1=IZ2JS(IZ1)
        DO 410 IZ2=1,4
          AMZIZ2=ABS(AMZISS(IZ2))
          JTYPZ2=IZ2JS(IZ2)
          IF(.NOT.(GOQ(JTYPZ1,1).AND.GOQ(JTYPZ2,2))) GO TO 410
          IF((AMZIZ1+AMZIZ2).GE.ECM) GO TO 410
          WIJ=SQRT(G**2+GP**2)*ZI**(ITHZ(IZ2))*(-ZI)**(ITHZ(IZ1))*
     $    (ZMIXSS(1,IZ1)*ZMIXSS(1,IZ2)-ZMIXSS(2,IZ1)*
     $    ZMIXSS(2,IZ2))/4.
          KK=SQRT(SCM*SCM+(AMZIZ1**2-AMZIZ2**2)**2-2*SCM*
     $    (AMZIZ1**2+AMZIZ2**2))/4./EB
          Z=CTH(1)
          SIGLL=2*AEZ(IZ1)*CONJG(AEZ(IZ1))*AEZ(IZ2)*CONJG(AEZ(IZ2))*
     $    SSGT(SCM,MEL,Z,IZ1,IZ2)
          SIGRR=2*BEZ(IZ1)*CONJG(BEZ(IZ1))*BEZ(IZ2)*CONJG(BEZ(IZ2))*
     $    SSGT(SCM,MER,Z,IZ1,IZ2)
          SIGZZL=4*E**2*WIJ*CONJG(WIJ)*(AE-BE)**2*
     $    (SCM*SCM-(AMZIZ1**2-AMZIZ2**2)**2+4*(-1.)**(ITHZ(IZ1)+
     $    ITHZ(IZ2)+1)*SCM*AMZIZ1*AMZIZ2+4*SCM*KK*KK*Z*Z)/PROPZ
          SIGZZR=4*E**2*WIJ*CONJG(WIJ)*(AE+BE)**2*
     $    (SCM*SCM-(AMZIZ1**2-AMZIZ2**2)**2+4*(-1.)**(ITHZ(IZ1)+
     $    ITHZ(IZ2)+1)*SCM*AMZIZ1*AMZIZ2+4*SCM*KK*KK*Z*Z)/PROPZ
          SIGLZ=-E*(AE-BE)*(SCM-AMZ**2)/2./PROPZ*
     $    (REAL(WIJ*CONJG(AEZ(IZ1))*AEZ(IZ2))*
     $    SSGST(SCM,MEL,Z,IZ1,IZ2)+(-1.)**(ITHZ(IZ1)+ITHZ(IZ2))*
     $    REAL(WIJ*AEZ(IZ1)*CONJG(AEZ(IZ2)))*
     $    SSGST(SCM,MEL,-Z,IZ1,IZ2))
          SIGRZ=-E*(-1.)**(ITHZ(IZ1)+ITHZ(IZ2)+1)*
     $    (AE+BE)*(SCM-AMZ**2)/2./PROPZ*
     $    (REAL(WIJ*CONJG(BEZ(IZ1))*BEZ(IZ2))*
     $    SSGST(SCM,MER,Z,IZ1,IZ2)+(-1.)**(ITHZ(IZ1)+ITHZ(IZ2))*
     $    REAL(WIJ*BEZ(IZ1)*CONJG(BEZ(IZ2)))*
     $    SSGST(SCM,MER,-Z,IZ1,IZ2))
          SIGLR=2*KK/16./PI/SCM/SQRT(SCM)*(SIGLL+SIGZZL+SIGLZ)
          SIGRL=2*KK/16./PI/SCM/SQRT(SCM)*(SIGRR+SIGZZR+SIGRZ)
C         BELOW FACTOR OF 2 FOR ID PARTICLES AND JETTYP SWITCH
          SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
          CALL SIGFIL(SIG,0,0,JTYPZ1,JTYPZ2)
410     CONTINUE
400   CONTINUE
C
C     Higgs boson mechanisms
C
C          E+ E- --> Z H_L; symmetric in cos(theta)
      IF((AMZ+AMHL).LT.ECM) THEN
        FACLR=E**2*G**2*(SIN(ALFAH+BETA))**2*(AE-BE)**2/CS2THW
        FACRL=E**2*G**2*(SIN(ALFAH+BETA))**2*(AE+BE)**2/CS2THW
        Z=CTH(1)
        PCM=SQRT(SSXLAM(SCM,AMZ**2,AMHL**2))/4./EB
        EZ0=SQRT(PCM**2+AMZ**2)
        FAC1=AMZ**2+EZ0**2-PCM**2*Z**2
        SIGLR=2*FACLR/32./PI/PROPZ/SQRT(SCM)*PCM*FAC1
        SIGRL=2*FACRL/32./PI/PROPZ/SQRT(SCM)*PCM*FAC1
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        IF(GOQ(80,1).AND.GOQ(81,2)) CALL SIGFIL(SIG,0,0,80,81)
        IF(GOQ(81,1).AND.GOQ(80,2)) CALL SIGFIL(SIG,0,0,81,80)
      ENDIF
C          E+ E- --> Z H_H; symmetric in cos(theta)
      IF((AMZ+AMHH).LT.ECM) THEN
        FACLR=E**2*G**2*(COS(ALFAH+BETA))**2*(AE-BE)**2/CS2THW
        FACRL=E**2*G**2*(COS(ALFAH+BETA))**2*(AE+BE)**2/CS2THW
        Z=CTH(1)
        PCM=SQRT(SSXLAM(SCM,AMZ**2,AMHH**2))/4./EB
        EZ0=SQRT(PCM**2+AMZ**2)
        FAC1=AMZ**2+EZ0**2-PCM**2*Z**2
        SIGLR=2*FACLR/32./PI/PROPZ/SQRT(SCM)*PCM*FAC1
        SIGRL=2*FACRL/32./PI/PROPZ/SQRT(SCM)*PCM*FAC1
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        IF(GOQ(80,1).AND.GOQ(82,2)) CALL SIGFIL(SIG,0,0,80,82)
        IF(GOQ(82,1).AND.GOQ(80,2)) CALL SIGFIL(SIG,0,0,82,80)
      ENDIF
C          E+ E- --> H_P H_L; symmetric in cos(theta)
      IF((AMHA+AMHL).LT.ECM) THEN
        PCM=SQRT(SSXLAM(SCM,AMHA**2,AMHL**2))/4./EB
        Z=CTH(1)
        FAC1=PCM**3*(1.-Z**2)
        FACLR=E**4*(COS(ALFAH+BETA))**2*(AE-BE)**2*FAC1
        FACRL=E**4*(COS(ALFAH+BETA))**2*(AE+BE)**2*FAC1
        SIGLR=2*FACLR/32./PI/SQRT(SCM)/SN2THW/CS2THW/PROPZ
        SIGRL=2*FACRL/32./PI/SQRT(SCM)/SN2THW/CS2THW/PROPZ
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        IF(GOQ(81,1).AND.GOQ(83,2)) CALL SIGFIL(SIG,0,0,81,83)
        IF(GOQ(83,1).AND.GOQ(81,2)) CALL SIGFIL(SIG,0,0,83,81)
      ENDIF
C          E+ E- --> H_P H_H; SYMMETRIC IN COS(THETA)
      IF((AMHA+AMHH).LT.ECM) THEN
        PCM=SQRT(SSXLAM(SCM,AMHA**2,AMHH**2))/4./EB
        Z=CTH(1)
        FAC1=PCM**3*(1.-Z**2)
        FACLR=E**4*(SIN(ALFAH+BETA))**2*(AE-BE)**2*FAC1
        FACRL=E**4*(SIN(ALFAH+BETA))**2*(AE+BE)**2*FAC1
        SIGLR=2*FACLR/32./PI/SQRT(SCM)/SN2THW/CS2THW/PROPZ
        SIGRL=2*FACRL/32./PI/SQRT(SCM)/SN2THW/CS2THW/PROPZ
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        IF(GOQ(82,1).AND.GOQ(83,2)) CALL SIGFIL(SIG,0,0,82,83)
        IF(GOQ(83,1).AND.GOQ(82,2)) CALL SIGFIL(SIG,0,0,83,82)
      ENDIF
C          E+ E- --> H^+ H^-; symmetric in cos(theta)
      IF((2*AMHC).LT.ECM) THEN
        PCM=SQRT(SSXLAM(SCM,AMHC**2,AMHC**2))/4./EB
        Z=CTH(1)
        FAC1=PCM**3*(1.-Z**2)
        FACLR=FAC1*(1./SCM**2+(2*SN2THW-1.)**2/SN2THW/CS2THW*
     $(AE-BE)**2/4./PROPZ+(2*SN2THW-1.)*(AE-BE)*(SCM-AMZ**2)/SCM/
     $SQRT(SN2THW*CS2THW)/PROPZ)
        FACRL=FAC1*(1./SCM**2+(2*SN2THW-1.)**2/SN2THW/CS2THW*
     $(AE+BE)**2/4./PROPZ+(2*SN2THW-1.)*(AE+BE)*(SCM-AMZ**2)/SCM/
     $SQRT(SN2THW*CS2THW)/PROPZ)
        SIGLR=2*E**4*FACLR/8./PI/SQRT(SCM)
        SIGRL=2*E**4*FACRL/8./PI/SQRT(SCM)
        SIG=(FLEM*FREP*SIGLR+FREM*FLEP*SIGRL)*UNITS/2.
        IF(GOQ(84,1).AND.GOQ(85,2)) CALL SIGFIL(SIG,0,0,84,85)
        IF(GOQ(85,1).AND.GOQ(84,2)) CALL SIGFIL(SIG,0,0,85,84)
      ENDIF
C
      RETURN
      END
CDECK  ID>, SIGSSL. 
      SUBROUTINE SIGSSL
C
C          Calculate d(sigma)/d(pt**2)d(y1)d(y2) for supersymmetric
C          sleptons and sneutrinos in MSSM using cross
C          sections from Baer and Tata.
C
C          SIGMA    = cross section summed over types allowed by
C                     JETTYPE cards.
C          SIGS(I)  = partial cross section for I1 + I2 --> I3 + I4
C          INOUT(I) = IOPAK**3*I4 + IOPAK**2*I3 + IOPAK*I2 +I1
C          JETTYP -> IDENT mapping:
C          GLSS, UPSSL, UBSSL, ..., UPSSR, UBSSR, ...,
C          W1SS+, W1SS-, WS22+, W2SS-, Z1SS, Z2SS, Z3SS, Z4SS
C          NUEL, ANUEL, EL-, ..., TAUL+
C
C          Extra factor of 1/2 needed for nonidentical final jets.
C          Y=-log(tan(theta/2)) gives jacobean P1*P2/E1*E2
C
C          Called from SIGSSY and so does not reinitialize /JETSIG/.
C
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
C
      REAL X(2)
      EQUIVALENCE (X(1),X1)
      EQUIVALENCE (S,SHAT),(T,THAT),(U,UHAT)
      INTEGER JS2JT(25),IW2JS(4),IW2IM(4),IZ2JS(4),IS2UD(25)
      SAVE JS2JT,IW2JS,IW2IM,IZ2JS,IS2UD
      INTEGER IDLSS(18)
      SAVE IDLSS
      INTEGER IL2JS(18),IS2LN(18),II
      SAVE IL2JS,IS2LN
      REAL SIG,S,T,U,FAC,AM22,AM12,TT,GP,G,
     $E1,E2
      INTEGER IQ,IQ1,IQ2,IH
      REAL QFCN,STRUC,PSIFCN,AMASS
      REAL SR2,AML,AMN,SIGW,PROPZ
      REAL CS2THW,TNTHW,CTTHW,AL(2),BE(2),ESQ,XWI(2),YWI(2)
      REAL ALL(2),BEL(2),EL1
      REAL EQ1,XMGG,XMZZ,XMGZ,XM,CTH2L
      REAL SIGUT,SIGTU,EHAT,PHAT,EBM,TPP,AMWI,AMQ,PROPW
      REAL A,B,ASPBS,ASMBS,TM1,TM2,TM3,COTB,TANB
      INTEGER JTYP1,JTYP2,IFLQ,IUD(13)
      INTEGER IFLL,IL,IN,IDL,IDN,IL1,IL2,JTYPL1,JTYPL2,IDL1,IDL2
C
C          IDENT codes from /SSTYPE/. (Fortran 77 allows - signs in
C          parameter statements but not data statements.)
      INTEGER MSUPL,MSDNL,MSSTL,MSCHL,MSBT1,MSTP1,
     $MSUPR,MSDNR,MSSTR,MSCHR,MSBT2,MSTP2,MSW1,MSW2,
     $MSNEL,MSEL,MSNML,MSMUL,MSNTL,MSTAU1,MSER,MSMUR,MSTAU2
      PARAMETER (MSUPL=-ISUPL)
      PARAMETER (MSDNL=-ISDNL)
      PARAMETER (MSSTL=-ISSTL)
      PARAMETER (MSCHL=-ISCHL)
      PARAMETER (MSBT1=-ISBT1)
      PARAMETER (MSTP1=-ISTP1)
      PARAMETER (MSUPR=-ISUPR)
      PARAMETER (MSDNR=-ISDNR)
      PARAMETER (MSSTR=-ISSTR)
      PARAMETER (MSCHR=-ISCHR)
      PARAMETER (MSBT2=-ISBT2)
      PARAMETER (MSTP2=-ISTP2)
      PARAMETER (MSW1=-ISW1)
      PARAMETER (MSW2=-ISW2)
      PARAMETER (MSNEL=-ISNEL)
      PARAMETER (MSEL=-ISEL)
      PARAMETER (MSNML=-ISNML)
      PARAMETER (MSMUL=-ISMUL)
      PARAMETER (MSNTL=-ISNTL)
      PARAMETER (MSTAU1=-ISTAU1)
      PARAMETER (MSER=-ISER)
      PARAMETER (MSMUR=-ISMUR)
      PARAMETER (MSTAU2=-ISTAU2)
      DATA IDLSS/ISNEL,MSNEL,ISEL,MSEL,ISNML,MSNML,ISMUL,MSMUL,
     $ISNTL,MSNTL,ISTAU1,MSTAU1,ISER,MSER,ISMUR,MSMUR,
     $ISTAU2,MSTAU2/
      DATA IUD/0,1,-1,2,-2,2,-2,1,-1,2,-2,1,-1/
C
C          JS2JT: Susy jettype -> normal jettype
      DATA JS2JT/1,
     $2,3,4,5,6,7,8,9,10,11,12,13,2,3,4,5,6,7,8,9,10,11,12,13/
C          IW2JS: Wino index -> susy jettype
      DATA IW2JS/26,27,28,29/
C          IW2IM: Wino index -> match code
      DATA IW2IM/2,3,2,3/
C          IZ2JS: Zino index -> susy jettype
      DATA IZ2JS/30,31,32,33/
C          IS2UD: Susy jettype -> u/d code
      DATA IS2UD/0,1,1,2,2,2,2,1,1,2,2,1,1,1,1,2,2,2,2,1,1,2,2,1,1/
      DATA IS2LN/1,1,2,2,1,1,2,2,1,1,2,2,2,2,2,2,2,2/
      DATA IL2JS/34,35,36,37,38,39,40,41,42,43,44,45,46,47,
     $48,49,50,51/
C
C          Functions
      QFCN(IQ,IH)=STRUC(X(IH),QSQ,IQ,IDIN(IH))/X(IH)
      PSIFCN(AM12,AM22,TT)=((S+TT-AM12)/(2*S)
     $-AM12*(AM22-TT)/(AM12-TT)**2
     $+(TT*(AM22-AM12)+AM22*(S-AM22+AM12))/(S*(AM12-TT)))
C
C          Constants from Baer and Tata,
C
      G=SQRT(4*PI*ALFAEM/SN2THW)
      GP=G*SQRT(SN2THW/(1.-SN2THW))
C          Quark couplings to Z
      CS2THW=1.-SN2THW
      TNTHW=SQRT(SN2THW/CS2THW)
      CTTHW=1./TNTHW
      AL(1)=(CTTHW/4.-5*TNTHW/12.)
      AL(2)=(TNTHW/12.-CTTHW/4.)
      BE(1)=-(CTTHW+TNTHW)/4.
      BE(2)=-BE(1)
      ALL(1)=(CTTHW+TNTHW)/4.
      ALL(2)=(-CTTHW+3*TNTHW)/4.
      BEL(1)=-(CTTHW+TNTHW)/4.
      BEL(2)=-BEL(1)
      ESQ=4*PI*ALFAEM
      SR2=SQRT(2.)
      COTB=RV2V1
      TANB=1./COTB
C
C         qk qb --> slss slbss
C
C
C     Left-leftbar slepton pair production
C
      DO 200 IL=1,6
        IL1=2*IL-1
        IL2=IL1+1
        AML=AMASS(IDLSS(IL1))
        JTYPL1=IL2JS(IL1)
        JTYPL2=IL2JS(IL2)
        IDL1=IDLSS(IL1)
        IDL2=IDLSS(IL2)
          IF (.NOT.(GOQ(JTYPL1,1).AND.GOQ(JTYPL2,2))) GO TO 210
          CALL TWOKIN(0.,0.,AML,AML)
          IF (X1.GE.1..OR.X2.GE.1.) GO TO 210
          E1=SQRT(P(1)**2+AML**2)
          E2=SQRT(P(2)**2+AML**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          DO 220 IQ1=2,11
            IFLQ=IS2UD(IQ1)
            IFLL=IS2LN(IL1)
            IF (IFLQ.EQ.1) THEN
              EQ1=2./3.
            ELSE
              EQ1=-1./3.
            END IF
            IF (IFLL.EQ.1) THEN
              EL1=0.
            ELSE
              EL1=-1.
            END IF
            IQ2=MATCH(IQ1,4)
            PROPZ=(S-AMZ**2)**2+AMZ**2*GAMZ**2
            IF (IQ2.EQ.0.OR.IQ2.GE.12) GO TO 220
              XMGG=EL1**2*EQ1**2/S/S
              CTH2L=1.
              IF (JTYPL1.EQ.44) CTH2L=COS(2*THETAL)
              XMZZ=(AL(IFLQ)**2+BE(IFLQ)**2)*(ALL(IFLL)-BEL(IFLL)*
     $              CTH2L)**2/PROPZ
              XMGZ=2*EL1*EQ1*AL(IFLQ)*(ALL(IFLL)-BEL(IFLL)*CTH2L)*
     $             (S-AMZ**2)/S/PROPZ
              XM=2*ESQ*ESQ*(U*T-AML**4)/3.
              SIG=XM*(XMGG+XMZZ+XMGZ)
              SIG=SIG*FAC*QFCN(IQ1,1)*QFCN(IQ2,2)
              SIG=.5*SIG
              CALL SIGFIL(SIG,IQ1,IQ2,JTYPL1,JTYPL2)
220       CONTINUE
210     CONTINUE
200   CONTINUE
C          stau_1 + stau_2 bar
      IF (GOQ(44,1).AND.GOQ(51,2)) THEN
          CALL TWOKIN(0.,0.,AML1SS,AML2SS)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 231
          E1=SQRT(P(1)**2+AML1SS**2)
          E2=SQRT(P(2)**2+AML2SS**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          PROPZ=(S-AMZ**2)**2+AMZ**2*GAMZ**2
          DO 230 IQ1=2,11
            IFLQ=IS2UD(IQ1)
            IQ2=MATCH(IQ1,4)
            IF (IQ2.EQ.0.OR.IQ2.GE.12) GO TO 230
            SIG=2*ESQ**2*(AL(IFLQ)**2+BE(IFLQ)**2)*BEL(2)**2*
     $     SIN(2*THETAL)**2*(U*T-AML1SS**2*AML2SS**2)/3./PROPZ
            SIG=.5*SIG*FAC*QFCN(IQ1,1)*QFCN(IQ2,2)
            CALL SIGFIL(SIG,IQ1,IQ2,44,51)
230         CONTINUE
231       CONTINUE
      END IF
C
C
C     Right-rightbar slepton pair production
C
      DO 300 IL=1,3
        IL1=11+2*IL
        IL2=IL1+1
        AML=AMASS(IDLSS(IL1))
        JTYPL1=IL2JS(IL1)
        JTYPL2=IL2JS(IL2)
        IDL1=IDLSS(IL1)
        IDL2=IDLSS(IL2)
          IF (.NOT.(GOQ(JTYPL1,1).AND.GOQ(JTYPL2,2))) GO TO 310
          CALL TWOKIN(0.,0.,AML,AML)
          IF (X1.GE.1..OR.X2.GE.1.) GO TO 310
          E1=SQRT(P(1)**2+AML**2)
          E2=SQRT(P(2)**2+AML**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          DO 320 IQ1=2,11
            IFLQ=IS2UD(IQ1)
            IFLL=IS2LN(IL1)
            IF (IFLQ.EQ.1) THEN
              EQ1=2./3.
            ELSE
              EQ1=-1./3.
            END IF
            IF (IFLL.EQ.1) THEN
              EL1=0.
            ELSE
              EL1=-1.
            END IF
            IQ2=MATCH(IQ1,4)
            PROPZ=(S-AMZ**2)**2+AMZ**2*GAMZ**2
            IF (IQ2.EQ.0.OR.IQ2.GE.12) GO TO 320
              XMGG=EL1**2*EQ1**2/S/S
              CTH2L=1.
              IF (JTYPL1.EQ.50) CTH2L=COS(2*THETAL)
              XMZZ=(AL(IFLQ)**2+BE(IFLQ)**2)*(ALL(IFLL)+BEL(IFLL)*
     $              CTH2L)**2/PROPZ
              XMGZ=2*EL1*EQ1*AL(IFLQ)*(ALL(IFLL)+BEL(IFLL)*CTH2L)*
     $             (S-AMZ**2)/S/PROPZ
              XM=2*ESQ*ESQ*(U*T-AML**4)/3.
              SIG=XM*(XMGG+XMZZ+XMGZ)
              SIG=SIG*FAC*QFCN(IQ1,1)*QFCN(IQ2,2)
              SIG=.5*SIG
              CALL SIGFIL(SIG,IQ1,IQ2,JTYPL1,JTYPL2)
320       CONTINUE
310     CONTINUE
300   CONTINUE
C          stau_2 bar + stau_1
      IF (GOQ(51,1).AND.GOQ(44,2)) THEN
          CALL TWOKIN(0.,0.,AML2SS,AML1SS)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 331
          E1=SQRT(P(1)**2+AML2SS**2)
          E2=SQRT(P(2)**2+AML1SS**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          PROPZ=(S-AMZ**2)**2+AMZ**2*GAMZ**2
          DO 330 IQ1=2,11
            IFLQ=IS2UD(IQ1)
            IQ2=MATCH(IQ1,4)
            IF (IQ2.EQ.0.OR.IQ2.GE.12) GO TO 330
            SIG=2*ESQ**2*(AL(IFLQ)**2+BE(IFLQ)**2)*BEL(2)**2*
     $     SIN(2*THETAL)**2*(U*T-AML1SS**2*AML2SS**2)/3./PROPZ
            SIG=.5*SIG*FAC*QFCN(IQ1,1)*QFCN(IQ2,2)
            CALL SIGFIL(SIG,IQ1,IQ2,51,44)
330         CONTINUE
331       CONTINUE
      END IF
C
C
C     Leftbar-left slepton pair production
C
      DO 400 IL=1,6
        IL1=2*IL
        IL2=IL1-1
        AML=AMASS(IDLSS(IL1))
        JTYPL1=IL2JS(IL1)
        JTYPL2=IL2JS(IL2)
        IDL1=IDLSS(IL1)
        IDL2=IDLSS(IL2)
          IF (.NOT.(GOQ(JTYPL1,1).AND.GOQ(JTYPL2,2))) GO TO 410
          CALL TWOKIN(0.,0.,AML,AML)
          IF (X1.GE.1..OR.X2.GE.1.) GO TO 410
          E1=SQRT(P(1)**2+AML**2)
          E2=SQRT(P(2)**2+AML**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          DO 420 IQ1=2,11
            IFLQ=IS2UD(IQ1)
            IFLL=IS2LN(IL1)
            IF (IFLQ.EQ.1) THEN
              EQ1=2./3.
            ELSE
              EQ1=-1./3.
            END IF
            IF (IFLL.EQ.1) THEN
              EL1=0.
            ELSE
              EL1=-1.
            END IF
            IQ2=MATCH(IQ1,4)
            PROPZ=(S-AMZ**2)**2+AMZ**2*GAMZ**2
            IF (IQ2.EQ.0.OR.IQ2.GE.12) GO TO 420
              XMGG=EL1**2*EQ1**2/S/S
              CTH2L=1.
              IF (JTYPL1.EQ.45) CTH2L=COS(2*THETAL)
              XMZZ=(AL(IFLQ)**2+BE(IFLQ)**2)*(ALL(IFLL)-BEL(IFLL)*
     $              CTH2L)**2/PROPZ
              XMGZ=2*EL1*EQ1*AL(IFLQ)*(ALL(IFLL)-BEL(IFLL)*CTH2L)*
     $             (S-AMZ**2)/S/PROPZ
              XM=2*ESQ*ESQ*(U*T-AML**4)/3.
              SIG=XM*(XMGG+XMZZ+XMGZ)
              SIG=SIG*FAC*QFCN(IQ1,1)*QFCN(IQ2,2)
              SIG=.5*SIG
              CALL SIGFIL(SIG,IQ1,IQ2,JTYPL1,JTYPL2)
420       CONTINUE
410     CONTINUE
400   CONTINUE
C          stau_1 bar + stau_2
      IF (GOQ(45,1).AND.GOQ(50,2)) THEN
          CALL TWOKIN(0.,0.,AML1SS,AML2SS)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 431
          E1=SQRT(P(1)**2+AML1SS**2)
          E2=SQRT(P(2)**2+AML2SS**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          PROPZ=(S-AMZ**2)**2+AMZ**2*GAMZ**2
          DO 430 IQ1=2,11
            IFLQ=IS2UD(IQ1)
            IQ2=MATCH(IQ1,4)
            IF (IQ2.EQ.0.OR.IQ2.GE.12) GO TO 430
            SIG=2*ESQ**2*(AL(IFLQ)**2+BE(IFLQ)**2)*BEL(2)**2*
     $     SIN(2*THETAL)**2*(U*T-AML1SS**2*AML2SS**2)/3./PROPZ
            SIG=.5*SIG*FAC*QFCN(IQ1,1)*QFCN(IQ2,2)
            CALL SIGFIL(SIG,IQ1,IQ2,45,50)
430         CONTINUE
431       CONTINUE
      END IF
C
C
C     Rightbar-right slepton pair production
C
      DO 500 IL=1,3
        IL1=12+2*IL
        IL2=IL1-1
        AML=AMASS(IDLSS(IL1))
        JTYPL1=IL2JS(IL1)
        JTYPL2=IL2JS(IL2)
        IDL1=IDLSS(IL1)
        IDL2=IDLSS(IL2)
          IF (.NOT.(GOQ(JTYPL1,1).AND.GOQ(JTYPL2,2))) GO TO 510
          CALL TWOKIN(0.,0.,AML,AML)
          IF (X1.GE.1..OR.X2.GE.1.) GO TO 510
          E1=SQRT(P(1)**2+AML**2)
          E2=SQRT(P(2)**2+AML**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          DO 520 IQ1=2,11
            IFLQ=IS2UD(IQ1)
            IFLL=IS2LN(IL1)
            IF (IFLQ.EQ.1) THEN
              EQ1=2./3.
            ELSE
              EQ1=-1./3.
            END IF
            IF (IFLL.EQ.1) THEN
              EL1=0.
            ELSE
              EL1=-1.
            END IF
            IQ2=MATCH(IQ1,4)
            PROPZ=(S-AMZ**2)**2+AMZ**2*GAMZ**2
            IF (IQ2.EQ.0.OR.IQ2.GE.12) GO TO 520
              XMGG=EL1**2*EQ1**2/S/S
              CTH2L=1.
              IF (JTYPL1.EQ.51) CTH2L=COS(2*THETAL)
              XMZZ=(AL(IFLQ)**2+BE(IFLQ)**2)*(ALL(IFLL)+BEL(IFLL)*
     $              CTH2L)**2/PROPZ
              XMGZ=2*EL1*EQ1*AL(IFLQ)*(ALL(IFLL)+BEL(IFLL)*CTH2L)*
     $             (S-AMZ**2)/S/PROPZ
              XM=2*ESQ*ESQ*(U*T-AML**4)/3.
              SIG=XM*(XMGG+XMZZ+XMGZ)
              SIG=SIG*FAC*QFCN(IQ1,1)*QFCN(IQ2,2)
              SIG=.5*SIG
              CALL SIGFIL(SIG,IQ1,IQ2,JTYPL1,JTYPL2)
520       CONTINUE
510     CONTINUE
500   CONTINUE
C          stau_2 + stau_1 bar
      IF (GOQ(50,1).AND.GOQ(45,2)) THEN
          CALL TWOKIN(0.,0.,AML2SS,AML1SS)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 531
          E1=SQRT(P(1)**2+AML2SS**2)
          E2=SQRT(P(2)**2+AML1SS**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          PROPZ=(S-AMZ**2)**2+AMZ**2*GAMZ**2
          DO 530 IQ1=2,11
            IFLQ=IS2UD(IQ1)
            IQ2=MATCH(IQ1,4)
            IF (IQ2.EQ.0.OR.IQ2.GE.12) GO TO 530
            SIG=2*ESQ**2*(AL(IFLQ)**2+BE(IFLQ)**2)*BEL(2)**2*
     $     SIN(2*THETAL)**2*(U*T-AML1SS**2*AML2SS**2)/3./PROPZ
            SIG=.5*SIG*FAC*QFCN(IQ1,1)*QFCN(IQ2,2)
            CALL SIGFIL(SIG,IQ1,IQ2,50,45)
530         CONTINUE
531       CONTINUE
      END IF
C
C          slepton+sneutrino-bar via W-*
C
      DO 600 II=1,3
        IL=4*II-1
        IN=IL-1
        IDL=IDLSS(IL)
        IDN=IDLSS(IN)
        AML=AMASS(IDL)
        AMN=AMASS(IDN)
        JTYP1=IL2JS(IL)
        JTYP2=IL2JS(IN)
          IF(.NOT.(GOQ(JTYP1,1).AND.GOQ(JTYP2,2))) GO TO 610
          CALL TWOKIN(0.,0.,AML,AMN)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 610
          E1=SQRT(P(1)**2+AML**2)
          E2=SQRT(P(2)**2+AMN**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          PROPW=(S-AMW**2)**2+AMW**2*GAMW**2
          SIGW=G**4*(U*T-AML**2*AMN**2)/12./PROPW
          IF (JTYP1.EQ.44) SIGW=SIGW*COS(THETAL)**2
            SIG=.5*SIGW*FAC*QFCN(3,1)*QFCN(4,2)
            CALL SIGFIL(SIG,3,4,JTYP1,JTYP2)
            SIG=.5*SIGW*FAC*QFCN(4,1)*QFCN(3,2)
            CALL SIGFIL(SIG,4,3,JTYP1,JTYP2)
            SIG=.5*SIGW*FAC*QFCN(9,1)*QFCN(6,2)
            CALL SIGFIL(SIG,9,6,JTYP1,JTYP2)
            SIG=.5*SIGW*FAC*QFCN(6,1)*QFCN(9,2)
            CALL SIGFIL(SIG,6,9,JTYP1,JTYP2)
610     CONTINUE
600   CONTINUE
C          stau_2 +nu_tau bar
      IF (GOQ(50,1).AND.GOQ(43,2)) THEN
          CALL TWOKIN(0.,0.,AML2SS,AMN3SS)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 620
          E1=SQRT(P(1)**2+AML2SS**2)
          E2=SQRT(P(2)**2+AMN3SS**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          PROPW=(S-AMW**2)**2+AMW**2*GAMW**2
          SIGW=G**4*(U*T-AML2SS**2*AMN3SS**2)/12./PROPW
          SIGW=SIGW*SIN(THETAL)**2
          SIG=.5*SIGW*FAC*QFCN(3,1)*QFCN(4,2)
          CALL SIGFIL(SIG,3,4,50,43)
          SIG=.5*SIGW*FAC*QFCN(4,1)*QFCN(3,2)
          CALL SIGFIL(SIG,4,3,50,43)
          SIG=.5*SIGW*FAC*QFCN(9,1)*QFCN(6,2)
          CALL SIGFIL(SIG,9,6,50,43)
          SIG=.5*SIGW*FAC*QFCN(6,1)*QFCN(9,2)
          CALL SIGFIL(SIG,6,9,50,43)
620       CONTINUE
      END IF
C
C          sneutrino-bar+slepton via W-*
C
      DO 700 II=1,3
        IN=4*II-2
        IL=IN+1
        IDL=IDLSS(IL)
        IDN=IDLSS(IN)
        AML=AMASS(IDL)
        AMN=AMASS(IDN)
        JTYP1=IL2JS(IN)
        JTYP2=IL2JS(IL)
          IF(.NOT.(GOQ(JTYP1,1).AND.GOQ(JTYP2,2))) GO TO 710
          CALL TWOKIN(0.,0.,AMN,AML)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 710
          E1=SQRT(P(1)**2+AMN**2)
          E2=SQRT(P(2)**2+AML**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          PROPW=(S-AMW**2)**2+AMW**2*GAMW**2
          SIGW=G**4*(U*T-AML**2*AMN**2)/12./PROPW
          IF (JTYP2.EQ.44) SIGW=SIGW*COS(THETAL)**2
            SIG=.5*SIGW*FAC*QFCN(3,1)*QFCN(4,2)
            CALL SIGFIL(SIG,3,4,JTYP1,JTYP2)
            SIG=.5*SIGW*FAC*QFCN(4,1)*QFCN(3,2)
            CALL SIGFIL(SIG,4,3,JTYP1,JTYP2)
            SIG=.5*SIGW*FAC*QFCN(9,1)*QFCN(6,2)
            CALL SIGFIL(SIG,9,6,JTYP1,JTYP2)
            SIG=.5*SIGW*FAC*QFCN(6,1)*QFCN(9,2)
            CALL SIGFIL(SIG,6,9,JTYP1,JTYP2)
710     CONTINUE
700   CONTINUE
C          nu_tau bar + STAU_2
      IF (GOQ(43,1).AND.GOQ(50,2)) THEN
          CALL TWOKIN(0.,0.,AMN3SS,AML2SS)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 720
          E1=SQRT(P(1)**2+AMN3SS**2)
          E2=SQRT(P(2)**2+AML2SS**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          PROPW=(S-AMW**2)**2+AMW**2*GAMW**2
          SIGW=G**4*(U*T-AML2SS**2*AMN3SS**2)/12./PROPW
          SIGW=SIGW*SIN(THETAL)**2
          SIG=.5*SIGW*FAC*QFCN(3,1)*QFCN(4,2)
          CALL SIGFIL(SIG,3,4,43,50)
          SIG=.5*SIGW*FAC*QFCN(4,1)*QFCN(3,2)
          CALL SIGFIL(SIG,4,3,43,50)
          SIG=.5*SIGW*FAC*QFCN(9,1)*QFCN(6,2)
          CALL SIGFIL(SIG,9,6,43,50)
          SIG=.5*SIGW*FAC*QFCN(6,1)*QFCN(9,2)
          CALL SIGFIL(SIG,6,9,43,50)
720       CONTINUE
      END IF
C
C          slepton-bar+sneutrino via W+*
C
      DO 800 II=1,3
        IL=4*II
        IN=IL-3
        IDL=IDLSS(IL)
        IDN=IDLSS(IN)
        AML=AMASS(IDL)
        AMN=AMASS(IDN)
        JTYP1=IL2JS(IL)
        JTYP2=IL2JS(IN)
          IF(.NOT.(GOQ(JTYP1,1).AND.GOQ(JTYP2,2))) GO TO 810
          CALL TWOKIN(0.,0.,AML,AMN)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 810
          E1=SQRT(P(1)**2+AML**2)
          E2=SQRT(P(2)**2+AMN**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          PROPW=(S-AMW**2)**2+AMW**2*GAMW**2
          SIGW=G**4*(U*T-AML**2*AMN**2)/12./PROPW
          IF (JTYP1.EQ.45) SIGW=SIGW*COS(THETAL)**2
            SIG=.5*SIGW*FAC*QFCN(2,1)*QFCN(5,2)
            CALL SIGFIL(SIG,2,5,JTYP1,JTYP2)
            SIG=.5*SIGW*FAC*QFCN(5,1)*QFCN(2,2)
            CALL SIGFIL(SIG,5,2,JTYP1,JTYP2)
            SIG=.5*SIGW*FAC*QFCN(8,1)*QFCN(7,2)
            CALL SIGFIL(SIG,8,7,JTYP1,JTYP2)
            SIG=.5*SIGW*FAC*QFCN(7,1)*QFCN(8,2)
            CALL SIGFIL(SIG,7,8,JTYP1,JTYP2)
810     CONTINUE
800   CONTINUE
C          stau_2 bar+nu_tau
      IF (GOQ(51,1).AND.GOQ(42,2)) THEN
          CALL TWOKIN(0.,0.,AML2SS,AMN3SS)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 820
          E1=SQRT(P(1)**2+AML2SS**2)
          E2=SQRT(P(2)**2+AMN3SS**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          PROPW=(S-AMW**2)**2+AMW**2*GAMW**2
          SIGW=G**4*(U*T-AML2SS**2*AMN3SS**2)/12./PROPW
          SIGW=SIGW*SIN(THETAL)**2
          SIG=.5*SIGW*FAC*QFCN(2,1)*QFCN(5,2)
          CALL SIGFIL(SIG,2,5,51,42)
          SIG=.5*SIGW*FAC*QFCN(5,1)*QFCN(2,2)
          CALL SIGFIL(SIG,5,2,51,42)
          SIG=.5*SIGW*FAC*QFCN(8,1)*QFCN(7,2)
          CALL SIGFIL(SIG,8,7,51,42)
          SIG=.5*SIGW*FAC*QFCN(7,1)*QFCN(8,2)
          CALL SIGFIL(SIG,7,8,51,42)
820       CONTINUE
      END IF
C
C          sneutrino+slepton-bar via W+*
C
      DO 900 II=1,3
        IN=4*II-3
        IL=IN+3
        IDL=IDLSS(IL)
        IDN=IDLSS(IN)
        AML=AMASS(IDL)
        AMN=AMASS(IDN)
        JTYP1=IL2JS(IN)
        JTYP2=IL2JS(IL)
          IF(.NOT.(GOQ(JTYP1,1).AND.GOQ(JTYP2,2))) GO TO 910
          CALL TWOKIN(0.,0.,AMN,AML)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 910
          E1=SQRT(P(1)**2+AMN**2)
          E2=SQRT(P(2)**2+AML**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          PROPW=(S-AMW**2)**2+AMW**2*GAMW**2
          SIGW=G**4*(U*T-AML**2*AMN**2)/12./PROPW
          IF (JTYP2.EQ.45) SIGW=SIGW*COS(THETAL)**2
            SIG=.5*SIGW*FAC*QFCN(2,1)*QFCN(5,2)
            CALL SIGFIL(SIG,2,5,JTYP1,JTYP2)
            SIG=.5*SIGW*FAC*QFCN(5,1)*QFCN(2,2)
            CALL SIGFIL(SIG,5,2,JTYP1,JTYP2)
            SIG=.5*SIGW*FAC*QFCN(8,1)*QFCN(7,2)
            CALL SIGFIL(SIG,8,7,JTYP1,JTYP2)
            SIG=.5*SIGW*FAC*QFCN(7,1)*QFCN(8,2)
            CALL SIGFIL(SIG,7,8,JTYP1,JTYP2)
910     CONTINUE
900   CONTINUE
C          nu_tau + stau_2 bar
      IF (GOQ(42,1).AND.GOQ(51,2)) THEN
          CALL TWOKIN(0.,0.,AMN3SS,AML2SS)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 920
          E1=SQRT(P(1)**2+AMN3SS**2)
          E2=SQRT(P(2)**2+AML2SS**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          PROPW=(S-AMW**2)**2+AMW**2*GAMW**2
          SIGW=G**4*(U*T-AML2SS**2*AMN3SS**2)/12./PROPW
          SIGW=SIGW*SIN(THETAL)**2
          SIG=.5*SIGW*FAC*QFCN(2,1)*QFCN(5,2)
          CALL SIGFIL(SIG,2,5,42,51)
          SIG=.5*SIGW*FAC*QFCN(5,1)*QFCN(2,2)
          CALL SIGFIL(SIG,5,2,42,51)
          SIG=.5*SIGW*FAC*QFCN(8,1)*QFCN(7,2)
          CALL SIGFIL(SIG,8,7,42,51)
          SIG=.5*SIGW*FAC*QFCN(7,1)*QFCN(8,2)
          CALL SIGFIL(SIG,7,8,42,51)
920       CONTINUE
      END IF
C
      RETURN
      END
CDECK  ID>, SIGSSY. 
      SUBROUTINE SIGSSY
C
C          Calculate d(sigma)/d(pt**2)d(y1)d(y2) for supersymmetric
C          particle pairs, including gluinos, gauginos, and squarks.
C
C          SIGMA    = cross section summed over types allowed by
C                     JETTYPE cards (with natural equivalence.)
C          SIGS(I)  = partial cross section for I1 + I2 --> I3 + I4
C          INOUT(I) = IOPAK**3*I4 + IOPAK**2*I3 + IOPAK*I2 +I1
C
C          Extra factor of 1/2 needed for nonidentical final jets.
C          Y=-log(tan(theta/2)) gives jacobean P1*P2/E1*E2
C
C          Dec. 1992: Use cross sections from Baer and Tata, Phys.
C          Lett. 160B, 159; Phys. Rev. D42, 2259. These papers
C          separate L and R squarks.
C
C          Gauginos are included only for MSSM. The cross sections are
C          calculated in SIGSSZ, which is called from here.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/QSAVE/QSAVE(29,2)
      SAVE /QSAVE/
      REAL      QSAVE
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C
      REAL X(2)
      INTEGER IDQ(13),IDQSS(25),JS2JT(25)
      EQUIVALENCE (X(1),X1)
      LOGICAL LLRR
      REAL QFCN,STRUC,AMASS,FQG
      REAL AMG,SIG0,SIGR,AM1,SIG,FAC,AMQ,AM,AM2,AMQ2,S,T,U,AMG2,E1,E2,
     $AMSQ,AM1SQ,AM2SQ,SIGL
      INTEGER IFL1,IFL2,IQ1,IQ2,JQ1,JQ2,I,IFLQ1,IFLQ2,IH,IQ,
     $JQ,JQIN1,JQIN2
C
C          IDENT codes from /SSTYPE/. (Fortran 77 allows - signs in
C          parameter statements but not data statements.)
      INTEGER MSUPL,MSDNL,MSSTL,MSCHL,MSBT1,MSTP1,
     $MSUPR,MSDNR,MSSTR,MSCHR,MSBT2,MSTP2,
     $MDUP,MDDN,MDST,MDCH,MDBT,MDTP
      PARAMETER (MSUPL=-ISUPL)
      PARAMETER (MSDNL=-ISDNL)
      PARAMETER (MSSTL=-ISSTL)
      PARAMETER (MSCHL=-ISCHL)
      PARAMETER (MSBT1=-ISBT1)
      PARAMETER (MSTP1=-ISTP1)
      PARAMETER (MSUPR=-ISUPR)
      PARAMETER (MSDNR=-ISDNR)
      PARAMETER (MSSTR=-ISSTR)
      PARAMETER (MSCHR=-ISCHR)
      PARAMETER (MSBT2=-ISBT2)
      PARAMETER (MSTP2=-ISTP2)
      PARAMETER (MDUP=-IDUP)
      PARAMETER (MDDN=-IDDN)
      PARAMETER (MDST=-IDST)
      PARAMETER (MDCH=-IDCH)
      PARAMETER (MDBT=-IDBT)
      PARAMETER (MDTP=-IDTP)
      DATA IDQSS/0,
     $ISUPL,MSUPL,ISDNL,MSDNL,ISSTL,MSSTL,ISCHL,MSCHL,ISBT1,MSBT1,
     $ISTP1,MSTP1,
     $ISUPR,MSUPR,ISDNR,MSDNR,ISSTR,MSSTR,ISCHR,MSCHR,ISBT2,MSBT2,
     $ISTP2,MSTP2/
      DATA IDQ/IDGL,IDUP,MDUP,IDDN,MDDN,IDST,MDST,IDCH,MDCH,
     $IDBT,MDBT,IDTP,MDTP/
C          JS2JT: Susy jettype -> normal jettype
      DATA JS2JT/1,
     $2,3,4,5,6,7,8,9,10,11,12,13,2,3,4,5,6,7,8,9,10,11,12,13/
C
C          Functions
      QFCN(IQ,IH)=STRUC(X(IH),QSQ,IQ,IDIN(IH))/X(IH)
      FQG(S,T,U)=((16./3.)*(1./(U*T)**2+1./(S*U)**2)
     $+2.*(-2./3.)/(S*T*U**2))*(-U*S*T**2+2.*U*S*T*(AMG2-AMQ2)
     $-2.*U*S*(AMG2-AMQ2)**2-2.*S**2*AMG2*(AMG2-AMQ2))
C
C          Initialize
C
      SIGMA=0.
      NSIGS=0
      DO 100 I=1,MXSIGS
        SIGS(I)=0.
100   CONTINUE
C
C          Gluino + gluino
C
      IF(.NOT.(GOQ(1,1).AND.GOQ(1,2))) GO TO 300
      AM=AMASS(ISGL)
      CALL TWOKIN(0.,0.,AM,AM)
      IF(X1.GE.1..OR.X2.GE.1.) GO TO 300
      AM2=AM**2
      S=SHAT
      T=THAT
      U=UHAT
      E1=SQRT(P(1)**2+AM2)
      E2=SQRT(P(2)**2+AM2)
      FAC=PI*ALFQSQ**2/S**2
      FAC=FAC*(S/SCM)*(P(1)*P(2)/(E1*E2))*UNITS
C
C          gl gl ---> glss glss
      SIG=9./4.*(2.*(T-AM2)*(U-AM2)/S**2
     $+((T-AM2)*(U-AM2)-2.*AM2*(T+AM2))/(T-AM2)**2
     $+((U-AM2)*(T-AM2)-2.*AM2*(U+AM2))/(U-AM2)**2
     $+((T-AM2)*(U-AM2)+AM2*(U-T))/(S*(T-AM2))
     $+((U-AM2)*(T-AM2)+AM2*(T-U))/(S*(U-AM2))
     $+AM2*(S-4*AM2)/((T-AM2)*(U-AM2)))
      SIG=.5*FAC*SIG*QFCN(1,1)*QFCN(1,2)
      CALL SIGFIL(SIG,1,1,1,1)
C
C          qk qb ---> glss glss
      DO 220 IQ=1,5
        IQ1=2*IQ
        IQ2=IQ1+1
C          Left squark exchange
        AMQ=AMASS(IDQSS(IQ1))
        AMQ2=AMQ**2
        SIGL=(8./3.)*((T-AM2)**2+(U-AM2)**2+2.*AM2*S)/(S**2)
     $  +(32./27.)*(T-AM2)**2/(T-AMQ2)**2
     $  +(32./27.)*(U-AM2)**2/(U-AMQ2)**2
     $  +(8./3.)*((T-AM2)**2+AM2*S)/(S*(T-AMQ2))
     $  +(8./3.)*((U-AM2)**2+AM2*S)/(S*(U-AMQ2))
     $  +(8./27.)*AM2*S/((T-AMQ2)*(U-AMQ2))
        SIGL=.5*FAC*SIGL
C          Right squark exchange
        AMQ=AMASS(IDQSS(IQ1+12))
        AMQ2=AMQ**2
        SIGR=(8./3.)*((T-AM2)**2+(U-AM2)**2+2.*AM2*S)/(S**2)
     $  +(32./27.)*(T-AM2)**2/(T-AMQ2)**2
     $  +(32./27.)*(U-AM2)**2/(U-AMQ2)**2
     $  +(8./3.)*((T-AM2)**2+AM2*S)/(S*(T-AMQ2))
     $  +(8./3.)*((U-AM2)**2+AM2*S)/(S*(U-AMQ2))
     $  +(8./27.)*AM2*S/((T-AMQ2)*(U-AMQ2))
        SIGR=.5*FAC*SIGR
        SIG0=.5*(SIGL+SIGR)
C          Total
        SIG=SIG0*QFCN(IQ1,1)*QFCN(IQ2,2)
        CALL SIGFIL(SIG,IQ1,IQ2,1,1)
        SIG=SIG0*QFCN(IQ2,1)*QFCN(IQ1,2)
        CALL SIGFIL(SIG,IQ2,IQ1,1,1)
220   CONTINUE
C
C          Scalar quark + scalar (anti)quark
C
300   CONTINUE
      AMG=AMASS(ISGL)
      AMG2=AMG**2
C          IQ1 and IQ2 loop over left and right (anti)squarks
      DO 310 IQ1=2,25
      DO 320 IQ2=2,25
        IF(.NOT.(GOQ(IQ1,1).AND.GOQ(IQ2,2))) GO TO 320
        JQ1=JS2JT(IQ1)
        JQ2=JS2JT(IQ2)
C        IF(JQ1.GE.12.OR.JQ2.GE.12) GO TO 320
        IFL1=IDQSS(IQ1)
        IFL2=IDQSS(IQ2)
        IFLQ1=IDQ(JQ1)
        IFLQ2=IDQ(JQ2)
C          LLRR is true for left-left or right-right
        IF((IQ1.LE.13.AND.IQ2.LE.13).OR.(IQ1.GT.13.AND.IQ2.GT.13))
     $  THEN
          LLRR=.TRUE.
        ELSE
          LLRR=.FALSE.
        ENDIF
C          Kinematics
        AM1=AMASS(IFL1)
        AM2=AMASS(IFL2)
        AM=AM1
        CALL TWOKIN(0.,0.,AM1,AM2)
        IF(X1.GE.1..OR.X2.GE.1.) GO TO 320
        AMSQ=AM**2
        AM1SQ=AM1**2
        AM2SQ=AM2**2
        S=SHAT
        T=THAT
        U=UHAT
        E1=SQRT(P(1)**2+AM1SQ)
        E2=SQRT(P(2)**2+AM2SQ)
        FAC=PI*ALFQSQ**2/S**2
        FAC=FAC*(S/SCM)*(P(1)*P(2)/(E1*E2))*UNITS
C
C          gl gl ---> qkss qbss
C
        IF(IFL1.EQ.-IFL2) THEN
          SIG=(7./48.+3.*(U-T)**2/(16.*S**2))
     $    *(1.+2.*AMSQ*T/(T-AMSQ)**2+2.*AMSQ*U/(U-AMSQ)**2
     $    +4.*AMSQ**2/((T-AMSQ)*(U-AMSQ)))
          SIG=SIG*FAC*QFCN(1,1)*QFCN(1,2)
          SIG=.5*SIG
C          Another .5 to sum over L and R
          SIG=.5*SIG
          CALL SIGFIL(SIG,1,1,IQ1,IQ2)
        ENDIF
C
C          qk qb ---> qkss qbss
C
        IF(IFLQ1.EQ.-IFLQ2.AND.LLRR) THEN
C          Identical squark-antisquark, LL or RR
          SIG=(2./9.)*(1/(T-AMG2)**2+2/S**2-2/(3*S*(T-AMG2)))
     $     *(-S*T-(T-AMSQ)**2)*FAC*QFCN(JQ1,1)*QFCN(JQ2,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,JQ1,JQ2,IQ1,IQ2)
          SIG=(2./9.)*(1/(U-AMG2)**2+2/S**2-2/(3*S*(U-AMG2)))
     $     *(-S*U-(U-AMSQ)**2)*FAC*QFCN(JQ2,1)*QFCN(JQ1,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,JQ2,JQ1,IQ1,IQ2)
        ELSEIF(IFLQ1.EQ.-IFLQ2.AND..NOT.LLRR) THEN
C          Identical squark-antisquark, LR or RL
          SIG=(2./9.)*AMG2*S/(T-AMG2)**2*FAC*QFCN(JQ1,1)*QFCN(JQ2,2)
        SIG=.5*SIG
          CALL SIGFIL(SIG,JQ1,JQ2,IQ1,IQ2)
          SIG=(2./9.)*AMG2*S/(U-AMG2)**2*FAC*QFCN(JQ2,1)*QFCN(JQ1,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,JQ2,JQ1,IQ1,IQ2)
        ELSEIF(IFLQ1.EQ.IFLQ2.AND.LLRR) THEN
C          Identical squark-squark, LL or RR
          SIG=(1./9.)*AMG2*S*(1/(T-AMG2)**2+1/(U-AMG2)**2
     $    -(2./3.)/((T-AMG2)*(U-AMG2)))*FAC*QFCN(JQ1,1)*QFCN(JQ2,2)
          CALL SIGFIL(SIG,JQ1,JQ2,IQ1,IQ2)
        ELSEIF(IFLQ1.EQ.IFLQ2.AND..NOT.LLRR) THEN
C          Identical squark-squark, LR or RL
          SIG=(2./9.)*(1/(T-AMG2)**2*(-S*T-(T-AM1SQ)*(T-AM2SQ))
     $    +1/(U-AMG2)**2*(-S*U-(U-AM1SQ)*(U-AM2SQ)))
     $    *FAC*QFCN(JQ1,1)*QFCN(JQ2,2)
          CALL SIGFIL(SIG,JQ1,JQ2,IQ1,IQ2)
        ELSEIF(IFL1*IFL2.LT.0.AND.LLRR) THEN
C          Nonidentical squark-antisquark, LL or RR
          SIG=(2./9.)*(-S*T-(T-AM1SQ)*(T-AM2SQ))/(T-AMG2)**2*FAC
     $    *QFCN(JQ1,1)*QFCN(JQ2,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,JQ1,JQ2,IQ1,IQ2)
          SIG=(2./9.)*(-S*U-(U-AM1SQ)*(U-AM2SQ))/(U-AMG2)**2*FAC
     $    *QFCN(JQ2,1)*QFCN(JQ1,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,JQ2,JQ1,IQ1,IQ2)
        ELSEIF(IFL1*IFL2.LT.0.AND..NOT.LLRR) THEN
C          Nonidentical squark-antisquark, LR or RL
          SIG=(2./9.)*AMG2*S/(T-AMG2)**2*FAC*QFCN(JQ1,1)*QFCN(JQ2,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,JQ1,JQ2,IQ1,IQ2)
          SIG=(2./9.)*AMG2*S/(U-AMG2)**2*FAC*QFCN(JQ2,1)*QFCN(JQ1,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,JQ2,JQ1,IQ1,IQ2)
        ELSEIF(IFL1*IFL2.GT.0.AND.LLRR) THEN
C          Nonidentical squark-squark, LL or RR
          SIG=(2./9.)*AMG2*S/(T-AMG2)**2*FAC*QFCN(JQ1,1)*QFCN(JQ2,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,JQ1,JQ2,IQ1,IQ2)
          SIG=(2./9.)*AMG2*S/(U-AMG2)**2*FAC*QFCN(JQ2,1)*QFCN(JQ1,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,JQ2,JQ1,IQ1,IQ2)
        ELSEIF(IFL1*IFL2.GT.0.AND..NOT.LLRR) THEN
C          Nonidentical squark-squark, LR or RL
          SIG=(2./9.)*(-S*T-(T-AM1SQ)*(T-AM2SQ))/(T-AMG2)**2*FAC
     $    *QFCN(JQ1,1)*QFCN(JQ2,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,JQ1,JQ2,IQ1,IQ2)
          SIG=(2./9.)*(-S*U-(U-AM1SQ)*(U-AM2SQ))/(U-AMG2)**2*FAC
     $    *QFCN(JQ2,1)*QFCN(JQ1,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,JQ2,JQ1,IQ1,IQ2)
        ELSE
          STOP99
        ENDIF
C
C          q1 + q1bar --> q2ss + q2ssbar
C
        IF(IFLQ1.EQ.-IFLQ2.AND.LLRR) THEN
          DO 330 JQIN1=2,10,2
            IF(JQIN1.EQ.JQ1.OR.JQIN1.EQ.JQ2) GO TO 330
            JQIN2=MATCH(JQIN1,4)
            SIG=(4./9.)*(-S*T-(T-AM1SQ)**2)/S**2*FAC
     $      *QFCN(JQIN1,1)*QFCN(JQIN2,2)
            SIG=.5*SIG
            CALL SIGFIL(SIG,JQIN1,JQIN2,IQ1,IQ2)
            SIG=(4./9.)*(-S*U-(U-AM1SQ)**2)/S**2*FAC
     $      *QFCN(JQIN2,1)*QFCN(JQIN1,2)
            SIG=.5*SIG
            CALL SIGFIL(SIG,JQIN2,JQIN1,IQ1,IQ2)
330       CONTINUE
        ENDIF
320   CONTINUE
310   CONTINUE
C
C          Scalar quark + gluino
C
      AMG=AMASS(ISGL)
      AMG2=AMG**2
      DO 400 IQ=2,25
        AMQ=AMASS(IDQSS(IQ))
        AMQ2=AMQ**2
        JQ=JS2JT(IQ)
C
C          Jet 1 = scalar quark
        IF(.NOT.(GOQ(JQ,1).AND.GOQ(1,2))) GO TO 410
        CALL TWOKIN(0.,0.,AMQ,AMG)
        IF(X1.GE.1..OR.X2.GE.1.) GO TO 410
        S=SHAT
        E1=SQRT(P(1)**2+AMQ2)
        E2=SQRT(P(2)**2+AMG2)
        FAC=PI*ALFQSQ**2/S**2
        FAC=FAC*S/SCM*P(1)*P(2)/(E1*E2)*UNITS
C
        T=THAT-AMQ2
        U=UHAT-AMG2
        SIG=FQG(S,T,U)*FAC/12.*QFCN(JQ,1)*QFCN(1,2)
        SIG=.5*SIG
        SIG=.5*SIG
        CALL SIGFIL(SIG,JQ,1,IQ,1)
C
        T=UHAT-AMQ2
        U=THAT-AMG2
        SIG=FQG(S,T,U)*FAC/12.*QFCN(1,1)*QFCN(JQ,2)
        SIG=.5*SIG
        SIG=.5*SIG
        CALL SIGFIL(SIG,1,JQ,IQ,1)
C
C          Jet 2 = scalar quark
410     IF(.NOT.(GOQ(1,1).AND.GOQ(JQ,2))) GO TO 400
        CALL TWOKIN(0.,0.,AMG,AMQ)
        IF(X1.GE.1..OR.X2.GE.1.) GO TO 400
        S=SHAT
        E1=SQRT(P(1)**2+AMG2)
        E2=SQRT(P(2)**2+AMQ2)
        FAC=PI*ALFQSQ**2/S**2
        FAC=FAC*S/SCM*P(1)*P(2)/(E1*E2)*UNITS
C
        T=UHAT-AMQ2
        U=THAT-AMG2
        SIG=FQG(S,T,U)*FAC/12.*QFCN(1,1)*QFCN(JQ,2)
        SIG=.5*SIG
        SIG=.5*SIG
        CALL SIGFIL(SIG,1,JQ,1,IQ)
C
        T=THAT-AMQ2
        U=UHAT-AMG2
        SIG=FQG(S,T,U)*FAC/12.*QFCN(JQ,1)*QFCN(1,2)
        SIG=.5*SIG
        SIG=.5*SIG
        CALL SIGFIL(SIG,JQ,1,1,IQ)
400   CONTINUE
C
C          Calculate gaugino AND slepton cross sections only for MSSM
C
      IF(GOMSSM) CALL SIGSSZ
      IF(GOMSSM) CALL SIGSSL
C
      RETURN
      END
CDECK  ID>, SIGSSZ. 
      SUBROUTINE SIGSSZ
C
C          Calculate d(sigma)/d(pt**2)d(y1)d(y2) for supersymmetric
C          zino or wino plus squark or gluino in MSSM using cross
C          sections from Baer, Karatas, and Tata, PR D42, 2259.
C          Also include wino and zino pairs.
C
C          SIGMA    = cross section summed over types allowed by
C                     JETTYPE cards.
C          SIGS(I)  = partial cross section for I1 + I2 --> I3 + I4
C          INOUT(I) = IOPAK**3*I4 + IOPAK**2*I3 + IOPAK*I2 +I1
C          JETTYP -> IDENT mapping:
C          GLSS, UPSSL, UBSSL, ..., UPSSR, UBSSR, ...,
C          W1SS+, W1SS-, WS22+, W2SS-, Z1SS, Z2SS, Z3SS, Z4SS
C
C          Extra factor of 1/2 needed for nonidentical final jets.
C          Y=-log(tan(theta/2)) gives jacobean P1*P2/E1*E2
C
C          Called from SIGSSY and so does not reinitialize /JETSIG/.
C
C          Ver 7.23: Add test setting SIG=0 for gaugino pairs if
C          ABS(ZZ)>0.999 and SIG<0.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
C
      REAL X(2)
      EQUIVALENCE (X(1),X1)
      COMPLEX AQZ(2,4),BQZ(2,4),AQW(2,2),WIJ
      EQUIVALENCE (S,SHAT),(T,THAT),(U,UHAT)
      INTEGER JS2JT(25),IW2JS(4),IW2IM(4),IZ2JS(4),IS2UD(25)
      SAVE JS2JT,IW2JS,IW2IM,IZ2JS,IS2UD
      INTEGER IDQSS(25),IDZSS(4),IDWSS(4)
      SAVE IDQSS,IDZSS,IDWSS
      INTEGER ITHZ(4),ITHW(2)
      REAL AMWISS(2)
      REAL XZIWJ(4,2),YZIWJ(4,2)
      REAL SIG,SIG0,CON,AMQIQ,S,T,U,AMWIW,FAC,AM22,AM12,TT,GP,G,
     $E1,E2,AMG,YM,XM,GS,THX,THY,AMZIZ,AMSQK
      INTEGER IX,JQ,IQ,IQ1,IQ2,JW,IW,JTYPW,IH,JTYPZ,IZ,ITHG,IWM
      COMPLEX ZONE,ZI
      SAVE ZONE,ZI
      REAL QFCN,STRUC,PSIFCN,AMASS
      REAL CON11,CON22,CON12,AMQIQ1,AMQIQ2
      INTEGER IX1,IX2
      REAL CS2THW,TNTHW,CTTHW,AL(2),BE(2),ESQ,XWI(2),YWI(2)
      REAL X12,Y12,SN12,AMWIW1,AMWIW2,EQ1,ZZ,XMGG,XMZZ
      REAL XMGZ,XMUU,XMGU,XMZU,XMDD,XMGD,XMZD,DEL,RSH,SR2
      REAL SIGUT,SIGTU,EHAT,PHAT,EBM,TPP,AMWI,AMQ,PROPW
      REAL SIGUT1,SIGUT2,SIGUT3,SGUT12,SGUT13,SGUT23
      REAL SIGTU1,SIGTU2,SIGTU3,SGTU12,SGTU13,SGTU23
      REAL AMSQL,AMSQR,KK,AMZIZ1,AMZIZ2
      REAL SIGLL,SIGRR,SIGZZ,SIGLZ,SIGRZ,SSGT,SSGST,PROPZ,SSXLAM
      INTEGER IZ1,JTYPZ1,IZ2,JTYPZ2
      INTEGER IW1,JW1,JTYPW1,IDW1,IW2,JW2,JTYPW2,IDW2,IFLQ,IUD(13)
C
C          IDENT codes from /SSTYPE/. (Fortran 77 allows - signs in
C          parameter statements but not data statements.)
      INTEGER MSUPL,MSDNL,MSSTL,MSCHL,MSBT1,MSTP1,
     $MSUPR,MSDNR,MSSTR,MSCHR,MSBT2,MSTP2,MSW1,MSW2
      PARAMETER (MSUPL=-ISUPL)
      PARAMETER (MSDNL=-ISDNL)
      PARAMETER (MSSTL=-ISSTL)
      PARAMETER (MSCHL=-ISCHL)
      PARAMETER (MSBT1=-ISBT1)
      PARAMETER (MSTP1=-ISTP1)
      PARAMETER (MSUPR=-ISUPR)
      PARAMETER (MSDNR=-ISDNR)
      PARAMETER (MSSTR=-ISSTR)
      PARAMETER (MSCHR=-ISCHR)
      PARAMETER (MSBT2=-ISBT2)
      PARAMETER (MSTP2=-ISTP2)
      PARAMETER (MSW1=-ISW1)
      PARAMETER (MSW2=-ISW2)
      DATA IDQSS/0,
     $ISUPL,MSUPL,ISDNL,MSDNL,ISSTL,MSSTL,ISCHL,MSCHL,ISBT1,MSBT1,
     $ISTP1,MSTP1,
     $ISUPR,MSUPR,ISDNR,MSDNR,ISSTR,MSSTR,ISCHR,MSCHR,ISBT2,MSBT2,
     $ISTP2,MSTP2/
      DATA IDZSS/ISZ1,ISZ2,ISZ3,ISZ4/
      DATA IDWSS/ISW1,MSW1,ISW2,MSW2/
      DATA IUD/0,1,-1,2,-2,2,-2,1,-1,2,-2,1,-1/
C
C          JS2JT: Susy jettype -> normal jettype
      DATA JS2JT/1,
     $2,3,4,5,6,7,8,9,10,11,12,13,2,3,4,5,6,7,8,9,10,11,12,13/
C          IW2JS: Wino index -> susy jettype
      DATA IW2JS/26,27,28,29/
C          IW2IM: Wino index -> match code
      DATA IW2IM/2,3,2,3/
C          IZ2JS: Zino index -> susy jettype
      DATA IZ2JS/30,31,32,33/
C          IS2UD: Susy jettype -> u/d code
      DATA IS2UD/0,1,1,2,2,2,2,1,1,2,2,1,1,1,1,2,2,2,2,1,1,2,2,1,1/
C
      DATA ZONE,ZI/(1.,0.),(0.,1.)/
C
C          Functions
      QFCN(IQ,IH)=STRUC(X(IH),QSQ,IQ,IDIN(IH))/X(IH)
      PSIFCN(AM12,AM22,TT)=((S+TT-AM12)/(2*S)
     $-AM12*(AM22-TT)/(AM12-TT)**2
     $+(TT*(AM22-AM12)+AM22*(S-AM22+AM12))/(S*(AM12-TT)))
C
C          Constants from Baer, Barger, Karatas, and Tata,
C          PR D36, 96, using results from SSMIX
C
      G=SQRT(4*PI*ALFAEM/SN2THW)
      GP=G*SQRT(SN2THW/(1.-SN2THW))
C     GS=SQRT(4.*PI*ALFA3)
      XM=1./TAN(GAMMAL)
      YM=1./TAN(GAMMAR)
      THX=SIGN(1.,XM)
      THY=SIGN(1.,YM)
      AMG=AMASS(ISGL)
      ITHG=+1
C          Signed masses
      AMWISS(1)=AMW1SS
      AMWISS(2)=AMW2SS
C          Zi couplings
      DO 100 IZ=1,4
        ITHZ(IZ)=0
        IF(AMZISS(IZ).LT.0) ITHZ(IZ)=1
        AQZ(1,IZ)=ZI**(ITHZ(IZ)-1)*(-ZONE)**(ITHZ(IZ)+1)
     $  *(+G/SQRT2*ZMIXSS(3,IZ)+GP/(3*SQRT2)*ZMIXSS(4,IZ))
        AQZ(2,IZ)=ZI**(ITHZ(IZ)-1)*(-ZONE)**(ITHZ(IZ)+1)
     $  *(-G/SQRT2*ZMIXSS(3,IZ)+GP/(3*SQRT2)*ZMIXSS(4,IZ))
        BQZ(1,IZ)=+(4./3.)*ZI**(ITHZ(IZ)-1)*GP/SQRT2*ZMIXSS(4,IZ)
        BQZ(2,IZ)=-(2./3.)*ZI**(ITHZ(IZ)-1)*GP/SQRT2*ZMIXSS(4,IZ)
100   CONTINUE
C          Wi couplings
      ITHW(1)=0
      IF(AMW1SS.LT.0.) ITHW(1)=1
      AQW(1,1)=ZI*G*SIN(GAMMAL)
      AQW(2,1)=ZI*G*(-ZONE)**ITHW(1)*SIN(GAMMAR)
      ITHW(2)=0
      IF(AMW2SS.LT.0.) ITHW(2)=1
      AQW(1,2)=ZI*G*THX*COS(GAMMAL)
      AQW(2,2)=ZI*G*(-ZONE)**ITHW(2)*THY*COS(GAMMAR)
C          Quark couplings to Z
      CS2THW=1.-SN2THW
      TNTHW=SQRT(SN2THW/CS2THW)
      CTTHW=1./TNTHW
      AL(1)=CTTHW/4.-5*TNTHW/12.
      AL(2)=TNTHW/12.-CTTHW/4.
      BE(1)=-(CTTHW+TNTHW)/4.
      BE(2)=-BE(1)
      ESQ=4*PI*ALFAEM
C           Chargino couplings to Z
      XWI(1)=1.-(COS(GAMMAL)**2+COS(GAMMAR)**2)/4./CS2THW
      XWI(2)=1.-(SIN(GAMMAL)**2+SIN(GAMMAR)**2)/4./CS2THW
      YWI(1)=(COS(GAMMAR)**2-COS(GAMMAL)**2)/4./CS2THW
      YWI(2)=(SIN(GAMMAR)**2-SIN(GAMMAL)**2)/4./CS2THW
      X12=.5*(THX*SIN(GAMMAL)*COS(GAMMAL)-
     $    THY*SIN(GAMMAR)*COS(GAMMAR))
      Y12=.5*(THX*SIN(GAMMAL)*COS(GAMMAL)+
     $    THY*SIN(GAMMAR)*COS(GAMMAR))
      SN12=-1.*SIGN(1.,AMW1SS)*SIGN(1.,AMW2SS)
C
C         qk qb --> ziss glss
C
      DO 200 IZ=1,4
        AMZIZ=ABS(AMZISS(IZ))
        JTYPZ=IZ2JS(IZ)
C          Jet 1 = ziss, jet 2 = glss
        IF(.NOT.(GOQ(JTYPZ,1).AND.GOQ(1,2))) GO TO 220
        CALL TWOKIN(0.,0.,AMZIZ,AMG)
        IF(X1.GE.1..OR.X2.GE.1.) GO TO 220
        GS=SQRT(4*PI*ALFQSQ)
        E1=SQRT(P(1)**2+AMZIZ**2)
        E2=SQRT(P(2)**2+AMG**2)
        FAC=1./(16.*PI*S**2)
        FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
C          Sum over initial quarks (no top quarks)
        DO 210 IQ=2,11
          IQ1=IQ
          IQ2=MATCH(IQ1,4)
          AMQIQ=AMASS(IDQSS(IQ))
          SIG0=(AMZIZ**2-T)*(AMG**2-T)/(AMQIQ**2-T)**2
     $    +(AMZIZ**2-U)*(AMG**2-U)/(AMQIQ**2-U)**2
     $    -2*(-1)**(ITHZ(IZ)+ITHG)*AMG*AMZIZ*S
     $    /((AMQIQ**2-T)*(AMQIQ**2-U))
          SIG0=SIG0*2*GS**2/9
          CON=AQZ(IS2UD(IQ),IZ)*CONJG(AQZ(IS2UD(IQ),IZ))
     $    +BQZ(IS2UD(IQ),IZ)*CONJG(BQZ(IS2UD(IQ),IZ))
          SIG=FAC*CON*SIG0*QFCN(IQ1,1)*QFCN(IQ2,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,IQ1,IQ2,JTYPZ,1)
210     CONTINUE
C          Jet 1 = glss, jet 2 = ziss
220     IF(.NOT.(GOQ(1,1).AND.GOQ(JTYPZ,2))) GO TO 200
        CALL TWOKIN(0.,0.,AMG,AMZIZ)
        IF(X1.GE.1..OR.X2.GE.1.) GO TO 200
        GS=SQRT(4*PI*ALFQSQ)
        E1=SQRT(P(1)**2+AMG**2)
        E2=SQRT(P(2)**2+AMZIZ**2)
        FAC=1./(16.*PI*S**2)
        FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
        DO 230 IQ=2,11
          IQ1=IQ
          IQ2=MATCH(IQ1,4)
          AMQIQ=AMASS(IDQSS(IQ))
          SIG0=(AMZIZ**2-T)*(AMG**2-T)/(AMQIQ**2-T)**2
     $    +(AMZIZ**2-U)*(AMG**2-U)/(AMQIQ**2-U)**2
     $    -2*(-1)**(ITHZ(IZ)+ITHG)*AMG*AMZIZ*S
     $    /((AMQIQ**2-T)*(AMQIQ**2-U))
          SIG0=SIG0*2*GS**2/9
          CON=AQZ(IS2UD(IQ),IZ)*CONJG(AQZ(IS2UD(IQ),IZ))
     $    +BQZ(IS2UD(IQ),IZ)*CONJG(BQZ(IS2UD(IQ),IZ))
          SIG=FAC*CON*SIG0*QFCN(IQ1,1)*QFCN(IQ2,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,IQ1,IQ2,1,JTYPZ)
230     CONTINUE
200   CONTINUE
C
C          qk gl -> ziss qkss
C
      DO 300 IZ=1,4
        AMZIZ=ABS(AMZISS(IZ))
        JTYPZ=IZ2JS(IZ)
        DO 310 IQ=2,25
          JQ=JS2JT(IQ)
          IF(IABS(JQ).GE.12) GO TO 310
          AMQIQ=AMASS(IDQSS(IQ))
C          Jet 1 = ziss, jet 2 = qkss
          IF(.NOT.(GOQ(JTYPZ,1).AND.GOQ(IQ,2))) GO TO 320
          CALL TWOKIN(0.,0.,AMZIZ,AMQIQ)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 320
          GS=SQRT(4*PI*ALFQSQ)
          E1=SQRT(P(1)**2+AMZIZ**2)
          E2=SQRT(P(2)**2+AMQIQ**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          IX=IS2UD(IQ)
C          Use AQZ for left squarks, BQZ for right
          IF(IQ.LE.13) THEN
            CON=AQZ(IX,IZ)*CONJG(AQZ(IX,IZ))
          ELSE
            CON=BQZ(IX,IZ)*CONJG(BQZ(IX,IZ))
          ENDIF
          SIG=GS**2/6*FAC*CON*PSIFCN(AMQIQ**2,AMZIZ**2,T)
     $    *QFCN(JQ,1)*QFCN(1,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,JQ,1,JTYPZ,IQ)
          SIG=GS**2/6*FAC*CON*PSIFCN(AMQIQ**2,AMZIZ**2,U)
     $    *QFCN(1,1)*QFCN(JQ,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,1,JQ,JTYPZ,IQ)
C          Jet 1 = qkss, jet 2 = ziss
320       IF(.NOT.(GOQ(IQ,1).AND.GOQ(JTYPZ,2))) GO TO 310
          CALL TWOKIN(0.,0.,AMQIQ,AMZIZ)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 310
          GS=SQRT(4*PI*ALFQSQ)
          E1=SQRT(P(1)**2+AMQIQ**2)
          E2=SQRT(P(2)**2+AMZIZ**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          IX=IS2UD(IQ)
C          Use AQZ for left squarks, BQZ for right
          IF(IQ.LE.13) THEN
            CON=AQZ(IX,IZ)*CONJG(AQZ(IX,IZ))
          ELSE
            CON=BQZ(IX,IZ)*CONJG(BQZ(IX,IZ))
          ENDIF
          SIG=GS**2/6*CON*FAC*PSIFCN(AMQIQ**2,AMZIZ**2,U)
     $    *QFCN(JQ,1)*QFCN(1,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,JQ,1,IQ,JTYPZ)
          SIG=GS**2/6*CON*FAC*PSIFCN(AMQIQ**2,AMZIZ**2,T)
     $    *QFCN(1,1)*QFCN(JQ,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,1,JQ,IQ,JTYPZ)
310     CONTINUE
300   CONTINUE
C
C          qk gl -> wiss qkss
C
      DO 400 IW=1,4
        JW=(IW+1)/2
        AMWIW=ABS(AMWISS(JW))
        JTYPW=IW2JS(IW)
        IWM=IW2IM(IW)
C          Left squarks only -
        DO 410 IQ=2,11
          AMQIQ=AMASS(IDQSS(IQ))
C          JQ is the matching incoming quark
          JQ=JS2JT(IQ)
          JQ=MATCH(JQ,4)
          JQ=MATCH(JQ,IWM)
          IF(JQ.EQ.0.OR.JQ.GE.12) GO TO 410
C          Jet 1 = wiss, jet 2 = qkss
          IF(.NOT.(GOQ(JTYPW,1).AND.GOQ(IQ,2))) GO TO 420
          CALL TWOKIN(0.,0.,AMWIW,AMQIQ)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 420
          GS=SQRT(4*PI*ALFQSQ)
          E1=SQRT(P(1)**2+AMWIW**2)
          E2=SQRT(P(2)**2+AMQIQ**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          IX=IS2UD(JQ)
          CON=AQW(IX,JW)*CONJG(AQW(IX,JW))
          SIG=GS**2/6*FAC*CON*PSIFCN(AMQIQ**2,AMWIW**2,T)
     $    *QFCN(JQ,1)*QFCN(1,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,JQ,1,JTYPW,IQ)
          SIG=GS**2/6*FAC*CON*PSIFCN(AMQIQ**2,AMWIW**2,U)
     $    *QFCN(1,1)*QFCN(JQ,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,1,JQ,JTYPW,IQ)
C          Jet 1 = qkss, jet 2 = wiss
420       IF(.NOT.(GOQ(IQ,1).AND.GOQ(JTYPW,2))) GO TO 410
          CALL TWOKIN(0.,0.,AMQIQ,AMWIW)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 410
          GS=SQRT(4*PI*ALFQSQ)
          E1=SQRT(P(1)**2+AMQIQ**2)
          E2=SQRT(P(2)**2+AMWIW**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          IX=IS2UD(JQ)
          CON=AQW(IX,JW)*CONJG(AQW(IX,JW))
          SIG=GS**2/6*FAC*CON*PSIFCN(AMQIQ**2,AMWIW**2,U)
     $    *QFCN(JQ,1)*QFCN(1,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,JQ,1,IQ,JTYPW)
          SIG=GS**2/6*FAC*CON*PSIFCN(AMQIQ**2,AMWIW**2,T)
     $    *QFCN(1,1)*QFCN(JQ,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,1,JQ,IQ,JTYPW)
410     CONTINUE
400   CONTINUE
C
C          qk qb -> wiss glss
C
      DO 500 IW=1,4
        JW=(IW+1)/2
        AMWIW=ABS(AMWISS(JW))
        JTYPW=IW2JS(IW)
        IWM=IW2IM(IW)
C          Jet 1 = wiss, jet 2 = glss
        IF(.NOT.(GOQ(JTYPW,1).AND.GOQ(1,2))) GO TO 520
        CALL TWOKIN(0.,0.,AMWIW,AMG)
        IF(X1.GE.1..OR.X2.GE.1.) GO TO 520
        GS=SQRT(4*PI*ALFQSQ)
        E1=SQRT(P(1)**2+AMWIW**2)
        E2=SQRT(P(2)**2+AMG**2)
        FAC=1./(16.*PI*S**2)
        FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
C          Loop over quarks (no top quarks)
        DO 510 IQ=2,11
          IQ1=IQ
          IQ2=MATCH(IQ1,IWM)
          IF(IQ2.EQ.0.OR.IQ2.GE.12) GO TO 510
          AMQIQ1=AMASS(IDQSS(IQ1))
          IX1=IS2UD(IQ1)
          AMQIQ2=AMASS(IDQSS(IQ2))
          IX2=IS2UD(IQ2)
          CON11=AQW(IX1,JW)*CONJG(AQW(IX1,JW))
          CON22=AQW(IX2,JW)*CONJG(AQW(IX2,JW))
          CON12=2*(-1)**ITHG*REAL(AQW(IX1,JW)*AQW(IX2,JW))
          SIG=CON11*(AMWIW**2-T)*(AMG**2-T)/(AMQIQ2**2-T)**2
     $    +CON22*(AMWIW**2-U)*(AMG**2-U)/(AMQIQ1**2-U)**2
     $    +CON12*AMG*AMWIW*S/((AMQIQ2**2-T)*(AMQIQ1**2-U))
          SIG=2*GS**2/9*SIG*FAC*QFCN(IQ1,1)*QFCN(IQ2,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,IQ1,IQ2,JTYPW,1)
C          No interchange needed here
510     CONTINUE
C          Jet 1 = glss, jet 2 = wiss
520     IF(.NOT.(GOQ(1,1).AND.GOQ(JTYPW,2))) GO TO 500
        CALL TWOKIN(0.,0.,AMG,AMWIW)
        IF(X1.GE.1..OR.X2.GE.1.) GO TO 500
        GS=SQRT(4*PI*ALFQSQ)
        E1=SQRT(P(1)**2+AMG**2)
        E2=SQRT(P(2)**2+AMWIW**2)
        FAC=1./(16.*PI*S**2)
        FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
C          Loop over quarks (no top quarks)
        DO 530 IQ=2,11
          IQ1=IQ
          IQ2=MATCH(IQ1,IWM)
          IF(IQ2.EQ.0.OR.IQ2.GE.12) GO TO 530
          AMQIQ1=AMASS(IDQSS(IQ1))
          IX1=IS2UD(IQ1)
          AMQIQ2=AMASS(IDQSS(IQ2))
          IX2=IS2UD(IQ2)
          CON11=AQW(IX1,JW)*CONJG(AQW(IX1,JW))
          CON22=AQW(IX2,JW)*CONJG(AQW(IX2,JW))
          CON12=2*(-1)**ITHG*REAL(AQW(IX1,JW)*AQW(IX2,JW))
          SIG=CON11*(AMWIW**2-U)*(AMG**2-U)/(AMQIQ2**2-U)**2
     $    +CON22*(AMWIW**2-T)*(AMG**2-T)/(AMQIQ1**2-T)**2
     $    +CON12*AMG*AMWIW*S/((AMQIQ2**2-U)*(AMQIQ1**2-T))
          SIG=2*GS**2/9*SIG*FAC*QFCN(IQ1,1)*QFCN(IQ2,2)
          SIG=.5*SIG
          CALL SIGFIL(SIG,IQ1,IQ2,1,JTYPW)
C       NO INTERCHANGE NEEDED HERE
530     CONTINUE
500   CONTINUE
C
C          Gaugino pair production. The W,Z poles are assumed
C          to be outside the physical region.
C          Constants from SSWZBF:
C
      SR2=SQRT(2.)
      DO 601 IZ=1,4
        XZIWJ(IZ,1)=.5*(SIGN(1.,AMWISS(1))*SIGN(1.,AMZISS(IZ))
     $  *(COS(GAMMAR)*ZMIXSS(1,IZ)/SR2+SIN(GAMMAR)*ZMIXSS(3,IZ))
     $  -COS(GAMMAL)*ZMIXSS(2,IZ)/SR2+SIN(GAMMAL)*ZMIXSS(3,IZ))
        YZIWJ(IZ,1)=.5*(-SIGN(1.,AMWISS(1))*SIGN(1.,AMZISS(IZ))
     $  *(COS(GAMMAR)*ZMIXSS(1,IZ)/SR2+SIN(GAMMAR)*ZMIXSS(3,IZ))
     $  -COS(GAMMAL)*ZMIXSS(2,IZ)/SR2+SIN(GAMMAL)*ZMIXSS(3,IZ))
        XZIWJ(IZ,2)=.5*(SIGN(1.,AMWISS(2))*SIGN(1.,AMZISS(IZ))*THY
     $  *(-SIN(GAMMAR)*ZMIXSS(1,IZ)/SR2+COS(GAMMAR)*ZMIXSS(3,IZ))
     $  +THX*(SIN(GAMMAL)*ZMIXSS(2,IZ)/SR2+COS(GAMMAL)*ZMIXSS(3,IZ)))
        YZIWJ(IZ,2)=.5*(-SIGN(1.,AMWISS(2))*SIGN(1.,AMZISS(IZ))
     $  *THY*(-SIN(GAMMAR)*ZMIXSS(1,IZ)/SR2+COS(GAMMAR)*ZMIXSS(3,IZ))
     $  +THX*(SIN(GAMMAL)*ZMIXSS(2,IZ)/SR2+COS(GAMMAL)*ZMIXSS(3,IZ)))
601   CONTINUE
C
C          Zino + wino: W* and squark graphs included
C
      DO 610 IW=1,4
        JW=(IW+1)/2
        AMWIW=ABS(AMWISS(JW))
        JTYPW=IW2JS(IW)
        IWM=IW2IM(IW)
        DO 620 IZ=1,4
          AMZIZ=ABS(AMZISS(IZ))
          JTYPZ=IZ2JS(IZ)
          AMQ=AMASS(IDQSS(2))
C          Jet 1 = wiss, jet 2 = zjss
          IF(.NOT.(GOQ(JTYPW,1).AND.GOQ(JTYPZ,2))) GO TO 630
          CALL TWOKIN(0.,0.,AMWIW,AMZIZ)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 630
          E1=SQRT(P(1)**2+AMWIW**2)
          E2=SQRT(P(2)**2+AMZIZ**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
C          Loop over quarks (no top quarks)
          SIGUT1=(XZIWJ(IZ,JW)**2+YZIWJ(IZ,JW)**2)
     $    *((AMWIW**2-U)*(AMZIZ**2-U)+(AMWIW**2-T)*(AMZIZ**2-T))/4.
     $    +2*XZIWJ(IZ,JW)*YZIWJ(IZ,JW)
     $    *((AMWIW**2-U)*(AMZIZ**2-U)-(AMWIW**2-T)*(AMZIZ**2-T))/4.
     $    +AMWIW*AMZIZ*(XZIWJ(IZ,JW)**2-YZIWJ(IZ,JW)**2)*S/2.
          PROPW=(S-AMW**2)**2+AMW**2*GAMW**2
          SIGUT1=2*G**4/3./PROPW*SIGUT1
          SIGUT2=(AQZ(2,IZ)*CONJG(AQZ(2,IZ)))*
     $    (AQW(1,JW)*CONJG(AQW(1,JW)))
     $    *(AMWIW**2-U)*(AMZIZ**2-U)/4./3./(U-AMQ**2)**2
          SIGUT3=(AQZ(1,IZ)*CONJG(AQZ(1,IZ)))*
     $    (AQW(2,JW)*CONJG(AQW(2,JW)))
     $    *(AMWIW**2-T)*(AMZIZ**2-T)/4./3./(T-AMQ**2)**2
          SGUT12=-G**2*SR2*(S-AMW**2)/PROPW/(U-AMQ**2)/12.*
     $    REAL(CONJG(AQZ(2,IZ))*AQW(1,JW)*(-ZI)**(ITHZ(IZ)))*
     $    (8*(XZIWJ(IZ,JW)+YZIWJ(IZ,JW))*(AMZIZ**2-U)*(AMWIW**2-U)/4.
     $    +4*(XZIWJ(IZ,JW)-YZIWJ(IZ,JW))*AMWIW*AMZIZ*S/2.)
          SGUT13=G**2*SR2*(S-AMW**2)/PROPW/(T-AMQ**2)/12.*
     $    REAL(CONJG(AQW(2,JW))*AQZ(1,IZ)*(-ZI)**(ITHZ(IZ)))*
     $    (8*(XZIWJ(IZ,JW)-YZIWJ(IZ,JW))*(AMZIZ**2-T)*(AMWIW**2-T)/4.
     $    +4*(XZIWJ(IZ,JW)+YZIWJ(IZ,JW))*AMWIW*AMZIZ*S/2.)
          SGUT23=-4*AMWIW*AMZIZ*S/2./(U-AMQ**2)/(T-AMQ**2)/12.*
     $    REAL(AQZ(1,IZ)*AQZ(2,IZ)*CONJG(AQW(1,JW)*AQW(2,JW)))
          SIGUT=SIGUT1+SIGUT2+SIGUT3+SGUT12+SGUT13+SGUT23
C
          SIGTU1=(XZIWJ(IZ,JW)**2+YZIWJ(IZ,JW)**2)
     $    *((AMWIW**2-T)*(AMZIZ**2-T)+(AMWIW**2-U)*(AMZIZ**2-U))/4.
     $    +2*XZIWJ(IZ,JW)*YZIWJ(IZ,JW)
     $    *((AMWIW**2-T)*(AMZIZ**2-T)-(AMWIW**2-U)*(AMZIZ**2-U))/4.
     $    +AMWIW*AMZIZ*(XZIWJ(IZ,JW)**2-YZIWJ(IZ,JW)**2)*S/2.
          SIGTU1=2*G**4/3./PROPW*SIGTU1
          SIGTU2=(AQZ(2,IZ)*CONJG(AQZ(2,IZ)))*
     $    (AQW(1,JW)*CONJG(AQW(1,JW)))
     $    *(AMWIW**2-T)*(AMZIZ**2-T)/4./3./(T-AMQ**2)**2
          SIGTU3=(AQZ(1,IZ)*CONJG(AQZ(1,IZ)))*
     $    (AQW(2,JW)*CONJG(AQW(2,JW)))
     $    *(AMWIW**2-U)*(AMZIZ**2-U)/4./3./(U-AMQ**2)**2
          SGTU12=-G**2*SR2*(S-AMW**2)/PROPW/(T-AMQ**2)/12.*
     $    REAL(CONJG(AQZ(2,IZ))*AQW(1,JW)*(-ZI)**(ITHZ(IZ)))*
     $    (8*(XZIWJ(IZ,JW)+YZIWJ(IZ,JW))*(AMZIZ**2-T)*(AMWIW**2-T)/4.
     $    +4*(XZIWJ(IZ,JW)-YZIWJ(IZ,JW))*AMWIW*AMZIZ*S/2.)
          SGTU13=G**2*SR2*(S-AMW**2)/PROPW/(U-AMQ**2)/12.*
     $    REAL(CONJG(AQW(2,JW))*AQZ(1,IZ)*(-ZI)**(ITHZ(IZ)))*
     $    (8*(XZIWJ(IZ,JW)-YZIWJ(IZ,JW))*(AMZIZ**2-U)*(AMWIW**2-U)/4.
     $    +4*(XZIWJ(IZ,JW)+YZIWJ(IZ,JW))*AMWIW*AMZIZ*S/2.)
          SGTU23=-4*AMWIW*AMZIZ*S/2./(T-AMQ**2)/(U-AMQ**2)/12.*
     $    REAL(AQZ(1,IZ)*AQZ(2,IZ)*CONJG(AQW(1,JW)*AQW(2,JW)))
          SIGTU=SIGTU1+SIGTU2+SIGTU3+SGTU12+SGTU13+SGTU23
          IF (IWM.EQ.2) THEN
            SIG=.5*SIGUT*FAC*QFCN(5,1)*QFCN(2,2)
            CALL SIGFIL(SIG,5,2,JTYPW,JTYPZ)
            SIG=.5*SIGUT*FAC*QFCN(8,1)*QFCN(7,2)
            CALL SIGFIL(SIG,8,7,JTYPW,JTYPZ)
            SIG=.5*SIGTU*FAC*QFCN(2,1)*QFCN(5,2)
            CALL SIGFIL(SIG,2,5,JTYPW,JTYPZ)
            SIG=.5*SIGTU*FAC*QFCN(7,1)*QFCN(8,2)
            CALL SIGFIL(SIG,7,8,JTYPW,JTYPZ)
          ELSE
            SIG=.5*SIGUT*FAC*QFCN(4,1)*QFCN(3,2)
            CALL SIGFIL(SIG,4,3,JTYPW,JTYPZ)
            SIG=.5*SIGUT*FAC*QFCN(6,1)*QFCN(9,2)
            CALL SIGFIL(SIG,6,9,JTYPW,JTYPZ)
            SIG=.5*SIGTU*FAC*QFCN(3,1)*QFCN(4,2)
            CALL SIGFIL(SIG,3,4,JTYPW,JTYPZ)
            SIG=.5*SIGTU*FAC*QFCN(9,1)*QFCN(6,2)
            CALL SIGFIL(SIG,9,6,JTYPW,JTYPZ)
          END IF
C          Jet 1 = zjss, jet 2 = wiss
630       IF(.NOT.(GOQ(JTYPZ,1).AND.GOQ(JTYPW,2))) GO TO 620
          CALL TWOKIN(0.,0.,AMZIZ,AMWIW)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 610
          E1=SQRT(P(1)**2+AMZIZ**2)
          E2=SQRT(P(2)**2+AMWIW**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
C          Loop over quarks (no top quarks)
          SIGUT1=(XZIWJ(IZ,JW)**2+YZIWJ(IZ,JW)**2)
     $    *((AMWIW**2-U)*(AMZIZ**2-U)+(AMWIW**2-T)*(AMZIZ**2-T))/4.
     $    +2*XZIWJ(IZ,JW)*YZIWJ(IZ,JW)
     $    *((AMWIW**2-U)*(AMZIZ**2-U)-(AMWIW**2-T)*(AMZIZ**2-T))/4.
     $    +AMWIW*AMZIZ*(XZIWJ(IZ,JW)**2-YZIWJ(IZ,JW)**2)*S/2.
          PROPW=(S-AMW**2)**2+AMW**2*GAMW**2
          SIGUT1=2*G**4/3./PROPW*SIGUT1
          SIGUT2=(AQZ(2,IZ)*CONJG(AQZ(2,IZ)))*
     $    (AQW(1,JW)*CONJG(AQW(1,JW)))
     $    *(AMWIW**2-U)*(AMZIZ**2-U)/4./3./(U-AMQ**2)**2
          SIGUT3=(AQZ(1,IZ)*CONJG(AQZ(1,IZ)))*
     $    (AQW(2,JW)*CONJG(AQW(2,JW)))
     $    *(AMWIW**2-T)*(AMZIZ**2-T)/4./3./(T-AMQ**2)**2
          SGUT12=-G**2*SR2*(S-AMW**2)/PROPW/(U-AMQ**2)/12.*
     $    REAL(CONJG(AQZ(2,IZ))*AQW(1,JW)*(-ZI)**(ITHZ(IZ)))*
     $    (8*(XZIWJ(IZ,JW)+YZIWJ(IZ,JW))*(AMZIZ**2-U)*(AMWIW**2-U)/4.
     $    +4*(XZIWJ(IZ,JW)-YZIWJ(IZ,JW))*AMWIW*AMZIZ*S/2.)
          SGUT13=G**2*SR2*(S-AMW**2)/PROPW/(T-AMQ**2)/12.*
     $    REAL(CONJG(AQW(2,JW))*AQZ(1,IZ)*(-ZI)**(ITHZ(IZ)))*
     $    (8*(XZIWJ(IZ,JW)-YZIWJ(IZ,JW))*(AMZIZ**2-T)*(AMWIW**2-T)/4.
     $    +4*(XZIWJ(IZ,JW)+YZIWJ(IZ,JW))*AMWIW*AMZIZ*S/2.)
          SGUT23=-4*AMWIW*AMZIZ*S/2./(U-AMQ**2)/(T-AMQ**2)/12.*
     $    REAL(AQZ(1,IZ)*AQZ(2,IZ)*CONJG(AQW(1,JW)*AQW(2,JW)))
          SIGUT=SIGUT1+SIGUT2+SIGUT3+SGUT12+SGUT13+SGUT23
C
          SIGTU1=(XZIWJ(IZ,JW)**2+YZIWJ(IZ,JW)**2)
     $    *((AMWIW**2-T)*(AMZIZ**2-T)+(AMWIW**2-U)*(AMZIZ**2-U))/4.
     $    +2*XZIWJ(IZ,JW)*YZIWJ(IZ,JW)
     $    *((AMWIW**2-T)*(AMZIZ**2-T)-(AMWIW**2-U)*(AMZIZ**2-U))/4.
     $    +AMWIW*AMZIZ*(XZIWJ(IZ,JW)**2-YZIWJ(IZ,JW)**2)*S/2.
          SIGTU1=2*G**4/3./PROPW*SIGTU1
          SIGTU2=(AQZ(2,IZ)*CONJG(AQZ(2,IZ)))*
     $    (AQW(1,JW)*CONJG(AQW(1,JW)))
     $    *(AMWIW**2-T)*(AMZIZ**2-T)/4./3./(T-AMQ**2)**2
          SIGTU3=(AQZ(1,IZ)*CONJG(AQZ(1,IZ)))*
     $    (AQW(2,JW)*CONJG(AQW(2,JW)))
     $    *(AMWIW**2-U)*(AMZIZ**2-U)/4./3./(U-AMQ**2)**2
          SGTU12=-G**2*SR2*(S-AMW**2)/PROPW/(T-AMQ**2)/12.*
     $    REAL(CONJG(AQZ(2,IZ))*AQW(1,JW)*(-ZI)**(ITHZ(IZ)))*
     $    (8*(XZIWJ(IZ,JW)+YZIWJ(IZ,JW))*(AMZIZ**2-T)*(AMWIW**2-T)/4.
     $    +4*(XZIWJ(IZ,JW)-YZIWJ(IZ,JW))*AMWIW*AMZIZ*S/2.)
          SGTU13=G**2*SR2*(S-AMW**2)/PROPW/(U-AMQ**2)/12.*
     $    REAL(CONJG(AQW(2,JW))*AQZ(1,IZ)*(-ZI)**(ITHZ(IZ)))*
     $    (8*(XZIWJ(IZ,JW)-YZIWJ(IZ,JW))*(AMZIZ**2-U)*(AMWIW**2-U)/4.
     $    +4*(XZIWJ(IZ,JW)+YZIWJ(IZ,JW))*AMWIW*AMZIZ*S/2.)
          SGTU23=-4*AMWIW*AMZIZ*S/2./(T-AMQ**2)/(U-AMQ**2)/12.*
     $    REAL(AQZ(1,IZ)*AQZ(2,IZ)*CONJG(AQW(1,JW)*AQW(2,JW)))
          SIGTU=SIGTU1+SIGTU2+SIGTU3+SGTU12+SGTU13+SGTU23
          IF (IWM.EQ.2) THEN
            SIG=.5*SIGTU*FAC*QFCN(5,1)*QFCN(2,2)
            CALL SIGFIL(SIG,5,2,JTYPW,JTYPZ)
            SIG=.5*SIGTU*FAC*QFCN(8,1)*QFCN(7,2)
            CALL SIGFIL(SIG,8,7,JTYPW,JTYPZ)
            SIG=.5*SIGUT*FAC*QFCN(2,1)*QFCN(5,2)
            CALL SIGFIL(SIG,2,5,JTYPW,JTYPZ)
            SIG=.5*SIGUT*FAC*QFCN(7,1)*QFCN(8,2)
            CALL SIGFIL(SIG,7,8,JTYPW,JTYPZ)
          ELSE
            SIG=.5*SIGTU*FAC*QFCN(4,1)*QFCN(3,2)
            CALL SIGFIL(SIG,4,3,JTYPW,JTYPZ)
            SIG=.5*SIGTU*FAC*QFCN(6,1)*QFCN(9,2)
            CALL SIGFIL(SIG,6,9,JTYPW,JTYPZ)
            SIG=.5*SIGUT*FAC*QFCN(3,1)*QFCN(4,2)
            CALL SIGFIL(SIG,3,4,JTYPW,JTYPZ)
            SIG=.5*SIGUT*FAC*QFCN(9,1)*QFCN(6,2)
            CALL SIGFIL(SIG,9,6,JTYPW,JTYPZ)
          END IF
620     CONTINUE
610   CONTINUE
C
C          Chargino pair production
C          added squark exchange contribution 7/11/97
C
      DO 700 IW1=1,4
        JW1=(IW1+1)/2
        AMWIW1=ABS(AMWISS(JW1))
        JTYPW1=IW2JS(IW1)
        IDW1=IDWSS(IW1)
        DO 710 IW2=1,4
          JW2=(IW2+1)/2
          AMWIW2=ABS(AMWISS(JW2))
          JTYPW2=IW2JS(IW2)
          IDW2=IDWSS(IW2)
          IF (.NOT.(GOQ(JTYPW1,1).AND.GOQ(JTYPW2,2))) GO TO 710
          CALL TWOKIN(0.,0.,AMWIW1,AMWIW2)
          IF (X1.GE.1..OR.X2.GE.1.) GO TO 710
          E1=SQRT(P(1)**2+AMWIW1**2)
          E2=SQRT(P(2)**2+AMWIW2**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          DO 720 IQ1=2,11
            IFLQ=IS2UD(IQ1)
            IF (IFLQ.EQ.1) THEN
              EQ1=2./3.
            ELSE
              EQ1=-1./3.
            END IF
            IQ2=MATCH(IQ1,4)
            IF (IQ1.EQ.2.OR.IQ1.EQ.3) AMSQK=AMDLSS
            IF (IQ1.EQ.4.OR.IQ1.EQ.5) AMSQK=AMULSS
            IF (IQ1.EQ.6.OR.IQ1.EQ.7) AMSQK=AMCLSS
            IF (IQ1.EQ.8.OR.IQ1.EQ.9) AMSQK=AMSLSS
            IF (IQ1.EQ.10.OR.IQ1.EQ.11) AMSQK=AMB1SS
            IF (IQ2.EQ.0.OR.IQ2.GE.12) GO TO 720
            IF (IDW1.EQ.-IDW2) THEN
C          Convert ISAJET t_hat to particle-particle t_hat
              IF (IUD(IQ1)*IDW1.GT.0) THEN
                TPP=U
              ELSE
                TPP=T
              END IF
              ZZ=(2*TPP-2*AMWIW1**2+S)/SQRT(S*S-4*S*AMWIW1**2)
              EHAT=SQRT(S)/2.
              PHAT=SQRT(EHAT**2-AMWIW1**2)
              XMGG=16.*ESQ*ESQ*(EHAT**2*(1.+ZZ**2)+
     $        AMWIW1**2*(1.-ZZ**2))/S*EQ1**2
              XMZZ=16*ESQ*ESQ*CTTHW**2*S/((S-AMZ**2)**2+
     $        (GAMZ*AMZ)**2)*((XWI(JW1)**2+YWI(JW1)**2)*
     $        (AL(IFLQ)**2+BE(IFLQ)**2)*
     $        (EHAT**2*(1.+ZZ**2)+AMWIW1**2*(1.-ZZ**2))-2.*
     $        YWI(JW1)**2*(AL(IFLQ)**2+
     $        BE(IFLQ)**2)*AMWIW1**2-8*XWI(JW1)*YWI(JW1)*
     $        AL(IFLQ)*BE(IFLQ)*EHAT*PHAT*ZZ)
              XMGZ=(-EQ1)*(-32.)*ESQ*ESQ*CTTHW*(S-AMZ**2)/
     $        ((S-AMZ**2)**2+(GAMZ*AMZ)**2)*
     $        (AL(IFLQ)*XWI(JW1)*(EHAT**2*
     $        (1.+ZZ**2)+AMWIW1**2*(1.-ZZ**2))-2*
     $        BE(IFLQ)*YWI(JW1)*EHAT*PHAT*ZZ)
              XMUU=ESQ*ESQ*SIN(GAMMAR)**4*S*(EHAT-PHAT*ZZ)**2/
     $         SN2THW**2/(EHAT**2+PHAT**2-2*EHAT*PHAT*ZZ+
     $         AMSQK**2)**2
              XMGU=EQ1*4*ESQ*ESQ*SIN(GAMMAR)**2*
     $         ((EHAT-PHAT*ZZ)**2+AMWIW1**2)/SN2THW/
     $         (EHAT**2+PHAT**2-2*EHAT*PHAT*ZZ+AMSQK**2)
              XMZU=4*ESQ*ESQ*CTTHW*SIN(GAMMAR)**2*(S-AMZ**2)
     $         *(AL(IFLQ)-BE(IFLQ))*S/SN2THW/((S-AMZ**2)**2+
     $         (GAMZ*AMZ)**2)*((XWI(JW1)-YWI(JW1))*
     $         ((EHAT-PHAT*ZZ)**2+AMWIW1**2)+2*YWI(JW1)*
     $         AMWIW1**2)/(EHAT**2+PHAT**2-2*EHAT*PHAT*ZZ+
     $         AMSQK**2)
              XMDD=ESQ*ESQ*SIN(GAMMAL)**4*S*(EHAT-PHAT*ZZ)**2/
     $         SN2THW**2/(EHAT**2+PHAT**2-2*EHAT*PHAT*ZZ+
     $         AMSQK**2)**2
              XMGD=EQ1*4*ESQ*ESQ*SIN(GAMMAL)**2*
     $         ((EHAT-PHAT*ZZ)**2+AMWIW1**2)/SN2THW/
     $         (EHAT**2+PHAT**2-2*EHAT*PHAT*ZZ+AMSQK**2)
              XMZD=4*ESQ*ESQ*CTTHW*SIN(GAMMAL)**2*(S-AMZ**2)
     $         *(AL(IFLQ)-BE(IFLQ))*S/SN2THW/((S-AMZ**2)**2+
     $         (GAMZ*AMZ)**2)*((XWI(JW1)-YWI(JW1))*
     $         ((EHAT-PHAT*ZZ)**2+AMWIW1**2)+2*YWI(JW1)*
     $         AMWIW1**2)/(EHAT**2+PHAT**2-2*EHAT*PHAT*ZZ+
     $         AMSQK**2)
              IF (IFLQ.EQ.1) THEN
               SIG=(XMGG+XMZZ+XMGZ+XMDD+XMGD+XMZD)/12.
              ELSE
               SIG=(XMGG+XMZZ+XMGZ+XMUU+XMGU+XMZU)/12.
              END IF
              SIG=SIG*FAC*QFCN(IQ1,1)*QFCN(IQ2,2)
              SIG=.5*SIG
              IF(SIG.LT.0.AND.ABS(ZZ).GT.0.999) SIG=0
              CALL SIGFIL(SIG,IQ1,IQ2,JTYPW1,JTYPW2)
            ELSEIF (IDW1*IDW2.LT.0) THEN
              PHAT=SQRT(S*S+AMWIW1**4+AMWIW2**4-2*S*AMWIW1**2
     $        -2*S*AMWIW2**2-2*AMWIW1**2*AMWIW2**2)/2./SQRT(S)
              IF (IUD(IQ1)*IDW1.GT.0) THEN
                TPP=U
              ELSE
                TPP=T
              END IF
              IF (IDW1.LT.0) THEN
                AMWI=AMWIW1
              ELSE
                AMWI=AMWIW2
              END IF
              EHAT=SQRT(PHAT**2+AMWI**2)
              EBM=SQRT(S)/2.
              ZZ=(TPP-AMWI**2+SQRT(S)*EHAT)/SQRT(S)/PHAT
              DEL=(AMW2SS**2-AMW1SS**2)/4./EBM
              XMZZ=4*(CTTHW+TNTHW)**2/((S-AMZ**2)**2+
     $        (GAMZ*AMZ)**2)*((X12**2+Y12**2)*
     $        (AL(IFLQ)**2+BE(IFLQ)**2)*
     $        (EBM**2+PHAT**2*ZZ**2-DEL**2-SN12*AMWIW1*AMWIW2)+
     $        2*X12**2*SN12*(AL(IFLQ)**2+ BE(IFLQ)**2)*AMWIW1*
     $        AMWIW2-8*X12*Y12*AL(IFLQ)*BE(IFLQ)*EBM*PHAT*ZZ)
              XMUU=SIN(GAMMAR)**2*COS(GAMMAR)**2*((EBM-PHAT*ZZ)
     $         **2-DEL**2)/SN2THW**2/(2*EBM*(EBM-DEL)-2*EBM*PHAT*
     $         ZZ+AMSQK**2-AMW1SS**2)**2
              XMZU=-2*THY*(CTTHW+TNTHW)*SIN(GAMMAR)*COS(GAMMAR)*
     $         (S-AMZ**2)*(AL(IFLQ)-BE(IFLQ))/SN2THW/((S-AMZ**2)
     $         **2+(GAMZ*AMZ)**2)*((X12-Y12)*((EBM-PHAT*ZZ)**2-
     $         DEL**2-SN12*AMWIW1*AMWIW2)+2*X12*SN12*AMWIW1*
     $         AMWIW2)/(2*EBM*(EBM-DEL)-2*EBM*PHAT*ZZ+AMSQK**2
     $         -AMW1SS**2)
              XMDD=SIN(GAMMAL)**2*COS(GAMMAL)**2*((EBM+PHAT*ZZ)
     $         **2-DEL**2)/SN2THW**2/(2*EBM*(EBM-DEL)+2*EBM*PHAT*
     $         ZZ+AMSQK**2-AMW1SS**2)**2
              XMZD=-2*THX*(CTTHW+TNTHW)*SIN(GAMMAL)*COS(GAMMAL)*
     $         (S-AMZ**2)*(AL(IFLQ)-BE(IFLQ))/SN2THW/((S-AMZ**2)
     $         **2+(GAMZ*AMZ)**2)*((X12+Y12)*((EBM+PHAT*ZZ)**2-
     $         DEL**2+SN12*AMWIW1*AMWIW2)-2*Y12*SN12*AMWIW1*
     $         AMWIW2)/(2*EBM*(EBM-DEL)+2*EBM*PHAT*ZZ+AMSQK**2
     $         -AMW1SS**2)
              IF (IFLQ.EQ.1) THEN
               SIG=ESQ*ESQ*(XMZZ+XMDD+XMZD)*S/12.
              ELSE
               SIG=ESQ*ESQ*(XMZZ+XMUU+XMZU)*S/12.
              END IF
              SIG=SIG*FAC*QFCN(IQ1,1)*QFCN(IQ2,2)
              SIG=.5*SIG
              CALL SIGFIL(SIG,IQ1,IQ2,JTYPW1,JTYPW2)
            END IF
720       CONTINUE
710     CONTINUE
700   CONTINUE
C
C         qk qb --> ziss zjss
C
      DO 800 IZ1=1,4
        AMZIZ1=ABS(AMZISS(IZ1))
        JTYPZ1=IZ2JS(IZ1)
        DO 810 IZ2=1,4
          AMZIZ2=ABS(AMZISS(IZ2))
          JTYPZ2=IZ2JS(IZ2)
          IF(.NOT.(GOQ(JTYPZ1,1).AND.GOQ(JTYPZ2,2))) GO TO 810
          CALL TWOKIN(0.,0.,AMZIZ1,AMZIZ2)
          IF(X1.GE.1..OR.X2.GE.1.) GO TO 810
          E1=SQRT(P(1)**2+AMZIZ1**2)
          E2=SQRT(P(2)**2+AMZIZ2**2)
          FAC=1./(16.*PI*S**2)
          FAC=FAC*S/SCM*(P(1)*P(2)/(E1*E2))*UNITS
          WIJ=SQRT(G**2+GP**2)*ZI**(ITHZ(IZ2))*(-ZI)**(ITHZ(IZ1))*
     $    (ZMIXSS(1,IZ1)*ZMIXSS(1,IZ2)-ZMIXSS(2,IZ1)*
     $    ZMIXSS(2,IZ2))/4.
          RSH=SQRT(S)
          PROPZ=(S-AMZ**2)**2+AMZ**2*GAMZ**2
          KK=SQRT(S*S+(AMZIZ1**2-AMZIZ2**2)**2-2*S*
     $    (AMZIZ1**2+AMZIZ2**2))/2./RSH
C          Sum over initial quarks (no top quarks)
          DO 820 IQ=2,11
            IQ1=IQ
            IQ2=MATCH(IQ1,4)
            AMSQL=AMASS(IDQSS(IQ))
            AMSQR=AMASS(IDQSS(IQ+12))
            PHAT=SQRT(SSXLAM(S,AMZIZ1**2,AMZIZ2**2))/2./RSH
            EHAT=SQRT(PHAT**2+AMZIZ1**2)
            ZZ=(T-AMZIZ1**2+RSH*EHAT)/RSH/PHAT
            IF (IUD(IQ).LT.0) ZZ=-ZZ
            IFLQ=IS2UD(IQ)
            SIGLL=AQZ(IFLQ,IZ1)*CONJG(AQZ(IFLQ,IZ1))*AQZ(IFLQ,IZ2)*
     $      CONJG(AQZ(IFLQ,IZ2))*SSGT(S,AMSQL,ZZ,IZ1,IZ2)
            SIGRR=BQZ(IFLQ,IZ1)*CONJG(BQZ(IFLQ,IZ1))*BQZ(IFLQ,IZ2)*
     $      CONJG(BQZ(IFLQ,IZ2))*SSGT(S,AMSQR,ZZ,IZ1,IZ2)
            SIGZZ=4*ESQ*WIJ*CONJG(WIJ)*(AL(IFLQ)**2+BE(IFLQ)**2)*
     $      (S*S-(AMZIZ1**2-AMZIZ2**2)**2+4*(-1.)**(ITHZ(IZ1)+
     $      ITHZ(IZ2)+1)*S*AMZIZ1*AMZIZ2+4*S*KK*KK*ZZ*ZZ)/PROPZ
            SIGLZ=-SQRT(ESQ)*(AL(IFLQ)-BE(IFLQ))*(S-AMZ**2)/2./
     $      PROPZ*(REAL(WIJ*CONJG(AQZ(IFLQ,IZ1))*AQZ(IFLQ,IZ2))*
     $      SSGST(S,AMSQL,ZZ,IZ1,IZ2)+(-1.)**(ITHZ(IZ1)+ITHZ(IZ2))*
     $      REAL(WIJ*AQZ(IFLQ,IZ1)*CONJG(AQZ(IFLQ,IZ2)))*
     $      SSGST(S,AMSQL,-ZZ,IZ1,IZ2))
            SIGRZ=-SQRT(ESQ)*(-1.)**(ITHZ(IZ1)+ITHZ(IZ2)+1)*
     $      (AL(IFLQ)+BE(IFLQ))*(S-AMZ**2)/2./
     $      PROPZ*(REAL(WIJ*CONJG(BQZ(IFLQ,IZ1))*BQZ(IFLQ,IZ2))*
     $      SSGST(S,AMSQR,ZZ,IZ1,IZ2)+(-1.)**(ITHZ(IZ1)+ITHZ(IZ2))*
     $      REAL(WIJ*BQZ(IFLQ,IZ1)*CONJG(BQZ(IFLQ,IZ2)))*
     $      SSGST(S,AMSQR,-ZZ,IZ1,IZ2))
            SIG=KK*(SIGLL+SIGRR+SIGZZ+SIGLZ+SIGRZ)/3./PHAT
C          Below factor of 2 for id particles and jettyp switch
            SIG=SIG*FAC*QFCN(IQ1,1)*QFCN(IQ2,2)/2.
            IF(SIG.LT.0.AND.ABS(ZZ).GT.0.999) SIG=0
            CALL SIGFIL(SIG,IQ1,IQ2,JTYPZ1,JTYPZ2)
820       CONTINUE
810     CONTINUE
800   CONTINUE
      RETURN
      END
CDECK  ID>, SIGTC.  
      SUBROUTINE SIGTC
C
C          Compute the integrated technirho cross section
C          d(sigma)/d(qmw**2)d(yw) = d(sigma)/d(qmw**2)*f(x1)*f(x2)/scm
C          including W-technirho mixing from EHLQ 6.22 and 6.23 and
C          elastic resonance in longitudinal WW fusion.
C
C          Use WTYPE for control with
C          WTYPE = 2     3     4
C                  rho+  rho-  rho0
C
C          SIGMA    = cross section summed over allowed types.
C          SIGS(I)  = partial cross section for I1 + I2 --> I3 + I4.
C          INOUT(I) = IOPAK**3*I4 + IOPAK**2*I3 + IOPAK*I2 + I1
C                     using JETTYPE code.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/QSAVE/QSAVE(29,2)
      SAVE /QSAVE/
      REAL      QSAVE
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
      COMMON/TCPAR/TCMRHO,TCGRHO
      SAVE /TCPAR/
      REAL TCMRHO,TCGRHO
C
      REAL AMQCUR(6),WTHELI(4),FINT(9),X(2)
      EQUIVALENCE (S,SHAT),(T,THAT),(U,UHAT),(X(1),X1)
      INTEGER MATCHT(4,4)
      REAL ACOSH,Z,ATANH,AMASS,QMW2,QMZ,EHAT,ANEFF,Q2SAVE,YHAT,EY,AMW,
     $AMZ,STRUC,STRUCW,WM,ZM,PWWCM,SIG0,S,T,U,FACINV,RATZ,Q1L,Q1R,SIG1,
     $SIG,QZW
      INTEGER I,IH,IQ,IW,IQ1,IQ2,IQ3,IQ4,IRHO,LISTW(4)
C
      DATA AMQCUR/.005,.009,.175,1.25,4.50,30./
      DATA LISTW/10,80,-80,90/
      DATA MATCHT/0,0,0,0, 0,29,0,27, 0,0,29,28, 0,28,27,0/
C
C          Functions
      ACOSH(Z)=ALOG(Z+SQRT(Z**2-1.))
      ATANH(Z)=.5*ALOG((1.+Z)/(1.-Z))
C
C          Kinematics (identical to Drell-Yan)
C
      AMQCUR(6)=AMASS(6)
      QMW2=QMW**2
      QTMW=SQRT(QMW2+QTW**2)
      Q0W=QTMW*COSH(YW)
      QZW=QTMW*SINH(YW)
      QW=SQRT(QZW**2+QTW**2)
      IF(QW.NE.0.) THEN
        CTHW=QZW/QW
        STHW=QTW/QW
        IF(ABS(CTHW).LT.1.) THEN
          THW=ACOS(CTHW)
        ELSE
          CTHW=0.
          STHW=1.
          THW=.5*PI
        ENDIF
      ELSE
        CTHW=0.
        STHW=1.
        THW=.5*PI
      ENDIF
      EHAT=QMW
      SHAT=QMW**2
      QSQ=SHAT
      ANEFF=4.+QSQ/(QSQ+AMASS(5)**2)+QSQ/(QSQ+AMASS(6)**2)
      ALFQSQ=12.*PI/((33.-ANEFF)*ALOG(QSQ/ALAM2))
      Q2SAVE=QSQ
      YHAT=YW
      EY=EXP(YHAT)
      X1=EHAT/ECM*EY
      X2=EHAT/(ECM*EY)
C
C          Initialize
C
      SIGMA=0.
      NSIGS=0
      DO 100 I=1,MXSIGS
100   SIGS(I)=0
C
      IF(X1.GE.1..OR.X2.GE.1.) RETURN
      AMW=WMASS(2)
      AMZ=WMASS(4)
C
C          Compute structure functions
C
      DO 110 IH=1,2
        DO 120 IQ=1,13
120     QSAVE(IQ,IH)=STRUC(X(IH),QSQ,IQ,IDIN(IH))/X(IH)
        DO 130 IQ=14,26
130     QSAVE(IQ,IH)=0.
        DO 140 IW=2,4
          AMW=AMASS(LISTW(IW))
          IF(QMW.GT.2.*AMW) THEN
            QSAVE(25+IW,IH)=STRUCW(X(IH),IW,IDIN(IH))/X(IH)
          ELSE
            QSAVE(25+IW,IH)=0.
          ENDIF
140     CONTINUE
110   CONTINUE
C
C          qk + qb --> technirho0
C
      IF(.NOT.((GOQ(27,1).AND.GOQ(28,2)).OR.(GOQ(28,1).AND.GOQ(27,2))))
     $GO TO 300
      WM=WMASS(2)
      ZM=WMASS(4)
      IF(QMW.LE.2.*AMW) GO TO 300
      PWWCM=.5*SQRT(QMW**2-4.*WM**2)
      SIG0=PI*ALFA**2/(72.*SIN2W*S)*(2.*PWWCM/QMW)**3*X1*X2*UNITS
      SIG0=SIG0*TCMRHO**2/((S-TCMRHO**2)**2+TCMRHO**2*TCGRHO**2)
C          Initial state sum
      DO 210 IQ1=2,13
        IQ2=MATCH(IQ1,4)
        IF(IQ2.EQ.0) GO TO 210
        FACINV=2.*SQRT(SIN2W*(1.-SIN2W))
        RATZ=S/(S-ZM**2)
        Q1L=AQ(IQ1/2,4)*FACINV
        Q1R=BQ(IQ1/2,4)*FACINV
        SIG1=.25*SIG0*(1.-RATZ*Q1L/(Q1R*(1.-SIN2W))
     $  +RATZ**2*(Q1L**2+Q1R**2)/(4.*(1-SIN2W)**2))
     $  *QSAVE(IQ1,1)*QSAVE(IQ2,2)
C          Final state sum
        DO 220 IQ3=27,28
          IQ4=MATCHT(IQ3-25,4)
          IF(GOQ(IQ3,1).AND.GOQ(IQ4,2)) THEN
            SIG=SIG1*TBRWW(IQ3-25,1)*TBRWW(IQ4-25,2)
            CALL SIGFIL(SIG,IQ1,IQ2,IQ3,IQ4)
          ENDIF
220     CONTINUE
210   CONTINUE
C
C          W+ + W- -> technirho0 -> W+ + W-
C
      SIG0=12*PI/PWWCM**2*TCGRHO**2*X1*X2*UNITS
     $/((S-TCMRHO**2)**2+TCMRHO**2*TCGRHO**2)
C          Initial state sum
      DO 230 IQ1=27,28
        IQ2=MATCHT(IQ1-25,4)
        SIG1=.25*SIG0*QSAVE(IQ1,1)*QSAVE(IQ2,2)
C          Final state sum
        DO 240 IQ3=27,28
          IQ4=MATCHT(IQ3-25,4)
          IF(GOQ(IQ3,1).AND.GOQ(IQ4,2)) THEN
            SIG=SIG1*TBRWW(IQ3-25,1)*TBRWW(IQ4-25,2)
            CALL SIGFIL(SIG,IQ1,IQ2,IQ3,IQ4)
          ENDIF
240     CONTINUE
230   CONTINUE
C
C          q + qbar -> technirho+-
C
300   IF(.NOT.((GOQ(27,1).AND.GOQ(29,2)).OR.(GOQ(28,1).AND.GOQ(29,2))
     $.OR.(GOQ(29,1).AND.GOQ(27,2)).OR.(GOQ(29,1).AND.GOQ(28,2))))
     $GO TO 400
      WM=WMASS(2)
      ZM=WMASS(4)
      IF(QMW.LE.WM+ZM) GO TO 400
      PWWCM=SQRT((S-WM**2-ZM**2)**2-4.*WM**2*ZM**2)/(2.*QMW)
      SIG0=PI*ALFA**2/(144.*SIN2W)*S/(S-WM**2)**2*(2.*PWWCM/QMW)**3
     $*X1*X2*UNITS
      SIG0=SIG0*TCMRHO**2/((S-TCMRHO**2)**2+TCMRHO**2*TCGRHO**2)
      DO 310 IRHO=2,3
C          Initial state sum
        DO 320 IQ1=2,13
          IQ2=MATCH(IQ1,IRHO)
          IF(IQ2.EQ.0) GO TO 320
          SIG1=.25*SIG0*QSAVE(IQ1,1)*QSAVE(IQ2,2)
C          Final state sum
          DO 330 IQ3=27,28
            IQ4=MATCHT(IQ3-25,IRHO)
            IF(IQ4.EQ.0) GO TO 330
            IF(GOQ(IQ3,1).AND.GOQ(IQ4,2)) THEN
              SIG=SIG1*TBRWW(IQ3-25,1)*TBRWW(IQ4-25,2)
              CALL SIGFIL(SIG,IQ1,IQ2,IQ3,IQ4)
            ENDIF
330       CONTINUE
320     CONTINUE
310   CONTINUE
C
C          W+- + Z0 -> technirho+- -> W+- + Z0
C
      SIG0=12*PI/PWWCM**2*TCGRHO**2*X1*X2*UNITS
     $/((S-TCMRHO**2)**2+TCMRHO**2*TCGRHO**2)
      DO 340 IRHO=2,3
C          Initial state sum
        DO 350 IQ1=27,29
          IQ2=MATCHT(IQ1-25,IRHO)
          IF(IQ2.EQ.0) GO TO 350
          SIG1=.25*SIG0*QSAVE(IQ1,1)*QSAVE(IQ2,2)
C          Final state sum
          DO 360 IQ3=27,29
            IQ4=MATCHT(IQ3-25,IRHO)
            IF(IQ4.EQ.0) GO TO 360
            IF(GOQ(IQ3,1).AND.GOQ(IQ4,2)) THEN
              SIG=SIG1*TBRWW(IQ3-25,1)*TBRWW(IQ4-25,2)
              CALL SIGFIL(SIG,IQ1,IQ2,IQ3,IQ4)
            ENDIF
360       CONTINUE
350     CONTINUE
340   CONTINUE
C
400   RETURN
      END
CDECK  ID>, SIGTC2. 
      SUBROUTINE SIGTC2
C
C          Compute the techni-rho decay distribution cross section
C          D(SIGMA)/D(QMW**2)D(YW)D(OMEGA)
C          for the specified jet types. This is trivial but done for
C          compatibility with Drell-Yan and Higgs.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/WSIG/SIGLLQ
      SAVE /WSIG/
      REAL      SIGLLQ
      COMMON/TCPAR/TCMRHO,TCGRHO
      SAVE /TCPAR/
      REAL TCMRHO,TCGRHO
C
      REAL AM12,AM22,ANGFAC,S,T,U
      EQUIVALENCE (S,SHAT),(T,THAT),(U,UHAT)
C
C          Angfac is (1-z**2), and is determined in terms of S,T,U.
C          Note that both rho+- and rho0 are always elastic.
      AM12=PJETS(5,1)**2
      AM22=PJETS(5,2)**2
      ANGFAC=4.*(T*U-AM12*AM22)/((S-AM12-AM22)**2-4.*AM12*AM22)
C          Differential cross section
      SIGLLQ=SIGEVT*ANGFAC*3./(8.*PI)
      RETURN
      END
CDECK  ID>, SIGTC3. 
      SUBROUTINE SIGTC3
C
C          Calculate angular distributions for W decays from technirho:
C          d(sigma)/d(qmw**2)d(yw)d(omega)d(omega1)d(omega2)
C
      IMPLICIT NONE
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/WSIG/SIGLLQ
      SAVE /WSIG/
      REAL      SIGLLQ
      COMMON/WWSIG/WWSIG
      SAVE /WWSIG/
      REAL      WWSIG
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/WWPAR/SWW,TWW,UWW,WM2,ZM2,P1WW(5),P2WW(5),P3WW(5),P4WW(5)
     $,PZERO(4,4),S13,P3(5),Q1(5),Q3(5),JQWW(2)
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      SAVE /WWPAR/
      DOUBLE PRECISION SWW,TWW,UWW,WM2,ZM2,P1WW,P2WW,P3WW,P4WW
     $,PZERO,S13,P3,Q1,Q3
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      INTEGER   JQWW
      COMMON/TCPAR/TCMRHO,TCGRHO
      SAVE /TCPAR/
      REAL TCMRHO,TCGRHO
C
      EQUIVALENCE (S,SHAT),(T,THAT),(U,UHAT)
      INTEGER I,K,IDADDR(4),IW(2)
      REAL T12(3,3),T34(3,3),FR(3,3),FI(3,3),CPHI12(3),SPHI12(3),
     $CPHI34(3),SPHI34(3),PFCM(5,4),PWCM(5,2),CHWW,SHWW,TMP,PTW1,
     $CPHIW1,SPHIW1,PW1,CTHW1,STHW1,CHW1,SHW1,SHWI,TH12,PHI12,TH34,
     $PHI34,AMV,GAMV,QMH,A12,B12,A34,B34,TVV12,TVA12,COS12,SIN12,
     $TVV34,TVA34,COS34,SIN34,TCPHI,TSPHI,TC2PHI,TS2PHI,F0,F1,TOTAL,
     $DIFF,T,U,S
C
      IF(NPAIR.NE.4) RETURN
C
C          Reconstruct W-->FF decay angles
C
C          Initialize PFCM and PWCM
      DO 10 I=1,4
      DO 10 K=1,5
        PFCM(K,I)=PPAIR(K,I)
10    CONTINUE
      DO 11 I=1,2
      DO 11 K=1,5
        PWCM(K,I)=PJETS(K,I)
11    CONTINUE
C
C          Z boost to WW center of mass
      CHWW=QWJET(4)/QWJET(5)
      SHWW=QWJET(3)/QWJET(5)
      DO 20 I=1,4
        TMP=CHWW*PFCM(4,I)-SHWW*PFCM(3,I)
        PFCM(3,I)=-SHWW*PFCM(4,I)+CHWW*PFCM(3,I)
        PFCM(4,I)=TMP
20    CONTINUE
      DO 21 I=1,2
        TMP=CHWW*PWCM(4,I)-SHWW*PWCM(3,I)
        PWCM(3,I)=-SHWW*PWCM(4,I)+CHWW*PWCM(3,I)
        PWCM(4,I)=TMP
21    CONTINUE
C
C          Rotate W1 to +z axis
      PTW1=SQRT(PWCM(1,1)**2+PWCM(2,1)**2)
      CPHIW1=PWCM(1,1)/PTW1
      SPHIW1=PWCM(2,1)/PTW1
      PW1=SQRT(PTW1**2+PWCM(3,1)**2)
      CTHW1=PWCM(3,1)/PW1
      STHW1=PTW1/PW1
C          Z rotation
      DO 30 I=1,4
        TMP=CPHIW1*PFCM(1,I)+SPHIW1*PFCM(2,I)
        PFCM(2,I)=-SPHIW1*PFCM(1,I)+CPHIW1*PFCM(2,I)
        PFCM(1,I)=TMP
30    CONTINUE
C          Y rotation
      DO 31 I=1,4
        TMP=CTHW1*PFCM(1,I)-STHW1*PFCM(3,I)
        PFCM(3,I)=STHW1*PFCM(1,I)+CTHW1*PFCM(3,I)
        PFCM(1,I)=TMP
31    CONTINUE
C
C          Boost to W rest frames
      CHW1=PWCM(4,1)/PWCM(5,1)
      SHW1=PW1/PWCM(5,1)
      DO 40 I=1,4
        IF(I.LE.2) THEN
          SHWI=SHW1
        ELSE
          SHWI=-SHW1
        ENDIF
        TMP=CHW1*PFCM(4,I)-SHWI*PFCM(3,I)
        PFCM(3,I)=-SHWI*PFCM(4,I)+CHW1*PFCM(3,I)
        PFCM(4,I)=TMP
40    CONTINUE
C
C          Compute angles
      TH12=ACOS(PFCM(3,1)/SQRT(PFCM(1,1)**2+PFCM(2,1)**2+PFCM(3,1)**2))
      PHI12=ATAN2(PFCM(2,1),PFCM(1,1))
      TH34=ACOS(PFCM(3,3)/SQRT(PFCM(1,3)**2+PFCM(2,3)**2+PFCM(3,3)**2))
      PHI34=ATAN2(PFCM(2,3),PFCM(1,3))
C
C          Compute decay angular distributions.
C
      DO 100 I=1,4
        IDADDR(I)=IABS(IDPAIR(I))
        IF(IDADDR(I).GE.11) IDADDR(I)=IDADDR(I)-4
100   CONTINUE
      IW(1)=JETTYP(1)-25
      IW(2)=JETTYP(2)-25
C
      AMV=PJETS(5,1)
      GAMV=WGAM(IW(1))
      QMH=QMW
C          COUPLINGS
      A12=AQ(IDADDR(1),IW(1))
      B12=BQ(IDADDR(1),IW(1))
      A34=AQ(IDADDR(3),IW(2))
      B34=BQ(IDADDR(3),IW(2))
C          DECAY DISTRIBUTIONS
      TVV12=8.*PI*ALFA*(A12**2+B12**2)
      TVA12=16.*PI*ALFA*A12*B12
      COS12=COS(TH12)
      SIN12=SIN(TH12)
      T12(1,1)=TVV12*SIN12**2
      T12(1,2)=TVV12*SIN12*COS12/SQRT2+TVA12*SIN12/SQRT2
      T12(1,3)=-TVV12*SIN12*COS12/SQRT2+TVA12*SIN12/SQRT2
      T12(2,1)=T12(1,2)
      T12(2,2)=TVV12*(.5+.5*COS12**2)+TVA12*COS12
      T12(2,3)=TVV12*.5*SIN12**2
      T12(3,1)=T12(1,3)
      T12(3,2)=T12(2,3)
      T12(3,3)=TVV12*(.5+.5*COS12**2)-TVA12*COS12
C
      TVV34=8.*PI*ALFA*(A34**2+B34**2)
      TVA34=16.*PI*ALFA*A34*B34
      COS34=COS(TH34)
      SIN34=SIN(TH34)
      T34(1,1)=TVV34*SIN34**2
      T34(1,2)=TVV34*SIN34*COS34/SQRT2+TVA34*SIN34/SQRT2
      T34(1,3)=-TVV34*SIN34*COS34/SQRT2+TVA34*SIN34/SQRT2
      T34(2,1)=T34(1,2)
      T34(2,2)=TVV34*(.5+.5*COS34**2)+TVA34*COS34
      T34(2,3)=TVV34*.5*SIN34**2
      T34(3,1)=T34(1,3)
      T34(3,2)=T34(2,3)
      T34(3,3)=TVV34*(.5+.5*COS34**2)-TVA34*COS34
C
      CPHI12(1)=1.
      CPHI12(2)=COS(PHI12)
      CPHI12(3)=COS(2.*PHI12)
      SPHI12(1)=0.
      SPHI12(2)=SIN(PHI12)
      SPHI12(3)=SIN(2.*PHI12)
      CPHI34(1)=1.
      CPHI34(2)=COS(PHI34)
      CPHI34(3)=COS(2.*PHI34)
      SPHI34(1)=0.
      SPHI34(2)=SIN(PHI34)
      SPHI34(3)=SIN(2.*PHI34)
C
      TCPHI=CPHI12(2)*CPHI34(2)-SPHI12(2)*SPHI34(2)
      TSPHI=SPHI12(2)*CPHI34(2)+CPHI12(2)*SPHI34(2)
      TC2PHI=CPHI12(3)*CPHI34(3)-SPHI12(3)*SPHI34(3)
      TS2PHI=SPHI12(3)*CPHI34(3)+CPHI12(3)*SPHI34(3)
C
C          Pure technirho --> WW. Calculate angular distribution for
C          decay and multiply by cross section.
C
      F0=.5*QMH**2/AMV**2-1.
      F1=1.
      TOTAL=(8.*PI/3.)**2*TVV12*TVV34*(F0**2+2.*F1**2)
      DIFF=F0**2*T12(1,1)*T34(1,1)
     $+F0*F1*(2.*T12(1,2)*T34(1,2)+2.*T12(1,3)*T34(1,3))*TCPHI
     $+F1**2*(T12(2,2)*T34(1,2)+T12(3,3)*T34(3,3)
     $  +2.*T12(2,3)*T34(2,3)*TC2PHI)
      WWSIG=SIGLLQ*DIFF/TOTAL
      RETURN
      END
CDECK  ID>, SIGWW.  
      SUBROUTINE SIGWW
C
C          Calculate D(SIGMA)/D(PT**2)D(Y1)D(Y2) for QK+QB-->W+W
C          summed over W types allowed on JETTYPE cards and
C          including branching ratio implied by WMODE cards.
C
C          SIGMA    = cross section summed over quark types allowed by
C                     JETTYPE card.
C          SIGS(I)  = partial cross section for I1 + I2 --> I3 + I4.
C          INOUT(I) = IOPAK**3*I4 + IOPAK**2*I3 + IOPAK*I2 + I1
C                     using JETTYPE code.
C
C          Cross sections from Brown and Mikaelian,
C          Phys Rev D19, 922, D20, 1164.
C          Include extra factor of 1/2 for double counting.
C
C          Double precision needed for 32-bit machines.
C
C          Ver. 6.22: Modified to used W + GM decay distributions from
C                     Cortes, Hagiwara, and Herzog, NP B278, 26 (1986)
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/QSAVE/QSAVE(29,2)
      SAVE /QSAVE/
      REAL      QSAVE
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/WWPAR/SWW,TWW,UWW,WM2,ZM2,P1WW(5),P2WW(5),P3WW(5),P4WW(5)
     $,PZERO(4,4),S13,P3(5),Q1(5),Q3(5),JQWW(2)
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      SAVE /WWPAR/
      DOUBLE PRECISION SWW,TWW,UWW,WM2,ZM2,P1WW,P2WW,P3WW,P4WW
     $,PZERO,S13,P3,Q1,Q3
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      INTEGER   JQWW
C
      DIMENSION X(2),LISTW(4),QSGN(6)
      EQUIVALENCE (X(1),X1)
      EQUIVALENCE (S,SWW),(T,TWW),(U,UWW)
      DOUBLE PRECISION S,T,U,TX,UX,TXX,UXX,TT,UU
     $,WWA,WWI,WWE,WZA,WZI,WZE,TERM
     $,GA,GI,GE,GJ,GZ
      REAL WM2S,ZM2S,X,STRUC,FJAC,SGN,QSGN,SIG,FACTOR
      INTEGER I,IH,IQ,IW1,IW2,JW,JZ,IW,IQ1,IQ2,IFL1,IFL2,JG,LISTW
      INTEGER IFLI,IFLJ
      LOGICAL LQK1
C
      DATA LISTW/10,80,-80,90/
      DATA QSGN/1.,-1.,-1.,1.,-1.,1./
C
C          Functions for W+W-
      WWA(S,T,U)=(U*T/WM2**2-1.)*(.25-WM2/S+3.*(WM2/S)**2)+S/WM2-4.
      WWI(S,T,U)=(U*T/WM2**2-1.)*(.25-.5*WM2/S-WM2**2/(S*T))
     $+S/WM2-2.+2.*WM2/T
      WWE(S,T,U)=(U*T/WM2**2-1.)*(.25+(WM2/T)**2)+S/WM2
C          Functions for W+-Z0
      WZA(S,T,U)=(U*T/(WM2*ZM2)-1.)*(.25-(WM2+ZM2)/(2.*S)
     $+((WM2+ZM2)**2+8.*WM2*ZM2)/(4.*S**2))
     $+(WM2+ZM2)/(WM2*ZM2)*(.5*S-WM2-ZM2+(WM2-ZM2)**2/(2.*S))
      WZI(S,T,U)=.25*(U*T/(WM2*ZM2)-1.)*(1.-(WM2+ZM2)/S
     $-4.*WM2*ZM2/(S*T))
     $+(WM2+ZM2)/(2.*WM2*ZM2)*(S-WM2-ZM2+2.*WM2*ZM2/T)
      WZE(S,T,U)=.25*(U*T/(WM2*ZM2)-1.)+.5*S*(WM2+ZM2)/(WM2*ZM2)
C
C          Initialize
      DO 10 I=1,MXSIGS
10    SIGS(I)=0.
      SIGMA=0.
      NSIGS=0
C
C          Convention is that even for double precision single
C          precision mass is exact.
      WM2=WMASS(2)
      WM2=WM2**2
      ZM2=WMASS(4)
      ZM2=ZM2**2
C          Also need single precision mass**2.
      WM2S=WM2
      ZM2S=ZM2
C
C          W+ W- pairs
C
      IF(.NOT.((GOQ(2,1).AND.GOQ(3,2)).OR.(GOQ(3,1).AND.GOQ(2,2))))
     $GO TO 200
      CALL WWKIN(WMASS(2),WMASS(2))
      IF(X1.GE.1..OR.X2.GE.1.) GO TO 200
      DO 110 IH=1,2
      DO 110 IQ=2,9
110   QSAVE(IQ,IH)=STRUC(X(IH),QSQ,IQ,IDIN(IH))/X(IH)
      FJAC=S/SCM*UNITS
      FJAC=FJAC*PI*ALFA**2/(3.*S**2)
      FJAC=FJAC*P(1)*P(2)/SQRT((P(1)**2+WM2S)*(P(2)**2+WM2S))
      FJAC=.5*FJAC
C          Sum over jet1 = W+ and jet2 = W+.
C          Swap t and u in latter case.
      DO 120 IW1=2,3
      IW2=5-IW1
      IF(.NOT.(GOQ(IW1,1).AND.GOQ(IW2,2))) GO TO 120
      IF(IW1.EQ.3) GO TO 121
      TX=T
      UX=U
      GO TO 122
121   TX=U
      UX=T
C
C          Sum over quarks, swapping t and u for negative charge.
122   DO 130 IQ=1,4
      GA=2.*(AQDP(IQ,1)+EZDP*AQDP(IQ,4)*S/(S-ZM2))**2
     $+2.*(EZDP*BQDP(IQ,4)*S/(S-ZM2))**2
      GI=8.*(AQDP(IQ,1)+EZDP*(AQDP(IQ,4)+BQDP(IQ,4))*S/(S-ZM2))
     $*(AQDP(IQ,2))**2
      GE=16.*(AQDP(IQ,2))**4
      SGN=QSGN(IQ)
      IF(SGN.LT.0.) GO TO 131
      TT=TX
      UU=UX
      GO TO 132
131   TT=UX
      UU=TX
132   SIG=QSAVE(2*IQ,1)*QSAVE(2*IQ+1,2)*FJAC*TBRWW(IW1,1)*TBRWW(IW2,2)
     $*(GA*WWA(S,TT,UU)-SGN*GI*WWI(S,TT,UU)+GE*WWE(S,TT,UU))
      CALL SIGFIL(SIG,2*IQ,2*IQ+1,IW1,IW2)
      SIG=QSAVE(2*IQ+1,1)*QSAVE(2*IQ,2)*FJAC*TBRWW(IW1,1)*TBRWW(IW2,2)
     $*(GA*WWA(S,UU,TT)-SGN*GI*WWI(S,UU,TT)+GE*WWE(S,UU,TT))
      CALL SIGFIL(SIG,2*IQ+1,2*IQ,IW1,IW2)
130   CONTINUE
120   CONTINUE
C
C          Z0 Z0 pairs
C
200   IF(.NOT.(GOQ(4,1).AND.GOQ(4,2))) GO TO 300
      CALL WWKIN(WMASS(4),WMASS(4))
      IF(X1.GE.1..OR.X2.GE.1.) RETURN
      DO 210 IH=1,2
      DO 210 IQ=2,9
210   QSAVE(IQ,IH)=STRUC(X(IH),QSQ,IQ,IDIN(IH))/X(IH)
C          Jacobean -- including factor of 1/2 for identical particles.
      FJAC=.5*S/SCM*UNITS
      FJAC=FJAC*PI*ALFA**2/(3.*S**2)
      FJAC=FJAC*P(1)*P(2)/SQRT((P(1)**2+ZM2S)*(P(2)**2+ZM2S))
      DO 220 IQ=1,4
      GZ=2.*(AQDP(IQ,4)**4+BQDP(IQ,4)**4
     $+6.*AQDP(IQ,4)**2*BQDP(IQ,4)**2)
      FACTOR=(T/U+U/T+4.*ZM2*S/(T*U)-ZM2**2*(1./T**2+1./U**2))
      FACTOR=FACTOR*FJAC*GZ*TBRWW(4,1)*TBRWW(4,2)
      SIG=FACTOR*QSAVE(2*IQ,1)*QSAVE(2*IQ+1,2)
      CALL SIGFIL(SIG,2*IQ,2*IQ+1,4,4)
      SIG=FACTOR*QSAVE(2*IQ+1,1)*QSAVE(2*IQ,2)
      CALL SIGFIL(SIG,2*IQ+1,2*IQ,4,4)
220   CONTINUE
C
C          W+- Z0 pairs
C
C          JW and JZ are W+- and Z0 jet numbers.
300   DO 310 JW=1,2
      JZ=3-JW
      IF(.NOT.((GOQ(2,JW).OR.GOQ(3,JW)).AND.GOQ(4,JZ))) GO TO 310
C          Must swap t and u if JW=2.
      IF(JW.EQ.2) GO TO 315
      CALL WWKIN(WMASS(2),WMASS(4))
      TX=T
      UX=U
      FJAC=S/SCM*UNITS
      FJAC=FJAC*PI*ALFA**2/(3.*S**2)
      FJAC=.5*FJAC
      FJAC=FJAC*P(1)*P(2)/SQRT((P(1)**2+WM2S)*(P(2)**2+ZM2S))
      GO TO 320
C
315   CALL WWKIN(WMASS(4),WMASS(2))
      TX=U
      UX=T
      FJAC=S/SCM*UNITS
      FJAC=FJAC*PI*ALFA**2/(3.*S**2)
      FJAC=.5*FJAC
      FJAC=FJAC*P(1)*P(2)/SQRT((P(1)**2+ZM2S)*(P(2)**2+WM2S))
320   IF(X1.GE.1..OR.X2.GE.1.) GO TO 310
      DO 325 IH=1,2
      DO 325 IQ=1,9
325   QSAVE(IQ,IH)=STRUC(X(IH),QSQ,IQ,IDIN(IH))/X(IH)
C
C          Sum over W+ and W-, swapping t and u for W+.
      DO 340 IW=2,3
      IF(IW.EQ.2) GO TO 341
      TXX=TX
      UXX=UX
      SGN=1.
      GO TO 342
341   TXX=UX
      UXX=TX
      SGN=-1.
C
C          Sum over quarks, swapping t and u for negative charge.
342   DO 350 IQ=1,4
      IQ1=2*IQ
      IQ2=MATCH(IQ1,IW)
      IF(IQ2.EQ.0) GO TO 351
      TT=TXX
      UU=UXX
      IFLI=IQ1/2
      IFLJ=IQ2/2
      GO TO 352
C
351   IQ1=IQ1+1
      IQ2=MATCH(IQ1,IW)
      IF(IQ2.EQ.0) GO TO 350
      TT=UXX
      UU=TXX
      IFLI=IQ2/2
      IFLJ=IQ1/2
C
352   GA=AQDP(IQ,IW)*EZDP*S/(S-WM2)
      GI=AQDP(IQ,IW)*(AQDP(IFLI,4)+BQDP(IFLI,4))
      GJ=AQDP(IQ,IW)*(AQDP(IFLJ,4)+BQDP(IFLJ,4))
      TERM=GA**2*WZA(S,TT,UU)
      TERM=TERM+2.*GA*SGN*(-GJ*WZI(S,TT,UU)+GI*WZI(S,UU,TT))
      TERM=TERM+(GI-GJ)**2*WZE(S,TT,UU)
      TERM=TERM+GI**2*(UU*TT-WM2*ZM2)/UU**2
     $+2.*GI*GJ*S*(WM2+ZM2)/(TT*UU)+GJ**2*(UU*TT-WM2*ZM2)/TT**2
      TERM=TERM*4.*FJAC*QSAVE(IQ1,1)*QSAVE(IQ2,2)
      TERM=TERM*TBRWW(IW,JW)*TBRWW(4,JZ)
      SIG=TERM
      IF(JW.EQ.1) CALL SIGFIL(SIG,IQ1,IQ2,IW,4)
      IF(JW.EQ.2) CALL SIGFIL(SIG,IQ1,IQ2,4,IW)
350   CONTINUE
340   CONTINUE
310   CONTINUE
C
C          W+- GM pairs.
C
400   DO 410 JW=1,2
        JG=3-JW
        IF(.NOT.((GOQ(2,JW).OR.GOQ(3,JW)).AND.GOQ(1,JG))) GO TO 410
C
C          Must swap t and u if JW=2.
        IF(JW.EQ.1) THEN
          CALL WWKIN(WMASS(2),0.)
          TX=T
          UX=U
          FJAC=S/SCM*UNITS
          FJAC=FJAC*PI*ALFA**2/S**2
          FJAC=.5*FJAC
          FJAC=FJAC*P(1)/SQRT(P(1)**2+WM2S)
        ELSE
          CALL WWKIN(0.,WMASS(2))
          TX=U
          UX=T
          FJAC=S/SCM*UNITS
          FJAC=FJAC*PI*ALFA**2/S**2
          FJAC=.5*FJAC
          FJAC=FJAC*P(2)/SQRT(P(2)**2+WM2S)
        ENDIF
C
        IF(X1.GE.1..OR.X2.GE.1.) GO TO 410
        DO 420 IH=1,2
        DO 420 IQ=1,9
420     QSAVE(IQ,IH)=STRUC(X(IH),QSQ,IQ,IDIN(IH))/X(IH)
C
C          Sum over W+ and W-
        DO 440 IW=2,3

C
C          Sum over quarks, swapping t and u as needed.
          DO 450 IQ1=2,9
            IQ2=MATCH(IQ1,IW)
            IF(IQ2.EQ.0) GO TO 450
            IQ=IQ1/2
            IF(2*IQ.EQ.IQ1) THEN
              LQK1=.TRUE.
            ELSE
              LQK1=.FALSE.
            ENDIF
            IF((LQK1.AND.IW.EQ.3).OR.(.NOT.LQK1.AND.IW.EQ.2)) THEN
              TT=TX
              UU=UX
            ELSE
              TT=UX
              UU=TX
            ENDIF
C
            SIG=TBRWW(IW,JW)/(6.*SIN2W)*(-1./3.+UU/(TT+UU))**2
     $      *(UU**2+TT**2+2.*S*WM2)/(TT*UU)
            SIG=SIG*FJAC*QSAVE(IQ1,1)*QSAVE(IQ2,2)
            IF(JW.EQ.1) CALL SIGFIL(SIG,IQ1,IQ2,IW,1)
            IF(JW.EQ.2) CALL SIGFIL(SIG,IQ1,IQ2,1,IW)
450       CONTINUE
440     CONTINUE
410   CONTINUE
C
      RETURN
      END
CDECK  ID>, SIGWW2. 
      SUBROUTINE SIGWW2
C
C          Calculate WPAIR decay distribution
C          D(SIGMA)/D(PT**2)D(Y1)D(Y2)D(OMEGA1)D(OMEGA2)
C          for modes selected in WPAIR.
C
C          Also fix the initial parton types to those selected.
C
C          Cross sections from SCHOONSCHIP (1980) neglecting W width
C          and quark masses. Hence use zero-mass vectors PZERO from
C          WPAIR to define kinematics.
C          QK(P1) + QB(P2) --> W1(P3) + W2(P4)
C                   W1(P3) --> QK(Q1) + QB(Q2)
C                   W2(P4) --> QK(Q3) + QB(Q4)
C          S=(P3+P4)**2,  T=(P3-P1)**2,  U=(P3-P2)**2
C          S1=(Q1+P4)**2, T1=(Q1-P1)**2, U1=(Q1-P2)**2
C          S3=(Q3+P3)**2, T3=(Q3-P2)**2, U3=(Q3-P1)**2
C          S13=(Q1+Q3)**2
C          Note that the W+- final couplings have been set equal to 1.
C          in the SCHOONSCHIP formulas and must be restored.
C
C          Need double precision for 32-bit machines.
C
C          Ver. 5.35 - correct symmetrization for DN DB -> W+ W-.
C          Ver. 6.22 - use W + GM decay distributions from
C                      Cortes, Hagiwara, and Herzog, NP B278, 26 (1986)
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/QSAVE/QSAVE(29,2)
      SAVE /QSAVE/
      REAL      QSAVE
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PINITS/PINITS(5,2),IDINIT(2)
      SAVE /PINITS/
      INTEGER   IDINIT
      REAL      PINITS
      COMMON/WWSIG/WWSIG
      SAVE /WWSIG/
      REAL      WWSIG
      COMMON/WWPAR/SWW,TWW,UWW,WM2,ZM2,P1WW(5),P2WW(5),P3WW(5),P4WW(5)
     $,PZERO(4,4),S13,P3(5),Q1(5),Q3(5),JQWW(2)
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      SAVE /WWPAR/
      DOUBLE PRECISION SWW,TWW,UWW,WM2,ZM2,P1WW,P2WW,P3WW,P4WW
     $,PZERO,S13,P3,Q1,Q3
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      INTEGER   JQWW
C
      DIMENSION P1(5),P2(5),QSGN(6),PP1(4),PP2(4)
      EQUIVALENCE (S,SWW),(T,TWW),(U,UWW)
      EQUIVALENCE (P1(1),P1WW(1)),(P2(1),P2WW(1))
C          Double precision kinematics for 32-bit.
      DOUBLE PRECISION S,T,U,T1,U1,T3,U3,P1,P2
     1,TX,UX,TT,UU,TT1,UU1,TT3,UU3,PP1,PP2
      DOUBLE PRECISION TERM,WWSS,WWST,WWTT,ZZALL,WZSS,WZST,WZSU,WZTU
     1,WGSS,WGST,WGSU,WGTU
      REAL P3IS3,P3IS4,FJAC,AMW1,AMW2,GAM1,GAM2,SGN,QSGN,AMASS3
      REAL P1DQ2,P2DQ1
      INTEGER K,JQ1,JQ3,JW1,JW2,IW1,IW2,IQ1,IQ2,IQ,ISWAPQ,JW,JZ,ISGN
      INTEGER IFLI,IFLJ,JG,IL,IW
      LOGICAL LQK1
C
      DATA QSGN/1.,-1.,-1.,1.,-1.,1./
C
C          Entry
C
      WWSIG=0.
      IF(IDJETS(1).EQ.10.OR.IDJETS(2).EQ.10) GO TO 2
C          Normal case
      IF((IDJETS(1).EQ.80.AND.IDJETS(2).EQ.-80).OR.
     $(IDJETS(1).EQ.90.AND.IDJETS(2).EQ.90).OR.
     $(IABS(IDJETS(1)).EQ.80.AND.IDJETS(2).EQ.90)) THEN
        DO 10 K=1,4
          P3(K)=P3WW(K)
          Q1(K)=PZERO(K,1)
          Q3(K)=PZERO(K,3)
10      CONTINUE
        P3IS3=1.
        P3IS4=0.
        JQ1=1
        JQ3=3
        JW1=1
        JW2=2
        TX=T
        UX=U
C          Crossed case
      ELSE
        DO 20 K=1,4
          P3(K)=P4WW(K)
          Q1(K)=PZERO(K,3)
          Q3(K)=PZERO(K,1)
20      CONTINUE
        P3IS3=0.
        P3IS4=1.
        JQ1=3
        JQ3=1
        JW1=2
        JW2=1
        TX=U
        UX=T
      ENDIF
C          Variables
      T1=-2.*(Q1(4)*P1(4)-Q1(1)*P1(1)-Q1(2)*P1(2)-Q1(3)*P1(3))
      U1=-2.*(Q1(4)*P2(4)-Q1(1)*P2(1)-Q1(2)*P2(2)-Q1(3)*P2(3))
      T3=-2.*(Q3(4)*P2(4)-Q3(1)*P2(1)-Q3(2)*P2(2)-Q3(3)*P2(3))
      U3=-2.*(Q3(4)*P1(4)-Q3(1)*P1(1)-Q3(2)*P1(2)-Q3(3)*P1(3))
      S13=2.*(Q1(4)*Q3(4)-Q1(1)*Q3(1)-Q1(2)*Q3(2)-Q1(3)*Q3(3))
C          Jacobean for 4-body cross section in terms of squared
C          matrix exement in narrow resonance approximation--
C          1/((P**2-M**2)**2+M**2*GAM**2)=1/(2*M*GAM)*DELTA(P**2-M**2)
      FJAC=S/SCM*UNITS
      FJAC=FJAC*ALFA**4/(256.*PI*3.*S**2)
      AMW1=PJETS(5,1)
      AMW2=PJETS(5,2)
      GAM1=WGAM(JETTYP(1))
      GAM2=WGAM(JETTYP(2))
      FJAC=FJAC/(AMW1*GAM1*AMW2*GAM2)
      FJAC=FJAC*P(1)*P(2)/SQRT((P(1)**2+AMW1**2)*(P(2)**2+AMW2**2))
C          Color factor
      IF(IABS(IDPAIR(1)).LT.10) FJAC=3.*FJAC
      IF(IABS(IDPAIR(3)).LT.10) FJAC=3.*FJAC
C
C          W+ W- pair decays
C          Standard order is UP + UB --> W+ + W-
C
      IF(.NOT.((JETTYP(1).EQ.2.AND.JETTYP(2).EQ.3).OR.(JETTYP(1).EQ.3
     1.AND.JETTYP(2).EQ.2))) GO TO 200
      FJAC=.5*FJAC*AQ(2,2)**4
C
C          Select W+ W- OR W- W+, swapping T and U for latter.
      IW1=JETTYP(1)
      IW2=JETTYP(2)
C
C          Select quarks
      IQ1=INITYP(1)
      IQ2=INITYP(2)
      IQ=IQ1/2
      CQ=AQDP(IQ,2)**2
      CV=AQDP(IQ,1)/S+EZDP*AQDP(IQ,4)/(S-ZM2)
      CA=EZDP*BQDP(IQ,4)/(S-ZM2)
      SGN=QSGN(IQ)
      ISWAPQ=1
      IF(SGN.LT.0.) ISWAPQ=-1
      IF(ISWAPQ.GT.0) THEN
        TT=TX
        UU=UX
        TT1=T1
        UU1=U1
        TT3=T3
        UU3=U3
        DO 122 K=1,4
          PP1(K)=P1(K)
          PP2(K)=P2(K)
          P3(K)=P3IS3*P3WW(K)+P3IS4*P4WW(K)
          Q1(K)=PZERO(K,JQ1)
          Q3(K)=PZERO(K,JQ3)
122     CONTINUE
      ELSE
        TT=UX
        UU=TX
        TT1=U3
        UU1=T3
        TT3=U1
        UU3=T1
        DO 123 K=1,4
          PP1(K)=P1(K)
          PP2(K)=P2(K)
          P3(K)=P3IS4*P3WW(K)+P3IS3*P4WW(K)
          Q1(K)=PZERO(K,JQ3)
          Q3(K)=PZERO(K,JQ1)
123     CONTINUE
      ENDIF
C
      IF(IQ1.EQ.2*IQ) THEN
        TERM=WWTT(TT,UU,TT1,UU1,TT3,UU3)
        TERM=TERM-SGN*WWST(TT,UU,TT1,UU1,TT3,UU3,PP1,PP2)
        TERM=TERM+WWSS(TT,UU,TT1,UU1,TT3,UU3)
        WWSIG=TERM*QSAVE(2*IQ,1)*QSAVE(2*IQ+1,2)*FJAC
      ELSE
        TERM=WWTT(UU,TT,UU1,TT1,UU3,TT3)
        TERM=TERM-SGN*WWST(UU,TT,UU1,TT1,UU3,TT3,PP2,PP1)
        TERM=TERM+WWSS(UU,TT,UU1,TT1,UU3,TT3)
        WWSIG=TERM*QSAVE(2*IQ+1,1)*QSAVE(2*IQ,2)*FJAC
      ENDIF
C
      RETURN
C
C          Z0 Z0 pair decays
C          Standard order is UP + UB --> Z0 + Z0
C
200   IF(.NOT.(JETTYP(1).EQ.4.AND.JETTYP(2).EQ.4)) GO TO 300
      FJAC=.5*FJAC
C
C          Select quarks
      IQ1=INITYP(1)
      IQ2=INITYP(2)
      IQ=IQ1/2
      CV=AQDP(IQ,4)**2+BQDP(IQ,4)**2
      CA=2.*AQDP(IQ,4)*BQDP(IQ,4)
      CV1=AQDP(JQWW(1),4)**2+BQDP(JQWW(1),4)**2
      CA1=2.*AQDP(JQWW(1),4)*BQDP(JQWW(1),4)
      CV3=AQDP(JQWW(2),4)**2+BQDP(JQWW(2),4)**2
      CA3=2.*AQDP(JQWW(2),4)*BQDP(JQWW(2),4)
C
      TERM=ZZALL(TX,UX,T1,U1,T3,U3,P1,P2)
      IF(INITYP(1).EQ.2*IQ) THEN
        WWSIG=TERM*QSAVE(2*IQ,1)*QSAVE(2*IQ+1,2)*FJAC
      ELSE
        WWSIG=TERM*QSAVE(2*IQ+1,1)*QSAVE(2*IQ,2)*FJAC
      ENDIF
C
      RETURN
C
C          W+- Z0 pair decays
C          Standard order is DN + UB --> W- + Z0
C
300   JW=JW1
      JZ=JW2
      ISGN=-ISIGN(1,IDJETS(JW))
      SGN=ISGN
      CV3=AQDP(JQWW(JZ),4)**2+BQDP(JQWW(JZ),4)**2
      CA3=2.*AQDP(JQWW(JZ),4)*BQDP(JQWW(JZ),4)
      FJAC=.5*FJAC*AQ(1,2)**2
C
C          Select quarks. Formulas are for DN UB --> W- Z0.
C          Use symmetry for other cases.
      IQ1=INITYP(1)
      IQ2=INITYP(2)
      IQ=IQ1/2
C          Find whether IQ1 should be fermion or antifermion.
      IF(IQ1.EQ.2*(IQ1/2)) THEN
        ISWAPQ=+1
        IFLI=IQ1/2
        IFLJ=IQ2/2
      ELSE
        ISWAPQ=-1
        IFLI=IQ2/2
        IFLJ=IQ1/2
      ENDIF
C
      CS=AQDP(IQ,JETTYP(JW))*EZDP/(S-WM2)
      CT=AQDP(IQ,JETTYP(JW))*(AQDP(IFLJ,4)+BQDP(IFLJ,4))
      CU=AQDP(IQ,JETTYP(JW))*(AQDP(IFLI,4)+BQDP(IFLI,4))
C
C          SWAP T AND U AS NEEDED
      IF(ISWAPQ*ISGN.GT.0) THEN
        TT=TX
        UU=UX
        TT1=T1
        UU1=U1
        TT3=T3
        UU3=U3
        DO 321 K=1,4
          PP1(K)=P1(K)
          PP2(K)=P2(K)
321     CONTINUE
      ELSE
        TT=UX
        UU=TX
        TT1=U1
        UU1=T1
        TT3=U3
        UU3=T3
        DO 323 K=1,4
          PP1(K)=P2(K)
          PP2(K)=P1(K)
323     CONTINUE
      ENDIF
C
      TERM=WZSS(TT,UU,TT1,UU1,TT3,UU3,PP1,PP2)
      TERM=TERM-SGN*WZST(TT,UU,TT1,UU1,TT3,UU3,PP1,PP2)
      TERM=TERM-SGN*WZSU(TT,UU,TT1,UU1,TT3,UU3,PP1,PP2)
      TERM=TERM+WZTU(TT,UU,TT1,UU1,TT3,UU3,PP1,PP2)
      WWSIG=TERM*QSAVE(IQ1,1)*QSAVE(IQ2,2)*FJAC
C
      RETURN
C
C          W+- GM pair decays
C          Standard order is DN + UB --> W- + GM
C
2     CONTINUE
C          Swap if W is jet 2
      IF(IDJETS(2).EQ.10) THEN
        DO 510 K=1,4
          P3(K)=P3WW(K)
          Q1(K)=PZERO(K,1)
510     CONTINUE
        AMASS3=PJETS(5,1)
        JW=1
        JG=2
        TX=T
        UX=U
      ELSE
        DO 520 K=1,4
          P3(K)=P4WW(K)
          Q1(K)=PZERO(K,1)
520     CONTINUE
        AMASS3=PJETS(5,2)
        JW=2
        JG=1
        TX=U
        UX=T
      ENDIF
      IF(IDJETS(JW).EQ.80) THEN
        IW=2
      ELSE
        IW=3
      ENDIF
C
      T1=-2.*(Q1(4)*P1(4)-Q1(1)*P1(1)-Q1(2)*P1(2)-Q1(3)*P1(3))
      U1=-2.*(Q1(4)*P2(4)-Q1(1)*P2(1)-Q1(2)*P2(2)-Q1(3)*P2(3))
C          Jacobean
      FJAC=S/SCM*UNITS
      FJAC=FJAC*P(JW)/SQRT(P(JW)**2+WM2)
C          Sum over quarks. Formulas are for DN UB --> W- GM.
C          Use symmetry for other cases.
      IQ1=INITYP(1)
      IQ2=INITYP(2)
      IQ=IQ1/2
      IF(2*IQ.EQ.IQ1) THEN
        LQK1=.TRUE.
      ELSE
        LQK1=.FALSE.
      ENDIF
C          Swap t and u as necessary
      IF((LQK1.AND.IW.EQ.3).OR.(.NOT.LQK1.AND.IW.EQ.2)) THEN
        TT=TX
        UU=UX
        TT1=T1
        UU1=U1
      ELSE
        TT=UX
        UU=TX
        TT1=U1
        UU1=T1
      ENDIF
C          Lepton or quark pointer
      IL=IABS(IDPAIR(1))
      IF(IL.GT.6) IL=IL-4
C
C          Matrix element - properly crossed variables.
C          Remember PZERO(K,1) is always the fermion.
      IF(LQK1) THEN
        P1DQ2=P1(4)*PZERO(4,2)-P1(1)*PZERO(1,2)-P1(2)*PZERO(2,2)
     $  -P1(3)*PZERO(3,2)
        P2DQ1=P2(4)*PZERO(4,1)-P2(1)*PZERO(1,1)-P2(2)*PZERO(2,1)
     $  -P2(3)*PZERO(3,1)
      ELSE
        P1DQ2=P2(4)*PZERO(4,2)-P2(1)*PZERO(1,2)-P2(2)*PZERO(2,2)
     $  -P2(3)*PZERO(3,2)
        P2DQ1=P1(4)*PZERO(4,1)-P1(1)*PZERO(1,1)-P1(2)*PZERO(2,1)
     $  -P1(3)*PZERO(3,1)
      ENDIF
      TERM=ALFA**2/(8.*SIN2W*S**2)*TBRWW(IW,JW)*RBRWW(IL,IW,JW)
     $*(-1./3.+UU/(TT+UU))**2/(TT*UU)*(4.*P2DQ1**2+4.*P1DQ2**2)
      WWSIG=TERM*QSAVE(IQ1,1)*QSAVE(IQ2,2)*FJAC
C
      RETURN
      END
CDECK  ID>, SSGST.  
        REAL FUNCTION SSGST(S,AMSQ,Z,I,J)
C-----------------------------------------------------------------------
C          Function for Sig(qqbar->z_i + z_j
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
        REAL S,AMSQ,K,Z,MZI,MZJ,RS,TP,BT
        INTEGER I,J,ITHI,ITHJ
C
        MZI=ABS(AMZISS(I))
        MZJ=ABS(AMZISS(J))
        IF (AMZISS(I).LT.0.) THEN
          ITHI=1
        ELSE
          ITHI=0
        END IF
        IF (AMZISS(J).LT.0.) THEN
          ITHJ=1
        ELSE
          ITHJ=0
        END IF
        RS=SQRT(S)
        K=SQRT(S*S+(MZI**2-MZJ**2)**2-2*S*(MZI**2+MZJ**2))/
     $   2./RS
        TP=S*S-(MZI**2-MZJ**2)**2-4*K*S**1.5*Z+4*K*K*S*Z*Z+
     $   4*(-1.)**(ITHI+ITHJ+1)*MZI*MZJ*S
        BT=(S-MZI**2-MZJ**2)/2.-RS*K*Z+AMSQ**2
        SSGST=TP/BT
        RETURN
        END
CDECK  ID>, SSGT.   
        REAL FUNCTION SSGT(S,AMSQ,Z,I,J)
C-----------------------------------------------------------------------
C          Function for Sig(qqbar->z_i + z_j
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
        REAL S,AMSQ,K,Z,MZI,MZJ,RS,TPP,TPM,BTP,BTM
        INTEGER I,J,ITHI,ITHJ
C
        MZI=ABS(AMZISS(I))
        MZJ=ABS(AMZISS(J))
        IF (AMZISS(I).LT.0.) THEN
          ITHI=1
        ELSE
          ITHI=0
        END IF
        IF (AMZISS(J).LT.0.) THEN
          ITHJ=1
        ELSE
          ITHJ=0
        END IF
        RS=SQRT(S)
        K=SQRT(S*S+(MZI**2-MZJ**2)**2-2*S*(MZI**2+MZJ**2))/
     $   2./RS
        TPP=S*S-(MZI**2-MZJ**2)**2-4*K*S**1.5*Z+4*K*K*S*Z*Z
        TPM=S*S-(MZI**2-MZJ**2)**2+4*K*S**1.5*Z+4*K*K*S*Z*Z
        BTP=(S-MZI**2-MZJ**2)/2.-RS*K*Z+AMSQ**2
        BTM=(S-MZI**2-MZJ**2)/2.+RS*K*Z+AMSQ**2
        SSGT=(TPP/BTP**2+TPM/BTM**2-8*(-1.)**(ITHI+ITHJ)*
     $   MZI*MZJ*S/BTM/BTP)/16.
        RETURN
        END
CDECK  ID>, STRUC.  
      FUNCTION STRUC(X,QSQ,IQ,IH)
C
C          Compute structure functions X*F(X,QSQ)
C          ISTRUC=1,2  obsolete
C          ISTRUC=3    for Eichten, Hinchliffe, Lane, and Quigg (1984)
C                      solution 1
C          ISTRUC=4    Duke and Owens, Phys. Rev. D30, 49.
C                      solution 1
C          ISTRUC=5    CTEQ Collaboration, Phys. Lett. 304B, 159
C                      fit CTEQ2L (lowest order QCD)
C          ISTRUC=6    CTEQ Collaboration, Phys. Rev. D51, 4763 (1995)
C                      fit CTEQ3L (lowest order QCD)
C          ISTRUC=-999 PDFLIB interface. Parameters are passed by call
C                      to PDFSET in READIN.
C          Quark types--
C          IQ=1  2  3  4  5  6  7  8  9  10 11 12 13
C             GL UP UB DN DB ST SB CH CB BT BB TP TB
C          Hadron types--
C          IH=+1120  -1120  +1220  -1220
C                 P     AP      N     AN
C
C          For IBM compatibility require STRUC > SFMIN = 1.E-10
C          Ver. 7.23: Simplify type mapping and fix PDF error for pbar
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
C          E1STRC contains all the coefficients for Eichten, etal,
C          solution 1. It is equivalenced to arrays for the 16 sets of
C          coefficients.
      DIMENSION E1STRC(6,6,16),E1POW(8),IE1FIT(13)
      DIMENSION E1UPHI(6,6),E1DNHI(6,6),E1UBHI(6,6),E1GLHI(6,6),
     $E1STHI(6,6),E1CHHI(6,6),E1BTHI(6,6),E1TPHI(6,6)
      DIMENSION E1UPLO(6,6),E1DNLO(6,6),E1UBLO(6,6),E1GLLO(6,6),
     $E1STLO(6,6),E1CHLO(6,6),E1BTLO(6,6),E1TPLO(6,6)
      EQUIVALENCE (E1UPHI(1,1),E1STRC(1,1,1))
      EQUIVALENCE (E1DNHI(1,1),E1STRC(1,1,2))
      EQUIVALENCE (E1UBHI(1,1),E1STRC(1,1,3))
      EQUIVALENCE (E1GLHI(1,1),E1STRC(1,1,4))
      EQUIVALENCE (E1STHI(1,1),E1STRC(1,1,5))
      EQUIVALENCE (E1CHHI(1,1),E1STRC(1,1,6))
      EQUIVALENCE (E1BTHI(1,1),E1STRC(1,1,7))
      EQUIVALENCE (E1TPHI(1,1),E1STRC(1,1,8))
      EQUIVALENCE (E1UPLO(1,1),E1STRC(1,1,9))
      EQUIVALENCE (E1DNLO(1,1),E1STRC(1,1,10))
      EQUIVALENCE (E1UBLO(1,1),E1STRC(1,1,11))
      EQUIVALENCE (E1GLLO(1,1),E1STRC(1,1,12))
      EQUIVALENCE (E1STLO(1,1),E1STRC(1,1,13))
      EQUIVALENCE (E1CHLO(1,1),E1STRC(1,1,14))
      EQUIVALENCE (E1BTLO(1,1),E1STRC(1,1,15))
      EQUIVALENCE (E1TPLO(1,1),E1STRC(1,1,16))
      DIMENSION CHEBX(6),CHEBQ(6)
C
      REAL X,QSQ,STRUC
      REAL BETA,CHEB1,CHEB2,CHEB3,CHEB4,CHEB5,AMASS,E1POW,FD,CHEBX,
     $E1STRC,E1UPHI,CHEBQ,AD,ETA3,GUD,ETA2,ETA4,FUD,AUD,GD,E1GLLO,
     $E1UBLO,E1DNLO,E1STLO,E1TPLO,E1BTLO,E1CHLO,E1UPLO,E1GLHI,E1UBHI,
     $E1DNHI,E1STHI,E1TPHI,E1BTHI,ETA1,T,TMAX,TMIN,AMQ,Q2MIN,W2,W1,
     $SFMIN,T1,A1,A0,SS,B1,C2,B2,A2,S,X1,TERM,E1CHHI,Q2,GAMMA
      INTEGER IQ,IH
      INTEGER IE1FIT,IFIT,IFIT2,JX,JQ,ISHFT,IIQ
C          CTEQ declarations
      REAL A3,A4,A5,SBL,QI,Q,SB,SB2,SB3
      INTEGER IFL
      INTEGER IQPB(13),IQN(13),IQNB(13)
      DOUBLE PRECISION SEA,VAL,P012,P34,P5
C          PDFLIB declarations
C
C          Map pbar, n, nbar types to p type
      DATA IQPB/1,3,2,5,4,7,6,9,8,11,10,13,12/
      DATA IQN /1,4,5,2,3,6,7,8,9,10,11,12,13/
      DATA IQNB/1,5,4,3,2,7,6,9,8,11,10,13,12/
C
C          Eichten etal solution 1 constants
C          corrected coefficients from Ian Hinchliffe, 3 June 1986.
      DATA E1UPHI/
     $  0.76772, -0.20874, -0.33026, -0.02517, -0.01570, -0.00010,
     $ -0.53259, -0.26612,  0.32007,  0.11918,  0.02434,  0.00762,
     $  0.21618,  0.18812, -0.08375, -0.06515, -0.01743, -0.00504,
     $ -0.09211, -0.09952,  0.01373,  0.02506,  0.00877,  0.00255,
     $  0.03670,  0.04409,  0.00096, -0.00796, -0.00342, -0.00105,
     $ -0.01549, -0.02026, -0.00306,  0.00222,  0.00124,  0.00041/
      DATA E1DNHI/
     $  0.38130, -0.08090, -0.16336, -0.02185, -0.00843, -0.00062,
     $ -0.29475, -0.14348,  0.16650,  0.06638,  0.01473,  0.00408,
     $  0.12518,  0.10422, -0.04722, -0.03683, -0.01038, -0.00286,
     $ -0.05478, -0.05678,  0.00890,  0.01484,  0.00534,  0.00152,
     $  0.02220,  0.02567, -0.00003, -0.00497, -0.00216, -0.00065,
     $ -0.00953, -0.01204, -0.00151,  0.00151,  0.00083,  0.00027/
      DATA E1UBHI/
     $  0.06870, -0.06861,  0.02973, -0.00540,  0.00378, -0.00097,
     $ -0.01802,  0.00014,  0.00649, -0.00854,  0.00122, -0.00175,
     $ -0.00465,  0.00148, -0.00593,  0.00060, -0.00103, -0.00008,
     $  0.00644,  0.00257,  0.00283,  0.00115,  0.00071,  0.00033,
     $ -0.00393, -0.00254, -0.00116, -0.00077, -0.00036, -0.00019,
     $  0.00234,  0.00193,  0.00053,  0.00037,  0.00016,  0.00009/
      DATA E1GLHI/
     $  0.94819, -0.95779,  0.10085, -0.10510,  0.03456, -0.03054,
     $ -0.96265,  0.53790,  0.33684, -0.09525,  0.01488, -0.02051,
     $  0.43004, -0.08306, -0.33719,  0.04902, -0.00916,  0.01041,
     $ -0.19249, -0.01790,  0.21830,  0.00749,  0.00414, -0.00186,
     $  0.08183,  0.01926, -0.10718, -0.01944, -0.00277, -0.00052,
     $ -0.03884, -0.01234,  0.05410,  0.01879,  0.00335,  0.00104/
      DATA E1STHI/
     $  0.04968, -0.04173,  0.02102, -0.00327,  0.00324, -0.00067,
     $ -0.00615, -0.01294,  0.00674, -0.00689,  0.00090, -0.00151,
     $ -0.00858,  0.00505, -0.00490, -0.00016, -0.00094, -0.00015,
     $  0.00784,  0.00151,  0.00222,  0.00140,  0.00070,  0.00035,
     $ -0.00441, -0.00222, -0.00089, -0.00085, -0.00036, -0.00020,
     $  0.00252,  0.00184,  0.00041,  0.00039,  0.00016,  0.00009/
      DATA E1CHHI/
     $  0.00927, -0.01817,  0.00959, -0.00639,  0.00169, -0.00154,
     $  0.00571, -0.01188,  0.00609, -0.00465,  0.00124, -0.00131,
     $ -0.00396,  0.00710, -0.00359,  0.00184, -0.00039,  0.00034,
     $  0.00112, -0.00196,  0.00112, -0.00048,  0.00010, -0.00004,
     $  0.00004, -0.00003, -0.00018,  0.00009, -0.00005, -0.00002,
     $ -0.00042,  0.00073, -0.00016,  0.00005,  0.00005,  0.00005/
      DATA E1BTHI/
     $  0.00901, -0.01401,  0.00715, -0.00413,  0.00126, -0.00104,
     $  0.00628, -0.00932,  0.00478, -0.00289,  0.00091, -0.00082,
     $ -0.00293,  0.00409, -0.00189,  0.00076, -0.00023,  0.00014,
     $  0.00039, -0.00120,  0.00044, -0.00025,  0.00002, -0.00002,
     $  0.00026,  0.00014, -0.00008,  0.00010,  0.00001,  0.00001,
     $ -0.00026,  0.00032,  0.00001, -0.00001,  0.00001, -0.00001/
      DATA E1TPHI/
     $  0.00441, -0.00748,  0.00377, -0.00258,  0.00073, -0.00071,
     $  0.00384, -0.00605,  0.00303, -0.00203,  0.00058, -0.00059,
     $ -0.00088,  0.00166, -0.00075,  0.00047, -0.00010,  0.00010,
     $ -0.00008, -0.00015,  0.00012, -0.00009,  0.00003,  0.00000,
     $  0.00013, -0.00022, -0.00002, -0.00002, -0.00002, -0.00002,
     $ -0.00007,  0.00019, -0.00004,  0.00002,  0.00000,  0.00000/
      DATA E1UPLO/
     $  0.23946,  0.29055,  0.09778,  0.02149,  0.00344,  0.00050,
     $  0.01751, -0.00609, -0.02687, -0.01916, -0.00797, -0.00275,
     $ -0.00576, -0.00504,  0.00108,  0.00249,  0.00153,  0.00075,
     $  0.00174,  0.00196,  0.00030, -0.00034, -0.00029, -0.00018,
     $ -0.00053, -0.00064, -0.00017,  0.00004,  0.00006,  0.00004,
     $  0.00017,  0.00022,  0.00008,  0.00001, -0.00001, -0.00001/
      DATA E1DNLO/
     $  0.12613,  0.13542,  0.03958,  0.00824,  0.00166,  0.00045,
     $  0.00389, -0.01159, -0.01625, -0.00961, -0.00371, -0.00126,
     $ -0.00191, -0.00056,  0.00159,  0.00159,  0.00084,  0.00039,
     $  0.00064,  0.00049, -0.00015, -0.00029, -0.00018, -0.00010,
     $ -0.00020, -0.00019,  0.00000,  0.00006,  0.00004,  0.00003,
     $  0.00007,  0.00008,  0.00002, -0.00001, -0.00001, -0.00001/
      DATA E1UBLO/
     $  1.01386, -1.10585,  0.33739, -0.07444,  0.00885, -0.00087,
     $  0.92334, -1.28541,  0.44755, -0.09786,  0.01419, -0.00112,
     $  0.04888, -0.12708,  0.08606, -0.02608,  0.00478, -0.00060,
     $ -0.02691,  0.04887, -0.01771,  0.00162,  0.00025, -0.00006,
     $  0.00704, -0.01113,  0.00159,  0.00070, -0.00020,  0.00000,
     $ -0.00171,  0.00229,  0.00038, -0.00035,  0.00004,  0.00001/
      DATA E1GLLO/
     $ 29.47734,-39.02468, 14.63570, -3.33516,  0.50538, -0.05915,
     $ 25.58960,-39.54527, 16.61420, -4.29861,  0.69036, -0.08243,
     $ -1.66291,  1.17624,  1.11844, -0.70986,  0.19481, -0.02404,
     $ -0.21679,  0.81705, -0.71688,  0.18507, -0.01924, -0.00325,
     $  0.20880, -0.43547,  0.22391, -0.02446, -0.00362,  0.00191,
     $ -0.09097,  0.16009, -0.05681, -0.00250,  0.00258, -0.00047/
      DATA E1STLO/
     $  0.92351, -1.08483,  0.34642, -0.07210,  0.00914, -0.00091,
     $  0.93146, -1.27376,  0.45122, -0.09775,  0.01380, -0.00131,
     $  0.04739, -0.12960,  0.08482, -0.02642,  0.00476, -0.00057,
     $ -0.02653,  0.04953, -0.01735,  0.00175,  0.00028, -0.00006,
     $  0.00694, -0.01132,  0.00148,  0.00065, -0.00021,  0.00000,
     $ -0.00168,  0.00234,  0.00042, -0.00034,  0.00005,  0.00001/
      DATA E1CHLO/
     $  0.80983, -1.04168,  0.33980, -0.06824,  0.00876, -0.00090,
     $  0.89606, -1.21708,  0.43386, -0.09287,  0.01304, -0.00129,
     $  0.03058, -0.10402,  0.07604, -0.02415,  0.00460, -0.00050,
     $ -0.02451,  0.04432, -0.01651,  0.00143,  0.00012, -0.00010,
     $  0.01122, -0.01457,  0.00268,  0.00058, -0.00012,  0.00003,
     $ -0.00773,  0.00733, -0.00076, -0.00024,  0.00001,  0.00000/
      DATA E1BTLO/
     $  0.80288, -1.07532,  0.37920, -0.07843,  0.01007, -0.00109,
     $  0.79033, -1.09887,  0.41532, -0.09301,  0.01317, -0.00141,
     $ -0.01704, -0.01130,  0.02882, -0.01341,  0.00304, -0.00036,
     $ -0.00072,  0.00723, -0.00516,  0.00108, -0.00005, -0.00004,
     $  0.00305, -0.00461,  0.00166, -0.00013, -0.00001,  0.00001,
     $ -0.00436,  0.00523, -0.00161,  0.00020, -0.00002,  0.00000/
      DATA E1TPLO/
     $  0.66233, -0.92481,  0.35193, -0.07930,  0.01110, -0.00118,
     $  0.63797, -0.90619,  0.35816, -0.08479,  0.01265, -0.00139,
     $ -0.02581,  0.02125,  0.00419, -0.00498,  0.00149, -0.00021,
     $  0.00071,  0.00053, -0.00127,  0.00039, -0.00005, -0.00001,
     $  0.00385, -0.00506,  0.00186, -0.00035,  0.00004,  0.00000,
     $ -0.00353,  0.00446, -0.00150,  0.00027, -0.00003,  0.00000/
C          E1POW gives powers of (1-x).
C          IE1FIT points to fit for each value of IQ.
      DATA E1POW/3.,4.,7.,5.,7.,7.,7.,7./
      DATA IE1FIT/4,1,3,2,3,5,5,6,6,7,7,8,8/
C          Minimum value for STRUC
      DATA SFMIN/1.E-10/
C
      BETA(W1,W2)=GAMMA(W1)*GAMMA(W2)/GAMMA(W1+W2)
C          Chebyshev polynomials
      CHEB1(X)=X
      CHEB2(X)=2.*X**2-1.
      CHEB3(X)=X*(-3.+4.*X**2)
      CHEB4(X)=1.+X**2*(-8.+8.*X**2)
      CHEB5(X)=X*(5.+X**2*(-20.+16.*X**2))
C
C          Entry -- check for unphysical X
C
      IF(X.LE.0..OR.X.GE..9999) THEN
        STRUC=0.
        GO TO 9999
      ENDIF
C
C          Determine equivalent quark type IIQ for proton
C
      IF(IH.EQ.1120) THEN
        IIQ=IQ
      ELSEIF(IH.EQ.-1120) THEN
        IIQ=IQPB(IQ)
      ELSEIF(IH.EQ.1220) THEN
        IIQ=IQN(IQ)
      ELSEIF(IH.EQ.-1220) THEN
        IIQ=IQNB(IQ)
      ELSE
C          This should never happen
        STRUC=0
        RETURN
      ENDIF
C
C          Select structure function fit.
C
      IF(ISTRUC.EQ.3) GO TO 1000
      IF(ISTRUC.EQ.4) GO TO 2000
      IF(ISTRUC.EQ.5) GO TO 3000
      IF(ISTRUC.EQ.6) GO TO 3100
      STRUC=0.
      GO TO 9999
C
C          Calculate Eichten etal structure fcn for type IIQ
C
1000  STRUC=0.
      Q2=QSQ
      IF(Q2.LT.5.) Q2=5.
      T=ALOG(Q2/ALAM2)
      TMAX=ALOG(1.E8/ALAM2)
      IF(IIQ.GT.9) GO TO 1001
      Q2MIN=5.
      GO TO 1002
1001  AMQ=AMASS(IIQ/2)
      Q2MIN=4.*AMQ**2/(1.-X)
      IF(Q2.LT.Q2MIN) GO TO 9999
1002  TMIN=ALOG(Q2MIN/ALAM2)
      T1=(2.*T-(TMAX+TMIN))/(TMAX-TMIN)
      CHEBQ(1)=1.
      CHEBQ(2)=CHEB1(T1)
      CHEBQ(3)=CHEB2(T1)
      CHEBQ(4)=CHEB3(T1)
      CHEBQ(5)=CHEB4(T1)
      CHEBQ(6)=CHEB5(T1)
C          x.gt.0.1
      IF(X.LT.0.1) GO TO 1010
      X1=(2.*X-1.1)/.9
      ISHFT=0
      GO TO 1020
C          x.lt.0.1
1010  X1=(2.*ALOG(X)+11.51293)/6.90776
      ISHFT=8
C          IFIT is pointer for Eichten quark type.
C          IFIT2 is pointer for function -- shifted by 8 for x<0.1
1020  IFIT=IE1FIT(IIQ)
      IFIT2=IFIT+ISHFT
      CHEBX(1)=1.
      CHEBX(2)=CHEB1(X1)
      CHEBX(3)=CHEB2(X1)
      CHEBX(4)=CHEB3(X1)
      CHEBX(5)=CHEB4(X1)
      CHEBX(6)=CHEB5(X1)
      TERM=0.
      DO 1030 JQ=1,6
      DO 1030 JX=1,6
1030  TERM=TERM+E1STRC(JX,JQ,IFIT2)*CHEBQ(JQ)*CHEBX(JX)
      TERM=TERM*(1.-X)**E1POW(IFIT)
      STRUC=ABS(TERM)
      IF(IFIT.GT.2) GO TO 9999
C          Add sea term for valence quarks
      TERM=0.
      DO 1040 JQ=1,6
      DO 1040 JX=1,6
1040  TERM=TERM+E1STRC(JX,JQ,3+ISHFT)*CHEBQ(JQ)*CHEBX(JX)
      TERM=TERM*(1.-X)**E1POW(3)
      STRUC=STRUC+ABS(TERM)
      GO TO 9999
C
C          Calculate Duke-Owens structure function for type IIQ.
C
2000  STRUC=0.
      Q2=QSQ
      IF(Q2.LT.4.) Q2=4.
      S=ALOG(ALOG(Q2/ALAM2)/ALOG(4./ALAM2))
      SS=S*S
C          x*f(x) for gl
      IF(IIQ.EQ.1) THEN
        A0=1.56-1.71*S+.638*SS
        A1=-0.949*S+.325*SS
        B1=6.+1.44*S-1.05*SS
        A2=9.-7.19*S+.255*SS
        B2=-16.5*S+10.9*SS
        C2=15.3*S-10.1*SS
        STRUC=A0*X**A1*(1.-X)**B1*(1.+A2*X+B2*X**2+C2*X**3)
C          x*f(x) for up,ub,dn,db,st,sb
      ELSEIF(IIQ.LE.7) THEN
        A0=1.265-1.132*S+.293*SS
        A1=-.372*S-.029*SS
        B1=8.05+1.59*S-.153*SS
        A2=6.31*S-.273*SS
        B2=-10.5*S-3.17*SS
        C2=14.7*S+9.80*SS
        STRUC=A0*X**A1*(1.-X)**B1*(1.+A2*X+B2*X**2+C2*X**3)/6.
        IF(IIQ.EQ.2.OR.IIQ.EQ.4) THEN
          ETA1=.419+.004*S-.007*SS
          ETA2=3.46+.724*S-.066*SS
          GUD=4.40-4.86*S+1.33*SS
          ETA3=.763-.237*S+.026*SS
          ETA4=4.00+.627*S-.019*SS
          GD=-.421*S+.033*SS
          AUD=3./(BETA(ETA1,ETA2+1.)*(1.+GUD*ETA1/(ETA1+ETA2+1.)))
          FUD=AUD*X**ETA1*(1.-X)**ETA2*(1.+GUD*X)
          AD=1./(BETA(ETA3,ETA4+1.)*(1.+GD*ETA3/(ETA3+ETA4+1.)))
          FD=AD*X**ETA3*(1.-X)**ETA4*(1.+GD*X)
          IF(IIQ.EQ.2) STRUC=STRUC+FUD-FD
          IF(IIQ.EQ.4) STRUC=STRUC+FD
        ENDIF
C          x*f(x) for ch,cb
      ELSEIF(IIQ.LE.9) THEN
        A0=.135*S-.0075*SS
        A1=-.036-.222*S-.058*SS
        B1=6.35+3.26*S-.909*SS
        A2=-3.03*S+1.50*SS
        B2=17.4*S-11.3*SS
        C2=-17.9*S+15.6*SS
        STRUC=A0*X**A1*(1.-X)**B1*(1.+A2*X+B2*X**2+C2*X**3)
C          x*f(x)=0 for bt,bb,tp,tb
      ELSE
        STRUC=0.
      ENDIF
      GO TO 9999
C
C          Calculate CTEQ2L distribution for type IIQ
C
3000  STRUC=0
      IFL=IIQ/2
C          Set up thresholds
      Q=SQRT(QSQ)
      IF(IFL.LE.4) THEN
        QI=1.6
      ELSEIF(IFL.EQ.5) THEN
        QI=5.0
      ELSEIF(IFL.EQ.6) THEN
        QI=180
      ELSE
        RETURN
      ENDIF
      IF(Q.LT.QI) THEN
        Q=QI
        IF(IFL.GE.4) GO TO 9999
      ENDIF
C          Hard code lambda=0.190
      SBL=LOG(Q/0.190)/LOG(QI/0.190)
      SB=LOG (SBL)
      SB2=SB*SB
      SB3=SB2*SB
C          Calculate sea part
      IF(IFL.EQ.0) THEN
        A0=EXP(-0.6510E+00-0.1128E+01*SB-0.6239E-01*SB2-0.8838E-01*SB3)
        A1=-0.2590E+00+0.1822E+00*SB-0.2682E+00*SB2+0.9422E-01*SB3
        A2= 0.4607E+01+0.7792E+00*SB+0.8937E+00*SB2-0.5553E+00*SB3
        A3= 0.1627E+02-0.1114E+02*SB+0.4928E+01*SB2-0.1715E+01*SB3
        A4= 0.1236E+01+0.1945E+00*SB-0.3297E+00*SB2+0.6489E-01*SB3
        A5= 0.0000E+00+0.3346E+01*SB-0.2337E+01*SB2+0.7850E+00*SB3
      ELSEIF(IFL.EQ.1) THEN
        A0=EXP(-0.1508E+01-0.5560E+00*SB-0.3523E+00*SB2+0.6562E-01*SB3)
        A1=-0.3223E+00+0.2095E-01*SB-0.2049E-02*SB2-0.3475E-01*SB3
        A2= 0.9469E+01-0.3923E+01*SB+0.4333E+01*SB2-0.1654E+01*SB3
        A3= 0.1646E+02-0.1082E+02*SB+0.8941E+01*SB2-0.5494E+01*SB3
        A4= 0.2908E+01+0.2162E+01*SB-0.3233E+01*SB2+0.1267E+01*SB3
        A5=-0.5819E+00+0.3914E+00*SB+0.6460E+00*SB2-0.3239E+00*SB3
      ELSEIF(IFL.EQ.2) THEN
        A0=EXP(-0.1951E+01-0.3435E+01*SB+0.3424E+01*SB2-0.1249E+01*SB3)
        A1=-0.2942E+00+0.4408E+00*SB-0.5453E+00*SB2+0.1552E+00*SB3
        A2= 0.9782E+01-0.3454E+01*SB+0.4510E+01*SB2-0.1649E+01*SB3
        A3= 0.4999E+02-0.1993E+02*SB-0.2039E+01*SB2+0.5694E+00*SB3
        A4= 0.1938E+01-0.1351E+01*SB+0.1386E+01*SB2-0.5324E+00*SB3
        A5=-0.2410E+00+0.3434E+01*SB-0.3334E+01*SB2+0.1067E+01*SB3
      ELSEIF(IFL.EQ.3) THEN
        A0=EXP(-0.1804E+01-0.4381E+01*SB-0.3699E+00*SB2+0.3878E+00*SB3)
        A1=-0.1000E-02-0.9334E+00*SB+0.7156E+00*SB2-0.2029E+00*SB3
        A2= 0.6896E+01+0.2462E+01*SB-0.2885E+01*SB2+0.8701E+00*SB3
        A3= 0.0000E+00+0.5589E+01*SB+0.1047E+02*SB2+0.3000E+02*SB3
        A4= 0.1000E-02-0.5600E-02*SB+0.5618E-02*SB2+0.6598E-02*SB3
        A5= 0.0000E+00-0.3151E+01*SB+0.4025E+01*SB2-0.1232E+01*SB3
      ELSEIF(IFL.EQ.4) THEN
        A0=SB**0.7860E+00*EXP(-0.5041E+01-0.3357E+00*SB-0.4718E+00*SB2)
        A1=-0.4989E+00+0.9571E+00*SB-0.1359E+01*SB2+0.5384E+00*SB3
        A2= 0.5986E+01-0.8541E+01*SB+0.1274E+02*SB2-0.5275E+01*SB3
        A3= 0.8121E+01-0.1753E+02*SB+0.2194E+02*SB2-0.8538E+01*SB3
        A4= 0.9290E-01-0.4390E+00*SB+0.6162E+00*SB2-0.2231E+00*SB3
        A5=-0.1257E+01+0.5677E+01*SB-0.5977E+01*SB2+0.2387E+01*SB3
      ELSEIF(IFL.EQ.5) THEN
        A0=SB**0.4537E+00*EXP(-0.3269E+01-0.5398E+01*SB+0.2893E+01*SB2)
        A1=-0.1977E+00-0.4126E+00*SB+0.7058E+00*SB2-0.4038E+00*SB3
        A2= 0.4522E+01+0.6167E-01*SB-0.1849E+00*SB2+0.7345E+00*SB3
        A3=-0.1003E+01+0.1531E+01*SB+0.4515E+01*SB2-0.4368E+01*SB3
        A4= 0.3579E-01+0.1919E+00*SB-0.7268E+00*SB2+0.5192E+00*SB3
        A5= 0.5129E+00+0.2447E+01*SB-0.1989E+01*SB2+0.7529E+00*SB3
      ELSEIF(IFL.EQ.6) THEN
        A0=SB**0.7178E+00*EXP(-0.7327E+01+0.2277E+01*SB+0.3913E+01*SB2)
        A1=-0.9842E-01-0.2362E+01*SB+0.8851E+01*SB2-0.7208E+01*SB3
        A2= 0.5552E+01-0.8935E+01*SB+0.2676E+02*SB2-0.1344E+02*SB3
        A3= 0.1593E+01-0.3505E+01*SB-0.1234E+01*SB2-0.1867E+02*SB3
        A4=-0.1723E+00+0.1530E+01*SB+0.2323E+01*SB2-0.9344E+01*SB3
        A5= 0.2081E+01+0.1939E+01*SB-0.3273E+01*SB2+0.9935E+01*SB3
      ENDIF
      P012=A0*(X**A1)*((1.-X)**A2)
      P34=(1.+A3*(X**A4))
      P5=(LOG(1.+1./X))**A5
      SEA=P012*P34*P5
C          Add valence part
      IF(IIQ.NE.2.AND.IIQ.NE.4) THEN
        STRUC=SEA
        GO TO 9999
      ELSEIF(IIQ.EQ.2) THEN
        A0=EXP(-0.1806E+01-0.6672E-01*SB-0.2605E+00*SB2+0.2341E-01*SB3)
        A1= 0.1750E+00+0.3872E-01*SB-0.2189E-01*SB2+0.1415E-01*SB3
        A2= 0.3322E+01+0.7786E+00*SB-0.2902E+00*SB2+0.1517E+00*SB3
        A3= 0.4414E+02-0.1987E+02*SB+0.2597E+01*SB2+0.2670E+01*SB3
        A4= 0.9610E+00-0.2864E+00*SB-0.5524E-01*SB2+0.6229E-01*SB3
        A5= 0.0000E+00+0.2658E+00*SB-0.4728E-02*SB2+0.6048E-01*SB3
      ELSEIF(IIQ.EQ.4) THEN
        A0=EXP( 0.8000E-01+0.7364E+00*SB-0.2714E+01*SB2+0.1311E+01*SB3)
        A1= 0.4930E+00-0.2001E+00*SB+0.5784E+00*SB2-0.2915E+00*SB3
        A2= 0.3001E+01+0.3538E+01*SB-0.6155E+01*SB2+0.3083E+01*SB3
        A3=-0.1000E+01+0.3871E+01*SB-0.8334E+01*SB2+0.4219E+01*SB3
        A4= 0.2986E+01+0.1597E+01*SB-0.3368E+01*SB2+0.1644E+01*SB3
        A5= 0.0000E+00-0.9256E+00*SB+0.3570E+01*SB2-0.1777E+01*SB3
      ENDIF
      P012=A0*(X**A1)*((1.-X)**A2)
      P34=(1.+A3*(X**A4))
      P5=(LOG(1.+1./X))**A5
      VAL=P012*P34*P5
      STRUC=VAL+SEA
      GO TO 9999
C
C          Calculate CTEQ3L distribution for type IIQ
C
3100  STRUC=0
      IFL=IIQ/2
C          Set up thresholds
      Q=SQRT(QSQ)
      IF(IFL.LE.4) THEN
        QI=1.6
      ELSEIF(IFL.EQ.5) THEN
        QI=5.0
      ELSEIF(IFL.EQ.6) THEN
        QI=180
      ELSE
        RETURN
      ENDIF
      IF(Q.LT.QI) THEN
        Q=QI
        IF(IFL.GE.4) GO TO 9999
      ENDIF
C          Hard code lambda=0.177
      SBL=LOG(Q/0.177)/LOG(QI/0.177)
      SB=LOG (SBL)
      SB2=SB*SB
      SB3=SB2*SB
C          Calculate sea part
      IF(IFL.EQ.0) THEN
        A0=Exp(-0.7631E+00-0.7241E+00*SB -0.1170E+01*SB2+0.5343E+00*SB3)
        A1=-0.3573E+00+0.3469E+00*SB -0.3396E+00*SB2+0.9188E-01*SB3
        A2= 0.5604E+01+0.7458E+00*SB -0.5082E+00*SB2+0.1844E+00*SB3
        A3= 0.1549E+02-0.1809E+02*SB +0.1162E+02*SB2-0.3483E+01*SB3
        A4= 0.9881E+00+0.1364E+00*SB -0.4421E+00*SB2+0.2051E+00*SB3
        A5=-0.9505E-01+0.3259E+01*SB -0.1547E+01*SB2+0.2918E+00*SB3
      ELSEIF(IFL.EQ.1) THEN
        A0=Exp(-0.2740E+01-0.7987E-01*SB -0.9015E+00*SB2-0.9872E-01*SB3)
        A1=-0.3909E+00+0.1244E+00*SB -0.4487E-01*SB2+0.1277E-01*SB3
        A2= 0.9163E+01+0.2823E+00*SB -0.7720E+00*SB2-0.9360E-02*SB3
        A3= 0.1080E+02-0.3915E+01*SB -0.1153E+01*SB2+0.2649E+01*SB3
        A4= 0.9894E+00-0.1647E+00*SB -0.9426E-02*SB2+0.2945E-02*SB3
        A5=-0.3395E+00+0.6998E+00*SB +0.7000E+00*SB2-0.6730E-01*SB3
      ELSEIF(IFL.EQ.2) THEN
        A0=Exp(-0.2449E+01-0.3513E+01*SB +0.4529E+01*SB2-0.2031E+01*SB3)
        A1=-0.4050E+00+0.3411E+00*SB -0.3669E+00*SB2+0.1109E+00*SB3
        A2= 0.7470E+01-0.2982E+01*SB +0.5503E+01*SB2-0.2419E+01*SB3
        A3= 0.1503E+02+0.1638E+01*SB -0.8772E+01*SB2+0.3852E+01*SB3
        A4= 0.1137E+01-0.1006E+01*SB +0.1485E+01*SB2-0.6389E+00*SB3
        A5=-0.5299E+00+0.3160E+01*SB -0.3104E+01*SB2+0.1219E+01*SB3
      ELSEIF(IFL.EQ.3) THEN
        A0=Exp(-0.3640E+01+0.1250E+01*SB -0.2914E+01*SB2+0.8390E+00*SB3)
        A1=-0.3595E+00-0.5259E-01*SB +0.3122E+00*SB2-0.1642E+00*SB3
        A2= 0.7305E+01+0.9727E+00*SB -0.9788E+00*SB2-0.5193E-01*SB3
        A3= 0.1198E+02-0.1799E+02*SB +0.2614E+02*SB2-0.1091E+02*SB3
        A4= 0.9882E+00-0.6101E+00*SB +0.9737E+00*SB2-0.4935E+00*SB3
        A5=-0.1186E+00-0.3231E+00*SB +0.3074E+01*SB2-0.1274E+01*SB3
      ELSEIF(IFL.EQ.4) THEN
        A0=SB**0.1122E+01*Exp(-0.3718E+01-0.1335E+01*SB +0.1651E-01*SB2)
        A1=-0.4719E+00+0.7509E+00*SB -0.8420E+00*SB2+0.2901E+00*SB3
        A2= 0.6194E+01-0.1641E+01*SB +0.4907E+01*SB2-0.2523E+01*SB3
        A3= 0.4426E+01-0.4270E+01*SB +0.6581E+01*SB2-0.3474E+01*SB3
        A4= 0.2683E+00+0.9876E+00*SB -0.7612E+00*SB2+0.1780E+00*SB3
        A5=-0.4547E+00+0.4410E+01*SB -0.3712E+01*SB2+0.1245E+01*SB3
      ELSEIF(IFL.EQ.5) THEN
        A0=SB**0.9838E+00*Exp(-0.2548E+01-0.7660E+01*SB +0.3702E+01*SB2)
        A1=-0.3122E+00-0.2120E+00*SB +0.5716E+00*SB2-0.3773E+00*SB3
        A2= 0.6257E+01-0.8214E-01*SB -0.2537E+01*SB2+0.2981E+01*SB3
        A3=-0.6723E+00+0.2131E+01*SB +0.9599E+01*SB2-0.7910E+01*SB3
        A4= 0.9169E-01+0.4295E-01*SB -0.5017E+00*SB2+0.3811E+00*SB3
        A5= 0.2402E+00+0.2656E+01*SB -0.1586E+01*SB2+0.2880E+00*SB3
      ELSEIF(IFL.EQ.6) THEN
        A0=SB**0.1001E+01*Exp(-0.6934E+01+0.3050E+01*SB -0.6943E+00*SB2)
        A1=-0.1713E+00-0.5167E+00*SB +0.1241E+01*SB2-0.1703E+01*SB3
        A2= 0.6169E+01+0.3023E+01*SB -0.1972E+02*SB2+0.1069E+02*SB3
        A3= 0.4439E+01-0.1746E+02*SB +0.1225E+02*SB2+0.8350E+00*SB3
        A4= 0.5458E+00-0.4586E+00*SB +0.9089E+00*SB2-0.4049E+00*SB3
        A5= 0.3207E+01-0.3362E+01*SB +0.5877E+01*SB2-0.7659E+01*SB3
      ENDIF
      P012=A0*(X**A1)*((1.-X)**A2)
      P34=(1.+A3*(X**A4))
      P5=(LOG(1.+1./X))**A5
      SEA=P012*P34*P5
C          Add valence part
      IF(IIQ.NE.2.AND.IIQ.NE.4) THEN
        STRUC=SEA
        GO TO 9999
      ELSEIF(IIQ.EQ.2) THEN
        A0=Exp( 0.1907E+00+0.4205E-01*SB +0.2752E+00*SB2-0.3171E+00*SB3)
        A1= 0.4611E+00+0.2331E-01*SB -0.3403E-01*SB2+0.3174E-01*SB3
        A2= 0.3504E+01+0.5739E+00*SB +0.2676E+00*SB2-0.1553E+00*SB3
        A3= 0.7452E+01-0.6742E+01*SB +0.2849E+01*SB2-0.1964E+00*SB3
        A4= 0.1116E+01-0.3435E+00*SB +0.2865E+00*SB2-0.1288E+00*SB3
        A5= 0.6659E-01+0.2714E+00*SB -0.2688E+00*SB2+0.2763E+00*SB3
      ELSEIF(IIQ.EQ.4) THEN
        A0=Exp( 0.1141E+00+0.4764E+00*SB -0.1745E+01*SB2+0.7728E+00*SB3)
        A1= 0.4275E+00-0.1290E+00*SB +0.3609E+00*SB2-0.1689E+00*SB3
        A2= 0.3000E+01+0.2946E+01*SB -0.4117E+01*SB2+0.1989E+01*SB3
        A3=-0.1302E+01+0.2322E+01*SB -0.4258E+01*SB2+0.2109E+01*SB3
        A4= 0.2586E+01-0.1920E+00*SB -0.3754E+00*SB2+0.2731E+00*SB3
        A5=-0.2251E+00-0.5374E+00*SB +0.2245E+01*SB2-0.1034E+01*SB3
      ENDIF
      P012=A0*(X**A1)*((1.-X)**A2)
      P34=(1.+A3*(X**A4))
      P5=(LOG(1.+1./X))**A5
      VAL=P012*P34*P5
      STRUC=VAL+SEA
      GO TO 9999
C
C          Calculate PDFLIB distributions and return one for type IIQ.
C
C
C          Require minimum value for STRUC
C
9999  IF(STRUC.LT.SFMIN) STRUC=SFMIN
      RETURN
      END
CDECK  ID>, STRUCW. 
      FUNCTION STRUCW(XW,IW,IH)
C
C          LONGITUDINAL W STRUCTURE FUNCTIONS CALCULATED BY CONVOLUTION
C          OF EHLQ STRUCTURE FUNCTIONS AT Q**2=AMW**2 WITH F(W/Q) FROM
C          DAWSON, N.P. B249, 42 (1985).
C          IW = 1   2   3   4
C               GM  W+  W-  Z0
C          WARNING: DEFAULT VALUES ONLY FOR LAMBDA, SIN2W, ETC.
C
      DOUBLE PRECISION X,XLOG
C          FOLLOWING CONSTANTS ARE (CV**2+CA**2)/(4*PI**2)
      DATA CVAW/2.701E-3/,CVAZUU/1.017E-3/,CVAZDD/1.298E-3/
C
C          STATEMENT FUNCTIONS CALCULATED BY INTEGRATING EACH TERM IN
C          EHLQ PARAMETERIZATION USING SMP 1.5.0.
C
C          FROM STRUCW2.EX
      FUVAL(X) = 5.769575427 - 10.13681547*X + 3.042561145*XLOG -
     $ 0.2798411214*(1./X) - 0.3404284678*(XLOG/X) + 8.296794608*(X**2)
     $ - 6.017283047*(X**3) + 3.548706099*(X**4) - 1.560232679*(X**5)
     $ + 0.4342326806*(X**6) - 0.05513649922*(X**7)
C
      FDVAL(X) = 2.533753356 - 4.57001915*X + 0.9589133982*XLOG -
     $ 0.307417692*(1./X) - 0.1793690733*(XLOG/X) + 4.566485508*(X**2)
     $ - 3.937617129*(X**3) + 2.773480477*(X**4) - 1.540248513*(X**5)
     $ + 0.6183097947*(X**6) - 0.1542126064*(X**7) +
     $ 0.0174859553*(X**8)
C
      FUSEA(X) = -5.503869566 + 15.20985662*X - 5.166205929*XLOG -
     $ 1.728208206*(1./X) - 0.4215945253*(XLOG/X) - 18.82164974*(X**2)
     $ + 24.27679709*(X**3) - 27.22445715*(X**4) + 24.98752188*(X**5)
     $ - 18.12394891*(X**6) + 10.06144542*(X**7) - 4.106763252*(X**8)
     $ + 1.15847115*(X**9) - 0.2014529514*(X**10) +
     $ 0.01625760301*(X**11)
C
      FDSEA(X) = -5.478593775 + 15.1097528*X - 5.581750835*XLOG -
     $ 1.987547927*(1./X) - 0.4944113864*(XLOG/X) - 17.23528157*(X**2)
     $ + 20.59071315*(X**3) - 21.48775889*(X**4) + 18.40750425*(X**5)
     $ - 12.46901771*(X**6) + 6.45303238*(X**7) - 2.445316084*(X**8) +
     $ 0.6363027326*(X**9) - 0.1011660335*(X**10) +
     $ 0.007376682094*(X**11)
C
      GUVAL1(X) = 6.650062246 + 1.480836233*X - 3.536793901*XLOG -
     $ 5.08758928*(1./X) - 2.458893299*(XLOG/X) -
     $ 0.4159265541*(XLOG**2/X) - 0.03949356966*(XLOG**3/X) -
     $ 0.002175877338*(XLOG**4/X) - 6.382577207E-5*(XLOG**5/X) -
     $ 7.324244818E-7*(XLOG**6/X) + 0.575121435*(X*XLOG) +
     $ 0.09704190061*(X*XLOG**2) + 791./90953.*(X *XLOG**3)
      GUVAL2(X) =
     $ 3.962955366E-4*(X*XLOG**4) + 6.591820335E-6*(X *XLOG**5) -
     $ 0.07706665525*(X**2*XLOG) - 0.01260088982*(X**2*XLOG**2) -
     $ 0.001080476729*(X**2*XLOG**3) - 4.647425231E-5*(X**2*XLOG**4) -
     $ 7.324244829E-7*(X**2*XLOG**5) - 0.2027508558*(X**2) -
     $ 0.6721633358*(XLOG**2) - 0.07339139987*(XLOG**3) -
     $ 0.004744695259*(XLOG**4) - 1.651100349E-4*XLOG**5 -
     $ 2.197273446E-6*XLOG**6
C
      GDVAL1(X) = 2.403815112 + 1.359504335*X - 2.144999226*XLOG -
     $ 2.357471591*(1./X) - 1.13339787*(XLOG/X) -
     $ 0.2003574358*(XLOG**2/X) - 0.02221455952*(XLOG**3/X) -
     $ 0.001601991722*(XLOG**4/X) - 6.878677010E-5*(XLOG**5/X) -
     $ 1.323789434E-6*(XLOG**6/X) + 0.4984901703*(X*XLOG) +
     $ 0.09080940556*(X*XLOG**2) + 0.01045471879*(X *XLOG**3)
      GDVAL2(X) =
     $ 7.339489291E-4*(X*XLOG**4) + 2.382820980E-5*(X *XLOG**5) -
     $ 0.1348586553*(X**2*XLOG) - 0.02441501092*(X**2*XLOG**2) -
     $ 0.002734669503*(X**2*XLOG**3) - 1.807502877E-4*(X**2*XLOG**4) -
     $ 5.295157736E-6*(X**2*XLOG**5) + 0.01826324487*(X**3*XLOG) +
     $ 0.003291926818*(X**3*XLOG**2) + 3.636001057E-4*(X**3*XLOG**3) +
     $ 2.342115438E-5*(X**3*XLOG**4) + 6.618947159E-7*(X**3*XLOG**5) -
     $ 0.3679347826*(X**2) + 0.04985470259*(X**3) -
     $ 0.3928663839*(XLOG**2) - 0.04732954832*(XLOG**3) -
     $ 0.003974205548*( XLOG**4) - 2.116051876E-4*XLOG**5 -
     $ 5.295157736E-6*XLOG**6
C
      GUSEA1(X) = -0.8251281831 + 1.555766474*X - 0.476618796*XLOG -
     $ 0.157877015*(1./X) + 0.3273497735*(XLOG/X) +
     $ 0.1184829659*(XLOG**2/X) + 0.01147973292*(XLOG**3/X) +
     $ 0.001370332595*(XLOG**4/X) + 4.084139287E-5*(XLOG**5/X) +
     $ 2.284079310E-6*(XLOG**6/X) - 1.681676555*(X*XLOG) +
     $ 0.01771802464*(X*XLOG**2) - 0.04546554244*(X *XLOG**3) -
     $ 3.454606694E-4*(X*XLOG**4) - 1.438969965E-4*(X *XLOG**5) +
     $ 0.8875664376*(X**2*XLOG) + 0.04051742981*(X**2 *XLOG**2)
      GUSEA2(X) =
     $ 0.0254151271*(X**2*XLOG**3) + 4.583985126E-4*(X**2*XLOG**4) +
     $ 7.994277584E-5*(X**2*XLOG**5) - 0.4492144518*(X**3*XLOG) -
     $ 0.02965496152*(X**3*XLOG**2) - 0.01288679853*(X**3*XLOG**3) -
     $ 2.791634921E-4*(X**3*XLOG**4) - 3.997138792E-5*(X**3*XLOG**5) +
     $ 0.1638328221*(X**4*XLOG) + 0.01250393016*(X**4*XLOG**2) +
     $ 0.004685172364*(X**4*XLOG**3) + 1.100919901E-4*(X**4*XLOG**4) +
     $ 1.438969967E-5*(X**4*XLOG**5) - 0.0367848506*(X**5*XLOG) -
     $ 0.003035305139*(X**5*XLOG**2) - 0.001048416117*(X**5*XLOG**3) -
     $ 2.579726667E-5*(X**5*XLOG**4) - 3.197711036E-6*(X**5*XLOG**5) +
     $ 0.003783780648*(X**6*XLOG) + 3.278296157E-4*(X**6*XLOG**2) +
     $ 1.075296502E-4*(X**6*XLOG**3) + 2.725601849E-6*(X**6*XLOG**4)
      GUSEA3(X) =
     $ 3.262970444E-7*(X**6*XLOG**5) - 0.2259054436*(X**2) +
     $ 0.003364712414*(X**3) + 0.01992787001*(X**4) - 0.007399430903*
     $ (X**5) + 9.652150086E-4*X**6 + 0.554652844*(XLOG**2) +
     $ 0.011217842*(XLOG**3) + 0.007692743973*(XLOG**4) +
     $ 9.402708800E-5*XLOG**5 + 1.598855517E-5*XLOG**6
C
      GDSEA1(X) = -0.9201807217 + 2.243479849*X - 0.899698589*XLOG -
     $ 0.3970657521*(1./X) + 0.2818290666*(XLOG/X) +
     $ 0.120664241*(XLOG**2/X) + 0.01043451714 *(XLOG**3/X) +
     $ 0.001191246128*(XLOG**4/X) + 3.001102810E-5*(XLOG**5/X) +
     $ 2.039937816E-6*(XLOG**6/X) - 1.787863927*(X*XLOG) +
     $ 826./63247.*(X*XLOG**2) - 0.04263009293*(X*XLOG**3) +
     $ 3.087205491E-5*( X*XLOG**4) - 1.285160824E-4*(X*XLOG**5) +
     $ 0.9517638436*(X**2*XLOG) + 0.04047432532*(X**2*XLOG**2) +
     $ 0.02332032497*(X**2*XLOG**3) + 2.208416029E-4*(X**2*XLOG**4)
      GDSEA2(X) =
     $ 7.139782355E-5*(X**2*XLOG**5) - 0.4816526149*(X**3*XLOG) -
     $ 0.02893293689*(X**3*XLOG**2) - 0.01172595961*(X**3*XLOG**3) -
     $ 1.550444419E-4*(X**3*XLOG**4) - 3.569891178E-5*(X**3*XLOG**5) +
     $ 0.1755025883*(X**4*XLOG) + 0.01209064681*(X**4*XLOG**2) +
     $ 0.004244259809*(X**4*XLOG**3) + 6.438373778E-5*(X**4*XLOG**4) +
     $ 1.285160826E-5*(X**4*XLOG**5) - 0.03937044174*(X**5*XLOG) -
     $ 0.002920614679*(X**5*XLOG**2) - 9.471446970E-4*(X**5*XLOG**3) -
     $ 1.549746135E-5*(X**5*XLOG**4) - 2.855912944E-6*(X**5*XLOG**5)
      GDSEA3(X) =
     $ 0.004046756409*(X**6*XLOG) + 3.144555106E-4*(X**6*XLOG**2) +
     $ 9.696129739E-5*(X**6*XLOG**3) + 1.664636351E-6*(X**6*XLOG**4) +
     $ 2.914196881E-7*(X**6*XLOG**5) - 0.5703745807*(X**2) +
     $ 0.1676594704*(X**3) - 0.03765961644*(X**4) +
     $ 0.005180399826*(X**5) - 3.032419889E-4*X**6 +
     $ 0.5916013402*(XLOG**2) + 0.0113078292*(XLOG**3) +
     $ 0.007094724813*( XLOG**4) + 3.872242009E-5*XLOG**5 +
     $ 1.427956471E-5*XLOG**6
C
      EUVAL(X) = -3.398748694 + 0.6266420937*(1./X)
      EDVAL(X) = -1.300464877 + 0.2267175031*(1./X)
      EUSEA(X) = -0.4281951222 + 0.0600001177*(1./X)
      EDSEA(X) = -0.5744690066 + 0.08143317382*(1./X)
C
C          ENTRY
C
      IF(XW.LE.0..OR.XW.GE.1.) THEN
        STRUCW=0.
        RETURN
      ENDIF
      X=XW
      XLOG=LOG(X)
C
      IIW=IW
      IF(IH.EQ.-1120) THEN
        IF(IW.EQ.2) IIW=3
        IF(IW.EQ.3) IIW=2
      ELSEIF(IH.EQ.1220) THEN
        IF(IW.EQ.2) IIW=3
        IF(IW.EQ.3) IIW=2
      ENDIF
C
      IF(XW.GT..1) GO TO 1000
C
C          STRUCW = XW*F(XW) FOR IIW=W+ IN PROTON, XW<.1
      IF(IIW.EQ.2) THEN
        G1=GUVAL1(X)
        G1=G1+GUVAL2(X)
        G2=GUSEA1(X)
        G2=G2+GUSEA2(X)
        G2=G2+GUSEA3(X)
        G3=GDSEA1(X)
        G3=G3+GDSEA2(X)
        G3=G3+GDSEA3(X)
        SUM=G1+G2+G3+EUVAL(X)+EUSEA(X)+EDSEA(X)
        STRUCW=X*CVAW*SUM
C          STRUCW = XW*F(XW) FOR IIW=W- IN PROTON, XW<.1
      ELSEIF(IIW.EQ.3) THEN
        G1=GDVAL1(X)
        G1=G1+GDVAL2(X)
        G2=GDSEA1(X)
        G2=G2+GDSEA2(X)
        G2=G2+GDSEA3(X)
        G3=GUSEA1(X)
        G3=G3+GUSEA2(X)
        G3=G3+GUSEA3(X)
        SUM=G1+G2+G3+EDVAL(X)+EDSEA(X)+EUSEA(X)
        STRUCW=X*CVAW*SUM
C          STRUCW=XW*F(XW) FOR IIW=Z0 IN PROTON, XW<.1
      ELSEIF(IIW.EQ.4) THEN
        G1=GUVAL1(X)
        G1=G1+GUVAL2(X)
        G2=GUSEA1(X)
        G2=G2+GUSEA2(X)
        G2=G2+GUSEA3(X)
        SUMU=G1+2.*G2+EUVAL(X)+2.*EUSEA(X)
        G1=GDVAL1(X)
        G1=G1+GDVAL2(X)
        G2=GDSEA1(X)
        G2=G2+GDSEA2(X)
        G2=G2+GDSEA3(X)
        SUMD=G1+2.*G2+EDVAL(X)+2.*EDSEA(X)
        STRUCW=X*(CVAZUU*SUMU+CVAZDD*SUMD)
      ENDIF
      IF(STRUCW.LT.0.) STRUCW=0.
      RETURN
C
1000  CONTINUE
C
C            STRUCW=XW*F(XW) FOR IIW=W+ IN PROTON, XW>.1
      IF(IIW.EQ.2) THEN
        F1=FUVAL(X)
        F2=FUSEA(X)
        F3=FDSEA(X)
        SUM=F1+F2+F3
        STRUCW=X*CVAW*SUM
C          STRUCW=XW*F(XW) FOR IIW=W- IN PROTON, XW>.1
      ELSEIF(IIW.EQ.3) THEN
        F1=FDVAL(X)
        F2=FDSEA(X)
        F3=FUSEA(X)
        SUM=F1+F2+F3
        STRUCW=X*CVAW*SUM
C          STRUCW=XW*F(XW) FOR IIW=Z0 IN PROTON, XW>.1
      ELSEIF(IIW.EQ.4) THEN
        F1=FUVAL(X)
        F2=FUSEA(X)
        SUMU=F1+2.*F2
        F1=FDVAL(X)
        F2=FDSEA(X)
        SUMD=F1+2.*F2
        STRUCW=X*(CVAZUU*SUMU+CVAZDD*SUMD)
      ENDIF
      IF(STRUCW.LT.0.) STRUCW=0.
      RETURN
      END
CDECK  ID>, TIMER.  
      SUBROUTINE TIMER(IT)
C
C          CALL SYSTEM CPU CLOCK -- MACHINE DEPENDENT.
C          IT=1 FOR RUN START TIME.
C          IT=2 FOR RUN STOP TIME.
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/TIMES/TIME1,TIME2
      SAVE /TIMES/
      REAL      TIME1,TIME2
      DIMENSION TIMES(2)
      EQUIVALENCE (TIMES(1),TIME1)
      DIMENSION TTT(2)
      INTEGER CPUTIM(2),ITMLST(4),NHSEC
      EXTERNAL JPI$_CPUTIM
C
C          DEFAULT IS TO RETURN ZERO.
      TNOW=0.
C          VAX HAS NO FORTRAN FUNCTION FOR CPU TIME.
C          FOLLOWING PROVIDED BY T. KILLIAN
      ITMLST(1)=ISHFT(%LOC(JPI$_CPUTIM),16)+4
      ITMLST(2)=%LOC(NHSEC)
      ITMLST(3)=0
      ITMLST(4)=0
      CALL SYS$GETJPI(,,,ITMLST,,,)
      TNOW=.01*NHSEC
      TIMES(IT)=TNOW
      RETURN
      END
CDECK  ID>, TWOJET. 
      SUBROUTINE TWOJET
C
C          Driving routine to generate initial parameters for jets,
C          assuming zero initial transverse momentum, ie PT(1)=PT(2).
C
C          Parameters are PT,YJ,PHI with P,YJ,XJ as dependent variables,
C          where YJ=RAPIDITY, XJ=Feynman X.
C          All parameters are stored in COMMON/JETPAR/.
C          Cross section is called from NOGOOD.
C
      IMPLICIT NONE
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/MBPAR/PUD0,PJSPN,PISPN,SIGQT0,XGEN0(2),PMIX01(3,2)
     1,PMIX02(3,2),PBARY0
      SAVE /MBPAR/
      REAL      PUD0,PJSPN,PISPN,SIGQT0,XGEN0,PMIX01,PMIX02,PBARY0
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PINITS/PINITS(5,2),IDINIT(2)
      SAVE /PINITS/
      INTEGER   IDINIT
      REAL      PINITS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/PTPAR/PTFUN1,PTFUN2,PTGEN1,PTGEN2,PTGEN3,SIGMAX
      SAVE /PTPAR/
      REAL      PTFUN1,PTFUN2,PTGEN1,PTGEN2,PTGEN3,SIGMAX
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/TOTALS/NKINPT,NWGEN,NKEEP,SUMWT,WT
      SAVE /TOTALS/
      INTEGER   NKINPT,NWGEN,NKEEP
      REAL      SUMWT,WT
      COMMON/ISLOOP/NEVOLV,NFRGMN,IEVOL,IFRG
      SAVE /ISLOOP/
      INTEGER NEVOLV,NFRGMN,IEVOL,IFRG
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C
      REAL ACOSH,XXX,WTFCN,PPP,RANF,SIGN,SGN,AMQ1,AMASS,AMQ2
      REAL PPLUS,PMINUS,PSUM3,PSUM4,PPL,PMN,SQ1,SQ2,ROOT,P1PL,P1MN
      REAL P2PL,P2MN,AMI1,AMI2
      INTEGER NREJ,I,II,IS,IFL1,IFL2
      REAL X(2)
      EQUIVALENCE (X(1),X1)
      LOGICAL NOGOOD
      LOGICAL YGENJ
      INTEGER LISTJ(17),LISTW(4),LISTSS(85)
C
C          SUSY IDENT codes from /SSTYPE/. (Fortran 77 allows - signs
C          in parameter statements but not data statements.)
      INTEGER MSUPL,MSDNL,MSSTL,MSCHL,MSBT1,MSTP1,
     $MSUPR,MSDNR,MSSTR,MSCHR,MSBT2,MSTP2,MSW1,MSW2,
     $MSNEL,MSEL,MSNML,MSMUL,MSNTL,MSTAU1,MSER,MSMUR,MSTAU2
      PARAMETER (MSUPL=-ISUPL)
      PARAMETER (MSDNL=-ISDNL)
      PARAMETER (MSSTL=-ISSTL)
      PARAMETER (MSCHL=-ISCHL)
      PARAMETER (MSBT1=-ISBT1)
      PARAMETER (MSTP1=-ISTP1)
      PARAMETER (MSUPR=-ISUPR)
      PARAMETER (MSDNR=-ISDNR)
      PARAMETER (MSSTR=-ISSTR)
      PARAMETER (MSCHR=-ISCHR)
      PARAMETER (MSBT2=-ISBT2)
      PARAMETER (MSTP2=-ISTP2)
      PARAMETER (MSW1=-ISW1)
      PARAMETER (MSW2=-ISW2)
      PARAMETER (MSNEL=-ISNEL)
      PARAMETER (MSEL=-ISEL)
      PARAMETER (MSNML=-ISNML)
      PARAMETER (MSMUL=-ISMUL)
      PARAMETER (MSNTL=-ISNTL)
      PARAMETER (MSTAU1=-ISTAU1)
      PARAMETER (MSER=-ISER)
      PARAMETER (MSMUR=-ISMUR)
      PARAMETER (MSTAU2=-ISTAU2)
C
      DATA LISTSS/ISGL,
     $ISUPL,MSUPL,ISDNL,MSDNL,ISSTL,MSSTL,ISCHL,MSCHL,ISBT1,MSBT1,
     $ISTP1,MSTP1,
     $ISUPR,MSUPR,ISDNR,MSDNR,ISSTR,MSSTR,ISCHR,MSCHR,ISBT2,MSBT2,
     $ISTP2,MSTP2,
     $ISW1,MSW1,ISW2,MSW2,ISZ1,ISZ2,ISZ3,ISZ4,
     $ISNEL,MSNEL,ISEL,MSEL,ISNML,MSNML,ISMUL,MSMUL,ISNTL,MSNTL,
     $ISTAU1,MSTAU1,ISER,MSER,ISMUR,MSMUR,ISTAU2,MSTAU2,
     $9,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,11,-11,12,-12,13,-13,
     $14,-14,15,-15,16,-16,10,80,-80,90,82,83,84,86,-86/
      DATA LISTJ/9,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8/
      DATA LISTW/10,80,-80,90/
C          Inverse hyperbolic cosine function
      ACOSH(XXX)=ALOG(XXX+SQRT(XXX**2-1.))
      WTFCN(PPP)=2.*PPP*PTGEN2*PTGEN3*PPP**((PTGEN3-1.)/PTGEN3)
C
C          Initialize
C
      NPTCL=0
      PHI(1)=PHIMIN(1)+(PHIMAX(1)-PHIMIN(1))*RANF()
      PHI(2)=AMOD(PHI(1)+PI,2.*PI)
      NREJ=-1
      SIGMA=0.
      WT=1.
      IF(.NOT.FIXPT(2)) GOTO 101
      FIXPT(1)=.TRUE.
      PT(1)=PT(2)
  101 CONTINUE
      IF(FIXPT(1)) GOTO 400
      DO 110 I=1,2
      IF(FIXP(I)) GOTO 200
      IF(FIXXJ(I)) GOTO 300
  110 CONTINUE
C
C          Genetate PT and YJ with no variables fixed
C
  111 NREJ=NREJ+1
      IF(NREJ.GT.NTRIES) GO TO 910
      SUMWT=SUMWT+SIGMA*WT/(NEVOLV*NFRGMN)
      NKINPT=NKINPT+1
      SIGMA=0.
      WT=1.
C            Generate PT with a power law distribution
      PT(1)=(PTGEN1+PTGEN2*RANF())**PTGEN3
      PT(2)=PT(1)
      SIGMAX=PTFUN1*PT(1)**PTFUN2
C          GENERATE FLAT IN YJ, CALCULATE CORRESPONDING TH
      DO 115 I=1,2
      IF(FIXYJ(I)) GOTO 115
      IF(.NOT.YGENJ(I)) GOTO 111
  115 CONTINUE
      DO 116 I=1,2
      P(I)=PT(I)/STH(I)
      IF(P(I).LT.PMIN(I).OR.P(I).GT.PMAX(I)) GOTO 111
      XJ(I)=P(I)*CTH(I)/HALFE
      IF(XJ(I).LT.XJMIN(I).OR.XJ(I).GT.XJMAX(I)) GOTO 111
  116 CONTINUE
      WT=WT*WTFCN(PT(1))
      IF(NOGOOD(1)) GOTO 111
      SUMWT=SUMWT+SIGMA*WT/(NEVOLV*NFRGMN)
      NKEEP=NKEEP+1
      GO TO 500
C
C          Generate PT and YJ fixing P
C
  200 CONTINUE
      II=3-I
  211 NREJ=NREJ+1
      IF(NREJ.GT.NTRIES) GO TO 910
      NKINPT=NKINPT+1
      WT=0.
      IF(FIXYJ(I)) GOTO 212
C          Generate PT with a power law distribution
      PT(1)=(PTGEN1+PTGEN2*RANF())**PTGEN3
      SIGMAX=PTFUN1*PT(1)**PTFUN2
      PT(2)=PT(1)
C          Given PT, TH is fixed except for a sign
      STH(I)=PT(I)/P(I)
      SIGN=1.0
      IF(RANF().GT.0.5) SIGN=-1.0
      CTH(I)=SIGN*SQRT(1.-STH(I)**2)
      TH(I)=ATAN2(STH(I),CTH(I))
      YJ(I)=-ALOG(TAN(TH(I)/2.))
      IF(YJ(I).LT.YJMIN(I).OR.YJ(I).GT.YJMAX(I)) GOTO 211
      GOTO 213
  212 PT(1)=P(I)*STH(I)
  213 CONTINUE
      XJ(I)=P(I)*CTH(I)/HALFE
      IF(XJ(I).LT.XJMIN(I).OR.XJ(I).GT.XJMAX(I)) GOTO 211
      IF(FIXP(II)) GOTO 220
      IF(FIXXJ(II)) GOTO 230
      IF(FIXYJ(II)) GOTO 215
      IF(.NOT.YGENJ(II)) GOTO 211
  215 CONTINUE
      P(II)=PT(II)/STH(II)
      IF(P(II).LT.PMIN(II).OR.P(II).GT.PMAX(II)) GOTO 211
      XJ(II)=P(II)*CTH(II)/HALFE
      IF(XJ(II).LT.XJMIN(II).OR.XJ(II).GT.XJMAX(II)) GOTO 211
      GOTO 250
220   STH(II)=PT(II)/P(II)
      SGN=1.0
      IF(RANF().GT.0.5) SGN=-1.0
      CTH(II)=SGN*SQRT(1.-STH(II)**2)
      TH(II)=ATAN2(STH(II),CTH(II))
      YJ(II)=-ALOG(TAN(TH(II)/2.))
      IF(YJ(II).LT.YJMIN(II).OR.YJ(II).GT.YJMAX(II)) GOTO 211
      XJ(II)=P(II)*CTH(II)/HALFE
      IF(XJ(II).LT.XJMIN(II).OR.XJ(II).GT.XJMAX(II)) GOTO 211
      GOTO 250
  230 TH(II)=ATAN2(PT(II),XJ(II)*HALFE)
      YJ(II)=-ALOG(TAN(TH(II)/2.))
      IF(YJ(II).LT.YJMIN(II).OR.YJ(II).GT.YJMAX(II)) GOTO 211
      CTH(II)=COS(TH(II))
      STH(II)=SIN(TH(II))
  250 CONTINUE
      IF(NOGOOD(1)) GOTO 211
      NKEEP=NKEEP+1
      GO TO 500
C
C          Generate PT and YJ at fixed XJ
C
  300 CONTINUE
      II=3-I
  311 NREJ=NREJ+1
      IF(NREJ.GT.NTRIES) GO TO 910
      NKINPT=NKINPT+1
      WT=0.
C          Generate PT with a power law distribution
      PT(1)=(PTGEN1+PTGEN2*RANF())**PTGEN3
      SIGMAX=PTFUN1*PT(1)**PTFUN2
      PT(2)=PT(1)
      TH(I)=ATAN2(PT(I),XJ(I)*HALFE)
      YJ(I)=-ALOG(TAN(TH(I)/2.))
      IF(YJ(I).LT.YJMIN(I).OR.YJ(I).GT.YJMAX(I)) GOTO 311
      CTH(I)=COS(TH(I))
      STH(I)=SIN(TH(I))
      P(I)=PT(I)/STH(I)
      IF(FIXYJ(II)) GOTO 315
      IF(FIXP(II)) GOTO 314
      YJ(II)=YJMIN(II)+(YJMAX(II)-YJMIN(II))*RANF()
      TH(II)=2.*ATAN(EXP(-YJ(II)))
      CTH(II)=COS(TH(II))
      STH(II)=SIN(TH(II))
      GOTO 315
  314 CONTINUE
      STH(II)=PT(II)/P(II)
      CTH(II)=SQRT(1.-STH(II)**2)
      IF(RANF().GT.0.5) CTH(II)=-CTH(II)
      TH(II)=ATAN2(STH(II),CTH(II))
      YJ(II)=-ALOG(TAN(TH(II)/2.))
  315 CONTINUE
      P(II)=PT(II)/STH(II)
      XJ(II)=P(II)*CTH(II)/HALFE
      IF(XJ(II).LT.XJMIN(II).OR.XJ(II).GT.XJMAX(II)) GOTO 311
      IF(NOGOOD(1)) GOTO 311
      NKEEP=NKEEP+1
      GO TO 500
C
C          Generate YJ at fixed PT
C
  400 CONTINUE
      PT(2)=PT(1)
  411 NREJ=NREJ+1
      IF(NREJ.GT.NTRIES) GO TO 910
      NKINPT=NKINPT+1
      WT=0.
      DO 415 I=1,2
      IF(FIXYJ(I)) GOTO 415
      IF(FIXP(I)) GOTO 413
      IF(.NOT.YGENJ(I)) GO TO 411
      GOTO 414
  413 CONTINUE
      IS=1
      IF(RANF().GT.0.5) IS=2
      CTH(I)=CTHS(IS,I)
      TH(I)=THS(IS,I)
      YJ(I)=YJS(IS,I)
  414 CONTINUE
      P(I)=PT(I)/STH(I)
      XJ(I)=P(I)*CTH(I)/HALFE
  415 CONTINUE
      IF(NOGOOD(1)) GOTO 411
      NKEEP=NKEEP+1
C
C          Reset /JETPAR/
C
  500 CONTINUE
      IF(KEYS(1)) THEN
        IFL1=LISTJ(JETTYP(1))
        IFL2=LISTJ(JETTYP(2))
        AMQ1=AMASS(IFL1)
        AMQ2=AMASS(IFL2)
        AMI1=AMASS(LISTJ(INITYP(1)))
        AMI2=AMASS(LISTJ(INITYP(2)))
        CALL TWOKIN(AMI1,AMI2,AMQ1,AMQ2)
      ELSEIF(KEYS(5)) THEN
        IFL1=LISTSS(JETTYP(1))
        IFL2=LISTSS(JETTYP(2))
        AMQ1=AMASS(IFL1)
        AMQ2=AMASS(IFL2)
        CALL TWOKIN(0.,0.,AMQ1,AMQ2)
      ELSEIF(KEYS(6)) THEN
        IFL1=LISTW(JETTYP(1))
        IFL2=LISTW(JETTYP(2))
        AMQ1=AMASS(IFL1)
        AMQ2=AMASS(IFL2)
        CALL TWOKIN(0.,0.,AMQ1,AMQ2)
      ELSEIF(KEYS(8)) THEN
        IF(JETTYP(1).LE.13) THEN
          IFL1=LISTJ(JETTYP(1))
        ELSE
          IFL1=10
        ENDIF
        IF(JETTYP(2).LE.13) THEN
          IFL2=LISTJ(JETTYP(2))
        ELSE
          IFL2=10
        ENDIF
        AMQ1=AMASS(IFL1)
        AMQ2=AMASS(IFL2)
        CALL TWOKIN(0.,0.,AMQ1,AMQ2)
      ENDIF
C
C            Set PBEAM and PJETS
C
      PBEAM(1)=(1.-X1)*HALFE
      PBEAM(2)=(1.-X2)*HALFE
      DO 501 I=1,2
        PJETS(3,I)=P(I)*CTH(I)
        PJETS(1,I)=PT(I)*COS(PHI(I))
        PJETS(2,I)=PT(I)*SIN(PHI(I))
        IF(KEYS(1)) THEN
          IDJETS(I)=LISTJ(JETTYP(I))
        ELSEIF(KEYS(5)) THEN
          IDJETS(I)=LISTSS(JETTYP(I))
        ELSEIF(KEYS(6)) THEN
          IDJETS(I)=LISTW(JETTYP(I))
        ELSEIF(KEYS(8)) THEN
          IDJETS(1)=IFL1
          IDJETS(2)=IFL2
        ENDIF
        PJETS(5,I)=AMASS(IDJETS(I))
        PJETS(4,I)=SQRT(P(I)**2+PJETS(5,I)**2)
  501 CONTINUE
C
C          Set PINITS
C
      DO 600 I=1,2
      IDINIT(I)=LISTJ(INITYP(I))
      PINITS(5,I)=AMASS(IDINIT(I))
      PPLUS=X(I)*ECM
      PMINUS=PINITS(5,I)**2/PPLUS
      PINITS(4,I)=.5*(PPLUS+PMINUS)
      PINITS(3,I)=.5*(PPLUS-PMINUS)*(3-2*I)
      PINITS(2,I)=0.
      PINITS(1,I)=0.
600   CONTINUE
C          Calculate PINITS exactly.
      PSUM3=PJETS(3,1)+PJETS(3,2)
      PSUM4=PJETS(4,1)+PJETS(4,2)
      IF(PSUM3.GT.0.) THEN
        PPL=PSUM4+PSUM3
        PMN=SHAT/PPL
      ELSE
        PMN=PSUM4-PSUM3
        PPL=SHAT/PMN
      ENDIF
      SQ1=PINITS(5,1)**2
      SQ2=PINITS(5,2)**2
      ROOT=SQRT((PPL*PMN-SQ1-SQ2)**2-4.*SQ1*SQ2)
      P1PL=(PPL*PMN+SQ1-SQ2+ROOT)/(2.*PMN)
      P1MN=SQ1/P1PL
      P2MN=(PPL*PMN+SQ2-SQ1+ROOT)/(2.*PPL)
      P2PL=SQ2/P2MN
      PINITS(4,1)=.5*(P1PL+P1MN)
      PINITS(3,1)=.5*(P1PL-P1MN)
      PINITS(4,2)=.5*(P2PL+P2MN)
      PINITS(3,2)=.5*(P2PL-P2MN)
      RETURN
C
C          Error
C
910   CALL PRTEVT(0)
      WRITE(ITLIS,1000) NREJ
 1000 FORMAT(//' IT IS TAKING MORE THAN',I5,' TRIES TO GENERATE AN',
     $' EVENT. CHECK LIMITS OR INCREASE NTRIES.')
      STOP 99
      END
CDECK  ID>, TWOKIN. 
      SUBROUTINE TWOKIN(AMI1,AMI2,AM1,AM2)
C
C          Given P,PT,TH,PHI, and initial and final masses AMI1, AMI2,
C          AM1,AM2, set X1, X2, SHAT, etc.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
C
      REAL    AMI1,AMI2,AM1,AM2,P1PL,P1MN,P2PL,P2MN,E1,E2,PPL,PMN,
     $        PI1PL,PI1MN,PI2PL,PI2MN,ANEFF,AMASS,ALAMFN
C
      E1=SQRT(P(1)**2+AM1**2)
      E2=SQRT(P(2)**2+AM2**2)
C
C          For 32-bit machines must use large and small components
C          carefully, with pbig*psmall = pt**2+am**2.
C
      IF(CTH(1).GT.0.) THEN
        P1PL=E1+P(1)*CTH(1)
        P1MN=(PT(1)**2+AM1**2)/P1PL
      ELSE
        P1MN=E1-P(1)*CTH(1)
        P1PL=(PT(1)**2+AM1**2)/P1MN
      ENDIF
      IF(CTH(2).GT.0.) THEN
        P2PL=E2+P(2)*CTH(2)
        P2MN=(PT(2)**2+AM2**2)/P2PL
      ELSE
        P2MN=E2-P(2)*CTH(2)
        P2PL=(PT(2)**2+AM2**2)/P2MN
      ENDIF
C
C          Initial light cone momenta. Not symmetric if AMI1 /= AMI2.
C
      PPL=P1PL+P2PL
      PMN=P1MN+P2MN
      SHAT=PPL*PMN
      ALAMFN=SQRT((SHAT-AMI1**2-AMI2**2)**2-4.*(AMI1*AMI2)**2)
      PI1PL=(SHAT+AMI1**2-AMI2**2+ALAMFN)/(2.*PMN)
      PI1MN=AMI1**2/PI1PL
      PI2MN=(SHAT+AMI2**2-AMI1**2+ALAMFN)/(2.*PPL)
      PI2PL=AMI2**2/PI2MN
      X1=PI1PL/ECM
      X2=PI2MN/ECM
C
C          t=(p1-pi1)**2, u=(p1-pi2)**2
C
      THAT=AM1**2+AMI1**2-P1PL*PI1MN-P1MN*PI1PL
      UHAT=AM1**2+AMI2**2-P1PL*PI2MN-P1MN*PI2PL
C
C          Q**2 variable from Field, Fox, Wolfram
C
      QSQ=2.*SHAT*THAT*UHAT/(SHAT**2+THAT**2+UHAT**2)
      QSQ=AMAX1(QSQ,(AM1+AM2)**2)
      ANEFF=4.+QSQ/(QSQ+AMASS(5)**2)+QSQ/(QSQ+AMASS(6)**2)
      ALFQSQ=12.*PI/((33.-2.*ANEFF)*ALOG(QSQ/ALAM2))
      RETURN
      END
CDECK  ID>, VISAJE. 
      CHARACTER*40 FUNCTION VISAJE()
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      VISAJE = ' ISAJET     V7.37   14-APR-1998 11:53:18'
      IDVER = 737
      RETURN
      END
CDECK  ID>, WPAIR.  
      SUBROUTINE WPAIR
C
C          Finish generation of wpair events started bY TWOJET.
C          Select W decay modes as allowed by WMODE1, WMODE2.
C          Generate W decay angles and put vectors in PPAIR.
C
C          Also generate massless decay vectors PZERO for matrix
C          element -- double precision for 32-bit machines.
C
C          Ver 6.26: Check kinematics for W -> ff decay, since Z0 from
C                    Higgs decay can be virtual.
C          Ver. 6.30: Added check in loop 201.
C          Ver. 7.14: Add MSSM Higgs hooks
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      COMMON/WWSIG/WWSIG
      SAVE /WWSIG/
      REAL      WWSIG
      COMMON/WWPAR/SWW,TWW,UWW,WM2,ZM2,P1WW(5),P2WW(5),P3WW(5),P4WW(5)
     $,PZERO(4,4),S13,P3(5),Q1(5),Q3(5),JQWW(2)
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      SAVE /WWPAR/
      DOUBLE PRECISION SWW,TWW,UWW,WM2,ZM2,P1WW,P2WW,P3WW,P4WW
     $,PZERO,S13,P3,Q1,Q3
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      INTEGER   JQWW
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/QSAVE/QSAVE(29,2)
      SAVE /QSAVE/
      REAL      QSAVE
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PINITS/PINITS(5,2),IDINIT(2)
      SAVE /PINITS/
      INTEGER   IDINIT
      REAL      PINITS
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/WSIG/SIGLLQ
      SAVE /WSIG/
      REAL      SIGLLQ
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C
      DIMENSION X(2),LIST(25),P1WCM(4),P2WCM(4),P1LAB(4),P2LAB(4)
     $,P1CM0(4),P2CM0(4),P1LAB0(4),P2LAB0(4)
     1,PBOOST(4)
      EQUIVALENCE (X(1),X1)
      DIMENSION PWW(5,2)
      EQUIVALENCE (PWW(1,1),P3WW(1))
      DIMENSION JWWTYP(2),THWFF(2),PHIWFF(2)
      DOUBLE PRECISION P1CM0,P2CM0,DPHI,DCTH,DSTH,DAM0,PWW,BOOST
      REAL AMWW1,AMWW2,X,STRUC,STRUCW,RND,RANF,CBRWW,AMASS,AM0,AM1,AM2,
     $E1CM,E2CM,P12CM,CTHCM,STHCM,PHICM,CPHICM,SPHICM,P1WCM,P2WCM,
     $PBOOST,P1LAB,P2LAB,AFX,SGWWMX,P1LAB0,P2LAB0,THWFF,PHIWFF
      INTEGER IH,IQ,JWWTYP,JET,JWT,JQ,IQ1,IQ2,LIST,NREJ,NJ0,K
      REAL BRANCH(12),SUMBR
      INTEGER IDABS,IDABS1,IDABS2
C
      DATA LIST/9,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,
     $11,-11,12,-12,13,-13,14,-14,15,-15,16,-16/
C
C          Initialize for given W type.
      AMWW1=PJETS(5,1)
      AMWW2=PJETS(5,2)
      CALL WWKIN(AMWW1,AMWW2)
      NPAIR=0
C
C          Calculate and save structure functions.
      DO 120 IH=1,2
      DO 121 IQ=1,13
121   QSAVE(IQ,IH)=STRUC(X(IH),QSQ,IQ,IDIN(IH))/X(IH)
      DO 122 IQ=14,25
122   QSAVE(IQ,IH)=0.
      IF(KEYS(7).OR.KEYS(9)) THEN
        DO 123 IQ=26,29
123     QSAVE(IQ,IH)=STRUCW(X(IH),IQ-25,IDIN(IH))/X(IH)
      ENDIF
120   CONTINUE
C          JWWTYP points to W types 1,2,3,4
      IF(KEYS(6)) THEN
        JWWTYP(1)=JETTYP(1)
        JWWTYP(2)=JETTYP(2)
      ELSEIF((KEYS(7).AND..NOT.GOMSSM).OR.KEYS(9)) THEN
        JWWTYP(1)=JETTYP(1)-25
        JWWTYP(2)=JETTYP(2)-25
      ELSEIF(KEYS(7).AND.GOMSSM) THEN
        JWWTYP(1)=JETTYP(1)-76
        JWWTYP(2)=JETTYP(2)-76
      ENDIF
C
C          Select W decay modes and put in /JETSET/. First particle
C          is always the fermion.

      DO 200 JET=1,2
        IDABS=IABS(IDJETS(JET))
        IF(IDABS.NE.80.AND.IDABS.NE.90) GO TO 200
        RND=RANF()
        JWT=JWWTYP(JET)
C          Must only consider allowed decays for this mass
        SUMBR=0.
        DO 201 JQ=1,12
          IQ1=2*JQ
          IQ2=MATCH(IQ1,JWT)
          IF(IQ2.EQ.0) THEN
            BRANCH(JQ)=0.
            GO TO 201
          ENDIF
          AM1=AMASS(LIST(IQ1))
          AM2=AMASS(LIST(IQ2))
          IF(AM1+AM2.LT.PJETS(5,JET)) THEN
            BRANCH(JQ)=RBRWW(JQ,JWT,JET)
            SUMBR=SUMBR+BRANCH(JQ)
          ELSE
            BRANCH(JQ)=0.
          ENDIF
201     CONTINUE
        IF(SUMBR.LE.0.) GO TO 998
        DO 202 JQ=1,12
202     BRANCH(JQ)=BRANCH(JQ)/SUMBR
C
        CBRWW=0.
        DO 210 JQ=1,12
          CBRWW=CBRWW+BRANCH(JQ)
          IF(RND.GT.CBRWW) GO TO 210
          IQ1=2*JQ
          IQ2=MATCH(IQ1,JWT)
          IDPAIR(NPAIR+1)=LIST(IQ1)
          IDPAIR(NPAIR+2)=LIST(IQ2)
          PPAIR(5,NPAIR+1)=AMASS(LIST(IQ1))
          PPAIR(5,NPAIR+2)=AMASS(LIST(IQ2))
          JPAIR(NPAIR+1)=JET
          JPAIR(NPAIR+2)=JET
          NPAIR=NPAIR+2
          JQWW(JET)=JQ
          GO TO 200
210     CONTINUE
200   CONTINUE
C
C          Generate decay uniformly in angle and put in PPAIR.
C          Will check cross section later.
C
      NREJ=0
300   NJ0=2
      DO 310 JET=1,2
        IDABS=IABS(IDJETS(JET))
        IF(IDABS.NE.80.AND.IDABS.NE.90) GO TO 310
C          Construct W com momenta.
        AM0=PJETS(5,JET)
        AM1=PPAIR(5,NJ0-1)
        AM2=PPAIR(5,NJ0)
        E1CM=(AM0**2+AM1**2-AM2**2)/(2.*AM0)
        E2CM=(AM0**2+AM2**2-AM1**2)/(2.*AM0)
        P12CM=(AM0**2-AM1**2-AM2**2)**2-4.*(AM1*AM2)**2
        P12CM=SQRT(P12CM)/(2.*AM0)
        CTHCM=2.*RANF()-1.
        STHCM=SQRT(1.-CTHCM**2)
        PHICM=2.*PI*RANF()
        CPHICM=COS(PHICM)
        SPHICM=SIN(PHICM)
        P1WCM(1)=P12CM*STHCM*CPHICM
        P2WCM(1)=-P1WCM(1)
        P1WCM(2)=P12CM*STHCM*SPHICM
        P2WCM(2)=-P1WCM(2)
        P1WCM(3)=P12CM*CTHCM
        P2WCM(3)=-P1WCM(3)
        P1WCM(4)=E1CM
        P2WCM(4)=E2CM
C          Also construct zero mass vectors at same angle
C          Double precision.
        DAM0=AM0
        DCTH=CTHCM
        DSTH=DSQRT(1.D0-DCTH**2)
        DPHI=PHICM
        P1CM0(1)=.5*AM0*DSTH*DCOS(DPHI)
        P2CM0(1)=-P1CM0(1)
        P1CM0(2)=.5*AM0*DSTH*DSIN(DPHI)
        P2CM0(2)=-P1CM0(2)
        P1CM0(3)=.5*AM0*DCTH
        P2CM0(3)=-P1CM0(3)
        P1CM0(4)=.5*AM0
        P2CM0(4)=P1CM0(4)
C          Boost to lab frame.
        DO 320 K=1,3
320     PBOOST(K)=-PJETS(K,JET)
        PBOOST(4)=PJETS(4,JET)
        CALL LBOOST(PBOOST,1,P1WCM,P1LAB)
        CALL LBOOST(PBOOST,1,P2WCM,P2LAB)
        DO 330 K=1,4
          PPAIR(K,NJ0-1)=P1LAB(K)
          PPAIR(K,NJ0)=P2LAB(K)
330     CONTINUE
C          Boost zero mass vectors -- double precision for 32 bits.
        PZERO(4,NJ0-1)=(P1CM0(4)*PWW(4,JET)+P1CM0(1)*PWW(1,JET)
     $  +P1CM0(2)*PWW(2,JET)+P1CM0(3)*PWW(3,JET))/PWW(5,JET)
        BOOST=(P1CM0(4)+PZERO(4,NJ0-1))/(PWW(4,JET)+PWW(5,JET))
        DO 340 K=1,3
340     PZERO(K,NJ0-1)=P1CM0(K)+BOOST*PWW(K,JET)
        PZERO(4,NJ0)=(P2CM0(4)*PWW(4,JET)+P2CM0(1)*PWW(1,JET)
     $  +P2CM0(2)*PWW(2,JET)+P2CM0(3)*PWW(3,JET))/PWW(5,JET)
        BOOST=(P2CM0(4)+PZERO(4,NJ0))/(PWW(4,JET)+PWW(5,JET))
        DO 350 K=1,3
350     PZERO(K,NJ0)=P2CM0(K)+BOOST*PWW(K,JET)
        NJ0=NJ0+2
310   CONTINUE
C
C          Calculate cross section SIGWW2 containing TBRWW*RBRWW.
C          Compare with WW cross section containing TBRWW. Ratio
C          must be bounded by 3/(4*PI) for each W.
C
      AFX=3./(2.*PI)
      IF(KEYS(6)) THEN
        CALL SIGWW2
        SGWWMX=SIGEVT
        IF(IDJETS(1).NE.10) SGWWMX=SGWWMX*RBRWW(JQWW(1),JWWTYP(1),1)*AFX
        IF(IDJETS(2).NE.10) SGWWMX=SGWWMX*RBRWW(JQWW(2),JWWTYP(2),2)*AFX
      ELSEIF(KEYS(7)) THEN
C          Note that except for WW -> WW processes, SIGH3 just computes
C          the decay angular distribution, so it can be used for both
C          for SM and SUSY HL0/HH0 decays; HA0 -> WW is forbidden.
C          For Z + HL0 decays, we just return, ie use phase space.
        IDABS1=IABS(IDJETS(1))
        IDABS2=IABS(IDJETS(2))
        IF(.NOT.(IDABS1.EQ.10.OR.IDABS1.EQ.80.OR.IDABS1.EQ.90)) RETURN
        IF(.NOT.(IDABS2.EQ.10.OR.IDABS2.EQ.80.OR.IDABS2.EQ.90)) RETURN
        CALL SIGH3
        SGWWMX=SIGLLQ*AFX**2
      ELSEIF(KEYS(9)) THEN
        CALL SIGTC3
        SGWWMX=SIGLLQ*AFX**2
      ENDIF
      IF(WWSIG.GT.SGWWMX*RANF()) GO TO 400
      NREJ=NREJ+1
      IF(NREJ.LT.NTRIES) GO TO 300
      GO TO 999
C
C          Good event
C
400   CONTINUE
      RETURN
C
999   CALL PRTEVT(0)
      WRITE(ITLIS,9991) NREJ
9991  FORMAT(//' IT IS TAKING MORE THAN',I5,' TRIES TO GENERATE ',
     1'A GOOD WPAIR EVENT.'/' CHECK LIMITS OR INCREASE NTRIES.')
      STOP 99
998   CALL PRTEVT(0)
      WRITE(ITLIS,9981) JET
9981  FORMAT(//' ERROR IN WPAIR ... NO DECAY POSSIBLE FOR JET',I3)
      STOP 99
      END
CDECK  ID>, WWKIN.  
      SUBROUTINE WWKIN(AM1,AM2)
C          WPAIR KINEMATICS, INCLUDING DOUBLE PRECISION CONVERSION FOR
C          32-BIT MACHINES. CONVENTION IS THAT SINGLE PRECISION MASSES
C          AM1,AM2 ARE EXACT.
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/WWPAR/SWW,TWW,UWW,WM2,ZM2,P1WW(5),P2WW(5),P3WW(5),P4WW(5)
     $,PZERO(4,4),S13,P3(5),Q1(5),Q3(5),JQWW(2)
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      SAVE /WWPAR/
      DOUBLE PRECISION SWW,TWW,UWW,WM2,ZM2,P1WW,P2WW,P3WW,P4WW
     $,PZERO,S13,P3,Q1,Q3
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      INTEGER   JQWW
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
C          BASIC KINEMATICS FROM TWOKIN
      CALL TWOKIN(0.,0.,AM1,AM2)
C          WPAIR KINEMATICS -- JUST A COPY FOR CDC BUT CONSTRUCTS A
C          CONSISTENT SET OF DOUBLE PRECISION VARIABLES FOR 32-BIT
C          MACHINES.
      P3WW(1)=PT(1)*COS(PHI(1))
      P3WW(2)=PT(1)*SIN(PHI(1))
      P3WW(3)=P(1)*CTH(1)
      P3WW(5)=AM1
      P4WW(1)=-P3WW(1)
      P4WW(2)=-P3WW(2)
      P4WW(3)=P(2)*CTH(2)
      P4WW(5)=AM2
      P3WW(4)=DSQRT(P3WW(1)**2+P3WW(2)**2+P3WW(3)**2+P3WW(5)**2)
      P4WW(4)=DSQRT(P4WW(1)**2+P4WW(2)**2+P4WW(3)**2+P4WW(5)**2)
      P1WW(1)=0.
      P1WW(2)=0.
      P1WW(4)=.5*(P3WW(4)+P3WW(3)+P4WW(4)+P4WW(3))
      P1WW(3)=P1WW(4)
      P2WW(1)=0.
      P2WW(2)=0.
      P2WW(4)=.5*(P3WW(4)-P3WW(3)+P4WW(4)-P4WW(3))
      P2WW(3)=-P2WW(4)
C          INVARIANTS
      SWW=+2.*(P1WW(4)*P2WW(4)-P1WW(3)*P2WW(3))
      TWW=-2.*(P1WW(4)*P3WW(4)-P1WW(3)*P3WW(3))+P3WW(5)**2
      UWW=-2.*(P2WW(4)*P3WW(4)-P2WW(3)*P3WW(3))+P3WW(5)**2
      RETURN
      END
CDECK  ID>, WWSS.   
      FUNCTION WWSS(T,U,T1,U1,T3,U3)
C          DECAY DISTRIBUTION FOR W+ W- PAIRS FROM SCHOONSCHIP(1980).
C          SQUARE OF S GRAPH.
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/WWPAR/SWW,TWW,UWW,WM2,ZM2,P1WW(5),P2WW(5),P3WW(5),P4WW(5)
     $,PZERO(4,4),S13,P3(5),Q1(5),Q3(5),JQWW(2)
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      SAVE /WWPAR/
      DOUBLE PRECISION SWW,TWW,UWW,WM2,ZM2,P1WW,P2WW,P3WW,P4WW
     $,PZERO,S13,P3,Q1,Q3
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      INTEGER   JQWW
      DOUBLE PRECISION WWSS
      DOUBLE PRECISION T,U,T1,U1,T3,U3
      DOUBLE PRECISION CV2A2
      CV2A2=CV**2+CA**2
      WWSS=
     1 +CV*CA*T*(-64.*T1*U1*T3+64.*T1*U1*U3+64.*T1*T3*U3+64.*T1*T3**2-6
     1 4.*T1**2*T3-64.*U1*T3*U3-64.*U1*U3**2+64.*U1**2*U3)
     1 +CV*CA*T*U*(-128.*T1*U3-64.*T1*S13+128.*U1*T3+64.*U1*S13+64.*T3*
     1 S13-64.*U3*S13)
     1 +CV*CA*T*WM2*(128.*T1*U3+64.*T1*S13-64.*T1**2-128.*U1*T3+64.*U1*
     1 S13+64.*U1**2-64.*T3*S13+64.*T3**2-64.*U3*S13-64.*U3**2)
     1 +CV*CA*T**2*(-64.*T1*U3-64.*T1*S13+64.*U1*T3+64.*T3*S13)
     1 +CV*CA*U*(-64.*T1*U1*T3+64.*T1*U1*U3+64.*T1*T3*U3+64.*T1*T3**2-6
     1 4.*T1**2*T3-64.*U1*T3*U3-64.*U1*U3**2+64.*U1**2*U3)
      WWSS=WWSS
     1 +CV*CA*U*WM2*(128.*T1*U3-64.*T1*S13-64.*T1**2-128.*U1*T3-64.*U1*
     1 S13+64.*U1**2+64.*T3*S13+64.*T3**2+64.*U3*S13-64.*U3**2)
     1 +CV*CA*U**2*(-64.*T1*U3+64.*U1*T3+64.*U1*S13-64.*U3*S13)
     1 +CV*CA*WM2*(128.*T1*U1*T3-128.*T1*U1*U3-128.*T1*T3*U3-128.*T1*T3
     1 **2+128.*T1**2*T3+128.*U1*T3*U3+128.*U1*U3**2-128.*U1**2*U3)
     1 +CV*CA*WM2**2*(128.*T1*S13+128.*T1**2-128.*U1*S13-128.*U1**2-128
     1 .*T3*S13-128.*T3**2+128.*U3*S13+128.*U3**2)
     1 +CV2A2*(128.*T1*U1*T3*U3-64.*T1**2*T3**2-64.*U1**2*U3**2)
      WWSS=WWSS
     1 +CV2A2*T*(-32.*T1*U1*T3-32.*T1*U1*U3-32.*T1*T3*U3-64.*T1*T3*S13+
     1 32.*T1*T3**2+32.*T1**2*T3-32.*U1*T3*U3+64.*U1*U3*S13+32.*U1*U3**
     1 2+32.*U1**2*U3)
     1 +CV2A2*T*U*(64.*T1*U3+32.*T1*S13+64.*U1*T3+32.*U1*S13+32.*T3*S13
     1 +32.*U3*S13+64.*S13**2)
     1 +CV2A2*T*WM2*(-64.*T1*U3-32.*T1*S13+32.*T1**2-64.*U1*T3+32.*U1*S
     1 13+32.*U1**2-32.*T3*S13+32.*T3**2+32.*U3*S13+32.*U3**2)
     1 +CV2A2*T**2*(32.*T1*U3+32.*T1*S13+32.*U1*T3+32.*T3*S13)
      WWSS=WWSS
     1 +CV2A2*U*(-32.*T1*U1*T3-32.*T1*U1*U3-32.*T1*T3*U3+64.*T1*T3*S13+
     1 32.*T1*T3**2+32.*T1**2*T3-32.*U1*T3*U3-64.*U1*U3*S13+32.*U1*U3**
     1 2+32.*U1**2*U3)
     1 +CV2A2*U*WM2*(-64.*T1*U3+32.*T1*S13+32.*T1**2-64.*U1*T3-32.*U1*S
     1 13+32.*U1**2+32.*T3*S13+32.*T3**2-32.*U3*S13+32.*U3**2)
     1 +CV2A2*U**2*(32.*T1*U3+32.*U1*T3+32.*U1*S13+32.*U3*S13)
     1 +CV2A2*WM2*(64.*T1*U1*T3+64.*T1*U1*U3+64.*T1*T3*U3-64.*T1*T3**2-
     1 64.*T1**2*T3+64.*U1*T3*U3-64.*U1*U3**2-64.*U1**2*U3)
      WWSS=WWSS
     1 +CV2A2*WM2**2*(-64.*T1*S13-64.*T1**2-64.*U1*S13-64.*U1**2-64.*T3
     1 *S13-64.*T3**2-64.*U3*S13-64.*U3**2-64.*S13**2)
      WWSS=2.*WWSS
      RETURN
      END
CDECK  ID>, WWST.   
      FUNCTION WWST(T,U,T1,U1,T3,U3,P1,P2)
C          DECAY DISTRIBUTION FOR W+ W- PAIRS FROM SCHOONSCHIP(1980).
C          INTERFERENCE OF T AND S GRAPHS.
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/WWPAR/SWW,TWW,UWW,WM2,ZM2,P1WW(5),P2WW(5),P3WW(5),P4WW(5)
     $,PZERO(4,4),S13,P3(5),Q1(5),Q3(5),JQWW(2)
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      SAVE /WWPAR/
      DOUBLE PRECISION SWW,TWW,UWW,WM2,ZM2,P1WW,P2WW,P3WW,P4WW
     $,PZERO,S13,P3,Q1,Q3
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      INTEGER   JQWW
      DIMENSION P1(4),P2(4)
      DOUBLE PRECISION WWST
      DOUBLE PRECISION T,U,T1,U1,T3,U3,P1,P2
      DOUBLE PRECISION CVACQ,EPF
      CVACQ=(CV+CA)*CQ
      WWST=
     1 +CVACQ*(-256.*T1*U1*T3*U3+256.*T1**2*T3**2)
     1 +CVACQ*T*(256.*T1*U1*T3+256.*T1*T3*S13-256.*T1*T3**2+128.*U1*T3*
     1 U3-128.*U1*U3*S13-128.*U1**2*U3)
     1 +CVACQ*T*U*(-256.*U1*T3-128.*U1*S13-128.*T3*S13-128.*S13**2)
     1 +CVACQ*T*WM2*(384.*U1*T3-128.*U1*S13-128.*U1**2+256.*T3*S13-256.
     1 *T3**2)
     1 +CVACQ*T**2*(-256.*U1*T3-256.*T3*S13)
     1 +CVACQ*U*(128.*T1*U1*T3-128.*T1*T3*S13-128.*T1*T3**2)
      WWST=WWST
     1 +CVACQ*U*WM2*(128.*U1*T3-128.*T3*S13-128.*T3**2)
     1 +CVACQ*WM2*(-256.*T1*U1*T3+512.*T1*T3**2-256.*U1*T3*U3)
     1 +CVACQ*WM2**2*(256.*U1*S13+128.*U1**2+256.*T3*S13+384.*T3**2+128
     1 .*S13**2)
     1 +EPF(P1,P2,P3,Q1)*CVACQ*(128.*T3*U3+128.*T3*S13+64.*T3**2+128.*U
     1 3*S13+64.*U3**2)
     1 +EPF(P1,P2,P3,Q1)*CVACQ*T*(-32.*T3-32.*U3-64.*S13)
     1 -32.*EPF(P1,P2,P3,Q1)*CVACQ*T*WM2
      WWST=WWST
     1 +EPF(P1,P2,P3,Q1)*CVACQ*U*(-32.*T3-32.*U3-64.*S13)
     1 -32.*EPF(P1,P2,P3,Q1)*CVACQ*U*WM2
     1 +EPF(P1,P2,P3,Q1)*CVACQ*WM2*(128.*T3+128.*U3+128.*S13)
     1 +64.*EPF(P1,P2,P3,Q1)*CVACQ*WM2**2
     1 -32.*EPF(P1,P2,P3,Q3)*CVACQ*T*WM2
     1 -32.*EPF(P1,P2,P3,Q3)*CVACQ*U*WM2
     1 +EPF(P1,P2,P3,Q3)*CVACQ*WM2*(64.*T3+64.*U3)
     1 +64.*EPF(P1,P2,P3,Q3)*CVACQ*WM2**2
      WWST=WWST
     1 +EPF(P1,P3,Q1,Q3)*CVACQ*(128.*U1*T3+128.*U1*U3)
     1 +EPF(P1,P3,Q1,Q3)*CVACQ*T*(-64.*U1)
     1 +32.*EPF(P1,P3,Q1,Q3)*CVACQ*T*U
     1 -32.*EPF(P1,P3,Q1,Q3)*CVACQ*T*WM2
     1 +EPF(P1,P3,Q1,Q3)*CVACQ*U*(-64.*U1-64.*T3-64.*U3)
     1 -96.*EPF(P1,P3,Q1,Q3)*CVACQ*U*WM2
     1 +32.*EPF(P1,P3,Q1,Q3)*CVACQ*U**2
     1 +EPF(P1,P3,Q1,Q3)*CVACQ*WM2*(128.*U1+64.*T3+64.*U3)
      WWST=WWST
     1 +64.*EPF(P1,P3,Q1,Q3)*CVACQ*WM2**2
     1 +EPF(P2,P3,Q1,Q3)*CVACQ*(-128.*T1*T3-128.*T1*U3)
     1 +EPF(P2,P3,Q1,Q3)*CVACQ*T*(64.*T1+64.*T3+64.*U3)
     1 -32.*EPF(P2,P3,Q1,Q3)*CVACQ*T*U
     1 +96.*EPF(P2,P3,Q1,Q3)*CVACQ*T*WM2
     1 -32.*EPF(P2,P3,Q1,Q3)*CVACQ*T**2
     1 +EPF(P2,P3,Q1,Q3)*CVACQ*U*(64.*T1)
     1 +32.*EPF(P2,P3,Q1,Q3)*CVACQ*U*WM2
     1 +EPF(P2,P3,Q1,Q3)*CVACQ*WM2*(-128.*T1-64.*T3-64.*U3)
     1 -64.*EPF(P2,P3,Q1,Q3)*CVACQ*WM2**2
      WWST=WWST/T
      WWST=2.*WWST
      RETURN
      END
CDECK  ID>, WWTT.   
      FUNCTION WWTT(T,U,T1,U1,T3,U3)
C          DECAY DISTRIBUTION FOR W+ W- PAIRS FROM SCHOONSCHIP(1980).
C          SQUARE OF T GRAPH.
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/WWPAR/SWW,TWW,UWW,WM2,ZM2,P1WW(5),P2WW(5),P3WW(5),P4WW(5)
     $,PZERO(4,4),S13,P3(5),Q1(5),Q3(5),JQWW(2)
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      SAVE /WWPAR/
      DOUBLE PRECISION SWW,TWW,UWW,WM2,ZM2,P1WW,P2WW,P3WW,P4WW
     $,PZERO,S13,P3,Q1,Q3
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      INTEGER   JQWW
      DOUBLE PRECISION WWTT
      DOUBLE PRECISION T,U,T1,U1,T3,U3
      WWTT=
     1(+CQ**2*(-512.*T1**2*T3**2)
     1 +CQ**2*T*(-512.*T1*U1*T3-512.*T1*T3*S13+512.*T1*T3**2)
     1 +CQ**2*T*WM2*(-512.*U1*T3-512.*T3*S13+512.*T3**2)
     1 +CQ**2*T**2*(512.*U1*T3+512.*T3*S13)
     1 +CQ**2*WM2*(-1024.*T1*T3**2)
     1 +CQ**2*WM2**2*(-512.*T3**2))/T**2
      WWTT=2.*WWTT
      RETURN
      END
CDECK  ID>, WZSS.   
      FUNCTION WZSS(T,U,T1,U1,T3,U3,P1,P2)
C          DECAY DISTRIBUTION FOR W- Z0 PAIRS FROM SCHOONSCHIP(1980).
C          SQUARE OF S GRAPH.
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/WWPAR/SWW,TWW,UWW,WM2,ZM2,P1WW(5),P2WW(5),P3WW(5),P4WW(5)
     $,PZERO(4,4),S13,P3(5),Q1(5),Q3(5),JQWW(2)
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      SAVE /WWPAR/
      DOUBLE PRECISION SWW,TWW,UWW,WM2,ZM2,P1WW,P2WW,P3WW,P4WW
     $,PZERO,S13,P3,Q1,Q3
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      INTEGER   JQWW
      DIMENSION P1(4),P2(4)
      DOUBLE PRECISION WZSS
      DOUBLE PRECISION T,U,T1,U1,T3,U3,P1,P2
      DOUBLE PRECISION WM4,ZM4,WZM2,CSXCS
      WM4=WM2**2
      ZM4=ZM2**2
      WZM2=WM2*ZM2
      CSXCS=CS**2
      WZSS=
     1 +CSXCS*CV3*(-32.*WM2*ZM2*WM4-32.*WM2*ZM2*ZM4-128.*WM2*T1*T3**2-1
     1 28.*WM2*T1*ZM4+128.*WM2*U1*T3*U3-64.*WM2*T3*ZM4-64.*WM2*S13*ZM4+
     1 64.*ZM2*T1*U1*T3+64.*ZM2*T1*U1*U3-64.*ZM2*T1*WM4-64.*ZM2*T1**2*T
     1 3-64.*ZM2*U1**2*U3-128.*ZM2*T3*WM4-64.*ZM2*S13*WM4+128.*T1*U1*T3
     1 *U3-192.*T1*T3*WZM2-64.*T1*S13*WZM2-64.*T1**2*T3**2-32.*T1**2*WZ
     1 M2-32.*T1**2*ZM4+64.*U1*U3*WZM2-64.*U1*S13*WZM2-64.*U1**2*U3**2-
     1 32.*U1**2*WZM2-32.*U1**2*ZM4-128.*T3*S13*WZM2-64.*T3**2*WZM2-64.
     1 *T3**2*WM4-64.*S13**2*WZM2-96.*WM4*ZM4)
      WZSS=WZSS
     1 +CSXCS*CV3*T*(64.*WM2*T1*T3-32.*WM2*U1*T3-32.*WM2*U1*U3-64.*WM2*
     1 T3*S13+64.*WM2*T3**2+96.*WM2*ZM4+64.*ZM2*T1*T3-32.*ZM2*T1*S13+32
     1 .*ZM2*T1**2-32.*ZM2*U1*T3-32.*ZM2*U1*U3+32.*ZM2*U1*S13+32.*ZM2*U
     1 1**2+96.*ZM2*WM4-32.*T1*U1*T3-32.*T1*U1*U3-64.*T1*T3*S13+64.*T1*
     1 T3**2+128.*T1*WZM2+32.*T1*ZM4+32.*T1**2*T3-64.*U1*T3*U3+64.*U1*U
     1 3*S13+32.*U1**2*U3+128.*T3*WZM2+32.*T3*WM4+32.*S13*WZM2)

      WZSS=WZSS
     1 +CSXCS*CV3*T*U*(-32.*WM2*T3+32.*WM2*S13-32.*ZM2*T1+32.*ZM2*S13-3
     1 2.*T1*T3+32.*T1*S13+64.*U1*T3+32.*U1*U3+32.*U1*S13+64.*T3*S13+64
     1 .*S13**2-32.*WZM2)
     1 +CSXCS*CV3*T**2*(-32.*WM2*T3+32.*WM2*S13-32.*ZM2*T1+32.*ZM2*S13-
     1 32.*T1*T3+32.*T1*S13+32.*U1*T3+32.*U1*U3+64.*T3*S13-64.*WZM2)
     1 +CSXCS*CV3*T**2*U*(-32.*S13)
     1 +CSXCS*CV3*T**3*(-32.*S13)
      WZSS=WZSS
     1 +CSXCS*CV3*U*(64.*WM2*T1*T3-32.*WM2*U1*T3-32.*WM2*U1*U3+64.*WM2*
     1 T3*S13+64.*WM2*T3**2+32.*WM2*ZM4+64.*ZM2*T1*T3+32.*ZM2*T1*S13+32
     1 .*ZM2*T1**2-32.*ZM2*U1*T3-32.*ZM2*U1*U3-32.*ZM2*U1*S13+32.*ZM2*U
     1 1**2+32.*ZM2*WM4-32.*T1*U1*T3-32.*T1*U1*U3+64.*T1*T3*S13+64.*T1*
     1 T3**2+64.*T1*WZM2+32.*T1*ZM4+32.*T1**2*T3-64.*U1*T3*U3-64.*U1*U3
     1 *S13+32.*U1**2*U3+64.*T3*WZM2+32.*T3*WM4+32.*S13*WZM2)
     1 +CSXCS*CV3*U**2*(32.*U1*T3+32.*U1*S13)
      WZSS=WZSS
     1 +CSXCS*CA3*(32.*WM2*ZM2*WM4+32.*WM2*ZM2*ZM4+128.*WM2*T1*ZM4+64.*
     1 WM2*T3*ZM4+64.*WM2*S13*ZM4+64.*ZM2*T1*U1*T3-64.*ZM2*T1*U1*U3+64.
     1 *ZM2*T1*WM4+64.*ZM2*T1**2*T3-64.*ZM2*U1**2*U3+128.*ZM2*T3*WM4+64
     1 .*ZM2*S13*WM4+192.*T1*T3*WZM2+64.*T1*S13*WZM2+32.*T1**2*WZM2+32.
     1 *T1**2*ZM4-64.*U1*U3*WZM2-64.*U1*S13*WZM2-32.*U1**2*WZM2-32.*U1*
     1 *2*ZM4+96.*WM4*ZM4)
      WZSS=WZSS
     1 +CSXCS*CA3*T*(-64.*WM2*T1*T3-32.*WM2*U1*T3+32.*WM2*U1*U3-96.*WM2
     1 *ZM4-64.*ZM2*T1*T3+32.*ZM2*T1*S13-32.*ZM2*T1**2-32.*ZM2*U1*T3+32
     1 .*ZM2*U1*U3+32.*ZM2*U1*S13+32.*ZM2*U1**2-96.*ZM2*WM4-32.*T1*U1*T
     1 3+32.*T1*U1*U3-128.*T1*WZM2-32.*T1*ZM4-32.*T1**2*T3+32.*U1**2*U3
     1 -128.*T3*WZM2-32.*T3*WM4-32.*S13*WZM2)
     1 +CSXCS*CA3*T*U*(32.*WM2*T3-32.*WM2*S13+32.*ZM2*T1-32.*ZM2*S13+32
     1 .*T1*T3-32.*T1*S13+64.*U1*T3-32.*U1*U3+32.*U1*S13+32.*WZM2)
      WZSS=WZSS
     1 +CSXCS*CA3*T**2*(32.*WM2*T3-32.*WM2*S13+32.*ZM2*T1-32.*ZM2*S13+3
     1 2.*T1*T3-32.*T1*S13+32.*U1*T3-32.*U1*U3+64.*WZM2)
     1 +CSXCS*CA3*T**2*U*(32.*S13)
     1 +CSXCS*CA3*T**3*(32.*S13)
      WZSS=WZSS
     1 +CSXCS*CA3*U*(-64.*WM2*T1*T3-32.*WM2*U1*T3+32.*WM2*U1*U3-32.*WM2
     1 *ZM4-64.*ZM2*T1*T3-32.*ZM2*T1*S13-32.*ZM2*T1**2-32.*ZM2*U1*T3+32
     1 .*ZM2*U1*U3-32.*ZM2*U1*S13+32.*ZM2*U1**2-32.*ZM2*WM4-32.*T1*U1*T
     1 3+32.*T1*U1*U3-64.*T1*WZM2-32.*T1*ZM4-32.*T1**2*T3+32.*U1**2*U3-
     1 64.*T3*WZM2-32.*T3*WM4-32.*S13*WZM2)
     1 +CSXCS*CA3*U**2*(32.*U1*T3+32.*U1*S13)
      RETURN
      END
CDECK  ID>, WZST.   
      FUNCTION WZST(T,U,T1,U1,T3,U3,P1,P2)
C          DECAY DISTRIBUTION FOR W- Z0 PAIRS FROM SCHOONSCHIP(1980).
C          INTERFERENCE OF S AND T GRAPHS.
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/WWPAR/SWW,TWW,UWW,WM2,ZM2,P1WW(5),P2WW(5),P3WW(5),P4WW(5)
     $,PZERO(4,4),S13,P3(5),Q1(5),Q3(5),JQWW(2)
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      SAVE /WWPAR/
      DOUBLE PRECISION SWW,TWW,UWW,WM2,ZM2,P1WW,P2WW,P3WW,P4WW
     $,PZERO,S13,P3,Q1,Q3
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      INTEGER   JQWW
      DIMENSION P1(4),P2(4)
      DOUBLE PRECISION WZST
      DOUBLE PRECISION T,U,T1,U1,T3,U3,P1,P2
      DOUBLE PRECISION WM4,ZM4,WZM2,CSXCT,EPF
      WM4=WM2**2
      ZM4=ZM2**2
      WZM2=WM2*ZM2
      CSXCT=CS*CT/T
      WZST=
     1 +CSXCT*CV3*(32.*WM2*ZM2*WM4+32.*WM2*ZM2*ZM4+256.*WM2*T1*T3**2+19
     1 2.*WM2*T1*ZM4-128.*WM2*U1*T3*U3+64.*WM2*T3*ZM4+64.*WM2*S13*ZM4-6
     1 4.*ZM2*T1*U1*T3-64.*ZM2*T1*U1*U3+64.*ZM2*T1*WM4+128.*ZM2*T1**2*T
     1 3+192.*ZM2*T3*WM4+64.*ZM2*S13*WM4-128.*T1*U1*T3*U3+320.*T1*T3*WZ
     1 M2+64.*T1*S13*WZM2+128.*T1**2*T3**2+32.*T1**2*WZM2+64.*T1**2*ZM4
     1 -64.*U1*U3*WZM2+64.*U1*S13*WZM2+32.*U1**2*WZM2+128.*T3*S13*WZM2+
     1 64.*T3**2*WZM2+128.*T3**2*WM4+64.*S13**2*WZM2+128.*WM4*ZM4)
      WZST=WZST
     1 +CSXCT*CV3*T*(-128.*WM2*T1*T3+64.*WM2*U1*T3+32.*WM2*U1*U3+128.*W
     1 M2*T3*S13-128.*WM2*T3**2-128.*WM2*ZM4-128.*ZM2*T1*T3+64.*ZM2*T1*
     1 S13-64.*ZM2*T1**2+32.*ZM2*U1*T3+32.*ZM2*U1*U3-32.*ZM2*U1*S13-32.
     1 *ZM2*U1**2-128.*ZM2*WM4+64.*T1*U1*T3+32.*T1*U1*U3+128.*T1*T3*S13
     1 -128.*T1*T3**2-192.*T1*WZM2-64.*T1*ZM4-64.*T1**2*T3+64.*U1*T3*U3
     1 -64.*U1*U3*S13-32.*U1**2*U3-192.*T3*WZM2-64.*T3*WM4)
      WZST=WZST
     1 +CSXCT*CV3*T*U*(32.*WM2*T3-32.*WM2*S13+32.*ZM2*T1-32.*ZM2*S13+32
     1 .*T1*T3-32.*T1*S13-64.*U1*T3-32.*U1*S13-64.*T3*S13-64.*S13**2+32
     1 .*WZM2)
     1 +CSXCT*CV3*T**2*(64.*WM2*T3-64.*WM2*S13+64.*ZM2*T1-64.*ZM2*S13+6
     1 4.*T1*T3-64.*T1*S13-64.*U1*T3-32.*U1*U3-128.*T3*S13+96.*WZM2)
     1 +CSXCT*CV3*T**2*U*(32.*S13)
      WZST=WZST
     1 +CSXCT*CV3*T**3*(64.*S13)
     1 +CSXCT*CV3*U*(-64.*WM2*T1*T3+32.*WM2*U1*T3-64.*WM2*T3*S13-64.*WM
     1 2*T3**2-32.*WM2*ZM4-64.*ZM2*T1*T3-32.*ZM2*T1*S13-32.*ZM2*T1**2-3
     1 2.*ZM2*WM4+32.*T1*U1*T3-64.*T1*T3*S13-64.*T1*T3**2-64.*T1*WZM2-3
     1 2.*T1*ZM4-32.*T1**2*T3-64.*T3*WZM2-32.*T3*WM4-32.*S13*WZM2)
      WZST=WZST
     1 +CSXCT*CA3*(-32.*WM2*ZM2*WM4-32.*WM2*ZM2*ZM4-192.*WM2*T1*ZM4-64.
     1 *WM2*T3*ZM4-64.*WM2*S13*ZM4-64.*ZM2*T1*U1*T3+64.*ZM2*T1*U1*U3-64
     1 .*ZM2*T1*WM4-128.*ZM2*T1**2*T3-192.*ZM2*T3*WM4-64.*ZM2*S13*WM4-3
     1 20.*T1*T3*WZM2-64.*T1*S13*WZM2-32.*T1**2*WZM2-64.*T1**2*ZM4+64.*
     1 U1*U3*WZM2+64.*U1*S13*WZM2+32.*U1**2*WZM2-128.*WM4*ZM4)
      WZST=WZST
     1 +CSXCT*CA3*T*(128.*WM2*T1*T3+64.*WM2*U1*T3-32.*WM2*U1*U3+128.*WM
     1 2*ZM4+128.*ZM2*T1*T3-64.*ZM2*T1*S13+64.*ZM2*T1**2+32.*ZM2*U1*T3-
     1 32.*ZM2*U1*U3-32.*ZM2*U1*S13-32.*ZM2*U1**2+128.*ZM2*WM4+64.*T1*U
     1 1*T3-32.*T1*U1*U3+192.*T1*WZM2+64.*T1*ZM4+64.*T1**2*T3-32.*U1**2
     1 *U3+192.*T3*WZM2+64.*T3*WM4)
      WZST=WZST
     1 +CSXCT*CA3*T*U*(-32.*WM2*T3+32.*WM2*S13-32.*ZM2*T1+32.*ZM2*S13-3
     1 2.*T1*T3+32.*T1*S13-64.*U1*T3-32.*U1*S13-32.*WZM2)
     1 +CSXCT*CA3*T**2*(-64.*WM2*T3+64.*WM2*S13-64.*ZM2*T1+64.*ZM2*S13-
     1 64.*T1*T3+64.*T1*S13-64.*U1*T3+32.*U1*U3-96.*WZM2)
     1 +CSXCT*CA3*T**2*U*(-32.*S13)
     1 +CSXCT*CA3*T**3*(-64.*S13)
      WZST=WZST
     1 +CSXCT*CA3*U*(64.*WM2*T1*T3+32.*WM2*U1*T3+32.*WM2*ZM4+64.*ZM2*T1
     1 *T3+32.*ZM2*T1*S13+32.*ZM2*T1**2+32.*ZM2*WM4+32.*T1*U1*T3+64.*T1
     1 *WZM2+32.*T1*ZM4+32.*T1**2*T3+64.*T3*WZM2+32.*T3*WM4+32.*S13*WZM
     1 2)
     1 +EPF(P1,P2,P3,Q1)*CSXCT*CV3*(64.*ZM2*T3+64.*ZM2*U3+64.*ZM2*S13+6
     1 4.*T3*U3+64.*T3*S13+32.*T3**2+64.*U3*S13+32.*U3**2+32.*ZM4)
      WZST=WZST
     1 +EPF(P1,P2,P3,Q1)*CSXCT*CV3*T*(-16.*ZM2-16.*T3-16.*U3-32.*S13)
     1 +EPF(P1,P2,P3,Q1)*CSXCT*CV3*U*(-16.*ZM2-16.*T3-16.*U3-32.*S13)
     1 +EPF(P1,P2,P3,Q3)*CSXCT*CV3*(32.*WM2*T3+32.*WM2*U3+32.*WZM2)
     1 +EPF(P1,P2,P3,Q3)*CSXCT*CV3*T*(-16.*WM2)
     1 +EPF(P1,P2,P3,Q3)*CSXCT*CV3*U*(-16.*WM2)
     1 +EPF(P1,P3,Q1,Q3)*CSXCT*CV3*(32.*WM2*T3+32.*WM2*U3+64.*ZM2*U1+64
     1 .*U1*T3+64.*U1*U3+32.*WZM2)
      WZST=WZST
     1 +EPF(P1,P3,Q1,Q3)*CSXCT*CV3*T*(-16.*WM2-32.*U1)
     1 +16.*EPF(P1,P3,Q1,Q3)*CSXCT*CV3*T*U
     1 +EPF(P1,P3,Q1,Q3)*CSXCT*CV3*U*(-16.*WM2-32.*ZM2-32.*U1-32.*T3-32
     1 .*U3)
     1 +16.*EPF(P1,P3,Q1,Q3)*CSXCT*CV3*U**2
     1 +EPF(P2,P3,Q1,Q3)*CSXCT*CV3*(-32.*WM2*T3-32.*WM2*U3-64.*ZM2*T1-6
     1 4.*T1*T3-64.*T1*U3-32.*WZM2)
      WZST=WZST
     1 +EPF(P2,P3,Q1,Q3)*CSXCT*CV3*T*(16.*WM2+32.*ZM2+32.*T1+32.*T3+32.
     1 *U3)
     1 -16.*EPF(P2,P3,Q1,Q3)*CSXCT*CV3*T*U
     1 -16.*EPF(P2,P3,Q1,Q3)*CSXCT*CV3*T**2
     1 +EPF(P2,P3,Q1,Q3)*CSXCT*CV3*U*(16.*WM2+32.*T1)
      RETURN
      END
CDECK  ID>, WZSU.   
      FUNCTION WZSU(T,U,T1,U1,T3,U3,P1,P2)
C          DECAY DISTRIBUTION FOR W- Z0 PAIRS FROM SCHOONSCHIP(1980).
C          INTERFERENCE OF S AND U GRAPHS.
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/WWPAR/SWW,TWW,UWW,WM2,ZM2,P1WW(5),P2WW(5),P3WW(5),P4WW(5)
     $,PZERO(4,4),S13,P3(5),Q1(5),Q3(5),JQWW(2)
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      SAVE /WWPAR/
      DOUBLE PRECISION SWW,TWW,UWW,WM2,ZM2,P1WW,P2WW,P3WW,P4WW
     $,PZERO,S13,P3,Q1,Q3
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      INTEGER   JQWW
      DIMENSION P1(4),P2(4)
      DOUBLE PRECISION WZSU
      DOUBLE PRECISION T,U,T1,U1,T3,U3,P1,P2
      DOUBLE PRECISION WM4,ZM4,WZM2,CSXCU,EPF
      WM4=WM2**2
      ZM4=ZM2**2
      WZM2=WM2*ZM2
      CSXCU=CS*CU/U
      WZSU=
     1 +CSXCU*CV3*(-32.*WM2*ZM2*WM4-32.*WM2*ZM2*ZM4-64.*WM2*T1*ZM4+128.
     1 *WM2*U1*T3*U3-64.*WM2*T3*ZM4-64.*WM2*S13*ZM4+64.*ZM2*T1*U1*T3+64
     1 .*ZM2*T1*U1*U3-64.*ZM2*T1*WM4-128.*ZM2*U1**2*U3-64.*ZM2*T3*WM4-6
     1 4.*ZM2*S13*WM4+128.*T1*U1*T3*U3-64.*T1*T3*WZM2-64.*T1*S13*WZM2-3
     1 2.*T1**2*WZM2+64.*U1*U3*WZM2-64.*U1*S13*WZM2-128.*U1**2*U3**2-32
     1 .*U1**2*WZM2-64.*U1**2*ZM4-128.*T3*S13*WZM2-64.*T3**2*WZM2-64.*S
     1 13**2*WZM2-64.*WM4*ZM4)
      WZSU=WZSU
     1 +CSXCU*CV3*T*(-32.*WM2*U1*U3+64.*WM2*ZM4-32.*ZM2*U1*T3-32.*ZM2*U
     1 1*U3+32.*ZM2*U1*S13+32.*ZM2*U1**2+64.*ZM2*WM4-32.*T1*U1*U3+64.*T
     1 1*WZM2-64.*U1*T3*U3+64.*U1*U3*S13+32.*U1**2*U3+64.*T3*WZM2+64.*S
     1 13*WZM2)
     1 +CSXCU*CV3*T*U*(-32.*WM2*T3+32.*WM2*S13-32.*ZM2*T1+32.*ZM2*S13-3
     1 2.*T1*T3+32.*T1*S13+64.*U1*T3+64.*U1*U3+32.*U1*S13+64.*T3*S13+64
     1 .*S13**2-32.*WZM2)
      WZSU=WZSU
     1 +CSXCU*CV3*T**2*(32.*U1*U3-32.*WZM2)
     1 +CSXCU*CV3*T**2*U*(-32.*S13)
      WZSU=WZSU
     1 +CSXCU*CV3*U*(64.*WM2*T1*T3-32.*WM2*U1*T3-64.*WM2*U1*U3+64.*WM2*
     1 T3*S13+64.*WM2*T3**2+32.*WM2*ZM4+64.*ZM2*T1*T3+32.*ZM2*T1*S13+32
     1 .*ZM2*T1**2-64.*ZM2*U1*T3-64.*ZM2*U1*U3-64.*ZM2*U1*S13+64.*ZM2*U
     1 1**2+32.*ZM2*WM4-32.*T1*U1*T3-64.*T1*U1*U3+64.*T1*T3*S13+64.*T1*
     1 T3**2+64.*T1*WZM2+32.*T1*ZM4+32.*T1**2*T3-128.*U1*T3*U3-128.*U1*
     1 U3*S13+64.*U1**2*U3+64.*T3*WZM2+32.*T3*WM4+32.*S13*WZM2)
      WZSU=WZSU
     1 +CSXCU*CV3*U**2*(64.*U1*T3+64.*U1*S13)
     1 +CSXCU*CA3*(32.*WM2*ZM2*WM4+32.*WM2*ZM2*ZM4+64.*WM2*T1*ZM4+64.*W
     1 M2*T3*ZM4+64.*WM2*S13*ZM4+64.*ZM2*T1*U1*T3-64.*ZM2*T1*U1*U3+64.*
     1 ZM2*T1*WM4-128.*ZM2*U1**2*U3+64.*ZM2*T3*WM4+64.*ZM2*S13*WM4+64.*
     1 T1*T3*WZM2+64.*T1*S13*WZM2+32.*T1**2*WZM2-64.*U1*U3*WZM2-64.*U1*
     1 S13*WZM2-32.*U1**2*WZM2-64.*U1**2*ZM4+64.*WM4*ZM4)
      WZSU=WZSU
     1 +CSXCU*CA3*T*(32.*WM2*U1*U3-64.*WM2*ZM4-32.*ZM2*U1*T3+32.*ZM2*U1
     1 *U3+32.*ZM2*U1*S13+32.*ZM2*U1**2-64.*ZM2*WM4+32.*T1*U1*U3-64.*T1
     1 *WZM2+32.*U1**2*U3-64.*T3*WZM2-64.*S13*WZM2)
     1 +CSXCU*CA3*T*U*(32.*WM2*T3-32.*WM2*S13+32.*ZM2*T1-32.*ZM2*S13+32
     1 .*T1*T3-32.*T1*S13+64.*U1*T3-64.*U1*U3+32.*U1*S13+32.*WZM2)
     1 +CSXCU*CA3*T**2*(-32.*U1*U3+32.*WZM2)
      WZSU=WZSU
     1 +CSXCU*CA3*T**2*U*(32.*S13)
     1 +CSXCU*CA3*U*(-64.*WM2*T1*T3-32.*WM2*U1*T3+64.*WM2*U1*U3-32.*WM2
     1 *ZM4-64.*ZM2*T1*T3-32.*ZM2*T1*S13-32.*ZM2*T1**2-64.*ZM2*U1*T3+64
     1 .*ZM2*U1*U3-64.*ZM2*U1*S13+64.*ZM2*U1**2-32.*ZM2*WM4-32.*T1*U1*T
     1 3+64.*T1*U1*U3-64.*T1*WZM2-32.*T1*ZM4-32.*T1**2*T3+64.*U1**2*U3-
     1 64.*T3*WZM2-32.*T3*WM4-32.*S13*WZM2)
      WZSU=WZSU
     1 +CSXCU*CA3*U**2*(64.*U1*T3+64.*U1*S13)
     1 +EPF(P1,P2,P3,Q1)*CSXCU*CV3*(32.*ZM2*T1+32.*ZM2*U1+32.*WZM2)
     1 +EPF(P1,P2,P3,Q1)*CSXCU*CV3*T*(-16.*ZM2)
     1 +EPF(P1,P2,P3,Q1)*CSXCU*CV3*U*(-16.*ZM2)
     1 +EPF(P1,P2,P3,Q3)*CSXCU*CV3*(64.*WM2*T1+64.*WM2*U1+64.*WM2*S13+6
     1 4.*T1*U1+64.*T1*S13+32.*T1**2+64.*U1*S13+32.*U1**2+32.*WM4)
      WZSU=WZSU
     1 +EPF(P1,P2,P3,Q3)*CSXCU*CV3*T*(-16.*WM2-16.*T1-16.*U1-32.*S13)
     1 +EPF(P1,P2,P3,Q3)*CSXCU*CV3*U*(-16.*WM2-16.*T1-16.*U1-32.*S13)
     1 +EPF(P1,P2,Q1,Q3)*CSXCU*CV3*(64.*WM2*T3+64.*WM2*U3+64.*ZM2*T1+64
     1 .*ZM2*U1+64.*T1*T3+64.*T1*U3+64.*U1*T3+64.*U1*U3+64.*WZM2)
     1 +EPF(P1,P2,Q1,Q3)*CSXCU*CV3*T*(-32.*WM2-32.*ZM2-32.*T1-32.*U1-32
     1 .*T3-32.*U3)
      WZSU=WZSU
     1 +32.*EPF(P1,P2,Q1,Q3)*CSXCU*CV3*T*U
     1 +16.*EPF(P1,P2,Q1,Q3)*CSXCU*CV3*T**2
     1 +EPF(P1,P2,Q1,Q3)*CSXCU*CV3*U*(-32.*WM2-32.*ZM2-32.*T1-32.*U1-32
     1 .*T3-32.*U3)
     1 +16.*EPF(P1,P2,Q1,Q3)*CSXCU*CV3*U**2
     1 +EPF(P1,P3,Q1,Q3)*CSXCU*CV3*(-64.*WM2*T3-32.*ZM2*T1-32.*ZM2*U1-6
     1 4.*T1*T3-64.*U1*T3-32.*WZM2)
      WZSU=WZSU
     1 +EPF(P1,P3,Q1,Q3)*CSXCU*CV3*T*(32.*WM2+16.*ZM2+32.*T1+32.*U1+32.
     1 *T3)
     1 -16.*EPF(P1,P3,Q1,Q3)*CSXCU*CV3*T*U
     1 -16.*EPF(P1,P3,Q1,Q3)*CSXCU*CV3*T**2
     1 +EPF(P1,P3,Q1,Q3)*CSXCU*CV3*U*(16.*ZM2+32.*T3)
     1 +EPF(P2,P3,Q1,Q3)*CSXCU*CV3*(64.*WM2*U3+32.*ZM2*T1+32.*ZM2*U1+64
     1 .*T1*U3+64.*U1*U3+32.*WZM2)
      WZSU=WZSU
     1 +EPF(P2,P3,Q1,Q3)*CSXCU*CV3*T*(-16.*ZM2-32.*U3)
     1 +16.*EPF(P2,P3,Q1,Q3)*CSXCU*CV3*T*U
     1 +EPF(P2,P3,Q1,Q3)*CSXCU*CV3*U*(-32.*WM2-16.*ZM2-32.*T1-32.*U1-32
     1 .*U3)
     1 +16.*EPF(P2,P3,Q1,Q3)*CSXCU*CV3*U**2
      RETURN
      END
CDECK  ID>, WZTU.   
      FUNCTION WZTU(T,U,T1,U1,T3,U3,P1,P2)
C          DECAY DISTRIBUTION FOR W- Z0 PAIRS FROM SCHOONSCHIP(1980).
C          ALL T AND U GRAPH TERMS.
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/WWPAR/SWW,TWW,UWW,WM2,ZM2,P1WW(5),P2WW(5),P3WW(5),P4WW(5)
     $,PZERO(4,4),S13,P3(5),Q1(5),Q3(5),JQWW(2)
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      SAVE /WWPAR/
      DOUBLE PRECISION SWW,TWW,UWW,WM2,ZM2,P1WW,P2WW,P3WW,P4WW
     $,PZERO,S13,P3,Q1,Q3
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      INTEGER   JQWW
      DIMENSION P1(4),P2(4)
      DOUBLE PRECISION WZTU
      DOUBLE PRECISION T,U,T1,U1,T3,U3,P1,P2
      DOUBLE PRECISION WM4,ZM4,WZM2,CTXCT,CTXCU,CUXCU,EPF
      WM4=WM2**2
      ZM4=ZM2**2
      WZM2=WM2*ZM2
      CTXCT=CT**2/T**2
      CTXCU=CT*CU/(T*U)
      CUXCU=CU**2/U**2
      WZTU=
     1 +CTXCT*CV3*(-128.*WM2*T1*T3**2-64.*WM2*T1*ZM4-64.*ZM2*T1**2*T3-6
     1 4.*ZM2*T3*WM4-128.*T1*T3*WZM2-64.*T1**2*T3**2-32.*T1**2*ZM4-64.*
     1 T3**2*WM4-32.*WM4*ZM4)
      WZTU=WZTU
     1 +CTXCT*CV3*T*(64.*WM2*T1*T3-32.*WM2*U1*T3-64.*WM2*T3*S13+64.*WM2
     1 *T3**2+32.*WM2*ZM4+64.*ZM2*T1*T3-32.*ZM2*T1*S13+32.*ZM2*T1**2+32
     1 .*ZM2*WM4-32.*T1*U1*T3-64.*T1*T3*S13+64.*T1*T3**2+64.*T1*WZM2+32
     1 .*T1*ZM4+32.*T1**2*T3+64.*T3*WZM2+32.*T3*WM4-32.*S13*WZM2)
     1 +CTXCT*CV3*T**2*(-32.*WM2*T3+32.*WM2*S13-32.*ZM2*T1+32.*ZM2*S13-
     1 32.*T1*T3+32.*T1*S13+32.*U1*T3+64.*T3*S13-32.*WZM2)
      WZTU=WZTU
     1 +CTXCT*CV3*T**3*(-32.*S13)
     1 +CTXCT*CA3*(64.*WM2*T1*ZM4+64.*ZM2*T1**2*T3+64.*ZM2*T3*WM4+128.*
     1 T1*T3*WZM2+32.*T1**2*ZM4+32.*WM4*ZM4)
     1 +CTXCT*CA3*T*(-64.*WM2*T1*T3-32.*WM2*U1*T3-32.*WM2*ZM4-64.*ZM2*T
     1 1*T3+32.*ZM2*T1*S13-32.*ZM2*T1**2-32.*ZM2*WM4-32.*T1*U1*T3-64.*T
     1 1*WZM2-32.*T1*ZM4-32.*T1**2*T3-64.*T3*WZM2-32.*T3*WM4+32.*S13*WZ
     1 M2)
      WZTU=WZTU
     1 +CTXCT*CA3*T**2*(32.*WM2*T3-32.*WM2*S13+32.*ZM2*T1-32.*ZM2*S13+3
     1 2.*T1*T3-32.*T1*S13+32.*U1*T3+32.*WZM2)
     1 +CTXCT*CA3*T**3*(32.*S13)
      WZTU=WZTU
     1 +CTXCU*CV3*(32.*WM2*ZM2*WM4+32.*WM2*ZM2*ZM4+64.*WM2*T1*ZM4-128.*
     1 WM2*U1*T3*U3+64.*WM2*T3*ZM4+64.*WM2*S13*ZM4-64.*ZM2*T1*U1*T3-64.
     1 *ZM2*T1*U1*U3+64.*ZM2*T1*WM4+64.*ZM2*T3*WM4+64.*ZM2*S13*WM4-128.
     1 *T1*U1*T3*U3+64.*T1*T3*WZM2+64.*T1*S13*WZM2+32.*T1**2*WZM2-64.*U
     1 1*U3*WZM2+64.*U1*S13*WZM2+32.*U1**2*WZM2+128.*T3*S13*WZM2+64.*T3
     1 **2*WZM2+64.*S13**2*WZM2+64.*WM4*ZM4)
      WZTU=WZTU
     1 +CTXCU*CV3*T*(32.*WM2*U1*U3-64.*WM2*ZM4+32.*ZM2*U1*T3+32.*ZM2*U1
     1 *U3-32.*ZM2*U1*S13-32.*ZM2*U1**2-64.*ZM2*WM4+32.*T1*U1*U3-64.*T1
     1 *WZM2+64.*U1*T3*U3-64.*U1*U3*S13-32.*U1**2*U3-64.*T3*WZM2-64.*S1
     1 3*WZM2)
     1 +CTXCU*CV3*T*U*(32.*WM2*T3-32.*WM2*S13+32.*ZM2*T1-32.*ZM2*S13+32
     1 .*T1*T3-32.*T1*S13-64.*U1*T3-32.*U1*S13-64.*T3*S13-64.*S13**2+32
     1 .*WZM2)
      WZTU=WZTU
     1 +CTXCU*CV3*T**2*(-32.*U1*U3+32.*WZM2)
     1 +CTXCU*CV3*T**2*U*(32.*S13)
     1 +CTXCU*CV3*U*(-64.*WM2*T1*T3+32.*WM2*U1*T3-64.*WM2*T3*S13-64.*WM
     1 2*T3**2-32.*WM2*ZM4-64.*ZM2*T1*T3-32.*ZM2*T1*S13-32.*ZM2*T1**2-3
     1 2.*ZM2*WM4+32.*T1*U1*T3-64.*T1*T3*S13-64.*T1*T3**2-64.*T1*WZM2-3
     1 2.*T1*ZM4-32.*T1**2*T3-64.*T3*WZM2-32.*T3*WM4-32.*S13*WZM2)
      WZTU=WZTU
     1 +CTXCU*CA3*(-32.*WM2*ZM2*WM4-32.*WM2*ZM2*ZM4-64.*WM2*T1*ZM4-64.*
     1 WM2*T3*ZM4-64.*WM2*S13*ZM4-64.*ZM2*T1*U1*T3+64.*ZM2*T1*U1*U3-64.
     1 *ZM2*T1*WM4-64.*ZM2*T3*WM4-64.*ZM2*S13*WM4-64.*T1*T3*WZM2-64.*T1
     1 *S13*WZM2-32.*T1**2*WZM2+64.*U1*U3*WZM2+64.*U1*S13*WZM2+32.*U1**
     1 2*WZM2-64.*WM4*ZM4)
      WZTU=WZTU
     1 +CTXCU*CA3*T*(-32.*WM2*U1*U3+64.*WM2*ZM4+32.*ZM2*U1*T3-32.*ZM2*U
     1 1*U3-32.*ZM2*U1*S13-32.*ZM2*U1**2+64.*ZM2*WM4-32.*T1*U1*U3+64.*T
     1 1*WZM2-32.*U1**2*U3+64.*T3*WZM2+64.*S13*WZM2)
     1 +CTXCU*CA3*T*U*(-32.*WM2*T3+32.*WM2*S13-32.*ZM2*T1+32.*ZM2*S13-3
     1 2.*T1*T3+32.*T1*S13-64.*U1*T3-32.*U1*S13-32.*WZM2)
     1 +CTXCU*CA3*T**2*(32.*U1*U3-32.*WZM2)
      WZTU=WZTU
     1 +CTXCU*CA3*T**2*U*(-32.*S13)
     1 +CTXCU*CA3*U*(64.*WM2*T1*T3+32.*WM2*U1*T3+32.*WM2*ZM4+64.*ZM2*T1
     1 *T3+32.*ZM2*T1*S13+32.*ZM2*T1**2+32.*ZM2*WM4+32.*T1*U1*T3+64.*T1
     1 *WZM2+32.*T1*ZM4+32.*T1**2*T3+64.*T3*WZM2+32.*T3*WM4+32.*S13*WZM
     1 2)
     1 +CUXCU*CV3*(-64.*ZM2*U1**2*U3-64.*U1**2*U3**2-32.*U1**2*ZM4)
      WZTU=WZTU
     1 +CUXCU*CV3*T*U*(32.*U1*U3)
     1 +CUXCU*CV3*U*(-32.*WM2*U1*U3-32.*ZM2*U1*T3-32.*ZM2*U1*U3-32.*ZM2
     1 *U1*S13+32.*ZM2*U1**2-32.*T1*U1*U3-64.*U1*T3*U3-64.*U1*U3*S13+32
     1 .*U1**2*U3)
     1 +CUXCU*CV3*U**2*(32.*U1*T3+32.*U1*S13)
     1 +CUXCU*CA3*(-64.*ZM2*U1**2*U3-32.*U1**2*ZM4)
      WZTU=WZTU
     1 +CUXCU*CA3*T*U*(-32.*U1*U3)
     1 +CUXCU*CA3*U*(32.*WM2*U1*U3-32.*ZM2*U1*T3+32.*ZM2*U1*U3-32.*ZM2*
     1 U1*S13+32.*ZM2*U1**2+32.*T1*U1*U3+32.*U1**2*U3)
     1 +CUXCU*CA3*U**2*(32.*U1*T3+32.*U1*S13)
     1 +EPF(P1,P2,P3,Q1)*CTXCU*CV3*(-32.*ZM2*T1-16.*WZM2)
     1 +EPF(P1,P2,P3,Q1)*CTXCU*CV3*T*(16.*ZM2)
      WZTU=WZTU
     1 +EPF(P1,P2,P3,Q3)*CTXCU*CV3*(-48.*WM2*T1-16.*WM2*U1-32.*WM2*S13-
     1 32.*T1*U1-64.*T1*S13-32.*T1**2-16.*WM4)
     1 +EPF(P1,P2,P3,Q3)*CTXCU*CV3*T*(16.*WM2+16.*T1+16.*U1+32.*S13)
     1 +EPF(P1,P2,Q1,Q3)*CTXCU*CV3*(-32.*WM2*T3-32.*WM2*U3-64.*ZM2*T1-6
     1 4.*T1*T3-64.*T1*U3-32.*WZM2)
     1 +EPF(P1,P2,Q1,Q3)*CTXCU*CV3*T*(16.*WM2+32.*ZM2+32.*T1+32.*T3+32.
     1 *U3)
      WZTU=WZTU
     1 -16.*EPF(P1,P2,Q1,Q3)*CTXCU*CV3*T*U
     1 -16.*EPF(P1,P2,Q1,Q3)*CTXCU*CV3*T**2
     1 +EPF(P1,P2,Q1,Q3)*CTXCU*CV3*U*(16.*WM2+32.*T1)
     1 +EPF(P1,P3,Q1,Q3)*CTXCU*CV3*(32.*WM2*T3+32.*ZM2*T1+64.*T1*T3+16.
     1 *WZM2)
     1 +EPF(P1,P3,Q1,Q3)*CTXCU*CV3*T*(-16.*WM2-16.*ZM2-32.*T1-32.*T3)
      WZTU=WZTU
     1 +16.*EPF(P1,P3,Q1,Q3)*CTXCU*CV3*T**2
     1 +EPF(P2,P3,Q1,Q3)*CTXCU*CV3*(-32.*WM2*U3-32.*ZM2*T1-64.*T1*U3-16
     1 .*WZM2)
     1 +EPF(P2,P3,Q1,Q3)*CTXCU*CV3*T*(16.*ZM2+32.*U3)
     1 -16.*EPF(P2,P3,Q1,Q3)*CTXCU*CV3*T*U
     1 +EPF(P2,P3,Q1,Q3)*CTXCU*CV3*U*(16.*WM2+32.*T1)+0.
      RETURN
      END
CDECK  ID>, XWWWW.  
      SUBROUTINE XWWWW
C
C          SET UP W+ W- -> W+ W- AMPLITUDES AS RATIONAL FUNCTIONS OF Z
C
C          RE(F(Z,L)) = SUM(I,J)(ANWWWW(I+1,J,L)*Z**I
C                                  /(ADWWWW(1,J)+ADWWWW(2,J)*Z))
C          IM(F(Z,L)) = AIWWWW(L)   (INDEPENDENT OF Z)
C          J LABELS PIECES WITH SAME DENOMINATOR.
C          L=1 FOR 0,0; L=2 FOR 1,-1; L=3 FOR 1,1; L=4 FOR 0,1
C
C          *NOTE* A FACTOR OF SIN(THETA)/SQRT(2) IS REMOVED FROM F01
C
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
      DOUBLE PRECISION WM,ZM,ZM2,ZM3,ZM4,ZM5,ZM6,HM,HM2,HM3,HM4,HG,HG2
     $,PROPH,RTS,S,S2,S3,SW,QQ0,QQI,QQF
C
C          USE UNITS OF WM TO AVOID LARGE NUMBERS - NOTE ANWWWW/ADWWWW
C          AND AIWWWW ARE DIMENSIONLESS
      WM=WMASS(2)
      ZM=WMASS(4)/WM
      ZM2=ZM**2
      ZM3=ZM**3
      ZM4=ZM**4
      ZM5=ZM**5
      ZM6=ZM**6
      HM=HMASS/WM
      HM2=HM**2
      HM3=HM**3
      HM4=HM**4
      HG=HGAM/WM
      HG2=HG**2
      RTS=QMW/WM
      S=RTS**2
      S2=S**2
      S3=S**3
      PROPH=(S-HM2)**2+(HM*HG)**2
C
      CW=1./ZM
      CW2=CW**2
      SW2=1.-CW2
      SW=SQRT(SW2)
      QQ0=.5*RTS
      QQI=.5*SQRT(S-4.)
      QQF=.5*SQRT(S-4.)
      GSQ=4.*PI*ALFA/SW2
C
C          FROM WWWW3.EX
      ANWWWW(1,1,1) = 8.00E+00 * S - 3.00E+00 * S2 - 1.60E+01
     $ * ( HM2 / PROPH) + 1.60E+01 * (S / PROPH) - 1.60E+01 * (S2
     $ / PROPH) + 4.00E+00 * (S3 / PROPH) + 1.60E+01 * ((HM2 * S)
     $ / PROPH) - 4.00E+00 * ((HM2 * S2) / PROPH)
      ANWWWW(1,1,2) = 2.00E+00 * S
      ANWWWW(1,1,3) = -1.60E+01 + 6.00E+00 * S - 1.60E+01 * (HM2
     $ / PROPH) + 1.60E+01 * (S / PROPH) - 8.00E+00 * (S2 / PROPH)
     $ + 8.00E+00 * ((HM2 * S) / PROPH)
      ANWWWW(1,1,4) = -2.40E+01 * RTS + 6.40E+01 * (RTS / (S
     $ - 1.00E+00 * ZM2)) + 1.60E+01 * ((RTS * S) / (S - 1.00E+00
     $ * ZM2)) - 8.00E+00 * ((RTS * S2) / (S - 1.00E+00 * ZM2))
     $ + 6.40E+01 * ((RTS * SW2) / S) - 6.40E+01 * ((RTS * SW2) / (S
     $ - 1.00E+00 * ZM2)) - 1.60E+01 * ((RTS * S * SW2) / (S
     $ - 1.00E+00 * ZM2)) + 8.00E+00 * ((RTS * S2 * SW2) / (S
     $ - 1.00E+00 * ZM2)) + 6.00E+00 * RTS * S + 1.60E+01 * RTS
     $ * SW2 - 8.00E+00 * RTS * S * SW2
      ANWWWW(1,2,1) = -6.40E+01 + 1.60E+01 * S - 1.20E+01 * S2
     $ + 3.00E+00 * S3 + 6.40E+01 * SW2 - 1.60E+01 * S * SW2
     $ + 1.20E+01 * S2 * SW2 - 3.00E+00 * S3 * SW2
      ANWWWW(1,2,2) = 6.40E+01 + 8.00E+00 * S - 2.00E+00 * S2
     $ - 6.40E+01 * SW2 - 8.00E+00 * S * SW2 + 2.00E+00 * S2 * SW2
      ANWWWW(1,2,3) = -6.40E+01 + 2.40E+01 * S - 6.00E+00 * S2
     $ + 6.40E+01 * SW2 - 2.40E+01 * S * SW2 + 6.00E+00 * S2 * SW2
      ANWWWW(1,2,4) = -9.60E+01 * RTS + 1.60E+01 * RTS * S + 2.00E+00
     $ * RTS * S2 + 9.60E+01 * RTS * SW2 - 1.60E+01 * RTS * S * SW2
     $ - 2.00E+00 * RTS * S2 * SW2
      ANWWWW(1,3,1) = -6.40E+01 * SW2 + 1.60E+01 * S * SW2 - 1.20E+01
     $ * S2 * SW2 + 3.00E+00 * S3 * SW2
      ANWWWW(1,3,2) = 6.40E+01 * SW2 + 8.00E+00 * S * SW2 - 2.00E+00
     $ * S2 * SW2
      ANWWWW(1,3,3) = -6.40E+01 * SW2 + 2.40E+01 * S * SW2 - 6.00E+00
     $ * S2 * SW2
      ANWWWW(1,3,4) = -9.60E+01 * RTS * SW2 + 1.60E+01 * RTS * S * SW2
     $  + 2.00E+00 * RTS * S2 * SW2
      ANWWWW(1,4,1) = -3.20E+01 + 1.60E+01 * S - 2.00E+00 * S2
      ANWWWW(1,4,2) = -4.00E+00 * S
      ANWWWW(1,4,3) = 4.00E+00 * S
      ANWWWW(1,4,4) = -1.60E+01 * RTS + 4.00E+00 * RTS * S
      ANWWWW(2,1,1) = -2.40E+01 * S + 6.00E+00 * S2 + 4.80E+01 * SW2
     $ + 6.40E+01 * (1.00E+00 / (S - 1.00E+00 * ZM2)) + 4.80E+01 * (S
     $ / (S - 1.00E+00 * ZM2)) - 4.00E+00 * (S3 / (S - 1.00E+00
     $ * ZM2)) + 6.40E+01 * (SW2 / S) - 6.40E+01 * (SW2 / (S
     $ - 1.00E+00 * ZM2)) - 4.80E+01 * ((S * SW2) / (S - 1.00E+00
     $ * ZM2)) + 4.00E+00 * ((S3 * SW2) / (S - 1.00E+00 * ZM2))
     $ - 4.00E+00 * S2 * SW2
      ANWWWW(2,1,2) = 0.00E+00
      ANWWWW(2,1,3) = 1.60E+01 * SW2 + 6.40E+01 * (1.00E+00 / (S
     $ - 1.00E+00 * ZM2)) + 1.60E+01 * (S / (S - 1.00E+00 * ZM2))
     $ - 8.00E+00 * (S2 / (S - 1.00E+00 * ZM2)) + 6.40E+01 * (SW2
     $ / S) - 6.40E+01 * (SW2 / (S - 1.00E+00 * ZM2)) - 1.60E+01
     $ * ((S * SW2) / (S - 1.00E+00 * ZM2)) + 8.00E+00 * ((S2 * SW2)
     $ / (S - 1.00E+00 * ZM2)) - 8.00E+00 * S * SW2
      ANWWWW(2,1,4) = 2.00E+00 * RTS * S
      ANWWWW(2,2,1) = -6.40E+01 - 1.12E+02 * S + 5.20E+01 * S2
     $ - 5.00E+00 * S3 + 6.40E+01 * SW2 + 1.12E+02 * S * SW2
     $ - 5.20E+01 * S2 * SW2 + 5.00E+00 * S3 * SW2
      ANWWWW(2,2,2) = -8.00E+00 * S + 2.00E+00 * S2 + 8.00E+00 * S
     $ * SW2 - 2.00E+00 * S2 * SW2
      ANWWWW(2,2,3) = -5.60E+01 * S + 1.40E+01 * S2 + 5.60E+01 * S
     $ * SW2 - 1.40E+01 * S2 * SW2
      ANWWWW(2,2,4) = 1.60E+02 * RTS - 8.00E+00 * RTS * S - 4.00E+00
     $ * RTS * S2 - 1.60E+02 * RTS * SW2 + 8.00E+00 * RTS * S * SW2
     $ + 4.00E+00 * RTS * S2 * SW2
      ANWWWW(2,3,1) = -6.40E+01 * SW2 - 1.12E+02 * S * SW2 + 5.20E+01
     $ * S2 * SW2 - 5.00E+00 * S3 * SW2
      ANWWWW(2,3,2) = -8.00E+00 * S * SW2 + 2.00E+00 * S2 * SW2
      ANWWWW(2,3,3) = -5.60E+01 * S * SW2 + 1.40E+01 * S2 * SW2
      ANWWWW(2,3,4) = 1.60E+02 * RTS * SW2 - 8.00E+00 * RTS * S * SW2
     $ - 4.00E+00 * RTS * S2 * SW2
      ANWWWW(2,4,1) = -1.60E+01 * S + 4.00E+00 * S2
      ANWWWW(2,4,2) = 0.00E+00
      ANWWWW(2,4,3) = 0.00E+00
      ANWWWW(2,4,4) = -4.00E+00 * RTS * S
      ANWWWW(3,1,1) = S2
      ANWWWW(3,1,2) = -2.00E+00 * S
      ANWWWW(3,1,3) = 2.00E+00 * S
      ANWWWW(3,1,4) = 0.00E+00
      ANWWWW(3,2,1) = 1.60E+02 * S - 3.60E+01 * S2 + S3 - 1.60E+02
     $ * S * SW2 + 3.60E+01 * S2 * SW2 - 1.00E+00 * S3 * SW2
      ANWWWW(3,2,2) = -6.40E+01 - 8.00E+00 * S + 2.00E+00 * S2
     $ + 6.40E+01 * SW2 + 8.00E+00 * S * SW2 - 2.00E+00 * S2 * SW2
      ANWWWW(3,2,3) = 6.40E+01 + 4.00E+01 * S - 1.00E+01 * S2
     $ - 6.40E+01 * SW2 - 4.00E+01 * S * SW2 + 1.00E+01 * S2 * SW2
      ANWWWW(3,2,4) = -8.00E+00 * RTS * S + 2.00E+00 * RTS * S2
     $ + 8.00E+00 * RTS * S * SW2 - 2.00E+00 * RTS * S2 * SW2
      ANWWWW(3,3,1) = 1.60E+02 * S * SW2 - 3.60E+01 * S2 * SW2 + S3
     $ * SW2
      ANWWWW(3,3,2) = -6.40E+01 * SW2 - 8.00E+00 * S * SW2 + 2.00E+00
     $ * S2 * SW2
      ANWWWW(3,3,3) = 6.40E+01 * SW2 + 4.00E+01 * S * SW2 - 1.00E+01
     $ * S2 * SW2
      ANWWWW(3,3,4) = -8.00E+00 * RTS * S * SW2 + 2.00E+00 * RTS * S2
     $ * SW2
      ANWWWW(3,4,1) = -2.00E+00 * S2
      ANWWWW(3,4,2) = 4.00E+00 * S
      ANWWWW(3,4,3) = -4.00E+00 * S
      ANWWWW(3,4,4) = 0.00E+00
      ANWWWW(4,1,1) = 0.00E+00
      ANWWWW(4,1,2) = 0.00E+00
      ANWWWW(4,1,3) = 0.00E+00
      ANWWWW(4,1,4) = 0.00E+00
      ANWWWW(4,2,1) = -4.00E+00 * S2 + S3 + 4.00E+00 * S2 * SW2
     $ - 1.00E+00 * S3 * SW2
      ANWWWW(4,2,2) = 8.00E+00 * S - 2.00E+00 * S2 - 8.00E+00 * S
     $ * SW2 + 2.00E+00 * S2 * SW2
      ANWWWW(4,2,3) = -8.00E+00 * S + 2.00E+00 * S2 + 8.00E+00 * S
     $ * SW2 - 2.00E+00 * S2 * SW2
      ANWWWW(4,2,4) = 0.00E+00
      ANWWWW(4,3,1) = -4.00E+00 * S2 * SW2 + S3 * SW2
      ANWWWW(4,3,2) = 8.00E+00 * S * SW2 - 2.00E+00 * S2 * SW2
      ANWWWW(4,3,3) = -8.00E+00 * S * SW2 + 2.00E+00 * S2 * SW2
      ANWWWW(4,3,4) = 0.00E+00
      ANWWWW(4,4,1) = 0.00E+00
      ANWWWW(4,4,2) = 0.00E+00
      ANWWWW(4,4,3) = 0.00E+00
      ANWWWW(4,4,4) = 0.00E+00
C
      ADWWWW(1,1) = 1.00E+00
      ADWWWW(1,2) = -4.00E+00 + S + 2.00E+00 * ZM2
      ADWWWW(1,3) = -4.00E+00 + S
      ADWWWW(1,4) = -4.00E+00 + 2.00E+00 * HM2 + S
      ADWWWW(2,1) = 0.00E+00
      ADWWWW(2,2) = 4.00E+00 - 1.00E+00 * S
      ADWWWW(2,3) = 4.00E+00 - 1.00E+00 * S
      ADWWWW(2,4) = 4.00E+00 - 1.00E+00 * S
C
      AIWWWW(1) = 1.60E+01 * ((HG * HM) / PROPH) - 1.60E+01 * ((HG
     $ * HM * S) / PROPH) + 4.00E+00 * ((HG * HM * S2) / PROPH)
      AIWWWW(2) = 0.00E+00
      AIWWWW(3) = 1.60E+01 * ((HG * HM) / PROPH) - 8.00E+00 * ((HG
     $ * HM * S) / PROPH)
      AIWWWW(4) = 0.00E+00
C
C          RESTORE MISSING FACTORS
      DO 100 J=1,4
      AIWWWW(J)=AIWWWW(J)*GSQ/(16.)
      DO 100 I=1,4
      DO 110 K=1,4
110   ANWWWW(K,I,J)=ANWWWW(K,I,J)*GSQ/(16.)
100   CONTINUE
C
      RETURN
      END
CDECK  ID>, XWWZZ.  
      SUBROUTINE XWWZZ
C
C          SET UP W+ W- -> Z0 Z0 AMPLITUDES AS RATIONAL FUNCTIONS OF Z
C
C          RE(F(Z,L)) = SUM(I,J)(ANWWWW(I+1,J,L)*Z**I
C                                  /(ADWWWW(1,J)+ADWWWW(2,J)*Z))
C          IM(F(Z,L)) = AIWWWW(L)   (INDEPENDENT OF Z)
C          J LABELS PIECES WITH SAME DENOMINATOR.
C          L=1 FOR 0,0; L=2 FOR 1,-1; L=3 FOR 1,1; L=4 FOR 0,1
C
C          *NOTE* A FACTOR OF SIN(THETA)/SQRT(2) IS REMOVED FROM F01
C
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
      DOUBLE PRECISION WM,ZM,ZM2,ZM3,ZM4,ZM5,ZM6,HM,HM2,HM3,HM4,HG,HG2
     $,PROPH,RTS,S,S2,S3,SW,QQ0,QQI,QQF
C
C          USE UNITS OF WM TO AVOID LARGE NUMBERS - NOTE ANWWWW/ADWWWW
C          AND AIWWWW ARE DIMENSIONLESS
      WM=WMASS(2)
      ZM=WMASS(4)/WM
      ZM2=ZM**2
      ZM3=ZM**3
      ZM4=ZM**4
      ZM5=ZM**5
      ZM6=ZM**6
      HM=HMASS/WM
      HM2=HM**2
      HM3=HM**3
      HM4=HM**4
      HG=HGAM/WM
      HG2=HG**2
      RTS=QMW/WM
      S=RTS**2
      S2=S**2
      S3=S**3
      PROPH=(S-HM2)**2+(HM*HG)**2
C          CORRECT SIGN OF HIGGS AMPLITUDE.
      PROPH=-PROPH
C
      CW=1./ZM
      CW2=CW**2
      SW2=1.-CW2
      SW=SQRT(SW2)
      QQ0=.5*RTS
      QQI=.5*SQRT(S-4.)
      QQF=.5*SQRT(S-4.*ZM2)
      GSQ=4.*PI*ALFA/SW2
C
C          FROM WWZZ3.EX
      ANWWWW(1,1,1) = -1.60E+01 * ((HM2 * ZM3) / (CW * PROPH))
     $ + 1.60E+01 * ((S * ZM3) / (CW * PROPH) ) - 8.00E+00 * ((S2
     $ * ZM) / (CW * PROPH)) - 8.00E+00 * ((S2 * ZM3) / (CW * PROPH))
     $ + 4.00E+00 * ((S3 * ZM) / (CW * PROPH)) + 8.00E+00 * ((HM2 * S
     $ * ZM) / (CW * PROPH)) + 8.00E+00 * ((HM2 * S * ZM3) / (CW
     $ * PROPH)) - 4.00E+00 * ((HM2 * S2 * ZM) / (CW * PROPH))
     $ + 8.00E+00 * CW2 * S - 6.00E+00 * CW2 * S2 + 8.00E+00 * CW2
     $ * S * ZM2
      ANWWWW(1,1,2) = 4.00E+00 * CW2 * S * ZM2
      ANWWWW(1,1,3) = -1.60E+01 * ((HM2 * ZM3) / (CW * PROPH))
     $ + 1.60E+01 * ((S * ZM3) / (CW * PROPH) ) - 8.00E+00 * ((S2
     $ * ZM3) / (CW * PROPH)) + 8.00E+00 * ((HM2 * S * ZM3) / (CW
     $ * PROPH)) - 3.20E+01 * CW2 * ZM2 + 1.20E+01 * CW2 * S * ZM2
      ANWWWW(1,1,4) = 0.00E+00
      ANWWWW(1,2,1) = -4.00E+00 * CW2 * S2 + 3.00E+00 * CW2 * S3
     $ - 9.60E+01 * CW2 * ZM4 + 3.20E+01 * CW2 * ZM6 + 8.00E+00 * CW2
     $ * S * ZM2 + 1.60E+01 * CW2 * S * ZM4 - 8.00E+00 * CW2 * S
     $ * ZM6 - 1.00E+01 * CW2 * S2 * ZM2 + 2.00E+00 * CW2 * S2 * ZM4
      ANWWWW(1,2,2) = 6.40E+01 * CW2 * ZM2 + 1.20E+01 * CW2 * S * ZM2
     $ - 4.00E+00 * CW2 * S * ZM4 - 2.00E+00 * CW2 * S2 * ZM2
      ANWWWW(1,2,3) = -6.40E+01 * CW2 * ZM2 + 2.00E+01 * CW2 * S * ZM2
     $ + 4.00E+00 * CW2 * S * ZM4 - 6.00E+00 * CW2 * S2 * ZM2
      ANWWWW(1,2,4) = 1.92E+02 * CW2 * QQ0 * QQF * QQI * ZM
     $ - 3.20E+01 * CW2 * QQ0 * QQF * QQI * ZM3 + 3.20E+01 * CW2
     $ * QQ0 * QQF * QQI * ZM5 + 1.60E+01 * CW2 * QQ0 * QQF * QQI * S
     $ * ZM
      ANWWWW(1,3,1) = -4.00E+00 * CW2 * S2 + 3.00E+00 * CW2 * S3
     $ - 9.60E+01 * CW2 * ZM4 + 3.20E+01 * CW2 * ZM6 + 8.00E+00 * CW2
     $ * S * ZM2 + 1.60E+01 * CW2 * S * ZM4 - 8.00E+00 * CW2 * S
     $ * ZM6 - 1.00E+01 * CW2 * S2 * ZM2 + 2.00E+00 * CW2 * S2 * ZM4
      ANWWWW(1,3,2) = 6.40E+01 * CW2 * ZM2 + 1.20E+01 * CW2 * S * ZM2
     $ - 4.00E+00 * CW2 * S * ZM4 - 2.00E+00 * CW2 * S2 * ZM2
      ANWWWW(1,3,3) = -6.40E+01 * CW2 * ZM2 + 2.00E+01 * CW2 * S * ZM2
     $ + 4.00E+00 * CW2 * S * ZM4 - 6.00E+00 * CW2 * S2 * ZM2
      ANWWWW(1,3,4) = -1.92E+02 * CW2 * QQ0 * QQF * QQI * ZM
     $ + 3.20E+01 * CW2 * QQ0 * QQF * QQI * ZM3 - 3.20E+01 * CW2
     $ * QQ0 * QQF * QQI * ZM5 - 1.60E+01 * CW2 * QQ0 * QQF * QQI * S
     $ * ZM
      ANWWWW(1,4,1) = 0.00E+00
      ANWWWW(1,4,2) = 0.00E+00
      ANWWWW(1,4,3) = 0.00E+00
      ANWWWW(1,4,4) = 0.00E+00
      ANWWWW(2,1,1) = 0.00E+00
      ANWWWW(2,1,2) = 0.00E+00
      ANWWWW(2,1,3) = 0.00E+00
      ANWWWW(2,1,4) = 8.00E+00 * CW2 * QQ0 * S * ZM
      ANWWWW(2,2,1) = 4.80E+01 * CW2 * QQF * QQI * S - 2.00E+01 * CW2
     $ * QQF * QQI * S2 + 6.40E+01 * CW2 * QQF * QQI * ZM2 + 9.60E+01
     $ * CW2 * QQF * QQI * S * ZM2 - 1.60E+01 * CW2 * QQF * QQI * S
     $ * ZM4
      ANWWWW(2,2,2) = 8.00E+00 * CW2 * QQF * QQI * S * ZM2
      ANWWWW(2,2,3) = 5.60E+01 * CW2 * QQF * QQI * S * ZM2
      ANWWWW(2,2,4) = 1.28E+02 * CW2 * QQ0 * ZM + 1.92E+02 * CW2 * QQ0
     $ * ZM3 - 3.20E+01 * CW2 * QQ0 * S * ZM + 2.40E+01 * CW2 * QQ0
     $ * S * ZM3 - 8.00E+00 * CW2 * QQ0 * S * ZM5 - 8.00E+00 * CW2
     $ * QQ0 * S2 * ZM
      ANWWWW(2,3,1) = -4.80E+01 * CW2 * QQF * QQI * S + 2.00E+01 * CW2
     $ * QQF * QQI * S2 - 6.40E+01 * CW2 * QQF * QQI * ZM2
     $ - 9.60E+01 * CW2 * QQF * QQI * S * ZM2 + 1.60E+01 * CW2 * QQF
     $ * QQI * S * ZM4
      ANWWWW(2,3,2) = -8.00E+00 * CW2 * QQF * QQI * S * ZM2
      ANWWWW(2,3,3) = -5.60E+01 * CW2 * QQF * QQI * S * ZM2
      ANWWWW(2,3,4) = 1.28E+02 * CW2 * QQ0 * ZM + 1.92E+02 * CW2 * QQ0
     $ * ZM3 - 3.20E+01 * CW2 * QQ0 * S * ZM + 2.40E+01 * CW2 * QQ0
     $ * S * ZM3 - 8.00E+00 * CW2 * QQ0 * S * ZM5 - 8.00E+00 * CW2
     $ * QQ0 * S2 * ZM
      ANWWWW(2,4,1) = 0.00E+00
      ANWWWW(2,4,2) = 0.00E+00
      ANWWWW(2,4,3) = 0.00E+00
      ANWWWW(2,4,4) = 0.00E+00
      ANWWWW(3,1,1) = 2.00E+00 * CW2 * S2
      ANWWWW(3,1,2) = -4.00E+00 * CW2 * S * ZM2
      ANWWWW(3,1,3) = 4.00E+00 * CW2 * S * ZM2
      ANWWWW(3,1,4) = 0.00E+00
      ANWWWW(3,2,1) = 3.20E+01 * CW2 * S - 1.60E+01 * CW2 * S2 + CW2
     $ * S3 + 9.60E+01 * CW2 * S * ZM2 + 3.20E+01 * CW2 * S * ZM4
     $ - 2.20E+01 * CW2 * S2 * ZM2 + 2.00E+00 * CW2 * S2 * ZM4
      ANWWWW(3,2,2) = -6.40E+01 * CW2 * ZM2 - 1.20E+01 * CW2 * S
     $ * ZM2 + 4.00E+00 * CW2 * S * ZM4 + 2.00E+00 * CW2 * S2 * ZM2
      ANWWWW(3,2,3) = 6.40E+01 * CW2 * ZM2 + 1.20E+01 * CW2 * S * ZM2
     $ + 2.80E+01 * CW2 * S * ZM4 - 1.00E+01 * CW2 * S2 * ZM2
      ANWWWW(3,2,4) = 1.60E+01 * CW2 * QQ0 * QQF * QQI * S * ZM
      ANWWWW(3,3,1) = 3.20E+01 * CW2 * S - 1.60E+01 * CW2 * S2 + CW2
     $ * S3 + 9.60E+01 * CW2 * S * ZM2 + 3.20E+01 * CW2 * S * ZM4
     $ - 2.20E+01 * CW2 * S2 * ZM2 + 2.00E+00 * CW2 * S2 * ZM4
      ANWWWW(3,3,2) = -6.40E+01 * CW2 * ZM2 - 1.20E+01 * CW2 * S
     $ * ZM2 + 4.00E+00 * CW2 * S * ZM4 + 2.00E+00 * CW2 * S2 * ZM2
      ANWWWW(3,3,3) = 6.40E+01 * CW2 * ZM2 + 1.20E+01 * CW2 * S * ZM2
     $ + 2.80E+01 * CW2 * S * ZM4 - 1.00E+01 * CW2 * S2 * ZM2
      ANWWWW(3,3,4) = -1.60E+01 * CW2 * QQ0 * QQF * QQI * S * ZM
      ANWWWW(3,4,1) = 0.00E+00
      ANWWWW(3,4,2) = 0.00E+00
      ANWWWW(3,4,3) = 0.00E+00
      ANWWWW(3,4,4) = 0.00E+00
      ANWWWW(4,1,1) = 0.00E+00
      ANWWWW(4,1,2) = 0.00E+00
      ANWWWW(4,1,3) = 0.00E+00
      ANWWWW(4,1,4) = 0.00E+00
      ANWWWW(4,2,1) = 4.00E+00 * CW2 * QQF * QQI * S2
      ANWWWW(4,2,2) = -8.00E+00 * CW2 * QQF * QQI * S * ZM2
      ANWWWW(4,2,3) = 8.00E+00 * CW2 * QQF * QQI * S * ZM2
      ANWWWW(4,2,4) = 0.00E+00
      ANWWWW(4,3,1) = -4.00E+00 * CW2 * QQF * QQI * S2
      ANWWWW(4,3,2) = 8.00E+00 * CW2 * QQF * QQI * S * ZM2
      ANWWWW(4,3,3) = -8.00E+00 * CW2 * QQF * QQI * S * ZM2
      ANWWWW(4,3,4) = 0.00E+00
      ANWWWW(4,4,1) = 0.00E+00
      ANWWWW(4,4,2) = 0.00E+00
      ANWWWW(4,4,3) = 0.00E+00
      ANWWWW(4,4,4) = 0.00E+00
C
      ADWWWW(1,1) = 1.00E+00
      ADWWWW(1,2) = S - 2.00E+00 * ZM2
      ADWWWW(1,3) = S - 2.00E+00 * ZM2
      ADWWWW(1,4) = 1.00E+00
      ADWWWW(2,1) = 0.00E+00
      ADWWWW(2,2) = -1.00E+00 * S + 4.00E+00 * (S / (S + 4.00E+00
     $ * QQF * QQI)) - 1.60E+01 * (ZM2 / (S + 4.00E+00 * QQF * QQI))
     $ + 4.00E+00 * ((S * ZM2) / (S + 4.00E+00 * QQF * QQI))
      ADWWWW(2,3) = S - 4.00E+00 * (S / (S + 4.00E+00 * QQF * QQI))
     $ + 1.60E+01 * (ZM2 / (S + 4.00E+00 * QQF * QQI)) - 4.00E+00
     $ * ((S * ZM2) / (S + 4.00E+00 * QQF * QQI))
      ADWWWW(2,4) = 0.00E+00
C
      AIWWWW(1) = 1.60E+01 * ((HG * HM * ZM3) / (CW * PROPH))
     $ - 8.00E+00 * ((HG * HM * S * ZM) / (CW * PROPH)) - 8.00E+00
     $ * ((HG * HM * S * ZM3) / (CW * PROPH)) + 4.00E+00 * ((HG * HM
     $ * S2 * ZM) / (CW * PROPH))
      AIWWWW(2) = 0.00E+00
      AIWWWW(3) = 1.60E+01 * ((HG * HM * ZM3) / (CW * PROPH))
     $ - 8.00E+00 * ((HG * HM * S * ZM3) / (CW * PROPH))
      AIWWWW(4) = 0.00E+00
C
C          RESTORE MISSING FACTORS
      DO 100 J=1,4
      AIWWWW(J)=AIWWWW(J)*GSQ/(16.*ZM2)
      DO 100 I=1,4
      DO 110 K=1,4
110   ANWWWW(K,I,J)=ANWWWW(K,I,J)*GSQ/(16.*ZM2)
100   CONTINUE
C
      RETURN
      END
CDECK  ID>, XZZWW.  
      SUBROUTINE XZZWW
C
C          SET UP Z0 Z0 -> W+ W- AMPLITUDES AS RATIONAL FUNCTIONS OF Z
C
C          RE(F(Z,L)) = SUM(I,J)(ANWWWW(I+1,J,L)*Z**I
C                                  /(ADWWWW(1,J)+ADWWWW(2,J)*Z))
C          IM(F(Z,L)) = AIWWWW(L)   (INDEPENDENT OF Z)
C          J LABELS PIECES WITH SAME DENOMINATOR.
C          L=1 FOR 0,0; L=2 FOR 1,-1; L=3 FOR 1,1; L=4 FOR 0,1
C
C          *NOTE* A FACTOR OF SIN(THETA)/SQRT(2) IS REMOVED FROM F01
C
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
      DOUBLE PRECISION WM,ZM,ZM2,ZM3,ZM4,ZM5,ZM6,HM,HM2,HM3,HM4,HG,HG2
     $,PROPH,RTS,S,S2,S3,SW,QQ0,QQI,QQF
C
C          USE UNITS OF WM TO AVOID LARGE NUMBERS - NOTE ANWWWW/ADWWWW
C          AND AIWWWW ARE DIMENSIONLESS
      WM=WMASS(2)
      ZM=WMASS(4)/WM
      ZM2=ZM**2
      ZM3=ZM**3
      ZM4=ZM**4
      ZM5=ZM**5
      ZM6=ZM**6
      HM=HMASS/WM
      HM2=HM**2
      HM3=HM**3
      HM4=HM**4
      HG=HGAM/WM
      HG2=HG**2
      RTS=QMW/WM
      S=RTS**2
      S2=S**2
      S3=S**3
      PROPH=(S-HM2)**2+(HM*HG)**2
C          CORRECT SIGN OF HIGGS AMPLITUDE.
      PROPH=-PROPH
C
      CW=1./ZM
      CW2=CW**2
      SW2=1.-CW2
      SW=SQRT(SW2)
      QQ0=.5*RTS
      QQI=.5*SQRT(S-4.*ZM2)
      QQF=.5*SQRT(S-4.)
      GSQ=4.*PI*ALFA/SW2
C
C          FROM ZZWW3.EX
      ANWWWW(1,1,1) = -1.60E+01 * ((HM2 * ZM3) / (CW * PROPH))
     $ + 1.60E+01 * ((S * ZM3) / (CW * PROPH) ) - 8.00E+00 * ((S2
     $ * ZM) / (CW * PROPH)) - 8.00E+00 * ((S2 * ZM3) / (CW * PROPH))
     $ + 4.00E+00 * ((S3 * ZM) / (CW * PROPH)) + 8.00E+00 * ((HM2 * S
     $ * ZM) / (CW * PROPH)) + 8.00E+00 * ((HM2 * S * ZM3) / (CW
     $ * PROPH)) - 4.00E+00 * ((HM2 * S2 * ZM) / (CW * PROPH))
     $ + 8.00E+00 * CW2 * S - 6.00E+00 * CW2 * S2 + 8.00E+00 * CW2
     $ * S * ZM2
      ANWWWW(1,1,2) = 4.00E+00 * CW2 * S
      ANWWWW(1,1,3) = -1.60E+01 * ((HM2 * ZM3) / (CW * PROPH))
     $ + 1.60E+01 * ((S * ZM3) / (CW * PROPH) ) - 8.00E+00 * ((S2
     $ * ZM) / (CW * PROPH)) + 8.00E+00 * ((HM2 * S * ZM) / (CW
     $ * PROPH)) + 1.20E+01 * CW2 * S - 3.20E+01 * CW2 * ZM2
      ANWWWW(1,1,4) = 0.00E+00
      ANWWWW(1,2,1) = -4.00E+00 * CW2 * S2 + 3.00E+00 * CW2 * S3
     $ - 9.60E+01 * CW2 * ZM4 + 3.20E+01 * CW2 * ZM6 + 8.00E+00 * CW2
     $ * S * ZM2 + 1.60E+01 * CW2 * S * ZM4 - 8.00E+00 * CW2 * S
     $ * ZM6 - 1.00E+01 * CW2 * S2 * ZM2 + 2.00E+00 * CW2 * S2 * ZM4
      ANWWWW(1,2,2) = -4.00E+00 * CW2 * S - 2.00E+00 * CW2 * S2
     $ + 6.40E+01 * CW2 * ZM4 + 1.20E+01 * CW2 * S * ZM2
      ANWWWW(1,2,3) = 4.00E+00 * CW2 * S - 6.00E+00 * CW2 * S2
     $ - 6.40E+01 * CW2 * ZM4 + 2.00E+01 * CW2 * S * ZM2
      ANWWWW(1,2,4) = 6.40E+01 * CW2 * QQ0 * QQF * QQI + 1.60E+01
     $ * CW2 * QQ0 * QQF * QQI * S + 9.60E+01 * CW2 * QQ0 * QQF * QQI
     $ * ZM2 + 3.20E+01 * CW2 * QQ0 * QQF * QQI * ZM4
      ANWWWW(1,3,1) = -4.00E+00 * CW2 * S2 + 3.00E+00 * CW2 * S3
     $ - 9.60E+01 * CW2 * ZM4 + 3.20E+01 * CW2 * ZM6 + 8.00E+00 * CW2
     $ * S * ZM2 + 1.60E+01 * CW2 * S * ZM4 - 8.00E+00 * CW2 * S
     $ * ZM6 - 1.00E+01 * CW2 * S2 * ZM2 + 2.00E+00 * CW2 * S2 * ZM4
      ANWWWW(1,3,2) = -4.00E+00 * CW2 * S - 2.00E+00 * CW2 * S2
     $ + 6.40E+01 * CW2 * ZM4 + 1.20E+01 * CW2 * S * ZM2
      ANWWWW(1,3,3) = 4.00E+00 * CW2 * S - 6.00E+00 * CW2 * S2
     $ - 6.40E+01 * CW2 * ZM4 + 2.00E+01 * CW2 * S * ZM2
      ANWWWW(1,3,4) = -6.40E+01 * CW2 * QQ0 * QQF * QQI - 1.60E+01
     $ * CW2 * QQ0 * QQF * QQI * S - 9.60E+01 * CW2 * QQ0 * QQF * QQI
     $ * ZM2 - 3.20E+01 * CW2 * QQ0 * QQF * QQI * ZM4
      ANWWWW(1,4,1) = 0.00E+00
      ANWWWW(1,4,2) = 0.00E+00
      ANWWWW(1,4,3) = 0.00E+00
      ANWWWW(1,4,4) = 0.00E+00
      ANWWWW(2,1,1) = 0.00E+00
      ANWWWW(2,1,2) = 0.00E+00
      ANWWWW(2,1,3) = 0.00E+00
      ANWWWW(2,1,4) = 8.00E+00 * CW2 * QQ0 * S
      ANWWWW(2,2,1) = 4.80E+01 * CW2 * QQF * QQI * S - 2.00E+01 * CW2
     $ * QQF * QQI * S2 + 6.40E+01 * CW2 * QQF * QQI * ZM2 + 9.60E+01
     $ * CW2 * QQF * QQI * S * ZM2 - 1.60E+01 * CW2 * QQF * QQI * S
     $ * ZM4
      ANWWWW(2,2,2) = 8.00E+00 * CW2 * QQF * QQI * S
      ANWWWW(2,2,3) = 5.60E+01 * CW2 * QQF * QQI * S
      ANWWWW(2,2,4) = -8.00E+00 * CW2 * QQ0 * S2 + 1.92E+02 * CW2
     $ * QQ0 * ZM2 + 1.28E+02 * CW2 * QQ0 * ZM4 - 8.00E+00 * CW2
     $ * QQ0 * S * ZM2 - 8.00E+00 * CW2 * QQ0 * S * ZM4
      ANWWWW(2,3,1) = -4.80E+01 * CW2 * QQF * QQI * S + 2.00E+01 * CW2
     $ * QQF * QQI * S2 - 6.40E+01 * CW2 * QQF * QQI * ZM2
     $ - 9.60E+01 * CW2 * QQF * QQI * S * ZM2 + 1.60E+01 * CW2 * QQF
     $ * QQI * S * ZM4
      ANWWWW(2,3,2) = -8.00E+00 * CW2 * QQF * QQI * S
      ANWWWW(2,3,3) = -5.60E+01 * CW2 * QQF * QQI * S
      ANWWWW(2,3,4) = -8.00E+00 * CW2 * QQ0 * S2 + 1.92E+02 * CW2
     $ * QQ0 * ZM2 + 1.28E+02 * CW2 * QQ0 * ZM4 - 8.00E+00 * CW2
     $ * QQ0 * S * ZM2 - 8.00E+00 * CW2 * QQ0 * S * ZM4
      ANWWWW(2,4,1) = 0.00E+00
      ANWWWW(2,4,2) = 0.00E+00
      ANWWWW(2,4,3) = 0.00E+00
      ANWWWW(2,4,4) = 0.00E+00
      ANWWWW(3,1,1) = 2.00E+00 * CW2 * S2
      ANWWWW(3,1,2) = -4.00E+00 * CW2 * S
      ANWWWW(3,1,3) = 4.00E+00 * CW2 * S
      ANWWWW(3,1,4) = 0.00E+00
      ANWWWW(3,2,1) = 3.20E+01 * CW2 * S - 1.60E+01 * CW2 * S2 + CW2
     $ * S3 + 9.60E+01 * CW2 * S * ZM2 + 3.20E+01 * CW2 * S * ZM4
     $ - 2.20E+01 * CW2 * S2 * ZM2 + 2.00E+00 * CW2 * S2 * ZM4
      ANWWWW(3,2,2) = 4.00E+00 * CW2 * S + 2.00E+00 * CW2 * S2
     $ - 6.40E+01 * CW2 * ZM4 - 1.20E+01 * CW2 * S * ZM2
      ANWWWW(3,2,3) = 2.80E+01 * CW2 * S - 1.00E+01 * CW2 * S2
     $ + 6.40E+01 * CW2 * ZM4 + 1.20E+01 * CW2 * S * ZM2
      ANWWWW(3,2,4) = 1.60E+01 * CW2 * QQ0 * QQF * QQI * S
      ANWWWW(3,3,1) = 3.20E+01 * CW2 * S - 1.60E+01 * CW2 * S2 + CW2
     $ * S3 + 9.60E+01 * CW2 * S * ZM2 + 3.20E+01 * CW2 * S * ZM4
     $ - 2.20E+01 * CW2 * S2 * ZM2 + 2.00E+00 * CW2 * S2 * ZM4
      ANWWWW(3,3,2) = 4.00E+00 * CW2 * S + 2.00E+00 * CW2 * S2
     $ - 6.40E+01 * CW2 * ZM4 - 1.20E+01 * CW2 * S * ZM2
      ANWWWW(3,3,3) = 2.80E+01 * CW2 * S - 1.00E+01 * CW2 * S2
     $ + 6.40E+01 * CW2 * ZM4 + 1.20E+01 * CW2 * S * ZM2
      ANWWWW(3,3,4) = -1.60E+01 * CW2 * QQ0 * QQF * QQI * S
      ANWWWW(3,4,1) = 0.00E+00
      ANWWWW(3,4,2) = 0.00E+00
      ANWWWW(3,4,3) = 0.00E+00
      ANWWWW(3,4,4) = 0.00E+00
      ANWWWW(4,1,1) = 0.00E+00
      ANWWWW(4,1,2) = 0.00E+00
      ANWWWW(4,1,3) = 0.00E+00
      ANWWWW(4,1,4) = 0.00E+00
      ANWWWW(4,2,1) = 4.00E+00 * CW2 * QQF * QQI * S2
      ANWWWW(4,2,2) = -8.00E+00 * CW2 * QQF * QQI * S
      ANWWWW(4,2,3) = 8.00E+00 * CW2 * QQF * QQI * S
      ANWWWW(4,2,4) = 0.00E+00
      ANWWWW(4,3,1) = -4.00E+00 * CW2 * QQF * QQI * S2
      ANWWWW(4,3,2) = 8.00E+00 * CW2 * QQF * QQI * S
      ANWWWW(4,3,3) = -8.00E+00 * CW2 * QQF * QQI * S
      ANWWWW(4,3,4) = 0.00E+00
      ANWWWW(4,4,1) = 0.00E+00
      ANWWWW(4,4,2) = 0.00E+00
      ANWWWW(4,4,3) = 0.00E+00
      ANWWWW(4,4,4) = 0.00E+00
C
      ADWWWW(1,1) = 1.00E+00
      ADWWWW(1,2) = S - 2.00E+00 * ZM2
      ADWWWW(1,3) = S - 2.00E+00 * ZM2
      ADWWWW(1,4) = 1.00E+00
      ADWWWW(2,1) = 0.00E+00
      ADWWWW(2,2) = -1.00E+00 * S + 4.00E+00 * (S / (S + 4.00E+00
     $ * QQF * QQI)) - 1.60E+01 * (ZM2 / (S + 4.00E+00 * QQF * QQI))
     $ + 4.00E+00 * ((S * ZM2) / (S + 4.00E+00 * QQF * QQI))
      ADWWWW(2,3) = S - 4.00E+00 * (S / (S + 4.00E+00 * QQF * QQI))
     $ + 1.60E+01 * (ZM2 / (S + 4.00E+00 * QQF * QQI)) - 4.00E+00
     $ * ((S * ZM2) / (S + 4.00E+00 * QQF * QQI))
      ADWWWW(2,4) = 0.00E+00
C
      AIWWWW(1) = 1.60E+01 * ((HG * HM * ZM3) / (CW * PROPH))
     $ - 8.00E+00 * ((HG * HM * S * ZM) / (CW * PROPH))
     $ - 8.00E+00 * ((HG * HM * S * ZM3) / (CW * PROPH)) + 4.00E+00
     $ * ((HG * HM * S2 * ZM) / (CW * PROPH))
      AIWWWW(2) = 0.00E+00
      AIWWWW(3) = 1.60E+01 * ((HG * HM * ZM3) / (CW * PROPH))
     $ - 8.00E+00 * ((HG * HM * S * ZM) / (CW * PROPH))
      AIWWWW(4) = 0.00E+00
C
C          RESTORE MISSING FACTORS
      DO 100 J=1,4
      AIWWWW(J)=AIWWWW(J)*GSQ/(16.*ZM2)
      DO 100 I=1,4
      DO 110 K=1,4
110   ANWWWW(K,I,J)=ANWWWW(K,I,J)*GSQ/(16.*ZM2)
100   CONTINUE
C
      RETURN
      END
CDECK  ID>, XZZZZ.  
      SUBROUTINE XZZZZ
C
C          SET UP Z0 Z0 -> Z0 Z0 AMPLITUDES AS RATIONAL FUNCTIONS OF Z
C
C          RE(F(Z,L)) = SUM(I,J)(ANWWWW(I+1,J,L)*Z**I
C                                  /(ADWWWW(1,J)+ADWWWW(2,J)*Z))
C          IM(F(Z,L)) = AIWWWW(L)   (INDEPENDENT OF Z)
C          J LABELS PIECES WITH SAME DENOMINATOR.
C          L=1 FOR 0,0; L=2 FOR 1,-1; L=3 FOR 1,1; L=4 FOR 0,1
C
C          *NOTE* A FACTOR OF SIN(THETA)/SQRT(2) IS REMOVED FROM F01
C
      COMMON/CONST/PI,SQRT2,ALFA,GF,UNITS
      SAVE /CONST/
      REAL      PI,SQRT2,ALFA,GF,UNITS
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
      DOUBLE PRECISION WM,ZM,ZM2,ZM3,ZM4,ZM5,ZM6,HM,HM2,HM3,HM4,HG,HG2
     $,PROPH,RTS,S,S2,S3,SW,QQ0,QQI,QQF
C
C          USE UNITS OF WM TO AVOID LARGE NUMBERS - NOTE ANWWWW/ADWWWW
C          AND AIWWWW ARE DIMENSIONLESS
      WM=WMASS(2)
      ZM=WMASS(4)/WM
      ZM2=ZM**2
      ZM3=ZM**3
      ZM4=ZM**4
      ZM5=ZM**5
      ZM6=ZM**6
      HM=HMASS/WM
      HM2=HM**2
      HM3=HM**3
      HM4=HM**4
      HG=HGAM/WM
      HG2=HG**2
      RTS=QMW/WM
      S=RTS**2
      S2=S**2
      S3=S**3
      PROPH=(S-HM2)**2+(HM*HG)**2
C
      CW=1./ZM
      CW2=CW**2
      SW2=1.-CW2
      SW=SQRT(SW2)
      QQ0=.5*RTS
      QQI=.5*SQRT(S-4.*ZM2)
      QQF=.5*SQRT(S-4.*ZM2)
      GSQ=4.*PI*ALFA/SW2
C
C          FROM ZZZZ3.EX
      ANWWWW(1,1,1) = -1.60E+01 * ((HM2 * ZM6) / (CW2 * PROPH))
     $ + 1.60E+01 * ((S * ZM6) / (CW2 * PROPH )) - 1.60E+01 * ((S2
     $ * ZM4) / (CW2 * PROPH)) + 4.00E+00 * ((S3 * ZM2) / (CW2
     $ * PROPH)) + 1.60E+01 * ((HM2 * S * ZM4) / (CW2 * PROPH))
     $ - 4.00E+00 * ((HM2 * S2 * ZM2) / (CW2 * PROPH))
      ANWWWW(1,1,2) = 0.00E+00
      ANWWWW(1,1,3) = -1.60E+01 * ((HM2 * ZM6) / (CW2 * PROPH))
     $ + 1.60E+01 * ((S * ZM6) / (CW2 * PROPH )) - 8.00E+00 * ((S2
     $ * ZM4) / (CW2 * PROPH)) + 8.00E+00 * ((HM2 * S * ZM4) / (CW2
     $ * PROPH))
      ANWWWW(1,1,4) = 0.00E+00
      ANWWWW(1,2,1) = -3.20E+01 * (ZM6 / CW2) + 1.60E+01 * ((S * ZM4)
     $ / CW2) - 2.00E+00 * ((S2 * ZM2) / CW2)
      ANWWWW(1,2,2) = -4.00E+00 * ((S * ZM4) / CW2)
      ANWWWW(1,2,3) = 4.00E+00 * ((S * ZM4) / CW2)
      ANWWWW(1,2,4) = -3.20E+01 * ((QQ0 * ZM5) / CW2) + 8.00E+00
     $ * ((QQ0 * S * ZM3) / CW2)
      ANWWWW(1,3,1) = -3.20E+01 * (ZM6 / CW2) + 1.60E+01 * ((S * ZM4)
     $ / CW2) - 2.00E+00 * ((S2 * ZM2) / CW2)
      ANWWWW(1,3,2) = -4.00E+00 * ((S * ZM4) / CW2)
      ANWWWW(1,3,3) = 4.00E+00 * ((S * ZM4) / CW2)
      ANWWWW(1,3,4) = 3.20E+01 * ((QQ0 * ZM5) / CW2) - 8.00E+00
     $ * ((QQ0 * S * ZM3) / CW2)
      ANWWWW(1,4,1) = 0.00E+00
      ANWWWW(1,4,2) = 0.00E+00
      ANWWWW(1,4,3) = 0.00E+00
      ANWWWW(1,4,4) = 0.00E+00
      ANWWWW(2,1,1) = 0.00E+00
      ANWWWW(2,1,2) = 0.00E+00
      ANWWWW(2,1,3) = 0.00E+00
      ANWWWW(2,1,4) = 0.00E+00
      ANWWWW(2,2,1) = -1.60E+01 * ((S * ZM4) / CW2) + 4.00E+00 * ((S2
     $ * ZM2) / CW2)
      ANWWWW(2,2,2) = 0.00E+00
      ANWWWW(2,2,3) = 0.00E+00
      ANWWWW(2,2,4) = -8.00E+00 * ((QQ0 * S * ZM3) / CW2 )
      ANWWWW(2,3,1) = 1.60E+01 * ((S * ZM4) / CW2) - 4.00E+00 * ((S2
     $ * ZM2) / CW2)
      ANWWWW(2,3,2) = 0.00E+00
      ANWWWW(2,3,3) = 0.00E+00
      ANWWWW(2,3,4) = -8.00E+00 * ((QQ0 * S * ZM3) / CW2 )
      ANWWWW(2,4,1) = 0.00E+00
      ANWWWW(2,4,2) = 0.00E+00
      ANWWWW(2,4,3) = 0.00E+00
      ANWWWW(2,4,4) = 0.00E+00
      ANWWWW(3,1,1) = 0.00E+00
      ANWWWW(3,1,2) = 0.00E+00
      ANWWWW(3,1,3) = 0.00E+00
      ANWWWW(3,1,4) = 0.00E+00
      ANWWWW(3,2,1) = -2.00E+00 * ((S2 * ZM2) / CW2)
      ANWWWW(3,2,2) = 4.00E+00 * ((S * ZM4) / CW2)
      ANWWWW(3,2,3) = -4.00E+00 * ((S * ZM4) / CW2)
      ANWWWW(3,2,4) = 0.00E+00
      ANWWWW(3,3,1) = -2.00E+00 * ((S2 * ZM2) / CW2)
      ANWWWW(3,3,2) = 4.00E+00 * ((S * ZM4) / CW2)
      ANWWWW(3,3,3) = -4.00E+00 * ((S * ZM4) / CW2)
      ANWWWW(3,3,4) = 0.00E+00
      ANWWWW(3,4,1) = 0.00E+00
      ANWWWW(3,4,2) = 0.00E+00
      ANWWWW(3,4,3) = 0.00E+00
      ANWWWW(3,4,4) = 0.00E+00
      ANWWWW(4,1,1) = 0.00E+00
      ANWWWW(4,1,2) = 0.00E+00
      ANWWWW(4,1,3) = 0.00E+00
      ANWWWW(4,1,4) = 0.00E+00
      ANWWWW(4,2,1) = 0.00E+00
      ANWWWW(4,2,2) = 0.00E+00
      ANWWWW(4,2,3) = 0.00E+00
      ANWWWW(4,2,4) = 0.00E+00
      ANWWWW(4,3,1) = 0.00E+00
      ANWWWW(4,3,2) = 0.00E+00
      ANWWWW(4,3,3) = 0.00E+00
      ANWWWW(4,3,4) = 0.00E+00
      ANWWWW(4,4,1) = 0.00E+00
      ANWWWW(4,4,2) = 0.00E+00
      ANWWWW(4,4,3) = 0.00E+00
      ANWWWW(4,4,4) = 0.00E+00
C
      ADWWWW(1,1) = 1.00E+00
      ADWWWW(1,2) = 2.00E+00 * HM2 + S - 4.00E+00 * ZM2
      ADWWWW(1,3) = 2.00E+00 * HM2 + S - 4.00E+00 * ZM2
      ADWWWW(1,4) = 1.00E+00
      ADWWWW(2,1) = 0.00E+00
      ADWWWW(2,2) = -1.00E+00 * S + 4.00E+00 * ZM2
      ADWWWW(2,3) = S - 4.00E+00 * ZM2
      ADWWWW(2,4) = 0.00E+00
C
      AIWWWW(1) = 1.60E+01 * ((HG * HM * ZM6) / (CW2 * PROPH))
     $ - 1.60E+01 * ((HG * HM * S * ZM4) / (CW2 * PROPH))
     $ + 4.00E+00 * ((HG * HM * S2 * ZM2) / (CW2 * PROPH))
      AIWWWW(2) = 0.00E+00
      AIWWWW(3) = 1.60E+01 * ((HG * HM * ZM6) / (CW2 * PROPH))
     $ - 8.00E+00 * ((HG * HM * S * ZM4) / (CW2 * PROPH))
      AIWWWW(4) = 0.00E+00
C
C          RESTORE MISSING FACTORS
      DO 100 J=1,4
      AIWWWW(J)=AIWWWW(J)*GSQ/(16.*ZM4)
      DO 100 I=1,4
      DO 110 K=1,4
110   ANWWWW(K,I,J)=ANWWWW(K,I,J)*GSQ/(16.*ZM4)
100   CONTINUE
C
      RETURN
      END
CDECK  ID>, YGENJ.  
      LOGICAL FUNCTION YGENJ(I)
C
C            GENERATE Y FOR TWOJET
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/PTPAR/PTFUN1,PTFUN2,PTGEN1,PTGEN2,PTGEN3,SIGMAX
      SAVE /PTPAR/
      REAL      PTFUN1,PTFUN2,PTGEN1,PTGEN2,PTGEN3,SIGMAX
      COMMON/TOTALS/NKINPT,NWGEN,NKEEP,SUMWT,WT
      SAVE /TOTALS/
      INTEGER   NKINPT,NWGEN,NKEEP
      REAL      SUMWT,WT
      ACOSH(X)=ALOG(X+SQRT(X**2-1.0))
      YGENJ=.TRUE.
      YMAX=ACOSH(HALFE/PT(I))
      YMIN=-YMAX
      IF(YMAX.LT.YJMIN(I).OR.YMIN.GT.YJMAX(I)) GOTO 10
      YJ(I)=YJMIN(I)+(YJMAX(I)-YJMIN(I))*RANF()
      IF(YJ(I).LT.YMIN.OR.YJ(I).GT.YMAX) GOTO 10
      TH(I)=2.*ATAN(EXP(-YJ(I)))
      CTH(I)=COS(TH(I))
      STH(I)=SIN(TH(I))
      WT=WT*(YJMAX(I)-YJMIN(I))
      RETURN
   10 YGENJ=.FALSE.
      RETURN
      END
CDECK  ID>, ZZALL.  
      FUNCTION ZZALL(T,U,T1,U1,T3,U3,P1,P2)
C          DECAY DISTRIBUTION FOR Z0 Z0 PAIRS FROM SCHOONSCHIP(1980).
C          INCLUDES TT, TU, AND UU TERMS.
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/WWPAR/SWW,TWW,UWW,WM2,ZM2,P1WW(5),P2WW(5),P3WW(5),P4WW(5)
     $,PZERO(4,4),S13,P3(5),Q1(5),Q3(5),JQWW(2)
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      SAVE /WWPAR/
      DOUBLE PRECISION SWW,TWW,UWW,WM2,ZM2,P1WW,P2WW,P3WW,P4WW
     $,PZERO,S13,P3,Q1,Q3
     $,CQ,CV,CA,CV1,CA1,CV3,CA3,CS,CT,CU
      INTEGER   JQWW
      DIMENSION P1(4),P2(4)
      DOUBLE PRECISION ZZALL
      DOUBLE PRECISION T,U,T1,U1,T3,U3,P1,P2
      DOUBLE PRECISION CVAVA,DVAVA,CVVVV,CVVAA,TT,TU,UU,EPF
      TTUU=(T*U)**2
      CVAVA=CV*CA*(CV1*CA3+CA1*CV3)/TTUU
      DVAVA=CV*CA*(CV1*CA3-CA1*CV3)/TTUU
      CVVVV=(CV**2+CA**2)*CV1*CV3/TTUU
      CVVAA=(CV**2+CA**2)*CA1*CA3/TTUU
      TT=T**2
      TU=T*U
      UU=U**2
      ZZALL=
     1 +CVAVA*T*U*(-16.*ZM2*T1*U1*T3+16.*ZM2*T1*U1*U3+16.*ZM2*T1*T3*U3-
     1 16.*ZM2*U1*T3*U3-16.*ZM2**2*T1*S13-8.*ZM2**2*T1**2+16.*ZM2**2*U1
     1 *S13+8.*ZM2**2*U1**2+16.*ZM2**2*T3*S13+8.*ZM2**2*T3**2-16.*ZM2**
     1 2*U3*S13-8.*ZM2**2*U3**2)
     1 +CVAVA*T*U**2*(16.*ZM2*T1*S13-16.*ZM2*T3*S13)
     1 +CVAVA*T**2*(16.*ZM2*U1*U3**2-16.*ZM2*U1**2*U3-8.*ZM2**2*U1**2+8
     1 .*ZM2**2*U3**2)
     1 +CVAVA*T**2*U*(-16.*ZM2*U1*S13+16.*ZM2*U3*S13)
     1 +CVAVA*U**2*(-16.*ZM2*T1*T3**2+16.*ZM2*T1**2*T3+8.*ZM2**2*T1**2-
     1 8.*ZM2**2*T3**2)
      ZZALL=ZZALL
     1 +DVAVA*T*U*(-16.*ZM2*T1*U1*T3+16.*ZM2*T1*U1*U3-16.*ZM2*T1*T3*U3+
     1 16.*ZM2*U1*T3*U3-32.*ZM2**2*T1*T3-16.*ZM2**2*T1*S13-8.*ZM2**2*T1
     1 **2+32.*ZM2**2*U1*U3+16.*ZM2**2*U1*S13+8.*ZM2**2*U1**2-16.*ZM2**
     1 2*T3*S13-8.*ZM2**2*T3**2+16.*ZM2**2*U3*S13+8.*ZM2**2*U3**2-32.*Z
     1 M2**3*T1+32.*ZM2**3*U1-32.*ZM2**3*T3+32.*ZM2**3*U3)
     1 +DVAVA*T*U**2*(16.*ZM2*T1*S13+16.*ZM2*T3*S13-16.*ZM2**2*U1-16.*Z
     1 M2**2*U3-32.*ZM2**3)
     1 +DVAVA*T*U**3*(8.*ZM2**2)
      ZZALL=ZZALL
     1 +DVAVA*T**2*(-16.*ZM2*U1*U3**2-16.*ZM2*U1**2*U3-32.*ZM2**2*U1*U3
     1 -8.*ZM2**2*U1**2-8.*ZM2**2*U3**2-16.*ZM2**3*U1-16.*ZM2**3*U3-8.*
     1 ZM2**4)
     1 +DVAVA*T**2*U*(-16.*ZM2*U1*S13-16.*ZM2*U3*S13+16.*ZM2**2*T1+16.*
     1 ZM2**2*T3+32.*ZM2**3)
     1 +DVAVA*T**3*U*(-8.*ZM2**2)
     1 +DVAVA*U**2*(16.*ZM2*T1*T3**2+16.*ZM2*T1**2*T3+32.*ZM2**2*T1*T3+
     1 8.*ZM2**2*T1**2+8.*ZM2**2*T3**2+16.*ZM2**3*T1+16.*ZM2**3*T3+8.*Z
     1 M2**4)
      ZZALL=ZZALL
     1 +CVVVV*T*U*(-16.*ZM2*T1*U1*T3-16.*ZM2*T1*U1*U3-16.*ZM2*T1*T3*U3-
     1 16.*ZM2*U1*T3*U3+16.*ZM2**2*T1*S13+8.*ZM2**2*T1**2+16.*ZM2**2*U1
     1 *S13+8.*ZM2**2*U1**2+16.*ZM2**2*T3*S13+8.*ZM2**2*T3**2+16.*ZM2**
     1 2*U3*S13+8.*ZM2**2*U3**2+16.*ZM2**2*S13**2+16.*ZM2**3*T1+16.*ZM2
     1 **3*U1+16.*ZM2**3*T3+16.*ZM2**3*U3+32.*ZM2**3*S13+32.*ZM2**4-32.
     1 *T1*U1*T3*U3)
     1 +CVVVV*T*U**2*(-16.*ZM2*T1*S13-16.*ZM2*T3*S13-8.*ZM2**2*U1-8.*ZM
     1 2**2*U3-16.*ZM2**2*S13-16.*ZM2**3-32.*T1*T3*S13)
      ZZALL=ZZALL
     1 +CVVVV*T*U**3*(4.*ZM2**2)
     1 +CVVVV*T**2*(-16.*ZM2*U1*U3**2-16.*ZM2*U1**2*U3-16.*ZM2**2*U1*U3
     1 -8.*ZM2**2*U1**2-8.*ZM2**2*U3**2-8.*ZM2**3*U1-8.*ZM2**3*U3-4.*ZM
     1 2**4-16.*U1**2*U3**2)
     1 +CVVVV*T**2*U*(-16.*ZM2*U1*S13-16.*ZM2*U3*S13-8.*ZM2**2*T1-8.*ZM
     1 2**2*T3-16.*ZM2**2*S13-16.*ZM2**3-32.*U1*U3*S13)
     1 +CVVVV*T**2*U**2*(-16.*S13**2)
     1 +CVVVV*T**3*U*(4.*ZM2**2)
      ZZALL=ZZALL
     1 +CVVVV*U**2*(-16.*ZM2*T1*T3**2-16.*ZM2*T1**2*T3-16.*ZM2**2*T1*T3
     1 -8.*ZM2**2*T1**2-8.*ZM2**2*T3**2-8.*ZM2**3*T1-8.*ZM2**3*T3-4.*ZM
     1 2**4-16.*T1**2*T3**2)
     1 +CVVAA*T*U*(-16.*ZM2**3*T1-16.*ZM2**3*U1-16.*ZM2**3*T3-16.*ZM2**
     1 3*U3-32.*ZM2**3*S13-32.*ZM2**4)
     1 +CVVAA*T*U**2*(8.*ZM2**2*U1+8.*ZM2**2*U3+16.*ZM2**2*S13+16.*ZM2*
     1 *3)
     1 +CVVAA*T*U**3*(-4.*ZM2**2)
      ZZALL=ZZALL
     1 +CVVAA*T**2*(16.*ZM2**2*U1*U3+8.*ZM2**3*U1+8.*ZM2**3*U3+4.*ZM2**
     1 4)
     1 +CVVAA*T**2*U*(8.*ZM2**2*T1+8.*ZM2**2*T3+16.*ZM2**2*S13+16.*ZM2*
     1 *3)
     1 +CVVAA*T**3*U*(-4.*ZM2**2)
     1 +CVVAA*U**2*(16.*ZM2**2*T1*T3+8.*ZM2**3*T1+8.*ZM2**3*T3+4.*ZM2**
     1 4)
C          THE EPF TERMS FROM SCHOONSCHIP DID NOT CONTAIN CVAVA, ETC.,
C          BUT DID CONTAIN AN EXPLICIT T*U. THIS WAS REPLACED BY HAND
C          BY 1./TU.
      ZZALL=ZZALL
     1 +EPF(P1,P2,P3,Q3)/TU*(-32.*CV*CA*CV1*CV3*T1*S13)
     1 +EPF(P1,P2,Q1,Q3)/TU*(-32.*ZM2*CV*CA*CV1*CV3*T1-32.*CV*CA*CV1*C
     1 V3*T1*T3-32.*CV*CA*CV1*CV3*T1*U3)
     1 +EPF(P1,P3,Q1,Q3)/TU*(32.*CV*CA*CV1*CV3*T1*T3)
     1 +EPF(P2,P3,Q1,Q3)/TU*(-32.*CV*CA*CV1*CV3*T1*U3)+0.
      ZZALL=2.*ZZALL
      RETURN
      END
CDECK  ID>, ZZSTAR. 
      FUNCTION ZZSTAR(HM,IW)
C
C          Generate W* or Z* mass for H -> W W* or H -> Z Z* decay,
C          including the W or Z width in the propagator.
C          Ref: Marciano and Sirlin, Phys. Rev. D30, 248 (1984).
C
C          HM = generated Higgs mass, i.e. QMW**2
C          IW = 2   3   4
C               W+  W-  Z0
C
      IMPLICIT NONE
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/HCON/ANWWWW(4,4,4),ADWWWW(2,4),AIWWWW(4)
     $,HMASS,HGAM,HGAMS(29),ETAHGG,MATCHH(29),ZSTARS(4,2)
     $,IHTYPE,HGAMSS(85,85)
      SAVE /HCON/
      DOUBLE PRECISION ANWWWW,ADWWWW,AIWWWW
      INTEGER   MATCHH,IHTYPE
      REAL      HMASS,HGAM,HGAMS,ETAHGG,ZSTARS,HGAMSS
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
C
      REAL    HM,WM,WG,ZZSTAR,EPS,FBAR,R1,R2,RANF,X,F,DELTA,R,XM1
      INTEGER I,IW
C          WM and WG are the W or Z mass and width
      WM=WMASS(IW)
      WG=WGAM(IW)
      EPS=WM/HM
      DELTA=WM*WG/HM**2
C          FBAR is maximum of F below
      FBAR=12.*EPS**2*(1.-EPS)**2*(1.-EPS**2)
      R1=(2.*EPS-1.)/DELTA
      R2=EPS**2/DELTA
      R1=ATAN(R1)
      R2=ATAN(R2)
C          Generate Breit-Wigner and test remainder F against FBAR
      DO 100 I=1,NTRIES
        R=R1-RANF()*(R1-R2)
        XM1=DELTA*TAN(R)
        X=XM1+1.
        F=SQRT((X-2.*EPS)*(X+2.*EPS))
     $  *(X**2-12.*EPS**2*X+8.*EPS**2+12.*EPS**4)
        XM1=SQRT(XM1)
        ZZSTAR=HM*SQRT((EPS-XM1)*(EPS+XM1))
        IF(F.GT.FBAR*RANF()) RETURN
100   CONTINUE
C
      WRITE(ITLIS,9999) NTRIES
9999  FORMAT(' ERROR IN ZZSTAR ... NO MASS FOUND')
      STOP 99
      END
CDECK  ID>, DDILOG. 
      DOUBLE PRECISION FUNCTION DDILOG(X)
C
C          FROM CERN PROGRAM LIBRARY
C
      IMPLICIT NONE
      DOUBLE PRECISION X,Y,T,S,A,PI3,PI6,ZERO,ONE,HALF,MALF,MONE,MTWO
      DOUBLE PRECISION C(0:18),H,ALFA,B0,B1,B2
      INTEGER I
C
      DATA ZERO /0.0D0/, ONE /1.0D0/
      DATA HALF /0.5D0/, MALF /-0.5D0/, MONE /-1.0D0/, MTWO /-2.0D0/
      DATA PI3 /3.28986 81336 96453D0/, PI6 /1.64493 40668 48226D0/
C
      DATA C( 0) / 0.42996 69356 08137 0D0/
      DATA C( 1) / 0.40975 98753 30771 1D0/
      DATA C( 2) /-0.01858 84366 50146 0D0/
      DATA C( 3) / 0.00145 75108 40622 7D0/
      DATA C( 4) /-0.00014 30418 44423 4D0/
      DATA C( 5) / 0.00001 58841 55418 8D0/
      DATA C( 6) /-0.00000 19078 49593 9D0/
      DATA C( 7) / 0.00000 02419 51808 5D0/
      DATA C( 8) /-0.00000 00319 33412 7D0/
      DATA C( 9) / 0.00000 00043 45450 6D0/
      DATA C(10) /-0.00000 00006 05784 8D0/
      DATA C(11) / 0.00000 00000 86121 0D0/
      DATA C(12) /-0.00000 00000 12443 3D0/
      DATA C(13) / 0.00000 00000 01822 6D0/
      DATA C(14) /-0.00000 00000 00270 1D0/
      DATA C(15) / 0.00000 00000 00040 4D0/
      DATA C(16) /-0.00000 00000 00006 1D0/
      DATA C(17) / 0.00000 00000 00000 9D0/
      DATA C(18) /-0.00000 00000 00000 1D0/
C
      IF(X .EQ. ONE) THEN
       DDILOG=PI6
       RETURN
      ELSE IF(X .EQ. MONE) THEN
       DDILOG=MALF*PI6
       RETURN
      END IF
      T=-X
      IF(T .LE. MTWO) THEN
       Y=MONE/(ONE+T)
       S=ONE
       A=-PI3+HALF*(LOG(-T)**2-LOG(ONE+ONE/T)**2)
      ELSE IF(T .LT. MONE) THEN
       Y=MONE-T
       S=MONE
       A=LOG(-T)
       A=-PI6+A*(A+LOG(ONE+ONE/T))
      ELSE IF(T .LE. MALF) THEN
       Y=(MONE-T)/T
       S=ONE
       A=LOG(-T)
       A=-PI6+A*(MALF*A+LOG(ONE+T))
      ELSE IF(T .LT. ZERO) THEN
       Y=-T/(ONE+T)
       S=MONE
       A=HALF*LOG(ONE+T)**2
      ELSE IF(T .LE. ONE) THEN
       Y=T
       S=ONE
       A=ZERO
      ELSE
       Y=ONE/T
       S=MONE
       A=PI6+HALF*LOG(T)**2
      END IF
C
      H=Y+Y-ONE
      ALFA=H+H
      B1=ZERO
      B2=ZERO
      DO 1 I = 18,0,-1
      B0=C(I)+ALFA*B1-B2
      B2=B1
    1 B1=B0
      DDILOG=-(S*(B0-H*B2)+A)
      RETURN
      END
CDECK  ID>, EISRS1. 
      SUBROUTINE EISRS1(NM,N,AR,WR,ZR,IERR,WORK)
C     ALL EIGENVALUES AND CORRESPONDING EIGENVECTORS OF A REAL
C     SYMMETRIC MATRIX
C     FROM CERN PROGRAM LIBRARY
C
      IMPLICIT NONE
      INTEGER NM,N,IERR
      REAL AR(NM,NM),WR(N),ZR(NM,NM),WORK(1)
      CALL TRED2(NM,N,AR,WR,WORK,ZR)
      CALL TQL2(NM,N,WR,WORK,ZR,IERR)
      RETURN
      END
CDECK  ID>, RKSTP.  
C-----------------------------------------------------------------------
      SUBROUTINE RKSTP(N,H,X,Y,SUB,W)
C-----------------------------------------------------------------------
C
C     From CERN Program Library, routine D209, with error message for
C     N.LT.1 replaced by STOP 99 to eliminate Kernlib error routine.
C
      DIMENSION Y(N),W(N,3)
      LOGICAL MFLAG,RFLAG
      EXTERNAL SUB
C
C     ******************************************************************
C
C     THIS SUBROUTINE REPLACES X BY X+H AND ADVANCES THE SOLUTION OF THE
C     SYSTEM OF DIFFERENTIAL EQUATIONS DY/DX=F(X,Y) FROM Y(X) TO Y(X+H)
C     USING A FIFTH-ORDER RUNGE-KUTTA METHOD.
C
C     SUB IS THE NAME OF A SUBROUTINE SUB(X,Y,F) WHICH SETS THE VECTOR F
C     TO THE DERIVATIVE AT X OF THE VECTOR Y.
C
C     W IS A WORKING-SPACE ARRAY, TREATED AS CONSISTING OF THREE CONSEC-
C     UTIVE WORKING VECTORS OF LENGTH N.
C
C     ******************************************************************
C
C  START.
      IF (N.LT.1) STOP 99
      NLOCAL=N
      HLOCAL=H
      H2=0.5*HLOCAL
      H6=HLOCAL/6.
      XH=X+HLOCAL
      XH2=X+H2
      CALL SUB(X,Y,W(1,1))
      DO 1 J=1,NLOCAL
         W(J,2)=Y(J)+H2*W(J,1)
    1 CONTINUE
      CALL SUB(XH2,W(1,2),W(1,3))
      DO 2 J=1,NLOCAL
         W(J,1)=W(J,1)+2.*W(J,3)
         W(J,2)=Y(J)+H2*W(J,3)
    2 CONTINUE
      CALL SUB(XH2,W(1,2),W(1,3))
      DO 3 J=1,NLOCAL
         W(J,1)=W(J,1)+2.*W(J,3)
         W(J,2)=Y(J)+HLOCAL*W(J,3)
    3 CONTINUE
      CALL SUB(XH,W(1,2),W(1,3))
      DO 4 J=1,NLOCAL
         Y(J)=Y(J)+H6*(W(J,1)+W(J,3))
    4 CONTINUE
      X=XH
      RETURN
      END
CDECK  ID>, SSALFS. 
      DOUBLE PRECISION FUNCTION SSALFS(Q2)
C-----------------------------------------------------------------------
C     Strong coupling formula from page 201 of Barger and Phillips:
C     (using ALQCD4 for 4 flavor Lambda)
C
C     Bisset's STRCPLH
C-----------------------------------------------------------------------
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C
      DOUBLE PRECISION Q2,AS,TH5,TH6,PI
      DATA PI/3.14159265D0/
C
      TH5=4*AMBT**2
      TH6=4*AMTP**2
      IF (Q2.LE.TH5)THEN
        AS=12*PI/(25*LOG(Q2/ALQCD4**2))
      ELSE IF(Q2.GT.TH5.AND.Q2.LE.TH6) THEN
        AS=25*LOG(Q2/ALQCD4**2)-2*LOG(Q2/TH5)
        AS=12*PI/AS
      ELSEIF(Q2.GT.TH6)THEN
        AS=25*LOG(Q2/ALQCD4**2)
        AS=AS-2*(LOG(Q2/TH5)+LOG(Q2/TH6))
        AS=12*PI/AS
      ENDIF
      SSALFS=AS
      RETURN
      END
CDECK  ID>, SSB0.   
      COMPLEX*16 FUNCTION SSB0(QSQ,M1,M2)
      IMPLICIT NONE
      COMPLEX*16 SSF0
      DOUBLE PRECISION XLAM
      REAL QSQ,M1,M2
      COMMON /SSINF/ XLAM
      SSB0=XLAM*(1.D0,0.D0)-SSF0(QSQ,M1,M2)
      RETURN
      END
CDECK  ID>, SSB1.   
      COMPLEX*16 FUNCTION SSB1(XS,XMI,XMJ)
C     MODIFIED BY M. DREES 10/26/95
      REAL XS,XMI,XMJ
      DOUBLE PRECISION XLAM,S,MI,MJ,A0MI,A0MJ
      COMPLEX*16 SSB0
      COMMON /SSINF/ XLAM
      S=XS
      MI=XMI
      MJ=XMJ
      IF(S.GT.1.D-4*(MI**2+MJ**2)) THEN
        IF(MI.GE.1.D-10) THEN
          A0MI = MI**2*( 1.D0 - LOG(MI**2) + XLAM )
        ELSE
          A0MI = 0.D0
        ENDIF
        IF(MJ.GE.1.D-10) THEN
          A0MJ = MJ**2*( 1.D0 - LOG(MJ**2) + XLAM )
        ELSE
          A0MJ = 0.D0
        ENDIF
        SSB1 = ( (S+MI**2-MJ**2)*SSB0(XS,XMI,XMJ) + A0MJ - A0MI )/2.D0/S
      ELSE IF(ABS(MI-MJ).GT.1.D-4*MJ) THEN
	IF(MI.GT.1.D-10.AND.MJ.GT.1.D-10) THEN
          SSB1 = -(LOG(MI)*(MI**4-2.*MJ**2*MI**2) + MJ**4*LOG(MJ)
     $    -MJ**4/4.D0-.75*MI**4 + MI**2*MJ**2) / (MI**2-MJ**2)**2
     $    + XLAM/2.D0
	ELSEIF(MI.GT.1.D-10) THEN
	  SSB1 = -LOG(MI) + .75 + .5*XLAM
	ELSEIF(MJ.GT.1.D-10) THEN
	  SSB1 = -LOG(MJ) + .25 + .5*XLAM
	ENDIF
      ELSE IF(MI.NE.0.D0) THEN
        SSB1 = -LOG(MI) + XLAM/2.D0
      ENDIF
      RETURN
      END
CDECK  ID>, SSDHLL. 
      SUBROUTINE SSDHLL(DELHLL)
C-----------------------------------------------------------------------
C
C          Calculates radiative correction to the
C          H_h-H_l-H_l vertex.
C          calculated by M. Bisset
C
C          This subroutine calculates the
C          radiative correction to the
C          H_h-H_l-H_l vertex which can be
C          important in determining the
C           H_h --> H_l H_l partial decay width.
C
C          Both top and bottom couplings are now
C          included.  Non-degenerate mixed squark
C          masses and A-terms are also included.
C          The D-terms from the squark mass matrix
C          (terms prop. to g**2 * Yukawa coupling)
C          are included as an option:
C                 INRAD = 1 ==> D-TERMS ON
C                 INRAD = 2 ==> D-TERMS OFF    .
C
C         10/18/93 D-terms are now turned on.
C                     INRAD = 1
C
C         There is an arbitrary mass scale that must
C         chosen to avoid dimensionful logarithms.
C         The choice does not matter if D-terms are
C         not included, but it does matter if D-terms
C         are included.
C
C         10/18/93 arbitrary mass scale set to H_h mass
C                       QQQ = AMHH
C
C         It is assumed that the A-terms are real.
C
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C
      REAL PI,PI2,SR2,G2,GP2,GGP,GG1,GG2
      REAL TANB,COTB,COSB,SINB,BE
      REAL SINB2,COSB2,COS2B,SIN2B
      REAL V2,VP2,V,VP,VVP,VPVM,VVPP,MT,MB
      REAL MT2,MB2,FT2,FB2,FT,FB,FT4,FB4
      REAL MW2,ZAP,QQQ2,EP,EP2,RR,MHP2
      REAL ATI,ABI,ATR,ABR,AT2,AB2
      REAL MSTL2,MSTR2,MSBL2,MSBR2
      REAL TLRM,BLRM
      REAL MST1SQ,MST2SQ,MSB1SQ,MSB2SQ
      REAL RTT,RBB
C
      REAL A0,A1,A2,A1P,A2P,A3,A4
      REAL B0,B1,B2,B1P,B2P,B3,B4
      REAL MT1R,MT2R,MB1R,MB2R
      REAL MT1P,MT2P,MB1P,MB2P
      REAL MT1RR,MT2RR,MB1RR,MB2RR
      REAL MT1PP,MT2PP,MB1PP,MB2PP
      REAL MT1RP,MT2RP,MB1RP,MB2RP
      REAL MT1RRR,MT2RRR,MB1RRR,MB2RRR
      REAL MT1PRR,MT2PRR,MB1PRR,MB2PRR
      REAL MT1RPP,MT2RPP,MB1RPP,MB2RPP
      REAL MT1PPP,MT2PPP,MB1PPP,MB2PPP
C
      REAL SQVT1,SQVT2,SQVB1,SQVB2
      REAL SQVRRR,SQVPPP,SQVPRR,SQVRPP
      REAL FVRRR,FVPPP
      REAL VRRR,VPPP,VPRR,VRPP
C
      REAL ALPHAT,GGP1SQ,ALPHAB,GGP2SQ,TEMPSQ,BSQ
      REAL ASMB,MBMB,MBQ,ASMT,MTMT,MTQ,SUALFS,HIGFRZ
      DOUBLE PRECISION SSMQCD
C
      REAL CA2,SA2,DVHLL
      DOUBLE PRECISION DELHLL
C
      INTEGER INRAD,ISPECT,ISPECB
C
      MW2=AMW**2
      HIGFRZ=SQRT(AMTLSS*AMTRSS)
      QQQ2=HIGFRZ**2
      INRAD=1
      ZAP=1.0
C
      PI=4.*ATAN(1.)
      PI2=PI**2
      SR2=SQRT(2.)
      G2=4.*PI*ALFAEM/SN2THW
      GP2=G2*SN2THW/(1.-SN2THW)
      ASMB=SUALFS(AMBT**2,.36,AMTP,3)
      MBMB=AMBT*(1.-4*ASMB/3./PI)
      MBQ=SSMQCD(DBLE(MBMB),DBLE(HIGFRZ))
      HIGFRZ=SQRT(AMTLSS*AMTRSS)
      ASMT=SUALFS(AMTP**2,.36,AMTP,3)
      MTMT=AMTP/(1.+4*ASMT/3./PI+(16.11-1.04*(5.-6.63/AMTP))*
     $(ASMT/PI)**2)
      MTQ=SSMQCD(DBLE(MTMT),DBLE(HIGFRZ))
      MT=MTQ
      MB=MBQ
      MT2=MT**2
      MB2=MB**2
      EP=TWOM1
      EP2=EP**2
      MHP2=AMHA**2
      RR=RV2V1
      TANB=1.0/RR
      COTB=RR
      BE=ATAN(1./RV2V1)
      SINB=SIN(BE)
      COSB=COS(BE)
      SINB2=SINB**2
      COSB2=COSB**2
      SIN2B=SIN(2.*BE)
      COS2B=COS(2.*BE)
      V2=2.0*MW2*SINB2/G2
      VP2=2.0*MW2*COSB2/G2
      V=SQRT(V2)
      VP=SQRT(VP2)
      VVP=SQRT(V2*VP2)
      VPVM=VP2-V2
      GGP=G2+GP2
      GG1=G2-5.0*GP2/3.0
      GG2=G2-GP2/3.0
      VVPP=2.0*AMZ**2/GGP
      FT2=MT2/V2
      FB2=MB2/VP2
      FT=SQRT(FT2)
      FB=SQRT(FB2)
      FT4 = FT2**2
      FB4 = FB2**2
C
C      (AAT and AAB are also assumed to be real)
C
      ATR=AAT
      ABR=AAB
      ATI=0.0
      ABI=0.0
      AT2=ATR**2+ATI**2
      AB2=ABR**2+ABI**2
C
      MSTL2=AMTLSS**2
      MSTR2=AMTRSS**2
      MSBL2=AMBLSS**2
      MSBR2=AMBRSS**2
      TLRM=MSTL2-MSTR2
      BLRM=MSBL2-MSBR2
C
C      UNFORTUNATELY, I HAVE USED MY OLD CONVENTION
C      FOR THE STOP AND SBOTTOM EIGENVALUES HERE
C      (T1 <==> T2 OF NOTATION IN X. TATA'S AND OTHER
C      PEOPLE'S NOTATION).  SO THE NEXT FOUR LINES ARE
C      A FIX-UP UNTIL I GO THROUGH AND CHANGE THE
C      NOTATION THROUGHOUT THIS SUBROUTINE.
C
      MST2SQ=AMT1SS**2
      MST1SQ=AMT2SS**2
      MSB2SQ=AMB1SS**2
      MSB1SQ=AMB2SS**2
C
C
C      Calculation of radiative correction to
C      the H_H-H_l-H_l vertex
C
C
C                  STOP TERMS
C
      ISPECT=0
      RTT=(TLRM+VPVM*ZAP*GG1/4.0)**2
     $      +4.0*MT2*(EP*COTB+ATR)**2+4.0*MT2*ATI**2
C
      IF(RTT.GT.0.0) THEN
        A0=SQRT(RTT)
        A1=-V*ZAP*GG1*(TLRM+ZAP*VPVM*GG1/4.0)/SR2
        A1=A1+4.0*SR2*FT*MT*(AT2+EP*ATR*COTB)
        A2=-ZAP*GG1*(TLRM+ZAP*VPVM*GG1/4.0)/2.0
        A2=A2 +V2*ZAP*GG1**2/4.0 +4.0*FT2*AT2
        A1P=VP*ZAP*GG1*(TLRM+ZAP*VPVM*GG1/4.0)/SR2
        A1P=A1P+4.0*SR2*FT*MT*EP*(ATR+EP*COTB)
        A2P=ZAP*GG1*(TLRM+ZAP*VPVM*GG1/4.0)/2.0
        A2P=A2P +VP2*ZAP*GG1**2/4.0 +4.0*FT2*EP2
        A3=SR2*ZAP*GG1**2/8.0
        A4=-VVP*ZAP*GG1**2/4.0 +4.0*FT2*EP*ATR
C
        MT1R=SR2*FT*MT-SR2*V*ZAP*GGP/8.0 +A1/(4.0*A0)
        MT2R=SR2*FT*MT-SR2*V*ZAP*GGP/8.0 -A1/(4.0*A0)
        MT1P=SR2*VP*ZAP*GGP/8.0 +A1P/(4.0*A0)
        MT2P=SR2*VP*ZAP*GGP/8.0 -A1P/(4.0*A0)
        MT1RR=FT2 -ZAP*GGP/8.0 -A1**2/(8.0*A0**3) +A2/(4.0*A0)
        MT2RR=FT2 -ZAP*GGP/8.0 +A1**2/(8.0*A0**3) -A2/(4.0*A0)
        MT1PP=ZAP*GGP/8.0 -A1P**2/(8.0*A0**3) +A2P/(4.0*A0)
        MT2PP=ZAP*GGP/8.0 +A1P**2/(8.0*A0**3) -A2P/(4.0*A0)
        MT1RRR=3.0*A1**3/(16.0*A0**3)
        MT1RRR=MT1RRR/(A0**2) -3.0*A1*A2/(8.0*A0**3)
     $                            +3.0*V*A3/(4.0*A0)
        MT2RRR=-MT1RRR
        MT1PPP=3.0*A1P**3/(16.0*A0**3)
        MT1PPP=MT1PPP/(A0**2) -3.0*A1P*A2P/(8.0*A0**3)
     $                             +3.0*VP*A3/(4.0*A0)
        MT2PPP=-MT1PPP
        MT1RP=-A1*A1P/(8.0*A0**3) +A4/(4.0*A0)
        MT2RP=-MT1RP
        MT1PRR=3.0*A1P*A1**2/(16.0*A0**3)
        MT1PRR=MT1PRR/(A0**2)
     $          -(A2*A1P+2.0*A1*A4)/(8.0*A0**3) -VP*A3/(4.0*A0)
        MT2PRR=-MT1PRR
        MT1RPP=3.0*A1*A1P**2/(16.0*A0**3)
        MT1RPP=MT1RPP/(A0**2)
     $          -(A1*A2P+2.0*A1P*A4)/(8.0*A0**3) -V*A3/(4.0*A0)
        MT2RPP=-MT1RPP
      ELSEIF(RTT.EQ.0.0) THEN
        IF(INRAD.EQ.2.OR.TANB.EQ.1.0) THEN
          IF(EP.EQ.0.0.AND.TLRM.EQ.0.0) THEN
            IF(ATR.EQ.0.0.AND.ATI.EQ.0.0) THEN
              ISPECT=1
              MT1R=SR2*V*FT2
              MT2R=SR2*V*FT2
              MT1P=0.0
              MT2P=0.0
              MT1RR=FT2
              MT2RR=FT2
              MT1PP=0.0
              MT2PP=0.0
              MT1RRR=0.0
              MT2RRR=0.0
              MT1PPP=0.0
              MT2PPP=0.0
              MT1RP=0.0
              MT2RP=0.0
              MT1PRR=0.0
              MT2PRR=0.0
              MT1RPP=0.0
              MT2RPP=0.0
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      IF(RTT.NE.0.0 .OR. ISPECT.EQ.1) THEN
        SQVT1=2.0*(3.0*MT1R*MT1RR+MST1SQ*MT1RRR)
        SQVT1=SQVT1*LOG(MST1SQ/QQQ2)
        SQVT1=SQVT1 +2.0*MT1R**3/MST1SQ +9.0*MT1R*MT1RR
        SQVT1=SQVT1+MST1SQ*MT1RRR
        SQVT2=2.0*(3.0*MT2R*MT2RR+MST2SQ*MT2RRR)
        SQVT2=SQVT2*LOG(MST2SQ/QQQ2)
        SQVT2=SQVT2 +2.0*MT2R**3/MST2SQ +9.0*MT2R*MT2RR
        SQVT2=SQVT2+MST2SQ*MT2RRR
        SQVRRR=SQVT1+SQVT2
C
        SQVT1=2.0*(3.0*MT1P*MT1PP+MST1SQ*MT1PPP)
        SQVT1=SQVT1*LOG(MST1SQ/QQQ2)
        SQVT1=SQVT1 +2.0*MT1P**3/MST1SQ + 9.0*MT1P*MT1PP
        SQVT1=SQVT1+MST1SQ*MT1PPP
        SQVT2=2.0*(3.0*MT2P*MT2PP+MST2SQ*MT2PPP)
        SQVT2=SQVT2*LOG(MST2SQ/QQQ2)
        SQVT2=SQVT2 +2.0*MT2P**3/MST2SQ +9.0*MT2P*MT2PP
        SQVT2=SQVT2 +MST2SQ*MT2PPP
        SQVPPP = SQVT1 + SQVT2
C
        SQVT1=2.0*MT1R*MT1RP+MT1P*MT1RR+MST1SQ*MT1PRR
        SQVT1=2.0*SQVT1*LOG(MST1SQ/QQQ2)
        SQVT1=SQVT1 +2.0*MT1P*MT1R**2/MST1SQ
        SQVT1=SQVT1+3.0*MT1P*MT1RR+6.0*MT1R*MT1RP
        SQVT1=SQVT1+MST1SQ*MT1PRR
        SQVT2=2.0*MT2R*MT2RP+MT2P*MT2RR+MST2SQ*MT2PRR
        SQVT2=2.0*SQVT2*LOG(MST2SQ/QQQ2)
        SQVT2=SQVT2 +2.0*MT2P*MT2R**2/MST2SQ
        SQVT2=SQVT2+3.0*MT2P*MT2RR+6.0*MT2R*MT2RP
        SQVT2=SQVT2+MST2SQ*MT2PRR
        SQVPRR=SQVT1+SQVT2
C
        SQVT1=2.0*MT1P*MT1RP+MT1R*MT1PP+MST1SQ*MT1RPP
        SQVT1=2.0*SQVT1*LOG(MST1SQ/QQQ2)
        SQVT1=SQVT1 +2.0*MT1R*MT1P**2/MST1SQ
        SQVT1=SQVT1+3.0*MT1R*MT1PP+6.0*MT1P*MT1RP
        SQVT1=SQVT1+MST1SQ*MT1RPP
        SQVT2=2.0*MT2P*MT2RP+MT2R*MT2PP+MST2SQ*MT2RPP
        SQVT2=2.0*SQVT2*LOG(MST2SQ/QQQ2)
        SQVT2=SQVT2 +2.0*MT2R*MT2P**2/MST2SQ
        SQVT2=SQVT2+3.0*MT2R*MT2PP+6.0*MT2P*MT2RP
        SQVT2=SQVT2+MST2SQ*MT2RPP
        SQVRPP=SQVT1+SQVT2
C
        FVRRR=-2.0*SR2*FT4*V*(6.0*LOG(MT2/QQQ2) + 13.0)
      ENDIF
C
      IF(RTT.EQ.0.0 .AND. ISPECT.EQ.0) THEN
        ALPHAT=(MSTL2 + MSTR2)/2.0 + MT2
        ALPHAT=ALPHAT +VP2*(1.0-TANB**2)*ZAP*GGP/8.0
        GGP1SQ= ZAP*GGP**2 +ZAP*GG1**2
C
        SQVRRR=12.0*FT4*LOG(ALPHAT/MT2)
        TEMPSQ=-FT2*ZAP*GGP +GGP1SQ/16.0
        SQVRRR=SQVRRR +3.0*TEMPSQ*LOG(ALPHAT/QQQ2)
        SQVRRR=SQVRRR -8.0*FT4 -9.0*FT2*ZAP*GGP/2.0
        SQVRRR=SQVRRR +9.0*GGP1SQ/32.0
        TEMPSQ=8.0*V2*(FT2-ZAP*GGP/8.0)**2
        TEMPSQ=TEMPSQ +3.0*V2*ZAP*GG1**2/8.0
        TEMPSQ=TEMPSQ +6.0*FT2*EP2*COTB**2
        SQVRRR=SQVRRR +TEMPSQ*(FT2-ZAP*GGP/8.0)/ALPHAT
        SQVRRR=SQVRRR*SR2*V
C
        SQVPPP=3.0*GGP1SQ*(2.0*LOG(ALPHAT/QQQ2)+3.0)/32.0
        TEMPSQ=ZAP*GGP*(ZAP*GGP**2+3.0*GG1**2)*VP2/ALPHAT/64.0
        SQVPPP=SQVPPP+TEMPSQ
        TEMPSQ=3.0*FT2*EP2*ZAP*GGP/ALPHAT/4.0
        SQVPPP=(SQVPPP+TEMPSQ)*SR2*VP
C
        TEMPSQ=FT2*ZAP*GGP -GGP1SQ/8.0
        SQVPRR=TEMPSQ*(2.0*LOG(ALPHAT/QQQ2)+3.0)
        TEMPSQ=4.0*ZAP*GGP*(FT2-ZAP*GGP/8.0)-FT2*ZAP*GG1**2
        TEMPSQ=TEMPSQ +3.0*ZAP*GGP*GG1**2/16.0
        TEMPSQ=V2*TEMPSQ+EP2*FT2*ZAP*GGP*(2.0+COTB**2)
        TEMPSQ=TEMPSQ-16.0*EP2*FT4
        SQVPRR=(SQVPRR+TEMPSQ/ALPHAT)*SR2*VP/4.0
C
        TEMPSQ=FT2*ZAP*GGP -GGP1SQ/8.0
        SQVRPP=TEMPSQ*(2.0*LOG(ALPHAT/QQQ2)+3.0)
        TEMPSQ=GGP1SQ*(FT2-ZAP*GGP/8.0)-ZAP*GGP*GG1**2/4.0
        TEMPSQ=VP2*TEMPSQ/2.0 +8.0*EP2*FT4
        TEMPSQ=TEMPSQ+EP2*FT2*ZAP*GGP*(1.0+2.0*COTB**2)
        SQVRPP=(SQVRPP+TEMPSQ/ALPHAT)*SR2*V/4.0
C
        FVRRR = 0.0
C
C        Fermion part (FRRR) is already combined
C        with the squark part.
C
      ENDIF
C
C
C                  SBOTTOM TERMS
C
      ISPECB=0
      RBB=(BLRM-VPVM*ZAP*GG2/4.0)**2
     $      +4.0*MB2*(EP*TANB+ABR)**2+4.0*MB2*ABI**2
C
      IF(RBB.GT.0.0) THEN
        B0=SQRT(RBB)
        B1=V*ZAP*GG2*(BLRM-ZAP*VPVM*GG2/4.0)/SR2
        B1=B1+4.0*SR2*FB*MB*EP*(ABR+EP*TANB)
        B2=ZAP*GG2*(BLRM-ZAP*VPVM*GG2/4.0)/2.0
        B2=B2 +V2*ZAP*GG2**2/4.0 +4.0*FB2*EP2
        B1P=-VP*ZAP*GG2*(BLRM-ZAP*VPVM*GG2/4.0)/SR2
        B1P=B1P+4.0*SR2*FB*MB*(AB2+EP*ABR*TANB)
        B2P=-ZAP*GG2*(BLRM-ZAP*VPVM*GG2/4.0)/2.0
        B2P=B2P +VP2*ZAP*GG2**2/4.0 +4.0*FB2*AB2
        B3=SR2*ZAP*GG2**2/8.0
        B4=-VVP*ZAP*GG2**2/4.0 +4.0*FB2*EP*ABR
C
        MB1R=SR2*V*ZAP*GGP/8.0 +B1/(4.0*B0)
        MB2R=SR2*V*ZAP*GGP/8.0 -B1/(4.0*B0)
        MB1P=SR2*FB*MB -SR2*VP*ZAP*GGP/8.0 +B1P/(4.0*B0)
        MB2P=SR2*FB*MB -SR2*VP*ZAP*GGP/8.0 -B1P/(4.0*B0)
        MB1RR=ZAP*GGP/8.0 -B1**2/(8.0*B0**3) +B2/(4.0*B0)
        MB2RR=ZAP*GGP/8.0 +B1**2/(8.0*B0**3) -B2/(4.0*B0)
        MB1PP=FB2 -ZAP*GGP/8.0
        MB2PP=MB1PP
        MB1PP=MB1PP -B1P**2/(8.0*B0**3) +B2P/(4.0*B0)
        MB2PP=MB2PP +B1P**2/(8.0*B0**3) -B2P/(4.0*B0)
        MB1RRR=3.0*B1**3/(16.0*B0**3)
        MB1RRR=MB1RRR/(B0**2) -3.0*B1*B2/(8.0*B0**3)
     $                            +3.0*V*B3/(4.0*B0)
        MB2RRR=-MB1RRR
        MB1PPP=3.0*B1P**3/(16.0*B0**3)
        MB1PPP=MB1PPP/(B0**2) -3.0*B1P*B2P/(8.0*B0**3)
        MB1PPP=MB1PPP +3.0*VP*B3/(4.0*B0)
        MB2PPP=-MB1PPP
        MB1RP=-B1*B1P/(8.0*B0**3) +B4/(4.0*B0)
        MB2RP=-MB1RP
        MB1PRR=3.0*B1P*B1**2/(16.0*B0**3)
        MB1PRR=MB1PRR/(B0**2) -(B2*B1P+2.0*B1*B4)/(8.0*B0**3)
        MB1PRR=MB1PRR -VP*B3/(4.0*B0)
        MB2PRR=-MB1PRR
        MB1RPP=3.0*B1*B1P**2/(16.0*B0**3)
        MB1RPP=MB1RPP/(B0**2) -(B1*B2P+2.0*B1P*B4)/(8.0*B0**3)
        MB1RPP=MB1RPP -V*B3/(4.0*B0)
        MB2RPP=-MB1RPP
      ELSEIF(RBB.EQ.0.0) THEN
        IF(INRAD.EQ.2.OR.TANB.EQ.1.0) THEN
          IF(EP.EQ.0.0.AND.BLRM.EQ.0.0) THEN
            IF(ABR.EQ.0.0.AND.ABI.EQ.0.0) THEN
              ISPECB=1
              MB1R=0.0
              MB2R=0.0
              MB1P=SR2*VP*FB2
              MB2P=SR2*VP*FB2
              MB1RR=0.0
              MB2RR=0.0
              MB1PP=FB2
              MB2PP=FB2
              MB1RRR=0.0
              MB2RRR=0.0
              MB1PPP=0.0
              MB2PPP=0.0
              MB1RP=0.0
              MB2RP=0.0
              MB1PRR=0.0
              MB1PRR=0.0
              MB2PRR=0.0
              MB1RPP=0.0
              MB2RPP=0.0
            ENDIF
          ENDIF
        ENDIF
      ENDIF
C
      IF(RBB.NE.0.0 .OR. ISPECB.EQ.1) THEN
        SQVB1=2.0*(3.0*MB1R*MB1RR+MSB1SQ*MB1RRR)
        SQVB1=SQVB1*LOG(MSB1SQ/QQQ2)
        SQVB1=SQVB1 +2.0*MB1R**3/MSB1SQ +9.0*MB1R*MB1RR
        SQVB1=SQVB1+MSB1SQ*MB1RRR
        SQVB2=2.0*(3.0*MB2R*MB2RR+MSB2SQ*MB2RRR)
        SQVB2=SQVB2*LOG(MSB2SQ/QQQ2)
        SQVB2=SQVB2 +2.0*MB2R**3/MSB2SQ +9.0*MB2R*MB2RR
        SQVB2=SQVB2+MSB2SQ*MB2RRR
        SQVRRR = SQVRRR + SQVB1 + SQVB2
C
        SQVB1=2.0*(3.0*MB1P*MB1PP+MSB1SQ*MB1PPP)
        SQVB1=SQVB1*LOG(MSB1SQ/QQQ2)
        SQVB1=SQVB1 +2.0*MB1P**3/MSB1SQ +9.0*MB1P*MB1PP
        SQVB1=SQVB1+MSB1SQ*MB1PPP
        SQVB2=2.0*(3.0*MB2P*MB2PP+MSB2SQ*MB2PPP)
        SQVB2=SQVB2*LOG(MSB2SQ/QQQ2)
        SQVB2=SQVB2 +2.0*MB2P**3/MSB2SQ +9.0*MB2P*MB2PP
        SQVB2=SQVB2+MSB2SQ*MB2PPP
        SQVPPP= SQVPPP+SQVB1+SQVB2
C
        SQVB1=2.0*MB1R*MB1RP+MB1P*MB1RR+MSB1SQ*MB1PRR
        SQVB1=2.0*SQVB1*LOG(MSB1SQ/QQQ2)
        SQVB1=SQVB1 +2.0*MB1P*MB1R**2/MSB1SQ
        SQVB1=SQVB1 +3.0*MB1P*MB1RR +6.0*MB1R*MB1RP
        SQVB1=SQVB1+MSB1SQ*MB1PRR
        SQVB2=2.0*MB2R*MB2RP+MB2P*MB2RR+MSB2SQ*MB2PRR
        SQVB2=2.0*SQVB2*LOG(MSB2SQ/QQQ2)
        SQVB2=SQVB2 +2.0*MB2P*MB2R**2/MSB2SQ
        SQVB2=SQVB2 +3.0*MB2P*MB2RR +6.0*MB2R*MB2RP
        SQVB2=SQVB2+MSB2SQ*MB2PRR
        SQVPRR=SQVPRR+SQVB1+SQVB2
C
        SQVB1=2.0*MB1P*MB1RP+MB1R*MB1PP+MSB1SQ*MB1RPP
        SQVB1=2.0*SQVB1*LOG(MSB1SQ/QQQ2)
        SQVB1=SQVB1 +2.0*MB1R*MB1P**2/MSB1SQ
        SQVB1=SQVB1+3.0*MB1R*MB1PP+6.0*MB1P*MB1RP
        SQVB1=SQVB1+MSB1SQ*MB1RPP
        SQVB2=2.0*MB2P*MB2RP+MB2R*MB2PP+MSB2SQ*MB2RPP
        SQVB2=2.0*SQVB2*LOG(MSB2SQ/QQQ2)
        SQVB2=SQVB2 +2.0*MB2R*MB2P**2/MSB2SQ
        SQVB2=SQVB2 +3.0*MB2R*MB2PP +6.0*MB2P*MB2RP
        SQVB2=SQVB2+MSB2SQ*MB2RPP
        SQVRPP=SQVRPP+SQVB1+SQVB2
C
        IF(MB2.EQ.0.0) THEN
          FVPPP=0.0
        ELSE IF(MB2.NE.0.0) THEN
          FVPPP=-2.0*SR2*FB4*VP*(6.0*LOG(MB2/QQQ2)+13.0)
        ENDIF
C
      ENDIF
C
      IF(RBB.EQ.0.0 .AND. ISPECB.EQ.0) THEN
        ALPHAB=(MSBL2+MSBR2)/2.0 +MB2
        ALPHAB=ALPHAB -VP2*(1.0-TANB**2)*ZAP*GGP/8.0
        GGP2SQ=ZAP*GGP**2 +ZAP*GG2**2
C
        BSQ=3.0*GGP2SQ*(2.0*LOG(ALPHAB/QQQ2)+3.0)/8.0
        TEMPSQ=V2*(ZAP*GGP**2 +3.0*ZAP*GG2**2)/16.0
     $                                   +3.0*FB2*EP2
        BSQ=(BSQ +ZAP*GGP*TEMPSQ/ALPHAB)*SR2*V/4.0
        SQVRRR=SQVRRR+BSQ
C
        BSQ=12.0*FB4*LOG(ALPHAB/MB2) -8.0*FB4
        TEMPSQ=-FB2*ZAP*GGP +GGP2SQ/16.0
        BSQ=BSQ+3.0*TEMPSQ*(LOG(ALPHAB/QQQ2)+1.5)
        TEMPSQ=8.0*VP2*(FB2-ZAP*GGP/8.0)**2
     $     +3.0*VP2*ZAP*GG2**2/8.0 +6.0*FB2*EP2*TANB**2
        BSQ=BSQ +(FB2-ZAP*GGP/8.0)*TEMPSQ/ALPHAB
        BSQ=BSQ*SR2*VP
        SQVPPP=SQVPPP+BSQ
C
        TEMPSQ=0.5*(FB2*ZAP*GGP -GGP2SQ/8.0)
        BSQ=TEMPSQ*(LOG(ALPHAB/QQQ2)+1.5)
        TEMPSQ=(FB2 -ZAP*GGP/8.0)*GGP2SQ -ZAP*GGP*GG2**2/4.0
        TEMPSQ=V2*TEMPSQ/4.0 +4.0*FB4*EP2 -FB2*EP2*ZAP*GGP/2.0
        TEMPSQ=(TEMPSQ-FB2*EP2*ZAP*GGP*TANB**2)/ALPHAB/2.0
        BSQ=(BSQ+TEMPSQ)*SR2*VP
        SQVPRR=SQVPRR+BSQ
C
        TEMPSQ=0.5*(FB2*ZAP*GGP -GGP2SQ/8.0)
        BSQ=TEMPSQ*(LOG(ALPHAB/QQQ2)+1.5)
        TEMPSQ=4.0*ZAP*GGP*(FB2 -ZAP*GGP/8.0)**2
     $          -FB2*ZAP*GG2**2 +3.0*ZAP*GGP*GG2**2/16.0
        TEMPSQ=VP2*TEMPSQ-16.0*FB4*EP2
        TEMPSQ=TEMPSQ+FB2*EP2*ZAP*GGP*(TANB**2 +0.5)
        BSQ=(BSQ +TEMPSQ/ALPHAB/4.0)*SR2*V
        SQVRPP=SQVRPP+BSQ
C
        FVPPP=0.0
C
C        Fermion part (FPPP) is already combined
C        with the squark part.
C
      ENDIF
C
C
      VRRR=3.0*(SQVRRR+FVRRR)/(32.0*PI2)
      VRRR=VRRR/6.0
C
      VPPP=3.0*(SQVPPP+FVPPP)/(32.0*PI2)
      VPPP=VPPP/6.0
C
      VPRR=3.0*(SQVPRR)/(32.0*PI2)
      VPRR=VPRR/2.0
C
      VRPP=3.0*(SQVRPP)/(32.0*PI2)
      VRPP=VRPP/2.0
C
C
C      Note in the following that the angle ALFAH
C      calculated in the subroutine SSMHN must
C      be input.
C
      CA2=(COS(ALFAH))**2
      SA2=(SIN(ALFAH))**2
      DVHLL=-VRRR*CA2*SIN(ALFAH)
      DVHLL=DVHLL +VPRR*(CA2-2.0*SA2)*COS(ALFAH)
      DVHLL=DVHLL +VRPP*(2.0*CA2-SA2)*SIN(ALFAH)
      DVHLL=DVHLL +VPPP*SA2*COS(ALFAH)
C
      DVHLL=3.0*DVHLL
      DVHLL=-DVHLL
C
C      Finally, multiply bt the coefficient of the
C      tree-level Lagrangian level term (COEFF.)
C      so that the answer may be written as:
C        DW = (COEFF.)**2
C            * (TREE-LEVEL ANGULAR DEPENDENCE + DVHLL)
C
C              *(LAMBDA KINEMATIC FCN)**0.5/(8*PI*MHH**3)
C
C
      DVHLL=4.0*SQRT((1.-SN2THW)/G2)*DVHLL/AMZ
C
C
1000  DELHLL=DVHLL
      RETURN
      END
CDECK  ID>, SSDINT. 
      DOUBLE PRECISION FUNCTION SSDINT(XL,F,XR)
C-----------------------------------------------------------------------
C          Integrate F over (XL,XR) using adaptive Gaussian quadrature.
C          TOLABS = 1e-35: absolute error for convergence.
C          TOLREL = 5e-5:  relative error for convergence.
C          TOLBIN = 1e-3:  relative bin size limit. Set contribution to
C                          zero if bin falls below this.
C     Note quadrature constants R and W have been converted to explicit
C     double precision (.xxxxxDxx) form.
C
C     Bisset's XINTH
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
      EXTERNAL F
      INTEGER NMAX
      DOUBLE PRECISION TOLABS,TOLREL,TOLBIN,XMIN,XLIMS(100)
      DOUBLE PRECISION R(93),W(93)
      INTEGER PTR(4),NORD(4)
      INTEGER ICOUNT,IBAD
      DOUBLE PRECISION XL,XR,F
      DOUBLE PRECISION AA,BB,TVAL,VAL,TOL
      INTEGER NLIMS,I,J,KKK
C
      DATA PTR,NORD/4,10,22,46,  6,12,24,48/
      DATA (R(KKK),KKK=1,48)/
     $ .2386191860D0,.6612093865D0,.9324695142D0,.1252334085D0,
     $ .3678314990D0,.5873179543D0,.7699026742D0,.9041172563D0,
     $ .9815606342D0,.0640568929D0,.1911188675D0,.3150426797D0,
     $ .4337935076D0,.5454214714D0,.6480936519D0,.7401241916D0,
     $ .8200019860D0,.8864155270D0,.9382745520D0,.9747285560D0,
     $ .9951872200D0,.0323801710D0,.0970046992D0,.1612223561D0,
     $ .2247637903D0,.2873624873D0,.3487558863D0,.4086864820D0,
     $ .4669029048D0,.5231609747D0,.5772247261D0,.6288673968D0,
     $ .6778723796D0,.7240341309D0,.7671590325D0,.8070662040D0,
     $ .8435882616D0,.8765720203D0,.9058791367D0,.9313866907D0,
     $ .9529877032D0,.9705915925D0,.9841245837D0,.9935301723D0,
     $ .9987710073D0,.0162767488D0,.0488129851D0,.0812974955D0/
      DATA (R(KKK),KKK=49,93)/
     $ .1136958501D0,.1459737146D0,.1780968824D0,.2100313105D0,
     $ .2417431561D0,.2731988126D0,.3043649444D0,.3352085229D0,
     $ .3656968614D0,.3957976498D0,.4254789884D0,.4547094222D0,
     $ .4834579739D0,.5116941772D0,.5393881083D0,.5665104186D0,
     $ .5930323648D0,.6189258401D0,.6441634037D0,.6687183100D0,
     $ .6925645366D0,.7156768123D0,.7380306437D0,.7596023411D0,
     $ .7803690438D0,.8003087441D0,.8194003107D0,.8376235112D0,
     $ .8549590334D0,.8713885059D0,.8868945174D0,.9014606353D0,
     $ .9150714231D0,.9277124567D0,.9393703398D0,.9500327178D0,
     $ .9596882914D0,.9683268285D0,.9759391746D0,.9825172636D0,
     $ .9880541263D0,.9925439003D0,.9959818430D0,.9983643759D0,
     $ .9996895039/
        DATA (W(KKK),KKK=1,48)/
     $ .4679139346D0,.3607615730D0,.1713244924D0,.2491470458D0,
     $ .2334925365D0,.2031674267D0,.1600783285D0,.1069393260D0,
     $ .0471753364D0,.1279381953D0,.1258374563D0,.1216704729D0,
     $ .1155056681D0,.1074442701D0,.0976186521D0,.0861901615D0,
     $ .0733464814D0,.0592985849D0,.0442774388D0,.0285313886D0,
     $ .0123412298D0,.0647376968D0,.0644661644D0,.0639242386D0,
     $ .0631141923D0,.0620394232D0,.0607044392D0,.0591148397D0,
     $ .0572772921D0,.0551995037D0,.0528901894D0,.0503590356D0,
     $ .0476166585D0,.0446745609D0,.0415450829D0,.0382413511D0,
     $ .0347772226D0,.0311672278D0,.0274265097D0,.0235707608D0,
     $ .0196161605D0,.0155793157D0,.0114772346D0,.0073275539D0,
     $ .0031533461D0,.0325506145D0,.0325161187D0,.0324471637D0/
      DATA (W(KKK),KKK=49,93)/
     $ .0323438226D0,.0322062048D0,.0320344562D0,.0318287589D0,
     $ .0315893308D0,.0313164256D0,.0310103326D0,.0306713761D0,
     $ .0302999154D0,.0298963441D0,.0294610900D0,.0289946142D0,
     $ .0284974111D0,.0279700076D0,.0274129627D0,.0268268667D0,
     $ .0262123407D0,.0255700360D0,.0249006332D0,.0242048418D0,
     $ .0234833991D0,.0227370697D0,.0219666444D0,.0211729399D0,
     $ .0203567972D0,.0195190811D0,.0186606796D0,.0177825023D0,
     $ .0168854799D0,.0159705629D0,.0150387210D0,.0140909418D0,
     $ .0131282296D0,.0121516047D0,.0111621020D0,.0101607705D0,
     $ .0091486712D0,.0081268769D0,.0070964708D0,.0060585455D0,
     $ .0050142027D0,.0039645543D0,.0029107318D0,.0018539608D0,
     $ .0007967921/
C
      DATA TOLABS,TOLREL,TOLBIN,NMAX/1.D-35,5.D-5,1D-5,100/
C
      SSDINT=0
      NLIMS=2
      XLIMS(1)=XL
      XLIMS(2)=XR
      ICOUNT=0
      IBAD=0
      XMIN=TOLBIN*ABS(XR-XL)
C
10    AA=(XLIMS(NLIMS)-XLIMS(NLIMS-1))/2
      BB=(XLIMS(NLIMS)+XLIMS(NLIMS-1))/2
      TVAL=0
      DO 15 I=1,3
15    TVAL=TVAL+W(I)*(F(BB+AA*R(I))+F(BB-AA*R(I)))
      TVAL=TVAL*AA
      DO 25 J=1,4
        VAL=0
        DO 20 I=PTR(J),PTR(J)-1+NORD(J)
          ICOUNT=ICOUNT+1
          IF(ICOUNT.GT.1E5) THEN
            WRITE(LOUT,*) 'ERROR IN SSDINT: SET SSDINT = 0'
            SSDINT=0.
            RETURN
          ENDIF
20      VAL=VAL+W(I)*(F(BB+AA*R(I))+F(BB-AA*R(I)))
        VAL=VAL*AA
        TOL=MAX(TOLABS,TOLREL*ABS(VAL))
        IF(ABS(TVAL-VAL).LT.TOL) THEN
          SSDINT=SSDINT+VAL
          NLIMS=NLIMS-2
          IF (NLIMS.NE.0) GO TO 10
          GO TO 999
        ELSEIF(ABS(AA).LT.XMIN.AND.J.EQ.4) THEN
C           Bin is too small -- set VAL = 0. -- FEP
          IBAD=IBAD+1
          NLIMS=NLIMS-2
          IF (NLIMS.NE.0) GO TO 10
          GO TO 999
        ENDIF
25    TVAL=VAL
      IF(NMAX.EQ.2) THEN
        SSDINT=VAL
        GO TO 999
      ENDIF
      IF(NLIMS.GT.(NMAX-2)) THEN
        WRITE(LOUT,50) SSDINT,NMAX,BB-AA,BB+AA
50      FORMAT (' ERROR IN SSDINT, SSDINT,NMAX,XL,XR=',G15.7,I5,2G15.7)
        RETURN
      ENDIF
      XLIMS(NLIMS+1)=BB
      XLIMS(NLIMS+2)=BB+AA
      XLIMS(NLIMS)=BB
      NLIMS=NLIMS+2
      GO TO 10
C
999   IF(IBAD.GT.0) THEN
        WRITE(LOUT,*) 'WARNING IN SSXINT: BAD CONVERGENCE FOR ',IBAD,
     $  ' INTERVALS.'
      ENDIF
      RETURN
      END
CDECK  ID>, SSDLAM. 
        DOUBLE PRECISION FUNCTION SSDLAM(A,B,C)
C-----------------------------------------------------------------------
C          Kinematic function
C-----------------------------------------------------------------------
      IMPLICIT NONE
        DOUBLE PRECISION A,B,C
C            Rewrite SSDLAM=A**2+B**2+C**2-2*A*B-2*A*C-2*B*C
        IF(A.GE.B.AND.A.GE.C) THEN
          SSDLAM=(A-B-C)**2-4*B*C
        ELSEIF(B.GE.A.AND.B.GE.C) THEN
          SSDLAM=(B-A-C)**2-4*A*C
        ELSE
          SSDLAM=(C-A-B)**2-4*A*B
        ENDIF
        RETURN
        END
CDECK  ID>, SSF0.   
      COMPLEX*16 FUNCTION SSF0(XQSQ,XM1,XM2)
      IMPLICIT NONE
      REAL XQSQ,XM1,XM2
      DOUBLE PRECISION QSQ,M1,M2,M1SQ,M2SQ,AQSQ,RE,XI,R
      DOUBLE PRECISION PI,T1,T2,BETA,XL,T
      DATA PI/3.14159265359D0/
      QSQ=XQSQ
      M1=XM1
      M2=XM2
      M1SQ=M1*M1
      M2SQ=M2*M2
      AQSQ=ABS(QSQ)
      IF(AQSQ.LT.1.D-6*(M1SQ+M2SQ)) THEN
        IF(ABS(M1-M2).LT.1.D-6*M1) THEN
          IF(M1SQ.LT.1.D-8) THEN
            RE=LOG(1.D-8)
          ELSE
            RE=LOG(M1SQ)+.5*(M2SQ/M1SQ-1.D0) -QSQ/(6.*M1SQ)
          ENDIF
        ELSE
          IF(M2SQ.LT.1.D-6*M1SQ) THEN
            RE=LOG(M1SQ)-1.D0
          ELSE IF(M1SQ.LT.1.D-6*M2SQ) THEN
            RE=LOG(M2SQ)-1.D0
          ELSEIF(M1SQ.GE.1.D-9*M2SQ) THEN
            RE=LOG(M1*M2)+(M1SQ+M2SQ)/(M1SQ-M2SQ)*LOG(M1/M2)-1.D0
     $      -QSQ*(.5*(M1SQ+M2SQ)-M1SQ*M2SQ*LOG(M2SQ/M1SQ)/(M2SQ-M1SQ))
     $      /(M1SQ-M2SQ)**2
          ENDIF
        ENDIF
        XI=0.D0
      ELSE
        IF(M1SQ.LT.1.D-6*AQSQ.OR.M2SQ.LT.1.D-6*AQSQ.OR.
     $  M1SQ+M2SQ.LT.1.D-5*AQSQ) THEN
          IF(M1SQ.LT.1.D-6*AQSQ) THEN
            R=M2SQ/QSQ
          ELSE
            R=M1SQ/QSQ
          ENDIF
          IF(ABS(R-1.D0).GT.1.D-6.AND.ABS(R).GT.1.D-6.AND.
     $    M1SQ+M2SQ.GT.1.D-5*AQSQ) THEN
            RE=LOG(R*QSQ)-2.D0+(1.D0-R)*LOG(ABS(1.D0-1.D0/R))
          ELSE
            RE=-2.D0+LOG(AQSQ)
          ENDIF
          IF(R.LT.1.D0.AND.R.GT.-1.D-10) THEN
            XI=-PI*(1.D0-R)
          ELSE
            XI=0.D0
          ENDIF
        ELSE
          T1=(M1-M2)*(M1-M2)
          T2=T1+4.0*M1*M2
          BETA=SQRT(ABS((1.D0-T1/QSQ)*(1.D0-T2/QSQ)))
          IF(QSQ.GT.T2.OR.QSQ.LT.T1) THEN
            XL=.5*BETA*LOG((QSQ*(1.D0+BETA)-M1SQ-M2SQ)/
     $      (QSQ*(1.D0-BETA)-M1SQ-M2SQ))
          ELSE
          T=M1SQ+M2SQ-QSQ
          IF(T.EQ.0.) T=1.D-10
            XL=BETA*ATAN(QSQ*BETA/T)
            IF(T.LT.0.D0) XL = XL + PI*BETA
          ENDIF
          RE=LOG(M1*M2)-(M1SQ-M2SQ)/QSQ*LOG(M2/M1)-2.D0+XL
          IF(QSQ.GT.T2) THEN
            XI=-PI*BETA
          ELSE
            XI=0.D0
          ENDIF
        ENDIF
      ENDIF
      SSF0=RE*(1.D0,0.D0)-XI*(0.D0,1.D0)
      RETURN
      END
CDECK  ID>, SSGLBF. 
        SUBROUTINE SSGLBF
C-----------------------------------------------------------------------
C
C       This subroutine gives gluino branching fractions to gauginos
C       according to Baer,Barger,Karatas,Tata (Phys.Rev.D36,96(1987)
C       (Now includes gluino->gluon+zino1,2,3,4 loop decays. Jan 1990)
C       Also includes contribution due to non-degenerate t1-t2 stops
C       Also includes contribution due to non-degenerate b_L and b_R
C       Updated to include mixed sbottom states b1 and b2: 10/9/96
C
C       Auxiliary functions are called SSGxyi, where normally x
C       indicates the SUSY particle, y the SM particle(s), and i is
C       a counter.
C
C       Baer's GLUBF
C
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          MXSS                 = maximum number of modes
C          NSSMOD               = number of modes
C          ISSMOD               = initial particle
C          JSSMOD               = final particles
C          GSSMOD               = width
C          BSSMOD               = branching ratio
      INTEGER MXSS
      PARAMETER (MXSS=1000)
      COMMON/SSMODE/NSSMOD,ISSMOD(MXSS),JSSMOD(5,MXSS),GSSMOD(MXSS)
     $,BSSMOD(MXSS)
      INTEGER NSSMOD,ISSMOD,JSSMOD
      REAL GSSMOD,BSSMOD
      SAVE /SSMODE/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C
      EXTERNAL SSGWQ1,SSGWQ2,SSGZG1,SSGZG2,SSGZG3,SSGZT
      EXTERNAL SSGWT1,SSGWT2,SSGWT3,SSGWT4,SSGWT5,SSGWT6,
     $SSGWT7,SSGWT8
      EXTERNAL SSGX1,SSGX2,SSGX3,SSGX4,SSGX5,SSGX6,SSGX7,SSGX8
     $,SSGX9
      REAL WIDU,WIDD,WIDI,WIDL,WIDR
      REAL SSXINT,SSXLAM,XUPPER,XTCON,SUM,GMQK,C,G,FT,GP
     $,UPPER,GS,FB,TANB,PI,SR2,UPPR,ALF3
      REAL MW1,MW2,SNW1,SNW2,XM,YM,THX,THY,COST,SINT,COSB,SINB
      REAL MZIZ,AUIZ,ADIZ,BUIZ,BDIZ
      REAL WID,SNZIZ,FACT
      REAL XT1,XT2,XT3,XT4,XT5,XT6,XT7,XT8,XT9,AL1,AL2,BE1,BE2
      REAL XLL,XRR,XL1R1,XL2R2,XL1R2,XL2R1,XL1L2,XR1R2,XLR1
      REAL XMST1,XMST2,XMST12,XLR2,XMSB1,XMSB2,XMSB12
      REAL BW1,BW2,GT1,GT2,GT1T2,GB1,GB2,GT1B1,GT1B2,GT2B1,GT2B2
      REAL KUL,KUR,KDL,KDR,KCL,KCR,KSL,KSR,KBL,KBR,KT1,KT2
      REAL XKUL,XKUR,XKDL,XKDR,XKSL,XKSR,XKCL,XKCR,XKBL,XKBR,
     $XKT1,XKT2
      REAL XI1UL,XI1UR,XI1DL,XI1DR,XI1SL,XI1SR,XI1CL,XI1CR,
     $XI1BL,XI1BR,XI1T1,XI1T2,XIT1,XIT2
      REAL ALT1,ART1,ALT2,ART2,ALB1,ARB1,ALB2,ARB2
      REAL BETA,ASMB,MBMB,MBQ,ASMT,MTMT,MTQ,SUALFS,AMPL
      INTEGER IZ,ISZI(4)
      COMPLEX ZONE,ZI,ZAT1(2),ZAT2(2),ZADW1,ZADW2,ZAUW1,ZAUW2
      DOUBLE PRECISION SSALFS,SSMQCD
      SAVE ZONE,ZI
      DATA ZONE,ZI/(1.,0.),(0.,1.)/

C
C          Partly duplicated from SSMASS.
C
      AMPL=2.4E18
      PI=4.*ATAN(1.)
      SR2=SQRT(2.)
      G=SQRT(4*PI*ALFAEM/SN2THW)
      GP=G*SQRT(SN2THW/(1.-SN2THW))
      ALF3=SSALFS(DBLE(AMGLSS**2))
      GS=SQRT(4.*PI*ALF3)
      TANB=1./RV2V1
      BETA=ATAN(TANB)
      ASMB=SUALFS(AMBT**2,.36,AMTP,3)
      MBMB=AMBT*(1.-4*ASMB/3./PI)
      MBQ=SSMQCD(DBLE(MBMB),DBLE(AMGLSS))
      ASMT=SUALFS(AMTP**2,.36,AMTP,3)
      MTMT=AMTP/(1.+4*ASMT/3./PI+(16.11-1.04*(5.-6.63/AMTP))*
     $(ASMT/PI)**2)
      MTQ=SSMQCD(DBLE(MTMT),DBLE(AMGLSS))
      FB=G*MBQ/SR2/AMW/COS(BETA)
      FT=G*MTQ/SR2/AMW/SIN(BETA)
      MW1=ABS(AMW1SS)
      MW2=ABS(AMW2SS)
      SNW1=SIGN(1.,AMW1SS)
      SNW2=SIGN(1.,AMW2SS)
      XM=1./TAN(GAMMAL)
      YM=1./TAN(GAMMAR)
      THX=SIGN(1.,XM)
      THY=SIGN(1.,YM)
      COST=COS(THETAT)
      SINT=SIN(THETAT)
      COSB=COS(THETAB)
      SINB=SIN(THETAB)
C
      ZADW1=ZI*G*SNW1*SIN(GAMMAR)
      ZAUW1=ZI*G*SIN(GAMMAL)
      ZADW2=ZI*G*SNW2*COS(GAMMAR)*THY
      ZAUW2=ZI*G*COS(GAMMAL)*THX
      BW1=-FT*SNW1*COS(GAMMAR)
      BW2=FT*SNW2*SIN(GAMMAR)*THY
      ZAT1(1)=ZADW1*COST+ZI*BW1*SINT
      ZAT2(1)=ZADW1*SINT-ZI*BW1*COST
      ZAT1(2)=ZADW2*COST+ZI*BW2*SINT
      ZAT2(2)=ZADW2*SINT-ZI*BW2*COST
      C=SSALFS(DBLE(AMGLSS**2))*AMGLSS/8./PI**2
C
C          gluino --> w1 + qk + qb
C
C     Now includes sbottom as well as stop mixing/Yukawa effects
C     as of 3/31/97, thanks to M. Drees
      TMP(1)=MW1
      UPPR=(AMGLSS**2-MW1**2)/2./AMGLSS
      IF (AMGLSS.GT.(MW1+AMUP+AMDN)) THEN
        IF (AMGLSS.LT.AMULSS.AND.AMGLSS.LT.AMDLSS) THEN
          TMP(2)=AMULSS
          WIDU=ZADW1*CONJG(ZADW1)*SSXINT(0.,SSGWQ1,UPPR)
          TMP(2)=AMDLSS
          WIDD=ZAUW1*CONJG(ZAUW1)*SSXINT(0.,SSGWQ1,UPPR)
          WIDI=2*REAL(ZAUW1*ZADW1)*SSXINT(0.,SSGWQ2,UPPR)
          WID=GS**2/2./AMGLSS/(2*PI)**5*(WIDU+WIDD+WIDI)
        ELSE IF (AMGLSS.LT.AMULSS.AND.AMGLSS.GE.AMDLSS) THEN
          TMP(2)=AMULSS
          WIDU=ZADW1*CONJG(ZADW1)*SSXINT(0.,SSGWQ1,UPPR)
          WID=GS**2/2./AMGLSS/(2*PI)**5*WIDU
        ELSE IF (AMGLSS.LT.AMDLSS.AND.AMGLSS.GE.AMULSS) THEN
          TMP(2)=AMDLSS
          WIDD=ZAUW1*CONJG(ZAUW1)*SSXINT(0.,SSGWQ1,UPPR)
          WID=GS**2/2./AMGLSS/(2*PI)**5*WIDD
        ELSE
          WID=0.
        END IF
        CALL SSSAVE(ISGL,WID,+ISW1,-IDUP,+IDDN,0,0)
        CALL SSSAVE(ISGL,WID,-ISW1,+IDUP,-IDDN,0,0)
      END IF
C
      IF (AMGLSS.GT.(MW1+AMST+AMCH)) THEN
        IF (AMGLSS.LT.AMCLSS.AND.AMGLSS.LT.AMSLSS) THEN
          TMP(2)=AMCLSS
          WIDU=ZADW1*CONJG(ZADW1)*SSXINT(0.,SSGWQ1,UPPR)
          TMP(2)=AMSLSS
          WIDD=ZAUW1*CONJG(ZAUW1)*SSXINT(0.,SSGWQ1,UPPR)
          WIDI=2*REAL(ZAUW1*ZADW1)*SSXINT(0.,SSGWQ2,UPPR)
          WID=GS**2/2./AMGLSS/(2*PI)**5*(WIDU+WIDD+WIDI)
        ELSE IF (AMGLSS.LT.AMCLSS.AND.AMGLSS.GE.AMSLSS) THEN
          TMP(2)=AMCLSS
          WIDU=ZADW1*CONJG(ZADW1)*SSXINT(0.,SSGWQ1,UPPR)
          WID=GS**2/2./AMGLSS/(2*PI)**5*WIDU
        ELSE IF (AMGLSS.LT.AMSLSS.AND.AMGLSS.GE.AMCLSS) THEN
          TMP(2)=AMSLSS
          WIDD=ZAUW1*CONJG(ZAUW1)*SSXINT(0.,SSGWQ1,UPPR)
          WID=GS**2/2./AMGLSS/(2*PI)**5*WIDD
        ELSE
          WID=0.
        END IF
        CALL SSSAVE(ISGL,WID,+ISW1,-IDCH,+IDST,0,0)
        CALL SSSAVE(ISGL,WID,-ISW1,+IDCH,-IDST,0,0)
      END IF
C
      IF (AMGLSS.GT.(MW1+AMTP+AMBT)) THEN
        ALT1=-G*SIN(GAMMAR)*COST+FT*COS(GAMMAR)*SINT
        ART1=-FB*COS(GAMMAL)*COST
        ALT2=-G*SIN(GAMMAR)*SINT-FT*COS(GAMMAR)*COST
        ART2=-FB*COS(GAMMAL)*SINT
        ALB1=-G*SIN(GAMMAL)*COSB+FB*COS(GAMMAL)*SINB
        ARB1=-FT*COS(GAMMAR)*COSB
        ALB2=-G*SIN(GAMMAL)*SINB-FB*COS(GAMMAL)*COSB
        ARB2=-FT*COS(GAMMAR)*SINB
        UPPER=(AMGLSS**2+AMTP**2-(MW1+AMBT)**2)/2./AMGLSS
        FACT=GS**2*PI**2/(2*PI)**5/2./AMGLSS
        TMP(1)=MW1
        TMP(2)=AMGLSS
        TMP(3)=AMTP
        IF (AMGLSS.LT.(AMTP+AMT1SS)) THEN
          TMP(6)=AMT1SS
          TMP(7)=AMT1SS
          GT1=(ALT1**2+ART1**2)*(SSXINT(AMTP,SSGWT1,UPPER)+
     ,        SIN(2*THETAT)*SSXINT(AMTP,SSGWT8,UPPER))
          TMP(7)=AMT2SS
          GT1T2=2*(ALT1*ALT2+ART1*ART2)*(SINT**2-COST**2)*
     ,          SSXINT(AMTP,SSGWT8,UPPER)
        ELSE
          GT1=0.
          GT1T2=0.
        END IF
        IF (AMGLSS.LT.(AMTP+AMT2SS)) THEN
          TMP(6)=AMT2SS
          TMP(7)=AMT2SS
          GT2=(ALT2**2+ART2**2)*(SSXINT(AMTP,SSGWT1,UPPER)-
     ,        SIN(2*THETAT)*SSXINT(AMTP,SSGWT8,UPPER))
        ELSE
          GT2=0.
        END IF
        IF (AMGLSS.LT.(AMB1SS+AMBT)) THEN
          TMP(4)=AMB1SS
          TMP(8)=SNW1
C          Rewrite UPPR=(AMGLSS**2+AMBT**2-(AMTP+MW1)**2)/2./AMGLSS
          UPPR=((AMGLSS-AMTP-MW1)*(AMGLSS+AMTP+MW1)+AMBT**2)/(2*AMGLSS)
          GB1=(ALB1**2+ARB1**2)*SSXINT(AMBT,SSGWT2,UPPR)-
     ,        ALB1*ARB1*SSXINT(AMBT,SSGWT3,UPPR)
        ELSE
          GB1=0.
        END IF
        IF (AMGLSS.LT.(AMB2SS+AMBT)) THEN
          TMP(4)=AMB2SS
          TMP(8)=SNW1
C          Rewrite UPPR=(AMGLSS**2+AMBT**2-(AMTP+MW1)**2)/2./AMGLSS
          UPPR=((AMGLSS-AMTP-MW1)*(AMGLSS+AMTP+MW1)+AMBT**2)/(2*AMGLSS)
          GB2=(ALB2**2+ARB2**2)*SSXINT(AMBT,SSGWT2,UPPR)-
     ,        ALB2*ARB2*SSXINT(AMBT,SSGWT3,UPPR)
        ELSE
          GB2=0.
        END IF
        IF (AMGLSS.LT.(AMTP+AMT1SS).AND.AMGLSS.LT.
     $    (AMB1SS+AMBT)) THEN
          TMP(4)=AMB1SS
          TMP(6)=AMT1SS
          TMP(8)=SNW1
          GT1B1=(COST*SINB*ART1*ALB1+SINT*COSB*ALT1*ARB1)*
     ,           SSXINT(AMTP,SSGWT6,UPPER)-
     ,          (COST*COSB*ALT1*ALB1+SINT*SINB*ART1*ARB1)*
     ,           SSXINT(AMTP,SSGWT4,UPPER)+
     ,          (COST*COSB*ALT1*ARB1+SINT*SINB*ART1*ALB1)*
     ,           SSXINT(AMTP,SSGWT5,UPPER)-
     ,          (COST*SINB*ART1*ARB1+SINT*COSB*ALT1*ALB1)*
     ,           SSXINT(AMTP,SSGWT7,UPPER)
        ELSE
          GT1B1=0.
        END IF
        IF (AMGLSS.LT.(AMTP+AMT1SS).AND.AMGLSS.LT.
     $    (AMB2SS+AMBT)) THEN
          TMP(4)=AMB2SS
          TMP(6)=AMT1SS
          TMP(8)=SNW1
          GT1B2=(-COST*COSB*ART1*ALB2+SINT*SINB*ALT1*ARB2)*
     ,           SSXINT(AMTP,SSGWT6,UPPER)-
     ,          (COST*COSB*ALT1*ALB2-SINT*COSB*ART1*ARB2)*
     ,           SSXINT(AMTP,SSGWT4,UPPER)+
     ,          (COST*SINB*ALT1*ARB2-SINT*COSB*ART1*ALB2)*
     ,           SSXINT(AMTP,SSGWT5,UPPER)-
     ,          (-COST*COSB*ART1*ARB2+SINT*SINB*ALT1*ALB2)*
     ,           SSXINT(AMTP,SSGWT7,UPPER)
        ELSE
          GT1B2=0.
        END IF
        IF (AMGLSS.LT.(AMTP+AMT2SS).AND.AMGLSS.LT.
     $    (AMB1SS+AMBT)) THEN
          TMP(4)=AMB1SS
          TMP(6)=AMT2SS
          TMP(8)=SNW1
          GT2B1=(SINT*SINB*ART2*ALB1-COST*COSB*ALT2*ARB1)*
     ,           SSXINT(AMTP,SSGWT6,UPPER)-
     ,          (SINT*COSB*ALT2*ALB1-COST*SINB*ART2*ARB1)*
     ,           SSXINT(AMTP,SSGWT4,UPPER)+
     ,          (SINT*COSB*ALT2*ARB1-COST*SINB*ART2*ALB1)*
     ,           SSXINT(AMTP,SSGWT5,UPPER)-
     ,          (SINT*SINB*ART2*ARB1-COST*COSB*ALT2*ALB1)*
     ,           SSXINT(AMTP,SSGWT7,UPPER)
        ELSE
          GT2B1=0.
        END IF
        IF (AMGLSS.LT.(AMTP+AMT2SS).AND.AMGLSS.LT.
     $    (AMB2SS+AMBT)) THEN
          TMP(4)=AMB2SS
          TMP(6)=AMT2SS
          TMP(8)=SNW1
          GT2B2=(-SINT*COSB*ART2*ALB2-COST*SINB*ALT2*ARB2)*
     ,           SSXINT(AMTP,SSGWT6,UPPER)-
     ,          (SINT*SINB*ALT2*ALB2+COST*COSB*ART2*ARB2)*
     ,           SSXINT(AMTP,SSGWT4,UPPER)+
     ,          (SINT*SINB*ALT2*ARB2+COST*COSB*ART2*ALB2)*
     ,           SSXINT(AMTP,SSGWT5,UPPER)-
     ,          (-SINT*COSB*ART2*ARB2-COST*SINB*ALT2*ALB2)*
     ,           SSXINT(AMTP,SSGWT7,UPPER)
        ELSE
          GT2B2=0.
        END IF
        WID=GT1+GT2+GT1T2+GB1+GB2+GT1B1+GT1B2+GT2B1+GT2B2
        WID=FACT*WID
        IF (WID.GT.0.) THEN
        CALL SSSAVE(ISGL,WID,+ISW1,-IDTP,+IDBT,0,0)
        CALL SSSAVE(ISGL,WID,-ISW1,+IDTP,-IDBT,0,0)
        END IF
      END IF
C
C          gluino --> w2 + qk + qb
C
      TMP(1)=MW2
      UPPR=(AMGLSS**2-MW2**2)/2./AMGLSS
      IF (AMGLSS.GT.(MW2+AMUP+AMDN)) THEN
        IF (AMGLSS.LT.AMULSS.AND.AMGLSS.LT.AMDLSS) THEN
          TMP(2)=AMULSS
          WIDU=ZADW2*CONJG(ZADW2)*SSXINT(0.,SSGWQ1,UPPR)
          TMP(2)=AMDLSS
          WIDD=ZAUW2*CONJG(ZAUW2)*SSXINT(0.,SSGWQ1,UPPR)
          WIDI=2*REAL(ZAUW2*ZADW2)*SSXINT(0.,SSGWQ2,UPPR)
          WID=GS**2/2./AMGLSS/(2*PI)**5*(WIDU+WIDD+WIDI)
        ELSE IF (AMGLSS.LT.AMULSS.AND.AMGLSS.GE.AMDLSS) THEN
          TMP(2)=AMULSS
          WIDU=ZADW2*CONJG(ZADW2)*SSXINT(0.,SSGWQ1,UPPR)
          WID=GS**2/2./AMGLSS/(2*PI)**5*WIDU
        ELSE IF (AMGLSS.LT.AMDLSS.AND.AMGLSS.GE.AMULSS) THEN
          TMP(2)=AMDLSS
          WIDD=ZAUW2*CONJG(ZAUW2)*SSXINT(0.,SSGWQ1,UPPR)
          WID=GS**2/2./AMGLSS/(2*PI)**5*WIDD
        ELSE
          WID=0.
        END IF
        CALL SSSAVE(ISGL,WID,+ISW2,-IDUP,+IDDN,0,0)
        CALL SSSAVE(ISGL,WID,-ISW2,+IDUP,-IDDN,0,0)
      END IF
C
      IF (AMGLSS.GT.(MW2+AMST+AMCH)) THEN
        IF (AMGLSS.LT.AMCLSS.AND.AMGLSS.LT.AMSLSS) THEN
          TMP(2)=AMCLSS
          WIDU=ZADW2*CONJG(ZADW2)*SSXINT(0.,SSGWQ1,UPPR)
          TMP(2)=AMSLSS
          WIDD=ZAUW2*CONJG(ZAUW2)*SSXINT(0.,SSGWQ1,UPPR)
          WIDI=2*REAL(ZAUW2*ZADW2)*SSXINT(0.,SSGWQ2,UPPR)
          WID=GS**2/2./AMGLSS/(2*PI)**5*(WIDU+WIDD+WIDI)
        ELSE IF (AMGLSS.LT.AMCLSS.AND.AMGLSS.GE.AMSLSS) THEN
          TMP(2)=AMCLSS
          WIDU=ZADW2*CONJG(ZADW2)*SSXINT(0.,SSGWQ1,UPPR)
          WID=GS**2/2./AMGLSS/(2*PI)**5*WIDU
        ELSE IF (AMGLSS.LT.AMSLSS.AND.AMGLSS.GE.AMCLSS) THEN
          TMP(2)=AMSLSS
          WIDD=ZAUW2*CONJG(ZAUW2)*SSXINT(0.,SSGWQ1,UPPR)
          WID=GS**2/2./AMGLSS/(2*PI)**5*WIDD
        ELSE
          WID=0.
        END IF
        CALL SSSAVE(ISGL,WID,+ISW2,-IDCH,+IDST,0,0)
        CALL SSSAVE(ISGL,WID,-ISW2,+IDCH,-IDST,0,0)
      END IF
C
      IF (AMGLSS.GT.(MW2+AMTP+AMBT)) THEN
        ALT1=-G*THY*COS(GAMMAR)*COST-FT*THY*SIN(GAMMAR)*SINT
        ART1=FB*THX*SIN(GAMMAL)*COST
        ALT2=-G*THY*COS(GAMMAR)*SINT+FT*THY*SIN(GAMMAR)*COST
        ART2=FB*THX*SIN(GAMMAL)*SINT
        ALB1=-G*THX*COS(GAMMAL)*COSB-FB*THX*SIN(GAMMAL)*SINB
        ARB1=FT*THY*SIN(GAMMAR)*COSB
        ALB2=-G*THX*COS(GAMMAL)*SINB+FB*THX*SIN(GAMMAL)*COSB
        ARB2=FT*THY*SIN(GAMMAR)*SINB
        UPPER=(AMGLSS**2+AMTP**2-(MW2+AMBT)**2)/2./AMGLSS
        FACT=GS**2*PI**2/(2*PI)**5/2./AMGLSS
        TMP(1)=MW2
        TMP(2)=AMGLSS
        TMP(3)=AMTP
        IF (AMGLSS.LT.(AMTP+AMT1SS)) THEN
          TMP(6)=AMT1SS
          TMP(7)=AMT1SS
          GT1=(ALT1**2+ART1**2)*(SSXINT(AMTP,SSGWT1,UPPER)+
     ,        SIN(2*THETAT)*SSXINT(AMTP,SSGWT8,UPPER))
          TMP(7)=AMT2SS
          GT1T2=2*(ALT1*ALT2+ART1*ART2)*(SINT**2-COST**2)*
     ,          SSXINT(AMTP,SSGWT8,UPPER)
        ELSE
          GT1=0.
          GT1T2=0.
        END IF
        IF (AMGLSS.LT.(AMTP+AMT2SS)) THEN
          TMP(6)=AMT2SS
          TMP(7)=AMT2SS
          GT2=(ALT2**2+ART2**2)*(SSXINT(AMTP,SSGWT1,UPPER)-
     ,        SIN(2*THETAT)*SSXINT(AMTP,SSGWT8,UPPER))
        ELSE
          GT2=0.
        END IF
        IF (AMGLSS.LT.(AMB1SS+AMBT)) THEN
          TMP(4)=AMB1SS
          TMP(8)=SNW2
C          Rewrite UPPR=(AMGLSS**2+AMBT**2-(AMTP+MW2)**2)/2./AMGLSS
          UPPR=((AMGLSS-AMTP-MW2)*(AMGLSS+AMTP+MW2)+AMBT**2)/(2*AMGLSS)
          GB1=(ALB1**2+ARB1**2)*SSXINT(AMBT,SSGWT2,UPPR)-
     ,        ALB1*ARB1*SSXINT(AMBT,SSGWT3,UPPR)
        ELSE
          GB1=0.
        END IF
        IF (AMGLSS.LT.(AMB2SS+AMBT)) THEN
          TMP(4)=AMB2SS
          TMP(8)=SNW2
          UPPR=((AMGLSS-AMTP-MW2)*(AMGLSS+AMTP+MW2)+AMBT**2)/(2*AMGLSS)
          GB2=(ALB2**2+ARB2**2)*SSXINT(AMBT,SSGWT2,UPPR)-
     ,        ALB2*ARB2*SSXINT(AMBT,SSGWT3,UPPR)
        ELSE
          GB2=0.
        END IF
        IF (AMGLSS.LT.(AMTP+AMT1SS).AND.AMGLSS.LT.
     $    (AMB1SS+AMBT)) THEN
          TMP(4)=AMB1SS
          TMP(6)=AMT1SS
          TMP(8)=SNW2
          GT1B1=(COST*SINB*ART1*ALB1+SINT*COSB*ALT1*ARB1)*
     ,           SSXINT(AMTP,SSGWT6,UPPER)-
     ,          (COST*COSB*ALT1*ALB1+SINT*SINB*ART1*ARB1)*
     ,           SSXINT(AMTP,SSGWT4,UPPER)+
     ,          (COST*COSB*ALT1*ARB1+SINT*SINB*ART1*ALB1)*
     ,           SSXINT(AMTP,SSGWT5,UPPER)-
     ,          (COST*SINB*ART1*ARB1+SINT*COSB*ALT1*ALB1)*
     ,           SSXINT(AMTP,SSGWT7,UPPER)
        ELSE
          GT1B1=0.
        END IF
        IF (AMGLSS.LT.(AMTP+AMT1SS).AND.AMGLSS.LT.
     $    (AMB2SS+AMBT)) THEN
          TMP(4)=AMB2SS
          TMP(6)=AMT1SS
          TMP(8)=SNW2
          GT1B2=(-COST*COSB*ART1*ALB2+SINT*SINB*ALT1*ARB2)*
     ,           SSXINT(AMTP,SSGWT6,UPPER)-
     ,          (COST*COSB*ALT1*ALB2-SINT*COSB*ART1*ARB2)*
     ,           SSXINT(AMTP,SSGWT4,UPPER)+
     ,          (COST*SINB*ALT1*ARB2-SINT*COSB*ART1*ALB2)*
     ,           SSXINT(AMTP,SSGWT5,UPPER)-
     ,          (-COST*COSB*ART1*ARB2+SINT*SINB*ALT1*ALB2)*
     ,           SSXINT(AMTP,SSGWT7,UPPER)
        ELSE
          GT1B2=0.
        END IF
        IF (AMGLSS.LT.(AMTP+AMT2SS).AND.AMGLSS.LT.
     $    (AMB1SS+AMBT)) THEN
          TMP(4)=AMB1SS
          TMP(6)=AMT2SS
          TMP(8)=SNW2
          GT2B1=(SINT*SINB*ART2*ALB1-COST*COSB*ALT2*ARB1)*
     ,           SSXINT(AMTP,SSGWT6,UPPER)-
     ,          (SINT*COSB*ALT2*ALB1-COST*SINB*ART2*ARB1)*
     ,           SSXINT(AMTP,SSGWT4,UPPER)+
     ,          (SINT*COSB*ALT2*ARB1-COST*SINB*ART2*ALB1)*
     ,           SSXINT(AMTP,SSGWT5,UPPER)-
     ,          (SINT*SINB*ART2*ARB1-COST*COSB*ALT2*ALB1)*
     ,           SSXINT(AMTP,SSGWT7,UPPER)
        ELSE
          GT2B1=0.
        END IF
        IF (AMGLSS.LT.(AMTP+AMT2SS).AND.AMGLSS.LT.
     $    (AMB2SS+AMBT)) THEN
          TMP(4)=AMB2SS
          TMP(6)=AMT2SS
          TMP(8)=SNW2
          GT2B2=(-SINT*COSB*ART2*ALB2-COST*SINB*ALT2*ARB2)*
     ,           SSXINT(AMTP,SSGWT6,UPPER)-
     ,          (SINT*SINB*ALT2*ALB2+COST*COSB*ART2*ARB2)*
     ,           SSXINT(AMTP,SSGWT4,UPPER)+
     ,          (SINT*SINB*ALT2*ARB2+COST*COSB*ART2*ALB2)*
     ,           SSXINT(AMTP,SSGWT5,UPPER)-
     ,          (-SINT*COSB*ART2*ARB2-COST*SINB*ALT2*ALB2)*
     ,           SSXINT(AMTP,SSGWT7,UPPER)
        ELSE
          GT2B2=0.
        END IF
        WID=GT1+GT2+GT1T2+GB1+GB2+GT1B1+GT1B2+GT2B1+GT2B2
        WID=FACT*WID
        IF (WID.GT.0.) THEN
        CALL SSSAVE(ISGL,WID,+ISW2,-IDTP,+IDBT,0,0)
        CALL SSSAVE(ISGL,WID,-ISW2,+IDTP,-IDBT,0,0)
        END IF
      END IF
C
C       gluino --> zi decays, zi = z1, z2, z3, z4
C       the auiz etc, below are Atilde's etc. of PRD 42,1568 (1990)
C
      ISZI(1)=ISZ1
      ISZI(2)=ISZ2
      ISZI(3)=ISZ3
      ISZI(4)=ISZ4
      DO 100 IZ=1,4
        MZIZ=ABS(AMZISS(IZ))
        AUIZ=G/SR2*ZMIXSS(3,IZ)+GP/3./SR2*ZMIXSS(4,IZ)
        ADIZ=-G/SR2*ZMIXSS(3,IZ)+GP/3./SR2*ZMIXSS(4,IZ)
        BUIZ=4*GP*ZMIXSS(4,IZ)/3./SR2
        BDIZ=-2*GP/3./SR2*ZMIXSS(4,IZ)
        SNZIZ=SIGN(1.,AMZISS(IZ))
C          Radiative gluino --> gluon + zi loop decay
        IF (AMGLSS.GT.MZIZ) THEN
          IF (AMGLSS.LT.(AMT1SS+AMTP)) THEN
            TMP(1)=AMTP
            TMP(2)=MZIZ
            TMP(3)=AMT1SS
            XIT1=SSXINT(0.,SSGZG1,1.)
            XI1T1=SSXINT(0.,SSGZG2,1.)
            XKT1=SSXINT(0.,SSGZG3,1.)
          ELSE
            XIT1=0.
            XI1T1=0.
            XKT1=0.
          END IF
          IF (AMGLSS.LT.(AMT2SS+AMTP)) THEN
            TMP(1)=AMTP
            TMP(2)=MZIZ
            TMP(3)=AMT2SS
            XIT2=SSXINT(0.,SSGZG1,1.)
            XI1T2=SSXINT(0.,SSGZG2,1.)
            XKT2=SSXINT(0.,SSGZG3,1.)
          ELSE
            XIT2=0.
            XI1T2=0.
            XKT2=0.
          END IF
C         !!! NEEDS UPDATE FOR SBOTTOM MIXING !!!
          IF (AMGLSS.LT.(AMB1SS+AMBT)) THEN
            TMP(1)=AMBT
            TMP(2)=MZIZ
            TMP(3)=AMB1SS
            XI1BL=SSXINT(0.,SSGZG2,1.)
            XKBL=SSXINT(0.,SSGZG3,1.)
          ELSE
            XI1BL=0.
            XKBL=0.
          END IF
          IF (AMGLSS.LT.(AMB2SS+AMBT)) THEN
            TMP(1)=AMBT
            TMP(2)=MZIZ
            TMP(3)=AMB2SS
            XI1BR=SSXINT(0.,SSGZG2,1.)
            XKBR=SSXINT(0.,SSGZG3,1.)
          ELSE
            XI1BR=0.
            XKBR=0.
          END IF
          IF (AMGLSS.LT.(AMULSS+AMUP)) THEN
            TMP(1)=AMUP
            TMP(2)=MZIZ
            TMP(3)=AMULSS
            XI1UL=SSXINT(0.,SSGZG2,1.)
            XKUL=SSXINT(0.,SSGZG3,1.)
          ELSE
            XI1UL=0.
            XKUL=0.
          END IF
          IF (AMGLSS.LT.(AMURSS+AMUP)) THEN
            TMP(1)=AMUP
            TMP(2)=MZIZ
            TMP(3)=AMURSS
            XI1UR=SSXINT(0.,SSGZG2,1.)
            XKUR=SSXINT(0.,SSGZG3,1.)
          ELSE
            XI1UR=0.
            XKUR=0.
          END IF
          IF (AMGLSS.LT.(AMDLSS+AMDN)) THEN
            TMP(1)=AMDN
            TMP(2)=MZIZ
            TMP(3)=AMDLSS
            XI1DL=SSXINT(0.,SSGZG2,1.)
            XKDL=SSXINT(0.,SSGZG3,1.)
          ELSE
            XI1DL=0.
            XKDL=0.
          END IF
          IF (AMGLSS.LT.(AMDRSS+AMDN)) THEN
            TMP(1)=AMDN
            TMP(2)=MZIZ
            TMP(3)=AMDRSS
            XI1DR=SSXINT(0.,SSGZG2,1.)
            XKDR=SSXINT(0.,SSGZG3,1.)
          ELSE
            XI1DR=0.
            XKDR=0.
          END IF
          IF (AMGLSS.LT.(AMSLSS+AMST)) THEN
            TMP(1)=AMST
            TMP(2)=MZIZ
            TMP(3)=AMSLSS
            XI1SL=SSXINT(0.,SSGZG2,1.)
            XKSL=SSXINT(0.,SSGZG3,1.)
          ELSE
            XI1SL=0.
            XKSL=0.
          END IF
          IF (AMGLSS.LT.(AMSRSS+AMST)) THEN
            TMP(1)=AMST
            TMP(2)=MZIZ
            TMP(3)=AMSRSS
            XI1SR=SSXINT(0.,SSGZG2,1.)
            XKSR=SSXINT(0.,SSGZG3,1.)
          ELSE
            XI1SR=0.
            XKSR=0.
          END IF
          IF (AMGLSS.LT.(AMCLSS+AMCH)) THEN
            TMP(1)=AMCH
            TMP(2)=MZIZ
            TMP(3)=AMCLSS
            XI1CL=SSXINT(0.,SSGZG2,1.)
            XKCL=SSXINT(0.,SSGZG3,1.)
          ELSE
            XI1CL=0.
            XKCL=0.
          END IF
          IF (AMGLSS.LT.(AMCRSS+AMCH)) THEN
            TMP(1)=AMCH
            TMP(2)=MZIZ
            TMP(3)=AMCRSS
            XI1CR=SSXINT(0.,SSGZG2,1.)
            XKCR=SSXINT(0.,SSGZG3,1.)
          ELSE
            XI1CR=0.
            XKCR=0.
          END IF
          KUL=AUIZ*(XKUL*(MZIZ-SNZIZ*AMGLSS)+MZIZ*XI1UL)
          KUR=-BUIZ*(XKUR*(MZIZ-SNZIZ*AMGLSS)+MZIZ*XI1UR)
          KDL=ADIZ*(XKDL*(MZIZ-SNZIZ*AMGLSS)+MZIZ*XI1DL)
          KDR=-BDIZ*(XKDR*(MZIZ-SNZIZ*AMGLSS)+MZIZ*XI1DR)
          KCL=AUIZ*(XKCL*(MZIZ-SNZIZ*AMGLSS)+MZIZ*XI1CL)
          KCR=-BUIZ*(XKCR*(MZIZ-SNZIZ*AMGLSS)+MZIZ*XI1CR)
          KSL=ADIZ*(XKSL*(MZIZ-SNZIZ*AMGLSS)+MZIZ*XI1SL)
          KSR=-BDIZ*(XKSR*(MZIZ-SNZIZ*AMGLSS)+MZIZ*XI1SR)
          KBL=ADIZ*(XKBL*(MZIZ-SNZIZ*AMGLSS)+MZIZ*XI1BL)
          KBR=-BDIZ*(XKBR*(MZIZ-SNZIZ*AMGLSS)+MZIZ*XI1BR)
          KT1=(MZIZ*(XKT1+XI1T1)*(AUIZ*COST-FT*ZMIXSS(1,IZ)*SINT)
     $      -SNZIZ*AMGLSS*XKT1*(AUIZ*COST-FT*ZMIXSS(1,IZ)*SINT)+
     $      SNZIZ*AMTP*XIT1*(BUIZ*SINT+FT*ZMIXSS(1,IZ)*COST))*COST+
     $      (MZIZ*(XKT1+XI1T1)*(-BUIZ*SINT-FT*ZMIXSS(1,IZ)*COST)
     $      -SNZIZ*AMGLSS*XKT1*(-BUIZ*SINT-FT*ZMIXSS(1,IZ)*COST)-
     $      SNZIZ*AMTP*XIT1*(AUIZ*COST-FT*ZMIXSS(1,IZ)*SINT))*SINT
          KT2=(MZIZ*(XKT2+XI1T2)*(AUIZ*SINT+FT*ZMIXSS(1,IZ)*COST)
     $      -SNZIZ*AMGLSS*XKT2*(AUIZ*SINT+FT*ZMIXSS(1,IZ)*COST)+
     $      SNZIZ*AMTP*XIT2*(-BUIZ*COST+FT*ZMIXSS(1,IZ)*SINT))*SINT+
     $      (-MZIZ*(XKT2+XI1T2)*(BUIZ*COST-FT*ZMIXSS(1,IZ)*SINT)
     $      +SNZIZ*AMGLSS*XKT2*(BUIZ*COST-FT*ZMIXSS(1,IZ)*SINT)+
     $      SNZIZ*AMTP*XIT2*(AUIZ*SINT+FT*ZMIXSS(1,IZ)*COST))*COST
          SUM=(KUL+KUR+KDL+KDR+KSL+KSR+KCL+KCR+KBL+KBR+KT1+
     $         KT2)**2/AMGLSS**2
          WID=ALF3**2*AMGLSS*(1.-MZIZ**2/AMGLSS**2)/256./PI**3*SUM
          CALL SSSAVE(ISGL,WID,ISZI(IZ),IDGL,0,0,0)
        END IF
C          3 body gluino --> q + qb + zi decay, q=u,d
        UPPR=(AMGLSS**2-MZIZ**2)/2./AMGLSS
        IF (AMGLSS.GT.(MZIZ+2*AMUP)) THEN
          IF (AMGLSS.LT.AMULSS.AND.AMGLSS.LT.AMURSS) THEN
            TMP(1)=MZIZ
            TMP(2)=AMULSS
            WIDL=2*AUIZ**2*(SSXINT(0.,SSGWQ1,UPPR)-SNZIZ*
     $          SSXINT(0.,SSGWQ2,UPPR))
            TMP(2)=AMURSS
            WIDR=2*BUIZ**2*(SSXINT(0.,SSGWQ1,UPPR)-SNZIZ*
     $          SSXINT(0.,SSGWQ2,UPPR))
            WID=WIDL+WIDR
          ELSE IF (AMGLSS.LT.AMULSS.AND.AMGLSS.GE.AMURSS) THEN
            TMP(2)=AMULSS
            WID=2*AUIZ**2*(SSXINT(0.,SSGWQ1,UPPR)-SNZIZ*
     $          SSXINT(0.,SSGWQ2,UPPR))
          ELSE IF (AMGLSS.LT.AMURSS.AND.AMGLSS.GE.AMULSS) THEN
            TMP(2)=AMURSS
            WID=2*BUIZ**2*(SSXINT(0.,SSGWQ1,UPPR)-SNZIZ*
     $          SSXINT(0.,SSGWQ2,UPPR))
          ELSE
            WID=0.
          END IF
          WID=GS**2/AMGLSS/2./(2*PI)**5*WID
          CALL SSSAVE(ISGL,WID,ISZI(IZ),IDUP,-IDUP,0,0)
        END IF
C
        IF (AMGLSS.GT.(MZIZ+2*AMDN)) THEN
          IF (AMGLSS.LT.AMDLSS.AND.AMGLSS.LT.AMDRSS) THEN
            TMP(1)=MZIZ
            TMP(2)=AMDLSS
            WIDL=2*ADIZ**2*(SSXINT(0.,SSGWQ1,UPPR)-SNZIZ*
     $          SSXINT(0.,SSGWQ2,UPPR))
            TMP(2)=AMDRSS
            WIDR=2*BDIZ**2*(SSXINT(0.,SSGWQ1,UPPR)-SNZIZ*
     $          SSXINT(0.,SSGWQ2,UPPR))
            WID=WIDL+WIDR
          ELSE IF (AMGLSS.LT.AMDLSS.AND.AMGLSS.GE.AMDRSS) THEN
            TMP(2)=AMDLSS
            WID=2*ADIZ**2*(SSXINT(0.,SSGWQ1,UPPR)-SNZIZ*
     $          SSXINT(0.,SSGWQ2,UPPR))
          ELSE IF (AMGLSS.LT.AMDRSS.AND.AMGLSS.GE.AMDLSS) THEN
            TMP(2)=AMDRSS
            WID=2*BDIZ**2*(SSXINT(0.,SSGWQ1,UPPR)-SNZIZ*
     $          SSXINT(0.,SSGWQ2,UPPR))
          ELSE
            WID=0.
          END IF
          WID=GS**2/AMGLSS/2./(2*PI)**5*WID
          CALL SSSAVE(ISGL,WID,ISZI(IZ),IDDN,-IDDN,0,0)
        END IF
C          3 body gluino --> q + qb + zi decay, q=s
        IF (AMGLSS.GT.(MZIZ+2*AMST)) THEN
          IF (AMGLSS.LT.AMSLSS.AND.AMGLSS.LT.AMSRSS) THEN
            TMP(1)=MZIZ
            TMP(2)=AMSLSS
            WIDL=2*ADIZ**2*(SSXINT(0.,SSGWQ1,UPPR)-SNZIZ*
     $          SSXINT(0.,SSGWQ2,UPPR))
            TMP(2)=AMSRSS
            WIDR=2*BDIZ**2*(SSXINT(0.,SSGWQ1,UPPR)-SNZIZ*
     $          SSXINT(0.,SSGWQ2,UPPR))
            WID=WIDL+WIDR
          ELSE IF (AMGLSS.LT.AMSLSS.AND.AMGLSS.GE.AMSRSS) THEN
            TMP(2)=AMSLSS
            WID=2*ADIZ**2*(SSXINT(0.,SSGWQ1,UPPR)-SNZIZ*
     $          SSXINT(0.,SSGWQ2,UPPR))
          ELSE IF (AMGLSS.LT.AMSRSS.AND.AMGLSS.GE.AMSLSS) THEN
            TMP(2)=AMSRSS
            WID=2*BDIZ**2*(SSXINT(0.,SSGWQ1,UPPR)-SNZIZ*
     $          SSXINT(0.,SSGWQ2,UPPR))
          ELSE
            WID=0.
          END IF
          WID=GS**2/AMGLSS/2./(2*PI)**5*WID
          CALL SSSAVE(ISGL,WID,ISZI(IZ),IDST,-IDST,0,0)
        END IF
C          3 body gluino --> q + qb + zi decay, q=c
        IF (AMGLSS.GT.(MZIZ+2*AMCH)) THEN
          IF (AMGLSS.LT.AMCLSS.AND.AMGLSS.LT.AMCRSS) THEN
            TMP(1)=MZIZ
            TMP(2)=AMCLSS
            WIDL=2*AUIZ**2*(SSXINT(0.,SSGWQ1,UPPR)-SNZIZ*
     $          SSXINT(0.,SSGWQ2,UPPR))
            TMP(2)=AMCRSS
            WIDR=2*BUIZ**2*(SSXINT(0.,SSGWQ1,UPPR)-SNZIZ*
     $          SSXINT(0.,SSGWQ2,UPPR))
            WID=WIDL+WIDR
          ELSE IF (AMGLSS.LT.AMCLSS.AND.AMGLSS.GE.AMCRSS) THEN
            TMP(2)=AMCLSS
            WID=2*AUIZ**2*(SSXINT(0.,SSGWQ1,UPPR)-SNZIZ*
     $          SSXINT(0.,SSGWQ2,UPPR))
          ELSE IF (AMGLSS.LT.AMCRSS.AND.AMGLSS.GE.AMCLSS) THEN
            TMP(2)=AMCRSS
            WID=2*BUIZ**2*(SSXINT(0.,SSGWQ1,UPPR)-SNZIZ*
     $          SSXINT(0.,SSGWQ2,UPPR))
          ELSE
            WID=0.
          END IF
          WID=GS**2/AMGLSS/2./(2*PI)**5*WID
          CALL SSSAVE(ISGL,WID,ISZI(IZ),IDCH,-IDCH,0,0)
        END IF
C          3 body gluino --> q + qb + zi decay, q=b
        XTCON=ALF3/8./PI**4/AMGLSS
        IF (AMGLSS.GT.(MZIZ+2*AMBT).AND.AMGLSS.LT.
     $     (AMB1SS+AMBT)) THEN
          TMP(1)=AMGLSS
          TMP(2)=AMBT
          TMP(3)=MZIZ
          TMP(4)=AMB1SS
          TMP(5)=AMB1SS
          XUPPER=(AMGLSS**2+AMBT**2-(AMBT+MZIZ)**2)/2./AMGLSS
          XT1=SSXINT(AMBT,SSGX1,XUPPER)
          XT2=SSXINT(AMBT,SSGX2,XUPPER)
          XT3=SSXINT(AMBT,SSGX3,XUPPER)
          XT4=SSXINT(AMBT,SSGX4,XUPPER)
          XT5=SSXINT(AMBT,SSGX5,XUPPER)
          XT6=SSXINT(AMBT,SSGX6,XUPPER)
          XT7=SSXINT(AMBT,SSGX7,XUPPER)
          XT8=SSXINT(AMBT,SSGX8,XUPPER)
          XT9=SSXINT(AMBT,SSGX9,XUPPER)
          AL1=ADIZ*COSB-FB*ZMIXSS(2,IZ)*SINB
          BE1=FB*ZMIXSS(2,IZ)*COSB+BDIZ*SINB
C         ---- here, al2 is (-) al2 of tata notes-----
          AL2=BDIZ*SINB+FB*ZMIXSS(2,IZ)*COSB
          BE2=-FB*ZMIXSS(2,IZ)*SINB+ADIZ*COSB
          XLL=(AL1**2+BE1**2)*XT1-4*AMBT*MZIZ*SNZIZ*AL1*
     $     BE1*XT3-AMGLSS*(SNZIZ*MZIZ*(AL1**2*XT2/AMGLSS/
     $     MZIZ+BE1**2*AMBT**2*XT5)-AL1*BE1*AMBT*(XT4-
     $     MZIZ**2*XT5))
          XRR=(AL2**2+BE2**2)*XT1-4*AMBT*MZIZ*SNZIZ*AL2*
     $     BE2*XT3-AMGLSS*(SNZIZ*MZIZ*(AL2**2*XT2/AMGLSS/
     $     MZIZ+BE2**2*AMBT**2*XT5)-AL2*BE2*AMBT*(XT4-
     $     MZIZ**2*XT5))
          XL1R1=-2*AMGLSS*AMBT*((AL1*AL2+BE1*BE2)*SNZIZ*AMBT*
     $     MZIZ*XT6-(AL2*BE1+AL1*BE2)*XT7)
          XL2R2=XL1R1
          XL1R2=BE1*BE2*XT8+AL1*AL2*AMBT**2*XT4-AMBT*MZIZ*
     $     SNZIZ*(AL1*BE2+AL2*BE1)*XT9
          XL2R1=XL1R2
          XMSB1=COSB**2*XLL+SINB**2*XRR-SINB*COSB*(XL1R1+XL1R2+
     $     XL2R1+XL2R2)
        ELSE
          XMSB1=0.
        END IF
        IF (AMGLSS.GT.(MZIZ+2*AMBT).AND.AMGLSS.LT.
     $     (AMB2SS+AMBT)) THEN
          TMP(1)=AMGLSS
          TMP(2)=AMBT
          TMP(3)=MZIZ
          TMP(4)=AMB2SS
          TMP(5)=AMB2SS
          XUPPER=(AMGLSS**2+AMBT**2-(AMBT+MZIZ)**2)/2./AMGLSS
          XT1=SSXINT(AMBT,SSGX1,XUPPER)
          XT2=SSXINT(AMBT,SSGX2,XUPPER)
          XT3=SSXINT(AMBT,SSGX3,XUPPER)
          XT4=SSXINT(AMBT,SSGX4,XUPPER)
          XT5=SSXINT(AMBT,SSGX5,XUPPER)
          XT6=SSXINT(AMBT,SSGX6,XUPPER)
          XT7=SSXINT(AMBT,SSGX7,XUPPER)
          XT8=SSXINT(AMBT,SSGX8,XUPPER)
          XT9=SSXINT(AMBT,SSGX9,XUPPER)
          AL1=ADIZ*SINB+FB*ZMIXSS(2,IZ)*COSB
          BE1=FB*ZMIXSS(2,IZ)*SINB-BDIZ*COSB
C         ---- here, al2 is (-) al2 of tata notes-----
          AL2=-BDIZ*COSB+FB*ZMIXSS(2,IZ)*SINB
          BE2=FB*ZMIXSS(2,IZ)*COSB+ADIZ*SINB
          XLL=(AL1**2+BE1**2)*XT1-4*AMBT*MZIZ*SNZIZ*AL1*
     $     BE1*XT3-AMGLSS*(SNZIZ*MZIZ*(AL1**2*XT2/AMGLSS/
     $     MZIZ+BE1**2*AMBT**2*XT5)-AL1*BE1*AMBT*(XT4-
     $     MZIZ**2*XT5))
          XRR=(AL2**2+BE2**2)*XT1-4*AMBT*MZIZ*SNZIZ*AL2*
     $     BE2*XT3-AMGLSS*(SNZIZ*MZIZ*(AL2**2*XT2/AMGLSS/
     $     MZIZ+BE2**2*AMBT**2*XT5)-AL2*BE2*AMBT*(XT4-
     $     MZIZ**2*XT5))
          XL1R1=-2*AMGLSS*AMBT*((AL1*AL2+BE1*BE2)*SNZIZ*AMBT*
     $     MZIZ*XT6-(AL2*BE1+AL1*BE2)*XT7)
          XL2R2=XL1R1
          XL1R2=BE1*BE2*XT8+AL1*AL2*AMBT**2*XT4-AMBT*MZIZ*
     $     SNZIZ*(AL1*BE2+AL2*BE1)*XT9
          XL2R1=XL1R2
          XMSB2=SINB**2*XLL+COSB**2*XRR+SINB*COSB*(XL1R1+XL1R2+
     $     XL2R1+XL2R2)
        ELSE
          XMSB2=0.
        END IF
C       ----cross term between b_1 and b_2 graphs -----------
        IF (AMGLSS.GT.(MZIZ+2*AMBT).AND.AMGLSS.LT.
     $     (AMB1SS+AMBT)) THEN
          TMP(1)=AMGLSS
          TMP(2)=AMBT
          TMP(3)=MZIZ
          TMP(4)=AMB1SS
          TMP(5)=AMB2SS
          XUPPER=(AMGLSS**2+AMBT**2-(AMBT+MZIZ)**2)/2./AMGLSS
          XT1=SSXINT(AMBT,SSGX1,XUPPER)
          XT2=SSXINT(AMBT,SSGX2,XUPPER)
          XT3=SSXINT(AMBT,SSGX3,XUPPER)
          XT4=SSXINT(AMBT,SSGX4,XUPPER)
          XT5=SSXINT(AMBT,SSGX5,XUPPER)
          XT6=SSXINT(AMBT,SSGX6,XUPPER)
          XT7=SSXINT(AMBT,SSGX7,XUPPER)
          XT8=SSXINT(AMBT,SSGX8,XUPPER)
          XT9=SSXINT(AMBT,SSGX9,XUPPER)
          AL1=ADIZ*COSB-FB*ZMIXSS(2,IZ)*SINB
          AL2=ADIZ*SINB+FB*ZMIXSS(2,IZ)*COSB
          BE1=FB*ZMIXSS(2,IZ)*COSB+BDIZ*SINB
          BE2=FB*ZMIXSS(2,IZ)*SINB-BDIZ*COSB
          XL1L2=COSB*SINB*(2*(AL1*AL2+BE1*BE2)*XT1-4*SNZIZ*AMBT*
     $     MZIZ*(AL1*BE2+AL2*BE1)*XT3-AMGLSS*(2*MZIZ*
     $     SNZIZ*(AL1*AL2*XT2/AMGLSS/MZIZ+BE1*BE2*AMBT**2*
     $     XT5)-(AL1*BE2+AL2*BE1)*AMBT*(XT4-MZIZ**2*XT5)))
          AL1=-BDIZ*SINB-FB*ZMIXSS(2,IZ)*COSB
          AL2=BDIZ*COSB-FB*ZMIXSS(2,IZ)*SINB
          BE1=-FB*ZMIXSS(2,IZ)*SINB+ADIZ*COSB
          BE2=FB*ZMIXSS(2,IZ)*COSB+ADIZ*SINB
          XR1R2=-COSB*SINB*(2*(AL1*AL2+BE1*BE2)*XT1+4*SNZIZ*AMBT*
     $     MZIZ*(AL1*BE2+AL2*BE1)*XT3-AMGLSS*(2*MZIZ*
     $     SNZIZ*(AL1*AL2*XT2/AMGLSS/MZIZ+BE1*BE2*AMBT**2*
     $     XT5)+(AL1*BE2+AL2*BE1)*AMBT*(XT4-MZIZ**2*XT5)))
          AL1=ADIZ*COSB-FB*ZMIXSS(2,IZ)*SINB
          AL2=BDIZ*COSB-FB*ZMIXSS(2,IZ)*SINB
          BE1=FB*ZMIXSS(2,IZ)*COSB+BDIZ*SINB
          BE2=FB*ZMIXSS(2,IZ)*COSB+ADIZ*SINB
          XL1R1=2*AMGLSS*AMBT*COSB**2*(SNZIZ*(AL1*AL2-BE1*BE2)*
     $     AMBT*MZIZ*XT6-(AL2*BE1-AL1*BE2)*XT7)
          XL1R2=COSB**2*(BE1*BE2*XT8-AL1*AL2*AMBT**2*XT4+AMBT*
     $     MZIZ*SNZIZ*XT9*(-AL1*BE2+BE1*AL2))
          XLR1=2*(XL1R1+XL1R2)
          AL1=ADIZ*SINB+FB*ZMIXSS(2,IZ)*COSB
          AL2=-BDIZ*SINB-FB*ZMIXSS(2,IZ)*COSB
          BE1=FB*ZMIXSS(2,IZ)*SINB-BDIZ*COSB
          BE2=-FB*ZMIXSS(2,IZ)*SINB+ADIZ*COSB
          TMP(4)=AMB2SS
          TMP(5)=AMB1SS
          XT8=SSXINT(AMBT,SSGX8,XUPPER)
          XT9=SSXINT(AMBT,SSGX9,XUPPER)
          XL1R1=2*AMGLSS*AMBT*SINB**2*(SNZIZ*(-AL1*AL2+BE1*BE2)*
     $     AMBT*MZIZ*XT6+(AL2*BE1-AL1*BE2)*XT7)
          XL1R2=-SINB**2*(BE1*BE2*XT8-AL1*AL2*AMBT**2*XT4+AMBT*
     $     MZIZ*SNZIZ*XT9*(-AL1*BE2+BE1*AL2))
          XLR2=2*(XL1R1+XL1R2)
          XMSB12=XL1L2+XR1R2+XLR1+XLR2
        ELSE
          XMSB12=0.
        END IF
        WID=XTCON*(XMSB1+XMSB2+XMSB12)
        IF (WID.GT.0.) THEN
          CALL SSSAVE(ISGL,WID,ISZI(IZ),IDBT,-IDBT,0,0)
        END IF
C          3 body gluino --> q + qb + zi decay, q=t
        IF (AMGLSS.GT.(MZIZ+2*AMTP).AND.AMGLSS.LT.
     $     (AMT1SS+AMTP)) THEN
          TMP(1)=AMGLSS
          TMP(2)=AMTP
          TMP(3)=MZIZ
          TMP(4)=AMT1SS
          TMP(5)=AMT1SS
          XUPPER=(AMGLSS**2+AMTP**2-(AMTP+MZIZ)**2)/2./AMGLSS
          XT1=SSXINT(AMTP,SSGX1,XUPPER)
          XT2=SSXINT(AMTP,SSGX2,XUPPER)
          XT3=SSXINT(AMTP,SSGX3,XUPPER)
          XT4=SSXINT(AMTP,SSGX4,XUPPER)
          XT5=SSXINT(AMTP,SSGX5,XUPPER)
          XT6=SSXINT(AMTP,SSGX6,XUPPER)
          XT7=SSXINT(AMTP,SSGX7,XUPPER)
          XT8=SSXINT(AMTP,SSGX8,XUPPER)
          XT9=SSXINT(AMTP,SSGX9,XUPPER)
          AL1=AUIZ*COST-FT*ZMIXSS(1,IZ)*SINT
          BE1=FT*ZMIXSS(1,IZ)*COST+BUIZ*SINT
C         ---- here, al2 is (-) al2 of tata notes-----
          AL2=BUIZ*SINT+FT*ZMIXSS(1,IZ)*COST
          BE2=-FT*ZMIXSS(1,IZ)*SINT+AUIZ*COST
          XLL=(AL1**2+BE1**2)*XT1-4*AMTP*MZIZ*SNZIZ*AL1*
     $     BE1*XT3-AMGLSS*(SNZIZ*MZIZ*(AL1**2*XT2/AMGLSS/
     $     MZIZ+BE1**2*AMTP**2*XT5)-AL1*BE1*AMTP*(XT4-
     $     MZIZ**2*XT5))
          XRR=(AL2**2+BE2**2)*XT1-4*AMTP*MZIZ*SNZIZ*AL2*
     $     BE2*XT3-AMGLSS*(SNZIZ*MZIZ*(AL2**2*XT2/AMGLSS/
     $     MZIZ+BE2**2*AMTP**2*XT5)-AL2*BE2*AMTP*(XT4-
     $     MZIZ**2*XT5))
          XL1R1=-2*AMGLSS*AMTP*((AL1*AL2+BE1*BE2)*SNZIZ*AMTP*
     $     MZIZ*XT6-(AL2*BE1+AL1*BE2)*XT7)
          XL2R2=XL1R1
          XL1R2=BE1*BE2*XT8+AL1*AL2*AMTP**2*XT4-AMTP*MZIZ*
     $     SNZIZ*(AL1*BE2+AL2*BE1)*XT9
          XL2R1=XL1R2
          XMST1=COST**2*XLL+SINT**2*XRR-SINT*COST*(XL1R1+XL1R2+
     $     XL2R1+XL2R2)
        ELSE
          XMST1=0.
        END IF
        IF (AMGLSS.GT.(MZIZ+2*AMTP).AND.AMGLSS.LT.
     $     (AMT2SS+AMTP)) THEN
          TMP(1)=AMGLSS
          TMP(2)=AMTP
          TMP(3)=MZIZ
          TMP(4)=AMT2SS
          TMP(5)=AMT2SS
          XUPPER=(AMGLSS**2+AMTP**2-(AMTP+MZIZ)**2)/2./AMGLSS
          XT1=SSXINT(AMTP,SSGX1,XUPPER)
          XT2=SSXINT(AMTP,SSGX2,XUPPER)
          XT3=SSXINT(AMTP,SSGX3,XUPPER)
          XT4=SSXINT(AMTP,SSGX4,XUPPER)
          XT5=SSXINT(AMTP,SSGX5,XUPPER)
          XT6=SSXINT(AMTP,SSGX6,XUPPER)
          XT7=SSXINT(AMTP,SSGX7,XUPPER)
          XT8=SSXINT(AMTP,SSGX8,XUPPER)
          XT9=SSXINT(AMTP,SSGX9,XUPPER)
          AL1=AUIZ*SINT+FT*ZMIXSS(1,IZ)*COST
          BE1=FT*ZMIXSS(1,IZ)*SINT-BUIZ*COST
C         ---- here, al2 is (-) al2 of tata notes-----
          AL2=-BUIZ*COST+FT*ZMIXSS(1,IZ)*SINT
          BE2=FT*ZMIXSS(1,IZ)*COST+AUIZ*SINT
          XLL=(AL1**2+BE1**2)*XT1-4*AMTP*MZIZ*SNZIZ*AL1*
     $     BE1*XT3-AMGLSS*(SNZIZ*MZIZ*(AL1**2*XT2/AMGLSS/
     $     MZIZ+BE1**2*AMTP**2*XT5)-AL1*BE1*AMTP*(XT4-
     $     MZIZ**2*XT5))
          XRR=(AL2**2+BE2**2)*XT1-4*AMTP*MZIZ*SNZIZ*AL2*
     $     BE2*XT3-AMGLSS*(SNZIZ*MZIZ*(AL2**2*XT2/AMGLSS/
     $     MZIZ+BE2**2*AMTP**2*XT5)-AL2*BE2*AMTP*(XT4-
     $     MZIZ**2*XT5))
          XL1R1=-2*AMGLSS*AMTP*((AL1*AL2+BE1*BE2)*SNZIZ*AMTP*
     $     MZIZ*XT6-(AL2*BE1+AL1*BE2)*XT7)
          XL2R2=XL1R1
          XL1R2=BE1*BE2*XT8+AL1*AL2*AMTP**2*XT4-AMTP*MZIZ*
     $     SNZIZ*(AL1*BE2+AL2*BE1)*XT9
          XL2R1=XL1R2
          XMST2=SINT**2*XLL+COST**2*XRR+SINT*COST*(XL1R1+XL1R2+
     $     XL2R1+XL2R2)
        ELSE
          XMST2=0.
        END IF
C       ----cross term between t_1 and t_2 graphs -----------
        IF (AMGLSS.GT.(MZIZ+2*AMTP).AND.AMGLSS.LT.
     $     (AMT1SS+AMTP)) THEN
          TMP(1)=AMGLSS
          TMP(2)=AMTP
          TMP(3)=MZIZ
          TMP(4)=AMT1SS
          TMP(5)=AMT2SS
          XUPPER=(AMGLSS**2+AMTP**2-(AMTP+MZIZ)**2)/2./AMGLSS
          XT1=SSXINT(AMTP,SSGX1,XUPPER)
          XT2=SSXINT(AMTP,SSGX2,XUPPER)
          XT3=SSXINT(AMTP,SSGX3,XUPPER)
          XT4=SSXINT(AMTP,SSGX4,XUPPER)
          XT5=SSXINT(AMTP,SSGX5,XUPPER)
          XT6=SSXINT(AMTP,SSGX6,XUPPER)
          XT7=SSXINT(AMTP,SSGX7,XUPPER)
          XT8=SSXINT(AMTP,SSGX8,XUPPER)
          XT9=SSXINT(AMTP,SSGX9,XUPPER)
          AL1=AUIZ*COST-FT*ZMIXSS(1,IZ)*SINT
          AL2=AUIZ*SINT+FT*ZMIXSS(1,IZ)*COST
          BE1=FT*ZMIXSS(1,IZ)*COST+BUIZ*SINT
          BE2=FT*ZMIXSS(1,IZ)*SINT-BUIZ*COST
          XL1L2=COST*SINT*(2*(AL1*AL2+BE1*BE2)*XT1-4*SNZIZ*AMTP*
     $     MZIZ*(AL1*BE2+AL2*BE1)*XT3-AMGLSS*(2*MZIZ*
     $     SNZIZ*(AL1*AL2*XT2/AMGLSS/MZIZ+BE1*BE2*AMTP**2*
     $     XT5)-(AL1*BE2+AL2*BE1)*AMTP*(XT4-MZIZ**2*XT5)))
          AL1=-BUIZ*SINT-FT*ZMIXSS(1,IZ)*COST
          AL2=BUIZ*COST-FT*ZMIXSS(1,IZ)*SINT
          BE1=-FT*ZMIXSS(1,IZ)*SINT+AUIZ*COST
          BE2=FT*ZMIXSS(1,IZ)*COST+AUIZ*SINT
          XR1R2=-COST*SINT*(2*(AL1*AL2+BE1*BE2)*XT1+4*SNZIZ*AMTP*
     $     MZIZ*(AL1*BE2+AL2*BE1)*XT3-AMGLSS*(2*MZIZ*
     $     SNZIZ*(AL1*AL2*XT2/AMGLSS/MZIZ+BE1*BE2*AMTP**2*
     $     XT5)+(AL1*BE2+AL2*BE1)*AMTP*(XT4-MZIZ**2*XT5)))
          AL1=AUIZ*COST-FT*ZMIXSS(1,IZ)*SINT
          AL2=BUIZ*COST-FT*ZMIXSS(1,IZ)*SINT
          BE1=FT*ZMIXSS(1,IZ)*COST+BUIZ*SINT
          BE2=FT*ZMIXSS(1,IZ)*COST+AUIZ*SINT
          XL1R1=2*AMGLSS*AMTP*COST**2*(SNZIZ*(AL1*AL2-BE1*BE2)*
     $     AMTP*MZIZ*XT6-(AL2*BE1-AL1*BE2)*XT7)
          XL1R2=COST**2*(BE1*BE2*XT8-AL1*AL2*AMTP**2*XT4+AMTP*
     $     MZIZ*SNZIZ*XT9*(-AL1*BE2+BE1*AL2))
          XLR1=2*(XL1R1+XL1R2)
          AL1=AUIZ*SINT+FT*ZMIXSS(1,IZ)*COST
          AL2=-BUIZ*SINT-FT*ZMIXSS(1,IZ)*COST
          BE1=FT*ZMIXSS(1,IZ)*SINT-BUIZ*COST
          BE2=-FT*ZMIXSS(1,IZ)*SINT+AUIZ*COST
          TMP(4)=AMT2SS
          TMP(5)=AMT1SS
          XT8=SSXINT(AMTP,SSGX8,XUPPER)
          XT9=SSXINT(AMTP,SSGX9,XUPPER)
          XL1R1=2*AMGLSS*AMTP*SINT**2*(SNZIZ*(-AL1*AL2+BE1*BE2)*
     $     AMTP*MZIZ*XT6+(AL2*BE1-AL1*BE2)*XT7)
          XL1R2=-SINT**2*(BE1*BE2*XT8-AL1*AL2*AMTP**2*XT4+AMTP*
     $     MZIZ*SNZIZ*XT9*(-AL1*BE2+BE1*AL2))
          XLR2=2*(XL1R1+XL1R2)
          XMST12=XL1L2+XR1R2+XLR1+XLR2
        ELSE
          XMST12=0.
        END IF
          WID=XTCON*(XMST1+XMST2+XMST12)
        IF (WID.GT.0.) THEN
          CALL SSSAVE(ISGL,WID,ISZI(IZ),IDTP,-IDTP,0,0)
        END IF
100   CONTINUE
C
C          gluino --> quark + squark mode
C
      IF (AMGLSS.GT.(AMULSS+AMUP)) THEN
        GMQK=ALF3*AMGLSS*(1.+AMUP**2/AMGLSS**2-AMULSS**2/AMGLSS**2)*
     $  SQRT(SSXLAM(1.,AMUP**2/AMGLSS**2,AMULSS**2/AMGLSS**2))/8.
        CALL SSSAVE(ISGL,GMQK,-ISUPL,+IDUP,0,0,0)
        CALL SSSAVE(ISGL,GMQK,+ISUPL,-IDUP,0,0,0)
      END IF
      IF (AMGLSS.GT.(AMDLSS+AMDN)) THEN
        GMQK=ALF3*AMGLSS*(1.+AMDN**2/AMGLSS**2-AMDLSS**2/AMGLSS**2)*
     $  SQRT(SSXLAM(1.,AMDN**2/AMGLSS**2,AMDLSS**2/AMGLSS**2))/8.
        CALL SSSAVE(ISGL,GMQK,-ISDNL,+IDDN,0,0,0)
        CALL SSSAVE(ISGL,GMQK,+ISDNL,-IDDN,0,0,0)
      END IF
      IF (AMGLSS.GT.(AMURSS+AMUP)) THEN
        GMQK=ALF3*AMGLSS*(1.+AMUP**2/AMGLSS**2-AMURSS**2/AMGLSS**2)*
     $  SQRT(SSXLAM(1.,AMUP**2/AMGLSS**2,AMURSS**2/AMGLSS**2))/8.
        CALL SSSAVE(ISGL,GMQK,-ISUPR,+IDUP,0,0,0)
        CALL SSSAVE(ISGL,GMQK,+ISUPR,-IDUP,0,0,0)
      END IF
      IF (AMGLSS.GT.(AMDRSS+AMDN)) THEN
        GMQK=ALF3*AMGLSS*(1.+AMDN**2/AMGLSS**2-AMDRSS**2/AMGLSS**2)*
     $  SQRT(SSXLAM(1.,AMDN**2/AMGLSS**2,AMDRSS**2/AMGLSS**2))/8.
        CALL SSSAVE(ISGL,GMQK,-ISDNR,+IDDN,0,0,0)
        CALL SSSAVE(ISGL,GMQK,+ISDNR,-IDDN,0,0,0)
      END IF
C
      IF (AMGLSS.GT.(AMSLSS+AMST)) THEN
        GMQK=ALF3*AMGLSS*(1.+AMST**2/AMGLSS**2-AMSLSS**2/AMGLSS**2)*
     $  SQRT(SSXLAM(1.,AMST**2/AMGLSS**2,AMSLSS**2/AMGLSS**2))/8.
        CALL SSSAVE(ISGL,GMQK,-ISSTL,+IDST,0,0,0)
        CALL SSSAVE(ISGL,GMQK,+ISSTL,-IDST,0,0,0)
      END IF
      IF (AMGLSS.GT.(AMSRSS+AMST)) THEN
        GMQK=ALF3*AMGLSS*(1.+AMST**2/AMGLSS**2-AMSRSS**2/AMGLSS**2)*
     $  SQRT(SSXLAM(1.,AMST**2/AMGLSS**2,AMSRSS**2/AMGLSS**2))/8.
        CALL SSSAVE(ISGL,GMQK,-ISSTR,+IDST,0,0,0)
        CALL SSSAVE(ISGL,GMQK,+ISSTR,-IDST,0,0,0)
      END IF
C
      IF (AMGLSS.GT.(AMCLSS+AMCH)) THEN
        GMQK=ALF3*AMGLSS*(1.+AMCH**2/AMGLSS**2-AMCLSS**2/AMGLSS**2)*
     $  SQRT(SSXLAM(1.,AMCH**2/AMGLSS**2,AMCLSS**2/AMGLSS**2))/8.
        CALL SSSAVE(ISGL,GMQK,-ISCHL,+IDCH,0,0,0)
        CALL SSSAVE(ISGL,GMQK,+ISCHL,-IDCH,0,0,0)
      END IF
      IF (AMGLSS.GT.(AMCRSS+AMCH)) THEN
        GMQK=ALF3*AMGLSS*(1.+AMCH**2/AMGLSS**2-AMCRSS**2/AMGLSS**2)*
     $  SQRT(SSXLAM(1.,AMCH**2/AMGLSS**2,AMCRSS**2/AMGLSS**2))/8.
        CALL SSSAVE(ISGL,GMQK,-ISCHR,+IDCH,0,0,0)
        CALL SSSAVE(ISGL,GMQK,+ISCHR,-IDCH,0,0,0)
      END IF
C
C     !!! NEED MIXING ANGLE PIECE LIKE STOPS
      IF (AMGLSS.GT.(AMB1SS+AMBT)) THEN
        GMQK=ALF3*AMGLSS*(1.+AMBT**2/AMGLSS**2-AMB1SS**2/AMGLSS**2)*
     $  SQRT(SSXLAM(1.,AMBT**2/AMGLSS**2,AMB1SS**2/AMGLSS**2))/8.
        CALL SSSAVE(ISGL,GMQK,-ISBT1,+IDBT,0,0,0)
        CALL SSSAVE(ISGL,GMQK,+ISBT1,-IDBT,0,0,0)
      END IF
C
      IF (AMGLSS.GT.(AMB2SS+AMBT)) THEN
        GMQK=ALF3*AMGLSS*(1.+AMBT**2/AMGLSS**2-AMB2SS**2/AMGLSS**2)*
     $  SQRT(SSXLAM(1.,AMBT**2/AMGLSS**2,AMB2SS**2/AMGLSS**2))/8.
        CALL SSSAVE(ISGL,GMQK,-ISBT2,+IDBT,0,0,0)
        CALL SSSAVE(ISGL,GMQK,+ISBT2,-IDBT,0,0,0)
      END IF
C
      IF (AMGLSS.GT.(AMT1SS+AMTP)) THEN
        GMQK=ALF3*AMGLSS*(1.+AMTP**2/AMGLSS**2-AMT1SS**2/AMGLSS**2-
     $   2*SIN(2*THETAT)*AMTP/AMGLSS)*
     $  SQRT(SSXLAM(1.,AMTP**2/AMGLSS**2,AMT1SS**2/AMGLSS**2))/8.
        CALL SSSAVE(ISGL,GMQK,-ISTP1,+IDTP,0,0,0)
        CALL SSSAVE(ISGL,GMQK,+ISTP1,-IDTP,0,0,0)
      END IF
C
      IF (AMGLSS.GT.(AMT2SS+AMTP)) THEN
        GMQK=ALF3*AMGLSS*(1.+AMTP**2/AMGLSS**2-AMT2SS**2/AMGLSS**2+
     $   2*SIN(2*THETAT)*AMTP/AMGLSS)*
     $  SQRT(SSXLAM(1.,AMTP**2/AMGLSS**2,AMT2SS**2/AMGLSS**2))/8.
        CALL SSSAVE(ISGL,GMQK,-ISTP2,+IDTP,0,0,0)
        CALL SSSAVE(ISGL,GMQK,+ISTP2,-IDTP,0,0,0)
      END IF
C
C     Decay to gravitino
C
      IF (AMGLSS.GT.AMGVSS) THEN
        WID=AMGLSS**5/48./PI/(AMGVSS*AMPL)**2
        CALL SSSAVE(ISGL,WID,91,IDGL,0,0,0)
      END IF
C
C          Normalize branching ratios
C
      CALL SSNORM(ISGL)
C
      RETURN
      END
CDECK  ID>, SSGWQ1. 
        REAL FUNCTION SSGWQ1(Q)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> wiss + qk + qb
C          The function psi of PRD36, 96 (1987); Eq. 3.2
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL Q,PI
        DOUBLE PRECISION MZ,MG,MS,QS,MGS,MSS,MZS,FUN
        PI=4*ATAN(1.)
        MZ=TMP(1)
        MS=TMP(2)
        MG=AMGLSS
        QS=Q*Q
        MGS=MG*MG
        MZS=MZ*MZ
        MSS=MS*MS
        FUN=QS*(MGS-2*MG*Q-MZS)**2/(MGS-2*MG*Q-MSS)**2/(MGS-2*MG*Q)
        SSGWQ1=PI**2*MG*FUN
        RETURN
        END
CDECK  ID>, SSGWQ2. 
        REAL FUNCTION SSGWQ2(Q)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> wiss + qk + qb
C          The function phi of PRD36, 96 (1987); Eq. 3.2
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL Q,PI
        DOUBLE PRECISION MZ,MG,MS,QS,MGS,MSS,MZS,FUN,TERM
        PI=4*ATAN(1.)
        MZ=TMP(1)
        MS=TMP(2)
        MG=AMGLSS
        QS=Q*Q
        MGS=MG*MG
        MZS=MZ*MZ
        MSS=MS*MS
        TERM=(MSS*MG-2*MSS*Q-MG*MZS)/(MG-2*Q)/(MSS-2*MG*Q-MZS)
        FUN=(-Q*(MGS-MZS-2*MG*Q)/(MGS-2*Q*MG)-(2*MG*Q-MSS+MZS)*
     $   DLOG(TERM)/2.D0/MG)/(MGS-MSS-2*MG*Q)
        SSGWQ2=PI**2*MG*MZ/2.*FUN
        RETURN
        END
CDECK  ID>, SSGWT1. 
        REAL FUNCTION SSGWT1(E)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> wiss + tp + bb
C          Baer's FTBW1
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL E
        DOUBLE PRECISION MWI,MG,MT,DFTBW,PT,ET,MST1,MST2,TOP,BOT
C
        ET=E
        MWI=TMP(1)
        MG=TMP(2)
        MT=TMP(3)
        MST1=TMP(6)
        MST2=TMP(7)
C
C            Rewrite PT=DSQRT(ET**2-MT**2)
        PT=DSQRT((ET-MT)*(ET+MT))
        TOP=(MG**2+MT**2-2*MG*ET-MWI**2)**2*ET*PT
        BOT=(MG**2+MT**2-2*MG*ET-MST1**2)*(MG**2+MT**2-2*MG*ET-
     $      MST2**2)*(MG**2+MT**2-2*ET*MG)
        DFTBW=MG*TOP/BOT
        SSGWT1=DFTBW
        RETURN
        END
CDECK  ID>, SSGWT2. 
        REAL FUNCTION SSGWT2(E)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> wiss + tp + bb
C          Drees' G_2
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL E
        DOUBLE PRECISION MWI,MG,MT,DFTBW,EB,TOP,BOT,MSB
        DOUBLE PRECISION SSDLAM,TERM
C
        EB=E
        MWI=TMP(1)
        MG=TMP(2)
        MT=TMP(3)
        MSB=TMP(4)
C
        TOP=EB**2*(MG**2+AMBT**2-2*MG*EB-MWI**2-MT**2)
        BOT=(MG**2+AMBT**2-2*MG*EB-MSB**2)**2*
     $       (MG**2+AMBT**2-2*EB*MG)
        TERM=SSDLAM((MG**2+AMBT**2-2*MG*EB),MWI**2,MT**2)
        IF(TERM.GT.0.D0) THEN
          DFTBW=MG*TOP/BOT*DSQRT(TERM)
        ELSE
          DFTBW=0.D0
        ENDIF
        SSGWT2=DFTBW
        RETURN
        END
CDECK  ID>, SSGWT3. 
        REAL FUNCTION SSGWT3(E)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> wiss + tp + bb
C          Drees' G_3
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL E
        DOUBLE PRECISION MWI,MG,MT,EB,BOT,MSB
        DOUBLE PRECISION SSDLAM,TERM,SN,DFTBW
C
        EB=E
        MWI=TMP(1)
        MG=TMP(2)
        MT=TMP(3)
        MSB=TMP(4)
        SN=TMP(8)
C

        BOT=(MG**2+AMBT**2-2*MG*EB-MSB**2)**2*
     $       (MG**2+AMBT**2-2*EB*MG)
        TERM=SSDLAM((MG**2+AMBT**2-2*MG*EB),MWI**2,MT**2)
        IF(TERM.GT.0.D0) THEN
          DFTBW=4*MG*MWI*MT*SN*EB*EB/BOT*DSQRT(TERM)
        ELSE
          DFTBW=0.D0
        ENDIF
        SSGWT3=DFTBW
        RETURN
        END
CDECK  ID>, SSGWT4. 
        REAL FUNCTION SSGWT4(E)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> wiss + tp + bb
C          Baer's FTBW12; EQ. A.3D OF BTW, MODIFIED FOR MB=/0
C          Drees' G_4
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL E
        DOUBLE PRECISION ET,MWI,MG,MT,MSB,MST,PT,EBMX
        DOUBLE PRECISION BOT,TOP,DFTBW,EBMN,XX
        DOUBLE PRECISION MB,Z,RDL,DEN,R1,R2,R3,SSDLAM,SN
C
        ET=E
        MWI=TMP(1)
        MG=TMP(2)
        MT=TMP(3)
        MSB=TMP(4)
        MST=TMP(6)
        SN=TMP(8)
        MB=AMBT
C
C            Rewrite PT=DSQRT(ET**2-MT**2)
        PT=DSQRT((ET-MT)*(ET+MT))
        Z=(MG**2+MT**2-2*MG*ET+MB**2-MWI**2)/2.
        R1=1.D0+MT**2/MG**2-2.D0*ET/MG
        R2=MB**2/MG**2
        R3=MWI**2/MG**2
        RDL=DSQRT(DMAX1(0.D0,SSDLAM(R1,R2,R3)))
        DEN=MG**2+MT**2-2*ET*MG
        EBMX=(2*Z*(1.D0-ET/MG)+PT*MG*RDL)*MG/2.D0/DEN
        EBMN=(2*Z*(1.D0-ET/MG)-PT*MG*RDL)*MG/2.D0/DEN
        XX=(MSB**2+2*MG*EBMX-MG**2)/(MSB**2+2*MG*EBMN-MG**2)
        TOP=EBMX-EBMN-(MSB**2-2*MG*ET+MT**2-MWI**2)*DLOG(XX)/2.D0/MG
        BOT=(MG**2+MT**2-2*MG*ET-MST**2)
        DFTBW=-SN*MG*MWI*TOP/BOT
        SSGWT4=DFTBW
        RETURN
        END
CDECK  ID>, SSGWT5. 
        REAL FUNCTION SSGWT5(E)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> wiss + tp + bb
C          Baer's FTBW12; EQ. A.3D OF BTW, MODIFIED FOR MB=/0
C          Drees' G_5
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL E
        DOUBLE PRECISION ET,MWI,MG,MT,MSB,MST,PT,EBMX
        DOUBLE PRECISION BOT,TOP,DFTBW,EBMN,XX
        DOUBLE PRECISION MB,Z,RDL,DEN,R1,R2,R3,SSDLAM
C
        ET=E
        MWI=TMP(1)
        MG=TMP(2)
        MT=TMP(3)
        MSB=TMP(4)
        MST=TMP(6)
        MB=AMBT
C
C            Rewrite PT=DSQRT(ET**2-MT**2)
        PT=DSQRT((ET-MT)*(ET+MT))
        Z=(MG**2+MT**2-2*MG*ET+MB**2-MWI**2)/2.
        R1=1.D0+MT**2/MG**2-2.D0*ET/MG
        R2=MB**2/MG**2
        R3=MWI**2/MG**2
        RDL=DSQRT(DMAX1(0.D0,SSDLAM(R1,R2,R3)))
        DEN=MG**2+MT**2-2*ET*MG
        EBMX=(2*Z*(1.D0-ET/MG)+PT*MG*RDL)*MG/2.D0/DEN
        EBMN=(2*Z*(1.D0-ET/MG)-PT*MG*RDL)*MG/2.D0/DEN
        XX=(MSB**2+2*MG*EBMX-MG**2)/(MSB**2+2*MG*EBMN-MG**2)
        TOP=(MG**2+MT**2-2*MG*ET-MWI**2)*DLOG(XX)
        BOT=MG**2+MT**2-2*MG*ET-MST**2
        DFTBW=-0.5*MT*TOP/BOT
        SSGWT5=DFTBW
        RETURN
        END
CDECK  ID>, SSGWT6. 
        REAL FUNCTION SSGWT6(E)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> wiss + tp + bb
C          Baer's FTBW23/Drees' G_6
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL E
        DOUBLE PRECISION ET,MWI,MG,MT,MSB,MST,PT,EBMX
        DOUBLE PRECISION DEN,T1,DFTBW,EBMN,XX,XL
        DOUBLE PRECISION MB,Z,RDL,DENO,R1,R2,R3,SSDLAM
C
        ET=E
        MWI=TMP(1)
        MG=TMP(2)
        MT=TMP(3)
        MSB=TMP(4)
        MST=TMP(6)
        MB=AMBT
C
C            Rewrite PT=DSQRT(ET**2-MT**2)
        PT=DSQRT((ET-MT)*(ET+MT))
        Z=(MG**2+MT**2-2*MG*ET+MB**2-MWI**2)/2.
        R1=1.D0+MT**2/MG**2-2.D0*ET/MG
        R2=MB**2/MG**2
        R3=MWI**2/MG**2
        RDL=DSQRT(DMAX1(0.D0,SSDLAM(R1,R2,R3)))
        DENO=MG**2+MT**2-2*ET*MG
        EBMX=(2*Z*(1.D0-ET/MG)+PT*MG*RDL)*MG/2.D0/DENO
        EBMN=(2*Z*(1.D0-ET/MG)-PT*MG*RDL)*MG/2.D0/DENO
        XX=(MSB**2+2*MG*EBMX-MG**2)/(MSB**2+2*MG*EBMN-MG**2)
        XL=DLOG(XX)
        DEN=MG**2-2*MG*ET+MT**2-MST**2
        T1=(MG*(MG**2+MT**2-2*MG*ET-MWI**2)-(MSB**2-MG**2)*
     $      (2*ET*MG-MT**2-MG**2)/MG)*XL+2*(2*ET*MG-MT**2-MG**2)*
     $      (EBMX-EBMN)
        DFTBW=.5D0*T1/DEN
        SSGWT6=DFTBW
        RETURN
        END
CDECK  ID>, SSGWT7. 
        REAL FUNCTION SSGWT7(E)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> wiss + tp + bb
C          Baer's FTBW23/Drees' G_7
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL E
        DOUBLE PRECISION ET,MWI,MG,MT,MSB,MST,PT,EBMX
        DOUBLE PRECISION DEN,T1,SN,DFTBW,EBMN,XX,XL
        DOUBLE PRECISION MB,Z,RDL,DENO,R1,R2,R3,SSDLAM
C
        ET=E
        MWI=TMP(1)
        MG=TMP(2)
        MT=TMP(3)
        MSB=TMP(4)
        MST=TMP(6)
        SN=TMP(8)
        MB=AMBT
C
C            Rewrite PT=DSQRT(ET**2-MT**2)
        PT=DSQRT((ET-MT)*(ET+MT))
        Z=(MG**2+MT**2-2*MG*ET+MB**2-MWI**2)/2.
        R1=1.D0+MT**2/MG**2-2.D0*ET/MG
        R2=MB**2/MG**2
        R3=MWI**2/MG**2
        RDL=DSQRT(DMAX1(0.D0,SSDLAM(R1,R2,R3)))
        DENO=MG**2+MT**2-2*ET*MG
        EBMX=(2*Z*(1.D0-ET/MG)+PT*MG*RDL)*MG/2.D0/DENO
        EBMN=(2*Z*(1.D0-ET/MG)-PT*MG*RDL)*MG/2.D0/DENO
        XX=(MSB**2+2*MG*EBMX-MG**2)/(MSB**2+2*MG*EBMN-MG**2)
        XL=DLOG(XX)
        DEN=MG**2-2*MG*ET+MT**2-MST**2
        T1=2*(EBMX-EBMN)-(MSB**2-MG**2)*XL/MG
        DFTBW=.5*SN*MWI*MT*T1/DEN
        SSGWT7=DFTBW
        RETURN
        END
CDECK  ID>, SSGWT8. 
        REAL FUNCTION SSGWT8(E)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> wiss + tp + bb
C          Baer's FTBW13/  Drees' G_8
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL E
        DOUBLE PRECISION ET,MWI,MG,MT,MST1,MST2,PT,EBMX,EBMN
        DOUBLE PRECISION TOP,BOT,DFTBW
        DOUBLE PRECISION MB,Z,RDL,DEN,R1,R2,R3,SSDLAM
C
        ET=E
        MWI=TMP(1)
        MG=TMP(2)
        MT=TMP(3)
        MST1=TMP(6)
        MST2=TMP(7)
        MB=AMBT
C
C            Rewrite PT=DSQRT(ET**2-MT**2)
        PT=DSQRT((ET-MT)*(ET+MT))
        Z=(MG**2+MT**2-2*MG*ET+MB**2-MWI**2)/2.
        R1=1.D0+MT**2/MG**2-2.D0*ET/MG
        R2=MB**2/MG**2
        R3=MWI**2/MG**2
        RDL=DSQRT(DMAX1(0.D0,SSDLAM(R1,R2,R3)))
        DEN=MG**2+MT**2-2*ET*MG
        EBMX=(2*Z*(1.D0-ET/MG)+PT*MG*RDL)*MG/2.D0/DEN
        EBMN=(2*Z*(1.D0-ET/MG)-PT*MG*RDL)*MG/2.D0/DEN
        TOP=(MG**2+MT**2-2*MG*ET-MWI**2)*(EBMX-EBMN)
        BOT=(MG**2+MT**2-2*MG*ET-MST1**2)*
     $  (MG**2+MT**2-2*MG*ET-MST2**2)
        DFTBW=-MG*MT*TOP/BOT
        SSGWT8=DFTBW
        RETURN
        END
CDECK  ID>, SSGX1.  
        REAL FUNCTION SSGX1(ET)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> ziss + tp + tb
C          Baer's XT1 - PSI- eq. a.6.a of prd45,142 (1992)
C          Modified for t_1 and t_2 eigenstates
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL ET
        DOUBLE PRECISION DET,DMG,DMT,DMZ,DMT1,DMT2,TOP
        DOUBLE PRECISION BOT,PT,DXT1,SSDLAM,PI,TOPS
        DATA PI/3.14159265D0/
        DET=ET
        DMG=TMP(1)
        DMT=TMP(2)
        DMZ=TMP(3)
        DMT1=TMP(4)
        DMT2=TMP(5)
        PT=DSQRT(DET**2-DMT**2)
        TOPS=SSDLAM(DMG**2+DMT**2-2*DMG*DET,DMT**2,DMZ**2)
        TOP=DSQRT(DMAX1(0.D0,TOPS))
        BOT=(DMG**2+DMT**2-2*DMG*DET-DMT1**2)*
     $   (DMG**2+DMT**2-2*DMG*DET-DMT2**2)
        DXT1=PI**2*DMG*DET*PT*(DMG**2-DMZ**2-2*DMG*DET)*TOP/BOT/
     $       (DMG**2-2*DMG*DET+DMT**2)
        SSGX1=DXT1
        RETURN
        END
CDECK  ID>, SSGX10. 
        REAL FUNCTION SSGX10(ET)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> ziss + tp + tb
C          Baer's XT10
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL MG,MT,MZ,MST1,MST2,ET
        DOUBLE PRECISION DET,DMG,DMT,DMZ,DMT1,DMT2,TOP,BOT,DXT10
        DOUBLE PRECISION XT,MUT,MUZ,XMIN,XMAX,EMIN,EMAX,SSDLAM
        DOUBLE PRECISION PI
        DATA PI/3.14159265D0/
        MG=TMP(1)
        MT=TMP(2)
        MZ=TMP(3)
        MST1=TMP(4)
        MST2=TMP(5)
        DET=ET
        DMG=TMP(1)
        DMT=TMP(2)
        DMZ=TMP(3)
        DMT1=TMP(4)
        DMT2=TMP(5)
        XT=2*ET/MG
        MUT=(MT/MG)**2
        MUZ=(MZ/MG)**2
        XMIN=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)-DSQRT(DMAX1(0.D0,
     $   (XT**2-4*MUT)*SSDLAM((1.D0+MUT-XT),MUT,MUZ))))
     $   /2.D0/(1.D0-XT+MUT)
        XMAX=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)+DSQRT(DMAX1(0.D0,
     $   (XT**2-4*MUT)*SSDLAM((1.D0+MUT-XT),MUT,MUZ))))
     $   /2.D0/(1.D0-XT+MUT)
        EMIN=XMIN*MG/2.D0
        EMAX=XMAX*MG/2.D0
        TOP=DMG**2-2*DMG*EMAX+DMT**2-DMT2**2
        BOT=DMG**2-2*DMG*EMIN+DMT**2-DMT2**2
        DXT10=(EMAX-EMIN-(DMG**2-2*DMG*DET+DMT2**2-DMT**2)/2.D0/DMG*
     $      DLOG(TOP/BOT))*PI**2/2.D0/(DMG**2+DMT**2-2*DMG*DET-DMT1**2)
        SSGX10=DXT10
        RETURN
        END
CDECK  ID>, SSGX11. 
        REAL FUNCTION SSGX11(ET)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> ziss + tp + tb
C          Baer's XT11
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL MG,MT,MZ,MST1,MST2,ET
        DOUBLE PRECISION DET,DMG,DMT,DMZ,DMT1,DMT2,TOP,BOT,DXT11
        DOUBLE PRECISION XT,MUT,MUZ,XMIN,XMAX,EMIN,EMAX,SSDLAM
        DOUBLE PRECISION PI
        DATA PI/3.14159265D0/
        MG=TMP(1)
        MT=TMP(2)
        MZ=TMP(3)
        MST1=TMP(4)
        MST2=TMP(5)
        DET=ET
        DMG=TMP(1)
        DMT=TMP(2)
        DMZ=TMP(3)
        DMT1=TMP(4)
        DMT2=TMP(5)
        XT=2*ET/MG
        MUT=(MT/MG)**2
        MUZ=(MZ/MG)**2
        XMIN=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)-DSQRT(DMAX1(0.D0,
     $   (XT**2-4*MUT)*SSDLAM((1.D0+MUT-XT),MUT,MUZ))))
     $   /2.D0/(1.D0-XT+MUT)
        XMAX=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)+DSQRT(DMAX1(0.D0,
     $   (XT**2-4*MUT)*SSDLAM((1.D0+MUT-XT),MUT,MUZ))))
     $   /2.D0/(1.D0-XT+MUT)
        EMIN=XMIN*MG/2.D0
        EMAX=XMAX*MG/2.D0
        TOP=DMG**2-2*DMG*EMAX+DMT**2-DMT2**2
        BOT=DMG**2-2*DMG*EMIN+DMT**2-DMT2**2
        DXT11=-PI**2*DET*DLOG(TOP/BOT)/2.D0/(DMG**2-2*DMG*DET+DMT**2
     $         -DMT1**2)
        SSGX11=DXT11
        RETURN
        END
CDECK  ID>, SSGX2.  
        REAL FUNCTION SSGX2(ET)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> ziss + tp + tb
C          Baer's XT2 - PHI- eq. a.6.b of prd45,142 (1992)
C          Modified for t_1 and t_2 eigenstates
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL ET
        DOUBLE PRECISION DET,DMG,DMT,DMZ,DMT1,DMT2,TOP,BOT,DXT2
        DOUBLE PRECISION XT,MUT,MUZ,XMIN,XMAX,EMIN,EMAX,SSDLAM,PI
        DATA PI/3.14159265D0/
        DET=ET
        DMG=TMP(1)
        DMT=TMP(2)
        DMZ=TMP(3)
        DMT1=TMP(4)
        DMT2=TMP(5)
        XT=2*DET/DMG
        MUT=(DMT/DMG)**2
        MUZ=(DMZ/DMG)**2
        XMIN=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)-DSQRT(DMAX1(0.D0,
     $   (XT**2-4*MUT)*SSDLAM((1.D0+MUT-XT),MUT,MUZ))))
     $   /2.D0/(1.D0-XT+MUT)
        XMAX=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)+DSQRT(DMAX1(0.D0,
     $   (XT**2-4*MUT)*SSDLAM((1.D0+MUT-XT),MUT,MUZ))))
     $   /2.D0/(1.D0-XT+MUT)
        EMIN=XMIN*DMG/2.D0
        EMAX=XMAX*DMG/2.D0
        TOP=DMG**2-2*DMG*EMAX+DMT**2-DMT2**2
        BOT=DMG**2-2*DMG*EMIN+DMT**2-DMT2**2
        DXT2=(-(EMAX-EMIN)-(2*DET*DMG+DMZ**2-DMT**2-DMT2**2)/2.D0/DMG*
     $      DLOG(TOP/BOT))*PI**2/2.D0*DMG*DMZ/
     $      (DMG**2+DMT**2-DMT1**2-2*DMG*DET)
        SSGX2=DXT2
        RETURN
        END
CDECK  ID>, SSGX3.  
        REAL FUNCTION SSGX3(ET)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> ziss + tp + tb
C          Baer's XT3 - CHI- eq. a.6.c of prd45,142 (1992)
C          Modified for t_1 and t_2 eigenstates
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL ET
        DOUBLE PRECISION DET,DMG,DMT,DMZ,DMT1,DMT2,TOP,BOT
        DOUBLE PRECISION PT,DXT3,SSDLAM,PI,TOPS
        DATA PI/3.14159265D0/
        DET=ET
        DMG=TMP(1)
        DMT=TMP(2)
        DMZ=TMP(3)
        DMT1=TMP(4)
        DMT2=TMP(5)
        TOPS=SSDLAM(DMG**2+DMT**2-2*DMG*DET,DMT**2,DMZ**2)
        TOP=DSQRT(DMAX1(1.D0,TOPS))
        BOT=(DMG**2+DMT**2-2*DMG*DET-DMT1**2)*
     $      (DMG**2+DMT**2-2*DMG*DET-DMT2**2)
        PT=DSQRT(DET**2-DMT**2)
        DXT3=PI**2*DMG*DET*PT*TOP/BOT/(DMG**2-2*DMG*DET+DMT**2)
        SSGX3=DXT3
        RETURN
        END
CDECK  ID>, SSGX4.  
        REAL FUNCTION SSGX4(ET)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> ziss + tp + tb
C          Baer's XT4 - XI- eq. a.6.d of prd45,142 (1992)
C          Modified for t_1 and t_2 eigenstates
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL ET
        DOUBLE PRECISION DET,DMG,DMT,DMZ,DMT1,DMT2,TOP,BOT,DXT4
        DOUBLE PRECISION XT,MUT,MUZ,XMIN,XMAX,EMIN,EMAX,SSDLAM,PI
        DATA PI/3.14159265D0/
        DET=ET
        DMG=TMP(1)
        DMT=TMP(2)
        DMZ=TMP(3)
        DMT1=TMP(4)
        DMT2=TMP(5)
        XT=2*ET/DMG
        MUT=(DMT/DMG)**2
        MUZ=(DMZ/DMG)**2
        XMIN=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)-DSQRT(DMAX1(0.D0,
     $   (XT**2-4*MUT)*SSDLAM((1.D0+MUT-XT),MUT,MUZ))))
     $   /2.D0/(1.D0-XT+MUT)
        XMAX=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)+DSQRT(DMAX1(0.D0,
     $   (XT**2-4*MUT)*SSDLAM((1.D0+MUT-XT),MUT,MUZ))))
     $   /2.D0/(1.D0-XT+MUT)
        EMIN=XMIN*DMG/2.D0
        EMAX=XMAX*DMG/2.D0
        TOP=DMG**2-2*DMG*EMAX+DMT**2-DMT2**2
        BOT=DMG**2-2*DMG*EMIN+DMT**2-DMT2**2
        DXT4=(EMAX-EMIN-(DMG**2-2*DMG*DET+DMT2**2-DMT**2)/2.D0/DMG*
     $      DLOG(TOP/BOT))*PI**2/2.D0/(DMG**2+DMT**2-2*DMG*DET-DMT1**2)
        SSGX4=DXT4
        RETURN
        END
CDECK  ID>, SSGX5.  
        REAL FUNCTION SSGX5(ET)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> ziss + tp + tb
C          Baer's XT5 - RHO- eq. a.6.e of prd45,142 (1992)
C          Modified for t_1 and t_2 eigenstates
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL ET
        DOUBLE PRECISION DET,DMG,DMT,DMZ,DMT1,DMT2,TOP,BOT,DXT5
        DOUBLE PRECISION XT,MUT,MUZ,XMIN,XMAX,EMIN,EMAX,SSDLAM
        DOUBLE PRECISION PI
        DATA PI/3.14159265D0/
        DET=ET
        DMG=TMP(1)
        DMT=TMP(2)
        DMZ=TMP(3)
        DMT1=TMP(4)
        DMT2=TMP(5)
        XT=2*ET/DMG
        MUT=(DMT/DMG)**2
        MUZ=(DMZ/DMG)**2
        XMIN=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)-DSQRT(DMAX1(0.D0,
     $   (XT**2-4*MUT)*SSDLAM((1.D0+MUT-XT),MUT,MUZ))))
     $   /2.D0/(1.D0-XT+MUT)
        XMAX=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)+DSQRT(DMAX1(0.D0,
     $   (XT**2-4*MUT)*SSDLAM((1.D0+MUT-XT),MUT,MUZ))))
     $   /2.D0/(1.D0-XT+MUT)
        EMIN=XMIN*DMG/2.D0
        EMAX=XMAX*DMG/2.D0
        TOP=DMG**2-2*DMG*EMAX+DMT**2-DMT2**2
        BOT=DMG**2-2*DMG*EMIN+DMT**2-DMT2**2
        DXT5=-PI**2*DLOG(TOP/BOT)/2.D0/DMG/(DMG**2-2*DMG*DET+DMT**2
     $         -DMT1**2)
        SSGX5=DXT5
        RETURN
        END
CDECK  ID>, SSGX6.  
        REAL FUNCTION SSGX6(ET)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> ziss + tp + tb
C          Baer's XT6 - ZETA- eq. a.6.f of prd45,142 (1992)
C          Modified for t_1 and t_2 eigenstates
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL ET
        DOUBLE PRECISION DET,DMG,DMT,DMZ,DMT1,DMT2,T1,T2,DXT6
        DOUBLE PRECISION XT,MUT,MUZ,XMIN,XMAX,EMIN,EMAX,SSDLAM
        DOUBLE PRECISION PI
        DATA PI/3.14159265D0/
        DET=ET
        DMG=TMP(1)
        DMT=TMP(2)
        DMZ=TMP(3)
        DMT1=TMP(4)
        DMT2=TMP(5)
        XT=2*DET/DMG
        MUT=(DMT/DMG)**2
        MUZ=(DMZ/DMG)**2
        XMIN=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)-DSQRT(DMAX1(0.D0,
     $   (XT**2-4*MUT)*SSDLAM((1.D0+MUT-XT),MUT,MUZ))))
     $   /2.D0/(1.D0-XT+MUT)
        XMAX=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)+DSQRT(DMAX1(0.D0,
     $   (XT**2-4*MUT)*SSDLAM((1.D0+MUT-XT),MUT,MUZ))))
     $   /2.D0/(1.D0-XT+MUT)
        EMIN=XMIN*DMG/2.D0
        EMAX=XMAX*DMG/2.D0
        T1=DMG**2+DMT**2-2*DMG*DET-DMT1**2
        T2=DMG**2+DMT**2-2*DMG*DET-DMT2**2
        DXT6=PI**2*(EMAX-EMIN)/T1/T2
        SSGX6=DXT6
        RETURN
        END
CDECK  ID>, SSGX7.  
        REAL FUNCTION SSGX7(ET)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> ziss + tp + tb
C          Baer's XT7 - X- eq. a.6.g of prd45,142 (1992)
C          Modified for t_1 and t_2 eigenstates
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL ET
        DOUBLE PRECISION DET,DMG,DMT,DMZ,DMT1,DMT2,TOP
        DOUBLE PRECISION BOT,PT,DXT7,SSDLAM,PI,TOPS
        DATA PI/3.14159265D0/
        DET=ET
        DMG=TMP(1)
        DMT=TMP(2)
        DMZ=TMP(3)
        DMT1=TMP(4)
        DMT2=TMP(5)
        PT=DSQRT(DET**2-DMT**2)
        TOPS=SSDLAM(DMG**2+DMT**2-2*DMG*DET,DMT**2,DMZ**2)
        TOP=DSQRT(DMAX1(0.D0,TOPS))
        BOT=(DMG**2+DMT**2-2*DMG*DET-DMT1**2)*
     $      (DMG**2+DMT**2-2*DMG*DET-DMT2**2)
        DXT7=PI**2/2.D0*PT*(DMG**2-DMZ**2-2*DMG*DET)/
     $      (DMG**2-2*DMG*DET+DMT**2)*TOP/BOT
        SSGX7=DXT7
        RETURN
        END
CDECK  ID>, SSGX8.  
        REAL FUNCTION SSGX8(ET)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> ziss + tp + tb
C          Baer's XT8 - Y- eq. a.6.h of prd45,142 (1992)
C          Modified for t_1 and t_2 eigenstates
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL ET
        DOUBLE PRECISION DET,DMG,DMT,DMZ,DMT1,DMT2,TOP,BOT,DXT8
        DOUBLE PRECISION XT,MUT,MUZ,XMIN,XMAX,EMIN,EMAX,SSDLAM
        DOUBLE PRECISION PI
        DATA PI/3.14159265D0/
        DET=ET
        DMG=TMP(1)
        DMT=TMP(2)
        DMZ=TMP(3)
        DMT1=TMP(4)
        DMT2=TMP(5)
        XT=2*DET/DMG
        MUT=(DMT/DMG)**2
        MUZ=(DMZ/DMG)**2
        XMIN=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)-DSQRT(DMAX1(0.D0,
     $   (XT**2-4*MUT)*SSDLAM((1.D0+MUT-XT),MUT,MUZ))))
     $   /2.D0/(1.D0-XT+MUT)
        XMAX=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)+DSQRT(DMAX1(0.D0,
     $   (XT**2-4*MUT)*SSDLAM((1.D0+MUT-XT),MUT,MUZ))))
     $   /2.D0/(1.D0-XT+MUT)
        EMIN=XMIN*DMG/2.D0
        EMAX=XMAX*DMG/2.D0
        TOP=DMG**2-2*DMG*EMAX+DMT**2-DMT2**2
        BOT=DMG**2-2*DMG*EMIN+DMT**2-DMT2**2
        DXT8=((EMAX-EMIN)*(DMG**2-2*DMG*DET+DMT**2)+
     $        (DMZ**2*DMG**2-DMT2**2*DMG**2+2*DMT2**2*DMG*DET+DMT**4
     $         -DMT2**2*DMT**2)/2.D0/DMG*DLOG(TOP/BOT))*PI**2/2.D0/
     $         (DMG**2+DMT**2-2*DMG*DET-DMT1**2)
        SSGX8=DXT8
        RETURN
        END
CDECK  ID>, SSGX9.  
        REAL FUNCTION SSGX9(ET)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> ziss + tp + tb
C          Baer's XT9 - XI'- eq. a.6.i of prd45,142 (1992)
C          Modified for t_1 and t_2 eigenstates
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL ET
        DOUBLE PRECISION DET,DMG,DMT,DMZ,DMT1,DMT2,TOP,BOT,DXT9
        DOUBLE PRECISION XT,MUT,MUZ,XMIN,XMAX,EMIN,EMAX,SSDLAM
        DOUBLE PRECISION PI
        DATA PI/3.14159265D0/
        DET=ET
        DMG=TMP(1)
        DMT=TMP(2)
        DMZ=TMP(3)
        DMT1=TMP(4)
        DMT2=TMP(5)
        XT=2*DET/DMG
        MUT=(DMT/DMG)**2
        MUZ=(DMZ/DMG)**2
        XMIN=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)-DSQRT(DMAX1(0.D0,
     $   (XT**2-4*MUT)*SSDLAM((1.D0+MUT-XT),MUT,MUZ))))
     $   /2.D0/(1.D0-XT+MUT)
        XMAX=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)+DSQRT(DMAX1(0.D0,
     $   (XT**2-4*MUT)*SSDLAM((1.D0+MUT-XT),MUT,MUZ))))
     $   /2.D0/(1.D0-XT+MUT)
        EMIN=XMIN*DMG/2.D0
        EMAX=XMAX*DMG/2.D0
        TOP=DMG**2-2*DMG*EMAX+DMT**2-DMT1**2
        BOT=DMG**2-2*DMG*EMIN+DMT**2-DMT1**2
        DXT9=-PI**2*DET*DLOG(TOP/BOT)/2.D0/(DMG**2-2*DMG*DET+DMT**2
     $         -DMT2**2)
        SSGX9=DXT9
        RETURN
        END
CDECK  ID>, SSGZG1. 
        REAL FUNCTION SSGZG1(XARG)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> ziss + gl
C          Baer's FUNI- removed mass dependence to simplify
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL XARG
        DOUBLE PRECISION TOP,BOT,XX,F,MQ,MX,MS,MG
C
        MQ=TMP(1)
        MX=TMP(2)
        MS=TMP(3)
        MG=AMGLSS
C
        XX=XARG
        TOP=-MG**2*XX*(1.D0-XX)+MS**2*XX+MQ**2*(1.D0-XX)
        BOT=-MX**2*XX*(1.D0-XX)+MS**2*XX+MQ**2*(1.D0-XX)
        F=DLOG(TOP/BOT)/XX
        SSGZG1=F
        RETURN
        END
CDECK  ID>, SSGZG2. 
        REAL FUNCTION SSGZG2(XARG)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> ziss + gl
C          Baer's FUNI1- removed masses to simplify
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL XARG
        DOUBLE PRECISION TOP,BOT,XX,F,MQ,MX,MS,MG
C
        MQ=TMP(1)
        MX=TMP(2)
        MS=TMP(3)
        MG=AMGLSS
C
        XX=XARG
        TOP=-MG**2*XX*(1.D0-XX)+MS**2*XX+MQ**2*(1.D0-XX)
        BOT=-MX**2*XX*(1.D0-XX)+MS**2*XX+MQ**2*(1.D0-XX)
        F=DLOG(TOP/BOT)
        SSGZG2=F
        RETURN
        END
CDECK  ID>, SSGZG3. 
        REAL FUNCTION SSGZG3(XARG)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> ziss + gl
C          Baer's FUNK - remove masses to simplify
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL XARG
        DOUBLE PRECISION TOP,BOT,XX,F,MQ,MX,MS,MG
C
        MQ=TMP(1)
        MX=TMP(2)
        MS=TMP(3)
        MG=AMGLSS
C
        XX=XARG
        TOP=-MG**2*XX*(1.D0-XX)+MS**2*XX+MQ**2*(1.D0-XX)
        BOT=-MX**2*XX*(1.D0-XX)+MS**2*XX+MQ**2*(1.D0-XX)
        F=-1.D0-BOT/(MG**2-MX**2)/XX/(1.D0-XX)*DLOG(TOP/BOT)
        SSGZG3=F
        RETURN
        END
CDECK  ID>, SSGZT.  
        REAL FUNCTION SSGZT(E)
C-----------------------------------------------------------------------
C          SSGLBF: glss -> ziss + tp + tb
C          Baer's TOPINT
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      REAL E
      DOUBLE PRECISION MG,MT,MS,MZ,SSDLAM,P,PSI,XLOG,PHI,SN,C1,C2
      DOUBLE PRECISION XT,MUT,MUZ,XMIN,XMAX,EMIN,EMAX
C          Convert to double precision
      MG=AMGLSS
      C1=TMP(1)
      C2=TMP(2)
      MS=TMP(3)
      MT=TMP(4)
      MZ=TMP(5)
      SN=TMP(6)
C
      XT=2*E/MG
      MUT=(MT/MG)**2
      MUZ=(MZ/MG)**2
      XMIN=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)-DSQRT((XT**2-4*MUT)*
     $SSDLAM((1.D0+MUT-XT),MUT,MUZ)))/2.D0/(1.D0-XT+MUT)
      XMAX=((2.D0-XT)*(1.D0+2*MUT-MUZ-XT)+DSQRT((XT**2-4*MUT)*
     $SSDLAM((1.D0+MUT-XT),MUT,MUZ)))/2.D0/(1.D0-XT+MUT)
      EMIN=XMIN*MG/2.D0
      EMAX=XMAX*MG/2.D0
      P=SQRT(E**2-MT**2)
      PSI=P*E*(MG**2-MZ**2-2*MG*E)*
     $DSQRT(SSDLAM((MG**2+MT**2-2*MG*E),MZ**2,MT**2))/MG/
     $(MG**2+MT**2-2*MG*E)/(MG**2+MT**2-2*MG*E-MS**2)**2
      XLOG=DLOG((MG**2+MT**2-2*MG*EMAX-MS**2)/
     $(MG**2+MT**2-2*MG*EMIN-MS**2))
      PHI=MZ*(-(EMAX-EMIN)-(2*E*MG+MZ**2-MT**2-MS**2)*
     $XLOG/2.D0/MG)/
     $2.D0/MG/(MG**2+MT**2-MS**2-2*MG*E)
      SSGZT=C1*PSI+SN*C2*PHI
      RETURN
      END
CDECK  ID>, SSHCC.  
      SUBROUTINE SSHCC
C-----------------------------------------------------------------------
C     Calculates the decay widths of all neutral Higgses into all
C     possible pairs of charginos.
C
C     Bisset's CHGINO
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C
      DOUBLE PRECISION PI,SR2,XM,THETX,YM,THETY,SGL,CGL,SGR,CGR
     $,MW1,MW2,THETM,THETP,G2,GP2,BETA,ALPHA,T1,MH,M1,M2,LAMB
     $,DWID,TEMP,TEMPXY
      DOUBLE PRECISION MHI(3),IDHI(3),SHP(3),SHM(3),SH(3),PH(3)
      DOUBLE PRECISION SSDLAM
      REAL WID
      INTEGER NUMH,IDH
C
      PI=4.*ATAN(1.D0)
      SR2=SQRT(2.D0)
      XM=1./TAN(GAMMAL)
      THETX=SIGN(1.D0,XM)
      YM=1./TAN(GAMMAR)
      THETY=SIGN(1.D0,YM)
      SGL=1/(DSQRT(1+XM**2))
      CGL=SGL*XM
      SGR=1/(DSQRT(1+YM**2))
      CGR=SGR*YM
      MW1=DBLE(ABS(AMW1SS))
      MW2=DBLE(ABS(AMW2SS))
      THETM=SIGN(1.,AMW1SS)
      THETP=SIGN(1.,AMW2SS)
      G2=4*PI*ALFAEM/SN2THW
      GP2=4*PI*ALFAEM/(1-SN2THW)
      BETA=ATAN(1.0/RV2V1)
      ALPHA=ALFAH
C
C          Arrays for loops
C
      MHI(1)=AMHL
      MHI(2)=AMHH
      MHI(3)=AMHA
      IDHI(1)=ISHL
      IDHI(2)=ISHH
      IDHI(3)=ISHA
C          The following came from Bisset's MASZIN, but with L,H,P
C          replaced by a generic H and a subscript.
      TEMPXY=0.5*THETX*THETY*(-THETP)
      SHP(1)=SIN(ALPHA)*CGR*SGL+COS(ALPHA)*CGL*SGR
      SHP(1)=SHP(1)*TEMPXY
      SHM(1)=SIN(ALPHA)*SGR*CGL+COS(ALPHA)*SGL*CGR
      SHM(1)=SHM(1)*0.5*THETM
      SH(1)=-THETX*SGR*SGL*SIN(ALPHA)*THETM
      PH(1)=-SH(1)
      T1=THETX*CGL*CGR*COS(ALPHA)*THETM
      SH(1)=SH(1)+T1
      PH(1)=PH(1)-T1
      T1=THETY*SGL*SGR*COS(ALPHA)*THETP
      SH(1)=SH(1)-T1
      PH(1)=PH(1)-T1
      T1=THETY*CGL*CGR*SIN(ALPHA)*THETP
      SH(1)=SH(1)+T1
      PH(1)=PH(1)+T1
      SH(1)=0.5*SH(1)
      PH(1)=0.5*PH(1)
      SHP(2)=COS(ALPHA)*CGR*SGL-SIN(ALPHA)*CGL*SGR
      SHP(2)=SHP(2)*TEMPXY
      SHM(2)=COS(ALPHA)*SGR*CGL-SIN(ALPHA)*SGL*CGR
      SHM(2)=SHM(2)*0.5*THETM
      SH(2)=-THETX*SGR*SGL*COS(ALPHA)*THETM
      PH(2)=-SH(2)
      T1=THETX*CGL*CGR*SIN(ALPHA)*THETM
      SH(2)=SH(2)-T1
      PH(2)=PH(2)+T1
      T1=THETY*SGL*SGR*SIN(ALPHA)*THETP
      SH(2)=SH(2)+T1
      PH(2)=PH(2)+T1
      T1=THETY*CGL*CGR*COS(ALPHA)*THETP
      SH(2)=SH(2)+T1
      PH(2)=PH(2)+T1
      SH(2)=0.5*SH(2)
      PH(2)=0.5*PH(2)
      SHP(3)=SIN(BETA)*CGR*SGL+COS(BETA)*CGL*SGR
      SHP(3)=SHP(3)*0.5*THETX*THETY*(-THETP)
      SHM(3)=SIN(BETA)*SGR*CGL+COS(BETA)*SGL*CGR
      SHM(3)=SHM(3)*0.5*THETM
      SH(3)=-THETX*SGR*SGL*SIN(BETA)*THETM
      PH(3)=-SH(3)
      T1=THETX*CGL*CGR*COS(BETA)*THETM
      SH(3)=SH(3)+T1
      PH(3)=PH(3)-T1
      T1=THETY*SGL*SGR*COS(BETA)*THETP
      SH(3)=SH(3)+T1
      PH(3)=PH(3)+T1
      T1=THETY*CGL*CGR*SIN(BETA)*THETP
      SH(3)=SH(3)-T1
      PH(3)=PH(3)-T1
      SH(3)=0.5*SH(3)
      PH(3)=0.5*PH(3)
C
C          Loop over neutral Higgs
C
      DO 100 NUMH=1,3
        MH=MHI(NUMH)
        IDH=IDHI(NUMH)
C          w1 + w1
        M1=ABS(AMW1SS)
        M2=M1
        IF(MH.GT.M1+M2) THEN
          LAMB=SSDLAM(MH**2,M1**2,M2**2)
          TEMP=1-4*M1**2/MH**2
          DWID=G2*MH*SHM(NUMH)**2/(4.0*PI)
          DWID=DWID*SQRT(TEMP**3)
          WID=DWID
          CALL SSSAVE(IDH,WID,ISW1,-ISW1,0,0,0)
        ENDIF
C          w2 + w2
        M1=ABS(AMW2SS)
        M2=M1
        IF(MH.GT.M1+M2) THEN
          TEMP=1-4*M1**2/MH**2
          DWID=G2*MH*SHP(NUMH)**2/(4*PI)
          DWID=DWID*SQRT(TEMP**3)
          WID=DWID
          CALL SSSAVE(IDH,WID,ISW2,-ISW2,0,0,0)
        ENDIF
C          w1 + w2
        M1=ABS(AMW1SS)
        M2=ABS(AMW2SS)
        IF(MH.GT.M1+M2) THEN
          LAMB=SSDLAM(MH**2,M1**2,M2**2)
          DWID=PH(NUMH)**2*(MH**2-(M1-M2)**2)
          DWID=DWID+SH(NUMH)**2*(MH**2-(M1+M2)**2)
          DWID=DWID*G2*SQRT(LAMB)/(16.0*PI*(MH**3))
          WID=DWID
          CALL SSSAVE(IDH,WID,ISW1,-ISW2,0,0,0)
          CALL SSSAVE(IDH,WID,-ISW1,ISW2,0,0,0)
        ENDIF
100   CONTINUE
C
      RETURN
      END
CDECK  ID>, SSHFF.  
      SUBROUTINE SSHFF
C-----------------------------------------------------------------------
C
C     Calculate all decays higgs -> f fbar, including QCD radiative
C     corrections for quarks.
C
C     Bisset's SETFAC, WDHFFN, QCDRAD
C
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C
      DOUBLE PRECISION PI,SR2,G2,DWID,MHIH,BETA,BEFAC,ALFAC,MH,MF
     $,MFRUN,FACTOR,ALAM,MF1,MF2,SUM,MF1RUN,MF2RUN,COLOR,TEMP1
     $,QCDFAC
      DOUBLE PRECISION MFIFF(9),MFIF1(6),MFIF2(6)
      DOUBLE PRECISION SSDLAM,SSMQCD,SSHFF1
      REAL WID
      INTEGER IH,IDIH,IFF,IDF,ID1,ID2
      INTEGER IDIFF(9),IDIF1(6),IDIF2(6)
C
      PI=4.*ATAN(1.)
      SR2=SQRT(2.)
      BETA=ATAN(1./RV2V1)
      G2=4.0*PI*ALFAEM/SN2THW
C
C          Loop over HL, HH, HA and fermions
C
      MFIFF(1)=AME
      IDIFF(1)=IDE
      MFIFF(2)=AMMU
      IDIFF(2)=IDMU
      MFIFF(3)=AMTAU
      IDIFF(3)=IDTAU
      MFIFF(4)=AMDN
      IDIFF(4)=IDDN
      MFIFF(5)=AMST
      IDIFF(5)=IDST
      MFIFF(6)=AMBT
      IDIFF(6)=IDBT
      MFIFF(7)=AMUP
      IDIFF(7)=IDUP
      MFIFF(8)=AMCH
      IDIFF(8)=IDCH
      MFIFF(9)=AMTP
      IDIFF(9)=IDTP
C
      DO 100 IH=1,3
        IF(IH.EQ.1) THEN
          MH=AMHL
          IDIH=ISHL
          BEFAC=COS(BETA)
          ALFAC=SIN(ALFAH)
        ELSEIF(IH.EQ.2) THEN
          MH=AMHH
          IDIH=ISHH
          BEFAC=COS(BETA)
          ALFAC=COS(ALFAH)
        ELSE
          MH=AMHA
          IDIH=ISHA
          BEFAC=1/TAN(BETA)
          ALFAC=1.
        ENDIF
C
C          Down type fermions
C
        DO 110 IFF=1,6
          MF=MFIFF(IFF)
          IDF=IDIFF(IFF)
          FACTOR=1.-4.*MF**2/MH**2
          IF(FACTOR.LE.0) GO TO 110
          FACTOR=SQRT(FACTOR)
          IF(IFF.GE.4) THEN
             COLOR=3.
             MFRUN=SSMQCD(MF,MH)
             QCDFAC=SSHFF1(MH,MF,IH)
          ELSE
             COLOR=1.
             MFRUN=MF
             QCDFAC=1.
          ENDIF
          DWID=G2*MFRUN**2*MH*ALFAC**2/(32.*PI*AMW**2*BEFAC**2)
          IF(IH.EQ.1.OR.IH.EQ.2) THEN
            DWID=DWID*FACTOR**3
          ELSEIF(IH.EQ.3) THEN
            DWID=DWID*FACTOR
          ENDIF
          DWID=DWID*COLOR*QCDFAC
          WID=DWID
          CALL SSSAVE(IDIH,WID,IDF,-IDF,0,0,0)
110     CONTINUE
C
C          Up type fermions
C
        IF(IH.EQ.1) THEN
          BEFAC=SIN(BETA)
          ALFAC=COS(ALFAH)
        ELSEIF(IH.EQ.2) THEN
          BEFAC=SIN(BETA)
          ALFAC=SIN(ALFAH)
        ELSE
          BEFAC=TAN(BETA)
          ALFAC=1.
        ENDIF
        DO 120 IFF=7,9
          MF=MFIFF(IFF)
          IDF=IDIFF(IFF)
          FACTOR=1.-4.*MF**2/MH**2
          IF(FACTOR.LE.0) GO TO 120
          FACTOR=SQRT(FACTOR)
          MFRUN=SSMQCD(MF,MH)
          QCDFAC=SSHFF1(MH,MF,IH)
          DWID=G2*MFRUN**2*MH*ALFAC**2/(32.*PI*AMW**2*BEFAC**2)
          IF(IH.EQ.1.OR.IH.EQ.2) THEN
            DWID=DWID*FACTOR**3
          ELSEIF(IH.EQ.3) THEN
            DWID=DWID*FACTOR
          ENDIF
          DWID=3.*DWID*QCDFAC
          WID=DWID
          CALL SSSAVE(IDIH,WID,IDF,-IDF,0,0,0)
120     CONTINUE
100   CONTINUE
C
C           HC decays. F1 has Iz=+1/2, F2 has Iz=-1/2
C
      MFIF1(1)=0
      IDIF1(1)=IDNE
      MFIF2(1)=AME
      IDIF2(1)=IDE
      MFIF1(2)=0
      IDIF1(2)=IDNM
      MFIF2(2)=AMMU
      IDIF2(2)=IDMU
      MFIF1(3)=0
      IDIF1(3)=IDNT
      MFIF2(3)=AMTAU
      IDIF2(3)=IDTAU
      MFIF1(4)=AMUP
      IDIF1(4)=IDUP
      MFIF2(4)=AMDN
      IDIF2(4)=IDDN
      MFIF1(5)=AMCH
      IDIF1(5)=IDCH
      MFIF2(5)=AMST
      IDIF2(5)=IDST
      MFIF1(6)=AMTP
      IDIF1(6)=IDTP
      MFIF2(6)=AMBT
      IDIF2(6)=IDBT
      MH=AMHC
C
      DO 200 IFF=1,6
        MF1=MFIF1(IFF)
        MF2=MFIF2(IFF)
        ID1=IDIF1(IFF)
        ID2=IDIF2(IFF)
        SUM=MF1+MF2
        ALAM=SSDLAM(MH**2,MF1**2,MF2**2)
        IF(ALAM.LE.0.OR.SUM.GE.MH) GO TO 200
        IF(IFF.LE.3) THEN
          MF1RUN=MF1
          MF2RUN=MF2
          COLOR=1
        ELSE
          MF1RUN=SSMQCD(MF1,MH)
          MF2RUN=SSMQCD(MF2,MH)
          COLOR=3
        ENDIF
        TEMP1=MF1RUN**2*1./TAN(BETA)**2+MF2RUN**2*TAN(BETA)**2
        TEMP1=TEMP1*(MH**2-MF1**2-MF2**2)-4.*MF1**2*MF2**2
        IF (TEMP1.LT.0.0) GO TO 200
        DWID=G2*COLOR*SQRT(ALAM)*TEMP1/MH**3/(32.0*PI*AMW**2)
        WID=DWID
        CALL SSSAVE(ISHC,WID,ID1,-ID2,0,0,0)
200   CONTINUE
C
      RETURN
      END
CDECK  ID>, SSHFF1. 
      DOUBLE PRECISION FUNCTION SSHFF1(MH,MF,NUMH)
C-----------------------------------------------------------------------
C     Calculate QCD radiative correction factor, the square brackets
C     in (4.5) of Drees and Hikasa, Phys. Lett. B240, 455 (1990).
C
C     Bisset's QCDRAD (partial)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C
      DOUBLE PRECISION MH,MF
      DOUBLE PRECISION BETA00,LIXX,LI2PP,LI2MM,TEMP,DELTAP,AS,CF
     $,INPOL,PI,ACAP,DELTAH
      DOUBLE PRECISION DDILOG,SSALFS
      INTEGER NUMH
C
      PI=4*ATAN(1.D0)
      BETA00=SQRT(1-4*MF**2/MH**2)
      LIXX=(1-BETA00)/(1+BETA00)
      LI2PP=DDILOG(LIXX)
      LI2MM=DDILOG(-LIXX)
      TEMP=-3*LOG(1/LIXX)*LOG(2/(1+BETA00))
      TEMP=TEMP-2*LOG(BETA00)*LOG(1/LIXX)
      TEMP=TEMP+4*LI2PP+2*LI2MM
      ACAP=(1+BETA00**2)*TEMP
      ACAP=ACAP-3*BETA00*LOG(4/(1-BETA00**2))
      ACAP=ACAP-4*BETA00*LOG(BETA00)
      IF (NUMH.EQ.3) THEN
         TEMP=19+2*BETA00**2+3*BETA00**4
         TEMP=TEMP*LOG(1/LIXX)/(16*BETA00)
         DELTAP=TEMP+3*(7-BETA00**2)/8
         DELTAP=DELTAP+ACAP/BETA00
       ELSE
         TEMP=3+34*BETA00**2-13*BETA00**4
         TEMP=TEMP*LOG(1/LIXX)/(16*BETA00**3)
         DELTAH=3*(-1+7*BETA00**2)/(8*BETA00**2)
         DELTAH=DELTAH+TEMP+ACAP/BETA00
       ENDIF
       IF (NUMH.EQ.3) THEN
         INPOL=DELTAP+1.5D0*LOG(MH**2/MF**2)
       ELSE
         INPOL=DELTAH+1.5D0*LOG(MH**2/MF**2)
       ENDIF
       AS=SSALFS(MH**2)
       CF=4.D0/3.D0
       SSHFF1=INPOL*CF*AS/PI+1
      RETURN
      END
CDECK  ID>, SSHGL.  
      SUBROUTINE SSHGL
C-----------------------------------------------------------------------
C
C     Calculate H -> gl gl decays including both SM particles and
C     SUSY particles in loop.
C
C     This subroutine uses the tau variable of the Higgs Hunters'
C     Guide.  Many other authors, including the paper cited in
C     Higgs Hunters' Guide (PR. D. 38(11): 3481) and Collider Physics
C     by Barger and Phillips use the variable lambda
C          LAMBDA = ( MASS OF PARTICLE IN LOOP / MASS OF HIGGS )**2
C          TAU = 4.0 * LAMBDA
C
C     Bisset's HGLGL
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C
      DOUBLE PRECISION ETAH,IITOT,RITOT,TAU,IFFF,RFFF
     $,IFHALF,RFHALF,IF1,RF1,IF0,RF0,TW2,RHF,RHSF,RHSFL,RHSFR
     $,IIHF,RIHF,IIHSFL,RIHSFL,IIHSFR,RIHSFR,AS,SUMISQ,DW
     $,RHSF1,RHSF2,IIHSF1,IIHSF2,RIHSF1,RIHSF2
      DOUBLE PRECISION PI,SR2,XM,THETX,YM,THETY,SGL,CGL,SGR,CGR
     $,MW1,MW2,THETM,THETP,G2,BETA,ALPHA,SW2,CW2,MH,AMSQ
      DOUBLE PRECISION MFL(3),MFD(3),MFU(3)
      DOUBLE PRECISION SSALFS
      REAL WID
      REAL ASMB,MBMB,MBQ,ASMT,MTMT,MTQ,SUALFS
      DOUBLE PRECISION SSMQCD
      INTEGER IJ,II,NUMOUT,NUMH,IDH
C
C          Mass matrix parameters
C
      PI=4.*ATAN(1.D0)
      SR2=SQRT(2.D0)
      XM=1./TAN(GAMMAL)
      THETX=SIGN(1.D0,XM)
      YM=1./TAN(GAMMAR)
      THETY=SIGN(1.D0,YM)
      SGL=1/(DSQRT(1+XM**2))
      CGL=SGL*XM
      SGR=1/(DSQRT(1+YM**2))
      CGR=SGR*YM
      MW1=DBLE(ABS(AMW1SS))
      MW2=DBLE(ABS(AMW2SS))
      THETM=SIGN(1.,AMW1SS)
      THETP=SIGN(1.,AMW2SS)
      G2=4.0*PI*ALFAEM/SN2THW
      BETA=ATAN(1.0/RV2V1)
      ALPHA=ALFAH
      SW2=SN2THW
      CW2=1.-SN2THW
C
C          Loop over neutral Higgs bosons
C
      DO 100 NUMH=1,3
        IF(NUMH.EQ.1) THEN
          MH=AMHL
          IDH=ISHL
        ELSEIF(NUMH.EQ.2) THEN
          MH=AMHH
          IDH=ISHH
        ELSE
          MH=AMHA
          IDH=ISHA
        ENDIF
        ETAH=1.0
        IITOT=0.0
        RITOT=0.0
C
      ASMB=SUALFS(AMBT**2,.36,AMTP,3)
      MBMB=AMBT*(1.-4*ASMB/3./PI)
      MBQ=SSMQCD(DBLE(MBMB),DBLE(MH))
      ASMT=SUALFS(AMTP**2,.36,AMTP,3)
      MTMT=AMTP/(1.+4*ASMT/3./PI+(16.11-1.04*(5.-6.63/AMTP))*
     $(ASMT/PI)**2)
      MTQ=SSMQCD(DBLE(MTMT),DBLE(MH))

C
      MFL(1)=DBLE(AME)
      MFL(2)=DBLE(AMMU)
      MFL(3)=DBLE(AMTAU)
      MFD(1)=DBLE(AMDN)
      MFD(2)=DBLE(AMST)
      MFD(3)=DBLE(MBQ)
      MFU(1)=DBLE(AMUP)
      MFU(2)=DBLE(AMCH)
      MFU(3)=DBLE(MTQ)
C
C
C          Down-type quark loops
C
        DO 20 II=1,3
          TAU=4.0*MFD(II)**2/MH**2
          CALL SSHGM1(TAU,IFFF,RFFF)
          IFHALF=0.5*TAU*(1.0-TAU*ETAH)*IFFF
          RFHALF=0.5*TAU*(ETAH+(1.0-TAU*ETAH)*RFFF)
          IF(NUMH.EQ.1) THEN
            RHF=SIN(ALPHA)/COS(BETA)
          ELSEIF(NUMH.EQ.2) THEN
            RHF=COS(ALPHA)/COS(BETA)
          ELSE
            RHF=TAN(BETA)
          ENDIF
          IIHF=RHF*IFHALF
          RIHF=RHF*RFHALF
          IITOT=IITOT+IIHF
          RITOT=RITOT+RIHF
20      CONTINUE
C
C          Up-type quark loops
C
        DO 30 II=1,2
          TAU=4.0*MFU(II)**2/MH**2
          CALL SSHGM1(TAU,IFFF,RFFF)
          IFHALF=0.5*TAU*(1.0-TAU*ETAH)*IFFF
          RFHALF=0.5*TAU*(ETAH+(1.0-TAU*ETAH)*RFFF)
          IF(NUMH.EQ.1) THEN
            RHF=COS(ALPHA)/SIN(BETA)
          ELSEIF(NUMH.EQ.2) THEN
            RHF=-SIN(ALPHA)/SIN(BETA)
          ELSE
            RHF=TAN(BETA)
          ENDIF
          IIHF=RHF*IFHALF
          RIHF=RHF*RFHALF
          IITOT=IITOT+IIHF
          RITOT=RITOT+RIHF
30      CONTINUE
C
        TAU=4.0*MTQ**2/MH**2
        CALL SSHGM1(TAU,IFFF,RFFF)
        IFHALF=0.5*TAU*(1.0-TAU*ETAH)*IFFF
        RFHALF=0.5*TAU*(ETAH+(1.0-TAU*ETAH)*RFFF)
        IF(NUMH.EQ.1) THEN
          RHF=COS(ALPHA)/SIN(BETA)
        ELSEIF(NUMH.EQ.2) THEN
          RHF=-SIN(ALPHA)/SIN(BETA)
        ELSE
          RHF=1.0/TAN(BETA)
        ENDIF
        IIHF=RHF*IFHALF
        RIHF=RHF*RFHALF
        IITOT=IITOT+IIHF
        RITOT=RITOT+RIHF
C
C          Down-type squark loops
C          Mixing between the sbottom squarks is included, so
C          masses used here are the mixed masses (AMB1SS & AMB2SS)
C          First do d_L and s_L squarks
        TW2=SW2/CW2
        DO 50 II=1,2
          IF(NUMH.EQ.1) THEN
            RHSF=2.0*(MFD(II)/AMW)**2*SIN(ALPHA)/COS(BETA)
            RHSFL=(-1.0-TW2/3.0)*SIN(BETA-ALPHA)-RHSF
          ELSEIF(NUMH.EQ.2) THEN
            RHSF=2.0*(MFD(II)/AMW)**2*COS(ALPHA)/COS(BETA)
            RHSFL=(-1.0-TW2/3.0)*(-1.0)*COS(BETA-ALPHA)-RHSF
          ELSE
            RHSF=0
            RHSFL=0
          ENDIF
          IF (II.EQ.1) AMSQ=AMDLSS
          IF (II.EQ.2) AMSQ=AMSLSS
          TAU=4.0*AMSQ**2/MH**2
          CALL SSHGM1(TAU,IFFF,RFFF)
          IF0=-TAU*TAU*IFFF
          RF0=TAU*(1.0-TAU*RFFF)
          IIHSFL=RHSFL*IF0*(AMW/AMSQ)**2/8.0
          RIHSFL=RHSFL*RF0*(AMW/AMSQ)**2/8.0
          IITOT=IITOT+IIHSFL
          RITOT=RITOT+RIHSFL
50      CONTINUE
c       Next, do R squarks
        DO 51 II=1,2
          IF(NUMH.EQ.1) THEN
            RHSF=2.0*(MFD(II)/AMW)**2*SIN(ALPHA)/COS(BETA)
            RHSFR=(-2.0*TW2/3.0)*SIN(BETA-ALPHA)-RHSF
          ELSEIF(NUMH.EQ.2) THEN
            RHSF=2.0*(MFD(II)/AMW)**2*COS(ALPHA)/COS(BETA)
            RHSFR=(-2.0*TW2/3.0)*(-1.0)*COS(BETA-ALPHA)-RHSF
          ELSE
            RHSF=0
            RHSFR=0
          ENDIF
          IF (II.EQ.1) AMSQ=AMDRSS
          IF (II.EQ.2) AMSQ=AMSRSS
          TAU=4.0*AMSQ**2/MH**2
          CALL SSHGM1(TAU,IFFF,RFFF)
          IF0=-TAU*TAU*IFFF
          RF0=TAU*(1.0-TAU*RFFF)
          IIHSFR=RHSFR*IF0*(AMW/AMSQ)**2/8.0
          RIHSFR=RHSFR*RF0*(AMW/AMSQ)**2/8.0
          IITOT=IITOT+IIHSFR
          RITOT=RITOT+RIHSFR
51      CONTINUE
        IF(NUMH.EQ.1) THEN
          RHSF=2.0*(MBQ/AMW)**2*SIN(ALPHA)/COS(BETA)
          RHSFL=(-1.0-TW2/3.0)*SIN(BETA-ALPHA)-RHSF
          RHSFR=(-2.0*TW2/3.0)*SIN(BETA-ALPHA)-RHSF
        ELSEIF(NUMH.EQ.2) THEN
          RHSF=2.0*(MBQ/AMW)**2*COS(ALPHA)/COS(BETA)
          RHSFL=(-1.0-TW2/3.0)*(-1.0)*COS(BETA-ALPHA)-RHSF
          RHSFR=(-2.0*TW2/3.0)*(-1.0)*COS(BETA-ALPHA)-RHSF
        ELSE
          RHSF=0
          RHSFL=0
          RHSFR=0
        ENDIF
        RHSF1=RHSFL*COS(THETAB)-RHSFR*SIN(THETAB)
        RHSF2=RHSFL*SIN(THETAB)+RHSFR*COS(THETAB)
        TAU=4.0*AMB1SS**2/MH**2
        CALL SSHGM1(TAU,IFFF,RFFF)
        IF0=-TAU*TAU*IFFF
        RF0=TAU*(1.0-TAU*RFFF)
        IIHSF1=RHSF1*IF0*(AMW/AMB1SS)**2/8.0
        RIHSF1=RHSF1*RF0*(AMW/AMB1SS)**2/8.0
        IITOT=IITOT+IIHSF1
        RITOT=RITOT+RIHSF1
        TAU=4.0*AMB2SS**2/MH**2
        CALL SSHGM1(TAU,IFFF,RFFF)
        IF0=-TAU*TAU*IFFF
        RF0=TAU*(1.0-TAU*RFFF)
        IIHSF2=RHSF2*IF0*(AMW/AMB2SS)**2/8.0
        RIHSF2=RHSF2*RF0*(AMW/AMB2SS)**2/8.0
        IITOT=IITOT+IIHSF2
        RITOT=RITOT+RIHSF2
C
C          Up-type squark loops
C          Mixing between the stop squarks is included, so
C          masses used here are the mixed masses (AMT1SS & AMT2SS)
C          First do u_L and c_L
        DO 60 II=1,2
          IF(NUMH.EQ.1) THEN
            RHSF=2.0*(MFU(II)/AMW)**2*COS(ALPHA)/SIN(BETA)
            RHSFL=(1.0-TW2/3.0)*SIN(BETA-ALPHA)-RHSF
          ELSEIF(NUMH.EQ.2) THEN
            RHSF=2.0*(MFU(II)/AMW)**2
            RHSF=RHSF*(-1.0)*SIN(ALPHA)/SIN(BETA)
            RHSFL=(1.0-TW2/3.0)*(-1.0)*COS(BETA-ALPHA)-RHSF
          ELSE
            RHSF=0
            RHSFL=0
          ENDIF
          IF (II.EQ.1) AMSQ=AMULSS
          IF (II.EQ.2) AMSQ=AMCLSS
          TAU=4.0*(AMSQ)**2/MH**2
          CALL SSHGM1(TAU,IFFF,RFFF)
          IF0=-TAU*TAU*IFFF
          RF0=TAU*(1.0-TAU*RFFF)
          IIHSFL=RHSFL*IF0*(AMW/AMSQ)**2/8.0
          RIHSFL=RHSFL*RF0*(AMW/AMSQ)**2/8.0
          IITOT=IITOT+IIHSFL
          RITOT=RITOT+RIHSFL
60      CONTINUE
C          Next, do u_R and c_R
        DO 61 II=1,2
          IF(NUMH.EQ.1) THEN
            RHSF=2.0*(MFU(II)/AMW)**2*COS(ALPHA)/SIN(BETA)
            RHSFR=(4.0*TW2/3.0)*SIN(BETA-ALPHA)-RHSF
          ELSEIF(NUMH.EQ.2) THEN
            RHSF=2.0*(MFU(II)/AMW)**2
            RHSF=RHSF*(-1.0)*SIN(ALPHA)/SIN(BETA)
            RHSFR=(4.0*TW2/3.0)*(-1.0)*COS(BETA-ALPHA)-RHSF
          ELSE
            RHSF=0
            RHSFR=0
          ENDIF
          IF (II.EQ.1) AMSQ=AMURSS
          IF (II.EQ.2) AMSQ=AMCRSS
          TAU=4.0*(AMSQ)**2/MH**2
          CALL SSHGM1(TAU,IFFF,RFFF)
          IF0=-TAU*TAU*IFFF
          RF0=TAU*(1.0-TAU*RFFF)
          IIHSFR=RHSFR*IF0*(AMW/AMSQ)**2/8.0
          RIHSFR=RHSFR*RF0*(AMW/AMSQ)**2/8.0
          IITOT=IITOT+IIHSFR
          RITOT=RITOT+RIHSFR
61      CONTINUE
C
        IF(NUMH.EQ.1) THEN
          RHSF=2.0*(MTQ/AMW)**2*COS(ALPHA)/SIN(BETA)
          RHSFL=(1.0-TW2/3.0)*SIN(BETA-ALPHA)-RHSF
          RHSFR=(4.0*TW2/3.0)*SIN(BETA-ALPHA)-RHSF
        ELSEIF(NUMH.EQ.2) THEN
          RHSF=2.0*(MTQ/AMW)**2
          RHSF=RHSF*(-1.0)*SIN(ALPHA)/SIN(BETA)
          RHSFL=(1.0-TW2/3.0)*(-1.0)*COS(BETA-ALPHA)-RHSF
          RHSFR=(4.0*TW2/3.0)*(-1.0)*COS(BETA-ALPHA)-RHSF
        ELSE
          RHSF=0
          RHSFL=0
          RHSFR=0
        ENDIF
        RHSF1=RHSFL*COS(THETAT)-RHSFR*SIN(THETAT)
        RHSF2=RHSFL*SIN(THETAT)+RHSFR*COS(THETAT)
        TAU=4.0*AMT1SS**2/MH**2
        CALL SSHGM1(TAU,IFFF,RFFF)
        IF0=-TAU*TAU*IFFF
        RF0=TAU*(1.0-TAU*RFFF)
        IIHSF1=RHSF1*IF0*(AMW/AMT1SS)**2/8.0
        RIHSF1=RHSF1*RF0*(AMW/AMT1SS)**2/8.0
        IITOT=IITOT+IIHSF1
        RITOT=RITOT+RIHSF1
        TAU=4.0*AMT2SS**2/MH**2
        CALL SSHGM1(TAU,IFFF,RFFF)
        IF0=-TAU*TAU*IFFF
        RF0=TAU*(1.0-TAU*RFFF)
        IIHSF2=RHSF2*IF0*(AMW/AMT2SS)**2/8.0
        RIHSF2=RHSF2*RF0*(AMW/AMT2SS)**2/8.0
        IITOT=IITOT+IIHSF2
        RITOT=RITOT+RIHSF2
C
C           IITOT and RITOT now contain the total imaginary and
C           real parts of the I function
C
        SUMISQ=IITOT**2+RITOT**2
        AS=SSALFS(MH**2)
        DW=AS**2*G2*MH**3/(32.0*(PI**3)*AMW**2)
        WID=DW*SUMISQ
        CALL SSSAVE(IDH,WID,IDGL,IDGL,0,0,0)
100   CONTINUE
C
       RETURN
       END
CDECK  ID>, SSHGM.  
      SUBROUTINE SSHGM
C-----------------------------------------------------------------------
C
C     Calculate H -> gm gm decays including both SM particles and
C     SUSY particles in loop.
C
C     This subroutine uses the tau variable of the Higgs Hunters'
C     Guide.  Many other authors, including the paper cited in
C     Higgs Hunters' Guide (PR. D. 38(11): 3481) and Collider Physics
C     by Barger and Phillips use the variable lambda
C          LAMBDA = ( MASS OF PARTICLE IN LOOP / MASS OF HIGGS )**2
C          TAU = 4.0 * LAMBDA
C
C     Bisset's HGAMGAM
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C
      DOUBLE PRECISION MW1,MW2
      DOUBLE PRECISION MFL(3),MFD(3),MFU(3)
      DOUBLE PRECISION ETAH,IITOT,RITOT,TAU,IFFF,RFFF,IFHALF,RFHALF
     $,IF1,RF1,IF0,RF0,NCC,EF,TEMPCH,RHF,RHW,RHCH,RHSF,RHSFL,RHSFR
     $,TEMP,RHCNO,IIHF,RIHF,IIHW,RIHW,IIHCH,RIHCH,IIHSFL,RIHSFL
     $,IIHSFR,RIHSFR,IIHCNO,RIHCNO
     $,RHSF1,RHSF2,IIHSF1,IIHSF2,RIHSF1,RIHSF2
      DOUBLE PRECISION U11,U12,U21,U22,V11,V12,V21,V22,S11,Q11,S22,Q22
     $,SUMISQ,DW
      DOUBLE PRECISION PI,SR2,XM,YM,CGL,SGL,CGR,SGR,G2,MH,BETA,ALPHA
     $,THETX,THETY,THETM,THETP,CW2,AMSQ
      REAL WID
      REAL ASMB,MBMB,MBQ,ASMT,MTMT,MTQ,SUALFS
      DOUBLE PRECISION SSMQCD
      INTEGER NUMH,IJ,II,NUMOUT,IDH
C
C          Mass matrix parameters
C
      PI=4.*ATAN(1.D0)
      SR2=SQRT(2.D0)
      XM=1./TAN(GAMMAL)
      THETX=SIGN(1.D0,XM)
      YM=1./TAN(GAMMAR)
      THETY=SIGN(1.D0,YM)
      SGL=1/(DSQRT(1+XM**2))
      CGL=SGL*XM
      SGR=1/(DSQRT(1+YM**2))
      CGR=SGR*YM
      MW1=DBLE(ABS(AMW1SS))
      MW2=DBLE(ABS(AMW2SS))
      THETM=SIGN(1.,AMW1SS)
      THETP=SIGN(1.,AMW2SS)
      G2=4.0*PI*ALFAEM/SN2THW
      BETA=ATAN(1.0/RV2V1)
      ALPHA=ALFAH
      CW2=1.-SN2THW
C
C          Loop over neutral Higgs bosons
C
      DO 100 NUMH=1,3
        IF(NUMH.EQ.1) THEN
           MH=AMHL
           IDH=ISHL
        ELSEIF(NUMH.EQ.2) THEN
           MH=AMHH
           IDH=ISHH
        ELSE
           MH=AMHA
           IDH=ISHA
        ENDIF
        ETAH=1.0
        IITOT=0.0
        RITOT=0.0
C
      ASMB=SUALFS(AMBT**2,.36,AMTP,3)
      MBMB=AMBT*(1.-4*ASMB/3./PI)
      MBQ=SSMQCD(DBLE(MBMB),DBLE(MH))
      ASMT=SUALFS(AMTP**2,.36,AMTP,3)
      MTMT=AMTP/(1.+4*ASMT/3./PI+(16.11-1.04*(5.-6.63/AMTP))*
     $(ASMT/PI)**2)
      MTQ=SSMQCD(DBLE(MTMT),DBLE(MH))
C
      MFL(1)=DBLE(AME)
      MFL(2)=DBLE(AMMU)
      MFL(3)=DBLE(AMTAU)
      MFD(1)=DBLE(AMDN)
      MFD(2)=DBLE(AMST)
      MFD(3)=DBLE(MBQ)
      MFU(1)=DBLE(AMUP)
      MFU(2)=DBLE(AMCH)
      MFU(3)=DBLE(MTQ)
C
C            Charged lepton loops
C
        DO 10 II=1,3
          TAU=4*MFL(II)**2/MH**2
          CALL SSHGM1(TAU,IFFF,RFFF)
          IFHALF=-2.0*TAU*(1.0-TAU*ETAH)*IFFF
          RFHALF=-2.0*TAU*(ETAH+(1.0-TAU*ETAH)*RFFF)
          NCC=1.0
          EF=-1.0
          IF(NUMH.EQ.1) THEN
            RHF=SIN(ALPHA)/COS(BETA)
          ELSEIF(NUMH.EQ.2) THEN
            RHF=COS(ALPHA)/COS(BETA)
          ELSE
            RHF=TAN(BETA)
          ENDIF
          IIHF=NCC*EF**2*RHF*IFHALF
          RIHF=NCC*EF**2*RHF*RFHALF
          IITOT=IITOT+IIHF
          RITOT=RITOT+RIHF
10      CONTINUE
C
C            Down-type quark loops
C
        DO 20 II=1,3
          TAU=4*MFD(II)**2/MH**2
          CALL SSHGM1(TAU,IFFF,RFFF)
          IFHALF=-2.0*TAU*(1.0-TAU*ETAH)*IFFF
          RFHALF=-2.0*TAU*(ETAH+(1.0-TAU*ETAH)*RFFF)
          NCC=3.0
          EF=-1.0/3.0
          IF(NUMH.EQ.1) THEN
            RHF=SIN(ALPHA)/COS(BETA)
          ELSEIF(NUMH.EQ.2) THEN
            RHF=COS(ALPHA)/COS(BETA)
          ELSE
            RHF=DTAN(BETA)
          ENDIF
          IIHF=NCC*EF**2*RHF*IFHALF
          RIHF=NCC*EF**2*RHF*RFHALF
          IITOT=IITOT+IIHF
          RITOT=RITOT+RIHF
20      CONTINUE
C
C            Up-type quark loops
C
        DO 30 II=1,2
          TAU=4*MFU(II)**2/MH**2
          CALL SSHGM1(TAU,IFFF,RFFF)
          IFHALF=-2.0*TAU*(1.0-TAU*ETAH)*IFFF
          RFHALF=-2.0*TAU*(ETAH+(1.0-TAU*ETAH)*RFFF)
          NCC=3.0
          EF=2.0/3.0
          IF(NUMH.EQ.1) THEN
            RHF=COS(ALPHA)/SIN(BETA)
          ELSEIF(NUMH.EQ.2) THEN
            RHF=-SIN(ALPHA)/SIN(BETA)
          ELSE
            RHF=1.0/TAN(BETA)
          ENDIF
          IIHF=NCC*EF**2*RHF*IFHALF
          RIHF=NCC*EF**2*RHF*RFHALF
          IITOT=IITOT+IIHF
          RITOT=RITOT+RIHF
30      CONTINUE
C
        TAU=4*MFU(3)**2/MH**2
        CALL SSHGM1(TAU,IFFF,RFFF)
        IFHALF=-2.0*TAU*(1.0-TAU*ETAH)*IFFF
        RFHALF=-2.0*TAU*(ETAH+(1.0-TAU*ETAH)*RFFF)
        NCC=3.0
        EF=2.0/3.0
        IF(NUMH.EQ.1) THEN
          RHF=COS(ALPHA)/SIN(BETA)
        ELSEIF(NUMH.EQ.2) THEN
          RHF=-SIN(ALPHA)/SIN(BETA)
        ELSE
          RHF=1.0/TAN(BETA)
        ENDIF
        IIHF=NCC*EF**2*RHF*IFHALF
        RIHF=NCC*EF**2*RHF*RFHALF
        IITOT=IITOT+IIHF
        RITOT=RITOT+RIHF
C
C            W-boson loop
C
        TAU=4*AMW**2/MH**2
        CALL SSHGM1(TAU,IFFF,RFFF)
        IF1=3.0*TAU*(2.0-TAU)*IFFF
        RF1=2.0+3.0*TAU+3.0*TAU*(2.0-TAU)*RFFF
        IF(NUMH.EQ.1) THEN
          RHW=SIN(BETA+ALPHA)
        ELSEIF(NUMH.EQ.2) THEN
          RHW=COS(BETA+ALPHA)
        ELSE
          RHW=0
        ENDIF
        IIHW=RHW*IF1
        RIHW=RHW*RF1
        IITOT=IITOT+IIHW
        RITOT=RITOT+RIHW
C
C            Charged Higgs loop
C
        TAU=4*AMHC**2/MH**2
        CALL SSHGM1(TAU,IFFF,RFFF)
        IF0=-TAU*TAU*IFFF
        RF0=TAU*(1.0-TAU*RFFF)
        IF(NUMH.EQ.1) THEN
          TEMPCH=SIN(BETA-ALPHA)*COS(2.0*BETA)
          TEMPCH=TEMPCH/(2.0*CW2)
          RHCH=TEMPCH+SIN(BETA+ALPHA)
        ELSEIF(NUMH.EQ.2) THEN
          TEMPCH=-COS(BETA-ALPHA)*COS(2.0*BETA)
          TEMPCH=TEMPCH/(2.0*CW2)
          RHCH=COS(BETA+ALPHA)+TEMPCH
        ELSE
          RHCH=0
        ENDIF
        IIHCH=RHCH*IF0*AMW**2/AMHC**2
        RIHCH=RHCH*RF0*AMW**2/AMHC**2
        IITOT=IITOT+IIHCH
        RITOT=RITOT+RIHCH
C
C         Slepton loops
C         The 3 L-type sneutrinos can be omitted since the sfermion
C         decay width is proportional to the sfermion charge.
C         ==> There are two sets of 3 degenerate sleptons.
C
        NCC=1.0
        EF=-1.0
C         First, do e_L and mu_L sleptons
        DO 40 II=1,2
          IF(NUMH.EQ.1) THEN
            RHSF=(MFL(II)/AMZ)**2*SIN(ALPHA)/COS(BETA)
            TEMP=(-0.5-EF*SN2THW)*SIN(BETA-ALPHA)
            RHSFL=RHSF-TEMP
          ELSEIF(NUMH.EQ.2) THEN
            RHSF=(MFL(II)/AMZ)**2*COS(ALPHA)/COS(BETA)
            TEMP=(-0.5-EF*SN2THW)*COS(BETA-ALPHA)
            RHSFL=RHSF-TEMP
          ELSE
            RHSF=0
            RHSFL=0
          ENDIF
          IF (II.EQ.1) AMSQ=AMELSS
          IF (II.EQ.2) AMSQ=AMMLSS
          TAU=4*AMSQ**2/MH**2
          CALL SSHGM1(TAU,IFFF,RFFF)
          IF0=-TAU*TAU*IFFF
          RF0=TAU*(1.0-TAU*RFFF)
          IIHSFL=NCC*(EF**2)*RHSFL*IF0*(AMZ/AMSQ)**2
          RIHSFL=NCC*(EF**2)*RHSFL*RF0*(AMZ/AMSQ)**2
          IITOT=IITOT+IIHSFL
          RITOT=RITOT+RIHSFL
40      CONTINUE
C         Next, do e_R and mu_R
        DO 41 II=1,2
          IF(NUMH.EQ.1) THEN
            RHSF=(MFL(II)/AMZ)**2*SIN(ALPHA)/COS(BETA)
            TEMP=-1.0*EF*SN2THW*SIN(BETA-ALPHA)
            RHSFR=RHSF+TEMP
          ELSEIF(NUMH.EQ.2) THEN
            RHSF=(MFL(II)/AMZ)**2*COS(ALPHA)/COS(BETA)
            TEMP=-1.0*EF*SN2THW*COS(BETA-ALPHA)
            RHSFR=RHSF+TEMP
          ELSE
            RHSF=0
            RHSFR=0
          ENDIF
          IF (II.EQ.1) AMSQ=AMERSS
          IF (II.EQ.2) AMSQ=AMMRSS
          TAU=4*AMSQ**2/MH**2
          CALL SSHGM1(TAU,IFFF,RFFF)
          IF0=-TAU*TAU*IFFF
          RF0=TAU*(1.0-TAU*RFFF)
          IIHSFR=NCC*(EF**2)*RHSFR*IF0*(AMZ/AMSQ)**2
          RIHSFR=NCC*(EF**2)*RHSFR*RF0*(AMZ/AMSQ)**2
          IITOT=IITOT+IIHSFR
          RITOT=RITOT+RIHSFR
41      CONTINUE
C         Next, do stau_1 and stau_2 contribution
        IF(NUMH.EQ.1) THEN
          RHSF=(AMTAU/AMZ)**2*SIN(ALPHA)/COS(BETA)
          TEMP=(-0.5-EF*SN2THW)*SIN(BETA-ALPHA)
          RHSFL=RHSF-TEMP
          TEMP=-1.0*EF*SN2THW*SIN(BETA-ALPHA)
          RHSFR=RHSF+TEMP
        ELSEIF(NUMH.EQ.2) THEN
          RHSF=(AMTAU/AMZ)**2*COS(ALPHA)/COS(BETA)
          TEMP=(-0.5-EF*SN2THW)*COS(BETA-ALPHA)
          RHSFL=RHSF-TEMP
          TEMP=-1.0*EF*SN2THW*COS(BETA-ALPHA)
          RHSFR=RHSF+TEMP
        ELSE
          RHSF=0
          RHSFL=0
          RHSFR=0
        ENDIF
        RHSF1=RHSFL*COS(THETAL)-RHSFR*SIN(THETAL)
        RHSF2=RHSFL*SIN(THETAL)+RHSFR*COS(THETAL)
        TAU=4*AML1SS**2/MH**2
        CALL SSHGM1(TAU,IFFF,RFFF)
        IF0=-TAU*TAU*IFFF
        RF0=TAU*(1.0-TAU*RFFF)
        IIHSF1=NCC*(EF**2)*RHSF1*IF0*(AMZ/AML1SS)**2
        RIHSF1=NCC*(EF**2)*RHSF1*RF0*(AMZ/AML1SS)**2
        IITOT=IITOT+IIHSF1
        RITOT=RITOT+RIHSF1
        TAU=4*AML2SS**2/MH**2
        CALL SSHGM1(TAU,IFFF,RFFF)
        IF0=-TAU*TAU*IFFF
        RF0=TAU*(1.0-TAU*RFFF)
        IIHSF2=NCC*(EF**2)*RHSF2*IF0*(AMZ/AML2SS)**2
        RIHSF2=NCC*(EF**2)*RHSF2*RF0*(AMZ/AML2SS)**2
        IITOT=IITOT+IIHSF2
        RITOT=RITOT+RIHSF2
C
C          Down-type squark loops
C          Mixing between the sbottom squarks is also included, so
C          masses used here are the mixed masses (AMB1SS & AMB2SS)
C
        NCC=3.0
        EF=-1.0/3.0
C          First, do d_L and s_L squarks
        DO 50 II=1,2
          IF(NUMH.EQ.1) THEN
            RHSF=(MFD(II)/AMZ)**2*SIN(ALPHA)/COS(BETA)
            TEMP=(-0.5-EF*SN2THW)*SIN(BETA-ALPHA)
            RHSFL=RHSF-TEMP
          ELSEIF(NUMH.EQ.2) THEN
            RHSF=(MFD(II)/AMZ)**2*COS(ALPHA)/COS(BETA)
            TEMP=(-0.5-EF*SN2THW)*COS(BETA-ALPHA)
            RHSFL=RHSF-TEMP
          ELSE
            RHSF=0
            RHSFL=0
          ENDIF
          IF (II.EQ.1) AMSQ=AMDLSS
          IF (II.EQ.2) AMSQ=AMSLSS
          TAU=4*AMSQ**2/MH**2
          CALL SSHGM1(TAU,IFFF,RFFF)
          IF0=-TAU*TAU*IFFF
          RF0=TAU*(1.0-TAU*RFFF)
          IIHSFL=NCC*(EF**2)*RHSFL*IF0*(AMZ/AMSQ)**2
          RIHSFL=NCC*(EF**2)*RHSFL*RF0*(AMZ/AMSQ)**2
          IITOT=IITOT+IIHSFL
          RITOT=RITOT+RIHSFL
50      CONTINUE
C         Next, do d_R and s_R squarks
        DO 51 II=1,2
          IF(NUMH.EQ.1) THEN
            RHSF=(MFD(II)/AMZ)**2*SIN(ALPHA)/COS(BETA)
            TEMP=-1.0*EF*SN2THW*SIN(BETA-ALPHA)
            RHSFR=RHSF+TEMP
          ELSEIF(NUMH.EQ.2) THEN
            RHSF=(MFD(II)/AMZ)**2*COS(ALPHA)/COS(BETA)
            TEMP=-1.0*EF*SN2THW*COS(BETA-ALPHA)
            RHSFR=RHSF+TEMP
          ELSE
            RHSF=0
            RHSFR=0
          ENDIF
          IF (II.EQ.1) AMSQ=AMDRSS
          IF (II.EQ.2) AMSQ=AMSRSS
          TAU=4*AMSQ**2/MH**2
          CALL SSHGM1(TAU,IFFF,RFFF)
          IF0=-TAU*TAU*IFFF
          RF0=TAU*(1.0-TAU*RFFF)
          IIHSFR=NCC*(EF**2)*RHSFR*IF0*(AMZ/AMSQ)**2
          RIHSFR=NCC*(EF**2)*RHSFR*RF0*(AMZ/AMSQ)**2
          IITOT=IITOT+IIHSFR
          RITOT=RITOT+RIHSFR
51      CONTINUE
C
        NCC=3.0
        EF=-1.0/3.0
        IF(NUMH.EQ.1) THEN
          RHSF=(MBQ/AMZ)**2*SIN(ALPHA)/COS(BETA)
          TEMP=(-0.5-EF*SN2THW)*SIN(BETA-ALPHA)
          RHSFL=RHSF-TEMP
          TEMP=-1.0*EF*SN2THW*SIN(BETA-ALPHA)
          RHSFR=RHSF+TEMP
        ELSEIF(NUMH.EQ.2) THEN
          RHSF=(MBQ/AMZ)**2*COS(ALPHA)/COS(BETA)
          TEMP=(-0.5-EF*SN2THW)*COS(BETA-ALPHA)
          RHSFL=RHSF-TEMP
          TEMP=-1.0*EF*SN2THW*COS(BETA-ALPHA)
          RHSFR=RHSF+TEMP
        ELSE
          RHSF=0
          RHSFL=0
          RHSFR=0
        ENDIF
        RHSF1=RHSFL*COS(THETAB)-RHSFR*SIN(THETAB)
        RHSF2=RHSFL*SIN(THETAB)+RHSFR*COS(THETAB)
        TAU=4*AMB1SS**2/MH**2
        CALL SSHGM1(TAU,IFFF,RFFF)
        IF0=-TAU*TAU*IFFF
        RF0=TAU*(1.0-TAU*RFFF)
        IIHSF1=NCC*(EF**2)*RHSF1*IF0*(AMZ/AMB1SS)**2
        RIHSF1=NCC*(EF**2)*RHSF1*RF0*(AMZ/AMB1SS)**2
        IITOT=IITOT+IIHSF1
        RITOT=RITOT+RIHSF1
        TAU=4*AMB2SS**2/MH**2
        CALL SSHGM1(TAU,IFFF,RFFF)
        IF0=-TAU*TAU*IFFF
        RF0=TAU*(1.0-TAU*RFFF)
        IIHSF2=NCC*(EF**2)*RHSF2*IF0*(AMZ/AMB2SS)**2
        RIHSF2=NCC*(EF**2)*RHSF2*RF0*(AMZ/AMB2SS)**2
        IITOT=IITOT+IIHSF2
        RITOT=RITOT+RIHSF2
C
C         Up-type squark loops
C         Mixing between the stop squarks is also included, so
C         masses used here are the mixed masses (AMT1SS & AMT2SS)
C
        NCC=3.0
        EF=2.0/3.0
C         First, do u_L and c_L squarks
        DO 60 II=1,2
          IF(NUMH.EQ.1) THEN
            RHSF=(MFU(II)/AMZ)**2*COS(ALPHA)/SIN(BETA)
            TEMP=(0.5-EF*SN2THW)*SIN(BETA-ALPHA)
            RHSFL=RHSF-TEMP
          ELSEIF(NUMH.EQ.2) THEN
            RHSF=(MFU(II)/AMZ)**2*(-1.0)*SIN(ALPHA)/SIN(BETA)
            TEMP=(0.5-EF*SN2THW)*COS(BETA-ALPHA)
            RHSFL=RHSF-TEMP
          ELSE
            RHSF=0
            RHSFL=0
          ENDIF
          IF (II.EQ.1) AMSQ=AMULSS
          IF (II.EQ.2) AMSQ=AMCLSS
          TAU=4*AMSQ**2/MH**2
          CALL SSHGM1(TAU,IFFF,RFFF)
          IF0=-TAU*TAU*IFFF
          RF0=TAU*(1.0-TAU*RFFF)
          IIHSFL=NCC*(EF**2)*RHSFL*IF0*(AMZ/AMSQ)**2
          RIHSFL=NCC*(EF**2)*RHSFL*RF0*(AMZ/AMSQ)**2
          IITOT=IITOT+IIHSFL
          RITOT=RITOT+RIHSFL
60      CONTINUE
C          Next, do u_R and c_R squarks
        DO 61 II=1,2
          IF(NUMH.EQ.1) THEN
            RHSF=(MFU(II)/AMZ)**2*COS(ALPHA)/SIN(BETA)
            TEMP=-1.0*EF*SN2THW*SIN(BETA-ALPHA)
            RHSFR=RHSF+TEMP
          ELSEIF(NUMH.EQ.2) THEN
            RHSF=(MFU(II)/AMZ)**2*(-1.0)*SIN(ALPHA)/SIN(BETA)
            TEMP=-1.0*EF*SN2THW*COS(BETA-ALPHA)
            RHSFR=RHSF+TEMP
          ELSE
            RHSF=0
            RHSFR=0
          ENDIF
          IF (II.EQ.1) AMSQ=AMURSS
          IF (II.EQ.2) AMSQ=AMCRSS
          TAU=4*AMSQ**2/MH**2
          CALL SSHGM1(TAU,IFFF,RFFF)
          IF0=-TAU*TAU*IFFF
          RF0=TAU*(1.0-TAU*RFFF)
          IIHSFR=NCC*(EF**2)*RHSFR*IF0*(AMZ/AMSQ)**2
          RIHSFR=NCC*(EF**2)*RHSFR*RF0*(AMZ/AMSQ)**2
          IITOT=IITOT+IIHSFR
          RITOT=RITOT+RIHSFR
61      CONTINUE
C
        NCC=3.0
        EF=2.0/3.0
        IF(NUMH.EQ.1) THEN
          RHSF=(MTQ/AMZ)**2*COS(ALPHA)/SIN(BETA)
          TEMP=(0.5-EF*SN2THW)*SIN(BETA-ALPHA)
          RHSFL=RHSF-TEMP
          TEMP=-1.0*EF*SN2THW*SIN(BETA-ALPHA)
          RHSFR=RHSF+TEMP
        ELSEIF(NUMH.EQ.2) THEN
          RHSF=(MTQ/AMZ)**2*(-1.0)*SIN(ALPHA)/SIN(BETA)
          TEMP=(0.5-EF*SN2THW)*COS(BETA-ALPHA)
          RHSFL=RHSF-TEMP
          TEMP=-1.0*EF*SN2THW*COS(BETA-ALPHA)
          RHSFR=RHSF+TEMP
        ELSE
          RHSF=0
          RHSFL=0
          IIHSFL=0
          RIHSFL=0
        ENDIF
        RHSF1=RHSFL*COS(THETAB)-RHSFR*SIN(THETAB)
        RHSF2=RHSFL*SIN(THETAB)+RHSFR*COS(THETAB)
        TAU=4*AMT1SS**2/MH**2
        CALL SSHGM1(TAU,IFFF,RFFF)
        IF0=-TAU*TAU*IFFF
        RF0=TAU*(1.0-TAU*RFFF)
        IIHSF1=NCC*(EF**2)*RHSF1*IF0*(AMZ/AMT1SS)**2
        RIHSF1=NCC*(EF**2)*RHSF1*RF0*(AMZ/AMT1SS)**2
        IITOT=IITOT+IIHSF1
        RITOT=RITOT+RIHSF1
        TAU=4*AMT2SS**2/MH**2
        CALL SSHGM1(TAU,IFFF,RFFF)
        IF0=-TAU*TAU*IFFF
        RF0=TAU*(1.0-TAU*RFFF)
        IIHSF2=NCC*(EF**2)*RHSF2*IF0*(AMZ/AMT2SS)**2
        RIHSF2=NCC*(EF**2)*RHSF2*RF0*(AMZ/AMT2SS)**2
        IITOT=IITOT+IIHSF2
        RITOT=RITOT+RIHSF2
C
C            Chargino loops
C
        TAU=4.0*(MW1)**2/MH**2
        CALL SSHGM1(TAU,IFFF,RFFF)
        IFHALF=-2.0*TAU*(1.0-TAU*ETAH)*IFFF
        RFHALF=-2.0*TAU*(ETAH+(1.0-TAU*ETAH)*RFFF)
        U11=SGL
        U12=-CGL
        V11=THETM*SGR
        V12=-THETM*CGR
        S11=U11*V12/SR2
        Q11=U12*V11/SR2
        RHCNO=2.0*(S11*COS(ALPHA)+Q11*SIN(ALPHA))
        IIHCNO=RHCNO*IFHALF*AMW/MW1
        RIHCNO=RHCNO*RFHALF*AMW/MW1
        IITOT=IITOT+IIHCNO
        RITOT=RITOT+RIHCNO
C
        TAU=4.0*(MW2)**2/MH**2
        CALL SSHGM1(TAU,IFFF,RFFF)
        IFHALF=-2.0*TAU*(1.0-TAU*ETAH)*IFFF
        RFHALF=-2.0*TAU*(ETAH+(1.0-TAU*ETAH)*RFFF)
        U21=THETX*CGL
        U22=THETX*SGL
        V21=THETP*THETY*CGR
        V22=THETP*THETY*SGR
        S22=U21*V22/SR2
        Q22=U22*V21/SR2
        RHCNO=2.0*(S22*COS(ALPHA)+Q22*SIN(ALPHA))
        IIHCNO=RHCNO*IFHALF*AMW/MW2
        RIHCNO=RHCNO*RFHALF*AMW/MW2
        IITOT=IITOT+IIHCNO
        RITOT=RITOT+RIHCNO
C
C          IITOT and RITOT now contain the total imaginary and real
C          parts of the I function
C
        SUMISQ=IITOT**2+RITOT**2
        DW=ALFAEM**2*G2*MH**3/(1024.0*(PI**3)*AMW**2)
        WID=DW*SUMISQ
        CALL SSSAVE(IDH,WID,IDGM,IDGM,0,0,0)
100   CONTINUE
C
      RETURN
      END
CDECK  ID>, SSHGM1. 
      SUBROUTINE SSHGM1(TAU,IFFF,RFFF)
C-----------------------------------------------------------------------
C
C     This subroutine uses the tau variable of the Higgs Hunters'
C     Guide.  Many other authors, including the paper cited in
C     Higgs Hunters' Guide (PR. D. 38(11): 3481) and Collider Physics
C     by Barger and Phillips use the variable lambda
C          LAMBDA = ( MASS OF PARTICLE IN LOOP / MASS OF HIGGS )**2
C          TAU = 4.0 * LAMBDA
C     Note also that what is defined as the f function by different
C     authors varies by a constant factor.  For example,
C          f(Barger and Phillips) = -2 * f(Higgs Hunters' Guide)
C
C     Bisset's FFF
C-----------------------------------------------------------------------
      IMPLICIT NONE
      DOUBLE PRECISION TAU,IFFF,RFFF,ETAP,ETAM,PI
C
      PI=3.1415926536
      IFFF=0.0
      RFFF=0.0
      IF(TAU.GE.1.0) THEN
        RFFF=(DASIN(DSQRT(1.0/TAU)))**2
        IFFF=0.0D0
      ELSE IF (TAU.LT.1.0) THEN
        ETAP=1.0D0+SQRT(1.0D0-TAU)
        ETAM=1.0D0-SQRT(1.0D0-TAU)
        RFFF=-((DLOG(ETAP/ETAM))**2-PI**2)/4.0D0
        IFFF=PI*DLOG(ETAP/ETAM)/2.0D0
      ENDIF
      RETURN
      END
CDECK  ID>, SSHHX.  
      SUBROUTINE SSHHX
C-----------------------------------------------------------------------
C     Calculates the decays Hi -> Hj + X.
C
C     Includes vertex corrections for triple Higgs couplings due
C     to top and stop quarks effects.
C     See Kunszt and Zwirner CERN-TH.6150/91 for all but hh-hc-hc
C     correction which is in our Higgs-->SUSY paper:
C     Baer et. al. FSU-HEP-920630 or UH-511-749-92.
C
C     The hh-hl-hl vertex correction now includes both
C        top & bottom and stop and sbottom squark
C        (non-degenerate with mixing) effects.
C        A-terms and mu=-2m1 are also included.
C
C
C     Bisset's HIGPRO
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C
      DOUBLE PRECISION PI,SR2,G2,GP2,BETA,ALPHA,SW2,CW2,LGTST,CBMA
     $,SBMA,LAMB1,DWID,DELLPP,MH,M1,M2,LAMB,TEMP,DTEMPL,DTEMPR
     $,DELHLL,DELHPP,DELHCC,CAB2,SAB2
      DOUBLE PRECISION SSDLAM
      REAL WID,ASMT,MTMT,MTQ,SUALFS,HIGFRZ
      DOUBLE PRECISION SSMQCD
C
      PI=4.*ATAN(1.D0)
      SR2=SQRT(2.D0)
      G2=4.0*PI*ALFAEM/SN2THW
      GP2=4*PI*ALFAEM/(1-SN2THW)
      HIGFRZ=SQRT(AMTLSS*AMTRSS)
      ASMT=SUALFS(AMTP**2,.36,AMTP,3)
      MTMT=AMTP/(1.+4*ASMT/3./PI+(16.11-1.04*(5.-6.63/AMTP))*
     $(ASMT/PI)**2)
      MTQ=SSMQCD(DBLE(MTMT),DBLE(HIGFRZ))

      BETA=ATAN(1.0/RV2V1)
      ALPHA=ALFAH
      SW2=SN2THW
      CW2=1.-SN2THW
C
      LGTST=(1+(AMTLSS/MTQ)**2)*(1+(AMTRSS/MTQ)**2)
      LGTST=LOG(LGTST)
      SBMA=SIN(BETA-ALPHA)
      CBMA=COS(BETA-ALPHA)
      CAB2=(DCOS(ALPHA+BETA))**2
      SAB2=1.0-CAB2
C
C          hl0 -> ha0 + ha0
C
      IF(AMHL.GT.2*AMHA) THEN
        LAMB1=AMHL**2-4.0*AMHA**2
        DWID=SBMA*COS(2.0*BETA)
C          Now add hl-hp-hp vertex correction
        DELLPP=3.0*G2*CW2*(MTQ**4)*COS(ALPHA)
        DELLPP=DELLPP*(COS(BETA)**2)/(16.0*(PI**2))
        DELLPP=DELLPP/((AMW**4)*(SIN(BETA))**3)
        DELLPP=DELLPP*LGTST
        DWID=(DWID+DELLPP)**2
        DWID=DWID*G2*(AMZ**2)/(128.0*PI*CW2*(AMHL**2))
        DWID=DWID*SQRT(LAMB1)
        WID=DWID
        CALL SSSAVE(ISHL,WID,ISHA,ISHA,0,0,0)
      ENDIF
C
C          hh -> ha + z
C
      IF(AMHH.GT.AMHA+AMZ) THEN
        MH=AMHH
        M1=AMHA
        M2=AMZ
        LAMB=SSDLAM(MH**2,M1**2,M2**2)
        DWID=SQRT(G2*CW2)+SQRT(GP2*SW2)
        DWID=DWID**2*SAB2*SQRT(LAMB)
        DWID=DWID/(64.0*PI*(AMZ**2)*(AMHH**3))
        DWID=DWID*LAMB
        WID=DWID
        CALL SSSAVE(ISHH,WID,ISHA,IDZ,0,0,0)
      ENDIF
C
C          hh -> hl + hl
C
      IF(AMHH.GT.2*AMHL) THEN
        LAMB1=AMHH**2-4.0*AMHL**2
        TEMP=CBMA*COS(2.0*ALPHA)
        TEMP=TEMP+2.0*SBMA*SIN(2.0*ALPHA)
C
C          Now add hh-hl-hl vertex correction
C
C        The following 8 lines calculate the radiative
C        hh-hl-hl vertex correction including only
C        effects from tops and stop squarks.
C
C        DTEMPL=3.0*LOG(1.0+(AMTLSS/MTQ)**2)
C        DTEMPL=DTEMPL-2.0*AMTLSS**2/(AMTLSS**2+MTQ**2)
C        DTEMPR=3.0*LOG(1.0+(AMTRSS/MTQ)**2)
C        DTEMPR=DTEMPR-2.0*AMTRSS**2/(AMTRSS**2+MTQ**2)
C        DELHLL=3.0*G2*CW2*(MTQ**4)*SIN(ALPHA)
C        DELHLL=DELHLL*(COS(ALPHA)**2)/(PI**2)
C        DELHLL=DELHLL/(16.0*(AMW**4)*(SIN(BETA))**3)
C        DELHLL=DELHLL*(DTEMPL+DTEMPR)
C
C        The subroutine SSHL calculates the radiative
C        hh-hl-hl vertex correction including both
C        top & bottom and stop and sbottom squark
C        (non-degenerate with mixing) effects.
C        A-terms and mu=-2m1 are also included.
C
        CALL SSDHLL(DELHLL)
C
C        Note:  the variable TEMP in the line below
C        this is the Lagrangian term (as noted on
C        page 27 of Prof. Tata's personal Lagrangian
C        term notes.  Thus DELHLL must also be the
C        Lagrangian entry - not the potential entry.
C        The subroutine SSHLL IS set up to yield the
C        the Lagrangian entry. (We must be very careful
C        about the relative sign between TEMP and DELHLL.)
C
        DWID=G2*(AMZ**2)*(TEMP+DELHLL)**2
        DWID=DWID/(128.0*PI*CW2*(AMHH**2))
        DWID=DWID*SQRT(LAMB1)
        WID=DWID
        CALL SSSAVE(ISHH,WID,ISHL,ISHL,0,0,0)
      ENDIF
C
C          hh -> ha + ha
C
      IF(AMHH.GT.2*AMHA) THEN
        LAMB1=AMHH**2-4.0*AMHA**2
        DWID=CBMA*COS(2*BETA)
C          Now add hh-hp-hp vertex correction
        DELHPP=3.0*G2*CW2*(MTQ**4)*SIN(ALPHA)
        DELHPP=DELHPP*(COS(BETA)**2)/(16.0*(PI**2))
        DELHPP=DELHPP/((AMW**4)*(SIN(BETA))**3)
        DELHPP=DELHPP*LGTST
        DWID=G2*(AMZ**2)*(DWID+DELHPP)**2
        DWID=DWID/(128.0*PI*CW2*(AMHH**2))
        DWID=DWID*SQRT(LAMB1)
        WID=DWID
        CALL SSSAVE(ISHH,WID,ISHA,ISHA,0,0,0)
      ENDIF
C
C          hh -> hc+ + hc-
C
      IF(AMHH.GT.2*AMHC) THEN
        LAMB1=1.0-4.0*(AMHC**2)/(AMHH**2)
        DWID=CBMA*COS(2.0*BETA)/(2.0*CW2)
        DWID=COS(BETA+ALPHA)-DWID
C          Now add hh-hc-hc vertex correction
        DELHCC=3.0*G2*MTQ**4*SIN(ALPHA)
        DELHCC=DELHCC/( SIN(BETA)*(DTAN(BETA))**2 )
        DELHCC=DELHCC/(32.0*PI**2*AMW**4)
        DELHCC=DELHCC*LGTST
        DWID=G2*AMW**2*(-DWID+DELHCC)**2
        DWID=DWID*SQRT(LAMB1)/(16.0*PI*AMHH)
        WID=DWID
        CALL SSSAVE(ISHH,WID,ISHC,-ISHC,0,0,0)
      ENDIF
C
C          ha -> hl + z
C
      IF(AMHA.GT.AMHL+AMZ) THEN
         MH=AMHA
         M1=AMHL
         M2=AMZ
         LAMB=SSDLAM(MH**2,M1**2,M2**2)
         DWID=SQRT(G2*CW2)+SQRT(GP2*SW2)
         DWID=DWID**2*CAB2*SQRT(LAMB)
         DWID=DWID/(64.0*PI*(AMZ**2)*(AMHA**3))
         DWID=DWID*LAMB
         WID=DWID
         CALL SSSAVE(ISHA,WID,ISHL,IDZ,0,0,0)
      ENDIF
C
C          hc+ -> w+ + hl
C
      IF(AMHC.GT.AMW+AMHL) THEN
        MH=AMHC
        M1=AMW
        M2=AMHL
        LAMB=SSDLAM(MH**2,M1**2,M2**2)
        DWID=G2*CAB2*SQRT(LAMB)
        DWID=DWID/( 64.0*PI*(AMW**2)*(AMHC**3) )
        DWID=DWID*LAMB
        WID=DWID
        CALL SSSAVE(ISHC,WID,ISHL,IDW,0,0,0)
      ENDIF
C
      RETURN
      END
CDECK  ID>, SSHIBF. 
      SUBROUTINE SSHIBF
C-----------------------------------------------------------------------
C
C     This subroutine calculates the decay widths for decays of the
C     Higgs scalars present in the minimal SUSY model.
C
C     NOTE: Decays into sfermions are not yet incorporated.
C
C     Standard model parameters are hard wired in  SSMSSM. To get
C     the 1987-8 values corresponding to the Gunion et al. papers
C     (Intl. J. Mod. Phys. 2(4):1035; Nucl. Phys. B307:445) you must
C     change
C          ALFA3 = 0.12  --> 0.136
C          AMW   = 80.0  --> 81.3
C          AMZ   = 91.17 --> 92.7
C
C     2/9/91:
C     I've modified the program slightly.  The ALPHA3 = 0.12 value
C     above is the recent empirical value from LEP. Using the equation
C     from page 220 in Barger and Phillips yields ALPHA3 = 0.136.
C
C     10/1/92:
C     Now includes vertex corrections for triple Higgs couplings.
C     (See Kunszt and Zwirner, CERN-TH.6150/91 for all but HH-HC-HC
C     correction which is in our Higgs --> SUSY paper: Baer et al.
C     FSU-HEP-920630 or UH-511-749-92)
C
C     Bisset's HIGSBF
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C
C          Decays into fermions
      CALL SSHFF
C          Loop decays into photons and gluons
      CALL SSHGM
      CALL SSHGL
C          Decays into WW(*), ZZ(*)
      CALL SSHWW
C          Decays into neutralinos and charginos
      CALL SSHNN
      CALL SSHCC
C          Decays into other Higgs bosons
      CALL SSHHX
C          Decays to sfermions
      CALL SSHSF
C          Normalize branching ratios
C
      CALL SSNORM(ISHL)
      CALL SSNORM(ISHH)
      CALL SSNORM(ISHA)
      CALL SSNORM(ISHC)
C
      RETURN
      END
CDECK  ID>, SSHNN.  
      SUBROUTINE SSHNN
C-----------------------------------------------------------------------
C     Calculates the decay widths of all neutral Higgses into all
C     possible pairs of neutralinos, and the decay widths of the
C     charged Higgs into any neutralino and any chargino
C
C     Bisset's NEUINO
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C
      DOUBLE PRECISION XIJ,XJI,DIJ,TEMP,DWZN,TEMP2,T2,RWZ,SWZ
     $,PI,SR2,XM,THETX,YM,THETY,SGL,CGL,SGR,CGR,MW1,MW2,THETM,THETP
     $,G2,GP2,BETA,ALPHA,MH,M1,M2
      DOUBLE PRECISION SN1,SN2,DWID,LAMB
      DOUBLE PRECISION A(4,4),MHI(3)
      DOUBLE PRECISION SSDLAM
      REAL WID
      INTEGER II,NUMH,I1,I2,IZ,IW,ID1,ID2,IDH
      INTEGER IDHI(3),IDZI(4)
C
C          Mass matrix parameters
C
      PI=4.*ATAN(1.D0)
      SR2=SQRT(2.D0)
      XM=1./TAN(GAMMAL)
      THETX=SIGN(1.D0,XM)
      YM=1./TAN(GAMMAR)
      THETY=SIGN(1.D0,YM)
      SGL=1/(DSQRT(1+XM**2))
      CGL=SGL*XM
      SGR=1/(DSQRT(1+YM**2))
      CGR=SGR*YM
      MW1=DBLE(ABS(AMW1SS))
      MW2=DBLE(ABS(AMW2SS))
      THETM=SIGN(1.,AMW1SS)
      THETP=SIGN(1.,AMW2SS)
      G2=4*PI*ALFAEM/SN2THW
      GP2=4*PI*ALFAEM/(1-SN2THW)
      BETA=ATAN(1.0/RV2V1)
      ALPHA=ALFAH
C          The following was calculated in Bisset's MASZIN
      DO 10 II=1,4
         TEMP=SQRT(G2)*ZMIXSS(3,II)+SQRT(GP2)*ZMIXSS(4,II)
         TEMP=TEMP/SR2
         A(1,II)=-TEMP*SGR-SQRT(G2)*ZMIXSS(1,II)*CGR
         A(2,II)=TEMP*CGR-SQRT(G2)*ZMIXSS(1,II)*SGR
         A(3,II)=-TEMP*SGL+SQRT(G2)*ZMIXSS(2,II)*CGL
         A(4,II)=TEMP*CGL+SQRT(G2)*ZMIXSS(2,II)*SGL
10    CONTINUE
C
C          Arrays for loops
C
      MHI(1)=AMHL
      MHI(2)=AMHH
      MHI(3)=AMHA
      IDHI(1)=ISHL
      IDHI(2)=ISHH
      IDHI(3)=ISHA
      IDZI(1)=ISZ1
      IDZI(2)=ISZ2
      IDZI(3)=ISZ3
      IDZI(4)=ISZ4
C
C          Loop over neutral Higgs decays h(numh) into neutralino
C          pairs zi(i1) and zi(i2)
C
      DO 100 NUMH=1,3
        MH=MHI(NUMH)
        IDH=IDHI(NUMH)
        DO 110 I1=1,4
          M1=ABS(AMZISS(I1))
          ID1=IDZI(I1)
          DO 120 I2=I1,4
            M2=ABS(AMZISS(I2))
            ID2=IDZI(I2)
            IF(M1+M2.GE.MH) GO TO 120
            LAMB=SSDLAM(MH**2,M1**2,M2**2)
            IF(I1.EQ.I2) THEN
              DIJ = 0.5
            ELSE
              DIJ = 1.0
            ENDIF
            TEMP=-0.5*SIGN(1.,AMZISS(I1))*SIGN(1.,AMZISS(I2))
            XIJ=TEMP*(SQRT(G2)*ZMIXSS(3,I2)-SQRT(GP2)*ZMIXSS(4,I2))
            XJI=TEMP*(SQRT(G2)*ZMIXSS(3,I1)-SQRT(GP2)*ZMIXSS(4,I1))
            IF(NUMH.EQ.1) THEN
              XIJ=XIJ*(ZMIXSS(2,I1)*SIN(ALPHA)-ZMIXSS(1,I1)*COS(ALPHA))
              XJI=XJI*(ZMIXSS(2,I2)*SIN(ALPHA)-ZMIXSS(1,I2)*COS(ALPHA))
            ELSEIF (NUMH .EQ. 2) THEN
              XIJ=XIJ*(ZMIXSS(2,I1)*COS(ALPHA)+ZMIXSS(1,I1)*SIN(ALPHA))
              XJI=XJI*(ZMIXSS(2,I2)*COS(ALPHA)+ZMIXSS(1,I2)*SIN(ALPHA))
            ELSEIF(NUMH.EQ.3) THEN
              XIJ=-XIJ*(ZMIXSS(2,I1)*SIN(BETA)-ZMIXSS(1,I1)*COS(BETA))
              XJI=-XJI*(ZMIXSS(2,I2)*SIN(BETA)-ZMIXSS(1,I2)*COS(BETA))
            ENDIF
            DWID=DIJ*(XIJ+XJI)**2
            DWID=DWID*SQRT(LAMB)/(8.0*PI*(MH**3))
            IF(NUMH.EQ.1.OR.NUMH.EQ.2) THEN
              TEMP2 = ((MH**2)-(M1-2.0*TEMP*M2)**2)
            ELSEIF(NUMH.EQ.3) THEN
              TEMP2=((MH**2)-(M1+2.0*TEMP*M2)**2)
            ENDIF
            DWID=DWID*TEMP2
            WID=DWID
            CALL SSSAVE(IDH,WID,ID1,ID2,0,0,0)
120       CONTINUE
110     CONTINUE
100   CONTINUE
C
C          Loop over h+ decays into wi(iw) + zi(iz)
C
      MH=AMHC
      DO 210 IW=1,2
        IF(IW.EQ.1) THEN
          M1=ABS(AMW1SS)
          ID1=ISW1
          SN1=SIGN(1.,AMW1SS)
        ELSE
          M1=ABS(AMW2SS)
          ID1=ISW2
          SN1=SIGN(1.,AMW2SS)
        ENDIF
        DO 220 IZ=1,4
          M2=ABS(AMZISS(IZ))
          ID2=IDZI(IZ)
          SN2=SIGN(1.,AMZISS(IZ))
          IF(M1+M2.GE.MH) GO TO 220
          LAMB=SSDLAM(MH**2,M1**2,M2**2)
          T2=MH**2-M1**2-M2**2
          IF(IW.EQ.1) THEN
            RWZ=COS(BETA)*A(2,IZ)*SN1
            TEMP=SIN(BETA)*A(4,IZ)*SN2
            SWZ=0.5*(RWZ+TEMP)
            RWZ=0.5*(RWZ-TEMP)
          ELSE
            RWZ=COS(BETA)*A(1,IZ)*THETY*SN1
            TEMP=SIN(BETA)*A(3,IZ)*THETX*SN2
            SWZ=0.5*(RWZ+TEMP)
            RWZ=0.5*(RWZ-TEMP)
          ENDIF
          DWID=RWZ**2+SWZ**2
          DWID=DWID*T2
          TEMP=2*M1*M2*(RWZ**2-SWZ**2)
          DWID=(DWID-TEMP)/(8.0*PI*(MH**3))
          DWID=DWID*SQRT(LAMB)
          WID=DWID
          CALL SSSAVE(ISHC,WID,ID1,ID2,0,0,0)
220     CONTINUE
210   CONTINUE
      RETURN
      END
CDECK  ID>, SSHSF.  
      SUBROUTINE SSHSF
C-----------------------------------------------------------------------
C
C          Calculates the partial decay widths of
C          the Higgs bosons into sfermions.
C          calculated by X. Tata
C          program by M. Bisset
C
C          10/23/93: modified by H. Baer, 10/8/96
C          Intra-flavor sfermion mixing is neglected
C          for all flavors EXCEPT for stops, sbottoms and staus.
C
C
C         10/23/93
C          It is assumed that the A-terms are real.
C          In addition, all coefficients of the sfermion
C          trilinear terms from the superpotential
C          EXCEPT the stop (AAT), sbottom (AAB) and stau (AAL)
C          coefficients are set to zero.
C
C     ===> Code for the general case removing all these
C          artificial restrictions is present below.
C          The preceeding restrictions are specified
C          by giving special values to some variables
C          This is discussed in two sections beginning
C          with the symbols  (*@&*)  in the code below.
C
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C
C
      REAL SR2,PI,GG,TW2,BETA,DSA,DCA,DSB,DCB,MH
      REAL EP,TANB,COTB,ATERM,MSFMIX,THETSF,SIN2B
      REAL TEMP,TEMP1,TEMP2,YA1,YA2
      REAL SINA,COSA,SINA2,COSA2,M1,M2,M12,LAMB
      REAL SINAU,COSAU,SINAD,COSAD
      REAL A11,A22,A12,B11,B22,B12,C11,C12,C21,C22
      REAL ASQ,BSQ,CSQ,DWSF
      REAL DWSFL,DWSFH,DWSFP,DWSFC,SSXLAM
      REAL ASMB,MBMB,MBQ,ASMT,MTMT,MTQ,SUALFS,SSMQCD
      DIMENSION ATERM(12),MSFMIX(12,2),THETSF(12)
      DIMENSION ASQ(10,3),BSQ(9),CSQ(6,4)
      DIMENSION DWSF(12,4),DWSFL(12,4),DWSFH(12,4)
      DIMENSION DWSFP(12,4),DWSFC(6,4)
      INTEGER II,IJ,JJ,IC,IJU,IJD,NUMH
C
C
      SR2=SQRT(2.0)
      PI=4.0*ATAN(1.0)
      TW2=SN2THW/(1.0-SN2THW)
      GG=SQRT(4.0*PI*ALFAEM/SN2THW)
      EP=TWOM1
C
      TANB=1.0/RV2V1
      COTB=RV2V1
      BETA=ATAN(1.0/RV2V1)
      DSA=SIN(ALFAH)
      DCA=COS(ALFAH)
      DSB=SIN(BETA)
      DCB=COS(BETA)
      SIN2B=2.0*DSB*DCB
C
C      Set A-terms.
C      (all A-terms are assumed to be real)
C      The A-terms are loaded into the array ATERM(12)
C      in the following way:
C          ATERM(1)=selectron A-term
C          ATERM(2)=smuon A-term
C          ATERM(3)=stau A-term
C          ATERM(4)=up squark A-term
C          ATERM(5)=charm squark A-term
C          ATERM(6)=down squark A-term
C          ATERM(7)=strange squark A-term
C          ATERM(8)=sbottom A-term
C          ATERM(9)=stop A-term
C          ATERM(10)=selectronic sneutrino A-term
C          ATERM(11)=smuonic sneutrino A-term
C          ATERM(12)=stauonic sneutrino A-term
C
      DO 10 II=1,7
        ATERM(II)=0.0
10    CONTINUE
      ATERM(3)=AAL
      ATERM(8)=AAB
      ATERM(9)=AAT
      DO 20 II=10,12
        ATERM(II)=0.0
20    CONTINUE
C
C      Set mixing parameters.
C      The intra-flavor-mixed sfermion masses are loaded into
C      the array MSFMIX(12,2) where (#,1) is the lighter
C      mixed sfermion mass of a given flavor and (#,2) is the
C      heavier sfermion mass.  The sfermionic mixing angles are
C      loaded into the array THETSF(12).  The identities of the
C      elements of these arrays are given below:
C        MSFMIX(1,*)=mixed selectron masses
C                                 THETSF(1)=selectron mixing angle
C        MSFMIX(2,*)=mixed smuon masses
C                                 THETSF(2)=smuon mixing angle
C        MSFMIX(3,*)=mixed stau masses
C                                 THETSF(3)=stau mixing angle
C        MSFMIX(4,*)=mixed up squark masses
C                                 THETSF(4)=up squark mixing angle
C        MSFMIX(5,*)=mixed charm squark masses
C                                 THETSF(5)=charm squark mixing angle
C        MSFMIX(6,*)=mixed down squark masses
C                                 THETSF(6)=down squark mixing angle
C        MSFMIX(7,*)=mixed strange squark masses
C                                 THETSF(7)=strange squark mixing angle
C        MSFMIX(8,*)=mixed sbottom masses
C                                 THETSF(8)=sbottom mixing angle
C        MSFMIX(9,*)=mixed stop masses
C                                 THETSF(9)=stop mixing angle
C        For sneuterinos MSFMIX(#,2)=0.0, THETSF(#)=0.0 ; #=10-12
C        Yukawa contributions from D-terms to the sneutrino masses
C        are supposed to be added in here.
C        MSFMIX(10,1)= selectronic sneutrino mass with D-terms
C        MSFMIX(11,1)= smuonic sneutrino mass with D-terms
C        MSFMIX(12,1)= stauonic sneutrino mass with D-terms
C
      DO 30 II=10,12
        MSFMIX(II,2)=0.0
        THETSF(II)=0.0
30    CONTINUE
C
C
C       (*@&*) 10/24/93 - Special conditions used ---
C        set all mixing angles EXCEPT stop, sbottom, stau to zero.
C        For all EXCEPT st, sb and stau, set mixed sfermion masses
C        to bare sfermion masses:
C            MSFMIX(#,1) = Left sfermion mass
C            MSFMIX(#,2) = Right sfermion mass  ;  # = 1-8
C         but
C            MSFMIX(9,1) = AMT1SS
C            MSFMIX(9,2) = AMT2SS              , etc.
C
C        (The choice of which to call Left and which to call
C         Right is based on the definition of the sfermion
C         mixing angle theta_sf :
C            sfermion_1 = cos(theta_sf) * sfermion_L
C                            - sin(theta_sf) * sfermion_R
C            sfermion_2 = sin(theta_sf) * sfermion_L
C                            + cos(theta_sf) * sfermion_R
C          Thus if we set theta_sf = 0, then
C                 sfermion_1 = sfermion_L
C           and   sfermion_2 = sfermion_R .               )
C
      DO 40 II=1,7
        THETSF(II)=0.0
40    CONTINUE
      MSFMIX(1,1)=AMELSS
      MSFMIX(1,2)=AMERSS
      MSFMIX(2,1)=AMMLSS
      MSFMIX(2,2)=AMMRSS
      MSFMIX(3,1)=AML1SS
      MSFMIX(3,2)=AML2SS
      THETSF(3)=THETAL
      MSFMIX(4,1)=AMULSS
      MSFMIX(4,2)=AMURSS
      MSFMIX(5,1)=AMCLSS
      MSFMIX(5,2)=AMCRSS
      MSFMIX(6,1)=AMDLSS
      MSFMIX(6,2)=AMDRSS
      MSFMIX(7,1)=AMSLSS
      MSFMIX(7,2)=AMSRSS
      MSFMIX(8,1)=AMB1SS
      MSFMIX(8,2)=AMB2SS
      THETSF(8)=THETAB
      MSFMIX(9,1)=AMT1SS
      MSFMIX(9,2)=AMT2SS
      THETSF(9)=THETAT
      MSFMIX(10,1)=AMN1SS
      MSFMIX(11,1)=AMN2SS
      MSFMIX(12,1)=AMN3SS
C
      DO 1000 NUMH=1,4
        IF(NUMH.EQ.1) THEN
          MH=AMHL
        ELSE IF(NUMH.EQ.2) THEN
          MH=AMHH
        ELSE IF(NUMH.EQ.3) THEN
          MH=AMHA
          GO TO 233
        ELSE IF(NUMH.EQ.4) THEN
          MH=AMHC
          GO TO 333
        ENDIF
      ASMB=SUALFS(AMBT**2,.36,AMTP,3)
      MBMB=AMBT*(1.-4*ASMB/3./PI)
      MBQ=SSMQCD(DBLE(MBMB),DBLE(MH))
      ASMT=SUALFS(AMTP**2,.36,AMTP,3)
      MTMT=AMTP/(1.+4*ASMT/3./PI+(16.11-1.04*(5.-6.63/AMTP))*
     $(ASMT/PI)**2)
      MTQ=SSMQCD(DBLE(MTMT),DBLE(MH))

C
C         Scalar neutral Higgses --> sfermions
C          partial decay widths
C
        IF(NUMH.EQ.1) THEN
          TEMP=GG*AMW*SIN(BETA-ALFAH)/2.0
          YA1=DCA
          YA2=DSA
        ELSE IF(NUMH.EQ.2) THEN
          TEMP=-GG*AMW*COS(BETA-ALFAH)/2.0
          YA1=-DSA
          YA2=DCA
        ENDIF
C
        TEMP1=TEMP*(1.0-TW2/3.0)
        TEMP2=GG*YA1/(AMW*DSB)
        ASQ(4,1)=TEMP1-TEMP2*AMUP**2
        ASQ(5,1)=TEMP1-TEMP2*AMCH**2
        ASQ(9,1)=TEMP1-TEMP2*MTQ**2
C
        TEMP1=-TEMP*(1.0+TW2/3.0)
        TEMP2=GG*YA2/(AMW*DCB)
        ASQ(6,1)=-TEMP1-TEMP2*AMDN**2
        ASQ(7,1)=-TEMP1-TEMP2*AMST**2
        ASQ(8,1)=-TEMP1-TEMP2*MBQ**2
C
        ASQ(10,1)=TEMP*(1.0+TW2)
        TEMP1=TEMP*(TW2-1.0)
        TEMP2=GG*YA2/(AMW*DCB)
        ASQ(1,1)=TEMP1-TEMP2*AME**2
        ASQ(2,1)=TEMP1-TEMP2*AMMU**2
        ASQ(3,1)=TEMP1-TEMP2*AMTAU**2
C
        TEMP1=4.0*TEMP*TW2/3.0
        TEMP2=GG*YA1/(AMW*DSB)
        ASQ(4,2)=TEMP1-TEMP2*AMUP**2
        ASQ(5,2)=TEMP1-TEMP2*AMCH**2
        ASQ(9,2)=TEMP1-TEMP2*MTQ**2
C
        TEMP1=-2.0*TEMP*TW2/3.0
        TEMP2=GG*YA2/(AMW*DCB)
        ASQ(6,2)=TEMP1-TEMP2*AMDN**2
        ASQ(7,2)=TEMP1-TEMP2*AMST**2
        ASQ(8,2)=TEMP1-TEMP2*MBQ**2
C
        ASQ(10,2)=0.0
        TEMP1=-2.0*TEMP*TW2
        TEMP2=GG*YA2/(AMW*DCB)
        ASQ(1,2)=TEMP1-TEMP2*AME**2
        ASQ(2,2)=TEMP1-TEMP2*AMMU**2
        ASQ(3,2)=TEMP1-TEMP2*AMTAU**2
C
        TEMP1=GG/(2.0*AMW*DSB)
        ASQ(4,3)=(EP*YA2 + ATERM(4)*YA1)*TEMP1*AMUP
        ASQ(5,3)=(EP*YA2 + ATERM(5)*YA1)*TEMP1*AMCH
        ASQ(9,3)=(EP*YA2 + ATERM(9)*YA1)*TEMP1*MTQ
C
        TEMP1=GG/(2.0*AMW*DCB)
        ASQ(6,3)=(ATERM(6)*YA2 + EP*YA1)*TEMP1*AMDN
        ASQ(7,3)=(ATERM(7)*YA2 + EP*YA1)*TEMP1*AMST
        ASQ(8,3)=(ATERM(8)*YA2 + EP*YA1)*TEMP1*MBQ
C
        ASQ(10,3)=0.0
        ASQ(1,3)=(ATERM(1)*YA2 + EP*YA1)*TEMP1*AME
        ASQ(2,3)=(ATERM(2)*YA2 + EP*YA1)*TEMP1*AMMU
        ASQ(3,3)=(ATERM(3)*YA2 + EP*YA1)*TEMP1*AMTAU
C
C
        DO 150 IJ=1,9
          IF(IJ.LT.4) THEN
            TEMP1=1.0/(16.0*PI*MH**3)
          ELSE
            TEMP1=3.0/(16.0*PI*MH**3)
          ENDIF
          SINA=SIN(THETSF(IJ))
          COSA=COS(THETSF(IJ))
          SINA2=SINA**2
          COSA2=COSA**2
          M1=MSFMIX(IJ,1)
          M2=MSFMIX(IJ,1)
          M12=M1+M2
          IF(MH.GT.M12) THEN
            A11=ASQ(IJ,1)*COSA2+ASQ(IJ,2)*SINA2
     $              -2.0*ASQ(IJ,3)*SINA*COSA
            LAMB=SSXLAM(MH**2,M1**2,M2**2)
            DWSF(IJ,1)=TEMP1*SQRT(LAMB)*A11**2
          ELSE IF(MH.LE.M12) THEN
            DWSF(IJ,1)=0.0
          ENDIF
C
          M1=MSFMIX(IJ,2)
          M2=MSFMIX(IJ,2)
          M12=M1+M2
          IF(MH.GT.M12) THEN
            A22=ASQ(IJ,1)*SINA2+ASQ(IJ,2)*COSA2
     $                 +2.0*ASQ(IJ,3)*SINA*COSA
            LAMB=SSXLAM(MH**2,M1**2,M2**2)
            DWSF(IJ,2)=TEMP1*SQRT(LAMB)*A22**2
          ELSE IF(MH.LE.M12) THEN
            DWSF(IJ,2)=0.0
          ENDIF
C
          M1=MSFMIX(IJ,1)
          M2=MSFMIX(IJ,2)
          M12=M1+M2
          IF(MH.GT.M12) THEN
            A12=(ASQ(IJ,1)-ASQ(IJ,2))*SINA*COSA
     $                +ASQ(IJ,3)*(COSA2-SINA2)
            LAMB=SSXLAM(MH**2,M1**2,M2**2)
            DWSF(IJ,3)=TEMP1*SQRT(LAMB)*A12**2
          ELSE IF(MH.LE.M12) THEN
               DWSF(IJ,3)=0.0
          ENDIF
C
          DWSF(IJ,4)=DWSF(IJ,3)
C
          IF(NUMH.EQ.1) THEN
            DO 121 JJ=1,4
              DWSFL(IJ,JJ)=DWSF(IJ,JJ)
121         CONTINUE
          ELSE IF(NUMH.EQ.2) THEN
            DO 122 JJ=1,4
              DWSFH(IJ,JJ)=DWSF(IJ,JJ)
122         CONTINUE
          ENDIF
C
150     CONTINUE
C
C          Now take care of sneutrinos.
C
        DO 155 IJ=10,12
          M1=MSFMIX(IJ,1)
          M2=MSFMIX(IJ,1)
          M12=M1+M2
          IF(MH.GT.M12) THEN
            LAMB=SSXLAM(MH**2,M1**2,M2**2)
            DWSF(IJ,1)=SQRT(LAMB)*(ASQ(10,1))**2
     $                           /(16.0*PI*MH**3)
          ELSE IF(MH.LE.M12) THEN
            DWSF(IJ,1) = 0.0
          ENDIF
          DWSF(IJ,2)=0.0
          DWSF(IJ,3)=0.0
          DWSF(IJ,4)=0.0
          IF(NUMH.EQ.1) THEN
            DO 151 JJ=1,4
              DWSFL(IJ,JJ)=DWSF(IJ,JJ)
151         CONTINUE
          ELSE IF(NUMH.EQ.2) THEN
            DO 152 JJ=1,4
              DWSFH(IJ,JJ)=DWSF(IJ,JJ)
152         CONTINUE
          ENDIF
C
155     CONTINUE
        GO TO 1000
C
C
C          Pseudocalar neutral Higgses --> sfermions
C           partial decay widths
C
233     TEMP1=GG/(2.0*AMW)
        BSQ(1)=TEMP1*AME*(EP-TANB*ATERM(1))
        BSQ(2)=TEMP1*AMMU*(EP-TANB*ATERM(2))
        BSQ(3)=TEMP1*AMTAU*(EP-TANB*ATERM(3))
        BSQ(4)=TEMP1*AMUP*(EP-COTB*ATERM(4))
        BSQ(5)=TEMP1*AMCH*(EP-COTB*ATERM(5))
        BSQ(6)=TEMP1*AMDN*(EP-TANB*ATERM(6))
        BSQ(7)=TEMP1*AMST*(EP-TANB*ATERM(7))
        BSQ(8)=TEMP1*MBQ*(EP-TANB*ATERM(8))
        BSQ(9)=TEMP1*MTQ*(EP-COTB*ATERM(9))
C
        DO 260 IJ=1,9
          IF(IJ.LT.4) THEN
            TEMP1=1.0/(16.0*PI*MH**3)
          ELSE
            TEMP1=3.0/(16.0*PI*MH**3)
          ENDIF
          SINA=SIN(THETSF(IJ))
          COSA=COS(THETSF(IJ))
          SINA2=SINA**2
          COSA2=COSA**2
          M1=MSFMIX(IJ,1)
          M2=MSFMIX(IJ,1)
          M12=M1+M2
          IF(MH.GT.M12) THEN
            B11=-2.0*COSA*SINA*BSQ(IJ)
            LAMB=SSXLAM(MH**2,M1**2,M2**2)
            DWSFP(IJ,1)=TEMP1*SQRT(LAMB)*B11**2
          ELSE IF(MH.LE.M12) THEN
            DWSFP(IJ,1)=0.0
          ENDIF
C
          M1=MSFMIX(IJ,2)
          M2=MSFMIX(IJ,2)
          M12=M1+M2
          IF(MH.GT.M12) THEN
            B22=-B11
            LAMB=SSXLAM(MH**2,M1**2,M2**2)
            DWSFP(IJ,2)=TEMP1*SQRT(LAMB)*B22**2
          ELSE IF(MH.LE.M12) THEN
            DWSFP(IJ,2)=0.0
          ENDIF
          M1=MSFMIX(IJ,1)
          M2=MSFMIX(IJ,2)
          M12=M1+M2
          IF(MH.GT.M12) THEN
            B12=(COSA2-SINA2)*BSQ(IJ)
            LAMB=SSXLAM(MH**2,M1**2,M2**2)
            DWSFP(IJ,3)=TEMP1*SQRT(LAMB)*B12**2
          ELSE IF(MH.LE.M12) THEN
            DWSFP(IJ,3)=0.0
          ENDIF
          DWSFP(IJ,4)=DWSFP(IJ,3)
260     CONTINUE
        DO 265 IJ=10,12
           DO 264 JJ=1,4
             DWSFP(IJ,JJ)=0.0
264        CONTINUE
265     CONTINUE
        GO TO 1000
C
C          Charged Higgses --> sfermions
C           partial decay widths
C
333     TEMP1=-AMW*SIN2B
        CSQ(1,1)=GG*(TEMP1+(TANB*AMDN**2 + COTB*AMUP**2)/AMW)/SR2
        CSQ(2,1)=GG*(TEMP1+(TANB*AMST**2 + COTB*AMCH**2)/AMW)/SR2
        CSQ(3,1)=GG*(TEMP1+(TANB*MBQ**2 + COTB*MTQ**2)/AMW)/SR2
        CSQ(4,1)=GG*(TEMP1 + (TANB*AME**2)/AMW)/SR2
        CSQ(5,1)=GG*(TEMP1 + (TANB*AMMU**2)/AMW)/SR2
        CSQ(6,1)=GG*(TEMP1 + (TANB*AMTAU**2)/AMW)/SR2
C
        TEMP1=GG*(COTB+TANB)/(SR2*AMW)
        CSQ(1,2)=TEMP1*AMUP*AMDN
        CSQ(2,2)=TEMP1*AMCH*AMST
        CSQ(3,2)=TEMP1*MTQ*MBQ
        CSQ(4,2)=0.0
        CSQ(5,2)=0.0
        CSQ(6,2)=0.0
C
        TEMP1=GG/(SR2*AMW)
        CSQ(1,3)=TEMP1*AMUP*(EP-COTB*ATERM(4))
        CSQ(2,3)=TEMP1*AMCH*(EP-COTB*ATERM(5))
        CSQ(3,3)=TEMP1*MTQ*(EP-COTB*ATERM(9))
        CSQ(4,3)=0.0
        CSQ(5,3)=0.0
        CSQ(6,3)=0.0
C
        CSQ(1,4)=TEMP1* AMDN*(EP-TANB*ATERM(6))
        CSQ(2,4)=TEMP1* AMST*(EP-TANB*ATERM(7))
        CSQ(3,4)=TEMP1* MBQ*(EP-TANB*ATERM(8))
        CSQ(4,4)=TEMP1* AME*(EP-TANB*ATERM(1))
        CSQ(5,4)=TEMP1* AMMU*(EP-TANB*ATERM(2))
        CSQ(6,4)=TEMP1* AMTAU*(EP-TANB*ATERM(3))
C
        DO 350 IC=1,3
          TEMP1=3.0/(16.0*PI*MH**3)
          IF(IC.EQ.1) THEN
            IJU=4
            IJD=6
          ELSE IF(IC.EQ.2) THEN
            IJU=5
            IJD=7
          ELSE IF(IC.EQ.3) THEN
            IJU=9
            IJD=8
          ENDIF
          SINAU=SIN(THETSF(IJU))
          COSAU=COS(THETSF(IJU))
          SINAD=SIN(THETSF(IJD))
          COSAD=COS(THETSF(IJD))
C
          M1=MSFMIX(IJU,1)
          M2=MSFMIX(IJD,1)
          M12=M1+M2
          IF(MH.GT.M12) THEN
            C11=COSAU*COSAD*CSQ(IC,1)
     $            + SINAU*SINAD*CSQ(IC,2)
     $                - SINAU*COSAD*CSQ(IC,3)
     $                    - COSAU*SINAD*CSQ(IC,4)
            LAMB=SSXLAM(MH**2,M1**2,M2**2)
            DWSFC(IC,1)=TEMP1*SQRT(LAMB)*C11**2
          ELSE IF(MH.LE.M12) THEN
            DWSFC(IC,1) = 0.0
          ENDIF
C
          M1=MSFMIX(IJU,1)
          M2=MSFMIX(IJD,2)
          M12=M1+M2
          IF(MH.GT.M12) THEN
            C12=COSAU*SINAD*CSQ(IC,1)
     $            - SINAU*COSAD*CSQ(IC,2)
     $                - SINAU*SINAD*CSQ(IC,3)
     $                    + COSAU*COSAD*CSQ(IC,4)
            LAMB=SSXLAM(MH**2,M1**2,M2**2)
            DWSFC(IC,2)=TEMP1*SQRT(LAMB)*C12**2
          ELSE IF(MH.LE.M12) THEN
            DWSFC(IC,2)=0.0
          ENDIF
C
          M1=MSFMIX(IJU,2)
          M2=MSFMIX(IJD,1)
          M12=M1+M2
          IF(MH.GT.M12) THEN
            C21=SINAU*COSAD*CSQ(IC,1)
     $            - COSAU*SINAD*CSQ(IC,2)
     $                + COSAU*COSAD*CSQ(IC,3)
     $                    - SINAU*SINAD*CSQ(IC,4)
            LAMB=SSXLAM(MH**2,M1**2,M2**2)
            DWSFC(IC,3)=TEMP1*SQRT(LAMB)*C21**2
          ELSE IF(MH.LE.M12) THEN
            DWSFC(IC,3)=0.0
          ENDIF
C
          M1=MSFMIX(IJU,2)
          M2=MSFMIX(IJD,2)
          M12=M1+M2
          IF(MH.GT.M12) THEN
            C22=SINAU*SINAD*CSQ(IC,1)
     $            + COSAU*COSAD*CSQ(IC,2)
     $                + COSAU*SINAD*CSQ(IC,3)
     $                    - SINAU*COSAD*CSQ(IC,4)
            LAMB=SSXLAM(MH**2,M1**2,M2**2)
            DWSFC(IC,4)=TEMP1*SQRT(LAMB)*C22**2
          ELSE IF(MH.LE.M12) THEN
            DWSFC(IC,4)=0.0
          ENDIF
C
350     CONTINUE
C
C
C         Now calculate the sleptonic
C          partial decay widths of the
C          charged Higgs.
C
        DO 355 IC = 4,6
          TEMP1=1.0/(16.0*PI*MH**3)
            IF(IC.EQ.4) THEN
              IJU=10
              IJD=1
            ELSE IF(IC.EQ.5) THEN
              IJU=11
              IJD=2
            ELSE IF(IC.EQ.6) THEN
              IJU=12
              IJD=3
            ENDIF
            SINAD=SIN(THETSF(IJD))
            COSAD=COS(THETSF(IJD))
C
            M1=MSFMIX(IJU,1)
            M2=MSFMIX(IJD,1)
            M12=M1+M2
            IF(MH.GT.M12) THEN
              C11=COSAD*CSQ(IC,1)-SINAD*CSQ(IC,4)
              LAMB=SSXLAM(MH**2,M1**2,M2**2)
              DWSFC(IC,1)=TEMP1*SQRT(LAMB)*C11**2
            ELSE IF(MH.LE.M12) THEN
              DWSFC(IC,1)=0.0
            ENDIF
C
            M1=MSFMIX(IJU,1)
            M2=MSFMIX(IJD,2)
            M12=M1+M2
            IF(MH.GT.M12) THEN
              C12=SINAD*CSQ(IC,1)+COSAD*CSQ(IC,4)
              LAMB=SSXLAM(MH**2,M1**2,M2**2)
              DWSFC(IC,2)=TEMP1*SQRT(LAMB)*C12**2
            ELSE IF(MH.LE.M12) THEN
              DWSFC(IC,2)=0.0
            ENDIF
            DWSFC(IC,3)=0.0
            DWSFC(IC,4)=0.0
355     CONTINUE
1000  CONTINUE
C          H_l decays
      CALL SSSAVE(ISHL,DWSFL(1,1),ISEL,-ISEL,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(1,2),ISER,-ISER,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(2,1),ISMUL,-ISMUL,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(2,2),ISMUR,-ISMUR,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(3,1),ISTAU1,-ISTAU1,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(3,2),ISTAU2,-ISTAU2,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(3,3),ISTAU1,-ISTAU2,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(3,4),ISTAU2,-ISTAU1,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(4,1),ISUPL,-ISUPL,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(4,2),ISUPR,-ISUPR,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(5,1),ISCHL,-ISCHL,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(5,2),ISCHR,-ISCHR,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(6,1),ISDNL,-ISDNL,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(6,2),ISDNR,-ISDNR,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(7,1),ISSTL,-ISSTL,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(7,2),ISSTR,-ISSTR,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(8,1),ISBT1,-ISBT1,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(8,2),ISBT2,-ISBT2,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(8,3),ISBT1,-ISBT2,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(8,4),ISBT2,-ISBT1,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(9,1),ISTP1,-ISTP1,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(9,2),ISTP2,-ISTP2,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(9,3),ISTP1,-ISTP2,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(9,4),ISTP2,-ISTP1,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(10,1),ISNEL,-ISNEL,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(11,1),ISNML,-ISNML,0,0,0)
      CALL SSSAVE(ISHL,DWSFL(12,1),ISNTL,-ISNTL,0,0,0)
C         H_h decays
      CALL SSSAVE(ISHH,DWSFH(1,1),ISEL,-ISEL,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(1,2),ISER,-ISER,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(2,1),ISMUL,-ISMUL,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(2,2),ISMUR,-ISMUR,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(3,1),ISTAU1,-ISTAU1,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(3,2),ISTAU2,-ISTAU2,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(3,3),ISTAU1,-ISTAU2,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(3,4),ISTAU2,-ISTAU1,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(4,1),ISUPL,-ISUPL,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(4,2),ISUPR,-ISUPR,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(5,1),ISCHL,-ISCHL,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(5,2),ISCHR,-ISCHR,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(6,1),ISDNL,-ISDNL,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(6,2),ISDNR,-ISDNR,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(7,1),ISSTL,-ISSTL,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(7,2),ISSTR,-ISSTR,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(8,1),ISBT1,-ISBT1,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(8,2),ISBT2,-ISBT2,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(8,3),ISBT1,-ISBT2,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(8,4),ISBT2,-ISBT1,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(9,1),ISTP1,-ISTP1,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(9,2),ISTP2,-ISTP2,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(9,3),ISTP1,-ISTP2,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(9,4),ISTP2,-ISTP1,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(10,1),ISNEL,-ISNEL,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(11,1),ISNML,-ISNML,0,0,0)
      CALL SSSAVE(ISHH,DWSFH(12,1),ISNTL,-ISNTL,0,0,0)
C          Decay of H_p
      CALL SSSAVE(ISHA,DWSFP(1,3),ISEL,-ISER,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(1,4),ISER,-ISEL,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(2,3),ISMUL,-ISMUR,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(2,4),ISMUR,-ISMUL,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(3,1),ISTAU1,-ISTAU1,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(3,2),ISTAU2,-ISTAU2,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(3,3),ISTAU1,-ISTAU2,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(3,4),ISTAU2,-ISTAU1,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(4,3),ISUPL,-ISUPR,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(4,4),ISUPR,-ISUPL,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(5,3),ISCHL,-ISCHR,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(5,4),ISCHR,-ISCHL,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(6,3),ISDNL,-ISDNR,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(6,4),ISDNR,-ISDNL,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(7,3),ISSTL,-ISSTR,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(7,4),ISSTR,-ISSTL,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(8,1),ISBT1,-ISBT1,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(8,2),ISBT2,-ISBT2,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(8,3),ISBT1,-ISBT2,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(8,4),ISBT2,-ISBT1,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(9,1),ISTP1,-ISTP1,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(9,2),ISTP2,-ISTP2,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(9,3),ISTP1,-ISTP2,0,0,0)
      CALL SSSAVE(ISHA,DWSFP(9,4),ISTP2,-ISTP1,0,0,0)
C          Decay of H+
      CALL SSSAVE(ISHC,DWSFC(1,1),ISUPL,-ISDNL,0,0,0)
      CALL SSSAVE(ISHC,DWSFC(1,2),ISUPR,-ISDNR,0,0,0)
      CALL SSSAVE(ISHC,DWSFC(2,1),ISCHL,-ISSTL,0,0,0)
      CALL SSSAVE(ISHC,DWSFC(2,2),ISCHR,-ISSTR,0,0,0)
      CALL SSSAVE(ISHC,DWSFC(3,1),ISTP1,-ISBT1,0,0,0)
      CALL SSSAVE(ISHC,DWSFC(3,2),ISTP1,-ISBT2,0,0,0)
      CALL SSSAVE(ISHC,DWSFC(3,3),ISTP2,-ISBT1,0,0,0)
      CALL SSSAVE(ISHC,DWSFC(3,4),ISTP2,-ISBT2,0,0,0)
      CALL SSSAVE(ISHC,DWSFC(4,1),-ISEL,ISNEL,0,0,0)
      CALL SSSAVE(ISHC,DWSFC(5,1),-ISMUL,ISNML,0,0,0)
      CALL SSSAVE(ISHC,DWSFC(6,1),-ISTAU1,ISNTL,0,0,0)
      CALL SSSAVE(ISHC,DWSFC(6,2),-ISTAU2,ISNTL,0,0,0)
      RETURN
      END
CDECK  ID>, SSHWW.  
      SUBROUTINE SSHWW
C-----------------------------------------------------------------------
C     Calculate HL, HH -> WW, ZZ, using either the on-shell matrix
C     element if kinematically allowed or the WW* or ZZ* matrix
C     element from Eqn.(6) for Keung and Marciano (PRD. 84: 248).
C     For the latter, save the mode as W(Z) f fbar, and require that
C     MH > MW + 2 * MB.
C
C     Bisset's GBDCY
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C
      EXTERNAL SSHWW1,SSHWW2
      DOUBLE PRECISION SSHWW1,SSHWW2
      DOUBLE PRECISION PI,SR2,G2,BETA,ALPHA,SW2,CW2,CAB2,SAB2,MW,MZ
     $,MH,COUPL,LOWER,UPPER,FWW1,FWW2,FWW3,FWW,DWID,FZZ
      DOUBLE PRECISION SSDINT,SSDLAM
      REAL WID
      REAL BRZN,BRZL,BRZU,BRZD,BRWL,BRWQ
      INTEGER IDH,IH
C          Hard wired Z branching ratios
      DATA BRZN,BRZL,BRZU,BRZD/.06839,.03442,.11792,.15191/
      DATA BRWL,BRWQ/.11111,.33333/
C
C          Mass matrix parameters
C
      PI=4*ATAN(1.D0)
      SR2=SQRT(2.D0)
      G2=4*PI*ALFAEM/SN2THW
      BETA=ATAN(1.0/RV2V1)
      ALPHA=ALFAH
      SW2=SN2THW
      CW2=1.-SN2THW
      CAB2=(DCOS(ALPHA+BETA))**2
      SAB2=1.0-CAB2
      MW=AMW
      MZ=AMZ
C
C          WW* and ZZ* decays
C
      DO 100 IH=1,2
        IF(IH.EQ.1) THEN
          MH=AMHL
          IDH=ISHL
          COUPL=SAB2
        ELSE
          MH=AMHH
          IDH=ISHH
          COUPL=CAB2
        ENDIF
C          H -> W + W* -> W + f + fbar
        TMP(1)=MH
        IF(MH.GT.MW+2*AMBT.AND.MH.LE.2*MW) THEN
          LOWER=2*MW/MH
          UPPER=1+MW**2/MH**2
          IF (LOWER.LT.0.998D0) THEN
            IF (UPPER.LE.1.001D0) THEN
              FWW1=SSDINT(LOWER,SSHWW1,0.998D0)
              FWW2=SSDINT(0.998D0,SSHWW1,UPPER)
              FWW=FWW1+FWW2
            ELSEIF(UPPER.GT.1.001D0) THEN
              FWW1=SSDINT(LOWER,SSHWW1,0.998D0)
              FWW2=SSDINT(0.998D0,SSHWW1,1.001D0)
              FWW3=SSDINT(1.001D0,SSHWW1,UPPER)
              FWW=FWW1+FWW2+FWW3
            ENDIF
          ELSE IF (0.998D0.LT.LOWER.AND.LOWER.LT.1.001D0) THEN
            IF (UPPER.LE.1.001D0) THEN
              FWW=SSDINT(LOWER,SSHWW1,UPPER)
            ELSEIF(UPPER.GT.1.001D0) THEN
              FWW1=SSDINT(LOWER,SSHWW1,1.001D0)
              FWW2=SSDINT(1.001D0,SSHWW1,UPPER)
              FWW=FWW1+FWW2
            ENDIF
          ELSE IF (LOWER.GT.1.001D0) THEN
            FWW=SSDINT(LOWER,SSHWW1,UPPER)
          END IF
          DWID=3*(G2**2)*MH*FWW/(512.0*PI**3)
          WID=DWID*COUPL
          CALL SSSAVE(IDH,0.5*BRWL*WID,IDW,IDE,-IDNE,0,0)
          CALL SSSAVE(IDH,0.5*BRWL*WID,IDW,IDMU,-IDNM,0,0)
          CALL SSSAVE(IDH,0.5*BRWL*WID,IDW,IDTAU,-IDNT,0,0)
          CALL SSSAVE(IDH,0.5*BRWQ*WID,IDW,-IDUP,IDDN,0,0)
          CALL SSSAVE(IDH,0.5*BRWQ*WID,IDW,-IDCH,IDST,0,0)
          CALL SSSAVE(IDH,0.5*BRWL*WID,-IDW,-IDE,IDNE,0,0)
          CALL SSSAVE(IDH,0.5*BRWL*WID,-IDW,-IDMU,IDNM,0,0)
          CALL SSSAVE(IDH,0.5*BRWL*WID,-IDW,-IDTAU,IDNT,0,0)
          CALL SSSAVE(IDH,0.5*BRWQ*WID,-IDW,IDUP,-IDDN,0,0)
          CALL SSSAVE(IDH,0.5*BRWQ*WID,-IDW,IDCH,-IDST,0,0)
        ENDIF
C          H -> Z + Z* -> Z + f + fbar
        IF(MH.GT.MZ+2*AMBT.AND.MH.LE.2*MZ) THEN
          LOWER=2*MZ/MH
          UPPER=1+MZ**2/MH**2
          FZZ=SSDINT(LOWER,SSHWW2,UPPER)
          DWID=7.0-40*SW2/3+160*SW2**2/9
          DWID=DWID/CW2**2
          DWID=DWID*G2**2*MH*FZZ/(2048*PI**3)
          WID=DWID*COUPL
          CALL SSSAVE(IDH,BRZN*WID,IDZ,IDNE,-IDNE,0,0)
          CALL SSSAVE(IDH,BRZN*WID,IDZ,IDNM,-IDNM,0,0)
          CALL SSSAVE(IDH,BRZN*WID,IDZ,IDNT,-IDNT,0,0)
          CALL SSSAVE(IDH,BRZL*WID,IDZ,IDE,-IDE,0,0)
          CALL SSSAVE(IDH,BRZL*WID,IDZ,IDMU,-IDMU,0,0)
          CALL SSSAVE(IDH,BRZL*WID,IDZ,IDTAU,-IDTAU,0,0)
          CALL SSSAVE(IDH,BRZU*WID,IDZ,IDUP,-IDUP,0,0)
          CALL SSSAVE(IDH,BRZU*WID,IDZ,IDCH,-IDCH,0,0)
          CALL SSSAVE(IDH,BRZD*WID,IDZ,IDDN,-IDDN,0,0)
          CALL SSSAVE(IDH,BRZD*WID,IDZ,IDST,-IDST,0,0)
          CALL SSSAVE(IDH,BRZD*WID,IDZ,IDBT,-IDBT,0,0)
        ENDIF
100   CONTINUE
C
C          HH -> WW, ZZ
C          If these are allowed, the WW* and ZZ* are not.
C
      MH=AMHH
      IF(MH.GT.2*MW) THEN
        DWID=3+(MH/MW)**4/4-(MH/MW)**2
        DWID=DWID*G2*CAB2*MW**2/(16.0*PI*MH**3)/(2*CW2**2)
        WID=DWID*SQRT(SSDLAM(MH**2,MW**2,MW**2))
        CALL SSSAVE(ISHH,WID,IDW,-IDW,0,0,0)
      ENDIF
      IF(MH.GT.2*MZ) THEN
        DWID=3+(MH/MZ)**4/4-(MH/MZ)**2
        DWID=DWID*G2*CAB2*MW**2/(16.0*PI*MH**3)/(2.0*CW2**2)
        WID=DWID*SQRT(SSDLAM(MH**2,MZ**2,MZ**2))
        CALL SSSAVE(ISHH,WID,IDZ,IDZ,0,0,0)
      ENDIF
C
      RETURN
      END
CDECK  ID>, SSHWW1. 
      DOUBLE PRECISION FUNCTION SSHWW1(XX)
C-----------------------------------------------------------------------
C     SSHWW: hi -> w + w*
C     Bisset's FUNWW
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      DOUBLE PRECISION XX,EPLN,PROP,TEMP,FN,AAA,MW,DELTAW,MH
C
      MW=AMW
      DELTAW=GAMW
      MH=TMP(1)
C
      EPLN=MW/MH
      PROP=(1.D0-XX)**2
      PROP=PROP+(EPLN**2)*DELTAW**2/MH**2
      TEMP=XX**2-12*XX*EPLN**2
      TEMP=TEMP+8*EPLN**2+12*EPLN**4
      AAA=XX**2-4*EPLN**2
      IF(AAA.LT.0) THEN
         AAA=0
      ENDIF
      FN=TEMP*SQRT(AAA)/PROP
      SSHWW1=FN
      RETURN
      END
CDECK  ID>, SSHWW2. 
      DOUBLE PRECISION FUNCTION SSHWW2(XX)
C-----------------------------------------------------------------------
C     SSHWW: hi -> z + z*
C     Bisset's FUNZZ
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      DOUBLE PRECISION XX,EPLN,PROP,TEMP,FN,AAA,MZ,DELTAZ,MH
C
C
      MZ=AMZ
      DELTAZ=GAMZ
      MH=TMP(1)
C
      EPLN=MZ/MH
      PROP=(1.D0-XX)**2
      PROP=PROP+(EPLN**2)*DELTAZ**2/MH**2
      TEMP=XX**2-12*XX*EPLN**2
      TEMP=TEMP+8*EPLN**2+12*EPLN**4
      AAA=XX**2-4*EPLN**2
      IF(AAA.LT.0) THEN
        AAA=0
      ENDIF
      FN=TEMP*SQRT(AAA)/PROP
      SSHWW2=FN
      RETURN
      END
CDECK  ID>, SSLPBF. 
        SUBROUTINE SSLPBF
C--------------------------------------------------------
C
C        This program gives slepton branching fractions to gauginos
C        according to Baer,Bartl,Karatas,Majerotto,Tata
C        (Int. J. Mod. Phys. A4,4111 (1989); updated 10/21/96
C
C
C-------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          MXSS                 = maximum number of modes
C          NSSMOD               = number of modes
C          ISSMOD               = initial particle
C          JSSMOD               = final particles
C          GSSMOD               = width
C          BSSMOD               = branching ratio
      INTEGER MXSS
      PARAMETER (MXSS=1000)
      COMMON/SSMODE/NSSMOD,ISSMOD(MXSS),JSSMOD(5,MXSS),GSSMOD(MXSS)
     $,BSSMOD(MXSS)
      INTEGER NSSMOD,ISSMOD,JSSMOD
      REAL GSSMOD,BSSMOD
      SAVE /SSMODE/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      EXTERNAL SSLRT1
      REAL SSXLAM,SSXINT,SSLRT1
      REAL WID,SNZI,THIZ,XM,YM,THX,THY,BPLWI(2),CS2THW
      REAL VS,PI,SR2,G,GP,VP,V,TANB,ANWI(2),ALWI(2)
      REAL ANIZ,AEIZ,BEIZ,MZIZ,SINL,COSL,BETA,FL,AMPL
      REAL MTAMTA,MTAMB,MTAMZ,SUALFE
      REAL MW1,MW2,TN2THW,SNW1,SNW2,AS,BS,BH,COSA,SINA,A
      REAL XLO,SUM1,SUM2,AEJZ,TERM,WID1,WID2
      INTEGER IZ,JZ
      INTEGER ISZIZ(4)
      COMPLEX ZI,ZONE,ZA,ZB,ZALIZ,ZBLIZ,ZPP,ZPM
      DATA ZONE/(1.,0.)/,ZI/(0.,1.)/
C
C          Partly duplicated from SSMASS
C
      AMPL=2.4E18
      PI=4.*ATAN(1.)
      SR2=SQRT(2.)
      G=SQRT(4*PI*ALFAEM/SN2THW)
      GP=G*SQRT(SN2THW/(1.-SN2THW))
      CS2THW=1.-SN2THW
      TN2THW=SN2THW/CS2THW
      VS=2*AMW**2/G/G/(1.+RV2V1**2)
      V=SQRT(VS)
      VP=RV2V1*V
      TANB=1./RV2V1
      BETA=ATAN(TANB)
      SINA=SIN(ALFAH)
      COSA=COS(ALFAH)
      XM=1./TAN(GAMMAL)
      YM=1./TAN(GAMMAR)
      THX=SIGN(1.,XM)
      THY=SIGN(1.,YM)
      MTAMTA=AMTAU*(1.-SUALFE(AMTAU**2)/PI)
      MTAMB=MTAMTA*(SUALFE(AMBT**2)/SUALFE(AMTAU**2))**(-27./76.)
      MTAMZ=MTAMB*(SUALFE(AMZ**2)/SUALFE(AMBT**2))**(-27./80.)
      FL=G*MTAMZ/SR2/AMW/COS(BETA)
      SINL=SIN(THETAL)
      COSL=COS(THETAL)
      SNW1=SIGN(1.,AMW1SS)
      SNW2=SIGN(1.,AMW2SS)
      BPLWI(1)=-FL*COS(GAMMAL)
      BPLWI(2)=FL*THX*SIN(GAMMAL)
      ANWI(1)=G*SIN(GAMMAL)
      ALWI(1)=SNW1*G*SIN(GAMMAR)
      ANWI(2)=G*THX*COS(GAMMAL)
      ALWI(2)=SNW2*G*THY*COS(GAMMAR)
C          Reconstruct masses from SSMASS
      MW1=ABS(AMW1SS)
      MW2=ABS(AMW2SS)
C
C          Compute slepton branching fractions to zi
C
      ISZIZ(1)=ISZ1
      ISZIZ(2)=ISZ2
      ISZIZ(3)=ISZ3
      ISZIZ(4)=ISZ4
      DO 100 IZ=1,4
        SNZI=SIGN(1.,AMZISS(IZ))
        IF (SNZI.EQ.1.) THEN
           THIZ=0.
        ELSE
           THIZ=1.
        END IF
        MZIZ=ABS(AMZISS(IZ))
        ANIZ=G/SR2*ZMIXSS(3,IZ)-GP/SR2*ZMIXSS(4,IZ)
        AEIZ=G/SR2*ZMIXSS(3,IZ)+GP/SR2*ZMIXSS(4,IZ)
        BEIZ=SR2*GP*ZMIXSS(4,IZ)
        ZALIZ=ZI**(THIZ-1.)*SNZI
     $  *(G/SR2*ZMIXSS(3,IZ)+GP/SR2*ZMIXSS(4,IZ))
        ZBLIZ=-1*ZI**(THIZ-1.)*SR2*GP*ZMIXSS(4,IZ)
        ZPP=ZI**THIZ
        ZPM=(-ZI)**THIZ
C          sLEPTON --> LEPTON + zi
        IF (AMELSS.GT.(MZIZ+AME)) THEN
          WID=AEIZ**2*(AMELSS**2-MZIZ**2-AME**2)/AMELSS**3
     $        /16./PI*SQRT(SSXLAM(AMELSS**2,MZIZ**2,AME**2))
          CALL SSSAVE(ISEL,WID,ISZIZ(IZ),IDE,0,0,0)
        ENDIF
        IF (AMMLSS.GT.(MZIZ+AMMU)) THEN
          WID=AEIZ**2*(AMMLSS**2-MZIZ**2-AMMU**2)/AMMLSS**3
     $        /16./PI*SQRT(SSXLAM(AMMLSS**2,MZIZ**2,AMMU**2))
          CALL SSSAVE(ISMUL,WID,ISZIZ(IZ),IDMU,0,0,0)
        ENDIF
        IF (AMN1SS.GT.MZIZ) THEN
          WID=ANIZ**2*AMN1SS*(1.-MZIZ**2/AMN1SS**2)**2/16./PI
          CALL SSSAVE(ISNEL,WID,ISZIZ(IZ),IDNE,0,0,0)
        ENDIF
        IF (AMN2SS.GT.MZIZ) THEN
          WID=ANIZ**2*AMN2SS*(1.-MZIZ**2/AMN2SS**2)**2/16./PI
          CALL SSSAVE(ISNML,WID,ISZIZ(IZ),IDNM,0,0,0)
        ENDIF
        IF (AMN3SS.GT.MZIZ) THEN
          WID=ANIZ**2*AMN3SS*(1.-MZIZ**2/AMN3SS**2)**2/16./PI
          CALL SSSAVE(ISNTL,WID,ISZIZ(IZ),IDNT,0,0,0)
        ENDIF
        IF (AMERSS.GT.(MZIZ+AME)) THEN
          WID=BEIZ**2*(AMERSS**2-MZIZ**2-AME**2)/AMERSS**3
     $        /16./PI*SQRT(SSXLAM(AMERSS**2,MZIZ**2,AME**2))
          CALL SSSAVE(ISER,WID,ISZIZ(IZ),IDE,0,0,0)
        ENDIF
        IF (AMMRSS.GT.(MZIZ+AMMU)) THEN
          WID=BEIZ**2*(AMMRSS**2-MZIZ**2-AMMU**2)/AMMRSS**3
     $        /16./PI*SQRT(SSXLAM(AMMRSS**2,MZIZ**2,AMMU**2))
          CALL SSSAVE(ISMUR,WID,ISZIZ(IZ),IDMU,0,0,0)
        ENDIF
C          sTAU_1 --> TAU + zi
        IF (AML1SS.GT.(MZIZ+AMTAU)) THEN
          ZA=((ZI*ZALIZ-ZPP*FL*ZMIXSS(2,IZ))*COSL
     $     -(ZI*ZBLIZ-ZPM*FL*ZMIXSS(2,IZ))*SINL)/2.
          ZB=((-ZI*ZALIZ-ZPP*FL*ZMIXSS(2,IZ))*COSL
     $     -(ZI*ZBLIZ+ZPM*FL*ZMIXSS(2,IZ))*SINL)/2.
          AS=ZA*CONJG(ZA)
          BS=ZB*CONJG(ZB)
          WID=(AS*(AML1SS**2-(AMTAU+MZIZ)**2)+BS*(AML1SS**2-
     $     (MZIZ-AMTAU)**2))/8./PI/AML1SS**3*
     $     SQRT(SSXLAM(AML1SS**2,MZIZ**2,AMTAU**2))
          CALL SSSAVE(ISTAU1,WID,ISZIZ(IZ),IDTAU,0,0,0)
        END IF
        IF (AML2SS.GT.(MZIZ+AMTAU)) THEN
          ZA=((ZI*ZALIZ-ZPP*FL*ZMIXSS(2,IZ))*SINL
     $     +(ZI*ZBLIZ-ZPM*FL*ZMIXSS(2,IZ))*COSL)/2.
          ZB=((-ZI*ZALIZ-ZPP*FL*ZMIXSS(2,IZ))*SINL
     $     +(ZI*ZBLIZ+ZPM*FL*ZMIXSS(2,IZ))*COSL)/2.
          AS=ZA*CONJG(ZA)
          BS=ZB*CONJG(ZB)
          WID=(AS*(AML2SS**2-(AMTAU+MZIZ)**2)+BS*(AML2SS**2-
     $     (MZIZ-AMTAU)**2))/8./PI/AML2SS**3*
     $     SQRT(SSXLAM(AML2SS**2,MZIZ**2,AMTAU**2))
          CALL SSSAVE(ISTAU2,WID,ISZIZ(IZ),IDTAU,0,0,0)
        END IF
100   CONTINUE
C
C           Compute branching fractions to wi --- theta-C = 0
C
      IF (AMELSS.GT.MW1) THEN
        WID=ANWI(1)**2*AMELSS*(1.-MW1**2/AMELSS**2)**2/16./PI
        CALL SSSAVE(ISEL,WID,-ISW1,IDNE,0,0,0)
      END IF
      IF (AMMLSS.GT.MW1) THEN
        WID=ANWI(1)**2*AMMLSS*(1.-MW1**2/AMMLSS**2)**2/16./PI
        CALL SSSAVE(ISMUL,WID,-ISW1,IDNM,0,0,0)
      END IF
      IF (AML1SS.GT.MW1) THEN
        AS=(-ANWI(1)*COSL-BPLWI(1)*SINL)**2
        WID=AS*AML1SS*(1.-MW1**2/AML1SS**2)**2/16./PI
        CALL SSSAVE(ISTAU1,WID,-ISW1,IDNT,0,0,0)
      END IF
      IF (AML2SS.GT.MW1) THEN
        AS=(-ANWI(1)*SINL+BPLWI(1)*COSL)**2
        WID=AS*AML2SS*(1.-MW1**2/AML2SS**2)**2/16./PI
        CALL SSSAVE(ISTAU2,WID,-ISW1,IDNT,0,0,0)
      END IF
C
      IF (AMN1SS.GT.(MW1+AME)) THEN
        WID=ALWI(1)**2*(AMN1SS**2-MW1**2-AME**2)*
     $      SQRT(SSXLAM(AMN1SS**2,MW1**2,AME**2))/16./PI/AMN1SS**3
        CALL SSSAVE(ISNEL,WID,ISW1,IDE,0,0,0)
      END IF
      IF (AMN2SS.GT.(MW1+AMMU)) THEN
        WID=ALWI(1)**2*(AMN2SS**2-MW1**2-AMMU**2)*
     $      SQRT(SSXLAM(AMN2SS**2,MW1**2,AMMU**2))/16./PI/AMN2SS**3
        CALL SSSAVE(ISNML,WID,ISW1,IDMU,0,0,0)
      END IF
C
      IF (AMN3SS.GT.(MW1+AMTAU)) THEN
        WID=((ALWI(1)**2+BPLWI(1)**2)*(AMN3SS**2-MW1**2-AMTAU**2)+
     $     4*MW1*AMTAU*BPLWI(1)*ALWI(1))*
     $     SQRT(SSXLAM(AMN3SS**2,MW1**2,AMTAU**2))/16./PI/AMN3SS**3
        CALL SSSAVE(ISNTL,WID,ISW1,IDTAU,0,0,0)
      END IF
C
C
      IF (AMELSS.GT.MW2) THEN
        WID=ANWI(2)**2*AMELSS*(1.-MW2**2/AMELSS**2)**2/16./PI
        CALL SSSAVE(ISEL,WID,-ISW2,IDNE,0,0,0)
      END IF
      IF (AMMLSS.GT.MW2) THEN
        WID=ANWI(2)**2*AMMLSS*(1.-MW2**2/AMMLSS**2)**2/16./PI
        CALL SSSAVE(ISMUL,WID,-ISW2,IDNM,0,0,0)
      END IF
      IF (AML1SS.GT.MW2) THEN
        AS=(-ANWI(2)*COSL-BPLWI(2)*SINL)**2
        WID=AS*AML1SS*(1.-MW2**2/AML1SS**2)**2/16./PI
        CALL SSSAVE(ISTAU1,WID,-ISW2,IDNT,0,0,0)
      END IF
      IF (AML2SS.GT.MW2) THEN
        AS=(-ANWI(2)*SINL+BPLWI(2)*COSL)**2
        WID=AS*AML2SS*(1.-MW2**2/AML2SS**2)**2/16./PI
        CALL SSSAVE(ISTAU2,WID,-ISW2,IDNT,0,0,0)
      END IF
C
      IF (AMN1SS.GT.(MW2+AME)) THEN
        WID=ALWI(2)**2*(AMN1SS**2-MW2**2-AME**2)*
     $      SQRT(SSXLAM(AMN1SS**2,MW2**2,AME**2))/16./PI/AMN1SS**3
        CALL SSSAVE(ISNEL,WID,ISW2,IDE,0,0,0)
      END IF
      IF (AMN2SS.GT.(MW2+AMMU)) THEN
        WID=ALWI(2)**2*(AMN2SS**2-MW2**2-AMMU**2)*
     $      SQRT(SSXLAM(AMN2SS**2,MW2**2,AMMU**2))/16./PI/AMN2SS**3
        CALL SSSAVE(ISNML,WID,ISW2,IDMU,0,0,0)
      END IF
C
      IF (AMN3SS.GT.(MW2+AMTAU)) THEN
        WID=((ALWI(2)**2+BPLWI(2)**2)*(AMN3SS**2-MW2**2-AMTAU**2)+
     $     4*MW2*AMTAU*BPLWI(2)*ALWI(2))*
     $     SQRT(SSXLAM(AMN3SS**2,MW2**2,AMTAU**2))/16./PI/AMN3SS**3
        CALL SSSAVE(ISNTL,WID,ISW2,IDTAU,0,0,0)
      END IF
C
C      DECAYS TO VECTOR BOSONS
C
      IF (AMELSS.GT.(AMN1SS+AMW)) THEN
        WID=G*G*(SSXLAM(AMELSS**2,AMN1SS**2,AMW**2))**1.5/
     $      32./PI/AMELSS**3/AMW**2
        CALL SSSAVE(ISEL,WID,-IDW,ISNEL,0,0,0)
      END IF
C
      IF (AMMLSS.GT.(AMN2SS+AMW)) THEN
        WID=G*G*(SSXLAM(AMMLSS**2,AMN2SS**2,AMW**2))**1.5/
     $      32./PI/AMMLSS**3/AMW**2
        CALL SSSAVE(ISMUL,WID,-IDW,ISNML,0,0,0)
      END IF
C
      IF (AML1SS.GT.(AMN3SS+AMW)) THEN
        WID=G*G*(SSXLAM(AML1SS**2,AMN3SS**2,AMW**2))**1.5/
     $      32./PI/AML1SS**3/AMW**2*COSL**2
        CALL SSSAVE(ISTAU1,WID,-IDW,ISNTL,0,0,0)
      END IF
C
      IF (AML2SS.GT.(AMN3SS+AMW)) THEN
        WID=G*G*(SSXLAM(AML2SS**2,AMN3SS**2,AMW**2))**1.5/
     $      32./PI/AML2SS**3/AMW**2*SINL**2
        CALL SSSAVE(ISTAU2,WID,-IDW,ISNTL,0,0,0)
      END IF
C
      IF (AMN1SS.GT.(AMELSS+AMW)) THEN
        WID=G*G*(SSXLAM(AMN1SS**2,AMELSS**2,AMW**2))**1.5/
     $      32./PI/AMN1SS**3/AMW**2
        CALL SSSAVE(ISNEL,WID,IDW,ISEL,0,0,0)
      END IF
C
      IF (AMN2SS.GT.(AMMLSS+AMW)) THEN
        WID=G*G*(SSXLAM(AMN2SS**2,AMMLSS**2,AMW**2))**1.5/
     $      32./PI/AMN2SS**3/AMW**2
        CALL SSSAVE(ISNML,WID,IDW,ISMUL,0,0,0)
      END IF
C
      IF (AMN3SS.GT.(AML1SS+AMW)) THEN
        WID=G*G*(SSXLAM(AMN3SS**2,AML1SS**2,AMW**2))**1.5/
     $      32./PI/AMN3SS**3/AMW**2*COSL**2
        CALL SSSAVE(ISNTL,WID,IDW,ISTAU1,0,0,0)
      END IF
C
      IF (AMN3SS.GT.(AML2SS+AMW)) THEN
        WID=G*G*(SSXLAM(AMN3SS**2,AML2SS**2,AMW**2))**1.5/
     $      32./PI/AMN3SS**3/AMW**2*SINL**2
        CALL SSSAVE(ISNTL,WID,IDW,ISTAU2,0,0,0)
      END IF
C
      IF (AML2SS.GT.(AML1SS+AMZ)) THEN
        WID=G*G*(SSXLAM(AML2SS**2,AML1SS**2,AMZ**2))**1.5/
     $      64./PI/AML2SS**3/CS2THW/AMZ**2*SINL**2*COSL**2
        CALL SSSAVE(ISTAU2,WID,IDZ,ISTAU1,0,0,0)
      END IF
C
C     3-body decay of l_R -> l+tau+stau_1
C
      XLO=(AML1SS+AMTAU)**2
      SUM1=0.
      SUM2=0.
      IF (AMERSS.GT.(AML1SS+AMTAU+AME)) THEN
        DO IZ=1,4
          DO JZ=IZ,4
            TMP(1)=AMERSS
            TMP(2)=-SR2*GP*ZMIXSS(4,IZ)
            TMP(3)=-SR2*GP*ZMIXSS(4,JZ)
            AEIZ=-(G*ZMIXSS(3,IZ)+GP*ZMIXSS(4,IZ))/SR2
            AEJZ=-(G*ZMIXSS(3,JZ)+GP*ZMIXSS(4,JZ))/SR2
            TMP(4)=AEIZ*COSL-FL*ZMIXSS(2,IZ)*SINL
            TMP(5)=AEJZ*COSL-FL*ZMIXSS(2,JZ)*SINL
            TMP(6)=TMP(2)*SINL+FL*ZMIXSS(2,IZ)*COSL
            TMP(7)=TMP(3)*SINL+FL*ZMIXSS(2,JZ)*COSL
            TMP(8)=AMZISS(IZ)
            TMP(9)=AMZISS(JZ)
            TERM=2*PI**2*SSXINT(XLO,SSLRT1,AMERSS**2)/AMERSS
            IF (IZ.EQ.JZ) TERM=TERM/2.
            SUM1=SUM1+TERM
            TMP(4)=TMP(6)
            TMP(5)=TMP(7)
            TMP(6)=AEIZ*COSL-FL*ZMIXSS(2,IZ)*SINL
            TMP(7)=AEJZ*COSL-FL*ZMIXSS(2,JZ)*SINL
            TERM=2*PI**2*SSXINT(XLO,SSLRT1,AMERSS**2)/AMERSS
            IF (IZ.EQ.JZ) TERM=TERM/2.
            SUM2=SUM2+TERM
          END DO
        END DO
        WID1=SUM1/2./AMERSS/(2*PI)**5
        WID2=SUM2/2./AMERSS/(2*PI)**5
        CALL SSSAVE(ISER,WID1,IDE,-IDTAU,ISTAU1,0,0)
        CALL SSSAVE(ISER,WID2,IDE,IDTAU,-ISTAU1,0,0)
      END IF
      SUM1=0.
      SUM2=0.
      IF (AMMRSS.GT.(AML1SS+AMTAU+AMMU)) THEN
        DO IZ=1,4
          DO JZ=IZ,4
            TMP(1)=AMMRSS
            TMP(2)=-SR2*GP*ZMIXSS(4,IZ)
            TMP(3)=-SR2*GP*ZMIXSS(4,JZ)
            AEIZ=-(G*ZMIXSS(3,IZ)+GP*ZMIXSS(4,IZ))/SR2
            AEJZ=-(G*ZMIXSS(3,JZ)+GP*ZMIXSS(4,JZ))/SR2
            TMP(4)=AEIZ*COSL-FL*ZMIXSS(2,IZ)*SINL
            TMP(5)=AEJZ*COSL-FL*ZMIXSS(2,JZ)*SINL
            TMP(6)=TMP(2)*SINL+FL*ZMIXSS(2,IZ)*COSL
            TMP(7)=TMP(3)*SINL+FL*ZMIXSS(2,JZ)*COSL
            TMP(8)=AMZISS(IZ)
            TMP(9)=AMZISS(JZ)
            TERM=2*PI**2*SSXINT(XLO,SSLRT1,AMMRSS**2)/AMMRSS
            IF (IZ.EQ.JZ) TERM=TERM/2.
            SUM1=SUM1+TERM
            TMP(4)=TMP(6)
            TMP(5)=TMP(7)
            TMP(6)=AEIZ*COSL-FL*ZMIXSS(2,IZ)*SINL
            TMP(7)=AEJZ*COSL-FL*ZMIXSS(2,JZ)*SINL
            TERM=2*PI**2*SSXINT(XLO,SSLRT1,AMMRSS**2)/AMMRSS
            IF (IZ.EQ.JZ) TERM=TERM/2.
            SUM2=SUM2+TERM
          END DO
        END DO
        WID1=SUM1/2./AMMRSS/(2*PI)**5
        WID2=SUM2/2./AMMRSS/(2*PI)**5
        CALL SSSAVE(ISMUR,WID1,IDMU,-IDTAU,ISTAU1,0,0)
        CALL SSSAVE(ISMUR,WID2,IDMU,IDTAU,-ISTAU1,0,0)
      END IF
C
C     decay to neutral higgs bosons
C
      IF (AML2SS.GT.(AMHL+AML1SS)) THEN
        BH=G*AMW*SIN(BETA-ALFAH)*(-1.+3*TN2THW)*SINL*COSL/2.+G*
     $  AMTAU*(TWOM1*COSA+AAL*SINA)*COS(2*THETAL)/2./AMW/COS(BETA)
        WID=BH**2*SQRT(SSXLAM(AML2SS**2,AMHL**2,AML1SS**2))/
     $      16./PI/AML2SS**3
        CALL SSSAVE(ISTAU2,WID,ISHL,ISTAU1,0,0,0)
      ENDIF
C
      IF (AML2SS.GT.(AMHA+AML1SS)) THEN
        BH=G*AMTAU*(TWOM1-AAL*TANB)/2./AMW
        WID=BH**2*SQRT(SSXLAM(AML2SS**2,AMHA**2,AML1SS**2))/
     $      16./PI/AML2SS**3
        CALL SSSAVE(ISTAU2,WID,ISHA,ISTAU1,0,0,0)
      ENDIF
C
      IF (AML2SS.GT.(AMHH+AML1SS)) THEN
        BH=-G*AMW*COS(BETA-ALFAH)*(-1.+3*TN2THW)*SINL*COSL/2.+G*
     $  AMTAU*(-TWOM1*SINA+AAL*COSA)*COS(2*THETAL)/2./AMW/COS(BETA)
        WID=BH**2*SQRT(SSXLAM(AML2SS**2,AMHH**2,AML1SS**2))/
     $      16./PI/AML2SS**3
        CALL SSSAVE(ISTAU2,WID,ISHH,ISTAU1,0,0,0)
      ENDIF
C
C     stau_i -> H^- stau_j
C
      IF (AMN3SS.GT.(AML1SS+AMHC)) THEN
        A=G/SR2/AMW*((AMTAU**2*TANB-AMW**2*SIN(2*BETA))*COSL-
     $    AMTAU*(TWOM1-AAL*TANB)*SINL)
        WID=A*A*SQRT(SSXLAM(AMN3SS**2,AML1SS**2,AMHC**2))/
     $      16./PI/AMN3SS**3
        CALL SSSAVE(ISNTL,WID,ISHC,ISTAU1,0,0,0)
      END IF
C
      IF (AMN3SS.GT.(AML2SS+AMHC)) THEN
        A=G/SR2/AMW*((AMTAU**2*TANB-AMW**2*SIN(2*BETA))*SINL+
     $    AMTAU*(TWOM1-AAL*TANB)*COSL)
        WID=A*A*SQRT(SSXLAM(AMN3SS**2,AML2SS**2,AMHC**2))/
     $      16./PI/AMN3SS**3
        CALL SSSAVE(ISNTL,WID,ISHC,ISTAU2,0,0,0)
      END IF
C
      IF (AML1SS.GT.(AMN3SS+AMHC)) THEN
        A=G/SR2/AMW*((AMTAU**2*TANB-AMW**2*SIN(2*BETA))*COSL-
     $    AMTAU*(TWOM1-AAL*TANB)*SINL)
        WID=A*A*SQRT(SSXLAM(AML1SS**2,AMN3SS**2,AMHC**2))/
     $      16./PI/AML1SS**3
        CALL SSSAVE(ISTAU1,WID,-ISHC,ISNTL,0,0,0)
      END IF
C
      IF (AML2SS.GT.(AMN3SS+AMHC)) THEN
        A=G/SR2/AMW*((AMTAU**2*TANB-AMW**2*SIN(2*BETA))*SINL+
     $    AMTAU*(TWOM1-AAL*TANB)*COSL)
        WID=A*A*SQRT(SSXLAM(AML2SS**2,AMN3SS**2,AMHC**2))/
     $      16./PI/AML2SS**3
        CALL SSSAVE(ISTAU2,WID,-ISHC,ISNTL,0,0,0)
      END IF
C
C     Gauge mediated SUSY breaking model decays to gravitino
      IF (AMERSS.GT.(AME+AMGVSS)) THEN
        WID=(AMERSS**2-AME**2)**4/48./PI/AMERSS**3/(AMPL*AMGVSS)**2
        CALL SSSAVE(ISER,WID,IDE,91,0,0,0)
      END IF
      IF (AMMRSS.GT.(AMMU+AMGVSS)) THEN
        WID=(AMMRSS**2-AMMU**2)**4/48./PI/AMMRSS**3/(AMPL*AMGVSS)**2
        CALL SSSAVE(ISMUR,WID,IDMU,91,0,0,0)
      END IF
      IF (AML1SS.GT.(AMTAU+AMGVSS)) THEN
        WID=(AML1SS**2-AMTAU**2)**4/48./PI/AML1SS**3/(AMPL*AMGVSS)**2
        CALL SSSAVE(ISTAU1,WID,IDTAU,91,0,0,0)
      END IF
C
C          Normalize branching ratios
C
      CALL SSNORM(ISEL)
      CALL SSNORM(ISMUL)
      CALL SSNORM(ISTAU1)
      CALL SSNORM(ISER)
      CALL SSNORM(ISMUR)
      CALL SSNORM(ISTAU2)
      CALL SSNORM(ISNEL)
      CALL SSNORM(ISNML)
      CALL SSNORM(ISNTL)
C
       RETURN
       END
CDECK  ID>, SSLRT1. 
        REAL FUNCTION SSLRT1(SS)
C-----------------------------------------------------------------------
C          SSLRT1: l_R -> l+tau+stau_1
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
        REAL SS
        DOUBLE PRECISION ETMX,ETMN,S,MT1,MT,MLR,BEZI,BEZJ,
     ,AI,AJ,BI,BJ,MZI,MZJ,SNZI,SNZJ,XL,BK1,BK2,BK3,BK,WID,SSDLAM
        S=SS
        MT1=AML1SS
        MT=AMTAU
        MLR=TMP(1)
        BEZI=TMP(2)
        BEZJ=TMP(3)
        AI=TMP(4)
        AJ=TMP(5)
        BI=TMP(6)
        BJ=TMP(7)
        MZI=ABS(TMP(8))
        MZJ=ABS(TMP(9))
        SNZI=SIGN(1.0,TMP(8))
        SNZJ=SIGN(1.0,TMP(9))
        XL=DSQRT(SSDLAM(S,MT**2,MT1**2))
        ETMN=(S+MT**2-MT1**2-XL*(MLR**2-S)/(MLR**2+S))*(MLR**2+S)/
     ,       (2*S)/(2*MLR)
        ETMX=(S+MT**2-MT1**2+XL*(MLR**2-S)/(MLR**2+S))*(MLR**2+S)/
     ,       (2*S)/(2*MLR)
        BK1=-(ETMX-ETMN)*((ETMX+ETMN)*MLR*S-
     ,       (S+MT**2-MT1**2)*MLR**2)/2.D0
        BK2=(ETMX-ETMN)*((ETMX+ETMN)*MLR-S-MT**2+MT1**2)/2.D0
        BK3=SNZJ*BI*AJ*MZJ+SNZI*BJ*AI*MZI
        BK=BI*BJ*BK1+AI*AJ*MZI*MZJ*SNZI*SNZJ*BK2+BK3*MT*(MLR**2-S)*
     ,     (ETMX-ETMN)/2.D0
        WID=BEZI*BEZJ*BK/(S-MZI**2)/(S-MZJ**2)
        SSLRT1=WID
        RETURN
        END
CDECK  ID>, SSMASS. 
      SUBROUTINE SSMASS(XM1,XM2,IALLOW,ILOOP,MHLNEG,MHCNEG,IMODEL)
C-----------------------------------------------------------------------
C
C          Diagonalize neutralino, chargino, and Higgs mass matrices
C          and save results in /SSPAR/.
C
C          If XM1, XM2 < 1E19, use them for the U(1) and SU(2) mass
C          terms. Otherwise calculate them from AMGLSS and unification.
C
C          Return IALLOW = 1 if Z1SS is not LSP
C                 IALLOW = 0 otherwise
C
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C
      REAL XM1,XM2
      INTEGER IALLOW,MHLNEG,MHCNEG,IMODEL
      REAL AR(4,4),WORK(4),WR(4)
      REAL ZETA,ZETAS,YM,XM,COS2A,SINA,AL,SIN2A,COSA,MU2,GP,G,
     $TEMP,VS,VP,V,MTAMTA,MTAMB,MTAMZ,ASMB,MBMB,
     $ASMT,MTMT,SUALFE,SUALFS
      REAL MW1,MW2,THX,THY,MU1
      REAL COSB,SINB,BE,COS2B,SIN2B,PI,SR2,HIGFRZ,MTQ,MBQ
      REAL TERM1,TERM2,TERM3,TANTHT,AMGLMZ,SSPOLE,TANTHB,TANTHL
      DOUBLE PRECISION SSMQCD
      INTEGER I,J,K,IERR,ILOOP
C
      IALLOW=0
      PI=4.*ATAN(1.)
      SR2=SQRT(2.)
      G=SQRT(4.*PI*ALFAEM/SN2THW)
      GP=G*SQRT(SN2THW/(1.-SN2THW))
C
      BE=ATAN(1./RV2V1)
      SINB=SIN(BE)
      COSB=COS(BE)
      SIN2B=SIN(2.*BE)
      COS2B=COS(2.*BE)
      HIGFRZ=MAX(AMZ,SQRT(AMTLSS*AMTRSS))
C
C          Compute m(tau), m(b) at z scale using qcd, qed
C
      MTAMTA=AMTAU*(1.-SUALFE(AMTAU**2)/PI)
      MTAMB=MTAMTA*(SUALFE(AMBT**2)/SUALFE(AMTAU**2))**(-27./76.)
      MTAMZ=MTAMB*(SUALFE(AMZ**2)/SUALFE(AMBT**2))**(-27./80.)
      ASMB=SUALFS(AMBT**2,.36,AMTP,3)
      MBMB=AMBT*(1.-4*ASMB/3./PI)
      MBQ=SSMQCD(DBLE(MBMB),DBLE(HIGFRZ))
      ASMT=SUALFS(AMTP**2,.36,AMTP,3)
      MTMT=AMTP/(1.+4*ASMT/3./PI+(16.11-1.04*(5.-6.63/AMTP))*
     $(ASMT/PI)**2)
      MTQ=SSMQCD(DBLE(MTMT),DBLE(HIGFRZ))
C
C     Light/heavy stop states and mixing angle
C
      TERM1=(AMTLSS**2+AMTRSS**2)/2.+AMZ**2*COS2B/4.+MTQ**2
      TERM2=((AMTLSS**2-AMTRSS**2)/2.+COS2B*(8.*AMW**2-5.*AMZ**2)
     $/12.)**2
      TERM3=SQRT(TERM2+MTQ**2*(TWOM1*COSB/SINB+AAT)**2)
      AMT1SS=SQRT(TERM1-TERM3)
      AMT2SS=SQRT(TERM1+TERM3)
      TANTHT=(AMT1SS**2-MTQ**2+AMZ**2*COS2B*(-.5+2*SN2THW/3.)-
     $AMTLSS**2)/MTQ/(TWOM1*COSB/SINB+AAT)
      THETAT=ATAN(TANTHT)
C
C     Light/heavy sbottom states and mixing angle
C
      TERM1=(AMBLSS**2+AMBRSS**2)/2.-AMZ**2*COS2B/4.+MBQ**2
      TERM2=((AMBLSS**2-AMBRSS**2)/2.-COS2B*(4.*AMW**2-AMZ**2)
     $/12.)**2
      TERM3=SQRT(TERM2+MBQ**2*(TWOM1*SINB/COSB+AAB)**2)
      AMB1SS=SQRT(TERM1-TERM3)
      AMB2SS=SQRT(TERM1+TERM3)
      TANTHB=(AMB1SS**2-MBQ**2+AMZ**2*COS2B*(.5-SN2THW/3.)-
     $AMBLSS**2)/MBQ/(TWOM1*SINB/COSB+AAB)
      THETAB=ATAN(TANTHB)
C
C     Light/heavy stau states and mixing angle
C
      TERM1=(AMLLSS**2+AMLRSS**2)/2.-AMZ**2*COS2B/4.+MTAMZ**2
      TERM2=((AMLLSS**2-AMLRSS**2)/2.-COS2B*(4.*AMW**2-3*AMZ**2)
     $/4.)**2
      TERM3=SQRT(TERM2+MTAMZ**2*(TWOM1*SINB/COSB+AAL)**2)
      AML1SS=SQRT(TERM1-TERM3)
      AML2SS=SQRT(TERM1+TERM3)
      TANTHL=(AML1SS**2-MTAMZ**2+AMZ**2*COS2B*(.5-SN2THW)-
     $AMLLSS**2)/MTAMZ/(TWOM1*SINB/COSB+AAL)
      THETAL=ATAN(TANTHL)
C
C     define msbar gluino mass at mz from physical gluino mass
      AMGLMZ=SSPOLE(AMGLSS,AMZ**2,-ALFA3)
      VS=2.*AMW**2/G**2/(1.+RV2V1**2)
      V=SQRT(VS)
      VP=RV2V1*V
C
C          Use either explicit values or scaling to determine SU(2)
C          and U(1) mass terms. NOTE SIGN CONVENTION!
C
      IF(ABS(XM2).LT.1.E19.AND.ABS(XM1).LT.1.E19) THEN
         MU2=-XM2
         MU1=-XM1
      ELSE
         MU2=-ALFA2*AMGLMZ/ALFA3
         MU1=5*SN2THW/3./(1.-SN2THW)*MU2
      ENDIF
C
C          Neutralino mass matrix
C
      AR(1,1)=0.
      AR(1,2)=-TWOM1
      AR(1,3)=-G*V/SR2
      AR(1,4)=GP*V/SR2
      AR(2,1)=-TWOM1
      AR(2,2)=0.
      AR(2,3)=G*VP/SR2
      AR(2,4)=-GP*VP/SR2
      AR(3,1)=-G*V/SR2
      AR(3,2)=G*VP/SR2
      AR(3,3)=MU2
      AR(3,4)=0.
      AR(4,1)=GP*V/SR2
      AR(4,2)=-GP*VP/SR2
      AR(4,3)=0.
      AR(4,4)=MU1
C
      CALL EISRS1(4,4,AR,WR,ZMIXSS,IERR,WORK)
      IF (IERR.NE.0) THEN
        WRITE(LOUT,*) 'EISRS1 ERROR IN SSMASS, IERR=',IERR
        STOP99
      END IF
C
C       Sort eigenvectors and eigenvalues according to masses
C
      DO 10 I=1,3
        DO 11 J=I+1,4
          IF (ABS(WR(I)).GT.ABS(WR(J))) THEN
            TEMP=WR(J)
            WR(J)=WR(I)
            WR(I)=TEMP
            DO 12 K=1,4
              TEMP=ZMIXSS(K,J)
              ZMIXSS(K,J)=ZMIXSS(K,I)
              ZMIXSS(K,I)=TEMP
12          CONTINUE
          END IF
11      CONTINUE
10    CONTINUE
C
      AMZ1SS=WR(1)
      AMZ2SS=WR(2)
      AMZ3SS=WR(3)
      AMZ4SS=WR(4)
C
C          Chargino mass matrix
C
      AL=ATAN(RV2V1)
      SINA=SIN(AL)
      COSA=COS(AL)
      SIN2A=SIN(2.*AL)
      COS2A=COS(2.*AL)
      ZETAS=(TWOM1**2-MU2**2)**2
     $+4*AMW**2*(AMW**2*COS2A**2+TWOM1**2+MU2**2+2*TWOM1*MU2*SIN2A)
      ZETA=SQRT(ZETAS)
      XM=-(TWOM1**2-MU2**2-2*AMW**2*COS2A-ZETA)
     $/(2*SR2*AMW*(MU2*SINA+TWOM1*COSA))
      YM=-(TWOM1**2-MU2**2+2*AMW**2*COS2A-ZETA)
     $/(2*SR2*AMW*(MU2*COSA+TWOM1*SINA))
      IF (XM.NE.0.) THEN
        GAMMAL=ATAN(1./XM)
      ELSE
        GAMMAL=PI/2.
      END IF
      IF (YM.NE.0.) THEN
        GAMMAR=ATAN(1./YM)
      ELSE
        GAMMAR=PI/2.
      END IF
      IF (GAMMAL.LT.0.) GAMMAL=GAMMAL+PI
      IF (GAMMAR.LT.0.) GAMMAR=GAMMAR+PI
      THX=SIGN(1.,XM)
      THY=SIGN(1.,YM)
      AMW2SS=THX*THY*(COS(GAMMAR)*(MU2*COS(GAMMAL)+G*VP*SIN(GAMMAL))
     $-SIN(GAMMAR)*(-G*V*COS(GAMMAL)-TWOM1*SIN(GAMMAL)))
      AMW1SS=SIN(GAMMAR)*(MU2*SIN(GAMMAL)-G*VP*COS(GAMMAL))
     $+COS(GAMMAR)*(-G*V*SIN(GAMMAL)+TWOM1*COS(GAMMAL))
      MW1=ABS(AMW1SS)
      MW2=ABS(AMW2SS)
C
C          Check validity of parameters
C
      IF (IMODEL.EQ.1) THEN
        IF(MW1.LE.ABS(AMZ1SS)) IALLOW=1
        IF(AMT1SS.LE.ABS(AMZ1SS)) IALLOW=1
        IF(AMB1SS.LE.ABS(AMZ1SS)) IALLOW=1
        IF(AML1SS.LE.ABS(AMZ1SS)) IALLOW=1
      END IF
C      IF(IALLOW.NE.0) RETURN
C
C          Higgs mass matrix
C
      IF (ILOOP.EQ.1) THEN
        CALL SSMHN(MHLNEG)
        CALL SSMHC(MHCNEG)
      END IF
C
      RETURN
      END
CDECK  ID>, SSMHC.  
      SUBROUTINE SSMHC(MHCNEG)
C-----------------------------------------------------------------------
C
C         Calculates charged Higgs mass
C         (scalar Higgs mixing angle) using radiative
C         corrections calculated by M. Bisset
C         and save results in /SSPAR/.
C
C         Both top and bottom couplings are now
C         included.  Non-degenerate mixed squark
C         masses and A-terms are also included.
C         The D-terms from the squark mass matrix
C         (terms prop. to g**2 * Yukawa coupling)
C         are included by default.
C
C         There is an arbitrary mass scale that must
C         chosen to avoid dimensionful logarithms.
C         The choice does not matter if D-terms are
C         not included, but it does matter if D-terms
C         are included.
C
C         Arbitrary mass scale set to
C              QQQ = HIGFRZ = SQRT(AMTLSS*AMTRSS)
C         Updated to include running masses as 2-loop effect
C
C         It is assumed that the A-terms are real.
C         (Complex A-terms are taken into account
C         much of the subroutine; but, not in all
C         cases.)
C
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C
      INTEGER MHCNEG
      REAL PI,PI2,SR2,G2,GP2,GGP,GG1,GG2
      REAL GGPM,GG3,GG4
      REAL TANB,COTB,COSB,SINB,BE
      REAL SINB2,COSB2,COS2B,SIN2B
      REAL V2,VP2,V,VP,VVP,VPVM,VVPP,MT,MB
      REAL MT2,MB2,MT4,MB4,FT2,FB2,FT,FB
      REAL MW2,ZAP,QQQ2,EP,EP2,RR,MHP2
      REAL ATI,ABI,ATR,ABR,AT2,AB2
      REAL MSTL2,MSTR2,MSBL2,MSBR2
      REAL TLRM,BLRM,TLRP,BLRP
      REAL MST1,MST2,MSB1,MSB2
      REAL MST1SQ,MST2SQ,MSB1SQ,MSB2SQ
      REAL TTT1,TTT2,TTT3,BBB1,BBB2,BBB3
      REAL TEMPT,TEMPB,ROOTT,ROOTB,TM1B
C
C     For special cases (degenerate squarks)
C
      REAL T1SQ,T2SQ,T3SQ,D2ZERO
      REAL DIFTSQ,DIFBSQ,ET,EB
      REAL TRM1,TRM2,TRM3,TRM4
      REAL TRMTT,TRMBB,TRMFF
      REAL PTERM1,PTERM2,PTERM3,PTERM4
      REAL FIRT,TMPFIR,SECT,V11
      REAL FIRB,TEMPFB,SECB,V22
      REAL FIRC,SECC,V12,D2DSQB
      REAL DIFTRM,TF,LGOLD,LCH,LSQ
C
      REAL TERM1B,TERM2B,TERM3B,TERM4B,PTERMB
      REAL TEMPB1,TEMPB2,TMPB34,TEMPP1,TEMPP2
      REAL PERTM1,PERTM2,PERTM3,PERTM4
C
C      For non-degenerate squarks
C
      REAL TERMT,TERMB,DHRT1,DHRT2,DHRB1,DHRB2
      REAL DHRPT1,DHRPT2,DHRPB1,DHRPB2
      REAL DHPST1,DHPST2,DHPSB1,DHPSB2
      REAL DHMST1,DHMST2,DHMSB1,DHMSB2
      REAL ATA1,ATA2,BTA1,BTA2,ABA1,ABA2,BBA1,BBA2
      REAL ATA1SQ,ATA2SQ,BTA1SQ,BTA2SQ
      REAL ABA1SQ,ABA2SQ,BBA1SQ,BBA2SQ
      REAL NABT1,NABT2,NABB1,NABB2
      REAL FTG,FBG,BABA,PT1B1,PT1B2,PT2B1,PT2B2
      REAL PDPST1,PDPST2,PDPSB1,PDPSB2
      REAL PDMST1,PDMST2,PDMSB1,PDMSB2
      REAL PDPMT1,PDPMT2,PDPMB1,PDPMB2
      REAL LMST1,LMST2,LMSB1,LMSB2
      REAL EMI1,EMI2,EM3,TEMPF
      REAL DVRR,DVRPRP,DVRRP,TRACE,DETV
      REAL TERMSQ,GOLD2,GOLD,MHC2,ORTHO,U2G,U2HC
      REAL HIGFRZ,ASMB,MBMB,MBQ,ASMT,MTMT,MTQ,SUALFS
      DOUBLE PRECISION SSMQCD
C
      MHCNEG=0
      PI=4.*ATAN(1.)
      PI2=PI**2
      SR2=SQRT(2.)
      G2=4.*PI*ALFAEM/SN2THW
      GP2=G2*SN2THW/(1.-SN2THW)
      HIGFRZ=SQRT(AMTLSS*AMTRSS)
      ASMB=SUALFS(AMBT**2,.36,AMTP,3)
      MBMB=AMBT*(1.-4*ASMB/3./PI)
      MBQ=SSMQCD(DBLE(MBMB),DBLE(HIGFRZ))
      ASMT=SUALFS(AMTP**2,.36,AMTP,3)
      MTMT=AMTP/(1.+4*ASMT/3./PI+(16.11-1.04*(5.-6.63/AMTP))*
     $(ASMT/PI)**2)
      MTQ=SSMQCD(DBLE(MTMT),DBLE(HIGFRZ))
      MT=MTQ
      MB=MBQ
      MT2=MT**2
      MB2=MB**2
      MT4=MT2**2
      MB4=MB2**2
      MW2=AMW**2
      EP=TWOM1
      EP2=EP**2
      RR=RV2V1
      MHP2=AMHA**2
      TANB=1.0/RR
      COTB=RR
      BE=ATAN(1./RV2V1)
      SINB=SIN(BE)
      COSB=COS(BE)
      SINB2=SINB**2
      COSB2=COSB**2
      SIN2B=SIN(2.*BE)
      COS2B=COS(2.*BE)
      V2=2.0*MW2*SINB2/G2
      VP2=2.0*MW2*COSB2/G2
      V=SQRT(V2)
      VP=SQRT(VP2)
      VVP=SQRT(V2*VP2)
      VPVM=VP2-V2
      GGP=G2+GP2
      GGPM=G2-GP2
      GG1=G2-5.0*GP2/3.0
      GG2=G2-GP2/3.0
      GG3=G2+5.0*GP2/3.0
      GG4=G2+GP2/3.0
C
      VVPP=2.0*AMZ**2/GGP
      FT2=MT2/V2
      FB2=MB2/VP2
      FT=SQRT(FT2)
      FB=SQRT(FB2)
C
      MSTL2=AMTLSS**2
      MSTR2=AMTRSS**2
      MSBL2=AMBLSS**2
      MSBR2=AMBRSS**2
      TLRM=MSTL2-MSTR2
      BLRM=MSBL2-MSBR2
      TLRP=MSTL2+MSTR2
      BLRP=MSBL2+MSBR2
C
C          Charged Higgs mass calculation
C          (AAT and AAB are also assumed to be real)
C
      ATR=AAT
      ABR=AAB
      ATI=0.0
      ABI=0.0
      AT2=ATR**2+ATI**2
      AB2=ABR**2+ABI**2
C
C      UNFORTUNATELY, I HAVE USED MY OLD CONVENTION
C      FOR THE STOP AND SBOTTOM EIGENVALUES HERE
C      (T1 <==> T2 OF NOTATION IN X. TATA'S AND OTHER
C      PEOPLE'S NOTATION).  SO THE NEXT EIGHT LINES ARE
C      A FIX-UP UNTIL I GO THROUGH AND CHANGE THE
C      NOTATION THROUGHOUT THIS SUBROUTINE.
C
      MST2=AMT1SS
      MST1=AMT2SS
      MSB2=AMB1SS
      MSB1=AMB2SS
      MST2SQ=AMT1SS**2
      MST1SQ=AMT2SS**2
      MSB2SQ=AMB1SS**2
      MSB1SQ=AMB2SS**2
C
      QQQ2=HIGFRZ**2
      ZAP=1
C
C          Non-degenerate squarks and/or D-terms. Since D-terms are
C          always included, old dead code has been deleted. FEP
C
C          ROOTT recast as a sum of squares. Note that ROOTT=0
C          could happen accidently and causes an error.
      TTT1=0.5*(MSTL2+MSTR2)+MT2+ZAP*VPVM*GGP/8.0
      TTT2=TLRM+ZAP*GG1*VPVM/4.0
      TTT3=4.0*FT2*(EP2*VP2+2.0*EP*VVP*ATR+AT2*V2)
      ROOTT=4*MT2*(COSB*EP + AAT*SINB)**2/SINB**2 +
     $(AMTLSS**2 - AMTRSS**2 +
     $AMW**2*(-5*GP2/3 + G2)*(COSB**2 - SINB**2)/(2*G2))**2
      ROOTT=0.5*SQRT(ROOTT)
      IF(ROOTT.EQ.0.0) THEN
        WRITE(LOUT,*) 'SSMHC: ERROR: ROOTT = 0,',
     $  '  CANNOT CALCULATE H+ MASS FOR THIS CASE.'
        STOP99
      ENDIF
C
      BBB1=0.5*(MSBL2+MSBR2)+MB2-ZAP*VPVM*GGP/8.0
      BBB2=BLRM-ZAP*GG2*VPVM/4.0
      BBB3=4.0*FB2*(EP2*V2+2.0*EP*VVP*ABR+AB2*VP2)
C          ROOTB recast as a sum of squares.
      ROOTB=4*MB2*(AAB*COSB + EP*SINB)**2/COSB**2 +
     $(AMBLSS**2 - AMBRSS**2 -
     $AMW**2*(-GP2/3 + G2)*(COSB**2 - SINB**2)/(2*G2))**2
      ROOTB=0.5*SQRT(ROOTB)
      IF(ROOTB.EQ.0.0) THEN
        WRITE(LOUT,*) 'SSMHC: ERROR: ROOTB = 0,',
     $  '  CANNOT CALCULATE H+ MASS FOR THIS CASE.'
        STOP99
      ENDIF
C
C      Calculate 2M1*B term
C
      TEMPT=EP*FT2*VVP*ATI**2/(ROOTT**2)
      TEMPB=EP*FB2*VVP*ABI**2/(ROOTB**2)
      TM1B=-FT2*(TEMPT+ATR)*TTT1*LOG(MST1SQ/MST2SQ)/ROOTT
      TM1B=TM1B-FT2*ATR*LOG(MST1SQ*MST2SQ/QQQ2/QQQ2)
      TM1B=TM1B+FT2*(2.0*TEMPT-ATR)
      TM1B=TM1B-FB2*(TEMPB+ABR)*BBB1*LOG(MSB1SQ/MSB2SQ)/ROOTB
      TM1B=TM1B-FB2*ABR*LOG(MSB1SQ*MSB2SQ/QQQ2/QQQ2)
      TM1B=TM1B+FB2*(2.0*TEMPB-ABR)
      TM1B=3.0*EP*TM1B/32.0/PI2
      TM1B=TM1B-VVP*MHP2/VVPP
C
C       Calculate derivatives w.r.t. H_R divided by v*sqrt(2)
C
      TEMPT=ZAP*GG1*(TLRM+VPVM*GG1/4.0)/8.0
      TERMT=-TEMPT+FT2*(EP*COTB*ATR+AT2)
      TERMT=TERMT/(2.0*ROOTT)
      DHRT1=FT2-ZAP*GGP/8.0 + TERMT
      DHRT2=FT2-ZAP*GGP/8.0 - TERMT
C
      TEMPB=ZAP*GG2*(BLRM-VPVM*GG2/4.0)/8.0
      TERMB=TEMPB+FB2*EP*(EP+COTB*ABR)
      TERMB=TERMB/(2.0*ROOTB)
      DHRB1=ZAP*GGP/8.0 + TERMB
      DHRB2=ZAP*GGP/8.0 - TERMB
C
C       Calculate derivatives w.r.t. H_R' divided by v'*sqrt(2)
C
      TERMT=TEMPT+FT2*EP*(EP+TANB*ATR)
      TERMT=TERMT/(2.0*ROOTT)
      DHRPT1=ZAP*GGP/8.0 + TERMT
      DHRPT2=ZAP*GGP/8.0 - TERMT
C
      TERMB=-TEMPB+FB2*(EP*TANB*ABR+AB2)
      TERMB=TERMB/(2.0*ROOTB)
      DHRPB1=FB2-ZAP*GGP/8.0 + TERMB
      DHRPB2=FB2-ZAP*GGP/8.0 - TERMB
C
C       Calculate second derivatives w.r.t. H_R^+
C
      TEMPT=(TLRM+ZAP*VPVM*GG1/4.0)/(4.0*ROOTT)
      TERMT=TEMPT*(-FT2+ZAP*GG3/4.0)
      DHPST1=FT2/2.0 + ZAP*GGPM/8.0 + TERMT
      DHPST2=FT2/2.0 + ZAP*GGPM/8.0 - TERMT
C
      TEMPB=(BLRM-ZAP*VPVM*GG2/4.0)/(4.0*ROOTB)
      TERMB=TEMPB*(FT2-ZAP*GG4/4.0)
      DHPSB1=FT2/2.0 - ZAP*GGPM/8.0 + TERMB
      DHPSB2=FT2/2.0 - ZAP*GGPM/8.0 - TERMB
C
C       Calculate second derivatives w.r.t. H_R'^-
C
      TERMT=TEMPT*(FB2-ZAP*GG3/4.0)
      DHMST1=FB2/2.0 - ZAP*GGPM/8.0 + TERMT
      DHMST2=FB2/2.0 - ZAP*GGPM/8.0 - TERMT
C
      TERMB=TEMPB*(-FB2+ZAP*GG4/4.0)
      DHMSB1=FB2/2.0 + ZAP*GGPM/8.0 + TERMB
      DHMSB2=FB2/2.0 + ZAP*GGPM/8.0 - TERMB
C
C       From perturbative terms
C       Here I assume A_t and A_b are real
C       and therefore the eigenvectors are real
C
C       Find stop eigenvector factors
C
      TEMPT=-TLRM/2.0 - ZAP*VPVM*GG1/8.0
      ATA1=TEMPT+ROOTT
      ATA2=TEMPT-ROOTT
      BTA1=-MT*(EP*COTB + ATR)
      BTA2=BTA1
      IF(ATA1.EQ.0.0 .AND. BTA1.EQ.0.0) THEN
        ATA1=-BTA1
        BTA1 = TEMPT - ROOTT
        IF(ATA1.EQ.0.0 .AND. BTA1.EQ.0.0) THEN
          WRITE(LOUT,*) 'SSMHC: ERROR: ZERO EIGENVECTOR FOR MST1SQ'
          STOP99
        ENDIF
      ENDIF
      IF(ATA2.EQ.0.0 .AND. BTA2.EQ.0.0) THEN
        ATA2=-BTA2
        BTA2=TEMPT+ROOTT
        IF(ATA2.EQ.0.0 .AND. BTA2.EQ.0.0) THEN
          WRITE(LOUT,*) 'SSMHC: ERROR:  ZERO EIGENVECTOR FOR MST2SQ'
          STOP99
        ENDIF
      ENDIF
      ATA1SQ=ATA1**2
      BTA1SQ=BTA1**2
      ATA2SQ=ATA2**2
      BTA2SQ=BTA2**2
      NABT1=1.0/(ATA1SQ+BTA1SQ)
      NABT2=1.0/(ATA2SQ+BTA2SQ)
C
C       Find sbottom eigenvector factors
C
      TEMPB=-BLRM/2.0 + ZAP*VPVM*GG2/8.0
      ABA1=TEMPB+ROOTB
      ABA2=TEMPB-ROOTB
      BBA1=-MB*(EP*TANB + ABR)
      BBA2=BBA1
      IF(ABA1.EQ.0.0 .AND. BBA1.EQ.0.0) THEN
        ABA1=-BBA1
        BBA1=TEMPB-ROOTB
        IF(ABA1.EQ.0.0 .AND. BBA1.EQ.0.0) THEN
          WRITE(LOUT,*) 'SSMHC: ERROR: ZERO EIGENVECTOR FOR MSB1SQ'
          STOP99
        ENDIF
      ENDIF
      IF(ABA2.EQ.0.0 .AND. BBA2.EQ.0.0) THEN
        ABA2=-BBA2
        BBA2=TEMPB+ROOTB
        IF(ABA2.EQ.0.0 .AND. BBA2.EQ.0.0) THEN
          WRITE(LOUT,*) 'SSMHC: ERROR ZERO EIGENVECTOR FOR MSB2SQ'
          STOP99
        ENDIF
      ENDIF
      ABA1SQ=ABA1**2
      BBA1SQ=BBA1**2
      ABA2SQ=ABA2**2
      BBA2SQ=BBA2**2
      NABB1=1.0/(ABA1SQ+BBA1SQ)
      NABB2=1.0/(ABA2SQ+BBA2SQ)
C
C       Calculate perturbative terms
C        from H_R^+2 derivative terms
C
      FTG=FT2-ZAP*G2/2.0
      BABA=FT*FB*(VVP*FTG-EP*ATR)
      PT1B1=V2*(FTG**2)*BTA1SQ*BBA1SQ
      PT1B1=PT1B1+2.0*EP*FB*V*FTG*BTA1SQ*BBA1*ABA1
      PT1B1=PT1B1-2.0*ATR*MT*FTG*BTA1*ATA1*BBA1SQ
      PT1B1=PT1B1+2.0*BABA*BTA1*ATA1*BBA1*ABA1
      PT1B1=PT1B1-2.0*ATR*FT2*MB*ATA1SQ*BBA1*ABA1
      PT1B1=PT1B1+2.0*EP*FT*FB*MB*BTA1*ATA1*ABA1SQ
      PT1B1=PT1B1+FT2*AT2*ATA1SQ*BBA1SQ
      PT1B1=PT1B1+FB2*EP2*BTA1SQ*ABA1SQ
      PT1B1=PT1B1+FT2*MB2*ATA1SQ*ABA1SQ
      PT1B1=PT1B1*NABT1*NABB1
C
      PT1B2=V2*(FTG**2)*BTA1SQ*BBA2SQ
      PT1B2=PT1B2+2.0*EP*FB*V*FTG*BTA1SQ*BBA2*ABA2
      PT1B2=PT1B2-2.0*ATR*MT*FTG*BTA1*ATA1*BBA2SQ
      PT1B2=PT1B2+2.0*BABA*BTA1*ATA1*BBA2*ABA2
      PT1B2=PT1B2-2.0*ATR*FT2*MB*ATA1SQ*BBA2*ABA2
      PT1B2=PT1B2+2.0*EP*FT*FB*MB*BTA1*ATA1*ABA2SQ
      PT1B2=PT1B2+FT2*AT2*ATA1SQ*BBA2SQ
      PT1B2=PT1B2+FB2*EP2*BTA1SQ*ABA2SQ
      PT1B2=PT1B2+FT2*MB2*ATA1SQ*ABA2SQ
      PT1B2=PT1B2*NABT1*NABB2
C
      PT2B1=V2*(FTG**2)*BTA2SQ*BBA1SQ
      PT2B1=PT2B1+2.0*EP*FB*V*FTG*BTA2SQ*BBA1*ABA1
      PT2B1=PT2B1-2.0*ATR*MT*FTG*BTA2*ATA2*BBA1SQ
      PT2B1=PT2B1+2.0*BABA*BTA2*ATA2*BBA1*ABA1
      PT2B1=PT2B1-2.0*ATR*FT2*MB*ATA2SQ*BBA1*ABA1
      PT2B1=PT2B1+2.0*EP*FT*FB*MB*BTA2*ATA2*ABA1SQ
      PT2B1=PT2B1+FT2*AT2*ATA2SQ*BBA1SQ
      PT2B1=PT2B1+FB2*EP2*BTA2SQ*ABA1SQ
      PT2B1=PT2B1+FT2*MB2*ATA2SQ*ABA1SQ
      PT2B1=PT2B1*NABT2*NABB1
C
      PT2B2=V2*(FTG**2)*BTA2SQ*BBA2SQ
      PT2B2=PT2B2+2.0*EP*FB*V*FTG*BTA2SQ*BBA2*ABA2
      PT2B2=PT2B2-2.0*ATR*MT*FTG*BTA2*ATA2*BBA2SQ
      PT2B2=PT2B2+2.0*BABA*BTA2*ATA2*BBA2*ABA2
      PT2B2=PT2B2-2.0*ATR*FT2*MB*ATA2SQ*BBA2*ABA2
      PT2B2=PT2B2+2.0*EP*FT*FB*MB*BTA2*ATA2*ABA2SQ
      PT2B2=PT2B2+FT2*AT2*ATA2SQ*BBA2SQ
      PT2B2=PT2B2+FB2*EP2*BTA2SQ*ABA2SQ
      PT2B2=PT2B2+FT2*MB2*ATA2SQ*ABA2SQ
      PT2B2=PT2B2*NABT2*NABB2
C          The following used to add 1e-8, but this may be less than
C          machine precision. Multiply by 1.001 instead.
      IF(MST1SQ.EQ.MSB1SQ) THEN
        WRITE(LOUT,*) 'SSMHC: WARNING: MST1 = MSB1',
     $  '  MST1 RAISED BY 0.0001'
        MST1SQ = MST1SQ*1.0001
      ENDIF
      IF(MST1SQ.EQ.MSB2SQ) THEN
        WRITE(LOUT,*) 'SSMHC: WARNING: MST1 = MSB2',
     $  '  MST1 RAISED BY 0.0001'
        MST1SQ = MST1SQ*1.0001
      ENDIF
      IF(MST2SQ.EQ.MSB1SQ) THEN
        WRITE(LOUT,*) 'SSMHC: WARNING: MST2 = MSB1',
     $  '  MST2 RAISED BY 0.0001'
        MST2SQ = MST2SQ*1.0001
      ENDIF
      IF(MST2SQ.EQ.MSB2SQ) THEN
        WRITE(LOUT,*) 'SSMHC: WARNING: MST2 = MSB2',
     $  '  MST2 RAISED BY 0.0001'
        MST2SQ = MST2SQ*1.0001
      ENDIF
C
      PDPST1=PT1B1/(MST1SQ-MSB1SQ) +PT1B2/(MST1SQ-MSB2SQ)
      PDPST2=PT2B1/(MST2SQ-MSB1SQ) +PT2B2/(MST2SQ-MSB2SQ)
      PDPSB1=PT1B1/(MSB1SQ-MST1SQ) +PT2B1/(MSB1SQ-MST2SQ)
      PDPSB2=PT1B2/(MSB2SQ-MST1SQ) +PT2B2/(MSB2SQ-MST2SQ)
C
C       Calculate perturbative terms
C        from H_R'^-2 derivative terms
C
      FBG=FB2-ZAP*G2/2.0
      BABA=FT*FB*(VVP*FBG-EP*ABR)
      PT1B1=VP2*(FBG**2)*BTA1SQ*BBA1SQ
      PT1B1=PT1B1-2.0*ABR*MB*FBG*BTA1SQ*BBA1*ABA1
      PT1B1=PT1B1+2.0*EP*FT*VP*FBG*BTA1*ATA1*BBA1SQ
      PT1B1=PT1B1+2.0*BABA*BTA1*ATA1*BBA1*ABA1
      PT1B1=PT1B1+2.0*EP*FT*FB*MT*ATA1SQ*BBA1*ABA1
      PT1B1=PT1B1-2.0*ABR*FB2*MT*BTA1*ATA1*ABA1SQ
      PT1B1=PT1B1+FT2*EP2*ATA1SQ*BBA1SQ
      PT1B1=PT1B1+FB2*AB2*BTA1SQ*ABA1SQ
      PT1B1=PT1B1+FB2*MT2*ATA1SQ*ABA1SQ
      PT1B1=PT1B1*NABT1*NABB1
C
      PT1B2=VP2*(FBG**2)*BTA1SQ*BBA2SQ
      PT1B2=PT1B2-2.0*ABR*MB*FBG*BTA1SQ*BBA2*ABA2
      PT1B2=PT1B2+2.0*EP*FT*VP*FBG*BTA1*ATA1*BBA2SQ
      PT1B2=PT1B2+2.0*BABA*BTA1*ATA1*BBA2*ABA2
      PT1B2=PT1B2+2.0*EP*FT*FB*MT*ATA1SQ*BBA2*ABA2
      PT1B2=PT1B2-2.0*ABR*FB2*MT*BTA1*ATA1*ABA2SQ
      PT1B2=PT1B2+FT2*EP2*ATA1SQ*BBA2SQ
      PT1B2=PT1B2+FB2*AB2*BTA1SQ*ABA2SQ
      PT1B2=PT1B2+FB2*MT2*ATA1SQ*ABA2SQ
      PT1B2=PT1B2*NABT1*NABB2
C
      PT2B1=VP2*(FBG**2)*BTA2SQ*BBA1SQ
      PT2B1=PT2B1-2.0*ABR*MB*FBG*BTA2SQ*BBA1*ABA1
      PT2B1=PT2B1+2.0*EP*FT*VP*FBG*BTA2*ATA2*BBA1SQ
      PT2B1=PT2B1+2.0*BABA*BTA2*ATA2*BBA1*ABA1
      PT2B1=PT2B1+2.0*EP*FT*FB*MT*ATA2SQ*BBA1*ABA1
      PT2B1=PT2B1-2.0*ABR*FB2*MT*BTA2*ATA2*ABA1SQ
      PT2B1=PT2B1+FT2*EP2*ATA2SQ*BBA1SQ
      PT2B1=PT2B1+FB2*AB2*BTA2SQ*ABA1SQ
      PT2B1=PT2B1+FB2*MT2*ATA2SQ*ABA1SQ
      PT2B1=PT2B1*NABT2*NABB1
C
      PT2B2=VP2*(FBG**2)*BTA2SQ*BBA2SQ
      PT2B2=PT2B2-2.0*ABR*MB*FBG*BTA2SQ*BBA2*ABA2
      PT2B2=PT2B2+2.0*EP*FT*VP*FBG*BTA2*ATA2*BBA2SQ
      PT2B2=PT2B2+2.0*BABA*BTA2*ATA2*BBA2*ABA2
      PT2B2=PT2B2+2.0*EP*FT*FB*MT*ATA2SQ*BBA2*ABA2
      PT2B2=PT2B2-2.0*ABR*FB2*MT*BTA2*ATA2*ABA2SQ
      PT2B2=PT2B2+FT2*EP2*ATA2SQ*BBA2SQ
      PT2B2=PT2B2+FB2*AB2*BTA2SQ*ABA2SQ
      PT2B2=PT2B2+FB2*MT2*ATA2SQ*ABA2SQ
      PT2B2=PT2B2*NABT2*NABB2
C
      PDMST1=PT1B1/(MST1SQ-MSB1SQ) +PT1B2/(MST1SQ-MSB2SQ)
      PDMST2=PT2B1/(MST2SQ-MSB1SQ) +PT2B2/(MST2SQ-MSB2SQ)
      PDMSB1=PT1B1/(MSB1SQ-MST1SQ) +PT2B1/(MSB1SQ-MST2SQ)
      PDMSB2=PT1B2/(MSB2SQ-MST1SQ) +PT2B2/(MSB2SQ-MST2SQ)
C
C        Calculate perturbative terms
C        from  H_R^+ H_R'^- derivative terms
C
      BABA=FT*FB*(V2*FTG+VP2*FBG+EP2+ATR*ABR)
      PT1B1=-VVP*FTG*FBG*BTA1SQ*BBA1SQ
      PT1B1=PT1B1+FB*(ABR*V*FTG-EP*VP*FBG)*BTA1SQ*BBA1*ABA1
      PT1B1=PT1B1-FT*(EP*V*FTG-ATR*VP*FBG)*BTA1*ATA1*BBA1SQ
      PT1B1=PT1B1-BABA*BTA1*ATA1*BBA1*ABA1
      PT1B1=PT1B1+FT2*FB*(ATR*V-EP*VP)*ATA1SQ*BBA1*ABA1
      PT1B1=PT1B1+FT*FB2*(ABR*VP-EP*V)*BTA1*ATA1*ABA1SQ
      PT1B1=PT1B1+FT2*EP*ATR*ATA1SQ*BBA1SQ
      PT1B1=PT1B1+FB2*EP*ABR*BTA1SQ*ABA1SQ
      PT1B1=PT1B1-FT*FB*MT*MB*ATA1SQ*ABA1SQ
      PT1B1=PT1B1*NABT1*NABB1
C
      PT1B2=-VVP*FTG*FBG*BTA1SQ*BBA2SQ
      PT1B2=PT1B2+FB*(ABR*V*FTG-EP*VP*FBG)*BTA1SQ*BBA2*ABA2
      PT1B2=PT1B2-FT*(EP*V*FTG-ATR*VP*FBG)*BTA1*ATA1*BBA2SQ
      PT1B2=PT1B2-BABA*BTA1*ATA1*BBA2*ABA2
      PT1B2=PT1B2+FT2*FB*(ATR*V-EP*VP)*ATA1SQ*BBA2*ABA2
      PT1B2=PT1B2+FT*FB2*(ABR*VP-EP*V)*BTA1*ATA1*ABA2SQ
      PT1B2=PT1B2+FT2*EP*ATR*ATA1SQ*BBA2SQ
      PT1B2=PT1B2+FB2*EP*ABR*BTA1SQ*ABA2SQ
      PT1B2=PT1B2-FT*FB*MT*MB*ATA1SQ*ABA2SQ
      PT1B2=PT1B2*NABT1*NABB2
C
      PT2B1= -VVP*FTG*FBG*BTA2SQ*BBA1SQ
      PT2B1= PT2B1 + FB*(ABR*V*FTG - EP*VP*FBG)*BTA2SQ*BBA1*ABA1
      PT2B1= PT2B1 - FT*(EP*V*FTG - ATR*VP*FBG)*BTA2*ATA2*BBA1SQ
      PT2B1= PT2B1 - BABA*BTA2*ATA2*BBA1*ABA1
      PT2B1= PT2B1 + FT2*FB*(ATR*V - EP*VP)*ATA2SQ*BBA1*ABA1
      PT2B1= PT2B1 + FT*FB2*(ABR*VP - EP*V)*BTA2*ATA2*ABA1SQ
      PT2B1= PT2B1 + FT2*EP*ATR*ATA2SQ*BBA1SQ
      PT2B1= PT2B1 + FB2*EP*ABR*BTA2SQ*ABA1SQ
      PT2B1= PT2B1 - FT*FB*MT*MB*ATA2SQ*ABA1SQ
      PT2B1= PT2B1*NABT2*NABB1
C
      PT2B2=-VVP*FTG*FBG*BTA2SQ*BBA2SQ
      PT2B2=PT2B2+FB*(ABR*V*FTG-EP*VP*FBG)*BTA2SQ*BBA2*ABA2
      PT2B2=PT2B2-FT*(EP*V*FTG-ATR*VP*FBG)*BTA2*ATA2*BBA2SQ
      PT2B2=PT2B2-BABA*BTA2*ATA2*BBA2*ABA2
      PT2B2=PT2B2+FT2*FB*(ATR*V-EP*VP)*ATA2SQ*BBA2*ABA2
      PT2B2=PT2B2+FT*FB2*(ABR*VP-EP*V)*BTA2*ATA2*ABA2SQ
      PT2B2=PT2B2+FT2*EP*ATR*ATA2SQ*BBA2SQ
      PT2B2=PT2B2+FB2*EP*ABR*BTA2SQ*ABA2SQ
      PT2B2=PT2B2-FT*FB*MT*MB*ATA2SQ*ABA2SQ
      PT2B2=PT2B2*NABT2*NABB2
C
      PDPMT1=PT1B1/(MST1SQ-MSB1SQ) +PT1B2/(MST1SQ-MSB2SQ)
      PDPMT2=PT2B1/(MST2SQ-MSB1SQ) +PT2B2/(MST2SQ-MSB2SQ)
      PDPMB1=PT1B1/(MSB1SQ-MST1SQ) +PT2B1/(MSB1SQ-MST2SQ)
      PDPMB2=PT1B2/(MSB2SQ-MST1SQ) +PT2B2/(MSB2SQ-MST2SQ)
C
      MST1SQ=MST1**2
      MST2SQ=MST2**2
      LMST1=MST1SQ*(2.0*LOG(MST1SQ/QQQ2)+1.0)
      LMST2=MST2SQ*(2.0*LOG(MST2SQ/QQQ2)+1.0)
      LMSB1=MSB1SQ*(2.0*LOG(MSB1SQ/QQQ2)+1.0)
      LMSB2=MSB2SQ*(2.0*LOG(MSB2SQ/QQQ2)+1.0)
C
      EMI1=LMST1*(PDPST1+DHPST1-DHRT1)
      EMI1=EMI1+LMST2*(PDPST2+DHPST2-DHRT2)
      EMI1=EMI1+LMSB1*(PDPSB1+DHPSB1-DHRB1)
      EMI1=EMI1+LMSB2*(PDPSB2+DHPSB2-DHRB2)
C
      EMI2=LMST1*(PDMST1+DHMST1-DHRPT1)
      EMI2=EMI2+LMST2*(PDMST2+DHMST2-DHRPT2)
      EMI2=EMI2+LMSB1*(PDMSB1+DHMSB1-DHRPB1)
      EMI2=EMI2+LMSB2*(PDMSB2+DHMSB2-DHRPB2)
C
      EM3=LMST1*PDPMT1+LMST2*PDPMT2
      EM3=EM3+LMSB1*PDPMB1+LMSB2*PDPMB2
C
      TEMPF=MT2*LOG(MT2/QQQ2)-MB2*LOG(MB2/QQQ2)
      DVRR=4.0*FT2*MB2*TEMPF/(MT2-MB2)
      DVRR=3.0*(EMI1-DVRR-2.0*FT2*MB2)/32.0/PI2
      DVRR=-TM1B*COTB +VP2*G2/2.0 +DVRR
C
      DVRPRP=4.0*FB2*MT2*TEMPF/(MT2-MB2)
      DVRPRP=3.0*(EMI2-DVRPRP-2.0*FB2*MT2)/32.0/PI2
      DVRPRP=-TM1B*TANB +V2*G2/2.0 +DVRPRP
C
      DVRRP=1.0 +(MT2+MB2)*LOG(MT2/MB2)/(MT2-MB2)
      DVRRP=2.0*FT*FB*MT*MB*(DVRRP+LOG(MT2*MB2/(QQQ2**2)))
      DVRRP=3.0*(EM3+DVRRP)/32.0/PI2
      DVRRP=TM1B -G2*VVP/2.0 +DVRRP
C
      TRACE=DVRR+DVRPRP
      DETV=4.0*(DVRR*DVRPRP-DVRRP**2)
C          Rewrite TERMSQ=TRACE**2-DETV
      TERMSQ=(DVRR-DVRPRP)**2+4*DVRRP**2
      TERMSQ=SQRT(TERMSQ)/2.0
      GOLD2=TRACE/2.0 -TERMSQ
      MHC2=TRACE/2.0 +TERMSQ
C
      IF(MHC2.LT.0.0) THEN
        MHCNEG=1
        AMHC=0.
        GO TO 1000
      ENDIF
      AMHC=SQRT(MHC2)
1000  RETURN
      END
CDECK  ID>, SSMHN.  
      SUBROUTINE SSMHN(MHLNEG)
C-----------------------------------------------------------------------
C
C          Calculate HL, HH masses and ALFAH
C          (scalar Higgs mixing angle) using radiative
C          corrections calculated by M. Bisset
C          and save results in /SSPAR/.
C
C          Both top and bottom couplings are now
C          included.  Non-degenerate mixed squark
C          masses and A-terms are also included.
C          The D-terms from the squark mass matrix
C          (terms prop. to g**2 * Yukawa coupling)
C          are included as an option:
C                 INRAD = 1 ==> D-TERMS ON
C                 INRAD = 2 ==> D-TERMS OFF    .
C
C         10/18/93 D-terms are now turned on.
C                     INRAD = 1
C
C         There is an arbitrary mass scale that must
C         chosen to avoid dimensionful logarithms.
C         The choice does not matter if D-terms are
C         not included, but it does matter if D-terms
C         are included.
C
C         Arbitrary mass scale updated to
C              QQQ = HIGFRZ = SQRT(AMTLSS*AMTRSS)
C         with running masses to include dominant 2-loop
C         effects. 12/10/96 H. Baer
C
C         It is assumed that the A-terms are real.
C         Complex A-terms are allowed
C         (unless RTT=0 or RBB=0 --see below) in
C         this subroutine, but the imaginary parts
C         are now set to zero.
C
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C
      REAL PI,PI2,SR2,G2,GP2,GGP,GG1,GG2
      REAL TANB,COTB,COSB,SINB,BE
      REAL SINB2,COSB2,COS2B,SIN2B
      REAL V2,VP2,V,VP,VVP,VPVM,VVPP
      REAL MT2,MB2,FT2,FB2,MW2,ZAP,QQQ2
      REAL EP,EP2,RR,MHP2
      REAL ATI,ABI,ATR,ABR,AT2,AB2
      REAL TLRM,BLRM,TLRP,BLRP
      REAL MST1SQ,MST2SQ,MSB1SQ,MSB2SQ

      REAL RTT,TTT1,TEMPT,TM1BT
      REAL TEMPS,T1RD,T2RD,T1RPD,T2RPD
      REAL CT1,A1,A2,T1RR,T2RR
      REAL CT5,A5,A6,T1RPRP,T2RPRP
      REAL A9,T1RRP,T2RRP
      REAL TEMPSQ,DT1,DT2,VRRT,VRPRPT,VRRPT
      REAL ALPHAT,LAT
C
      REAL RBB,BBB1,TEMPB,TM1BB
      REAL B1RD,B2RD,B1RPD,B2RPD
      REAL CB3,A3,A4,B1RR,B2RR
      REAL CB7,A7,A8,B1RPRP,B2RPRP
      REAL A10,B1RRP,B2RRP
      REAL DB1,DB2,VRRB,VRPRPB,VRRPB
      REAL ALPHAB,LAB
C
      REAL DVRR,DVRPRP,DVRRP,TEMPH
      REAL MHL2,MHH2,TRACEM,TPAL,TANAH
      REAL ASMB,MBMB,MBQ,ASMT,MTMT,MTQ,SUALFS,HIGFRZ
      DOUBLE PRECISION SSMQCD
      INTEGER INRAD,MHLNEG
C
      MHLNEG=0
      PI=4.*ATAN(1.)
      PI2 = PI**2
      SR2=SQRT(2.)
      G2=4.*PI*ALFAEM/SN2THW
      GP2=G2*SN2THW/(1.-SN2THW)
      HIGFRZ=SQRT(AMTLSS*AMTRSS)
      ASMB=SUALFS(AMBT**2,.36,AMTP,3)
      MBMB=AMBT*(1.-4*ASMB/3./PI)
      MBQ=SSMQCD(DBLE(MBMB),DBLE(HIGFRZ))
      ASMT=SUALFS(AMTP**2,.36,AMTP,3)
      MTMT=AMTP/(1.+4*ASMT/3./PI+(16.11-1.04*(5.-6.63/AMTP))*
     $(ASMT/PI)**2)
      MTQ=SSMQCD(DBLE(MTMT),DBLE(HIGFRZ))
      MT2=MTQ**2
      MB2=MBQ**2
      MW2=AMW**2
      EP=TWOM1
      EP2=EP**2
      RR=RV2V1
      MHP2=AMHA**2
      TANB=1.0/RR
      COTB=RR
      BE=ATAN(1./RV2V1)
      SINB=SIN(BE)
      COSB=COS(BE)
      SINB2=SINB**2
      COSB2=COSB**2
      SIN2B=SIN(2.*BE)
      COS2B=COS(2.*BE)
      V2=2.0*MW2*SINB2/G2
      VP2=2.0*MW2*COSB2/G2
      V=SQRT(V2)
      VP=SQRT(VP2)
      VVP=SQRT(V2*VP2)
      VPVM=VP2-V2
      GGP=G2+GP2
      GG1=G2-5.0*GP2/3.0
      GG2=G2-GP2/3.0
      VVPP=2.0*AMZ**2/GGP
      FT2=MT2/V2
      FB2=MB2/VP2
C
      TLRM=AMTLSS**2-AMTRSS**2
      BLRM=AMBLSS**2-AMBRSS**2
      TLRP=AMTLSS**2+AMTRSS**2
      BLRP=AMBLSS**2+AMBRSS**2
C
C          Higgs mass matrix
C
C     (AAT and AAB are also assumed to be real)
C
      ATR=AAT
      ABR=AAB
      ATI=0.0
      ABI=0.0
      AT2=ATR**2+ATI**2
      AB2=ABR**2+ABI**2
C
      MST1SQ=AMT1SS**2
      MST2SQ=AMT2SS**2
      MSB1SQ=AMB1SS**2
      MSB2SQ=AMB2SS**2
      INRAD=1
      QQQ2=HIGFRZ**2
C
      ZAP = 1.0
C
C                  STOP TERMS
C
      RTT=(TLRM+VPVM*ZAP*GG1/4.0)**2
     $      +4.0*MT2*(EP*COTB+ATR)**2+4.0*MT2*ATI**2
      RTT=SQRT(RTT)
C
C     calculate 2M1*B term
C
      TTT1=0.5*TLRP+MT2+VPVM*ZAP*GGP/8.0
      IF(RTT.NE.0.0) THEN
        TEMPT=4.0*EP*FT2*VVP*ATI**2/(RTT**2)
        TM1BT=-2.0*FT2*(TEMPT+ATR)*TTT1
     $               *LOG(MST2SQ/MST1SQ)/RTT
        TM1BT=TM1BT-FT2*ATR
     $               *LOG(MST1SQ*MST2SQ/QQQ2/QQQ2)
        TM1BT=TM1BT+FT2*(2.0*TEMPT-ATR)
        TM1BT=3.0*EP*TM1BT/32.0/PI2
C
C        calculate first derivatives w.r.t H_R
C           divided by sqrt(2) * v
C
         TEMPS=-ZAP*GG1*(TLRM+ZAP*GG1*VPVM/4.0)/2.0
         TEMPS=TEMPS+4.0*FT2*(AT2+EP*COTB*ATR)
         TEMPS=TEMPS/RTT/4.0
         T1RD=FT2-ZAP*GGP/8.0-TEMPS
         T2RD=FT2-ZAP*GGP/8.0+TEMPS
C
C        calculate first derivatives w.r.t H_R'
C           divided by sqrt(2) * v'
C
         TEMPS=ZAP*GG1*(TLRM+ZAP*GG1*VPVM/4.0)/2.0
         TEMPS=TEMPS+4.0*FT2*EP*(EP+TANB*ATR)
         TEMPS=TEMPS/RTT/4.0
         T1RPD=ZAP*GGP/8.0-TEMPS
         T2RPD=ZAP*GGP/8.0+TEMPS
C
C        calculate second derivatives w.r.t. H_R
C
         CT1=-V*ZAP*GG1*(TLRM+ZAP*GG1*VPVM/4.0)/SR2
         CT1=CT1+4.0*SR2*FT2*V*(EP*COTB*ATR+AT2)
         A1=-CT1**2/(RTT**3)/8.0
         A2=-ZAP*GG1*(TLRM+ZAP*GG1*VPVM/4.0)/2.0
         A2=A2+V2*ZAP*GG1**2/4.0+4.0*FT2*AT2
         A2=A2/RTT/4.0
         T1RR=FT2-ZAP*GGP/8.0-A1-A2
         T2RR=FT2-ZAP*GGP/8.0+A1+A2
C
C        calculate second derivatives w.r.t. H_R'
C
         CT5=VP*ZAP*GG1*(TLRM+ZAP*GG1*VPVM/4.0)/SR2
         CT5=CT5+4.0*SR2*FT2*VP*EP*(EP+TANB*ATR)
         A5=-CT5**2/(RTT**3)/8.0
         A6=ZAP*GG1*(TLRM+ZAP*GG1*VPVM/4.0)/2.0
         A6=A6+VP2*ZAP*GG1**2/4.0+4.0*FT2*EP2
         A6=A6/RTT/4.0
         T1RPRP=ZAP*GGP/8.0-A5-A6
         T2RPRP=ZAP*GGP/8.0+A5+A6
C
C        calculate second derivatives w.r.t. H_R and H_R'
C
         A9=-VVP*ZAP*(GG1**2)/4.0+4.0*FT2*EP*ATR
         A9=A9/RTT/4.0
         T1RRP=CT1*CT5/(RTT**3)/8.0-A9
         T2RRP=-CT1*CT5/(RTT**3)/8.0+A9
C
C        calculate D^2 V / D^2 H_R
C
         TEMPSQ=MST1SQ*(T1RR-T1RD)
         DT1=2.0*(2.0*V2*T1RD**2+TEMPSQ)*LOG(MST1SQ/QQQ2)
         DT1=DT1+6.0*V2*T1RD**2+TEMPSQ
         TEMPSQ=MST2SQ*(T2RR-T2RD)
         DT2=2.0*(2.0*V2*T2RD**2+TEMPSQ)*LOG(MST2SQ/QQQ2)
         DT2=DT2+6.0*V2*T2RD**2+TEMPSQ
         VRRT=DT1+DT2-8.0*FT2*MT2*LOG(MT2/QQQ2)-12.0*FT2*MT2
         VRRT=-TM1BT*COTB+3.0*VRRT/32.0/PI2
C
C        calculate D^2 V / D^2 H'_R
C
         TEMPSQ=MST1SQ*(T1RPRP-T1RPD)
         DT1=2.0*(2.0*VP2*T1RPD**2+TEMPSQ)*LOG(MST1SQ/QQQ2)
         DT1=DT1+6.0*VP2*T1RPD**2+TEMPSQ
         TEMPSQ=MST2SQ*(T2RPRP-T2RPD)
         DT2=2.0*(2.0*VP2*T2RPD**2+TEMPSQ)*LOG(MST2SQ/QQQ2)
         DT2=DT2+6.0*VP2*T2RPD**2+TEMPSQ
         VRPRPT=-TM1BT*TANB+3.0*(DT1+DT2)/32.0/PI2
C
C        calculate D^2 V / D^H_R  D^H_R'
C
         DT1=2.0*VVP*T1RD*T1RPD+MST1SQ*T1RRP
         DT1=2.0*DT1*LOG(MST1SQ/QQQ2)
         DT1=DT1+6.0*VVP*T1RD*T1RPD+MST1SQ*T1RRP
         DT2=2.0*VVP*T2RD*T2RPD+MST2SQ*T2RRP
         DT2=2.0*DT2*LOG(MST2SQ/QQQ2)
         DT2=DT2+6.0*VVP*T2RD*T2RPD+MST2SQ*T2RRP
         VRRPT=TM1BT+3.0*(DT1+DT2)/32.0/PI2
C
      ELSE IF(RTT.EQ.0.0) THEN
C
         ALPHAT=TLRP/2.0+MT2+ZAP*GGP*VPVM/8.0
         LAT=2.0*LOG(ALPHAT/QQQ2)+3.0
C
C        calculate D^2 V / D^2 H_R
C
         VRRT=V2*(GGP**2+GG1**2)/16.0-MT2*GGP
         VRRT=ZAP*VRRT*LAT+8.0*FT2*MT2*LOG(ALPHAT/MT2)
         VRRT=3.0*VRRT/32.0/PI2
C
C        calculate D^2 V / D^2 H_R'
C
         VRPRPT=ZAP*VP2*(GGP**2+GG1**2)/16.0
         VRPRPT=3.0*(VRPRPT*LAT)/32.0/PI2
C
C        calculate D^2 V / D^H_R D^H_R'
C
         VRRPT=FT2*GGP-(GGP**2+GG1**2)/8.0
         VRRPT=ZAP*VVP*VRRPT*LAT/2.0
         VRRPT=3.0*VRRPT/32.0/PI2
C
C
      ENDIF
C
C     SBOTTOM TERMS
C
      RBB=(BLRM-VPVM*ZAP*GG2/4.0)**2
     $      +4.0*MB2*(EP*TANB+ABR)**2+4.0*MB2*ABI**2
      RBB=SQRT(RBB)
C      IF(RBB.EQ.0.0.AND.ABI.NE.0.0) THEN
C        WRITE(6,*) 'RBB=0, ABI NOT 0'
C        WRITE(6,*) 'ERROR: THIS CASE NOT COVERED YET'
C        GO TO 1000
C      ENDIF
C
      IF(RBB.NE.0.0) THEN
C
C     calculate 2M1*B term
C
        BBB1=0.5*BLRP+MB2-VPVM*ZAP*GGP/8.0
        TEMPB=4.0*EP*FB2*VVP*ABI**2/(RBB**2)
        TM1BB=-2.0*FB2*(TEMPB+ABR)*BBB1
     $               *LOG(MSB2SQ/MSB1SQ)/RBB
        TM1BB=TM1BB-FB2*ABR
     $               *LOG(MSB1SQ*MSB2SQ/QQQ2/QQQ2)
        TM1BB=TM1BB+FB2*(2.0*TEMPB-ABR)
        TM1BB=3.0*EP*TM1BB/32.0/PI2
C
C        calculate first derivatives w.r.t H_R
C           divided by sqrt(2) * v
C
        TEMPS=ZAP*GG2*(BLRM-ZAP*GG2*VPVM/4.0)/2.0
        TEMPS=TEMPS+4.0*FB2*EP*(EP+COTB*ABR)
        TEMPS=TEMPS/RBB/4.0
        B1RD=ZAP*GGP/8.0-TEMPS
        B2RD=ZAP*GGP/8.0+TEMPS

C        calculate first derivatives w.r.t H_R'
C           divided by sqrt(2) * v'
C
        TEMPS=-ZAP*GG2*(BLRM-ZAP*GG2*VPVM/4.0)/2.0
        TEMPS=TEMPS+4.0*FB2*(AB2+EP*TANB*ABR)
        TEMPS=TEMPS/RBB/4.0
        B1RPD=FB2-ZAP*GGP/8.0-TEMPS
        B2RPD=FB2-ZAP*GGP/8.0+TEMPS
C
C        calculate second derivatives w.r.t. H_R
C
        CB3=V*ZAP*GG2*(BLRM-ZAP*GG2*VPVM/4.0)/SR2
        CB3=CB3+4.0*SR2*FB2*V*EP*(EP+COTB*ABR)
        A3=-CB3**2/(RBB**3)/8.0
        A4=ZAP*GG2*(BLRM-ZAP*GG2*VPVM/4.0)/2.0
        A4=A4+V2*ZAP*GG2**2/4.0+4.0*FB2*EP2
        A4=A4/RBB/4.0
        B1RR=ZAP*GGP/8.0-A3-A4
        B2RR=ZAP*GGP/8.0+A3+A4
C
C       calculate second derivatives w.r.t. H_R'
C
        CB7=-VP*ZAP*GG2*(BLRM-ZAP*GG2*VPVM/4.0)/SR2
        CB7=CB7+4.0*SR2*FB2*VP*(AB2+EP*TANB*ABR)
        A7=-CB7**2/(RBB**3)/8.0
        A8=-ZAP*GG2*(BLRM-ZAP*GG2*VPVM/4.0)/2.0
        A8=A8+VP2*ZAP*GG2**2/4.0+4.0*FB2*AB2
        A8=A8/RBB/4.0
        B1RPRP=FB2-ZAP*GGP/8.0-A7-A8
        B2RPRP=FB2-ZAP*GGP/8.0+A7+A8
C
C       calculate second derivatives w.r.t. H_R and H_R'
C
        A10=-VVP*ZAP*(GG2**2)/4.0+4.0*FB2*EP*ABR
        A10=A10/RBB/4.0
        B1RRP=CB3*CB7/(RBB**3)/8.0-A10
        B2RRP=-CB3*CB7/(RBB**3)/8.0+A10
C
C       calculate  D^2 V / D^2 H_R
C
        TEMPSQ=MSB1SQ*(B1RR-B1RD)
        DB1=2.0*(2.0*V2*B1RD**2+TEMPSQ)*LOG(MSB1SQ/QQQ2)
        DB1=DB1+6.0*V2*B1RD**2+TEMPSQ
        TEMPSQ=MSB2SQ*(B2RR-B2RD)
        DB2=2.0*(2.0*V2*B2RD**2+TEMPSQ)*LOG(MSB2SQ/QQQ2)
        DB2=DB2+6.0*V2*B2RD**2+TEMPSQ
        VRRB=-TM1BB*COTB+3.0*(DB1+DB2)/32.0/PI2
C
C       calculate  D^2 V / D^2 H'_R
C
        TEMPSQ=MSB1SQ*(B1RPRP-B1RPD)
        DB1=2.0*(2.0*VP2*B1RPD**2+TEMPSQ)*LOG(MSB1SQ/QQQ2)
        DB1=DB1+6.0*VP2*B1RPD**2+TEMPSQ
        TEMPSQ=MSB2SQ*(B2RPRP-B2RPD)
        DB2=2.0*(2.0*VP2*B2RPD**2+TEMPSQ)*LOG(MSB2SQ/QQQ2)
        DB2=DB2+6.0*VP2*B2RPD**2+TEMPSQ
        VRPRPB=DB1+DB2
        VRPRPB=DB1+DB2-8.0*FB2*MB2*LOG(MB2/QQQ2)-12.0*FB2*MB2
        VRPRPB=-TM1BB*TANB+3.0*VRPRPB/32.0/PI2
C
C       calculate  D^2 V / D H_R  D H'_R
C
        DB1=2.0*VVP*B1RD*B1RPD+MSB1SQ*B1RRP
        DB1=2.0*DB1*LOG(MSB1SQ/QQQ2)
        DB1=DB1+6.0*VVP*B1RD*B1RPD+MSB1SQ*B1RRP
        DB2=2.0*VVP*B2RD*B2RPD+MSB2SQ*B2RRP
        DB2=2.0*DB2*LOG(MSB2SQ/QQQ2)
        DB2=DB2+6.0*VVP*B2RD*B2RPD+MSB2SQ*B2RRP
        VRRPB=TM1BB+3.0*(DB1+DB2)/32.0/PI2

      ELSE IF(RBB.EQ.0.0) THEN
C
        ALPHAB=BLRP/2.0+MB2-ZAP*GGP*VPVM/8.0
        LAB=2.0*LOG(ALPHAB/QQQ2)+3.0
C
C       calculate  D^2 V / D^2 H_R
C
        VRRB=ZAP*V2*(GGP**2 + GG2**2)/16.0
        VRRB=3.0*(VRRB*LAB)/32.0/PI2
C
C       calculate  D^2 V / D^2 H_R'
C
        VRPRPB=VP2*(GGP**2+GG2**2)/16.0-MB2*GGP
        VRPRPB=ZAP*VRPRPB*LAB+8.0*FB2*MB2*LOG(ALPHAB/MB2)
        VRPRPB=3.0*VRPRPB/32.0/PI2
C
C       calculate  D^2 V / D^H_R D^H_R'
C
        VRRPB=FB2*GGP-(GGP**2+GG2**2)/8.0
        VRRPB=ZAP*VVP*VRRPB*LAB/2.0
        VRRPB=3.0*VRRPB/32.0/PI2
C
      ENDIF
C
      DVRR=VRRT+VRRB+VP2*MHP2/VVPP + V2*GGP/2.0
      DVRPRP=VRPRPT+VRPRPB+V2*MHP2/VVPP + VP2*GGP/2.0
      DVRRP=VRRPT+VRRPB-VVP*MHP2/VVPP - VVP*GGP/2.0
C          TEMPH is always non-negative:
      TEMPH=(DVRR-DVRPRP)**2+4*DVRRP**2
      TEMPH=0.5*SQRT(TEMPH)
      MHL2=0.5*(DVRR+DVRPRP)-TEMPH
      MHH2=0.5*(DVRR+DVRPRP)+TEMPH
      IF(MHL2.LT.0.0) THEN
        MHLNEG=1
C        WRITE(LOUT,*) 'SSMHN: ERROR:  MHL**2 < 0.0 FOR PARAMETERS:'
C        WRITE(LOUT,*) 'MHP =', AMHA, 'TANB =', 1.0/RR
C        WRITE(LOUT,*) 'MSTL=', AMTLSS, 'MSBL=', AMBLSS
C        WRITE(LOUT,*) 'MSTR=', AMTRSS, 'MSBR=', AMBRSS
C        WRITE(LOUT,*) 'AT=', AAT, 'AB=', AAB
C        WRITE(LOUT,*) 'MU=-2M1=', -EP
C        WRITE(LOUT,*) 'MT=', AMTP, 'MB=', AMBT
C        WRITE(LOUT,*) 'D-TERMS? 1=YES 2=NO :', INRAD
C        WRITE(LOUT,*) 'MASS SCALE (QQQ)=', SQRT(QQQ2)
        AMHH=SQRT(MHH2)
        AMHL=SQRT(ABS(MHL2))
        GO TO 1000
      ENDIF
      AMHL=SQRT(MHL2)
      AMHH=SQRT(MHH2)

C
C     Now calculate mixing angle ALFAH
C
      TRACEM=DVRR-DVRPRP
      TPAL=TRACEM**2 + 4.0*DVRRP**2
      TANAH=TRACEM+SQRT(TPAL)
      IF(DVRRP.EQ.0.0) THEN
        WRITE(LOUT,*) 'SSMHN: OFF-DIAGONAL TERM OF SCALAR HIGGS',
     $  ' MASS MATRIX IS ZERO '
        IF(TANAH.NE.0.0) THEN
          WRITE(LOUT,*) 'SSMHN: WARNING: TAN(ALFAH) FORMULA',
     $    ' YIELDS INFINITY'
        ELSE IF(TANAH.EQ.0.0) THEN
          WRITE(LOUT,*) 'SSMHN: WARNING: TAN(ALFAH) FORMULA',
     $    ' YIELDS 0/0 '
        ENDIF
        IF(DVRR.GT.DVRPRP) THEN
          WRITE(LOUT,*) 'SSMHN: DVRR > DVRPRP ==> SET ALFAH=PI/2'
          ALFAH = PI/2.0
        ELSE IF (DVRR .LT. DVRPRP) THEN
          WRITE(LOUT,*) 'SSMHN: DVRR < DVRPRP ==> SET ALFAH=0'
          ALFAH = 0.0
        ELSE IF (DVRR .EQ. DVRPRP) THEN
          WRITE(LOUT,*) 'SSMHN: DVRR = DVRPRP ==> ALFAH INDETERMINANT'
          WRITE(LOUT,*) 'SETTING SCALAR MIXING ANGLE ALPHA=PI/4'
          ALFAH=PI/4.0
        ENDIF
        GO TO 1000
      ENDIF
      TANAH = -0.5*TANAH/DVRRP
      ALFAH = ATAN(TANAH)
C
1000  RETURN
      END
CDECK  ID>, SSMQCD. 
      DOUBLE PRECISION FUNCTION SSMQCD(DM,DQ)
C-----------------------------------------------------------------------
C     Calculate leading-log running mass for quark with mass DM at
C     scale Q, using alpha_s which is continuous across thresholds.
C     See Drees and Hikasa, Phys. Lett. B240: 455-464, Eq. 4.5.
C
C     Note the threshold is at Q = 2 m, not at Q = m as in MSbar.
C
C     Bisset's QCDRAD, WDHFFC
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C
      DOUBLE PRECISION DM,DQ,DLAM4,DLAM5,DLAM6,DNEFF,POW,RENORM
     $,DQBT,DQTP
C
C         Do nothing for light quarks
C
      IF(DM.LT.1.0) THEN
        SSMQCD=DM
        RETURN
      ENDIF
C
C          Calculate running mass
C
      DLAM4=DBLE(ALQCD4)
      DQBT=2*DBLE(AMBT)
      DQTP=2*DBLE(AMTP)
      SSMQCD=0
C          Q < 2 m(b)
      DNEFF=4
      POW=12.D0/(33.D0-2.*DNEFF)
      IF(DQ.LT.DQBT) THEN
        RENORM=(LOG(2*DM/DLAM4)/LOG(DQ/DLAM4))**POW
        SSMQCD=RENORM*DM
        RETURN
      ELSE
        RENORM=(LOG(2*DM/DLAM4)/LOG(DQBT/DLAM4))**POW
      ENDIF
C          2 m(b) < Q < 2 m(t)
      DNEFF=5
      POW=12.D0/(33.D0-2.*DNEFF)
      DLAM5=DEXP((25.D0*LOG(DLAM4)-LOG(DQBT**2))/23.D0)
      IF(DQ.GE.DQBT.AND.DQ.LT.DQTP) THEN
        RENORM=RENORM
     $  *(LOG(DQBT/DLAM5)/LOG(DQ/DLAM5))**POW
        SSMQCD=RENORM*DM
        RETURN
      ELSE
        RENORM=RENORM
     $  *(LOG(DQBT/DLAM5)/LOG(DQTP/DLAM5))**POW
      ENDIF
C          2 m(t) < Q
      DNEFF=6
      POW=12.D0/(33.D0-2.*DNEFF)
      DLAM6=DEXP((25.D0*LOG(DLAM4)-LOG(DQBT**2)
     $-LOG(4*AMTP**2))/21.D0)
      RENORM=RENORM
     $*(LOG(DQTP/DLAM6)/LOG(DQ/DLAM6))**POW
      SSMQCD=RENORM*DM
      RETURN
      END
CDECK  ID>, SSMSSM. 
      SUBROUTINE SSMSSM(XMG,XMU,XMHA,XTANB,XMQ1,XMDR,XMUR,
     $XML1,XMER,XMQ2,XMSR,XMCR,XML2,XMMR,XMQ3,XMBR,XMTR,
     $XML3,XMLR,XAT,XAB,XAL,XM1,XM2,XMT,IALLOW,IMODEL)
C-----------------------------------------------------------------------
C
C     Calculate MSSM masses and decays using parameters:
C       XM1    = U(1) mass
C              > 1e19: use scaling from XMG
C       XM2    = SU(2) mass
C              > 1e19: use scaling from XMG
C       XMG    = gluino mass
C       XMQ1,...  = 1st gen. su(2) soft squark mass,...
C       XMTL   = m(stop-left)
C       XMTR   = m(stop-right)
C       XMBR   = m(sbot-right)
C       XML1   = left selectron mass
C       XMER   = right selectron mass
C       XMN1   = 1st ge. sneutrino mass
C       XTANB  = v/v' = ratio of vev's
C       XMU    = -2*m_1 = SUSY Higgs mass
C       XMHA   = m(pseudo-scalar-Higgs)
C       XMT    = m(top)
C       XAT    = stop trilinear coupling
C       XAB    = sbottom trilinear coupling
C       XAL    = stau trilinear coupling
C       IALLOW = 0 for valid point, 1 otherwise
C       IMODEL = 1 for SUGRA or MSSM, 2 for GMSB
C
C     Program outline:
C     SSMSSM:  Initialize standard model parameters in /SSSM/ and
C              SUSY parameters in /SSPAR/.
C     SSMASS:  Calculate dependent SUSY masses and mixings.
C     SSTPBF:  Calculate top decays; save in /SSMODE/.
C     SSSTBF:  Calculate stop decays; save in /SSMODE/.
C     SSGLBF:  Calcualte gluino decays; save in /SSMODE/.
C     SSQKBF:  Calculate squark decays; save in /SSMODE/.
C     SSWZBF:  Calculate gaugino decays; save in /SSMODE/.
C     SSHIBF:  Calculate Higgs decays; save in /SSMODE/.
C
C     Notes:
C  1) All particle ID codes are defined with symbolic names in
C     /SSTYPE/, making it easy to change them.
C
C  2) /SSMODE/ contains the parent, the daughters, the width, and
C     the branching ratio for each mode. Decay modes for a given parent
C     need not be adjacent, so they must be sorted at the end.
C
C  3) Some of Baer's original routines used single precision and others
C     double precision. To accomodate this, the variable names used in
C     /SSSM/ and /SSPAR/ have all been changed to longer, more
C     descriptive ones.
C
C  4) All routines have been strongly typed.
C
C     Source: H. Baer, et al.
C     Modified: F. Paige, Aug. 1992
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          MXSS                 = maximum number of modes
C          NSSMOD               = number of modes
C          ISSMOD               = initial particle
C          JSSMOD               = final particles
C          GSSMOD               = width
C          BSSMOD               = branching ratio
      INTEGER MXSS
      PARAMETER (MXSS=1000)
      COMMON/SSMODE/NSSMOD,ISSMOD(MXSS),JSSMOD(5,MXSS),GSSMOD(MXSS)
     $,BSSMOD(MXSS)
      INTEGER NSSMOD,ISSMOD,JSSMOD
      REAL GSSMOD,BSSMOD
      SAVE /SSMODE/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C
      REAL XR21,PI,SR2
      REAL XMG,XMU,XMHA,XTANB,XMQ1,XMDR,XMUR,XML1,XMER,XMQ2,XMSR,
     $XMCR,XML2,XMMR,XMQ3,XMBR,XMTR,XML3,XMLR,XAT,XAB,XAL,XM1,XM2,
     $XMT,MU1,MU2,BETA,COS2B
      INTEGER IALLOW,MHLNEG,MHCNEG,IMODEL
C
      NSSMOD=0
C
C          Standard model and SUSY parameters
C
      IALLOW=0
      XR21=1./XTANB
      PI=4.*ATAN(1.)
      SR2=SQRT(2.)
      AMUP=0.0099
      AMDN=0.0056
      AMST=0.199
      AMCH=1.35
      AMBT=5.0
      AMTP=XMT
      AME=0.511E-3
      AMMU=0.105
      AMTAU=1.784
      AMW=80.0
      AMZ=91.17
      GAMW=2.12
      GAMZ=2.487
      ALFAEM=1./128.
      SN2THW=0.232
      ALFA2=ALFAEM/SN2THW
      BETA=ATAN(XTANB)
      COS2B=COS(2*BETA)
C
C          SU(2) and U(1) gaugino masses are reset in SSMASS if
C          they are > 1e19.
C
      MU2=XM2
      MU1=XM1
C          Set 2nd gen soft terms equal to 1st gen. soft terms
c          unless previously set by user.
      IF (XMQ2.GE.1.E19) THEN
        XMQ2=XMQ1
        XMSR=XMDR
        XMCR=XMUR
        XML2=XML1
        XMMR=XMER
      END IF
C
C          The results can be quite sensitive to the choice of the
C          4-flavor QCD scale ALQCD4 and the expression for the QCD
C          coupling ALFA3. Select among the following lines:
C
      ALQCD4=0.177
      ALFA3=0.12
C
C          Calculate simple masses; other masses via SSMASS
      AMGLSS=XMG
      AMULSS=SQRT(XMQ1**2+AMUP**2+(.5-2.*SN2THW/3.)*AMZ**2*COS2B)
      AMURSS=SQRT(XMUR**2+AMUP**2+2./3.*SN2THW*AMZ**2*COS2B)
      AMDLSS=SQRT(XMQ1**2+AMDN**2+(-.5+SN2THW/3.)*AMZ**2*COS2B)
      AMDRSS=SQRT(XMDR**2+AMDN**2-1./3.*SN2THW*AMZ**2*COS2B)
      AMCLSS=SQRT(XMQ2**2+AMCH**2+(.5-2.*SN2THW/3.)*AMZ**2*COS2B)
      AMCRSS=SQRT(XMCR**2+AMCH**2+2./3.*SN2THW*AMZ**2*COS2B)
      AMSLSS=SQRT(XMQ2**2+AMST**2+(-.5+SN2THW/3.)*AMZ**2*COS2B)
      AMSRSS=SQRT(XMSR**2+AMST**2-1./3.*SN2THW*AMZ**2*COS2B)
      AMELSS=SQRT(XML1**2+AME**2-(.5-SN2THW)*AMZ**2*COS2B)
      AMERSS=SQRT(XMER**2+AME**2-SN2THW*AMZ**2*COS2B)
      AMMLSS=SQRT(XML2**2+AMMU**2-(.5-SN2THW)*AMZ**2*COS2B)
      AMMRSS=SQRT(XMMR**2+AMMU**2-SN2THW*AMZ**2*COS2B)
      AMN1SS=SQRT(XML1**2+.5*AMZ**2*COS2B)
      AMN2SS=SQRT(XML2**2+.5*AMZ**2*COS2B)
      AMN3SS=SQRT(XML3**2+.5*AMZ**2*COS2B)
      AMTLSS=XMQ3
      AMTRSS=XMTR
      AMBLSS=XMQ3
      AMBRSS=XMBR
      AMLLSS=XML3
      AMLRSS=XMLR
      AMHA=XMHA
      AAT=XAT
      AAB=XAB
      AAL=XAL
      TWOM1=-XMU
      RV2V1=XR21
C
C          Calculate mass eigenstates and check Z1SS = LSP
C
      CALL SSMASS(MU1,MU2,IALLOW,1,MHLNEG,MHCNEG,IMODEL)
      IF (MHLNEG.EQ.1.OR.MHCNEG.EQ.1) IALLOW=10
C     IF(IALLOW.NE.0) RETURN
C
C          Calculate decay widths and branching rations
C
      CALL SSTPBF
      CALL SSGLBF
      CALL SSQKBF
      CALL SSSTBF
      CALL SSLPBF
      CALL SSWZBF
      CALL SSHIBF
C
      RETURN
      END
CDECK  ID>, SSNORM. 
      SUBROUTINE SSNORM(ID)
C-----------------------------------------------------------------------
C          Normalize branching ratios for ID
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          MXSS                 = maximum number of modes
C          NSSMOD               = number of modes
C          ISSMOD               = initial particle
C          JSSMOD               = final particles
C          GSSMOD               = width
C          BSSMOD               = branching ratio
      INTEGER MXSS
      PARAMETER (MXSS=1000)
      COMMON/SSMODE/NSSMOD,ISSMOD(MXSS),JSSMOD(5,MXSS),GSSMOD(MXSS)
     $,BSSMOD(MXSS)
      INTEGER NSSMOD,ISSMOD,JSSMOD
      REAL GSSMOD,BSSMOD
      SAVE /SSMODE/
C
      INTEGER ID,I
      REAL GAMSUM
C
      GAMSUM=0
      DO 100 I=1,NSSMOD
        IF(ISSMOD(I).EQ.ID) GAMSUM=GAMSUM+GSSMOD(I)
100   CONTINUE
      IF(GAMSUM.EQ.0) RETURN
      DO 200 I=1,NSSMOD
        IF(ISSMOD(I).EQ.ID) BSSMOD(I)=GSSMOD(I)/GAMSUM
200   CONTINUE
      RETURN
      END
CDECK  ID>, SSPOLE. 
      REAL FUNCTION SSPOLE(MGMS,MUSQ,AS)
C*********************************************************************
C* Computes the on-shell (pole) gluino mass for given running (MSbar)*
C* gluino mass, defined at scale MUSQ, and given alpha_s (AS). The   *
C* squark masses are stored in the SQUARK COMMON block.              *
C* This function needs the complex functions B0 and B1.              *
C* Contributed by M. Drees; modified by H. Baer                      *
C                                                                    *
C  Version 7.30: Cast COMPLEX*16 to REAL*8 in standard way. :-(      *
C*********************************************************************
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
      REAL MGMS,MUSQ,AS,MGSQ,FAC
      DOUBLE PRECISION XLAM,DMUSQ,DFAC
      COMPLEX*16 SSB1
      COMMON /SSINF/ XLAM
      DMUSQ=MUSQ
      XLAM = LOG(DMUSQ)
      MGSQ = MGMS*MGMS
C
C          Cast COMPLEX*16 to REAL*8:
C
      DFAC = -8*SSB1(MGSQ,0.,AMULSS) - (SSB1(MGSQ,AMTP,AMT1SS)+
     $SSB1(MGSQ,AMTP,AMT2SS)+SSB1(MGSQ,4.0,AMB1SS)+
     $SSB1(MGSQ,4.0,AMB2SS))
      DFAC = DFAC + 12.D0 + 9.D0*LOG(DMUSQ/MGSQ)
      FAC=DFAC
      SSPOLE = MGMS*(1.0 + .0796*AS*FAC )
      RETURN
      END
CDECK  ID>, SSQKBF. 
        SUBROUTINE SSQKBF
C-----------------------------------------------------------------------
C
C        This program gives squark branching fractions to gauginos
C        according to Baer,Barger,Karatas,Tata (Phys.Rev.D36,96(1987)
C        Updated for b_1,b_2 and non-degenerate sq masses 8/13/96
C        Baer's SQUBF
C
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          MXSS                 = maximum number of modes
C          NSSMOD               = number of modes
C          ISSMOD               = initial particle
C          JSSMOD               = final particles
C          GSSMOD               = width
C          BSSMOD               = branching ratio
      INTEGER MXSS
      PARAMETER (MXSS=1000)
      COMMON/SSMODE/NSSMOD,ISSMOD(MXSS),JSSMOD(5,MXSS),GSSMOD(MXSS)
     $,BSSMOD(MXSS)
      INTEGER NSSMOD,ISSMOD,JSSMOD
      REAL GSSMOD,BSSMOD
      SAVE /SSMODE/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C
      COMPLEX ZI,ZONE,ZA,ZB,ZAUIZ,ZADIZ,ZBUIZ,ZBDIZ
      DOUBLE PRECISION SSALFS,SSMQCD
      REAL SSXLAM,WID,AUIZS,ADIZS,BUIZS,BDIZS
      REAL PI,SR2,G,GP,COSA,SINA,SNZI,THIZ
     $,TANB,COTB,XM,YM,THX,THY,FT,FB
      REAL MZIZ,CS2THW,TN2THW,BETA,BH,A,AS
      REAL ASMB,MBMB,MBQ,ASMT,MTMT,MTQ,SUALFS
      INTEGER IZ
      REAL MW1,MW2,SNW1,SNW2,COST,SINT,COSB,SINB
      REAL AWD(2),AWU(2),BW(2),BWP(2)
      INTEGER ISZIZ(4)
      DATA ZI/(0.,1.)/,ZONE/(1.,0.)/
C
C          Partly duplicated from SSMASS
C
      PI=4.*ATAN(1.)
      SR2=SQRT(2.)
      G=SQRT(4*PI*ALFAEM/SN2THW)
      GP=G*SQRT(SN2THW/(1.-SN2THW))
      CS2THW=1.-SN2THW
      TN2THW=SN2THW/CS2THW
      TANB=1./RV2V1
      COTB=RV2V1
      BETA=ATAN(TANB)
C          Reconstruct masses from SSMASS
      MW1=ABS(AMW1SS)
      MW2=ABS(AMW2SS)
      COST=COS(THETAT)
      SINT=SIN(THETAT)
      COSB=COS(THETAB)
      SINB=SIN(THETAB)
      COSA=COS(ALFAH)
      SINA=SIN(ALFAH)
      SNW1=SIGN(1.,AMW1SS)
      SNW2=SIGN(1.,AMW2SS)
      XM=1./TAN(GAMMAL)
      YM=1./TAN(GAMMAR)
      THX=SIGN(1.,XM)
      THY=SIGN(1.,YM)
      ASMB=SUALFS(AMBT**2,.36,AMTP,3)
      MBMB=AMBT*(1.-4*ASMB/3./PI)
      MBQ=SSMQCD(DBLE(MBMB),DBLE(AMULSS))
      ASMT=SUALFS(AMTP**2,.36,AMTP,3)
      MTMT=AMTP/(1.+4*ASMT/3./PI+(16.11-1.04*(5.-6.63/AMTP))*
     $(ASMT/PI)**2)
      MTQ=SSMQCD(DBLE(MTMT),DBLE(AMULSS))
      FB=G*MBQ/SR2/AMW/COS(BETA)
      FT=G*MTQ/SR2/AMW/SIN(BETA)
      AWD(1)=-G*SNW1*SIN(GAMMAR)
      AWD(2)=-G*SNW2*THY*COS(GAMMAR)
      AWU(1)=-G*SIN(GAMMAL)
      AWU(2)=-G*THX*COS(GAMMAL)
      BW(1)=-FT*SNW1*COS(GAMMAR)
      BW(2)=FT*SNW2*THY*SIN(GAMMAR)
      BWP(1)=-FB*COS(GAMMAL)
      BWP(2)=FB*THX*SIN(GAMMAL)
C
C          Compute squark branching fractions to zi
C
      ISZIZ(1)=ISZ1
      ISZIZ(2)=ISZ2
      ISZIZ(3)=ISZ3
      ISZIZ(4)=ISZ4
      DO 100 IZ=1,4
        MZIZ=ABS(AMZISS(IZ))
        SNZI=SIGN(1.,AMZISS(IZ))
        IF (SNZI.EQ.1.) THEN
           THIZ=0.
        ELSE
           THIZ=1.
        END IF
        ZAUIZ=ZI**(THIZ-1.)*(-1)*SNZI
     $  *(G/SR2*ZMIXSS(3,IZ)+GP/3./SR2*ZMIXSS(4,IZ))
        ZBUIZ=ZI**(THIZ-1.)*4*GP*ZMIXSS(4,IZ)/3./SR2
        ZADIZ=ZI**(THIZ-1.)*(-1)*SNZI
     $  *(-G/SR2*ZMIXSS(3,IZ)+GP/3./SR2*ZMIXSS(4,IZ))
        ZBDIZ=ZI**(THIZ-1.)*(-2)*GP*ZMIXSS(4,IZ)/3./SR2
        AUIZS=ZAUIZ*CONJG(ZAUIZ)
        ADIZS=ZADIZ*CONJG(ZADIZ)
        BUIZS=ZBUIZ*CONJG(ZBUIZ)
        BDIZS=ZBDIZ*CONJG(ZBDIZ)
C          squark --> q + qb + zi, q = u, d, s
        IF (AMULSS.GT.MZIZ) THEN
          WID=AUIZS*AMULSS*(1.-MZIZ**2/AMULSS**2)**2/16./PI
          CALL SSSAVE(ISUPL,WID,ISZIZ(IZ),IDUP,0,0,0)
        END IF
        IF (AMDLSS.GT.MZIZ) THEN
          WID=ADIZS*AMDLSS*(1.-MZIZ**2/AMDLSS**2)**2/16./PI
          CALL SSSAVE(ISDNL,WID,ISZIZ(IZ),IDDN,0,0,0)
        END IF
        IF (AMSLSS.GT.MZIZ) THEN
          WID=ADIZS*AMSLSS*(1.-MZIZ**2/AMSLSS**2)**2/16./PI
          CALL SSSAVE(ISSTL,WID,ISZIZ(IZ),IDST,0,0,0)
        END IF
        IF (AMURSS.GT.MZIZ) THEN
          WID=BUIZS*AMURSS*(1.-MZIZ**2/AMURSS**2)**2/16./PI
          CALL SSSAVE(ISUPR,WID,ISZIZ(IZ),IDUP,0,0,0)
        END IF
        IF (AMDRSS.GT.MZIZ) THEN
          WID=BDIZS*AMDRSS*(1.-MZIZ**2/AMDRSS**2)**2/16./PI
          CALL SSSAVE(ISDNR,WID,ISZIZ(IZ),IDDN,0,0,0)
        END IF
        IF (AMSRSS.GT.MZIZ) THEN
          WID=BDIZS*AMSRSS*(1.-MZIZ**2/AMSRSS**2)**2/16./PI
          CALL SSSAVE(ISSTR,WID,ISZIZ(IZ),IDST,0,0,0)
        END IF
C          squark --> q + zi, q = c
        IF (AMCLSS.GT.(MZIZ+AMCH)) THEN
          WID=AUIZS*AMCLSS*(1.-MZIZ**2/AMCLSS**2-AMCH**2/AMCLSS**2)
     $    *SQRT(SSXLAM(1.,MZIZ**2/AMCLSS**2,AMCH**2/AMCLSS**2))/16./PI
          CALL SSSAVE(ISCHL,WID,ISZIZ(IZ),IDCH,0,0,0)
        END IF
        IF (AMCRSS.GT.(MZIZ+AMCH)) THEN
          WID=BUIZS*AMCRSS*(1.-MZIZ**2/AMCRSS**2-AMCH**2/AMCRSS**2)
     $    *SQRT(SSXLAM(1.,MZIZ**2/AMCRSS**2,AMCH**2/AMCRSS**2))/16./PI
          CALL SSSAVE(ISCHR,WID,ISZIZ(IZ),IDCH,0,0,0)
        END IF
C          sbottom_1 --> b + zi
        IF (AMB1SS.GT.(MZIZ+AMBT)) THEN
          ZA=(ZI*ZADIZ-FB*ZMIXSS(2,IZ)*ZI**THIZ)*COSB/2.-
     $       (ZI*ZBDIZ-FB*ZMIXSS(2,IZ)*(-ZI)**THIZ)*SINB/2.
          ZB=(-ZI*ZADIZ-FB*ZMIXSS(2,IZ)*ZI**THIZ)*COSB/2.-
     $       (ZI*ZBDIZ+FB*ZMIXSS(2,IZ)*(-ZI)**THIZ)*SINB/2.
          WID=(ZA*CONJG(ZA)*(AMB1SS**2-(AMBT+MZIZ)**2)+
     $     ZB*CONJG(ZB)*(AMB1SS**2-(MZIZ-AMBT)**2))/8./PI/AMB1SS
     $    *SQRT(SSXLAM(1.,MZIZ**2/AMB1SS**2,AMBT**2/AMB1SS**2))
          CALL SSSAVE(ISBT1,WID,ISZIZ(IZ),IDBT,0,0,0)
        END IF
C          sbottom_2 --> b + zi
        IF (AMB2SS.GT.(MZIZ+AMBT)) THEN
          ZA=(ZI*ZADIZ-FB*ZMIXSS(2,IZ)*ZI**THIZ)*SINB/2.+
     $       (ZI*ZBDIZ-FB*ZMIXSS(2,IZ)*(-ZI)**THIZ)*COSB/2.
          ZB=(-ZI*ZADIZ-FB*ZMIXSS(2,IZ)*ZI**THIZ)*SINB/2.+
     $       (ZI*ZBDIZ+FB*ZMIXSS(2,IZ)*(-ZI)**THIZ)*COSB/2.
          WID=(ZA*CONJG(ZA)*(AMB2SS**2-(AMBT+MZIZ)**2)+
     $     ZB*CONJG(ZB)*(AMB2SS**2-(MZIZ-AMBT)**2))/8./PI/AMB2SS
     $    *SQRT(SSXLAM(1.,MZIZ**2/AMB2SS**2,AMBT**2/AMB2SS**2))
          CALL SSSAVE(ISBT2,WID,ISZIZ(IZ),IDBT,0,0,0)
        END IF
100   CONTINUE
C
C          Compute squark branching fractions to gluinos
C
      IF (AMULSS.GT.AMGLSS) THEN
        WID=2*SSALFS(DBLE(AMULSS**2))*AMULSS*
     $  (1.-AMGLSS**2/AMULSS**2)**2/3.
        CALL SSSAVE(ISUPL,WID,ISGL,IDUP,0,0,0)
      END IF
      IF (AMDLSS.GT.AMGLSS) THEN
        WID=2*SSALFS(DBLE(AMDLSS**2))*AMDLSS*
     $  (1.-AMGLSS**2/AMDLSS**2)**2/3.
        CALL SSSAVE(ISDNL,WID,ISGL,IDDN,0,0,0)
      END IF
      IF (AMSLSS.GT.AMGLSS) THEN
        WID=2*SSALFS(DBLE(AMSLSS**2))*AMSLSS*
     $  (1.-AMGLSS**2/AMSLSS**2)**2/3.
        CALL SSSAVE(ISSTL,WID,ISGL,IDST,0,0,0)
      END IF
      IF (AMURSS.GT.AMGLSS) THEN
        WID=2*SSALFS(DBLE(AMURSS**2))*AMURSS*
     $  (1.-AMGLSS**2/AMURSS**2)**2/3.
        CALL SSSAVE(ISUPR,WID,ISGL,IDUP,0,0,0)
      END IF
      IF (AMDRSS.GT.AMGLSS) THEN
        WID=2*SSALFS(DBLE(AMDRSS**2))*AMDRSS*
     $  (1.-AMGLSS**2/AMDRSS**2)**2/3.
        CALL SSSAVE(ISDNR,WID,ISGL,IDDN,0,0,0)
      END IF
      IF (AMSRSS.GT.AMGLSS) THEN
        WID=2*SSALFS(DBLE(AMSRSS**2))*AMSRSS*
     $  (1.-AMGLSS**2/AMSRSS**2)**2/3.
        CALL SSSAVE(ISSTR,WID,ISGL,IDST,0,0,0)
      END IF
C
      IF (AMCLSS.GT.(AMGLSS+AMCH)) THEN
        WID=2*SSALFS(DBLE(AMCLSS**2))*AMCLSS*(1.-AMGLSS**2/AMCLSS**2-
     $  AMCH**2/AMCLSS**2)*SQRT(SSXLAM(1.,AMGLSS**2/AMCLSS**2,
     $  AMCH**2/AMCLSS**2))/3.
        CALL SSSAVE(ISCHL,WID,ISGL,IDCH,0,0,0)
      END IF
      IF (AMCRSS.GT.(AMGLSS+AMCH)) THEN
        WID=2*SSALFS(DBLE(AMCRSS**2))*AMCRSS*(1.-AMGLSS**2/AMCRSS**2-
     $  AMCH**2/AMCRSS**2)*SQRT(SSXLAM(1.,AMGLSS**2/AMCRSS**2,
     $  AMCH**2/AMCRSS**2))/3.
        CALL SSSAVE(ISCHR,WID,ISGL,IDCH,0,0,0)
      END IF
C
      IF (AMB1SS.GT.(AMGLSS+AMBT)) THEN
        WID=2*SSALFS(DBLE(AMB1SS**2))*AMB1SS*(1.-AMGLSS**2/AMB1SS**2-
     $  AMBT**2/AMB1SS**2)*SQRT(SSXLAM(1.,AMGLSS**2/AMB1SS**2,
     $  AMBT**2/AMB1SS**2))/3.
        CALL SSSAVE(ISBT1,WID,ISGL,IDBT,0,0,0)
      END IF
C
      IF (AMB2SS.GT.(AMGLSS+AMBT)) THEN
        WID=2*SSALFS(DBLE(AMB2SS**2))*AMB2SS*(1.-AMGLSS**2/AMB2SS**2-
     $  AMBT**2/AMB2SS**2)*SQRT(SSXLAM(1.,AMGLSS**2/AMB2SS**2,
     $  AMBT**2/AMB2SS**2))/3.
        CALL SSSAVE(ISBT2,WID,ISGL,IDBT,0,0,0)
      END IF
C
C           Compute branching fractions to wi --- theta-C = 0
C
      IF (AMULSS.GT.MW1) THEN
        WID=G**2*SIN(GAMMAR)**2*AMULSS*(1.-MW1**2/AMULSS**2)**2/16./PI
        CALL SSSAVE(ISUPL,WID,ISW1,IDDN,0,0,0)
      END IF
      IF (AMCLSS.GT.MW1) THEN
        WID=G**2*SIN(GAMMAR)**2*AMCLSS*(1.-MW1**2/AMCLSS**2)**2/16./PI
        CALL SSSAVE(ISCHL,WID,ISW1,IDST,0,0,0)
      END IF
      IF (AMDLSS.GT.MW1) THEN
        WID=G**2*SIN(GAMMAL)**2*AMDLSS*(1.-MW1**2/AMDLSS**2)**2/16./PI
        CALL SSSAVE(ISDNL,WID,-ISW1,IDUP,0,0,0)
      END IF
C
      IF (AMSLSS.GT.(MW1+AMCH)) THEN
        WID=G**2*SIN(GAMMAL)**2*AMSLSS*(1.-MW1**2/AMSLSS**2
     $  -AMCH**2/AMSLSS**2)
     $  *SQRT(SSXLAM(1.,MW1**2/AMSLSS**2,AMCH**2/AMSLSS**2))/16./PI
        CALL SSSAVE(ISSTL,WID,-ISW1,IDCH,0,0,0)
      ENDIF
C
       IF (AMB1SS.GT.(MW1+AMTP)) THEN
         A=AWU(1)*COSB-BWP(1)*SINB
         AS=A*A
         WID=AMB1SS*((AS+BW(1)**2*COSB**2)*(1.-MW1**2/AMB1SS**2
     $  -AMTP**2/AMB1SS**2)-4*AMTP*MW1*BW(1)*A*COSB/AMB1SS**2)
     $   *SQRT(SSXLAM(1.,MW1**2/AMB1SS**2,AMTP**2/AMB1SS**2))/16./PI
        CALL SSSAVE(ISBT1,WID,-ISW1,IDTP,0,0,0)
      ENDIF
C
       IF (AMB2SS.GT.(MW1+AMTP)) THEN
         A=AWU(1)*SINB+BWP(1)*COSB
         AS=A*A
         WID=AMB2SS*((AS+BW(1)**2*SINB**2)*(1.-MW1**2/AMB2SS**2
     $  -AMTP**2/AMB2SS**2)-4*AMTP*MW1*BW(1)*A*SINB/AMB2SS**2)
     $   *SQRT(SSXLAM(1.,MW1**2/AMB2SS**2,AMTP**2/AMB2SS**2))/16./PI
        CALL SSSAVE(ISBT2,WID,-ISW1,IDTP,0,0,0)
      ENDIF
C
      IF (AMULSS.GT.MW2) THEN
        WID=G**2*COS(GAMMAR)**2*AMULSS*(1.-MW2**2/AMULSS**2)**2/16./PI
        CALL SSSAVE(ISUPL,WID,ISW2,IDDN,0,0,0)
      END IF
      IF (AMCLSS.GT.MW2) THEN
        WID=G**2*COS(GAMMAR)**2*AMCLSS*(1.-MW2**2/AMCLSS**2)**2/16./PI
        CALL SSSAVE(ISCHL,WID,ISW2,IDST,0,0,0)
      END IF
      IF (AMDLSS.GT.MW2) THEN
        WID=G**2*COS(GAMMAL)**2*AMDLSS*(1.-MW2**2/AMDLSS**2)**2/16./PI
        CALL SSSAVE(ISDNL,WID,-ISW2,IDUP,0,0,0)
      END IF
C
      IF (AMSLSS.GT.(MW2+AMCH)) THEN
        WID=G**2*COS(GAMMAL)**2*AMSLSS*(1.-MW2**2/AMSLSS**2
     $  -AMCH**2/AMSLSS**2)
     $  *SQRT(SSXLAM(1.,MW2**2/AMSLSS**2,AMCH**2/AMSLSS**2))/16./PI
        CALL SSSAVE(ISSTL,WID,-ISW2,IDCH,0,0,0)
      ENDIF
C
      IF (AMB1SS.GT.(MW2+AMTP)) THEN
         A=AWU(2)*COSB-BWP(2)*SINB
         AS=A*A
         WID=AMB1SS*((AS+BW(2)**2*COSB**2)*(1.-MW2**2/AMB1SS**2
     $  -AMTP**2/AMB1SS**2)-4*AMTP*MW2*BW(2)*A*COSB/AMB1SS**2)
     $   *SQRT(SSXLAM(1.,MW2**2/AMB1SS**2,AMTP**2/AMB1SS**2))/16./PI
        CALL SSSAVE(ISBT1,WID,-ISW2,IDTP,0,0,0)
      ENDIF
C
      IF (AMB2SS.GT.(MW2+AMTP)) THEN
         A=AWU(2)*SINB+BWP(2)*COSB
         AS=A*A
         WID=AMB2SS*((AS+BW(2)**2*SINB**2)*(1.-MW2**2/AMB2SS**2
     $  -AMTP**2/AMB2SS**2)-4*AMTP*MW2*BW(2)*A*SINB/AMB2SS**2)
     $   *SQRT(SSXLAM(1.,MW2**2/AMB2SS**2,AMTP**2/AMB2SS**2))/16./PI
        CALL SSSAVE(ISBT2,WID,-ISW2,IDTP,0,0,0)
      ENDIF
C
      IF (AMB1SS.GT.(AMW+AMT1SS)) THEN
        WID=G**2*COST**2*COSB**2*(SSXLAM(AMB1SS**2,AMW**2,
     $   AMT1SS**2))**1.5/32./PI/AMB1SS**3/AMW**2
        CALL SSSAVE(ISBT1,WID,-IDW,ISTP1,0,0,0)
      ENDIF
C
      IF (AMB1SS.GT.(AMW+AMT2SS)) THEN
        WID=G**2*SINT**2*COSB**2*(SSXLAM(AMB1SS**2,AMW**2,
     $   AMT2SS**2))**1.5/32./PI/AMB1SS**3/AMW**2
        CALL SSSAVE(ISBT1,WID,-IDW,ISTP2,0,0,0)
      ENDIF
C
      IF (AMB2SS.GT.(AMW+AMT1SS)) THEN
        WID=G**2*COST**2*SINB**2*(SSXLAM(AMB2SS**2,AMW**2,
     $   AMT1SS**2))**1.5/32./PI/AMB2SS**3/AMW**2
        CALL SSSAVE(ISBT2,WID,-IDW,ISTP1,0,0,0)
      ENDIF
C
      IF (AMB2SS.GT.(AMW+AMT2SS)) THEN
        WID=G**2*SINT**2*SINB**2*(SSXLAM(AMB2SS**2,AMW**2,
     $   AMT2SS**2))**1.5/32./PI/AMB2SS**3/AMW**2
        CALL SSSAVE(ISBT2,WID,-IDW,ISTP1,0,0,0)
      ENDIF
C
      IF (AMB2SS.GT.(AMZ+AMB1SS)) THEN
        WID=G**2*COSB**2*SINB**2*(SSXLAM(AMB2SS**2,AMZ**2,
     $   AMB1SS**2))**1.5/64./PI/AMB2SS**3/AMZ**2/CS2THW
        CALL SSSAVE(ISBT2,WID,IDZ,ISBT1,0,0,0)
      ENDIF
C
      IF (AMB2SS.GT.(AMHL+AMB1SS)) THEN
        BH=G*AMW*SIN(BETA-ALFAH)*(-1.+TN2THW/3.)*SINB*COSB/2.+G*
     $  AMBT*(TWOM1*COSA+AAB*SINA)*COS(2*THETAB)/2./AMW/COS(BETA)
        WID=BH**2*SQRT(SSXLAM(AMB2SS**2,AMHL**2,AMB1SS**2))/
     $      16./PI/AMB2SS**3
        CALL SSSAVE(ISBT2,WID,ISHL,ISBT1,0,0,0)
      ENDIF
C
      IF (AMB2SS.GT.(AMHA+AMB1SS)) THEN
        BH=G*AMBT*(TWOM1-AAB*TANB)/2./AMW
        WID=BH**2*SQRT(SSXLAM(AMB2SS**2,AMHA**2,AMB1SS**2))/
     $      16./PI/AMB2SS**3
        CALL SSSAVE(ISBT2,WID,ISHA,ISBT1,0,0,0)
      ENDIF
C
      IF (AMB2SS.GT.(AMHH+AMB1SS)) THEN
        BH=-G*AMW*COS(BETA-ALFAH)*(-1.+TN2THW/3.)*SINB*COSB/2.+G*
     $  AMBT*(-TWOM1*SINA+AAB*COSA)*COS(2*THETAB)/2./AMW/COS(BETA)
        WID=BH**2*SQRT(SSXLAM(AMB2SS**2,AMHH**2,AMB1SS**2))/
     $      16./PI/AMB2SS**3
        CALL SSSAVE(ISBT2,WID,ISHH,ISBT1,0,0,0)
      ENDIF
C
C     b_i -> H^- t_i
C
      IF (AMB1SS.GT.(AMT1SS+AMHC)) THEN
        A=G/SR2/AMW*(AMTP*AMBT*(COTB+TANB)*SINT*SINB+
     $(AMBT**2*TANB+AMTP**2*COTB-AMW**2*SIN(2*BETA))*
     $COST*COSB-AMTP*(TWOM1-AAT*COTB)*SINT*COSB-AMBT*
     $(TWOM1-AAB*TANB)*SINB*COST)
        AS=A*A
        WID=AS*SQRT(SSXLAM(AMB1SS**2,AMT1SS**2,AMHC**2))/
     $      16./PI/AMB1SS**3
        CALL SSSAVE(ISBT1,WID,-ISHC,ISTP1,0,0,0)
      END IF
C
      IF (AMB1SS.GT.(AMT2SS+AMHC)) THEN
        A=G/SR2/AMW*(-AMTP*AMBT*(COTB+TANB)*COST*SINT+
     $(AMBT**2*TANB+AMTP**2*COTB-AMW**2*SIN(2*BETA))*
     $SINT*COSB+AMTP*(TWOM1-AAT*COTB)*COST*COSB-AMBT*
     $(TWOM1-AAB*TANB)*SINT*SINB)
        AS=A*A
        WID=AS*SQRT(SSXLAM(AMB1SS**2,AMT2SS**2,AMHC**2))/
     $      16./PI/AMB1SS**3
        CALL SSSAVE(ISBT1,WID,-ISHC,ISTP2,0,0,0)
      END IF
C
      IF (AMB2SS.GT.(AMT1SS+AMHC)) THEN
        A=G/SR2/AMW*(-AMTP*AMBT*(COTB+TANB)*SINT*COSB+
     $(AMBT**2*TANB+AMTP**2*COTB-AMW**2*SIN(2*BETA))*
     $COST*SINB-AMTP*(TWOM1-AAT*COTB)*SINT*SINB+AMBT*
     $(TWOM1-AAB*TANB)*COST*COSB)
        AS=A*A
        WID=AS*SQRT(SSXLAM(AMB2SS**2,AMT1SS**2,AMHC**2))/
     $      16./PI/AMB2SS**3
        CALL SSSAVE(ISBT2,WID,-ISHC,ISTP1,0,0,0)
      END IF
C
      IF (AMB2SS.GT.(AMT2SS+AMHC)) THEN
        A=G/SR2/AMW*(AMTP*AMBT*(COTB+TANB)*COST*COSB+
     $(AMBT**2*TANB+AMTP**2*COTB-AMW**2*SIN(2*BETA))*
     $SINT*SINB+AMTP*(TWOM1-AAT*COTB)*SINB*COST+AMBT*
     $(TWOM1-AAB*TANB)*COSB*SINT)
        AS=A*A
        WID=AS*SQRT(SSXLAM(AMB2SS**2,AMT2SS**2,AMHC**2))/
     $      16./PI/AMB2SS**3
        CALL SSSAVE(ISBT2,WID,-ISHC,ISTP2,0,0,0)
      END IF
C
C          Normalize branching ratios
C
      CALL SSNORM(ISUPL)
      CALL SSNORM(ISDNL)
      CALL SSNORM(ISSTL)
      CALL SSNORM(ISCHL)
      CALL SSNORM(ISBT1)
      CALL SSNORM(ISUPR)
      CALL SSNORM(ISDNR)
      CALL SSNORM(ISSTR)
      CALL SSNORM(ISCHR)
      CALL SSNORM(ISBT2)
C
       RETURN
       END
CDECK  ID>, SSSAVE. 
      SUBROUTINE SSSAVE(IIN,GAM,IOUT1,IOUT2,IOUT3,IOUT4,IOUT5)
C-----------------------------------------------------------------------
C     Store a SUSY decay mode in /SSMODE/
C     Ver 7.14: Increment NSSMOD only after test
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          MXSS                 = maximum number of modes
C          NSSMOD               = number of modes
C          ISSMOD               = initial particle
C          JSSMOD               = final particles
C          GSSMOD               = width
C          BSSMOD               = branching ratio
      INTEGER MXSS
      PARAMETER (MXSS=1000)
      COMMON/SSMODE/NSSMOD,ISSMOD(MXSS),JSSMOD(5,MXSS),GSSMOD(MXSS)
     $,BSSMOD(MXSS)
      INTEGER NSSMOD,ISSMOD,JSSMOD
      REAL GSSMOD,BSSMOD
      SAVE /SSMODE/
      INTEGER IIN,IOUT1,IOUT2,IOUT3,IOUT4,IOUT5,I
      REAL GAM
C
      IF (GAM.EQ.0.) GO TO 999
      IF(GAM.LE.0.) THEN
        WRITE(LOUT,1000) IIN,IOUT1,IOUT2,IOUT3,IOUT4,IOUT5,GAM
1000    FORMAT(' WARNING: SSSAVE: ',I5,' --> ',5I5,E14.5)
        GO TO 999
      ENDIF
      NSSMOD=NSSMOD+1
      IF(NSSMOD.GT.MXSS) THEN
        WRITE(LOUT,*) 'SSSAVE: TOO MANY MODES, IIN = ',IIN
        STOP99
      ENDIF
      ISSMOD(NSSMOD)=IIN
      JSSMOD(1,NSSMOD)=IOUT1
      JSSMOD(2,NSSMOD)=IOUT2
      JSSMOD(3,NSSMOD)=IOUT3
      JSSMOD(4,NSSMOD)=IOUT4
      JSSMOD(5,NSSMOD)=IOUT5
      GSSMOD(NSSMOD)=GAM
      BSSMOD(NSSMOD)=0.
C          Check that quarks and gluons appear at end of list.
      DO 100 I=1,4
        IF(IABS(JSSMOD(I,NSSMOD)).LE.9.AND.
     $  IABS(JSSMOD(I+1,NSSMOD)).GT.9) THEN
          WRITE(LOUT,1100) IIN,IOUT1,IOUT2,IOUT3,IOUT4,IOUT5
1100      FORMAT(' WARNING: SSSAVE: BAD ORDER: ',I5,' --> ',5I5)
          STOP99
        ENDIF
100   CONTINUE
C
999   RETURN
      END
CDECK  ID>, SSSTBF. 
        SUBROUTINE SSSTBF
C-----------------------------------------------------------------------
C
C        This program gives stop squark branching fractions to gauginos
C        according to Baer and Tata.
C        If no other modes are allowed, stop -> c z_i through loops is
C        used as the default.
C
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          MXSS                 = maximum number of modes
C          NSSMOD               = number of modes
C          ISSMOD               = initial particle
C          JSSMOD               = final particles
C          GSSMOD               = width
C          BSSMOD               = branching ratio
      INTEGER MXSS
      PARAMETER (MXSS=1000)
      COMMON/SSMODE/NSSMOD,ISSMOD(MXSS),JSSMOD(5,MXSS),GSSMOD(MXSS)
     $,BSSMOD(MXSS)
      INTEGER NSSMOD,ISSMOD,JSSMOD
      REAL GSSMOD,BSSMOD
      SAVE /SSMODE/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C
      COMPLEX ZI,ZONE,ZA,ZB,ZPP,ZPM,ZAUIZ,ZBUIZ
      DOUBLE PRECISION SSALFS,SSMQCD
      REAL SSXLAM
      REAL WID,AWD(2),BW(2),FB,FT,XM,YM,THX,THY,AU1,MZ1,WIDC1
      REAL PI,SR2,G,GP,TANB,COTB,MPL,MMI,AH
      REAL AUIZ,MZIZ,SINT,COST,AS,BS,SNZI,THIZ
      INTEGER IZ,ISTOP,IDSTOP
      REAL AMSTOP,BWP(2),A
      REAL MW1,MW2,SNW1,SNW2,CS2THW,BETA,TN2THW,SINB,COSB
      REAL ASMB,MBMB,MBQ,ASMT,MTMT,MTQ,SUALFS
      INTEGER ISZIZ(4)
      DATA ZONE/(1.,0.)/,ZI/(0.,1.)/
C
C          Partly duplicated from SSMASS
C
      CS2THW=1.-SN2THW
      TN2THW=SN2THW/CS2THW
      PI=4.*ATAN(1.)
      SR2=SQRT(2.)
      G=SQRT(4*PI*ALFAEM/SN2THW)
      GP=G*SQRT(SN2THW/(1.-SN2THW))
      TANB=1./RV2V1
      COTB=RV2V1
      BETA=ATAN(TANB)
C          Reconstruct masses from SSMASS
      ASMB=SUALFS(AMBT**2,.36,AMTP,3)
      MBMB=AMBT*(1.-4*ASMB/3./PI)
      MBQ=SSMQCD(DBLE(MBMB),DBLE(AMT1SS))
      ASMT=SUALFS(AMTP**2,.36,AMTP,3)
      MTMT=AMTP/(1.+4*ASMT/3./PI+(16.11-1.04*(5.-6.63/AMTP))*
     $(ASMT/PI)**2)
      MTQ=SSMQCD(DBLE(MTMT),DBLE(AMT1SS))
      FB=G*MBQ/SR2/AMW/COS(BETA)
      FT=G*MTQ/SR2/AMW/SIN(BETA)
      MW1=ABS(AMW1SS)
      MW2=ABS(AMW2SS)
      SNW1=SIGN(1.,AMW1SS)
      SNW2=SIGN(1.,AMW2SS)
      XM=1./TAN(GAMMAL)
      YM=1./TAN(GAMMAR)
      THX=SIGN(1.,XM)
      THY=SIGN(1.,YM)
C
      AWD(1)=-G*SNW1*SIN(GAMMAR)
      AWD(2)=-G*SNW2*THY*COS(GAMMAR)
      BW(1)=-FT*SNW1*COS(GAMMAR)
      BW(2)=FT*SNW2*THY*SIN(GAMMAR)
      BWP(1)=-FB*COS(GAMMAL)
      BWP(2)=FB*THX*SIN(GAMMAL)
      MMI=AMW1SS
      MPL=AMW2SS
      COST=COS(THETAT)
      SINT=SIN(THETAT)
      COSB=COS(THETAB)
      SINB=SIN(THETAB)
C
C          Compute stop_i branching fractions to charm + zi if no other
C          modes are allowed. WIDC1 is an unknown amplitude arbitrarily
C          set equal to 1.0.
C
      ISZIZ(1)=ISZ1
      ISZIZ(2)=ISZ2
      ISZIZ(3)=ISZ3
      ISZIZ(4)=ISZ4
      AU1=-G/SR2*ZMIXSS(3,1)-GP/3./SR2*ZMIXSS(4,1)
      MZ1=ABS(AMZISS(1))
      DO 100 ISTOP=1,2
        IF(ISTOP.EQ.1) THEN
          AMSTOP=AMT1SS
          IDSTOP=ISTP1
          WIDC1=1.
        ELSE
          AMSTOP=AMT2SS
          IDSTOP=ISTP2
          WIDC1=1.
        ENDIF
        IF(AMSTOP.LT.(MW1+AMBT).AND.AMSTOP.GT.(AMCH+MZ1)) THEN
          DO 110 IZ=1,4
            MZIZ=ABS(AMZISS(IZ))
            AUIZ=-G/SR2*ZMIXSS(3,IZ)-GP/3./SR2*ZMIXSS(4,IZ)
            IF (AMT1SS.GT.(AMCH+MZIZ)) THEN
              WID=AUIZ**2*(AMSTOP**2-MZIZ**2)/AU1**2
     $        /(AMSTOP**2-MZ1**2)*WIDC1
              CALL SSSAVE(IDSTOP,WID,ISZIZ(IZ),IDCH,0,0,0)
            END IF
110       CONTINUE
        ELSEIF(AMSTOP.LT.(MW1+AMBT).AND.AMSTOP.LE.(AMCH+MZ1)) THEN
          WRITE(LOUT,1000) ISTOP
1000      FORMAT(' ERROR IN SSSTBF: NO ALLOWED MODE FOR STOP',I2)
        END IF
100   CONTINUE
C
C          stop_i -> gluino + top
C
      IF (AMT1SS.GT.(AMGLSS+AMTP)) THEN
        WID=2*SSALFS(DBLE(AMT1SS**2))*AMT1SS*((1.-AMGLSS**2/AMT1SS**2-
     $  AMTP**2/AMT1SS**2)-2*SIN(2*THETAT)*AMTP*AMGLSS/AMT1SS**2)
     $  *SQRT(SSXLAM(1.,AMGLSS**2/AMT1SS**2,AMTP**2/AMT1SS**2))/3.
        CALL SSSAVE(ISTP1,WID,ISGL,IDTP,0,0,0)
      END IF
C
      IF (AMT2SS.GT.(AMGLSS+AMTP)) THEN
        WID=2*SSALFS(DBLE(AMT2SS**2))*AMT2SS*((1.-AMGLSS**2/AMT2SS**2-
     $  AMTP**2/AMT2SS**2)+2*SIN(2*THETAT)*AMTP*AMGLSS/AMT2SS**2)
     $  *SQRT(SSXLAM(1.,AMGLSS**2/AMT2SS**2,AMTP**2/AMT2SS**2))/3.
        CALL SSSAVE(ISTP2,WID,ISGL,IDTP,0,0,0)
      END IF
C
C          stop_1 -> top + zino_i
C
      DO 200 IZ=1,4
        MZIZ=ABS(AMZISS(IZ))
        SNZI=SIGN(1.,AMZISS(IZ))
        IF (SNZI.EQ.1.) THEN
           THIZ=0.
        ELSE
           THIZ=1.
        END IF
        ZAUIZ=ZI**(THIZ-1.)*SNZI
     $  *(-G/SR2*ZMIXSS(3,IZ)-GP/3./SR2*ZMIXSS(4,IZ))
        ZBUIZ=ZI**(THIZ-1.)*4*GP*ZMIXSS(4,IZ)/3./SR2
        ZPP=ZI**THIZ
        ZPM=(-ZI)**THIZ
        ZA=((ZI*ZAUIZ-ZPP*FT*ZMIXSS(1,IZ))*COST
     $  -(ZI*ZBUIZ-ZPM*FT*ZMIXSS(1,IZ))*SINT)/2.
        ZB=((-ZI*ZAUIZ-ZPP*FT*ZMIXSS(1,IZ))*COST
     $  -(ZI*ZBUIZ+ZPM*FT*ZMIXSS(1,IZ))*SINT)/2.
        AS=ZA*CONJG(ZA)
        BS=ZB*CONJG(ZB)
        IF (AMT1SS.GT.(AMTP+MZIZ)) THEN
          WID=(AS*(AMT1SS**2-(AMTP+MZIZ)**2)+BS
     $    *(AMT1SS**2-(AMTP-MZIZ)**2))/8./PI/AMT1SS
     $    *SQRT(SSXLAM(1.,AMTP**2/AMT1SS**2,MZIZ**2/AMT1SS**2))
          CALL SSSAVE(ISTP1,WID,ISZIZ(IZ),IDTP,0,0,0)
        END IF
200   CONTINUE
C
C          Wino decays
C
      IF (AMT1SS.GT.(AMBT+MW1)) THEN
        A=AWD(1)*COST-BW(1)*SINT
        AS=A*A
        WID=AMT1SS*((AS+BWP(1)**2*COST**2)*(1.-MW1**2/AMT1SS**2-
     $   AMBT**2/AMT1SS**2)-4*MW1*AMBT*BWP(1)*COST*A/AMT1SS**2)
     $   *SQRT(SSXLAM(1.,MW1**2/AMT1SS**2,AMBT**2/AMT1SS**2))/16./PI
        CALL SSSAVE(ISTP1,WID,ISW1,IDBT,0,0,0)
      END IF
      IF (AMT1SS.GT.(AMBT+MW2)) THEN
        A=AWD(2)*COST-BW(2)*SINT
        AS=A*A
        WID=AMT1SS*((AS+BWP(2)**2*COST**2)*(1.-MW2**2/AMT1SS**2-
     $   AMBT**2/AMT1SS**2)-4*MW2*AMBT*BWP(2)*COST*A/AMT1SS**2)
     $   *SQRT(SSXLAM(1.,MW2**2/AMT1SS**2,AMBT**2/AMT1SS**2))/16./PI
        CALL SSSAVE(ISTP1,WID,ISW2,IDBT,0,0,0)
      END IF
C
      IF (AMT2SS.GT.(AMBT+MW1)) THEN
        A=AWD(1)*SINT+BW(1)*COST
        AS=A*A
        WID=AMT2SS*((AS+BWP(1)**2*SINT**2)*(1.-MW1**2/AMT2SS**2-
     $   AMBT**2/AMT2SS**2)-4*MW1*AMBT*BWP(1)*SINT*A/AMT2SS**2)
     $   *SQRT(SSXLAM(1.,MW1**2/AMT2SS**2,AMBT**2/AMT2SS**2))/16./PI
        CALL SSSAVE(ISTP2,WID,ISW1,IDBT,0,0,0)
      END IF
      IF (AMT2SS.GT.(AMBT+MW2)) THEN
        A=AWD(2)*SINT+BW(2)*COST
        AS=A*A
        WID=AMT2SS*((AS+BWP(2)**2*SINT**2)*(1.-MW2**2/AMT2SS**2-
     $   AMBT**2/AMT2SS**2)-4*MW2*AMBT*BWP(2)*SINT*A/AMT2SS**2)
     $  *SQRT(SSXLAM(1.,MW2**2/AMT2SS**2,AMBT**2/AMT2SS**2))/16./PI
        CALL SSSAVE(ISTP2,WID,ISW2,IDBT,0,0,0)
      END IF
C
C          stop_2 -> stop_1 + X modes
C
      IF (AMT2SS.GT.(AMT1SS+AMZ)) THEN
        WID=G**2*COST**2*SINT**2
     $  *(SQRT(SSXLAM(AMT2SS**2,AMZ**2,AMT1SS**2)))**3
     $  /64./PI/CS2THW/AMT2SS**3/AMZ**2
        CALL SSSAVE(ISTP2,WID,IDZ,ISTP1,0,0,0)
      END IF
C
      IF (AMT2SS.GT.(AMT1SS+AMHL)) THEN
        AH=G*AMW*SIN(BETA-ALFAH)*(1.-5.*TN2THW/3.)*SINT*COST/2.
     $  +G*AMTP*COS(2.*THETAT)*(TWOM1*SIN(ALFAH)+AAT*COS(ALFAH))/2.
     $  /AMW/SIN(BETA)
        WID=AH**2/16./PI/AMT2SS**3
     $  *SQRT(SSXLAM(AMT2SS**2,AMHL**2,AMT1SS**2))
        CALL SSSAVE(ISTP2,WID,ISHL,ISTP1,0,0,0)
      END IF
C
      IF (AMT2SS.GT.(AMT1SS+AMHH)) THEN
        AH=-G*AMW*COS(BETA-ALFAH)*(1.-5.*TN2THW/3.)*SINT*COST/2.
     $  +G*AMTP*COS(2.*THETAT)*(TWOM1*COS(ALFAH)-AAT*SIN(ALFAH))/2.
     $  /AMW/SIN(BETA)
        WID=AH**2/16./PI/AMT2SS**3
     $  *SQRT(SSXLAM(AMT2SS**2,AMHH**2,AMT1SS**2))
        CALL SSSAVE(ISTP2,WID,ISHH,ISTP1,0,0,0)
      END IF
C
      IF (AMT2SS.GT.(AMT1SS+AMHA)) THEN
        AH=G*AMTP*(TWOM1-AAT/TANB)/2./AMW
        WID=AH**2/16./PI/AMT2SS**3
     $  *SQRT(SSXLAM(AMT2SS**2,AMHA**2,AMT1SS**2))
        CALL SSSAVE(ISTP2,WID,ISHA,ISTP1,0,0,0)
      END IF
C
C          t_i --> b_i + W decays
C
      IF (AMT1SS.GT.(AMB1SS+AMW)) THEN
        WID=G**2*COST**2*COSB**2*(SSXLAM(AMT1SS**2,AMB1SS**2,
     $AMW**2))**1.5/32./PI/AMT1SS**3/AMW**2
        CALL SSSAVE(ISTP1,WID,IDW,ISBT1,0,0,0)
      END IF
C
      IF (AMT1SS.GT.(AMB2SS+AMW)) THEN
        WID=G**2*COST**2*SINB**2*(SSXLAM(AMT1SS**2,AMB2SS**2,
     $AMW**2))**1.5/32./PI/AMT1SS**3/AMW**2
        CALL SSSAVE(ISTP1,WID,IDW,ISBT2,0,0,0)
      END IF
C
      IF (AMT2SS.GT.(AMB1SS+AMW)) THEN
        WID=G**2*SINT**2*COSB**2*(SSXLAM(AMT2SS**2,AMB1SS**2,
     $AMW**2))**1.5/32./PI/AMT2SS**3/AMW**2
        CALL SSSAVE(ISTP2,WID,IDW,ISBT1,0,0,0)
      END IF
C
      IF (AMT2SS.GT.(AMB2SS+AMW)) THEN
        WID=G**2*SINT**2*SINB**2*(SSXLAM(AMT2SS**2,AMB2SS**2,
     $AMW**2))**1.5/32./PI/AMT2SS**3/AMW**2
        CALL SSSAVE(ISTP2,WID,IDW,ISBT2,0,0,0)
      END IF
C
C          t_i --> b_i + H+ decays
C
      IF (AMT1SS.GT.(AMB1SS+AMHC)) THEN
        A=G/SR2/AMW*(AMTP*AMBT*(COTB+TANB)*SINT*SINB+
     $(AMBT**2*TANB+AMTP**2*COTB-AMW**2*SIN(2*BETA))*
     $COST*COSB-AMTP*(TWOM1-AAT*COTB)*SINT*COSB-AMBT*
     $(TWOM1-AAB*TANB)*SINB*COST)
        AS=A*A
        WID=AS*SQRT(SSXLAM(AMT1SS**2,AMB1SS**2,AMHC**2))/
     $      16./PI/AMT1SS**3
        CALL SSSAVE(ISTP1,WID,ISHC,ISBT1,0,0,0)
      END IF
C
      IF (AMT1SS.GT.(AMB2SS+AMHC)) THEN
        A=G/SR2/AMW*(-AMTP*AMBT*(COTB+TANB)*SINT*COSB+
     $(AMBT**2*TANB+AMTP**2*COTB-AMW**2*SIN(2*BETA))*
     $COST*SINB-AMTP*(TWOM1-AAT*COTB)*SINT*SINB+AMBT*
     $(TWOM1-AAB*TANB)*COST*COSB)
        AS=A*A
        WID=AS*SQRT(SSXLAM(AMT1SS**2,AMB2SS**2,AMHC**2))/
     $      16./PI/AMT1SS**3
        CALL SSSAVE(ISTP1,WID,ISHC,ISBT2,0,0,0)
      END IF
C
      IF (AMT2SS.GT.(AMB1SS+AMHC)) THEN
        A=G/SR2/AMW*(-AMTP*AMBT*(COTB+TANB)*COST*SINT+
     $(AMBT**2*TANB+AMTP**2*COTB-AMW**2*SIN(2*BETA))*
     $SINT*COSB+AMTP*(TWOM1-AAT*COTB)*COST*COSB-AMBT*
     $(TWOM1-AAB*TANB)*SINT*SINB)
        AS=A*A
        WID=AS*SQRT(SSXLAM(AMT2SS**2,AMB1SS**2,AMHC**2))/
     $      16./PI/AMT2SS**3
        CALL SSSAVE(ISTP2,WID,ISHC,ISBT1,0,0,0)
      END IF
C
      IF (AMT2SS.GT.(AMB2SS+AMHC)) THEN
        A=G/SR2/AMW*(AMTP*AMBT*(COTB+TANB)*COST*COSB+
     $(AMBT**2*TANB+AMTP**2*COTB-AMW**2*SIN(2*BETA))*
     $SINT*SINB+AMTP*(TWOM1-AAT*COTB)*SINB*COST+AMBT*
     $(TWOM1-AAB*TANB)*COSB*SINT)
        AS=A*A
        WID=AS*SQRT(SSXLAM(AMT2SS**2,AMB2SS**2,AMHC**2))/
     $      16./PI/AMT2SS**3
        CALL SSSAVE(ISTP2,WID,ISHC,ISBT2,0,0,0)
      END IF
C
C
C          stop_2 -> top + zino_i
C
      DO 500 IZ=1,4
        MZIZ=ABS(AMZISS(IZ))
        SNZI=SIGN(1.,AMZISS(IZ))
        IF (SNZI.EQ.1.) THEN
           THIZ=0.
        ELSE
           THIZ=1.
        END IF
        ZAUIZ=ZI**(THIZ-1.)*SNZI
     $  *(-G/SR2*ZMIXSS(3,IZ)-GP/3./SR2*ZMIXSS(4,IZ))
        ZBUIZ=ZI**(THIZ-1.)*4*GP*ZMIXSS(4,IZ)/3./SR2
        ZPP=ZI**THIZ
        ZPM=(-ZI)**THIZ
        ZA=((ZI*ZAUIZ-ZPP*FT*ZMIXSS(1,IZ))*SINT
     $  +(ZI*ZBUIZ-ZPM*FT*ZMIXSS(1,IZ))*COST)/2.
        ZB=((-ZI*ZAUIZ-ZPP*FT*ZMIXSS(1,IZ))*SINT
     $  +(ZI*ZBUIZ+ZPM*FT*ZMIXSS(1,IZ))*COST)/2.
        AS=ZA*CONJG(ZA)
        BS=ZB*CONJG(ZB)
        IF (AMT2SS.GT.(AMTP+MZIZ)) THEN
          WID=(AS*(AMT2SS**2-(AMTP+MZIZ)**2)+BS
     $    *(AMT2SS**2-(AMTP-MZIZ)**2))/8./PI/AMT2SS
     $    *SQRT(SSXLAM(1.,AMTP**2/AMT2SS**2,MZIZ**2/AMT2SS**2))
          CALL SSSAVE(ISTP2,WID,ISZIZ(IZ),IDTP,0,0,0)
        END IF
500   CONTINUE
C
C          Normalize branching ratios
C
       CALL SSNORM(ISTP1)
       CALL SSNORM(ISTP2)
C
       RETURN
       END
CDECK  ID>, SSTEST. 
      SUBROUTINE SSTEST(IALLOW)
C
C          Test MSSM parameters against existing bounds on SUSY from
C          LEP and SLC:
C          IALLOW = 1    Z1 is not LSP
C          IALLOW = 2    Gamma(Z -> Z1SS Z1SS) < GAMINV
C          IALLOW = 4    Z -> charginos allowed
C          IALLOW = 8    BF(Z -> Z1SS Z2SS)>10^5
C          IALLOW = 16   Z -> squarks, sleptons
C          IALLOW = 32   BR(Z -> Z* HL0) < B(Z -> Z* H(M=MHSM))
C          IALLOW = 64   BR(Z -> HL0 HA0) > 0
C          IALLOW = 128  M(H+) > M(Z)/2
C          where GAMINV is the present bound on the invisible width,
C          and MHSM is the lower bound on the standard Higgs mass.
C
C          Bounds on the other modes are only approximate, but the
C          error in the allowed region of masses must be tiny.
C          Updated by H. Baer on 5/25/95
C
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          MXSS                 = maximum number of modes
C          NSSMOD               = number of modes
C          ISSMOD               = initial particle
C          JSSMOD               = final particles
C          GSSMOD               = width
C          BSSMOD               = branching ratio
      INTEGER MXSS
      PARAMETER (MXSS=1000)
      COMMON/SSMODE/NSSMOD,ISSMOD(MXSS),JSSMOD(5,MXSS),GSSMOD(MXSS)
     $,BSSMOD(MXSS)
      INTEGER NSSMOD,ISSMOD,JSSMOD
      REAL GSSMOD,BSSMOD
      SAVE /SSMODE/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C          Frozen couplings from RG equations:
C     GSS( 1) = g_1        GSS( 2) = g_2        GSS( 3) = g_3
C     GSS( 4) = y_tau      GSS( 5) = y_b        GSS( 6) = y_t
C     GSS( 7) = M_1        GSS( 8) = M_2        GSS( 9) = M_3
C     GSS(10) = A_tau      GSS(11) = A_b        GSS(12) = A_t
C     GSS(13) = M_h1^2     GSS(14) = M_h2^2     GSS(15) = M_er^2
C     GSS(16) = M_el^2     GSS(17) = M_dnr^2    GSS(18) = M_upr^2
C     GSS(19) = M_upl^2    GSS(20) = M_taur^2   GSS(21) = M_taul^2
C     GSS(22) = M_btr^2    GSS(23) = M_tpr^2    GSS(24) = M_tpl^2
C     GSS(25) = mu         GSS(26) = B
C          Masses:
C     MSS( 1) = glss     MSS( 2) = upl      MSS( 3) = upr
C     MSS( 4) = dnl      MSS( 5) = dnr      MSS( 6) = stl
C     MSS( 7) = str      MSS( 8) = chl      MSS( 9) = chr
C     MSS(10) = b1       MSS(11) = b2       MSS(12) = t1
C     MSS(13) = t2       MSS(14) = nuel     MSS(15) = numl
C     MSS(16) = nutl     MSS(17) = el-      MSS(18) = er-
C     MSS(19) = mul-     MSS(20) = mur-     MSS(21) = tau1
C     MSS(22) = tau2     MSS(23) = z1ss     MSS(24) = z2ss
C     MSS(25) = z3ss     MSS(26) = z4ss     MSS(27) = w1ss
C     MSS(28) = w2ss     MSS(29) = hl0      MSS(30) = hh0
C     MSS(31) = ha0      MSS(32) = h+
C          Unification:
C     MGUTSS  = M_GUT    GGUTSS  = g_GUT    AGUTSS  = alpha_GUT
      COMMON /SUGMG/ MSS(32),GSS(26),MGUTSS,GGUTSS,AGUTSS
      REAL MSS,GSS,MGUTSS,GGUTSS,AGUTSS
      SAVE /SUGMG/
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C
      INTEGER IALLOW
      EXTERNAL SSZHX
      REAL MHSM,GAMINV,PI,SR2,G,GP,MZ,MZ1,MZ2,MZ3,MZ4,MW1,MW2,
     $TANB,BETA,COS2B,SIN2B,VS,V,VP,FT,MHL,ALPHA,SUSYCC,
     $GAMSS,W11,GZ1Z1,GAMSM,SSXINT,SSXLAM,COS2W,
     $W12,GZ1Z2,DGAMZ,BFZ,BFZ1Z2
C
C          Current bounds
      DATA MHSM/64./,GAMINV/.0043/,DGAMZ/.0115/,BFZ/1.E-5/
C
C          Initialize
C
      IALLOW=0
      PI=4.*ATAN(1.)
      SR2=SQRT(2.)
      G=SQRT(4*PI*ALFAEM/SN2THW)
      GP=G*SQRT(SN2THW/(1.-SN2THW))
      COS2W=SQRT(1.-SN2THW)
      MZ=AMZ
      MZ1=ABS(AMZ1SS)
      MZ2=ABS(AMZ2SS)
      MZ3=ABS(AMZ3SS)
      MZ4=ABS(AMZ4SS)
      MW1=ABS(AMW1SS)
      MW2=ABS(AMW2SS)
C
C          Check that Z1SS is LSP
C
      IF(MZ1.GT.MW1.OR.MZ1.GT.AMGLSS.OR.MZ1.GT.AMULSS
     $.OR.MZ1.GT.AMERSS.OR.MZ1.GT.AMELSS.OR.MZ1.GT.AMN1SS
     $.OR.MZ1.GT.AMB1SS.OR.MZ1.GT.AMT1SS.OR.MZ1.GT.AML1SS) THEN
        IALLOW=IALLOW+1
      ENDIF
C
C          Z -> Z1SS + Z1SS
C
      IF (AMZ.GT.2*MZ1) THEN
        W11=SQRT(G*G+GP*GP)
     $  *(ZMIXSS(1,1)*ZMIXSS(1,1)-ZMIXSS(2,1)*ZMIXSS(2,1))/4.
        GZ1Z1=SQRT(SSXLAM(MZ**2,MZ1**2,MZ1**2))/12./PI/MZ**3*W11**2
     $  *(2*MZ**2-MZ1**2-MZ1**2-(MZ1**2-MZ1**2)**2/MZ**2
     $  -6*MZ1*MZ1*SIGN(1.,AMZ1SS*AMZ1SS))
        IF(GZ1Z1.GT.GAMINV) THEN
          IALLOW=IALLOW+2
        ENDIF
      ENDIF
C
C          Check for other allowed visible modes modes
C
      IF(AMZ.GT.2*MW1) THEN
        IALLOW=IALLOW+4
      ENDIF
C
C          Check funny Z branching fractions
C
      BFZ1Z2=0.
      IF (AMZ.GT.MZ1+MZ2) THEN
        W12=SQRT(G*G+GP*GP)
     $  *(ZMIXSS(1,1)*ZMIXSS(1,2)-ZMIXSS(2,1)*ZMIXSS(2,2))/4.
        GZ1Z2=SQRT(SSXLAM(MZ**2,MZ1**2,MZ2**2))/6./PI/MZ**3*W12**2
     $  *(2*MZ**2-MZ1**2-MZ2**2-(MZ1**2-MZ2**2)**2/MZ**2
     $  -6*MZ1*MZ2*SIGN(1.,AMZ1SS*AMZ2SS))
        BFZ1Z2=GZ1Z2/GAMZ
      END IF
      IF(BFZ1Z2.GT.BFZ) THEN
        IALLOW=IALLOW+8
      ENDIF
C
      IF(AMZ.GT.2*AMULSS.OR.AMZ.GT.2*AMELSS.OR.AMZ.GT.2*AMERSS
     $.OR.AMZ.GT.2*AMN1SS.OR.AMZ.GT.2*AMB1SS.OR.AMZ.GT.2*AMT1SS)THEN
        IALLOW=IALLOW+16
      ENDIF
C
C          Z -> Higgs modes
C
      TMP(1)=MHSM
      GAMSM=SSXINT(2*MHSM/MZ,SSZHX,(1.+MHSM**2/MZ**2))
C          Z -> hl0 x
      IF(AMZ.GT.AMHL) THEN
        TANB=1./RV2V1
        BETA=ATAN(TANB)
        COS2B=COS(2*BETA)
        SIN2B=SIN(2*BETA)
        VS=2*AMW**2/G**2/(1.+RV2V1**2)
        V=SQRT(VS)
        VP=RV2V1*V
        FT=G*AMTP/SR2/AMW/V*SQRT(V**2+VP**2)
        MHL=AMHL
        ALPHA=ALFAH
        SUSYCC=SIN(ALPHA+BETA)
        TMP(1)=MHL
        GAMSS=SSXINT(2*MHL/AMZ,SSZHX,(1.+MHL**2/AMZ**2))*SUSYCC**2
        IF(GAMSS.GE.GAMSM) IALLOW=IALLOW+32
      ENDIF
C          Z -> hl0 ha0
      IF (AMZ.GT.(AMHL+AMHA)) THEN
        IALLOW=IALLOW+64
      ENDIF
C          Z -> H+ H-
      IF(AMZ.GT.2*AMHC) THEN
        IALLOW=IALLOW+128
      ENDIF
C
      RETURN
      END
CDECK  ID>, SSTPBF. 
        SUBROUTINE SSTPBF
C-----------------------------------------------------------------------
C
C     Calculate the top branching ratios.
C     Source: H. Baer (modified by F. Paige)
C
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          MXSS                 = maximum number of modes
C          NSSMOD               = number of modes
C          ISSMOD               = initial particle
C          JSSMOD               = final particles
C          GSSMOD               = width
C          BSSMOD               = branching ratio
      INTEGER MXSS
      PARAMETER (MXSS=1000)
      COMMON/SSMODE/NSSMOD,ISSMOD(MXSS),JSSMOD(5,MXSS),GSSMOD(MXSS)
     $,BSSMOD(MXSS)
      INTEGER NSSMOD,ISSMOD,JSSMOD
      REAL GSSMOD,BSSMOD
      SAVE /SSMODE/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C
      COMPLEX ZI,ZONE,ZA,ZB,ZPP,ZPM,ZAUIZ,ZBUIZ
      REAL SSXLAM,G,AL2,BE2,TANB,COTB,GTBW,GTBH,BWLL,GF,BWQQ,PI,SR2
      REAL WID,AS,BS,MZIZ,CS2THW,GP,FT,FB,SNZI,THIZ
      REAL SINT,COST,SINB,COSB,AWI,BWI,AMW1,AMW2,SNWI
      REAL THX,THY,XM,YM,BETA,ASMB,MBMB,MBQ,ASMT,MTMT,MTQ,SUALFS
      DOUBLE PRECISION SSMQCD
      INTEGER IZ,ISZIZ(4)
      DATA ZONE/(1.,0.)/,ZI/(0.,1.)/
C
      PI=4.*ATAN(1.)
      SR2=SQRT(2.)
      G=SQRT(4*PI*ALFAEM/SN2THW)
      GP=G*SQRT(SN2THW/(1.-SN2THW))
      TANB=1./RV2V1
      COTB=1./TANB
      BETA=ATAN(TANB)
      CS2THW=1.-SN2THW
      ASMB=SUALFS(AMBT**2,.36,AMTP,3)
      MBMB=AMBT*(1.-4*ASMB/3./PI)
      MBQ=SSMQCD(DBLE(MBMB),DBLE(AMTP))
      ASMT=SUALFS(AMTP**2,.36,AMTP,3)
      MTMT=AMTP/(1.+4*ASMT/3./PI+(16.11-1.04*(5.-6.63/AMTP))*
     $(ASMT/PI)**2)
      MTQ=SSMQCD(DBLE(MTMT),DBLE(AMTP))
      FB=G*MBQ/SR2/AMW/COS(BETA)
      FT=G*MTQ/SR2/AMW/SIN(BETA)
      SINT=SIN(THETAT)
      COST=COS(THETAT)
      SINB=SIN(THETAB)
      COSB=COS(THETAB)
      ISZIZ(1)=ISZ1
      ISZIZ(2)=ISZ2
      ISZIZ(3)=ISZ3
      ISZIZ(4)=ISZ4
      XM=1./TAN(GAMMAL)
      YM=1./TAN(GAMMAR)
      THX=SIGN(1.,XM)
      THY=SIGN(1.,YM)
C
C          W decays
C
      GF=1.16E-5
      GTBW=GF*AMTP**3*SSXLAM(1.,AMW**2/AMTP**2,AMBT**2/AMTP**2)*
     $((1.-AMBT**2/AMTP**2)**2+AMW**2/AMTP**2*(1.+AMBT**2/AMTP**2)
     $-2*AMW**4/AMTP**4)/(8.*PI*SR2)
      BWQQ=3./9.
      BWLL=1./9.
      CALL SSSAVE(IDTP,BWQQ*GTBW,IDUP,-IDDN,IDBT,0,0)
      CALL SSSAVE(IDTP,BWQQ*GTBW,IDCH,-IDST,IDBT,0,0)
      CALL SSSAVE(IDTP,BWLL*GTBW,-IDE,IDNE,IDBT,0,0)
      CALL SSSAVE(IDTP,BWLL*GTBW,-IDMU,IDNM,IDBT,0,0)
      CALL SSSAVE(IDTP,BWLL*GTBW,-IDTAU,IDNT,IDBT,0,0)
C
C          H+ decays
C
      AL2=(G/2/SR2/AMW*(AMBT*TANB+AMTP*COTB))**2
      BE2=(G/2/SR2/AMW*(AMBT*TANB-AMTP*COTB))**2
      IF (AMTP.GT.(AMBT+AMHC)) THEN
        GTBH=AMTP/16./PI*((AL2+BE2)
     $  *(1.+AMBT**2/AMTP**2-AMHC**2/AMTP**2)
     $  +2*(AL2-BE2)*AMBT/AMTP)
     $  *SQRT(SSXLAM(1.,AMHC**2/AMTP**2,AMBT**2/AMTP**2))
        CALL SSSAVE(IDTP,GTBH,ISHC,IDBT,0,0,0)
      END IF
C
C          t->t_1 + z_i decays
      DO 100 IZ=1,4
        MZIZ=ABS(AMZISS(IZ))
        SNZI=SIGN(1.,AMZISS(IZ))
        IF (SNZI.EQ.1.) THEN
           THIZ=0.
        ELSE
           THIZ=1.
        END IF
        ZAUIZ=ZI**(THIZ-1.)*SNZI*
     $(-G/SR2*ZMIXSS(3,IZ)-GP/3./SR2*ZMIXSS(4,IZ))
        ZBUIZ=ZI**(THIZ-1.)*4*GP*ZMIXSS(4,IZ)/3./SR2
        ZPP=ZI**THIZ
        ZPM=(-ZI)**THIZ
        ZA=((ZI*ZAUIZ-ZPP*FT*ZMIXSS(1,IZ))*COST-
     $(ZI*ZBUIZ-ZPM*FT*ZMIXSS(1,IZ))*SINT)/2.
        ZB=((-ZI*ZAUIZ-ZPP*FT*ZMIXSS(1,IZ))*COST-
     $(ZI*ZBUIZ+ZPM*FT*ZMIXSS(1,IZ))*SINT)/2.
        AS=ZA*CONJG(ZA)
        BS=ZB*CONJG(ZB)
        IF (AMTP.GT.(AMT1SS+MZIZ)) THEN
          WID=(AS*((AMTP+MZIZ)**2-AMT1SS**2)+BS*
     $((AMTP-MZIZ)**2-AMT1SS**2))/16./PI/AMTP*
     $SQRT(SSXLAM(1.,AMT1SS**2/AMTP**2,MZIZ**2/AMTP**2))
          CALL SSSAVE(IDTP,WID,ISZIZ(IZ),ISTP1,0,0,0)
        END IF
100   CONTINUE
C
C       t -> sb_1 + sW_i
C
        AMW1=ABS(AMW1SS)
        AMW2=ABS(AMW2SS)
        IF (AMTP.GT.(AMB1SS+AMW1)) THEN
          SNWI=SIGN(1.,AMW1SS)
          AWI=-G*SIN(GAMMAL)*COSB+FB*COS(GAMMAL)*SINB
          BWI=-FT*(-SNWI)*COS(GAMMAR)
          WID=AMTP*((AWI**2+BWI**2*COSB**2)*(1.+AMW1**2/AMTP**2
     $-AMB1SS**2/AMTP**2)+4*AMW1/AMTP*AWI*BWI*COST)/32./PI*
     $SQRT(SSXLAM(1.,AMW1**2/AMTP**2,AMB1SS**2/AMTP**2))
          CALL SSSAVE(IDTP,WID,ISW1,ISBT1,0,0,0)
        END IF
c
        IF (AMTP.GT.(AMB1SS+AMW2)) THEN
          SNWI=SIGN(1.,AMW2SS)
          AWI=-G*THX*COS(GAMMAL)*COSB-FB*THX*SIN(GAMMAL)*SINB
          BWI=FT*(-SNWI)*THY*SIN(GAMMAR)
          WID=AMTP*((AWI**2+BWI**2*COSB**2)*(1.+AMW2**2/AMTP**2
     $-AMB1SS**2/AMTP**2)+4*AMW2/AMTP*AWI*BWI*COST)/32./PI*
     $SQRT(SSXLAM(1.,AMW2**2/AMTP**2,AMB1SS**2/AMTP**2))
          CALL SSSAVE(IDTP,WID,ISW2,ISBT1,0,0,0)
        END IF
C
C       t -> sb_2 + sW_i
C
        IF (AMTP.GT.(AMB2SS+AMW1)) THEN
          SNWI=SIGN(1.,AMW1SS)
          AWI=-G*SIN(GAMMAL)*SINB-FB*COS(GAMMAL)*COSB
          BWI=-FT*(-SNWI)*COS(GAMMAR)
          WID=AMTP*((AWI**2+BWI**2*SINB**2)*(1.+AMW1**2/AMTP**2
     $-AMB2SS**2/AMTP**2)+4*AMW1/AMTP*AWI*BWI*COST)/32./PI*
     $SQRT(SSXLAM(1.,AMW1**2/AMTP**2,AMB2SS**2/AMTP**2))
          CALL SSSAVE(IDTP,WID,ISW1,ISBT2,0,0,0)
        END IF
c
        IF (AMTP.GT.(AMB2SS+AMW2)) THEN
          SNWI=SIGN(1.,AMW2SS)
          AWI=-G*THX*COS(GAMMAL)*SINB+FB*THX*SIN(GAMMAL)*COSB
          BWI=FT*(-SNWI)*THY*SIN(GAMMAR)
          WID=AMTP*((AWI**2+BWI**2*SINB**2)*(1.+AMW2**2/AMTP**2
     $-AMB2SS**2/AMTP**2)+4*AMW2/AMTP*AWI*BWI*COST)/32./PI*
     $SQRT(SSXLAM(1.,AMW2**2/AMTP**2,AMB2SS**2/AMTP**2))
          CALL SSSAVE(IDTP,WID,ISW2,ISBT2,0,0,0)
        END IF
C
C
C          Normalize branching ratios
C
      CALL SSNORM(IDTP)
C
      RETURN
      END
CDECK  ID>, SSWWF1. 
        REAL FUNCTION SSWWF1(EE)
C-----------------------------------------------------------------------
C          SSWZBF: wiss -> zjss f fbar
C          Baer's WIWFUN
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      DOUBLE PRECISION E,MW2,MW1,MZ,SN,XX,YY,T1,T2,T3,T4
      REAL EE
C
      E=EE
      MW2=TMP(1)
      MW1=TMP(2)
      MZ=TMP(3)
      SN=TMP(4)
      XX=TMP(5)
      YY=TMP(6)
C
      T1=DSQRT(E**2-MW1**2)/(MW2**2+MW1**2-MZ**2-2*MW2*E)**2
      T2=3*E*MW2*(MW2**2+MW1**2)-2*MW2**2*MW1**2-4*MW2**2*E*E
      T3=2*E*MW2-MW2**2-MW1**2
      T4=T1*((XX**2+YY**2)*T2-3*SN*(XX**2-YY**2)*MW2*MW1*T3)
      SSWWF1=T4
      RETURN
      END
CDECK  ID>, SSWZBF. 
        SUBROUTINE SSWZBF
C-----------------------------------------------------------------------
C       This subroutine gives chargino (wi) and neutralino (zi)
C       decays according to Baer, et al.
C       Valid for all scalar masses (functions in double precision)
C       Includes Higgs sector radiative corrections (Aug. 31)
C
C       Auxiliary functions are called SSWxyi, SSZxyi, where normally
C       x indicates the SUSY particle, y the SM particle(s), and i is
C       a counter.
C
C       Ver. 7.07: For w_i -> z_j or z_i -> w_j decays, require that
C                  decay be allowed by a factor FUDGE = 1.05
C       Ver. 7.28: Calculate full large tan(beta) decays.
C                  Calculate tau polarizations.
C       Ver. 7.33: Add GMSB modes.
C
C       Baer's GAUGBF
C
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          MXSS                 = maximum number of modes
C          NSSMOD               = number of modes
C          ISSMOD               = initial particle
C          JSSMOD               = final particles
C          GSSMOD               = width
C          BSSMOD               = branching ratio
      INTEGER MXSS
      PARAMETER (MXSS=1000)
      COMMON/SSMODE/NSSMOD,ISSMOD(MXSS),JSSMOD(5,MXSS),GSSMOD(MXSS)
     $,BSSMOD(MXSS)
      INTEGER NSSMOD,ISSMOD,JSSMOD
      REAL GSSMOD,BSSMOD
      SAVE /SSMODE/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C          Polarizations in SUSY decays
C          PTAUj(i)  = P_tau for tauj -> ziss tau
C          PTAUZi(j) = P_tau for ziss -> tauj tau
C          PTAUZZ    = P_tau for z2ss -> z1ss tau tau
C          PTAUWZ    = P_tau for w1ss -> z1ss tau nutau
      COMMON/SSPOLS/PTAU1(4),PTAU2(4),PTAUZ2(2),PTAUZ3(2),PTAUZ4(2),
     $PTAUZZ,PTAUWZ
      SAVE /SSPOLS/
      REAL PTAU1,PTAU2,PTAUZ2,PTAUZ3,PTAUZ4,PTAUZZ,PTAUWZ
C
      EXTERNAL SSZWF1,SSZZF1,SSZZF2,SSZZF3,SSWZF1,SSWZF2,SSWZF3
     $,SSWZF4,SSWZF5,SSWZF6,SSWZF7,SSWWF1,SSZZF4,SSZZF5,SSGX1
     $,SSGX2,SSGX8
C
      REAL AUI(4),BUI(4),ADI(4),BDI(4),ALI(4),BLI(4),ANI(4),BNI(4)
     $,WIJ(4,4),AUWI(4),ADWI(4),ANWI(4),ALWI(4),XIM(4),YIM(4)
     $,XIP(4),YIP(4),SNIJ(4,4),XLIJ(4,4),HIJ(4,4)
     $,V1I(4),V2I(4),V3I(4),V4I(4),XHIJ(4,4),XPIJ(4,4),AMWISS(2)
C
      INTEGER ISZ(4)
C
      REAL MWIW,SL,PP,SP,PL,MZIZ,PH,SH,COSB,SINB,COSA,SINA
     $,FACTOR,MZJZ,ULIM,FAC,XINTGL,COSBE,SINBE
     $,UPPER,CONST
      REAL W21ZU,W21ZN,W21ZL,W21ZD,W21U,W21D,W21S,W21C,W21N1
     $,W21N2,W21N3,W21E,W21M,W21L,STHW,CTHW
      REAL T3,XI2,CC,PSIINT,T2,T1,PHIINT,XI1,EF,A,Z,B
     $,TANB,AWMD,AWMU,FB,FT,SR2,G,PI,GP,FL
     $,MW2,SNW1,MW1,YM,BE,SNW2,XM,AWPU,THX,AWPD,THY
     $,BTN,APD,APL,APU,BTD,BTL,APN,BTU,Y
      REAL TANW,COTW,ALPHL,BETAL,ALPHN,BETAN,ALPHU,BETAU,ALPHD,BETAD
     $,XWINO,YWINO,SN,SNIW,SNJZ
      REAL SSXINT,SSXLAM
      REAL WID,WIDEE,TERM1,TERM2,TERM3,TERM4,E,
     $TERMLL,TERMRR,TERMZZ,TERMLZ,TERMRZ,TERMH,TERMLH
      REAL FACT,ALIZ1,ALJZ1,ALIZ2,ALJZ2,BEIZ1,BEJZ1,BEIZ2,BEJZ2,
     $SGNIJ,XUPPER,GLLF1,GRRF1,GLRF1,GF1,GLLF2,GRRF2,GLRF2,GF2,
     $GLGL,GRGR,GLGR,GRGL,GF12,GF,TERMHL,TERMHH,TERMHA,
     $TERM1Z,TERM2Z,TERM1L,TERM2L,TERM1H,TERM2H,TERM1A,TERM2A
      REAL ALIW1,ALIW2,AHCJZ,BHCJZ,TERMW,TERMN,TERM12,TERMN1,
     $TERMN2,TERMWN,TERMW1,TERMW2,TERMH1,TERMH2,TERMHN
      REAL XIPM,YIPM,COSL,SINL,BPWI(2),BPLWI(2)
      REAL BWI(2),AS,BS,COST,SINT,SNZI,THIZ
      REAL POLNL,POLNR,POL1L,POL1R,POL2L,POL2R,POL12L,POL12R,
     $POLN1L,POLN1R,POLN2L,POLN2R
      REAL GLLF1L,GRRF1R,GLGLL,GRGRR,GLLF2L,GRRF2R,TMZZRL,TMZZLR,
     $TM1ZRL,TM1ZLR,TM2ZRL,TM2ZLR
      REAL ASMB,MBMB,MBQ,ASMT,MTMT,MTQ,SUALFS,AMASS
      REAL SUALFE,MTAMTA,MTAMB,MTAMZ,AMPL
      DOUBLE PRECISION SSMQCD
      COMPLEX ZI,ZONE,ZA,ZB,ZPP,ZPM,ZAUIZ,ZBUIZ,ZADIZ,ZBDIZ,
     $ZALIZ,ZBLIZ
      INTEGER IW,JZ,IZ,ISZIZ,ISZJZ,ISWIW
      REAL FUDGE
      DATA FUDGE/1.05/
      DATA ZONE/(1.,0.)/,ZI/(0.,1.)/
C
C          Constants from neutralino mass matrix
C
      AMPL=2.4E18
      PI=4.*ATAN(1.)
      SR2=SQRT(2.)
      G=SQRT(4*PI*ALFAEM/SN2THW)
      GP=G*SQRT(SN2THW/(1.-SN2THW))
      E=SQRT(4*PI/128.)
C
      TANW=SQRT(SN2THW/(1.-SN2THW))
      COTW=1./TANW
      STHW=SQRT(SN2THW)
      CTHW=SQRT(1.-SN2THW)
      ALPHL=.25*(3*TANW-COTW)
      BETAL=.25*(COTW+TANW)
      ALPHN=.25*(TANW+COTW)
      BETAN=-.25*(COTW+TANW)
      ALPHU=-5*TANW/12.+COTW/4.
      BETAU=-.25*(COTW+TANW)
      ALPHD=-COTW/4.+TANW/12.
      BETAD=.25*(COTW+TANW)
C
      TANB=1./RV2V1
      BE=ATAN(1./RV2V1)
      SINBE=SIN(BE)
      COSBE=COS(BE)
      XM=1./TAN(GAMMAL)
      YM=1./TAN(GAMMAR)
      THX=SIGN(1.,XM)
      THY=SIGN(1.,YM)
      ASMB=SUALFS(AMBT**2,.36,AMTP,3)
      MBMB=AMBT*(1.-4*ASMB/3./PI)
      MBQ=SSMQCD(DBLE(MBMB),DBLE(AMTP))
      ASMT=SUALFS(AMTP**2,.36,AMTP,3)
      MTMT=AMTP/(1.+4*ASMT/3./PI+(16.11-1.04*(5.-6.63/AMTP))*
     $(ASMT/PI)**2)
      MTQ=SSMQCD(DBLE(MTMT),DBLE(AMTP))
      FB=G*MBQ/SR2/AMW/COS(BE)
      FT=G*MTQ/SR2/AMW/SIN(BE)
      MTAMTA=AMTAU*(1.-SUALFE(AMTAU**2)/PI)
      MTAMB=MTAMTA*(SUALFE(AMBT**2)/SUALFE(AMTAU**2))**(-27./76.)
      MTAMZ=MTAMB*(SUALFE(AMZ**2)/SUALFE(AMBT**2))**(-27./80.)
      FL=G*MTAMZ/SR2/AMW/COS(BE)
      AWMD=G*SIN(GAMMAR)
      AWMU=G*SIN(GAMMAL)
      AWPD=G*COS(GAMMAR)*THY
      AWPU=G*COS(GAMMAL)*THX
      SNW1=SIGN(1.,AMW1SS)
      SNW2=SIGN(1.,AMW2SS)
      AMWISS(1)=AMW1SS
      AMWISS(2)=AMW2SS
      BWI(1)=-FT*SNW1*COS(GAMMAR)
      BWI(2)=FT*SNW2*THY*SIN(GAMMAR)
      BPWI(1)=-FB*COS(GAMMAL)
      BPWI(2)=FB*THX*SIN(GAMMAL)
      BPLWI(1)=-FL*COS(GAMMAL)
      BPLWI(2)=FL*THX*SIN(GAMMAL)
      MW1=ABS(AMW1SS)
      MW2=ABS(AMW2SS)
      XWINO=.5*(THX*SIN(GAMMAL)*COS(GAMMAL)
     $-THY*SIN(GAMMAR)*COS(GAMMAR))
      YWINO=.5*(THX*SIN(GAMMAL)*COS(GAMMAL)
     $+THY*SIN(GAMMAR)*COS(GAMMAR))
      COST=COS(THETAT)
      SINT=SIN(THETAT)
      COSB=COS(THETAB)
      SINB=SIN(THETAB)
      COSL=COS(THETAL)
      SINL=SIN(THETAL)
C
C          Constants from Higgs mass matrix
C
      SINA=SIN(ALFAH)
      COSA=COS(ALFAH)
C
C          Gaugino couplings
C
      DO 100 IZ=1,4
        AUI(IZ)=G/SR2*ZMIXSS(3,IZ)+GP/3./SR2*ZMIXSS(4,IZ)
        BUI(IZ)=4.*GP/3./SR2*ZMIXSS(4,IZ)
        ADI(IZ)=-G/SR2*ZMIXSS(3,IZ)+GP/3./SR2*ZMIXSS(4,IZ)
        BDI(IZ)=-2.*GP/3./SR2*ZMIXSS(4,IZ)
        ALI(IZ)=G/SR2*ZMIXSS(3,IZ)+GP/SR2*ZMIXSS(4,IZ)
        BLI(IZ)=-SR2*GP*ZMIXSS(4,IZ)
        ANI(IZ)=G/SR2*ZMIXSS(3,IZ)-GP/SR2*ZMIXSS(4,IZ)
        BNI(IZ)=0.0
100   CONTINUE
C
      DO 110 IZ=1,4
      DO 110 JZ=1,4
        IF(IZ.LT.JZ) THEN
          WIJ(IZ,JZ)=SQRT(G**2+GP**2)
     $    *(ZMIXSS(1,IZ)*ZMIXSS(1,JZ)-ZMIXSS(2,IZ)*ZMIXSS(2,JZ))/4.
        ELSEIF(IZ.GT.JZ) THEN
          WIJ(IZ,JZ)=-SQRT(G**2+GP**2)
     $    *(ZMIXSS(1,IZ)*ZMIXSS(1,JZ)-ZMIXSS(2,IZ)*ZMIXSS(2,JZ))/4.
        ENDIF
110   CONTINUE
C
      APU=(SQRT((1.-SN2THW)/SN2THW)-5.*SQRT(SN2THW/(1.-SN2THW))/3.)/4.
      APD=-(SQRT((1.-SN2THW)/SN2THW)-SQRT(SN2THW/(1.-SN2THW))/3.)/4.
      APL=-(SQRT((1.-SN2THW)/SN2THW)-3.*SQRT(SN2THW/(1.-SN2THW)))/4.
      APN=(SQRT((1.-SN2THW)/SN2THW)+SQRT(SN2THW/(1.-SN2THW)))/4.
      BTU=-APN
      BTD=APN
      BTL=APN
      BTN=-APN
C
      AUWI(2)=G*THX*COS(GAMMAL)
      ADWI(2)=SNW2*G*THY*COS(GAMMAR)
      ALWI(2)=ADWI(2)
      ANWI(2)=AUWI(2)
      AUWI(1)=G*SIN(GAMMAL)
      ADWI(1)=SNW1*G*SIN(GAMMAR)
      ALWI(1)=ADWI(1)
      ANWI(1)=AUWI(1)
C
      DO 120 IZ=1,4
        XIM(IZ)=.5*(SNW1*SIGN(1.,AMZISS(IZ))*(COS(GAMMAR)
     $  *ZMIXSS(1,IZ)/SR2+SIN(GAMMAR)*ZMIXSS(3,IZ))-COS(GAMMAL)
     $  *ZMIXSS(2,IZ)/SR2+SIN(GAMMAL)*ZMIXSS(3,IZ))
        YIM(IZ)=.5*(-SNW1*SIGN(1.,AMZISS(IZ))*(COS(GAMMAR)
     $  *ZMIXSS(1,IZ)/SR2+SIN(GAMMAR)*ZMIXSS(3,IZ))-COS(GAMMAL)
     $  *ZMIXSS(2,IZ)/SR2+SIN(GAMMAL)*ZMIXSS(3,IZ))
        XIP(IZ)=.5*(SNW2*SIGN(1.,AMZISS(IZ))*THY*(-SIN(GAMMAR)
     $  *ZMIXSS(1,IZ)/SR2+COS(GAMMAR)*ZMIXSS(3,IZ))+THX*(SIN(GAMMAL)
     $  *ZMIXSS(2,IZ)/SR2+COS(GAMMAL)*ZMIXSS(3,IZ)))
        YIP(IZ)=.5*(-SNW2*SIGN(1.,AMZISS(IZ))*THY*(-SIN(GAMMAR)
     $  *ZMIXSS(1,IZ)/SR2+COS(GAMMAR)*ZMIXSS(3,IZ))+THX*(SIN(GAMMAL)
     $  *ZMIXSS(2,IZ)/SR2+COS(GAMMAL)*ZMIXSS(3,IZ)))
120   CONTINUE
C
      DO 130 IZ=1,4
      DO 130 JZ=1,4
        IF(IZ.NE.JZ) THEN
          SNIJ(IZ,JZ)=-1.*SIGN(1.,AMZISS(IZ))*SIGN(1.,AMZISS(JZ))
          XLIJ(IZ,JZ)=-SIGN(1.,AMZISS(IZ))*SIGN(1.,AMZISS(JZ))
     $    *(ZMIXSS(2,IZ)*SINA-ZMIXSS(1,IZ)*COSA)
     $    *(G*ZMIXSS(3,JZ)-GP*ZMIXSS(4,JZ))/2.
          XHIJ(IZ,JZ)=-SIGN(1.,AMZISS(IZ))*SIGN(1.,AMZISS(JZ))
     $    *(ZMIXSS(2,IZ)*COSA+ZMIXSS(1,IZ)*SINA)
     $    *(G*ZMIXSS(3,JZ)-GP*ZMIXSS(4,JZ))/2.
          XPIJ(IZ,JZ)=SIGN(1.,AMZISS(IZ))*SIGN(1.,AMZISS(JZ))
     $    *(ZMIXSS(2,IZ)*SINBE-ZMIXSS(1,IZ)*COSBE)
     $    *(G*ZMIXSS(3,JZ)-GP*ZMIXSS(4,JZ))/2.
          HIJ(IZ,JZ)=-SIGN(1.,AMZISS(IZ))*SIGN(1.,AMZISS(JZ))
     $    *(ZMIXSS(2,IZ)*COSA+ZMIXSS(1,IZ)*SINA)
     $    *(G*ZMIXSS(3,JZ)-GP*ZMIXSS(4,JZ))/2.
        ENDIF
130   CONTINUE
C
      SP=-.5*(-THY*SNW2*COSBE*SIN(GAMMAL)*SIN(GAMMAR)+
     $THY*SNW2*SINBE*COS(GAMMAL)*COS(GAMMAR)-
     $THX*SNW1*COSBE*COS(GAMMAL)*COS(GAMMAR)+
     $THX*SNW1*SINBE*SIN(GAMMAL)*SIN(GAMMAR))
      PP=-.5*(-THY*SNW2*COSBE*SIN(GAMMAL)*SIN(GAMMAR)+
     $THY*SNW2*SINBE*COS(GAMMAL)*COS(GAMMAR)+
     $THX*SNW1*COSBE*COS(GAMMAL)*COS(GAMMAR)-
     $THX*SNW1*SINBE*SIN(GAMMAL)*SIN(GAMMAR))
C
      SL=.5*(THY*SNW2*SINA*COS(GAMMAL)*COS(GAMMAR)-
     $THY*SNW2*COSA*SIN(GAMMAL)*SIN(GAMMAR)+
     $THX*SNW1*COSA*COS(GAMMAL)*COS(GAMMAR)-
     $THX*SNW1*SINA*SIN(GAMMAL)*SIN(GAMMAR))
      PL=.5*(THY*SNW2*SINA*COS(GAMMAL)*COS(GAMMAR)-
     $THY*SNW2*COSA*SIN(GAMMAL)*SIN(GAMMAR)-
     $THX*SNW1*COSA*COS(GAMMAL)*COS(GAMMAR)+
     $THX*SNW1*SINA*SIN(GAMMAL)*SIN(GAMMAR))
C
      SH=.5*(THY*SNW2*COSA*COS(GAMMAL)*COS(GAMMAR)+
     $THY*SNW2*SINA*SIN(GAMMAL)*SIN(GAMMAR)-
     $THX*SNW1*SINA*COS(GAMMAL)*COS(GAMMAR)-
     $THX*SNW1*COSA*SIN(GAMMAL)*SIN(GAMMAR))
      PH=.5*(THY*SNW2*COSA*COS(GAMMAL)*COS(GAMMAR)+
     $THY*SNW2*SINA*SIN(GAMMAL)*SIN(GAMMAR)+
     $THX*SNW1*SINA*COS(GAMMAL)*COS(GAMMAR)+
     $THX*SNW1*COSA*SIN(GAMMAL)*SIN(GAMMAR))
C
      DO 140 IZ=1,4
        V1I(IZ)=-SIN(GAMMAR)/SR2*(G*ZMIXSS(3,IZ)+GP*ZMIXSS(4,IZ))
     $  -G*COS(GAMMAR)*ZMIXSS(1,IZ)
        V2I(IZ)=COS(GAMMAR)/SR2*(G*ZMIXSS(3,IZ)+GP*ZMIXSS(4,IZ))
     $  -G*SIN(GAMMAR)*ZMIXSS(1,IZ)
        V3I(IZ)=-SIN(GAMMAL)/SR2*(G*ZMIXSS(3,IZ)+GP*ZMIXSS(4,IZ))
     $  +G*COS(GAMMAL)*ZMIXSS(2,IZ)
        V4I(IZ)=COS(GAMMAL)/SR2*(G*ZMIXSS(3,IZ)+GP*ZMIXSS(4,IZ))
     $  +G*SIN(GAMMAL)*ZMIXSS(2,IZ)
140   CONTINUE
C
C          Initialize polarizations to zero
C
      DO 150 IZ=1,4
        PTAU1(IZ)=0
        PTAU2(IZ)=0
150   CONTINUE
      PTAUZZ=0
      PTAUWZ=0
C-----------------------------------------------------------------------
C          Generate Neutralino zi Branching Fractions
C-----------------------------------------------------------------------
      ISZ(1)=ISZ1
      ISZ(2)=ISZ2
      ISZ(3)=ISZ3
      ISZ(4)=ISZ4
C
      DO 200 IZ=2,4
        MZIZ=ABS(AMZISS(IZ))
        ISZIZ=ISZ(IZ)
C          z2 --> z1 + photon
C          !!! NEEDS UPDATING
        IF (IZ.EQ.2.AND.(ABS(ZMIXSS(3,1)).LE.1.E-4).AND.
     $  (ABS(ZMIXSS(4,1)).LE.1.E-4)) THEN
          CALL SSSAVE(ISZ2,1.,ISZ1,IDGM,0,0,0)
          GOTO 200
        END IF
C
C          zi --> wi + x partial widths
C
        DO 205 IW=1,2
C          Loop over w1, w2
          IF(IW.EQ.1) THEN
            MWIW=MW1
            SNIW=SNW1
            ISWIW=ISW1
          ELSE
            MWIW=MW2
            SNIW=SNW2
            ISWIW=ISW2
          ENDIF
C
C          zi -> wj + w
C
          IF(MZIZ.GT.MWIW+AMW) THEN
            EF=MZIZ**2+MWIW**2-AMW**2+((MZIZ**2-MWIW**2)**2
     $         -AMW**4)/AMW/AMW
            WID=G*G*SQRT(SSXLAM(MZIZ**2,AMW**2,MWIW**2))/32./PI/
     $          MZIZ**3*(2.*EF*(XIM(IZ)**2+YIM(IZ)**2)-12.*
     $          MZIZ*MWIW*(XIM(IZ)**2-YIM(IZ)**2))
            CALL SSSAVE(ISZIZ,WID,+ISWIW,-IDW,0,0,0)
            CALL SSSAVE(ISZIZ,WID,-ISWIW,+IDW,0,0,0)
C
C          zi -> wj + f + fbar (w forbidden)
C
          ELSEIF(MZIZ.GT.FUDGE*MWIW) THEN
            TMP(1)=MWIW
            TMP(2)=MZIZ
            IF(IW.EQ.1) THEN
              TMP(3)=XIM(IZ)
              TMP(4)=YIM(IZ)
            ELSE
              TMP(3)=XIP(IZ)
              TMP(4)=YIP(IZ)
            ENDIF
            WID=G**4/96./PI**3/MZIZ
     $      *SSXINT(MWIW,SSZWF1,(MWIW**2+MZIZ**2)/2./MZIZ)
            CALL SSSAVE(ISZIZ,3.*WID,-ISWIW,IDUP,-IDDN,0,0)
            CALL SSSAVE(ISZIZ,WID,-ISWIW,IDNE,-IDE,0,0)
            CALL SSSAVE(ISZIZ,WID,-ISWIW,IDNM,-IDMU,0,0)
            CALL SSSAVE(ISZIZ,3.*WID,ISWIW,-IDUP,IDDN,0,0)
            CALL SSSAVE(ISZIZ,WID,ISWIW,-IDNE,IDE,0,0)
            CALL SSSAVE(ISZIZ,WID,ISWIW,-IDNM,IDMU,0,0)
            IF (MZIZ.GT.(MWIW+AMCH+AMST)) THEN
              CALL SSSAVE(ISZIZ,3.*WID,-ISWIW,IDCH,-IDST,0,0)
              CALL SSSAVE(ISZIZ,WID,-ISWIW,IDNT,-IDTAU,0,0)
              CALL SSSAVE(ISZIZ,3.*WID,ISWIW,-IDCH,IDST,0,0)
              CALL SSSAVE(ISZIZ,WID,ISWIW,-IDNT,IDTAU,0,0)
            ENDIF
          ENDIF
C
C          zi --> wj + hc
C
          IF (MZIZ.GT.(MWIW+AMHC)) THEN
          IF (IW.EQ.1) THEN
            A=(SNW1*COSBE*V2I(IZ)-SIGN(1.,AMZISS(IZ))
     $      *SINBE*V4I(IZ))/2.
            B=(SNW1*COSBE*V2I(IZ)+SIGN(1.,AMZISS(IZ))
     $      *SINBE*V4I(IZ))/2.
          ELSE
            A=(THY*SNW2*COSBE*V1I(IZ)-SIGN(1.,AMZISS(IZ))
     $      *THX*SINBE*V3I(IZ))/2.
            B=(THY*SNW2*COSBE*V1I(IZ)+SIGN(1.,AMZISS(IZ))
     $      *THX*SINBE*V3I(IZ))/2.
          END IF
            WID=SQRT(MWIW**4+MZIZ**4+AMHC**4-2.*(MWIW*MZIZ)**2
     $      -2*(MWIW*AMHC)**2-2*(MZIZ*AMHC)**2)/8./PI/MZIZ**3
     $      *((A*A+B*B)*(MWIW*MWIW+MZIZ*MZIZ-AMHC*AMHC)/2.
     $      +(A*A-B*B)*MWIW*MZIZ)
            CALL SSSAVE(ISZIZ,WID,+ISWIW,-ISHC,0,0,0)
            CALL SSSAVE(ISZIZ,WID,-ISWIW,+ISHC,0,0,0)
          ENDIF
205     CONTINUE
C
C          zi --> zj + z
C
C          Note that if m(zi) > m(zj) + m(z), then the z terms are
C          omitted from the zi -> zj + f + fbar calculation, so there
C          is no double counting with zi -> zj + z.
C
        DO 210 JZ=1,IZ-1
          MZJZ=ABS(AMZISS(JZ))
          IF(MZIZ.GT.(MZJZ+AMZ)) THEN
            SN=-1.*SIGN(1.,AMZISS(IZ))*SIGN(1.,AMZISS(JZ))
            WID=WIJ(JZ,IZ)**2/(2.*PI)/(MZIZ)**3*SQRT(MZIZ**4+MZJZ**4
     $      +AMZ**4-2.*(MZIZ*MZJZ)**2-2.*(MZIZ*AMZ)**2-2.*(MZJZ*AMZ)**2)
     $      *((MZIZ**2+MZJZ**2-AMZ**2)/2.+((MZIZ**2-MZJZ**2)**2-AMZ**4)/
     $      2./AMZ**2-3.*SN*MZIZ*MZJZ)
            CALL SSSAVE(ISZIZ,WID,ISZ(JZ),IDZ,0,0,0)
          END IF
210     CONTINUE
C
C          zi --> zj + f + fbar
C
        DO 220 JZ=1,IZ-1
          MZJZ=ABS(AMZISS(JZ))
          IF(MZIZ.LT.FUDGE*MZJZ) GO TO 220
          FAC=1./2./MZIZ/(2.*PI)**5*PI**2*MZIZ**2
C          Leptons -- Z decay allowed, so omit Z
            TMP(1)=MZIZ
            TMP(2)=MZJZ
            TMP(4)=-SNIJ(JZ,IZ)
            TMP(6)=0.
C          zi -> zj + u + ubar
          IF (MZIZ.GT.(MZJZ+2*AMUP)) THEN
            IF (MZIZ.LT.AMULSS) THEN
            TMP(3)=AMULSS
            TERMLL=3*2*AUI(JZ)**2*AUI(IZ)**2*FAC*SSXINT(0.,SSZZF1,1.)
            ELSE
            TERMLL=0.
            END IF
            IF (MZIZ.LT.AMURSS) THEN
            TMP(3)=AMURSS
            TERMRR=3*2*BUI(JZ)**2*BUI(IZ)**2*FAC*SSXINT(0.,SSZZF1,1.)
            ELSE
            TERMRR=0.
            END IF
            IF (MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TERMZZ=3*(APU**2+BTU**2)*E**2*WIJ(JZ,IZ)**2/MZIZ
     $             *SSXINT(MZJZ,SSZZF2,(MZIZ**2+MZJZ**2)/2./MZIZ)
            ELSE
            TERMZZ=0.
            END IF
            IF (MZIZ.LT.AMULSS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TMP(3)=AMULSS
            TERMLZ=3*8*E*(APU-BTU)*WIJ(JZ,IZ)*AUI(JZ)*AUI(IZ)/MZIZ
     $      /(2*PI)**5*SSXINT(0.,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERMLZ=0.
            END IF
            IF (MZIZ.LT.AMURSS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TMP(3)=AMURSS
            TERMRZ=-3*8*E*(APU+BTU)*WIJ(JZ,IZ)*BUI(JZ)*BUI(IZ)/MZIZ
     $      /(2*PI)**5*SSXINT(0.,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERMRZ=0.
            END IF
            WID=TERMLL+TERMRR+TERMZZ+TERMLZ+TERMRZ
            CALL SSSAVE(ISZIZ,WID,ISZ(JZ),IDUP,-IDUP,0,0)
          END IF
C          zi -> zj + d + dbar
          TMP(4)=-SNIJ(JZ,IZ)
          IF (MZIZ.GT.(MZJZ+2*AMDN)) THEN
            IF (MZIZ.LT.AMDLSS) THEN
            TMP(3)=AMDLSS
            TERMLL=3*2*ADI(JZ)**2*ADI(IZ)**2*FAC*SSXINT(0.,SSZZF1,1.)
            ELSE
            TERMLL=0.
            END IF
            IF (MZIZ.LT.AMDRSS) THEN
            TMP(3)=AMDRSS
            TERMRR=3*2*BDI(JZ)**2*BDI(IZ)**2*FAC*SSXINT(0.,SSZZF1,1.)
            ELSE
            TERMRR=0.
            END IF
            IF (MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TERMZZ=3*(APD**2+BTD**2)*E**2*WIJ(JZ,IZ)**2/MZIZ
     $             *SSXINT(MZJZ,SSZZF2,(MZIZ**2+MZJZ**2)/2./MZIZ)
            ELSE
            TERMZZ=0.
            END IF
            IF (MZIZ.LT.AMDLSS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TMP(3)=AMDLSS
            TERMLZ=3*8*E*(APD-BTD)*WIJ(JZ,IZ)*ADI(JZ)*ADI(IZ)/MZIZ
     $      /(2*PI)**5*SSXINT(0.,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERMLZ=0.
            END IF
            IF (MZIZ.LT.AMDRSS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TMP(3)=AMDRSS
            TERMRZ=-3*8*E*(APD+BTD)*WIJ(JZ,IZ)*BDI(JZ)*BDI(IZ)/MZIZ
     $      /(2*PI)**5*SSXINT(0.,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERMRZ=0.
            END IF
            WID=TERMLL+TERMRR+TERMZZ+TERMLZ+TERMRZ
            CALL SSSAVE(ISZIZ,WID,ISZ(JZ),IDDN,-IDDN,0,0)
          END IF
C          zi -> zj + s + sbar
          TMP(4)=-SNIJ(JZ,IZ)
          IF (MZIZ.GT.(MZJZ+2*AMST)) THEN
            IF (MZIZ.LT.AMSLSS) THEN
            TMP(3)=AMSLSS
            TERMLL=3*2*ADI(JZ)**2*ADI(IZ)**2*FAC*SSXINT(0.,SSZZF1,1.)
            ELSE
            TERMLL=0.
            END IF
            IF (MZIZ.LT.AMSRSS) THEN
            TMP(3)=AMSRSS
            TERMRR=3*2*BDI(JZ)**2*BDI(IZ)**2*FAC*SSXINT(0.,SSZZF1,1.)
            ELSE
            TERMRR=0.
            END IF
            IF (MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TERMZZ=3*(APD**2+BTD**2)*E**2*WIJ(JZ,IZ)**2/MZIZ
     $             *SSXINT(MZJZ,SSZZF2,(MZIZ**2+MZJZ**2)/2./MZIZ)
            ELSE
            TERMZZ=0.
            END IF
            IF (MZIZ.LT.AMSLSS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TMP(3)=AMSLSS
            TERMLZ=3*8*E*(APD-BTD)*WIJ(JZ,IZ)*ADI(JZ)*ADI(IZ)/MZIZ
     $      /(2*PI)**5*SSXINT(0.,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERMLZ=0.
            END IF
            IF (MZIZ.LT.AMSRSS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TMP(3)=AMSRSS
            TERMRZ=-3*8*E*(APD+BTD)*WIJ(JZ,IZ)*BDI(JZ)*BDI(IZ)/MZIZ
     $      /(2*PI)**5*SSXINT(0.,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERMRZ=0.
            END IF
            WID=TERMLL+TERMRR+TERMZZ+TERMLZ+TERMRZ
            CALL SSSAVE(ISZIZ,WID,ISZ(JZ),IDST,-IDST,0,0)
          END IF
C          zi -> zj + c + cbar
          TMP(4)=-SNIJ(JZ,IZ)
          IF (MZIZ.GT.(MZJZ+2*AMCH)) THEN
            IF (MZIZ.LT.AMCLSS) THEN
            TMP(3)=AMCLSS
            TERMLL=3*2*AUI(JZ)**2*AUI(IZ)**2*FAC*SSXINT(0.,SSZZF1,1.)
            ELSE
            TERMLL=0.
            END IF
            IF (MZIZ.LT.AMCRSS) THEN
            TMP(3)=AMCRSS
            TERMRR=3*2*BUI(JZ)**2*BUI(IZ)**2*FAC*SSXINT(0.,SSZZF1,1.)
            ELSE
            TERMRR=0.
            END IF
            IF (MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TERMZZ=3*(APU**2+BTU**2)*E**2*WIJ(JZ,IZ)**2/MZIZ
     $             *SSXINT(MZJZ,SSZZF2,(MZIZ**2+MZJZ**2)/2./MZIZ)
            ELSE
            TERMZZ=0.
            END IF
            IF (MZIZ.LT.AMCLSS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TMP(3)=AMCLSS
            TERMLZ=3*8*E*(APU-BTU)*WIJ(JZ,IZ)*AUI(JZ)*AUI(IZ)/MZIZ
     $      /(2*PI)**5*SSXINT(0.,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERMLZ=0.
            END IF
            IF (MZIZ.LT.AMCRSS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TMP(3)=AMCRSS
            TERMRZ=-3*8*E*(APU+BTU)*WIJ(JZ,IZ)*BUI(JZ)*BUI(IZ)/MZIZ
     $      /(2*PI)**5*SSXINT(0.,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERMRZ=0.
            END IF
            WID=TERMLL+TERMRR+TERMZZ+TERMLZ+TERMRZ
            CALL SSSAVE(ISZIZ,WID,ISZ(JZ),IDCH,-IDCH,0,0)
          END IF
C          zi -> zj + b+ bbar ; mixing/yukawa effects now included!
C                              thanks to M. Drees
          FACT=1./2./(2*PI)**5/2./MZIZ
          ALIZ1=ADI(IZ)*COSB-FB*ZMIXSS(2,IZ)*SINB
          ALJZ1=ADI(JZ)*COSB-FB*ZMIXSS(2,JZ)*SINB
          ALIZ2=ADI(IZ)*SINB+FB*ZMIXSS(2,IZ)*COSB
          ALJZ2=ADI(JZ)*SINB+FB*ZMIXSS(2,JZ)*COSB
          BEIZ1=BDI(IZ)*SINB+FB*ZMIXSS(2,IZ)*COSB
          BEJZ1=BDI(JZ)*SINB+FB*ZMIXSS(2,JZ)*COSB
          BEIZ2=-BDI(IZ)*COSB+FB*ZMIXSS(2,IZ)*SINB
          BEJZ2=-BDI(JZ)*COSB+FB*ZMIXSS(2,JZ)*SINB
          SGNIJ=-SNIJ(JZ,IZ)
          XUPPER=(MZIZ**2+AMBT**2-(AMBT+MZJZ)**2)/2./MZIZ
          IF (MZIZ.GT.(MZJZ+2*AMBT)) THEN
            TMP(1)=MZIZ
            TMP(2)=AMBT
            TMP(3)=MZJZ
            TMP(4)=AMB1SS
            TMP(5)=AMB1SS
            TMP(6)=AMBT
            IF (MZIZ.LT.AMB1SS) THEN
              GLLF1=4*ALIZ1**2*((ALJZ1**2+BEJZ1**2)*
     ,             SSXINT(AMBT,SSGX1,XUPPER)+SGNIJ*ALJZ1**2*
     ,             SSXINT(AMBT,SSGX2,XUPPER))
              GRRF1=4*BEIZ1**2*((ALJZ1**2+BEJZ1**2)*
     ,             SSXINT(AMBT,SSGX1,XUPPER)+SGNIJ*BEJZ1**2*
     ,             SSXINT(AMBT,SSGX2,XUPPER))
              GLRF1=-8*ALIZ1*BEIZ1*ALJZ1*BEJZ1*
     ,               SSXINT(AMBT,SSGX8,XUPPER)
              GF1=GLLF1+GRRF1+GLRF1
            ELSE
              GF1=0.
            END IF
            IF (MZIZ.LT.AMB1SS) THEN
            TMP(4)=AMB1SS
            TMP(5)=AMB2SS
              GLGL=8*ALIZ1*ALIZ2*(ALJZ1*ALJZ2+BEJZ1*BEJZ2)*
     ,             SSXINT(AMBT,SSGX1,XUPPER)+SGNIJ*8*ALIZ1*ALIZ2*
     ,             ALJZ1*ALJZ2*SSXINT(AMBT,SSGX2,XUPPER)
              GRGR=8*BEIZ1*BEIZ2*(ALJZ1*ALJZ2+BEJZ1*BEJZ2)*
     ,             SSXINT(AMBT,SSGX1,XUPPER)+SGNIJ*8*BEIZ1*BEIZ2*
     ,             BEJZ1*BEJZ2*SSXINT(AMBT,SSGX2,XUPPER)
              GLGR=-8*ALIZ1*BEIZ2*ALJZ2*BEJZ1*
     ,              SSXINT(AMBT,SSGX8,XUPPER)
              GRGL=-8*ALIZ2*BEIZ1*ALJZ1*BEJZ2*
     ,              SSXINT(AMBT,SSGX8,XUPPER)
              GF12=GLGL+GRGR+GLGR+GRGL
            ELSE
              GF12=0.
            END IF
            IF (MZIZ.LT.AMB2SS) THEN
            TMP(4)=AMB2SS
            TMP(5)=AMB2SS
              GLLF2=4*ALIZ2**2*((ALJZ2**2+BEJZ2**2)*
     ,              SSXINT(AMBT,SSGX1,XUPPER)+SGNIJ*ALJZ2**2*
     ,              SSXINT(AMBT,SSGX2,XUPPER))
              GRRF2=4*BEIZ2**2*((ALJZ2**2+BEJZ2**2)*
     ,              SSXINT(AMBT,SSGX1,XUPPER)+SGNIJ*BEJZ2**2*
     ,              SSXINT(AMBT,SSGX2,XUPPER))
              GLRF2=-8*ALIZ2*BEIZ2*ALJZ2*BEJZ2*
     ,              SSXINT(AMBT,SSGX8,XUPPER)
              GF2=GLLF2+GRRF2+GLRF2
            ELSE
              GF2=0.
            END IF
            GF=FACT*(GF1+GF2+GF12)
            TMP(2)=MZJZ
            IF (MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TERMZZ=(APD**2+BTD**2)*E**2*WIJ(JZ,IZ)**2/MZIZ
     $       *SSXINT(MZJZ,SSZZF2,(MZIZ**2+MZJZ**2-4*AMBT**2)/2./MZIZ)
            ELSE
            TERMZZ=0.
            END IF
            IF (MZIZ.LE.(MZJZ+AMHL)) THEN
            TMP(3)=AMHL
            TMP(5)=AMHL
            TMP(4)=-SNIJ(JZ,IZ)
            TERMHL=G**2/64./PI**3/MZIZ*(AMBT*SINA*(XLIJ(JZ,IZ)+
     $        XLIJ(IZ,JZ))/AMW/COSBE)**2*
     $        SSXINT(MZJZ,SSZZF4,(MZIZ**2+MZJZ**2-4*AMBT**2)/2./MZIZ)
            ELSE
            TERMHL=0.
            END IF
            IF (MZIZ.LE.(MZJZ+AMHH)) THEN
            TMP(3)=AMHH
            TMP(5)=AMHH
            TMP(4)=-SNIJ(JZ,IZ)
            TERMHH=G**2/64./PI**3/MZIZ*(AMBT*COSA*(XHIJ(JZ,IZ)+
     $       XHIJ(IZ,JZ))/AMW/COSBE)**2*
     $       SSXINT(MZJZ,SSZZF4,(MZIZ**2+MZJZ**2-4*AMBT**2)/2./MZIZ)
            ELSE
            TERMHH=0.
            END IF
            IF (MZIZ.LE.(MZJZ+AMHH).AND.MZIZ.LE.(MZJZ+AMHL)) THEN
            TMP(3)=AMHL
            TMP(5)=AMHH
            TMP(4)=-SNIJ(JZ,IZ)
            TERMLH=2*G**2/64./PI**3/MZIZ*(AMBT/AMW/COSBE)**2*
     $            (COSA*(XHIJ(JZ,IZ)+XHIJ(IZ,JZ))*SINA*
     $       (XLIJ(JZ,IZ)+XLIJ(IZ,JZ)))*
     $       SSXINT(MZJZ,SSZZF4,(MZIZ**2+MZJZ**2-4*AMBT**2)/2./MZIZ)
            ELSE
            TERMLH=0.
            END IF
            IF (MZIZ.LE.(MZJZ+AMHA)) THEN
            TMP(3)=AMHA
            TMP(5)=AMHA
            TMP(4)=SNIJ(JZ,IZ)
            TERMHA=G**2*TANB**2/64./PI**3/MZIZ*(AMBT*(XPIJ(JZ,IZ)+
     $            XPIJ(IZ,JZ))/AMW)**2*
     $       SSXINT(MZJZ,SSZZF4,(MZIZ**2+MZJZ**2-4*AMBT**2)/2./MZIZ)
            ELSE
            TERMHA=0.
            END IF
            IF (MZIZ.LT.AMB1SS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=-SGNIJ
            TMP(3)=AMB1SS
            TERM1Z=8*E*WIJ(JZ,IZ)*(ALJZ1*ALIZ1*(APD-BTD)-
     $       BEJZ1*BEIZ1*(APD+BTD))/MZIZ
     $      /(2*PI)**5*SSXINT(4*AMBT**2,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERM1Z=0.
            END IF
            IF (MZIZ.LT.AMB2SS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=-SGNIJ
            TMP(3)=AMB2SS
            TERM2Z=8*E*WIJ(JZ,IZ)*(ALJZ2*ALIZ2*(APD-BTD)-
     $       BEJZ2*BEIZ2*(APD+BTD))/MZIZ
     $      /(2*PI)**5*SSXINT(4*AMBT**2,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERM2Z=0.
            END IF
            IF (MZIZ.LT.AMB1SS.AND.MZIZ.LT.(MZJZ+AMHL)) THEN
            TMP(3)=AMB1SS
            TMP(4)=SGNIJ
            TMP(5)=AMHL
            TERM1L=2*PI*PI*G*AMBT*SINA*SGNIJ*(XLIJ(IZ,JZ)+
     $        XLIJ(JZ,IZ))*(ALIZ1*BEJZ1+ALJZ1*BEIZ1)
     $       /MZIZ/AMW/COSBE*SSXINT(4*AMBT**2,SSZZF5,(MZIZ-MZJZ)**2)
            TERM1L=FACT*TERM1L
            ELSE
            TERM1L=0.
            END IF
            IF (MZIZ.LT.AMB2SS.AND.MZIZ.LT.(MZJZ+AMHL)) THEN
            TMP(3)=AMB2SS
            TMP(4)=SGNIJ
            TMP(5)=AMHL
            TERM2L=2*PI*PI*G*AMBT*SINA*SGNIJ*(XLIJ(IZ,JZ)+
     $        XLIJ(JZ,IZ))*(ALIZ2*BEJZ2+ALJZ2*BEIZ2)
     $       /MZIZ/AMW/COSBE*SSXINT(4*AMBT**2,SSZZF5,(MZIZ-MZJZ)**2)
            TERM2L=FACT*TERM2L
            ELSE
            TERM2L=0.
            END IF
            IF (MZIZ.LT.AMB1SS.AND.MZIZ.LT.(MZJZ+AMHH)) THEN
            TMP(3)=AMB1SS
            TMP(4)=SGNIJ
            TMP(5)=AMHH
            TERM1H=2*PI*PI*G*AMBT*COSA*SGNIJ*(XHIJ(IZ,JZ)+
     $        XHIJ(JZ,IZ))*(ALIZ1*BEJZ1+ALJZ1*BEIZ1)
     $       /MZIZ/AMW/COSBE*SSXINT(4*AMBT**2,SSZZF5,(MZIZ-MZJZ)**2)
            TERM1H=FACT*TERM1H
            ELSE
            TERM1H=0.
            END IF
            IF (MZIZ.LT.AMB2SS.AND.MZIZ.LT.(MZJZ+AMHH)) THEN
            TMP(3)=AMB2SS
            TMP(4)=SGNIJ
            TMP(5)=AMHH
            TERM2H=2*PI*PI*G*AMBT*COSA*SGNIJ*(XHIJ(IZ,JZ)+
     $        XHIJ(JZ,IZ))*(ALIZ2*BEJZ2+ALJZ2*BEIZ2)
     $       /MZIZ/AMW/COSBE*SSXINT(4*AMBT**2,SSZZF5,(MZIZ-MZJZ)**2)
            TERM2H=FACT*TERM2H
            ELSE
            TERM2H=0.
            END IF
            IF (MZIZ.LT.AMB1SS.AND.MZIZ.LT.(MZJZ+AMHA)) THEN
            TMP(3)=AMB1SS
            TMP(4)=-SGNIJ
            TMP(5)=AMHA
            TERM1A=-2*PI*PI*G*AMBT*TANB*SGNIJ*(XPIJ(IZ,JZ)+
     $        XPIJ(JZ,IZ))*(ALIZ1*BEJZ1+ALJZ1*BEIZ1)
     $        /MZIZ/AMW*SSXINT(4*AMBT**2,SSZZF5,(MZIZ-MZJZ)**2)
            TERM1A=FACT*TERM1A
            ELSE
            TERM1A=0.
            END IF
            IF (MZIZ.LT.AMB2SS.AND.MZIZ.LT.(MZJZ+AMHA)) THEN
            TMP(3)=AMB2SS
            TMP(4)=-SGNIJ
            TMP(5)=AMHA
            TERM2A=-2*PI*PI*G*AMBT*TANB*SGNIJ*(XPIJ(IZ,JZ)+
     $        XPIJ(JZ,IZ))*(ALIZ2*BEJZ2+ALJZ2*BEIZ2)
     $        /MZIZ/AMW*SSXINT(4*AMBT**2,SSZZF5,(MZIZ-MZJZ)**2)
            TERM2A=FACT*TERM2A
            ELSE
            TERM2A=0.
            END IF
            WID=3*(GF+TERMZZ+TERMHL+TERMHH+TERMLH+TERMHA+TERM1Z+
     $        TERM2Z+TERM1L+TERM2L+TERM1H+TERM2H+TERM1A+TERM2A)
            CALL SSSAVE(ISZIZ,WID,ISZ(JZ),IDBT,-IDBT,0,0)
          END IF
C          zi -> zj + e + ebar
          TMP(2)=MZJZ
          TMP(4)=-SNIJ(JZ,IZ)
          TMP(6)=0.
          IF (MZIZ.GT.(MZJZ+2*AME)) THEN
            IF (MZIZ.LT.AMELSS) THEN
            TMP(3)=AMELSS
            TERMLL=2*ALI(JZ)**2*ALI(IZ)**2*FAC*SSXINT(0.,SSZZF1,1.)
            ELSE
            TERMLL=0.
            END IF
            IF (MZIZ.LT.AMERSS) THEN
            TMP(3)=AMERSS
            TERMRR=2*BLI(JZ)**2*BLI(IZ)**2*FAC*SSXINT(0.,SSZZF1,1.)
            ELSE
            TERMRR=0.
            END IF
            IF (MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TERMZZ=(APL**2+BTL**2)*E**2*WIJ(JZ,IZ)**2/MZIZ
     $             *SSXINT(MZJZ,SSZZF2,(MZIZ**2+MZJZ**2)/2./MZIZ)
            ELSE
            TERMZZ=0.
            END IF
            IF (MZIZ.LT.AMELSS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TMP(3)=AMELSS
            TERMLZ=8*E*(APL-BTL)*WIJ(JZ,IZ)*ALI(JZ)*ALI(IZ)/MZIZ
     $      /(2*PI)**5*SSXINT(0.,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERMLZ=0.
            END IF
            IF (MZIZ.LT.AMERSS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TMP(3)=AMERSS
            TERMRZ=-8*E*(APL+BTL)*WIJ(JZ,IZ)*BLI(JZ)*BLI(IZ)/MZIZ
     $      /(2*PI)**5*SSXINT(0.,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERMRZ=0.
            END IF
            WID=TERMLL+TERMRR+TERMZZ+TERMLZ+TERMRZ
            CALL SSSAVE(ISZIZ,WID,ISZ(JZ),IDE,-IDE,0,0)
          END IF
C          zi -> zj + mu + mubar
          TMP(4)=-SNIJ(JZ,IZ)
          IF (MZIZ.GT.(MZJZ+2*AMMU)) THEN
            IF (MZIZ.LT.AMMLSS) THEN
            TMP(3)=AMMLSS
            TERMLL=2*ALI(JZ)**2*ALI(IZ)**2*FAC*SSXINT(0.,SSZZF1,1.)
            ELSE
            TERMLL=0.
            END IF
            IF (MZIZ.LT.AMMRSS) THEN
            TMP(3)=AMMRSS
            TERMRR=2*BLI(JZ)**2*BLI(IZ)**2*FAC*SSXINT(0.,SSZZF1,1.)
            ELSE
            TERMRR=0.
            END IF
            IF (MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TERMZZ=(APL**2+BTL**2)*E**2*WIJ(JZ,IZ)**2/MZIZ
     $             *SSXINT(MZJZ,SSZZF2,(MZIZ**2+MZJZ**2)/2./MZIZ)
            ELSE
            TERMZZ=0.
            END IF
            IF (MZIZ.LT.AMMLSS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TMP(3)=AMMLSS
            TERMLZ=8*E*(APL-BTL)*WIJ(JZ,IZ)*ALI(JZ)*ALI(IZ)/MZIZ
     $      /(2*PI)**5*SSXINT(0.,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERMLZ=0.
            END IF
            IF (MZIZ.LT.AMMRSS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TMP(3)=AMMRSS
            TERMRZ=-8*E*(APL+BTL)*WIJ(JZ,IZ)*BLI(JZ)*BLI(IZ)/MZIZ
     $      /(2*PI)**5*SSXINT(0.,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERMRZ=0.
            END IF
            WID=TERMLL+TERMRR+TERMZZ+TERMLZ+TERMRZ
            CALL SSSAVE(ISZIZ,WID,ISZ(JZ),IDMU,-IDMU,0,0)
          END IF
C          zi -> zj + tau + taubar.
C          Mixing/yukawa effects now included thanks to M. Drees
          ALIZ1=-ALI(IZ)*COSL-FL*ZMIXSS(2,IZ)*SINL
          ALJZ1=-ALI(JZ)*COSL-FL*ZMIXSS(2,JZ)*SINL
          ALIZ2=-ALI(IZ)*SINL+FL*ZMIXSS(2,IZ)*COSL
          ALJZ2=-ALI(JZ)*SINL+FL*ZMIXSS(2,JZ)*COSL
          BEIZ1=BLI(IZ)*SINL+FL*ZMIXSS(2,IZ)*COSL
          BEJZ1=BLI(JZ)*SINL+FL*ZMIXSS(2,JZ)*COSL
          BEIZ2=-BLI(IZ)*COSL+FL*ZMIXSS(2,IZ)*SINL
          BEJZ2=-BLI(JZ)*COSL+FL*ZMIXSS(2,JZ)*SINL
          SGNIJ=-SNIJ(JZ,IZ)
          XUPPER=(MZIZ**2+AMTAU**2-(AMTAU+MZJZ)**2)/2./MZIZ
C          Polarization for stau_i -> z2ss+tau, z3ss+tau, z4ss+tau.
C          See below for z1ss+tau.
          IF(JZ.EQ.1) THEN
            PTAU1(IZ)=(BEIZ1**2-ALIZ1**2)/(BEIZ1**2+ALIZ1**2)
            PTAU2(IZ)=(BEIZ2**2-ALIZ2**2)/(BEIZ2**2+ALIZ2**2)
          ENDIF
          IF (MZIZ.GT.(MZJZ+2*AMTAU)) THEN
            TMP(1)=MZIZ
            TMP(2)=AMTAU
            TMP(3)=MZJZ
            TMP(4)=AML1SS
            TMP(5)=AML1SS
            TMP(6)=AMTAU
            IF (MZIZ.LT.AML1SS) THEN
              GLLF1=4*ALIZ1**2*((ALJZ1**2+BEJZ1**2)*
     ,             SSXINT(AMTAU,SSGX1,XUPPER)+SGNIJ*ALJZ1**2*
     ,             SSXINT(AMTAU,SSGX2,XUPPER))
              GLLF1L=FACT*4*ALIZ1**2*(ALJZ1**2*
     ,             SSXINT(AMTAU,SSGX1,XUPPER)+SGNIJ*ALJZ1**2*
     ,             SSXINT(AMTAU,SSGX2,XUPPER))
              GRRF1=4*BEIZ1**2*((ALJZ1**2+BEJZ1**2)*
     ,             SSXINT(AMTAU,SSGX1,XUPPER)+SGNIJ*BEJZ1**2*
     ,             SSXINT(AMTAU,SSGX2,XUPPER))
              GRRF1R=FACT*4*BEIZ1**2*(BEJZ1**2*
     ,             SSXINT(AMTAU,SSGX1,XUPPER)+SGNIJ*BEJZ1**2*
     ,             SSXINT(AMTAU,SSGX2,XUPPER))
              GLRF1=-8*ALIZ1*BEIZ1*ALJZ1*BEJZ1*
     ,               SSXINT(AMTAU,SSGX8,XUPPER)
              GF1=GLLF1+GRRF1+GLRF1
            ELSE
              GLLF1L=0.
              GRRF1R=0.
              GF1=0.
            END IF
            IF (MZIZ.LT.AML1SS) THEN
            TMP(4)=AML1SS
            TMP(5)=AML2SS
              GLGL=8*ALIZ1*ALIZ2*(ALJZ1*ALJZ2+BEJZ1*BEJZ2)*
     ,             SSXINT(AMTAU,SSGX1,XUPPER)+SGNIJ*8*ALIZ1*ALIZ2*
     ,             ALJZ1*ALJZ2*SSXINT(AMTAU,SSGX2,XUPPER)
              GLGLL=FACT*(8*ALIZ1*ALIZ2*ALJZ1*ALJZ2*
     ,             SSXINT(AMTAU,SSGX1,XUPPER)+SGNIJ*8*ALIZ1*ALIZ2*
     ,             ALJZ1*ALJZ2*SSXINT(AMTAU,SSGX2,XUPPER))
              GRGR=8*BEIZ1*BEIZ2*(ALJZ1*ALJZ2+BEJZ1*BEJZ2)*
     ,             SSXINT(AMTAU,SSGX1,XUPPER)+SGNIJ*8*BEIZ1*BEIZ2*
     ,             BEJZ1*BEJZ2*SSXINT(AMTAU,SSGX2,XUPPER)
              GRGRR=FACT*(8*BEIZ1*BEIZ2*BEJZ1*BEJZ2*
     ,             SSXINT(AMTAU,SSGX1,XUPPER)+SGNIJ*8*BEIZ1*BEIZ2*
     ,             BEJZ1*BEJZ2*SSXINT(AMTAU,SSGX2,XUPPER))
              GLGR=-8*ALIZ1*BEIZ2*ALJZ2*BEJZ1*
     ,              SSXINT(AMTAU,SSGX8,XUPPER)
              GRGL=-8*ALIZ2*BEIZ1*ALJZ1*BEJZ2*
     ,              SSXINT(AMTAU,SSGX8,XUPPER)
              GF12=GLGL+GRGR+GLGR+GRGL
            ELSE
              GLGLL=0.
              GRGRR=0.
              GF12=0.
            END IF
            IF (MZIZ.LT.AML2SS) THEN
            TMP(4)=AML2SS
            TMP(5)=AML2SS
              GLLF2=4*ALIZ2**2*((ALJZ2**2+BEJZ2**2)*
     ,              SSXINT(AMTAU,SSGX1,XUPPER)+SGNIJ*ALJZ2**2*
     ,              SSXINT(AMTAU,SSGX2,XUPPER))
              GLLF2L=FACT*4*ALIZ2**2*(ALJZ2**2*
     ,              SSXINT(AMTAU,SSGX1,XUPPER)+SGNIJ*ALJZ2**2*
     ,              SSXINT(AMTAU,SSGX2,XUPPER))
              GRRF2=4*BEIZ2**2*((ALJZ2**2+BEJZ2**2)*
     ,              SSXINT(AMTAU,SSGX1,XUPPER)+SGNIJ*BEJZ2**2*
     ,              SSXINT(AMTAU,SSGX2,XUPPER))
              GRRF2R=FACT*4*BEIZ2**2*(BEJZ2**2*
     ,              SSXINT(AMTAU,SSGX1,XUPPER)+SGNIJ*BEJZ2**2*
     ,              SSXINT(AMTAU,SSGX2,XUPPER))
              GLRF2=-8*ALIZ2*BEIZ2*ALJZ2*BEJZ2*
     ,              SSXINT(AMTAU,SSGX8,XUPPER)
              GF2=GLLF2+GRRF2+GLRF2
            ELSE
              GLLF2L=0.
              GRRF2R=0.
              GF2=0.
            END IF
            GF=FACT*(GF1+GF2+GF12)
            TMP(2)=MZJZ
            IF (MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TERMZZ=(APL**2+BTL**2)*E**2*WIJ(JZ,IZ)**2/MZIZ
     $      *SSXINT(MZJZ,SSZZF2,(MZIZ**2+MZJZ**2-4*AMTAU**2)/2./MZIZ)
            TMZZRL=TERMZZ*(APL+BTL)**2/2./(APL**2+BTL**2)
            TMZZLR=TERMZZ*(APL-BTL)**2/2./(APL**2+BTL**2)
            ELSE
            TERMZZ=0.
            TMZZRL=0.
            TMZZLR=0.
            END IF
            IF (MZIZ.LE.(MZJZ+AMHL)) THEN
            TMP(3)=AMHL
            TMP(5)=AMHL
            TMP(4)=-SNIJ(JZ,IZ)
            TERMHL=G**2/64./PI**3/MZIZ*(AMTAU*SINA*(XLIJ(JZ,IZ)+
     $         XLIJ(IZ,JZ))/AMW/COSBE)**2*
     $      SSXINT(MZJZ,SSZZF4,(MZIZ**2+MZJZ**2-4*AMTAU**2)/2./MZIZ)
            ELSE
            TERMHL=0.
            END IF
            IF (MZIZ.LE.(MZJZ+AMHH)) THEN
            TMP(3)=AMHH
            TMP(5)=AMHH
            TMP(4)=-SNIJ(JZ,IZ)
            TERMHH=G**2/64./PI**3/MZIZ*(AMTAU*COSA*(XHIJ(JZ,IZ)+
     $            XHIJ(IZ,JZ))/AMW/COSBE)**2*
     $      SSXINT(MZJZ,SSZZF4,(MZIZ**2+MZJZ**2-4*AMTAU**2)/2./MZIZ)
            ELSE
            TERMHH=0.
            END IF
            IF (MZIZ.LE.(MZJZ+AMHH).AND.MZIZ.LE.(MZJZ+AMHL)) THEN
            TMP(3)=AMHL
            TMP(5)=AMHH
            TMP(4)=-SNIJ(JZ,IZ)
            TERMLH=2*G**2/64./PI**3/MZIZ*(AMTAU/AMW/COSBE)**2*
     $            (COSA*(XHIJ(JZ,IZ)+XHIJ(IZ,JZ))*SINA*
     $             (XLIJ(JZ,IZ)+XLIJ(IZ,JZ)))*
     $      SSXINT(MZJZ,SSZZF4,(MZIZ**2+MZJZ**2-4*AMTAU**2)/2./MZIZ)
            ELSE
            TERMLH=0.
            END IF
            IF (MZIZ.LE.(MZJZ+AMHA)) THEN
            TMP(3)=AMHA
            TMP(5)=AMHA
            TMP(4)=SNIJ(JZ,IZ)
            TERMHA=G**2*TANB**2/64./PI**3/MZIZ*(AMTAU*(XPIJ(JZ,IZ)+
     $            XPIJ(IZ,JZ))/AMW)**2*
     $      SSXINT(MZJZ,SSZZF4,(MZIZ**2+MZJZ**2-4*AMTAU**2)/2./MZIZ)
            ELSE
            TERMHA=0.
            END IF
            IF (MZIZ.LT.AML1SS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=-SGNIJ
            TMP(3)=AML1SS
            TERM1Z=8*E*WIJ(JZ,IZ)*(ALJZ1*ALIZ1*(APL-BTL)-
     $       BEJZ1*BEIZ1*(APL+BTL))/MZIZ
     $      /(2*PI)**5*SSXINT(4*AMTAU**2,SSZZF3,(MZIZ-MZJZ)**2)
            TM1ZRL=-8*E*WIJ(JZ,IZ)*BEJZ1*BEIZ1*(APL+BTL)/MZIZ
     $      /(2*PI)**5*SSXINT(4*AMTAU**2,SSZZF3,(MZIZ-MZJZ)**2)
            TM1ZLR=8*E*WIJ(JZ,IZ)*ALJZ1*ALIZ1*(APL-BTL)/MZIZ
     $      /(2*PI)**5*SSXINT(4*AMTAU**2,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERM1Z=0.
            TM1ZRL=0.
            TM1ZLR=0.
            END IF
            IF (MZIZ.LT.AML2SS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=-SGNIJ
            TMP(3)=AML2SS
            TERM2Z=8*E*WIJ(JZ,IZ)*(ALJZ2*ALIZ2*(APL-BTL)-
     $       BEJZ2*BEIZ2*(APL+BTL))/MZIZ
     $      /(2*PI)**5*SSXINT(4*AMTAU**2,SSZZF3,(MZIZ-MZJZ)**2)
            TM2ZRL=-8*E*WIJ(JZ,IZ)*BEJZ2*BEIZ2*(APL+BTL)/MZIZ
     $      /(2*PI)**5*SSXINT(4*AMTAU**2,SSZZF3,(MZIZ-MZJZ)**2)
            TM2ZLR=8*E*WIJ(JZ,IZ)*ALJZ2*ALIZ2*(APL-BTL)/MZIZ
     $      /(2*PI)**5*SSXINT(4*AMTAU**2,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERM2Z=0.
            TM2ZRL=0.
            TM2ZLR=0.
            END IF
            IF (MZIZ.LT.AML1SS.AND.MZIZ.LT.(MZJZ+AMHL)) THEN
            TMP(3)=AML1SS
            TMP(4)=SGNIJ
            TMP(5)=AMHL
            TERM1L=2*PI*PI*G*AMTAU*SINA*SGNIJ*(XLIJ(IZ,JZ)+
     $        XLIJ(JZ,IZ))*(ALIZ1*BEJZ1+ALJZ1*BEIZ1)
     $      /MZIZ/AMW/COSBE*SSXINT(4*AMTAU**2,SSZZF5,(MZIZ-MZJZ)**2)
            TERM1L=FACT*TERM1L
            ELSE
            TERM1L=0.
            END IF
            IF (MZIZ.LT.AML2SS.AND.MZIZ.LT.(MZJZ+AMHL)) THEN
            TMP(3)=AML2SS
            TMP(4)=SGNIJ
            TMP(5)=AMHL
            TERM2L=2*PI*PI*G*AMTAU*SINA*SGNIJ*(XLIJ(IZ,JZ)+
     $        XLIJ(JZ,IZ))*(ALIZ2*BEJZ2+ALJZ2*BEIZ2)
     $      /MZIZ/AMW/COSBE*SSXINT(4*AMTAU**2,SSZZF5,(MZIZ-MZJZ)**2)
            TERM2L=FACT*TERM2L
            ELSE
            TERM2L=0.
            END IF
            IF (MZIZ.LT.AML1SS.AND.MZIZ.LT.(MZJZ+AMHH)) THEN
            TMP(3)=AML1SS
            TMP(4)=SGNIJ
            TMP(5)=AMHH
            TERM1H=2*PI*PI*G*AMTAU*COSA*SGNIJ*(XHIJ(IZ,JZ)+
     $        XHIJ(JZ,IZ))*(ALIZ1*BEJZ1+ALJZ1*BEIZ1)
     $      /MZIZ/AMW/COSBE*SSXINT(4*AMTAU**2,SSZZF5,(MZIZ-MZJZ)**2)
            TERM1H=FACT*TERM1H
            ELSE
            TERM1H=0.
            END IF
            IF (MZIZ.LT.AML2SS.AND.MZIZ.LT.(MZJZ+AMHH)) THEN
            TMP(3)=AML2SS
            TMP(4)=SGNIJ
            TMP(5)=AMHH
            TERM2H=2*PI*PI*G*AMTAU*COSA*SGNIJ*(XHIJ(IZ,JZ)+
     $        XHIJ(JZ,IZ))*(ALIZ2*BEJZ2+ALJZ2*BEIZ2)
     $    /MZIZ/AMW/COSBE*SSXINT(4*AMTAU**2,SSZZF5,(MZIZ-MZJZ)**2)
            TERM2H=FACT*TERM2H
            ELSE
            TERM2H=0.
            END IF
            IF (MZIZ.LT.AML1SS.AND.MZIZ.LT.(MZJZ+AMHA)) THEN
            TMP(3)=AML1SS
            TMP(4)=-SGNIJ
            TMP(5)=AMHA
            TERM1A=-2*PI*PI*G*AMTAU*TANB*SGNIJ*(XPIJ(IZ,JZ)+
     $        XPIJ(JZ,IZ))*(ALIZ1*BEJZ1+ALJZ1*BEIZ1)
     $       /MZIZ/AMW*SSXINT(4*AMTAU**2,SSZZF5,(MZIZ-MZJZ)**2)
            TERM1A=FACT*TERM1A
            ELSE
            TERM1A=0.
            END IF
            IF (MZIZ.LT.AML2SS.AND.MZIZ.LT.(MZJZ+AMHA)) THEN
            TMP(3)=AML2SS
            TMP(4)=-SGNIJ
            TMP(5)=AMHA
            TERM2A=-2*PI*PI*G*AMTAU*TANB*SGNIJ*(XPIJ(IZ,JZ)+
     $        XPIJ(JZ,IZ))*(ALIZ2*BEJZ2+ALJZ2*BEIZ2)
     $       /MZIZ/AMW*SSXINT(4*AMTAU**2,SSZZF5,(MZIZ-MZJZ)**2)
            TERM2A=FACT*TERM2A
            ELSE
            TERM2A=0.
            END IF
            WID=GF+TERMZZ+TERMHL+TERMHH+TERMLH+TERMHA+TERM1Z+
     $        TERM2Z+TERM1L+TERM2L+TERM1H+TERM2H+TERM1A+TERM2A
C              tau polarization for 3-body z2 -> z1 tau tau
            IF (IZ.EQ.2.AND.JZ.EQ.1) THEN
              PTAUZZ=(GRRF1R+GRGRR+GRRF2R+TMZZRL+TM1ZRL+TM2ZRL-
     $               (GLLF1L+GLGLL+GLLF2L+TMZZLR+TM1ZLR+TM2ZLR))
     $               /WID
            END IF
            CALL SSSAVE(ISZIZ,WID,ISZ(JZ),IDTAU,-IDTAU,0,0)
          END IF
C          zi -> zj + nu_e + nu_e bar
          TMP(6)=0.
          IF (MZIZ.GT.MZJZ) THEN
            IF (MZIZ.LT.AMN1SS) THEN
            TMP(4)=-SNIJ(JZ,IZ)
            TMP(3)=AMN1SS
            TERMLL=2*ANI(JZ)**2*ANI(IZ)**2*FAC*SSXINT(0.,SSZZF1,1.)
            ELSE
            TERMLL=0.
            END IF
            IF (MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TERMZZ=(APN**2+BTN**2)*E**2*WIJ(JZ,IZ)**2/MZIZ
     $             *SSXINT(MZJZ,SSZZF2,(MZIZ**2+MZJZ**2)/2./MZIZ)
            ELSE
            TERMZZ=0.
            END IF
            IF (MZIZ.LT.AMN1SS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TMP(3)=AMN1SS
            TERMLZ=8*E*(APN-BTN)*WIJ(JZ,IZ)*ANI(JZ)*ANI(IZ)/MZIZ
     $      /(2*PI)**5*SSXINT(0.,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERMLZ=0.
            END IF
            WID=TERMLL+TERMZZ+TERMLZ
            CALL SSSAVE(ISZIZ,WID,ISZ(JZ),IDNE,-IDNE,0,0)
          END IF
C          zi -> zj + nu_mu + nu_mu bar
          IF (MZIZ.GT.MZJZ) THEN
            IF (MZIZ.LT.AMN2SS) THEN
            TMP(4)=-SNIJ(JZ,IZ)
            TMP(3)=AMN2SS
            TERMLL=2*ANI(JZ)**2*ANI(IZ)**2*FAC*SSXINT(0.,SSZZF1,1.)
            ELSE
            TERMLL=0.
            END IF
            IF (MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TERMZZ=(APN**2+BTN**2)*E**2*WIJ(JZ,IZ)**2/MZIZ
     $             *SSXINT(MZJZ,SSZZF2,(MZIZ**2+MZJZ**2)/2./MZIZ)
            ELSE
            TERMZZ=0.
            END IF
            IF (MZIZ.LT.AMN2SS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TMP(3)=AMN2SS
            TERMLZ=8*E*(APN-BTN)*WIJ(JZ,IZ)*ANI(JZ)*ANI(IZ)/MZIZ
     $      /(2*PI)**5*SSXINT(0.,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERMLZ=0.
            END IF
            WID=TERMLL+TERMZZ+TERMLZ
            CALL SSSAVE(ISZIZ,WID,ISZ(JZ),IDNM,-IDNM,0,0)
          END IF
C          zi -> zj + nu_tau + nu_tau bar
          IF (MZIZ.GT.MZJZ) THEN
            IF (MZIZ.LT.AMN3SS) THEN
            TMP(4)=-SNIJ(JZ,IZ)
            TMP(3)=AMN3SS
            TERMLL=2*ANI(JZ)**2*ANI(IZ)**2*FAC*SSXINT(0.,SSZZF1,1.)
            ELSE
            TERMLL=0.
            END IF
            IF (MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TERMZZ=(APN**2+BTN**2)*E**2*WIJ(JZ,IZ)**2/MZIZ
     $             *SSXINT(MZJZ,SSZZF2,(MZIZ**2+MZJZ**2)/2./MZIZ)
            ELSE
            TERMZZ=0.
            END IF
            IF (MZIZ.LT.AMN3SS.AND.MZIZ.LT.(MZJZ+AMZ)) THEN
            TMP(4)=+SNIJ(JZ,IZ)
            TMP(3)=AMN3SS
            TERMLZ=8*E*(APN-BTN)*WIJ(JZ,IZ)*ANI(JZ)*ANI(IZ)/MZIZ
     $      /(2*PI)**5*SSXINT(0.,SSZZF3,(MZIZ-MZJZ)**2)
            ELSE
            TERMLZ=0.
            END IF
            WID=TERMLL+TERMZZ+TERMLZ
            CALL SSSAVE(ISZIZ,WID,ISZ(JZ),IDNT,-IDNT,0,0)
          END IF
220     CONTINUE
C
C          zi --> zj + higgs
C
        DO 230 JZ=1,IZ-1
C          zi --> zj + hl
          MZJZ=ABS(AMZISS(JZ))
          IF (MZIZ.GT.(MZJZ+AMHL)) THEN
            SN=SIGN(1.,AMZISS(JZ))*SIGN(1.,AMZISS(IZ))
            WID=(XLIJ(JZ,IZ)+XLIJ(IZ,JZ))**2/8./PI/(MZIZ)**3
     $      *SQRT(MZIZ**4+MZJZ**4+AMHL**4-2.*(MZIZ*MZJZ)**2
     $      -2.*(MZIZ*AMHL)**2-2.*(MZJZ*AMHL)**2)*((MZIZ**2+MZJZ**2
     $      -AMHL**2)/2.+SN*MZIZ*MZJZ)
            CALL SSSAVE(ISZIZ,WID,ISZ(JZ),ISHL,0,0,0)
          END IF
C          zi --> zj + hh
          IF (MZIZ.GT.(MZJZ+AMHH)) THEN
            SN=SIGN(1.,AMZISS(JZ))*SIGN(1.,AMZISS(IZ))
            WID=(HIJ(JZ,IZ)+HIJ(IZ,JZ))**2/8./PI/(MZIZ)**3
     $      *SQRT(MZIZ**4+MZJZ**4+AMHH**4-2.*(MZIZ*MZJZ)**2
     $      -2.*(MZIZ*AMHH)**2-2.*(MZJZ*AMHH)**2)
     $      *((MZIZ**2+MZJZ**2-AMHH**2)/2.+SN*MZIZ*MZJZ)
            CALL SSSAVE(ISZIZ,WID,ISZ(JZ),ISHH,0,0,0)
          END IF
C          zi --> zj + ha
          IF (MZIZ.GT.(MZJZ+AMHA)) THEN
            SN=-SIGN(1.,AMZISS(JZ))*SIGN(1.,AMZISS(IZ))
            WID=(XPIJ(IZ,JZ)+XPIJ(JZ,IZ))**2/8./PI/(MZIZ)**3
     $      *SQRT(MZIZ**4+MZJZ**4+AMHA**4-2.*(MZIZ*MZJZ)**2
     $      -2.*(MZIZ*AMHA)**2-2.*(MZJZ*AMHA)**2)*((MZIZ**2+MZJZ**2
     $      -AMHA**2)/2.+SN*MZIZ*MZJZ)
            CALL SSSAVE(ISZIZ,WID,ISZ(JZ),ISHA,0,0,0)
          END IF
230     CONTINUE
200   CONTINUE
C
C          zi --> squark + qbar; enlarge to include Z1 decays
C                 in case of models with light gravitino
C
      DO 245 IZ=1,4
        MZIZ=ABS(AMZISS(IZ))
        ISZIZ=ISZ(IZ)
C          left squarks
        IF (MZIZ.GT.(AMULSS+AMUP)) THEN
          WID=3*AUI(IZ)**2*(MZIZ**2+AMUP**2-AMULSS**2)/MZIZ**3/
     $         32./PI*SQRT(SSXLAM(MZIZ**2,AMUP**2,AMULSS**2))
          CALL SSSAVE(ISZIZ,WID,ISUPL,-IDUP,0,0,0)
          CALL SSSAVE(ISZIZ,WID,-ISUPL,IDUP,0,0,0)
        ENDIF
        IF (MZIZ.GT.(AMDLSS+AMDN)) THEN
          WID=3*ADI(IZ)**2*(MZIZ**2+AMDN**2-AMDLSS**2)/MZIZ**3/
     $         32./PI*SQRT(SSXLAM(MZIZ**2,AMDN**2,AMDLSS**2))
          CALL SSSAVE(ISZIZ,WID,ISDNL,-IDDN,0,0,0)
          CALL SSSAVE(ISZIZ,WID,-ISDNL,IDDN,0,0,0)
        END IF
        IF (MZIZ.GT.(AMSLSS+AMST)) THEN
          WID=3*ADI(IZ)**2*(MZIZ**2+AMST**2-AMSLSS**2)/MZIZ**3/
     $         32./PI*SQRT(SSXLAM(MZIZ**2,AMST**2,AMSLSS**2))
          CALL SSSAVE(ISZIZ,WID,ISSTL,-IDST,0,0,0)
          CALL SSSAVE(ISZIZ,WID,-ISSTL,IDST,0,0,0)
        END IF
        IF (MZIZ.GT.(AMCLSS+AMCH)) THEN
          WID=3*AUI(IZ)**2*(MZIZ**2+AMCH**2-AMCLSS**2)/MZIZ**3/
     $         32./PI*SQRT(SSXLAM(MZIZ**2,AMCH**2,AMCLSS**2))
          CALL SSSAVE(ISZIZ,WID,ISCHL,-IDCH,0,0,0)
          CALL SSSAVE(ISZIZ,WID,-ISCHL,IDCH,0,0,0)
        ENDIF
C          right squarks
        IF (MZIZ.GT.(AMURSS+AMUP)) THEN
          WID=3*BUI(IZ)**2*(MZIZ**2+AMUP**2-AMURSS**2)/MZIZ**3/
     $         32./PI*SQRT(SSXLAM(MZIZ**2,AMUP**2,AMURSS**2))
          CALL SSSAVE(ISZIZ,WID,ISUPR,-IDUP,0,0,0)
          CALL SSSAVE(ISZIZ,WID,-ISUPR,IDUP,0,0,0)
        END IF
        IF (MZIZ.GT.(AMDRSS+AMDN)) THEN
          WID=3*BDI(IZ)**2*(MZIZ**2+AMDN**2-AMDRSS**2)/MZIZ**3/
     $         32./PI*SQRT(SSXLAM(MZIZ**2,AMDN**2,AMDRSS**2))
          CALL SSSAVE(ISZIZ,WID,ISDNR,-IDDN,0,0,0)
          CALL SSSAVE(ISZIZ,WID,-ISDNR,IDDN,0,0,0)
        END IF
        IF (MZIZ.GT.(AMSRSS+AMST)) THEN
          WID=3*BDI(IZ)**2*(MZIZ**2+AMST**2-AMSRSS**2)/MZIZ**3/
     $         32./PI*SQRT(SSXLAM(MZIZ**2,AMST**2,AMSRSS**2))
          CALL SSSAVE(ISZIZ,WID,ISSTR,-IDST,0,0,0)
          CALL SSSAVE(ISZIZ,WID,-ISSTR,IDST,0,0,0)
        END IF
        IF(MZIZ.GT.(AMCRSS+AMCH)) THEN
          WID=3*BUI(IZ)**2*(MZIZ**2+AMCH**2-AMCRSS**2)/MZIZ**3/
     $         32./PI*SQRT(SSXLAM(MZIZ**2,AMCH**2,AMCRSS**2))
            CALL SSSAVE(ISZIZ,WID,ISCHR,-IDCH,0,0,0)
            CALL SSSAVE(ISZIZ,WID,-ISCHR,IDCH,0,0,0)
        ENDIF
C          z_i --> sbottom + bottom
C
        SNZI=SIGN(1.,AMZISS(IZ))
        IF (SNZI.EQ.1.) THEN
           THIZ=0.
        ELSE
           THIZ=1.
        END IF
        ZAUIZ=ZI**(THIZ-1.)*SNZI
     $  *(-G/SR2*ZMIXSS(3,IZ)-GP/3./SR2*ZMIXSS(4,IZ))
        ZBUIZ=ZI**(THIZ-1.)*4*GP*ZMIXSS(4,IZ)/3./SR2
        ZADIZ=ZI**(THIZ-1.)*SNZI
     $  *(G/SR2*ZMIXSS(3,IZ)-GP/3./SR2*ZMIXSS(4,IZ))
        ZBDIZ=-2*ZI**(THIZ-1.)*GP*ZMIXSS(4,IZ)/3./SR2
        ZALIZ=ZI**(THIZ-1.)*SNZI
     $  *(G/SR2*ZMIXSS(3,IZ)+GP/SR2*ZMIXSS(4,IZ))
        ZBLIZ=-1*ZI**(THIZ-1.)*SR2*GP*ZMIXSS(4,IZ)
        ZPP=ZI**THIZ
        ZPM=(-ZI)**THIZ
        IF(MZIZ.GT.(AMB1SS+AMBT)) THEN
          ZA=((ZI*ZADIZ-ZPP*FB*ZMIXSS(2,IZ))*COSB
     $     -(ZI*ZBDIZ-ZPM*FB*ZMIXSS(2,IZ))*SINB)/2.
          ZB=((-ZI*ZADIZ-ZPP*FB*ZMIXSS(2,IZ))*COSB
     $     -(ZI*ZBDIZ+ZPM*FB*ZMIXSS(2,IZ))*SINB)/2.
          AS=ZA*CONJG(ZA)
          BS=ZB*CONJG(ZB)
          WID=3*(AS*((AMBT+MZIZ)**2-AMB1SS**2)+BS*((MZIZ-AMBT)**2-
     $     AMB1SS**2))/16./PI/MZIZ**3*
     $     SQRT(SSXLAM(MZIZ**2,AMB1SS**2,AMBT**2))
            CALL SSSAVE(ISZIZ,WID,ISBT1,-IDBT,0,0,0)
            CALL SSSAVE(ISZIZ,WID,-ISBT1,IDBT,0,0,0)
        ENDIF
        IF(MZIZ.GT.(AMB2SS+AMBT)) THEN
          ZA=((ZI*ZADIZ-ZPP*FB*ZMIXSS(2,IZ))*SINB
     $     +(ZI*ZBDIZ-ZPM*FB*ZMIXSS(2,IZ))*COSB)/2.
          ZB=((-ZI*ZADIZ-ZPP*FB*ZMIXSS(2,IZ))*SINB
     $     +(ZI*ZBDIZ+ZPM*FB*ZMIXSS(2,IZ))*COSB)/2.
          AS=ZA*CONJG(ZA)
          BS=ZB*CONJG(ZB)
          WID=3*(AS*((AMBT+MZIZ)**2-AMB2SS**2)+BS*((MZIZ-AMBT)**2-
     $     AMB2SS**2))/16./PI/MZIZ**3*
     $     SQRT(SSXLAM(MZIZ**2,AMB2SS**2,AMBT**2))
            CALL SSSAVE(ISZIZ,WID,ISBT2,-IDBT,0,0,0)
            CALL SSSAVE(ISZIZ,WID,-ISBT2,IDBT,0,0,0)
        ENDIF
C          z_i --> stop + top
C
        IF(MZIZ.GT.AMT1SS+AMTP) THEN
          ZA=((ZI*ZAUIZ-ZPP*FT*ZMIXSS(1,IZ))*COST
     $     -(ZI*ZBUIZ-ZPM*FT*ZMIXSS(1,IZ))*SINT)/2.
          ZB=((-ZI*ZAUIZ-ZPP*FT*ZMIXSS(1,IZ))*COST
     $     -(ZI*ZBUIZ+ZPM*FT*ZMIXSS(1,IZ))*SINT)/2.
          AS=ZA*CONJG(ZA)
          BS=ZB*CONJG(ZB)
          WID=3*(AS*((AMTP+MZIZ)**2-AMT1SS**2)+BS*((MZIZ-AMTP)**2-
     $     AMT1SS**2))/16./PI/MZIZ**3*
     $     SQRT(SSXLAM(MZIZ**2,AMT1SS**2,AMTP**2))
          CALL SSSAVE(ISZIZ,WID,ISTP1,-IDTP,0,0,0)
          CALL SSSAVE(ISZIZ,WID,-ISTP1,IDTP,0,0,0)
        ENDIF
        IF(MZIZ.GT.AMT2SS+AMTP) THEN
          ZA=((ZI*ZAUIZ-ZPP*FT*ZMIXSS(1,IZ))*SINT
     $     +(ZI*ZBUIZ-ZPM*FT*ZMIXSS(1,IZ))*COST)/2.
          ZB=((-ZI*ZAUIZ-ZPP*FT*ZMIXSS(1,IZ))*SINT
     $     +(ZI*ZBUIZ+ZPM*FT*ZMIXSS(1,IZ))*COST)/2.
          AS=ZA*CONJG(ZA)
          BS=ZB*CONJG(ZB)
          WID=3*(AS*((AMTP+MZIZ)**2-AMT2SS**2)+BS*((MZIZ-AMTP)**2-
     $     AMT2SS**2))/16./PI/MZIZ**3*
     $     SQRT(SSXLAM(MZIZ**2,AMT2SS**2,AMTP**2))
          CALL SSSAVE(ISZIZ,WID,ISTP2,-IDTP,0,0,0)
          CALL SSSAVE(ISZIZ,WID,-ISTP2,IDTP,0,0,0)
        ENDIF
C
C          zi --> slepton + lepton
C
        IF(MZIZ.GT.(AMELSS+AME)) THEN
          WID=ALI(IZ)**2*(MZIZ**2+AME**2-AMELSS**2)/MZIZ**3/
     $         32./PI*SQRT(SSXLAM(MZIZ**2,AME**2,AMELSS**2))
          CALL SSSAVE(ISZIZ,WID,ISEL,-IDE,0,0,0)
          CALL SSSAVE(ISZIZ,WID,-ISEL,IDE,0,0,0)
        END IF
        IF(MZIZ.GT.(AMMLSS+AMMU)) THEN
          WID=ALI(IZ)**2*(MZIZ**2+AMMU**2-AMMLSS**2)/MZIZ**3/
     $         32./PI*SQRT(SSXLAM(MZIZ**2,AMMU**2,AMMLSS**2))
          CALL SSSAVE(ISZIZ,WID,ISMUL,-IDMU,0,0,0)
          CALL SSSAVE(ISZIZ,WID,-ISMUL,IDMU,0,0,0)
        END IF
        IF(MZIZ.GT.(AMERSS+AME)) THEN
          WID=BLI(IZ)**2*(MZIZ**2+AME**2-AMERSS**2)/MZIZ**3/
     $         32./PI*SQRT(SSXLAM(MZIZ**2,AME**2,AMERSS**2))
          CALL SSSAVE(ISZIZ,WID,ISER,-IDE,0,0,0)
          CALL SSSAVE(ISZIZ,WID,-ISER,IDE,0,0,0)
        END IF
        IF(MZIZ.GT.(AMMRSS+AMMU)) THEN
          WID=BLI(IZ)**2*(MZIZ**2+AMMU**2-AMMRSS**2)/MZIZ**3/
     $         32./PI*SQRT(SSXLAM(MZIZ**2,AMMU**2,AMMRSS**2))
          CALL SSSAVE(ISZIZ,WID,ISMUR,-IDMU,0,0,0)
          CALL SSSAVE(ISZIZ,WID,-ISMUR,IDMU,0,0,0)
        END IF
        IF(MZIZ.GT.(AML1SS+AMTAU)) THEN
          ZA=((ZI*ZALIZ-ZPP*FL*ZMIXSS(2,IZ))*COSL
     $     -(ZI*ZBLIZ-ZPM*FL*ZMIXSS(2,IZ))*SINL)/2.
          ZB=((-ZI*ZALIZ-ZPP*FL*ZMIXSS(2,IZ))*COSL
     $     -(ZI*ZBLIZ+ZPM*FL*ZMIXSS(2,IZ))*SINL)/2.
          AS=ZA*CONJG(ZA)
          BS=ZB*CONJG(ZB)
          WID=(AS*((AMTAU+MZIZ)**2-AML1SS**2)+BS*((MZIZ-AMTAU)**2-
     $     AML1SS**2))/16./PI/MZIZ**3*
     $     SQRT(SSXLAM(MZIZ**2,AML1SS**2,AMTAU**2))
            CALL SSSAVE(ISZIZ,WID,ISTAU1,-IDTAU,0,0,0)
            CALL SSSAVE(ISZIZ,WID,-ISTAU1,IDTAU,0,0,0)
        END IF
        IF(MZIZ.GT.(AML2SS+AMTAU)) THEN
          ZA=((ZI*ZALIZ-ZPP*FL*ZMIXSS(2,IZ))*SINL
     $     +(ZI*ZBLIZ-ZPM*FL*ZMIXSS(2,IZ))*COSL)/2.
          ZB=((-ZI*ZALIZ-ZPP*FL*ZMIXSS(2,IZ))*SINL
     $     +(ZI*ZBLIZ+ZPM*FL*ZMIXSS(2,IZ))*COSL)/2.
          AS=ZA*CONJG(ZA)
          BS=ZB*CONJG(ZB)
          WID=(AS*((AMTAU+MZIZ)**2-AML2SS**2)+BS*((MZIZ-AMTAU)**2-
     $     AML2SS**2))/16./PI/MZIZ**3*
     $     SQRT(SSXLAM(MZIZ**2,AML2SS**2,AMTAU**2))
            CALL SSSAVE(ISZIZ,WID,ISTAU2,-IDTAU,0,0,0)
            CALL SSSAVE(ISZIZ,WID,-ISTAU2,IDTAU,0,0,0)
        ENDIF
        IF(MZIZ.GT.AMN1SS) THEN
          WID=(MZIZ**2-AMN1SS**2)**2/32./PI/MZIZ**3
          CALL SSSAVE(ISZIZ,ANI(IZ)**2*WID,ISNEL,-IDNE,0,0,0)
          CALL SSSAVE(ISZIZ,ANI(IZ)**2*WID,-ISNEL,IDNE,0,0,0)
        END IF
        IF(MZIZ.GT.AMN2SS) THEN
          WID=(MZIZ**2-AMN2SS**2)**2/32./PI/MZIZ**3
          CALL SSSAVE(ISZIZ,ANI(IZ)**2*WID,ISNML,-IDNM,0,0,0)
          CALL SSSAVE(ISZIZ,ANI(IZ)**2*WID,-ISNML,IDNM,0,0,0)
        END IF
        IF(MZIZ.GT.AMN3SS) THEN
          WID=(MZIZ**2-AMN3SS**2)**2/32./PI/MZIZ**3
          CALL SSSAVE(ISZIZ,ANI(IZ)**2*WID,ISNTL,-IDNT,0,0,0)
          CALL SSSAVE(ISZIZ,ANI(IZ)**2*WID,-ISNTL,IDNT,0,0,0)
        END IF
245   CONTINUE
C
C          Compute decays to gravitino for GMSB models
C
      DO 250 IZ=1,4
        MZIZ=ABS(AMZISS(IZ))
        ISZIZ=ISZ(IZ)
        IF (MZIZ.GT.AMGVSS) THEN
        WID=(ZMIXSS(4,IZ)*CTHW+ZMIXSS(3,IZ)*STHW)**2*MZIZ**5/
     ,       48./PI/(AMGVSS*AMPL)**2
        CALL SSSAVE(ISZIZ,WID,ISGRAV,IDGM,0,0,0)
C          Dalitz decay
          IF (MZIZ.GT.(AMGVSS+2*AME)) THEN
            WIDEE=WID*2*ALFAEM/(3*PI)*LOG(MZIZ/AME)
            CALL SSSAVE(ISZIZ,WIDEE,ISGRAV,IDE,-IDE,0,0)
          END IF
        END IF
        IF (MZIZ.GT.(AMZ+AMGVSS)) THEN
          WID=(2*(ZMIXSS(4,IZ)*STHW-ZMIXSS(3,IZ)*CTHW)**2+
     ,        (ZMIXSS(1,IZ)*SINBE-ZMIXSS(2,IZ)*COSBE)**2)*
     ,        (MZIZ**2-AMZ**2)**4/96./PI/MZIZ**3/(AMGVSS*AMPL)**2
          CALL SSSAVE(ISZIZ,WID,ISGRAV,IDZ,0,0,0)
        END IF
        IF (MZIZ.GT.(AMHL+AMGVSS)) THEN
          WID=(ZMIXSS(1,IZ)*COSA+ZMIXSS(2,IZ)*SINA)**2/6./
     ,        (AMGVSS*AMPL)**2*(MZIZ**2-AMHL**2)**4/16./PI/MZIZ**3
          CALL SSSAVE(ISZIZ,WID,ISGRAV,ISHL,0,0,0)
        END IF
        IF (MZIZ.GT.(AMHH+AMGVSS)) THEN
          WID=(-ZMIXSS(1,IZ)*SINA+ZMIXSS(2,IZ)*COSA)**2/6./
     ,        (AMGVSS*AMPL)**2*(MZIZ**2-AMHH**2)**4/16./PI/MZIZ**3
          CALL SSSAVE(ISZIZ,WID,ISGRAV,ISHH,0,0,0)
        END IF
        IF (MZIZ.GT.(AMHA+AMGVSS)) THEN
          WID=(ZMIXSS(1,IZ)*COSBE+ZMIXSS(2,IZ)*SINBE)**2/6./
     ,        (AMGVSS*AMPL)**2*(MZIZ**2-AMHA**2)**4/16./PI/MZIZ**3
          CALL SSSAVE(ISZIZ,WID,ISGRAV,ISHA,0,0,0)
        END IF
250   CONTINUE
C
C          Normalize zi branching ratios
C
      CALL SSNORM(ISZ1)
      CALL SSNORM(ISZ2)
      CALL SSNORM(ISZ3)
      CALL SSNORM(ISZ4)
C
C-----------------------------------------------------------------------
C          Generate Chargino Branching Fractions
C-----------------------------------------------------------------------
      DO 300 IW=1,2
C          Loop over w1, w2
        IF(IW.EQ.1) THEN
            MWIW=MW1
            SNIW=SNW1
            ISWIW=ISW1
        ELSE
            MWIW=MW2
            SNIW=SNW2
            ISWIW=ISW2
        ENDIF
C
C          Decays to zj
C
        DO 310 JZ=1,4
          MZJZ=ABS(AMZISS(JZ))
          ISZJZ=ISZ(JZ)
          IF(MWIW.LE.FUDGE*MZJZ) GOTO 310
C          Couplings
          IF(IW.EQ.1) THEN
            XIPM=XIM(JZ)
            YIPM=YIM(JZ)
          ELSE
            XIPM=XIP(JZ)
            YIPM=YIP(JZ)
          ENDIF
C
C          wi --> f + fbar + zj
C
          IF (MWIW.GT.(MZJZ+AMUP+AMDN)) THEN
            IF (MWIW.LT.(AMW+MZJZ)) THEN
            TMP(1)=XIPM**2+YIPM**2
            TMP(2)=XIPM**2-YIPM**2
            TMP(3)=MWIW
            TMP(4)=MZJZ
            TERM1=SSXINT(MZJZ,SSWZF1,(MWIW**2+MZJZ**2)/2./MWIW)/
     $            2./MWIW/(2*PI)**5*2*G**4*PI**2/3.
            ELSE
            TERM1=0.
            END IF
            ULIM=MWIW/2.*(1.-MZJZ**2/MWIW**2)
            TMP(1)=MWIW
            TMP(3)=MZJZ
            IF (MWIW.LT.AMULSS) THEN
            TMP(2)=AMULSS
            PSIINT=SSXINT(0.,SSWZF2,ULIM)
            T1=AUI(JZ)**2*ADWI(IW)**2*PSIINT
            ELSE
            T1=0.
            END IF
            IF (MWIW.LT.AMDLSS) THEN
            TMP(2)=AMDLSS
            PSIINT=SSXINT(0.,SSWZF2,ULIM)
            T2=ADI(JZ)**2*AUWI(IW)**2*PSIINT
            ELSE
            T2=0.
            END IF
            IF (MWIW.LT.AMDLSS.AND.MWIW.LT.AMULSS) THEN
            TMP(2)=0.
            TMP(4)=AMDLSS
            TMP(5)=AMULSS
            PHIINT=SSXINT(0.,SSGX2,ULIM)
            CC=2*SIGN(1.,AMZISS(JZ))*AUWI(IW)*ADWI(IW)*AUI(JZ)*ADI(JZ)
            T3=CC*PHIINT
            ELSE
            T3=0.
            END IF
            TERM2=(T1+T2+T3)/2./MWIW/(2*PI)**5
            FACTOR=1./2./MWIW/(2*PI)**5*2*SR2*G**2
            TMP(1)=MWIW
            TMP(3)=MZJZ
            IF (MWIW.LT.(MZJZ+AMW).AND.MWIW.LT.AMULSS) THEN
            TMP(2)=AMULSS
            XI1=SSXINT(0.,SSWZF4,(MWIW-MZJZ)**2)
            XI2=SSXINT(0.,SSWZF5,(MWIW-MZJZ)**2)
            TERM3=FACTOR*ADWI(IW)*AUI(JZ)*((XIPM-YIPM)*XI1
     $      -(XIPM+YIPM)*XI2)*SIGN(1.,AMZISS(JZ))
            ELSE
            TERM3=0.
            END IF
            IF (MWIW.LT.(MZJZ+AMW).AND.MWIW.LT.AMDLSS) THEN
            TMP(2)=AMDLSS
            XI1=SSXINT(0.,SSWZF4,(MWIW-MZJZ)**2)
            XI2=SSXINT(0.,SSWZF5,(MWIW-MZJZ)**2)
            TERM4=-FACTOR*AUWI(IW)*ADI(JZ)*((XIPM+YIPM)*XI1
     $      -(XIPM-YIPM)*XI2)
            ELSE
            TERM4=0.
            END IF
            WID=3*(TERM1+TERM2+TERM3+TERM4)
            CALL SSSAVE(ISWIW,WID,ISZJZ,IDUP,-IDDN,0,0)
          END IF
C          wi --> c + sbar + zj
          IF (MWIW.GT.(MZJZ+AMCH+AMST)) THEN
            IF (MWIW.LT.(AMW+MZJZ)) THEN
            TMP(1)=XIPM**2+YIPM**2
            TMP(2)=XIPM**2-YIPM**2
            TMP(3)=MWIW
            TMP(4)=MZJZ
            TERM1=SSXINT(MZJZ,SSWZF1,(MWIW**2+MZJZ**2)/2./MWIW)/
     $            2./MWIW/(2*PI)**5*2*G**4*PI**2/3.
            ELSE
            TERM1=0.
            END IF
            ULIM=MWIW/2.*(1.-MZJZ**2/MWIW**2)
            TMP(1)=MWIW
            TMP(3)=MZJZ
            IF (MWIW.LT.AMCLSS) THEN
            TMP(2)=AMCLSS
            PSIINT=SSXINT(0.,SSWZF2,ULIM)
            T1=AUI(JZ)**2*ADWI(IW)**2*PSIINT
            ELSE
            T1=0.
            END IF
            IF (MWIW.LT.AMSLSS) THEN
            TMP(2)=AMSLSS
            PSIINT=SSXINT(0.,SSWZF2,ULIM)
            T2=ADI(JZ)**2*AUWI(IW)**2*PSIINT
            ELSE
            T2=0.
            END IF
            IF (MWIW.LT.AMSLSS.AND.MWIW.LT.AMCLSS) THEN
            TMP(2)=0.
            TMP(4)=AMSLSS
            TMP(5)=AMCLSS
            PHIINT=SSXINT(0.,SSGX2,ULIM)
            CC=2*SIGN(1.,AMZISS(JZ))*AUWI(IW)*ADWI(IW)*AUI(JZ)*ADI(JZ)
            T3=CC*PHIINT
            ELSE
            T3=0.
            END IF
            TERM2=(T1+T2+T3)/2./MWIW/(2*PI)**5
            FACTOR=1./2./MWIW/(2*PI)**5*2*SR2*G**2
            TMP(1)=MWIW
            TMP(3)=MZJZ
            IF (MWIW.LT.(MZJZ+AMW).AND.MWIW.LT.AMCLSS) THEN
            TMP(2)=AMCLSS
            XI1=SSXINT(0.,SSWZF4,(MWIW-MZJZ)**2)
            XI2=SSXINT(0.,SSWZF5,(MWIW-MZJZ)**2)
            TERM3=FACTOR*ADWI(IW)*AUI(JZ)*((XIPM-YIPM)*XI1
     $      -(XIPM+YIPM)*XI2)*SIGN(1.,AMZISS(JZ))
            ELSE
            TERM3=0.
            END IF
            IF (MWIW.LT.(MZJZ+AMW).AND.MWIW.LT.AMSLSS) THEN
            TMP(2)=AMSLSS
            XI1=SSXINT(0.,SSWZF4,(MWIW-MZJZ)**2)
            XI2=SSXINT(0.,SSWZF5,(MWIW-MZJZ)**2)
            TERM4=-FACTOR*AUWI(IW)*ADI(JZ)*((XIPM+YIPM)*XI1
     $      -(XIPM-YIPM)*XI2)
            ELSE
            TERM4=0.
            END IF
            WID=3*(TERM1+TERM2+TERM3+TERM4)
            CALL SSSAVE(ISWIW,WID,ISZJZ,IDCH,-IDST,0,0)
          END IF
C          wi -> t + bbar + zj neglected since 2-body modes should dominate
C          wi --> nu_e + e + zj
          IF (MWIW.GT.(MZJZ+AME)) THEN
            IF (MWIW.LT.(AMW+MZJZ)) THEN
            TMP(1)=XIPM**2+YIPM**2
            TMP(2)=XIPM**2-YIPM**2
            TMP(3)=MWIW
            TMP(4)=MZJZ
            TERM1=SSXINT(MZJZ,SSWZF1,(MWIW**2+MZJZ**2)/2./MWIW)/
     $            2./MWIW/(2*PI)**5*2*G**4*PI**2/3.
            ELSE
            TERM1=0.
            END IF
            ULIM=MWIW/2.*(1.-MZJZ**2/MWIW**2)
            TMP(1)=MWIW
            TMP(3)=MZJZ
            IF (MWIW.LT.AMN1SS) THEN
            TMP(2)=AMN1SS
            T1=ANI(JZ)**2*ALWI(IW)**2*SSXINT(0.,SSWZF2,ULIM)
            ELSE
            T1=0.
            END IF
            IF (MWIW.LT.AMELSS) THEN
            TMP(2)=AMELSS
            T2=ALI(JZ)**2*ANWI(IW)**2*SSXINT(0.,SSWZF2,ULIM)
            ELSE
            T2=0.
            END IF
            IF (MWIW.LT.AMELSS.AND.MWIW.LT.AMN1SS) THEN
            TMP(2)=0.
            TMP(4)=AMELSS
            TMP(5)=AMN1SS
            T3=-2*SIGN(1.,AMZISS(JZ))*ANWI(IW)*ALWI(IW)*ANI(JZ)*
     $         ALI(JZ)*SSXINT(0.,SSGX2,ULIM)
            ELSE
            T3=0.
            END IF
            TERM2=(T1+T2+T3)/2./MWIW/(2*PI)**5
            FACTOR=1./2./MWIW/(2*PI)**5*2*SR2*G**2
            TMP(1)=MWIW
            TMP(3)=MZJZ
            IF (MWIW.LT.(MZJZ+AMW).AND.MWIW.LT.AMN1SS) THEN
            TMP(2)=AMN1SS
            XI1=SSXINT(0.,SSWZF4,(MWIW-MZJZ)**2)
            XI2=SSXINT(0.,SSWZF5,(MWIW-MZJZ)**2)
            TERM3=FACTOR*ALWI(IW)*ANI(JZ)*((XIPM-YIPM)*XI1
     $      -(XIPM+YIPM)*XI2)*SIGN(1.,AMZISS(JZ))
            ELSE
            TERM3=0.
            END IF
            IF (MWIW.LT.(MZJZ+AMW).AND.MWIW.LT.AMELSS) THEN
            TMP(2)=AMELSS
            XI1=SSXINT(0.,SSWZF4,(MWIW-MZJZ)**2)
            XI2=SSXINT(0.,SSWZF5,(MWIW-MZJZ)**2)
            TERM4=FACTOR*ANWI(IW)*ALI(JZ)*((XIPM+YIPM)*XI1
     $      -(XIPM-YIPM)*XI2)
            ELSE
            TERM4=0.
            END IF
            WID=TERM1+TERM2+TERM3+TERM4
            CALL SSSAVE(ISWIW,WID,ISZJZ,-IDE,IDNE,0,0)
          END IF
C          wi --> nu_mu + mu + zj
          IF (MWIW.GT.(MZJZ+AMMU)) THEN
            IF (MWIW.LT.(AMW+MZJZ)) THEN
            TMP(1)=XIPM**2+YIPM**2
            TMP(2)=XIPM**2-YIPM**2
            TMP(3)=MWIW
            TMP(4)=MZJZ
            TERM1=SSXINT(MZJZ,SSWZF1,(MWIW**2+MZJZ**2)/2./MWIW)/
     $            2./MWIW/(2*PI)**5*2*G**4*PI**2/3.
            ELSE
            TERM1=0.
            END IF
            ULIM=MWIW/2.*(1.-MZJZ**2/MWIW**2)
            TMP(1)=MWIW
            TMP(3)=MZJZ
            IF (MWIW.LT.AMN2SS) THEN
            TMP(2)=AMN2SS
            T1=ANI(JZ)**2*ALWI(IW)**2*SSXINT(0.,SSWZF2,ULIM)
            ELSE
            T1=0.
            END IF
            IF (MWIW.LT.AMMLSS) THEN
            TMP(2)=AMMLSS
            T2=ALI(JZ)**2*ANWI(IW)**2*SSXINT(0.,SSWZF2,ULIM)
            ELSE
            T2=0.
            END IF
            IF (MWIW.LT.AMMLSS.AND.MWIW.LT.AMN2SS) THEN
            TMP(2)=0.
            TMP(4)=AMMLSS
            TMP(5)=AMN2SS
            T3=-2*SIGN(1.,AMZISS(JZ))*ANWI(IW)*ALWI(IW)*ANI(JZ)*
     $         ALI(JZ)*SSXINT(0.,SSGX2,ULIM)
            ELSE
            T3=0.
            END IF
            TERM2=(T1+T2+T3)/2./MWIW/(2*PI)**5
            FACTOR=1./2./MWIW/(2*PI)**5*2*SR2*G**2
            TMP(1)=MWIW
            TMP(3)=MZJZ
            IF (MWIW.LT.(MZJZ+AMW).AND.MWIW.LT.AMN2SS) THEN
            TMP(2)=AMN2SS
            XI1=SSXINT(0.,SSWZF4,(MWIW-MZJZ)**2)
            XI2=SSXINT(0.,SSWZF5,(MWIW-MZJZ)**2)
            TERM3=FACTOR*ALWI(IW)*ANI(JZ)*((XIPM-YIPM)*XI1
     $      -(XIPM+YIPM)*XI2)*SIGN(1.,AMZISS(JZ))
            ELSE
            TERM3=0.
            END IF
            IF (MWIW.LT.(MZJZ+AMW).AND.MWIW.LT.AMMLSS) THEN
            TMP(2)=AMMLSS
            XI1=SSXINT(0.,SSWZF4,(MWIW-MZJZ)**2)
            XI2=SSXINT(0.,SSWZF5,(MWIW-MZJZ)**2)
            TERM4=FACTOR*ANWI(IW)*ALI(JZ)*((XIPM+YIPM)*XI1
     $      -(XIPM-YIPM)*XI2)
            ELSE
            TERM4=0.
            END IF
            WID=TERM1+TERM2+TERM3+TERM4
            CALL SSSAVE(ISWIW,WID,ISZJZ,-IDMU,IDNM,0,0)
          END IF
C          wi --> nu_tau + tau + zj ; includes mixing and Yukawas
          FACT=1./2./MWIW/(2*PI)**5
          ALJZ1=-ALI(JZ)*COSL-FL*ZMIXSS(2,JZ)*SINL
          ALJZ2=-ALI(JZ)*SINL+FL*ZMIXSS(2,JZ)*COSL
          BEJZ1=BLI(JZ)*SINL+FL*ZMIXSS(2,JZ)*COSL
          BEJZ2=-BLI(JZ)*COSL+FL*ZMIXSS(2,JZ)*SINL
          SNJZ=SIGN(1.,AMZISS(JZ))
C          Polarization for stau_1 -> z1ss+tau.
C          See above for other cases.
          IF(IW.EQ.1.AND.JZ.EQ.1) THEN
            PTAU1(JZ)=(BEJZ1**2-ALJZ1**2)/(BEJZ1**2+ALJZ1**2)
            PTAU2(JZ)=(BEJZ2**2-ALJZ2**2)/(BEJZ2**2+ALJZ2**2)
          ENDIF
          IF (IW.EQ.1) THEN
            ALIW1=-G*SIN(GAMMAL)*COSL+FL*COS(GAMMAL)*SINL
            ALIW2=-G*SIN(GAMMAL)*SINL-FL*COS(GAMMAL)*COSL
            AHCJZ=COSBE*V2I(JZ)
            BHCJZ=-SINBE*V4I(JZ)
          ELSE IF (IW.EQ.2) THEN
            ALIW1=(-G*COS(GAMMAL)*COSL-FL*SIN(GAMMAL)*SINL)*THX
            ALIW2=(-G*COS(GAMMAL)*SINL+FL*SIN(GAMMAL)*COSL)*THX
            AHCJZ=COSBE*V1I(JZ)*THY
            BHCJZ=-SINBE*V3I(JZ)*THX
          END IF
          IF (MWIW.GT.(MZJZ+AMTAU)) THEN
            IF (MWIW.LT.(AMW+MZJZ)) THEN
            TMP(1)=XIPM**2+YIPM**2
            TMP(2)=XIPM**2-YIPM**2
            TMP(3)=MWIW
            TMP(4)=MZJZ
            TERMW=SSXINT(MZJZ,SSWZF1,(MWIW**2+MZJZ**2)/2./MWIW)*
     $            FACT*2*G**4*PI**2/3.
            ELSE
            TERMW=0.
            END IF
            ULIM=(MWIW**2-MZJZ**2)/2./MWIW
            TMP(1)=MWIW
            TMP(3)=MZJZ
            IF (MWIW.LT.AMN3SS) THEN
            TMP(2)=AMN3SS
            POLNL=FACT*ANI(JZ)**2*ALWI(IW)**2*
     $            SSXINT(0.,SSWZF2,ULIM)
            POLNR=POLNL*BPLWI(IW)**2/ALWI(IW)**2
            TERMN=POLNL+POLNR
            ELSE
            POLNL=0.
            POLNR=0.
            TERMN=0.
            END IF
            IF (MWIW.LT.AML1SS) THEN
            TMP(2)=AML1SS
            POL1L=FACT*ALJZ1**2*ALIW1**2*SSXINT(0.,SSWZF2,ULIM)
            POL1R=POL1L*BEJZ1**2/ALJZ1**2
            TERM1=POL1L+POL1R
            ELSE
            POL1L=0.
            POL1R=0.
            TERM1=0.
            END IF
            IF (MWIW.LT.AML2SS) THEN
            TMP(2)=AML2SS
            POL2L=FACT*ALJZ2**2*ALIW2**2*SSXINT(0.,SSWZF2,ULIM)
            POL2R=POL2L*BEJZ2**2/ALJZ2**2
            TERM2=POL2L+POL2R
            ELSE
            POL2L=0.
            POL2R=0.
            TERM2=0.
            END IF
            IF (MWIW.LT.AML1SS) THEN
            TMP(2)=0.
            TMP(3)=MZJZ
            TMP(4)=AML1SS
            TMP(5)=AML2SS
            POL12L=FACT*2*ALIW1*ALIW2*ALJZ1*ALJZ2*
     $             SSXINT(0.,SSGX1,ULIM)
            POL12R=POL12L*BEJZ1*BEJZ2/ALJZ1/ALJZ2
            TERM12=POL12L+POL12R
            ELSE
            POL12L=0.
            POL12R=0.
            TERM12=0.
            END IF
            IF (MWIW.LT.(AMHC+MZJZ)) THEN
            TMP(2)=AMHC
            TMP(3)=MZJZ
            TMP(4)=AHCJZ
            TMP(5)=BHCJZ
            TMP(6)=SIGN(1.,AMZISS(JZ))*SIGN(1.,AMWISS(IW))
            TERMH=FACT*PI**2*MWIW*(G*AMTAU*TANB/AMW)**2/2.*
     $         SSXINT(MZJZ,SSWZF6,(MWIW**2+MZJZ**2)/2./MWIW)
            ELSE
            TERMH=0.
            END IF
            IF (MWIW.LT.AML1SS.AND.MWIW.LT.AMN3SS) THEN
            TMP(2)=0.
            TMP(3)=MZJZ
            TMP(4)=AMN3SS
            TMP(5)=AML1SS
            POLN1L=-2*FACT*ANI(JZ)*ALIW1*SNJZ*SNIW*AWMD*
     $             ALJZ1*SSXINT(0.,SSGX2,ULIM)
            POLN1R=-2*FACT*ANI(JZ)*ALIW1*BPLWI(IW)*BEJZ1*
     $             SSXINT(0.,SSGX8,ULIM)
            TERMN1=POLN1L+POLN1R
            ELSE
            POLN1L=0.
            POLN1R=0.
            TERMN1=0.
            END IF
            IF (MWIW.LT.AML2SS.AND.MWIW.LT.AMN3SS) THEN
            TMP(2)=0.
            TMP(3)=MZJZ
            TMP(4)=AMN3SS
            TMP(5)=AML2SS
            POLN2L=-2*FACT*ANI(JZ)*ALIW2*SNJZ*SNIW*AWMD*ALJZ2*
     $             SSXINT(0.,SSGX2,ULIM)
            POLN2R=-2*FACT*ANI(JZ)*ALIW2*BPLWI(IW)*BEJZ2*
     $             SSXINT(0.,SSGX8,ULIM)
            TERMN2=POLN2L+POLN2R
            ELSE
            POLN2L=0.
            POLN2R=0.
            TERMN2=0.
            END IF
            TMP(1)=MWIW
            TMP(3)=MZJZ
            IF (MWIW.LT.(MZJZ+AMW).AND.MWIW.LT.AMN3SS) THEN
            TMP(2)=AMN3SS
            XI1=SSXINT(0.,SSWZF4,(MWIW-MZJZ)**2)
            XI2=SSXINT(0.,SSWZF5,(MWIW-MZJZ)**2)
            TERMWN=2*SR2*G**2*FACT*ALWI(IW)*ANI(JZ)*((XIPM-
     $         YIPM)*XI1-(XIPM+YIPM)*XI2)*SIGN(1.,AMZISS(JZ))
            ELSE
            TERMWN=0.
            END IF
            IF (MWIW.LT.(MZJZ+AMW).AND.MWIW.LT.AML1SS) THEN
            TMP(2)=AML1SS
            XI1=SSXINT(0.,SSWZF4,(MWIW-MZJZ)**2)
            XI2=SSXINT(0.,SSWZF5,(MWIW-MZJZ)**2)
            TERMW1=2*SR2*G**2*FACT*ALIW1*ALJZ1*
     $             ((XIPM+YIPM)*XI1-(XIPM-YIPM)*XI2)
            ELSE
            TERMW1=0.
            END IF
            IF (MWIW.LT.(MZJZ+AMW).AND.MWIW.LT.AML2SS) THEN
            TMP(2)=AML2SS
            XI1=SSXINT(0.,SSWZF4,(MWIW-MZJZ)**2)
            XI2=SSXINT(0.,SSWZF5,(MWIW-MZJZ)**2)
            TERMW2=2*SR2*G**2*FACT*ALIW2*ALJZ2*
     $             ((XIPM+YIPM)*XI1-(XIPM-YIPM)*XI2)
            ELSE
            TERMW2=0.
            END IF
            TMP(2)=MZJZ
            TMP(3)=AMHC
            TMP(5)=AHCJZ
            TMP(6)=BHCJZ
            TMP(7)=SNJZ*SNIW
            IF (MWIW.LT.(AMHC+MZJZ).AND.MWIW.LT.AML1SS) THEN
            TMP(4)=AML1SS
            TERMH1=PI**2/2./MWIW*FACT*SR2*ALIW1*BEJZ1*G*AMTAU*
     $             TANB/AMW*SSXINT(0.,SSWZF7,(MWIW-MZJZ)**2)
            ELSE
            TERMH1=0.
            END IF
            IF (MWIW.LT.(AMHC+MZJZ).AND.MWIW.LT.AML2SS) THEN
            TMP(4)=AML2SS
            TERMH2=PI**2/2./MWIW*FACT*SR2*ALIW2*BEJZ2*G*AMTAU*
     $             TANB/AMW*SSXINT(0.,SSWZF7,(MWIW-MZJZ)**2)
            ELSE
            TERMH2=0.
            END IF
            IF (MWIW.LT.(AMHC+MZJZ).AND.MWIW.LT.AMN3SS) THEN
            TMP(4)=AMN3SS
            TERMHN=PI**2/2./MWIW*FACT*SR2*ANI(JZ)*BPLWI(IW)*G*
     $         AMTAU*TANB/AMW*SSXINT(0.,SSWZF7,(MWIW-MZJZ)**2)
            ELSE
            TERMHN=0.
            END IF
            WID=TERMW+TERMN+TERM1+TERM2+TERMH+TERMWN+TERMW1+
     $          TERMW2+TERM12+TERMN1+TERMN2+TERMH1+TERMH2+
     $          TERMHN
C          tau polarization for 3-body w1 -> z1 tau nu
            IF (IW.EQ.1.AND.JZ.EQ.1.AND.WID.NE.0.) THEN
              PTAUWZ=(POLNR+POL1R+POL2R+POL12R+TERMH+POLN1R+
     $               POLN2R+TERMHN+TERMH1+TERMH2-(TERMW+POLNL+
     $               POL1L+POL2L+POL12L+POLN1L+POLN2L+TERMWN+
     $               TERMW1+TERMW2))/WID
            END IF
            CALL SSSAVE(ISWIW,WID,ISZJZ,-IDTAU,IDNT,0,0)
          END IF
C
C          wi --> w + zj
C
          IF (MWIW.GT.(MZJZ+AMW)) THEN
            EF=MWIW**2+MZJZ**2-AMW**2+((MWIW**2-MZJZ**2)**2
     $         -AMW**4)/AMW/AMW
            WID=G*G*SQRT(SSXLAM(MWIW**2,MZJZ**2,AMW**2))/32./PI/
     $          MWIW**3*(2.*EF*(XIPM**2+YIPM**2)-12*MWIW*MZJZ*
     $          (XIPM**2-YIPM**2))
            CALL SSSAVE(ISWIW,WID,ISZJZ,IDW,0,0,0)
          END IF
C
C          wi --> h+ + zj
C
          IF (MWIW.GT.(MZJZ+AMHC)) THEN
            IF(IW.EQ.1) THEN
              A=(SNW1*COSBE*V2I(JZ)
     $        -SIGN(1.,AMZISS(JZ))*SINBE*V4I(JZ))/2.
              B=(SNW1*COSBE*V2I(JZ)
     $        +SIGN(1.,AMZISS(JZ))*SINBE*V4I(JZ))/2.
            ELSE
              A=(THY*SNW2*COSBE*V1I(JZ)
     $        -THX*SIGN(1.,AMZISS(JZ))*SINBE*V3I(JZ))/2.
              B=(THY*SNW2*COSBE*V1I(JZ)
     $        +THX*SIGN(1.,AMZISS(JZ))*SINBE*V3I(JZ))/2.
            ENDIF
            WID=SQRT(MWIW**4+MZJZ**4+AMHC**4-2.*(MWIW*MZJZ)**2-
     $      2.*(MWIW*AMHC)**2-2.*(MZJZ*AMHC)**2)/8./PI/MWIW**3*
     $      ((A*A+B*B)*(MWIW*MWIW+MZJZ*MZJZ-AMHC*AMHC)/2.
     $      +(A*A-B*B)*MWIW*MZJZ)
            CALL SSSAVE(ISWIW,WID,ISZJZ,ISHC,0,0,0)
          ENDIF
310     CONTINUE
C
C          wi --> quark + squark
C
        IF(MWIW.GT.(AMULSS+AMDN)) THEN
          WID=3.*ADWI(IW)**2/32./PI/MWIW*(1.+AMDN**2/MWIW**2-
     $     AMULSS**2/MWIW**2)*SQRT(SSXLAM(MWIW**2,AMDN**2,AMULSS**2))
          CALL SSSAVE(ISWIW,WID,+ISUPL,-IDDN,0,0,0)
        END IF
        IF(MWIW.GT.(AMDLSS+AMUP)) THEN
          WID=3.*AUWI(IW)**2/32./PI/MWIW*(1.+AMUP**2/MWIW**2-
     $     AMDLSS**2/MWIW**2)*SQRT(SSXLAM(MWIW**2,AMUP**2,AMDLSS**2))
          CALL SSSAVE(ISWIW,WID,-ISDNL,+IDUP,0,0,0)
        END IF
        IF(MWIW.GT.(AMCLSS+AMST)) THEN
          WID=3.*ADWI(IW)**2/32./PI/MWIW*(1.+AMST**2/MWIW**2-
     $     AMCLSS**2/MWIW**2)*SQRT(SSXLAM(MWIW**2,AMST**2,AMCLSS**2))
          CALL SSSAVE(ISWIW,WID,+ISCHL,-IDST,0,0,0)
        END IF
        IF(MWIW.GT.(AMSLSS+AMCH)) THEN
          WID=3.*AUWI(IW)**2/32./PI/MWIW*(1.+AMCH**2/MWIW**2-
     $     AMCLSS**2/MWIW**2)*SQRT(SSXLAM(MWIW**2,AMCH**2,AMCLSS**2))
          CALL SSSAVE(ISWIW,WID,-ISSTL,+IDCH,0,0,0)
        ENDIF
        IF(MWIW.GT.(AMT1SS+AMBT)) THEN
          AS=(-ADWI(IW)*COST-BWI(IW)*SINT)**2
          WID=3*((AS+BPWI(IW)**2*COST**2)*(MWIW**2+AMBT**2-AMT1SS**2)
     $        +4*SQRT(AS)*BPWI(IW)*COST*AMBT*MWIW)/32./PI/MWIW**3*
     $      SQRT(SSXLAM(MWIW**2,AMBT**2,AMT1SS**2))
          CALL SSSAVE(ISWIW,WID,ISTP1,-IDBT,0,0,0)
        ENDIF
        IF(MWIW.GT.(AMT2SS+AMBT)) THEN
          AS=(-ADWI(IW)*SINT+BWI(IW)*COST)**2
          WID=3*((AS+BPWI(IW)**2*SINT**2)*(MWIW**2+AMBT**2-AMT2SS**2)
     $        +4*SQRT(AS)*BPWI(IW)*SINT*AMBT*MWIW)/32./PI/MWIW**3*
     $      SQRT(SSXLAM(MWIW**2,AMBT**2,AMT2SS**2))
          CALL SSSAVE(ISWIW,WID,ISTP2,-IDBT,0,0,0)
        ENDIF
        IF(MWIW.GT.(AMB1SS+AMTP)) THEN
          AS=(-AUWI(IW)*COSB-BPWI(IW)*SINB)**2
          WID=3*((AS+BWI(IW)**2*COSB**2)*(MWIW**2+AMTP**2-AMB1SS**2)
     $        +4*SQRT(AS)*BWI(IW)*COSB*AMTP*MWIW)/32./PI/MWIW**3*
     $      SQRT(SSXLAM(MWIW**2,AMTP**2,AMB1SS**2))
          CALL SSSAVE(ISWIW,WID,-ISBT1,IDTP,0,0,0)
        ENDIF
        IF(MWIW.GT.(AMB2SS+AMTP)) THEN
          AS=(-AUWI(IW)*SINB+BPWI(IW)*COSB)**2
          WID=3*((AS+BWI(IW)**2*SINB**2)*(MWIW**2+AMTP**2-AMB2SS**2)
     $        +4*SQRT(AS)*BWI(IW)*SINB*AMTP*MWIW)/32./PI/MWIW**3*
     $      SQRT(SSXLAM(MWIW**2,AMTP**2,AMB2SS**2))
          CALL SSSAVE(ISWIW,WID,-ISBT2,IDTP,0,0,0)
        ENDIF
C
C          wi --> lepton + slepton
C
        IF(MWIW.GT.(AMN1SS+AME)) THEN
          AS=(-ALWI(IW))**2
          WID=AS*(MWIW**2+AME**2-AMN1SS**2)/32./PI/MWIW**3*
     $        SQRT(SSXLAM(MWIW**2,AME**2,AMN1SS**2))
          CALL SSSAVE(ISWIW,WID,ISNEL,-IDE,0,0,0)
        END IF
        IF(MWIW.GT.(AMN2SS+AMMU)) THEN
          AS=(-ALWI(IW))**2
          WID=AS*(MWIW**2+AMMU**2-AMN2SS**2)/32./PI/MWIW**3*
     $        SQRT(SSXLAM(MWIW**2,AMMU**2,AMN2SS**2))
          CALL SSSAVE(ISWIW,WID,ISNML,-IDMU,0,0,0)
        END IF
        IF(MWIW.GT.(AMN3SS+AMTAU)) THEN
          AS=(-ALWI(IW))**2
          WID=((AS+BPLWI(IW)**2)*(MWIW**2+AMTAU**2-AMN3SS**2)+
     $        4*SQRT(AS)*BPLWI(IW)*AMTAU*MWIW)/32./PI/MWIW**3*
     $        SQRT(SSXLAM(MWIW**2,AMTAU**2,AMN3SS**2))
          CALL SSSAVE(ISWIW,WID,ISNTL,-IDTAU,0,0,0)
        ENDIF
        IF(MWIW.GT.AMELSS) THEN
          WID=ANWI(IW)**2*(MWIW**2-AMELSS**2)**2/32./PI/MWIW**3
          CALL SSSAVE(ISWIW,WID,-ISEL,IDNE,0,0,0)
        ENDIF
        IF(MWIW.GT.AMMLSS) THEN
          WID=ANWI(IW)**2*(MWIW**2-AMMLSS**2)**2/32./PI/MWIW**3
          CALL SSSAVE(ISWIW,WID,-ISMUL,IDNM,0,0,0)
        END IF
        IF(MWIW.GT.AML1SS) THEN
          AS=(-ANWI(IW)*COSL-BPLWI(IW)*SINL)**2
          WID=AS*(MWIW**2-AML1SS**2)**2/32./PI/MWIW**3
          CALL SSSAVE(ISWIW,WID,-ISTAU1,IDNT,0,0,0)
        END IF
        IF(MWIW.GT.AML2SS) THEN
          AS=(-ANWI(IW)*SINL+BPLWI(IW)*COSL)**2
          WID=AS*(MWIW**2-AML2SS**2)**2/32./PI/MWIW**3
          CALL SSSAVE(ISWIW,WID,-ISTAU2,IDNT,0,0,0)
        END IF
300   CONTINUE
C
C          w2 --> w1 + z
C          w2 --> w1 + f + fbar
C
      IF (MW2.GT.(MW1+AMZ)) THEN
        EF=MW2**2+MW1**2-AMZ**2+((MW2**2-MW1**2)**2-
     $     AMZ**4)/AMZ/AMZ
        Y=(THX*SIN(GAMMAL)*COS(GAMMAL)-THY*SIN(GAMMAR)*COS(GAMMAR))/2.
        Z=(THX*SIN(GAMMAL)*COS(GAMMAL)+THY*SIN(GAMMAR)*COS(GAMMAR))/2.
        WID=(COTW+TANW)**2*SQRT(SSXLAM(MW2**2,MW1**2,AMZ**2))/
     $      128./32./MW2**3*(2*EF*(Y*Y+Z*Z)+
     $      12*MW2*MW1*(Y*Y-Z*Z)*SNW2*SNW1)
        CALL SSSAVE(ISW2,WID,ISW1,IDZ,0,0,0)
        W21ZL=0.
        W21ZN=0.
        W21ZU=0.
        W21ZD=0.
C          ...w1 + f + fbar
      ELSE
        CONST=E**4*(COTW+TANW)**2/96./PI**3/MW2
        UPPER=(MW2**2+MW1**2)/2./MW2
        TMP(1)=MW2
        TMP(2)=MW1
        TMP(3)=AMZ
        TMP(4)=SNW1*SNW2
        TMP(5)=XWINO
        TMP(6)=YWINO
        XINTGL=SSXINT(MW1,SSWWF1,UPPER)
        W21ZL=(ALPHL**2+BETAL**2)*CONST*XINTGL
        W21ZN=(ALPHN**2+BETAN**2)*CONST*XINTGL
        W21ZU=3*(ALPHU**2+BETAU**2)*CONST*XINTGL
        W21ZD=3*(ALPHD**2+BETAD**2)*CONST*XINTGL
      END IF
C     do w2 ->w1+q+qbar via sq'
      TMP(1)=MW2
      TMP(3)=MW1
      UPPER=(MW2**2-MW1**2)/2./MW2
      IF (MW2.LT.AMULSS) THEN
        TMP(2)=AMULSS
        XINTGL=SSXINT(0.,SSWZF2,UPPER)
        W21D=3*(ADWI(2)*ADWI(1))**2*XINTGL/2./MW2/(2*PI)**5
      ELSE
        W21D=0.
      END IF
      IF (MW2.LT.AMDLSS) THEN
        TMP(2)=AMDLSS
        XINTGL=SSXINT(0.,SSWZF2,UPPER)
        W21U=3*(AUWI(2)*AUWI(1))**2*XINTGL/2./MW2/(2*PI)**5
      ELSE
        W21U=0.
      END IF
      IF (MW2.LT.AMCLSS) THEN
        TMP(2)=AMCLSS
        XINTGL=SSXINT(0.,SSWZF2,UPPER)
        W21S=3*(ADWI(2)*ADWI(1))**2*XINTGL/2./MW2/(2*PI)**5
      ELSE
        W21S=0.
      END IF
      IF (MW2.LT.AMSLSS) THEN
        TMP(2)=AMSLSS
        XINTGL=SSXINT(0.,SSWZF2,UPPER)
        W21C=3*(AUWI(2)*AUWI(1))**2*XINTGL/2./MW2/(2*PI)**5
      ELSE
        W21C=0.
      END IF
      IF (MW2.LT.AMN1SS) THEN
        TMP(2)=AMN1SS
        XINTGL=SSXINT(0.,SSWZF2,UPPER)
        W21E=(ALWI(2)*ALWI(1))**2*XINTGL/2./MW2/(2*PI)**5
      ELSE
        W21E=0.
      END IF
      IF (MW2.LT.AMN2SS) THEN
        TMP(2)=AMN2SS
        XINTGL=SSXINT(0.,SSWZF2,UPPER)
        W21M=(ALWI(2)*ALWI(1))**2*XINTGL/2./MW2/(2*PI)**5
      ELSE
        W21M=0.
      END IF
      IF (MW2.LT.AMN3SS) THEN
        TMP(2)=AMN3SS
        XINTGL=SSXINT(0.,SSWZF2,UPPER)
        W21L=(ALWI(2)*ALWI(1))**2*XINTGL/2./MW2/(2*PI)**5
      ELSE
        W21L=0.
      END IF
      IF (MW2.LT.AMELSS) THEN
        TMP(2)=AMELSS
        XINTGL=SSXINT(0.,SSWZF2,UPPER)
        W21N1=(ANWI(2)*ANWI(1))**2*XINTGL/2./MW2/(2*PI)**5
      ELSE
        W21N1=0.
      END IF
      IF (MW2.LT.AMMLSS) THEN
        TMP(2)=AMMLSS
        XINTGL=SSXINT(0.,SSWZF2,UPPER)
        W21N2=(ANWI(2)*ANWI(1))**2*XINTGL/2./MW2/(2*PI)**5
      ELSE
        W21N2=0.
      END IF
C     !!! W2->W1+NU_TAU+NU_TAUBAR NEEDS UPDATING FOR STAU MIXING
      IF (MW2.LT.AML1SS) THEN
        TMP(2)=AML1SS
        XINTGL=SSXINT(0.,SSWZF2,UPPER)
        W21N3=(ANWI(2)*ANWI(1))**2*XINTGL/2./MW2/(2*PI)**5
      ELSE
        W21N3=0.
      END IF
C-----WINO-2 ->WINO-1 +BBBAR NEEDS UPDATE -------------------
C-----WINO-2 ->WINO-1 +TTBAR NEEDS UPDATE -------------------
C-----THESE ALL LACK INTERFERENCE TERMS AS WELL
      W21D=W21D+W21ZD
      W21U=W21U+W21ZU
      W21S=W21S+W21ZD
      W21C=W21C+W21ZU
      W21N1=W21N1+W21ZN
      W21N2=W21N2+W21ZN
      W21N3=W21N3+W21ZN
      W21E=W21E+W21ZL
      W21M=W21M+W21ZL
      W21L=W21L+W21ZL
      IF(W21D.GT.0.) THEN
        CALL SSSAVE(ISW2,W21D,ISW1,IDDN,-IDDN,0,0)
      END IF
      IF(MW2.GT.(MW1+2*AMST+1.)) THEN
        CALL SSSAVE(ISW2,W21S,ISW1,IDST,-IDST,0,0)
      END IF
C      IF (MW2.GT.(MW1+2*AMBT+2.)) THEN
C        CALL SSSAVE(ISW2,W21D,ISW1,IDBT,-IDBT,0,0)
C      END IF
      IF(W21U.GT.0.) THEN
        CALL SSSAVE(ISW2,W21U,ISW1,IDUP,-IDUP,0,0)
      END IF
      IF (MW2.GT.(MW1+2*AMCH+1.)) THEN
        CALL SSSAVE(ISW2,W21C,ISW1,IDCH,-IDCH,0,0)
      ENDIF
C        IF (MW2.GT.(MW1+2*AMTP+2.)) THEN
C          CALL SSSAVE(ISW2,W21U,ISW1,IDTP,-IDTP,0,0)
C        END IF
      IF(W21N1.GT.0.) THEN
        CALL SSSAVE(ISW2,W21N1,ISW1,IDNE,-IDNE,0,0)
      ENDIF
      IF(W21N2.GT.0.) THEN
        CALL SSSAVE(ISW2,W21N2,ISW1,IDNM,-IDNM,0,0)
      ENDIF
      IF(W21N3.GT.0.) THEN
        CALL SSSAVE(ISW2,W21N3,ISW1,IDNT,-IDNT,0,0)
      ENDIF
      IF(W21E.GT.0.) THEN
        CALL SSSAVE(ISW2,W21E,ISW1,IDE,-IDE,0,0)
      ENDIF
      IF(MW2.GT.(MW1+2*AMMU+1.)) THEN
        CALL SSSAVE(ISW2,W21M,ISW1,IDMU,-IDMU,0,0)
      ENDIF
      IF(MW2.GT.(MW1+2*AMTAU+1.)) THEN
        CALL SSSAVE(ISW2,W21L,ISW1,IDTAU,-IDTAU,0,0)
      ENDIF
C
C          w2 --> w1 + higgs
C
C          w2 --> w1 + hl
      IF(MW2.GT.(MW1+AMHL)) THEN
        WID=G*G/16./PI/MW2**3*SQRT(SSXLAM(MW2**2,MW1**2,AMHL**2))*
     $  ((SL*SL+PL*PL)*(MW2*MW2+MW1*MW1-AMHL*AMHL)/2.+
     $  (SL*SL-PL*PL)*MW2*MW1)
        CALL SSSAVE(ISW2,WID,ISW1,ISHL,0,0,0)
      ENDIF
C          w2 --> w1 + hh
      IF(MW2.GT.(MW1+AMHH)) THEN
        WID=G*G/16./PI/MW2**3*SQRT(SSXLAM(MW2**2,MW1**2,AMHH**2))*
     $  ((SH*SH+PH*PH)*(MW2*MW2+MW1*MW1-AMHH*AMHH)/2.+
     $  (SH*SH-PH*PH)*MW2*MW1)
        CALL SSSAVE(ISW2,WID,ISW1,ISHH,0,0,0)
      ENDIF
C          w2 --> w1 + ha
      IF(MW2.GT.(MW1+AMHA)) THEN
        WID=G*G/16./PI/MW2**3*SQRT(SSXLAM(MW2**2,MW1**2,AMHA**2))*
     $  ((SP*SP+PP*PP)*(MW2*MW2+MW1*MW1-AMHA*AMHA)/2.+
     $  (SP*SP-PP*PP)*MW2*MW1)
        CALL SSSAVE(ISW2,WID,ISW1,ISHA,0,0,0)
      END IF
C
C          Normalize wi branching ratios
C
      CALL SSNORM(ISW1)
      CALL SSNORM(ISW2)
C
C          Set more neutralino polarizations
C
      IF (ABS(AMZISS(2)).GT.(AMTAU+AML1SS)) PTAUZ2(1)=PTAU1(2)
      IF (ABS(AMZISS(2)).GT.(AMTAU+AML2SS)) PTAUZ2(2)=PTAU2(2)
      IF (ABS(AMZISS(3)).GT.(AMTAU+AML1SS)) PTAUZ3(1)=PTAU1(3)
      IF (ABS(AMZISS(3)).GT.(AMTAU+AML2SS)) PTAUZ3(2)=PTAU2(3)
      IF (ABS(AMZISS(4)).GT.(AMTAU+AML1SS)) PTAUZ4(1)=PTAU1(4)
      IF (ABS(AMZISS(4)).GT.(AMTAU+AML2SS)) PTAUZ4(2)=PTAU2(4)
C
      RETURN
      END
CDECK  ID>, SSWZF1. 
        REAL FUNCTION SSWZF1(EE)
C-----------------------------------------------------------------------
C          SSWZBF: wiss -> zjss f fbar
C          Baer's WIWFUN
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      REAL EE
      DOUBLE PRECISION C1,C2,MWI,MZI,MW,PROP,T1,T2,E
C
      E=EE
      C1=TMP(1)
      C2=TMP(2)
      MWI=TMP(3)
      MZI=TMP(4)
      MW=AMW
C
      PROP=(MWI**2+MZI**2-2*MWI*E-MW**2)**2
      T1=C1*(3*(MWI**2+MZI**2)*MWI*E-4*MWI**2*E*E-2*MWI**2*MZI**2)
      T2=-3*C2*MWI*MZI*(MWI**2+MZI**2-2*MWI*E)
      SSWZF1=SQRT(MAX(0.D0,E*E-MZI**2))/PROP*(T1+T2)
      RETURN
      END
CDECK  ID>, SSWZF2. 
        REAL FUNCTION SSWZF2(QQ)
C-----------------------------------------------------------------------
C          SSWZBF: wiss -> zjss f fbar
C          Baer's PSIFUN
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      REAL QQ
      DOUBLE PRECISION M1,M2,M3,PI,Q
      DATA PI/3.14159265D0/
C
      Q=QQ
      M1=TMP(1)
      M2=TMP(2)
      M3=TMP(3)
C
      SSWZF2=PI**2*M1*Q*Q*(M1**2-2*M1*Q-M3**2)**2/
     $(M1**2-2*M1*Q-M2**2)**2/(M1**2-2*M1*Q)
      RETURN
      END
CDECK  ID>, SSWZF3. 
        REAL FUNCTION SSWZF3(QQ)
C-----------------------------------------------------------------------
C          SSWZBF: wiss -> zjss f fbar
C          Baer's PHIFUN
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      REAL QQ
      DOUBLE PRECISION M1,M2,M3,T,B,XLOG,SQBKT,Q,PI
      DATA PI/3.14159265D0/
C
      Q=QQ
      M1=TMP(1)
      M2=TMP(2)
      M3=TMP(3)
C
      T=M2**2*(M1-2*Q)-M1*M3**2
      B=(M1-2*Q)*(M2**2-2*M1*Q-M3**2)
      XLOG=DLOG(T/B)
      SQBKT=-Q*(M1**2-M3**2-2*M1*Q)/M1/(M1-2*Q)-
     $(2*M1*Q-M2**2+M3**2)*XLOG/2./M1
      SSWZF3=.5*PI**2*M1*M3*SQBKT/(M1**2-M2**2-2*M1*Q)
      RETURN
      END
CDECK  ID>, SSWZF4. 
        REAL FUNCTION SSWZF4(SS)
C-----------------------------------------------------------------------
C          SSWZBF: wiss -> zjss f fbar
C          Baer's XI1FUN
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C-----------------------------------------------------------------------
      REAL SS,PI
      DOUBLE PRECISION M1,M2,M3,EQ,Q,XMUS,XLOG,TERM,S,MW
      DATA PI/3.14159265/
C
      S=SS
      M1=TMP(1)
      M2=TMP(2)
      M3=TMP(3)
      MW=AMW
C
      EQ=(S+M1**2-M3**2)/2./M1
      IF (EQ**2.GE.S) THEN
        Q=DSQRT(EQ**2-S)
      ELSE
        Q=0.D0
      END IF
      XMUS=M2**2+S-M3**2
      XLOG=DLOG((M1*(EQ+Q)-XMUS)/(M1*(EQ-Q)-XMUS))
      TERM=-.5*M1*EQ*Q-.5*(M2**2-M1**2-S)*Q-
     $.25/M1*(M2**2-M3**2)*(M2**2-M1**2)*XLOG
C          SS can stay single precision below
      SSWZF4=PI**2/2./M1/(SS-MW**2)*TERM
      RETURN
      END
CDECK  ID>, SSWZF5. 
        REAL FUNCTION SSWZF5(SS)
C-----------------------------------------------------------------------
C          SSWZBF: wiss -> zjss f fbar
C          Baer's XI2FUN
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      REAL MW,PI,SS
      DOUBLE PRECISION M1,M2,M3,EQ,Q,XMUS,D,XLOG,S
      DATA PI/3.14159265/,MW/80./
C
      S=SS
      M1=TMP(1)
      M2=TMP(2)
      M3=TMP(3)
      MW=AMW
C
      EQ=(S+M1**2-M3**2)/2./M1
      Q=DSQRT(EQ**2-S)
      XMUS=M2**2+S-M3**2
      D=(M1*(EQ+Q)-XMUS)/(M1*(EQ-Q)-XMUS)
      XLOG=DLOG(D)
      SSWZF5=PI**2/2./M1*M3*S/4./(SS-MW**2)*XLOG
      RETURN
      END
CDECK  ID>, SSWZF6. 
        REAL FUNCTION SSWZF6(EE)
C-----------------------------------------------------------------------
C          SSWZBF: wiss -> zjss f fbar
C          Drees' function for charged Higgs exchange
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      REAL EE
      DOUBLE PRECISION E,MW,MZ,MH,AL,BE,SN,RES
C
      E=EE
      MW=TMP(1)
      MH=TMP(2)
      MZ=TMP(3)
      AL=TMP(4)
      BE=TMP(5)
      SN=TMP(6)
C
      RES=SQRT(E**2-MZ**2)*(MW**2+MZ**2-2*MW*E)*
     ,(E*(AL**2+BE**2)+2*SN*MZ*AL*BE)/
     ,(MW**2+MZ**2-2*MW*E-MH**2)**2
      SSWZF6=RES
      RETURN
      END
CDECK  ID>, SSWZF7. 
        REAL FUNCTION SSWZF7(SS)
C-----------------------------------------------------------------------
C          SSWZBF: wiss -> zjss f fbar
C          Drees' function for charged Higgs/sfermion interference
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      REAL SS
      DOUBLE PRECISION S,MS,MW,MZ,MH,AL,BE,SN,RES,
     $EQ,Q,MUS,XL,TERM
C
      S=SS
      MW=TMP(1)
      MZ=TMP(2)
      MH=TMP(3)
      MS=TMP(4)
      AL=TMP(5)
      BE=TMP(6)
      SN=TMP(7)
C
      EQ=(S+MW**2-MZ**2)/2.D0/MW
      Q=SQRT(EQ**2-S)
      MUS=S+MS**2-MZ**2
      XL=LOG((MW*(EQ+Q)-MUS)/(MW*(EQ-Q)-MUS))
      TERM=BE*S*MS**2+SN*AL*MW*MZ*S
      RES=(S*Q*BE/2.D0+TERM*XL/4.D0/MW)/(S-MH**2)
      SSWZF7=RES
      RETURN
      END
CDECK  ID>, SSXINT. 
        REAL FUNCTION SSXINT(XL,F,XR)
C-----------------------------------------------------------------------
C          Integrate F over (XL,XR) using adaptive Gaussian quadrature.
C          TOLABS = 1e-35: absolute error for convergence.
C          TOLREL = 5e-5:  relative error for convergence.
C          TOLBIN = 1e-3:  relative bin size limit. Set contribution to
C                          zero if bin falls below this.
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
        EXTERNAL F
        INTEGER NMAX
        REAL TOLABS,TOLREL,TOLBIN,XMIN,XLIMS(100)
        REAL R(93),W(93)
        INTEGER PTR(4),NORD(4)
        INTEGER ICOUNT,IBAD
        REAL XL,XR,F
        REAL AA,BB,TVAL,VAL,TOL
        INTEGER NLIMS,I,J
C
        DATA PTR,NORD/4,10,22,46,  6,12,24,48/
        DATA R/.2386191860,.6612093865,.9324695142,
     1 .1252334085,.3678314990,.5873179543,.7699026742,.9041172563,
     1 .9815606342,.0640568929,.1911188675,.3150426797,.4337935076,
     1 .5454214714,.6480936519,.7401241916,.8200019860,.8864155270,
     1 .9382745520,.9747285560,.9951872200,.0323801710,.0970046992,
     1 .1612223561,.2247637903,.2873624873,.3487558863,.4086864820,
     1 .4669029048,.5231609747,.5772247261,.6288673968,.6778723796,
     1 .7240341309,.7671590325,.8070662040,.8435882616,.8765720203,
     1 .9058791367,.9313866907,.9529877032,.9705915925,.9841245837,
     1 .9935301723,.9987710073,.0162767488,.0488129851,.0812974955,
     1 .1136958501,.1459737146,.1780968824,.2100313105,.2417431561,
     1 .2731988126,.3043649444,.3352085229,.3656968614,.3957976498,
     1 .4254789884,.4547094222,.4834579739,.5116941772,.5393881083,
     1 .5665104186,.5930323648,.6189258401,.6441634037,.6687183100,
     1 .6925645366,.7156768123,.7380306437,.7596023411,.7803690438,
     1 .8003087441,.8194003107,.8376235112,.8549590334,.8713885059,
     1 .8868945174,.9014606353,.9150714231,.9277124567,.9393703398,
     1 .9500327178,.9596882914,.9683268285,.9759391746,.9825172636,
     1 .9880541263,.9925439003,.9959818430,.9983643759,.9996895039/
        DATA W/.4679139346,.3607615730,.1713244924,
     1 .2491470458,.2334925365,.2031674267,.1600783285,.1069393260,
     1 .0471753364,.1279381953,.1258374563,.1216704729,.1155056681,
     1 .1074442701,.0976186521,.0861901615,.0733464814,.0592985849,
     1 .0442774388,.0285313886,.0123412298,.0647376968,.0644661644,
     1 .0639242386,.0631141923,.0620394232,.0607044392,.0591148397,
     1 .0572772921,.0551995037,.0528901894,.0503590356,.0476166585,
     1 .0446745609,.0415450829,.0382413511,.0347772226,.0311672278,
     1 .0274265097,.0235707608,.0196161605,.0155793157,.0114772346,
     1 .0073275539,.0031533461,.0325506145,.0325161187,.0324471637,
     1 .0323438226,.0322062048,.0320344562,.0318287589,.0315893308,
     1 .0313164256,.0310103326,.0306713761,.0302999154,.0298963441,
     1 .0294610900,.0289946142,.0284974111,.0279700076,.0274129627,
     1 .0268268667,.0262123407,.0255700360,.0249006332,.0242048418,
     1 .0234833991,.0227370697,.0219666444,.0211729399,.0203567972,
     1 .0195190811,.0186606796,.0177825023,.0168854799,.0159705629,
     1 .0150387210,.0140909418,.0131282296,.0121516047,.0111621020,
     1 .0101607705,.0091486712,.0081268769,.0070964708,.0060585455,
     1 .0050142027,.0039645543,.0029107318,.0018539608,.0007967921/
C
      DATA TOLABS,TOLREL,TOLBIN,NMAX/1.E-35,5.E-5,1E-3,100/
C
      SSXINT=0
      NLIMS=2
      XLIMS(1)=XL
      XLIMS(2)=XR
      ICOUNT = 0
      IBAD=0
      XMIN=TOLBIN*ABS(XR-XL)
C
10    AA=(XLIMS(NLIMS)-XLIMS(NLIMS-1))/2
      BB=(XLIMS(NLIMS)+XLIMS(NLIMS-1))/2
      TVAL=0
      DO 15 I=1,3
15    TVAL=TVAL+W(I)*(F(BB+AA*R(I))+F(BB-AA*R(I)))
      TVAL=TVAL*AA
      DO 25 J=1,4
        VAL=0
        DO 20 I=PTR(J),PTR(J)-1+NORD(J)
          ICOUNT = ICOUNT + 1
          IF (ICOUNT .GT. 1E5) THEN
            WRITE(LOUT,*) 'ERROR IN SSXINT: SET SSXINT = 0'
            SSXINT=0
            RETURN
          ENDIF
20      VAL=VAL+W(I)*(F(BB+AA*R(I))+F(BB-AA*R(I)))
        VAL=VAL*AA
        TOL=MAX(TOLABS,TOLREL*ABS(VAL))
        IF (ABS(TVAL-VAL).LT.TOL) THEN
          SSXINT=SSXINT+VAL
          NLIMS=NLIMS-2
          IF (NLIMS.NE.0) GO TO 10
          GO TO 999
        ELSEIF(ABS(AA).LT.XMIN.AND.J.EQ.4) THEN
C           Bin is too small -- set VAL = 0. -- FEP
          IBAD=IBAD+1
          NLIMS=NLIMS-2
          IF (NLIMS.NE.0) GO TO 10
          GO TO 999
        ENDIF
25    TVAL=VAL
      IF (NMAX.EQ.2) THEN
        SSXINT=VAL
        GO TO 999
      END IF
      IF (NLIMS.GT.(NMAX-2)) THEN
        WRITE(LOUT,50) SSXINT,NMAX,BB-AA,BB+AA
50      FORMAT (' ERROR IN SSXINT, SSXINT,NMAX,XL,XR=',G15.7,I5,2G15.7)
        RETURN
      END IF
      XLIMS(NLIMS+1)=BB
      XLIMS(NLIMS+2)=BB+AA
      XLIMS(NLIMS)=BB
      NLIMS=NLIMS+2
      GO TO 10
C
999   IF(IBAD.GT.0) THEN
        WRITE(LOUT,*) 'WARNING IN SSXINT: BAD CONVERGENCE FOR ',IBAD,
     $  ' INTERVALS.'
      ENDIF
      RETURN
      END
CDECK  ID>, SSXLAM. 
      REAL FUNCTION SSXLAM(A,B,C)
C-----------------------------------------------------------------------
C          Kinematic function
C-----------------------------------------------------------------------
      IMPLICIT NONE
      REAL A,B,C
C          Rewrite SSXLAM=A**2+B**2+C**2-2*A*B-2*A*C-2*B*C
      IF(A.GE.B.AND.A.GE.C) THEN
        SSXLAM=(A-B-C)**2-4*B*C
      ELSEIF(B.GE.A.AND.B.GE.C) THEN
        SSXLAM=(B-A-C)**2-4*A*C
      ELSE
        SSXLAM=(C-A-B)**2-4*A*B
      ENDIF
      RETURN
      END
CDECK  ID>, SSZHX.  
      FUNCTION SSZHX(X)
C----------------------------------------------------------------
C          Auxiliary function for Z -> HL Z*. Called by SSTEST.
C----------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          MXSS                 = maximum number of modes
C          NSSMOD               = number of modes
C          ISSMOD               = initial particle
C          JSSMOD               = final particles
C          GSSMOD               = width
C          BSSMOD               = branching ratio
      INTEGER MXSS
      PARAMETER (MXSS=1000)
      COMMON/SSMODE/NSSMOD,ISSMOD(MXSS),JSSMOD(5,MXSS),GSSMOD(MXSS)
     $,BSSMOD(MXSS)
      INTEGER NSSMOD,ISSMOD,JSSMOD
      REAL GSSMOD,BSSMOD
      SAVE /SSMODE/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C          SM ident code definitions. These are standard ISAJET but
C          can be changed.
      INTEGER IDUP,IDDN,IDST,IDCH,IDBT,IDTP
      INTEGER IDNE,IDE,IDNM,IDMU,IDNT,IDTAU
      INTEGER IDGL,IDGM,IDW,IDZ
      PARAMETER (IDUP=1,IDDN=2,IDST=3,IDCH=4,IDBT=5,IDTP=6)
      PARAMETER (IDNE=11,IDE=12,IDNM=13,IDMU=14,IDNT=15,IDTAU=16)
      PARAMETER (IDGL=9,IDGM=10,IDW=80,IDZ=90)
C          SUSY ident code definitions. They are chosen to be similar
C          to those in versions < 6.50 but may be changed.
      INTEGER ISUPL,ISDNL,ISSTL,ISCHL,ISBT1,ISTP1
      INTEGER ISNEL,ISEL,ISNML,ISMUL,ISNTL,ISTAU1
      INTEGER ISUPR,ISDNR,ISSTR,ISCHR,ISBT2,ISTP2
      INTEGER ISNER,ISER,ISNMR,ISMUR,ISNTR,ISTAU2
      INTEGER ISZ1,ISZ2,ISZ3,ISZ4,ISW1,ISW2,ISGL
      INTEGER ISHL,ISHH,ISHA,ISHC
      INTEGER ISGRAV
      PARAMETER (ISUPL=21,ISDNL=22,ISSTL=23,ISCHL=24,ISBT1=25,ISTP1=26)
      PARAMETER (ISNEL=31,ISEL=32,ISNML=33,ISMUL=34,ISNTL=35,ISTAU1=36)
      PARAMETER (ISUPR=41,ISDNR=42,ISSTR=43,ISCHR=44,ISBT2=45,ISTP2=46)
      PARAMETER (ISNER=51,ISER=52,ISNMR=53,ISMUR=54,ISNTR=55,ISTAU2=56)
      PARAMETER (ISGL=29)
      PARAMETER (ISZ1=30,ISZ2=40,ISZ3=50,ISZ4=60,ISW1=39,ISW2=49)
      PARAMETER (ISHL=82,ISHH=83,ISHA=84,ISHC=86)
      PARAMETER (ISGRAV=91)
C
      REAL X,SSZHX
      REAL MHL,MZ,GZ,R,DEN,TERM
C
      MHL=TMP(1)
      MZ=AMZ
      GZ=GAMZ
      R=MHL/MZ
      TERM=(1.-X+X**2/12.+2*R**2/3.)*SQRT(X**2-4*R**2)
      DEN=(X-R**2)**2+(GZ/MZ)**2
      SSZHX=TERM/DEN
      RETURN
      END
CDECK  ID>, SSZWF1. 
        REAL FUNCTION SSZWF1(E)
C-----------------------------------------------------------------------
C          SSWZBF: ziss -> wiss f fbar
C          Baer's Z2WFUN
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      REAL MW,MZ,M,F1,F2,E,X,Y,WWID
C
      MW=TMP(1)
      MZ=TMP(2)
      X=TMP(3)
      Y=TMP(4)
      M=AMW
      WWID=GAMW
C
      F1=SQRT(MAX(0.,E**2-MW**2))/
     $((MZ**2+MW**2-M**2-2*MZ*E)**2+WWID**2*M**2)
      F2=(X**2+Y**2)*(3*(MZ**2+MW**2)*MZ*E-4*MZ**2*E*E-2*MZ**2*MW**2)
     $-3*(X**2-Y**2)*MZ*MW*(MZ**2+MW**2-2*MZ*E)
      SSZWF1=F1*F2
      RETURN
      END
CDECK  ID>, SSZZF1. 
      REAL FUNCTION SSZZF1(X)
C-----------------------------------------------------------------------
C          SSWZBF: ziss -> zjss f fbar
C          Baer's TFUNC
C-----------------------------------------------------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      REAL X
      DOUBLE PRECISION N,S,Q,D,SQBRKT,TERM1,QS
      DOUBLE PRECISION MZ2,MZ1,M,DSN
C
      MZ2=TMP(1)
      MZ1=TMP(2)
      M=TMP(3)
      DSN=TMP(4)
C
      N=MZ1**2/MZ2**2
      S=M**2/MZ2**2
      Q=X*(1.D0-N)/2.
      QS=Q**2
      D=(S-2*S*Q-N)/((1.D0-2*Q)*(S-2*Q-N))
      IF(D.LE.0.) THEN
        WRITE(LOUT,*) 'ERROR IN SSZZF1: D,S,Q,N=',D,S,Q,N
        SSZZF1=0
        RETURN
      END IF
      SQBRKT=-Q*(1.D0-2*Q-N)/(1.D0-2*Q)-(2*Q-S+N)/2.D0*DLOG(D)
      TERM1=QS*(1.D0-2*Q-N)**2/(1.D0-2*Q-S)**2/(1.D0-2*Q)
     $+DSQRT(N)/2.D0/(1.D0-2*Q-S)*SQBRKT*DSN
      SSZZF1=(1.D0-N)/2.D0*TERM1
      RETURN
      END
CDECK  ID>, SSZZF2. 
      REAL FUNCTION SSZZF2(E)
C-----------------------------------------------------------------------
C          SSWZBF: ziss -> zjss f fbar
C          Baer's Z2ZFUN
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      REAL E
      DOUBLE PRECISION MZ1,MZ2,SN,M,PI,F1,F2,ZWID,MF,BF
      DATA PI/3.14159265D0/
C
      MZ2=TMP(1)
      MZ1=TMP(2)
      SN=TMP(4)
      MF=TMP(6)
      M=AMZ
      ZWID=GAMZ
      BF=DSQRT(MAX(0.D0,1.D0-4*MF**2/(MZ2**2+MZ1**2-2*E*MZ2)))
C
      F1=SQRT(MAX(0.D0,E**2-MZ1**2))/
     $((MZ1**2+MZ2**2-M**2-2*MZ2*E)**2+ZWID**2*M**2)
      F2=E*(MZ1**2+MZ2**2+2*SN*MZ1*MZ2)-MZ2*(E**2+MZ1**2)-
     $BF*MZ2*(E**2-MZ1**2)/3.D0-SN*MZ1*(MZ1**2+MZ2**2-2*MF**2)
      SSZZF2=MZ2*BF*F1*F2/2.D0/PI**3
      RETURN
      END
CDECK  ID>, SSZZF3. 
        REAL FUNCTION SSZZF3(SP)
C-----------------------------------------------------------------------
C          SSWZBF: ziss -> zjss f fbar
C          Baer's FI
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      REAL SP
      DOUBLE PRECISION S,PI,M2,M1,MS,E,QS,MUS,BKT
      DOUBLE PRECISION THZ,TERM,MZ,DFI,Q,MF,QP
      DATA PI/3.14159265D0/
C
      MZ=AMZ
      M2=TMP(1)
      M1=TMP(2)
      MS=TMP(3)
      THZ=TMP(4)
      MF=TMP(6)
C
      S=SP
      E=(S+M2**2-M1**2)/2.D0/M2
      QS=E**2-S
      Q=DSQRT(MAX(0.D0,QS))
      QP=Q*DSQRT(1.D0-4*MF**2/S)
      MUS=MS**2+S-M1**2-MF**2
      BKT=(MS**2-M1**2-MF**2)*(MS**2-M2**2-MF**2)+THZ*M1*M2*(S-2*MF**2)
      TERM=DLOG((M2*(E+QP)-MUS)/(M2*(E-QP)-MUS))
      DFI=-.5D0*M2*E*QP-.5D0*(MS**2-M2**2-S-MF**2)*QP-BKT*TERM/4.D0/M2
      DFI=DFI*PI**2/2.D0/M2/(S-MZ**2)
      SSZZF3=DFI
      RETURN
      END
CDECK  ID>, SSZZF4. 
      REAL FUNCTION SSZZF4(E)
C-----------------------------------------------------------------------
C          Z_I -> Z_J +B +BBAR VIA HIGGS
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      REAL E
      DOUBLE PRECISION MZ1,MZ2,SN,EE,MH1,MH2,P,MF,BF
C
      MZ2=TMP(1)
      MZ1=TMP(2)
      MH1=TMP(3)
      SN=TMP(4)
      MH2=TMP(5)
      MF=TMP(6)
      EE=E
C
      P=SQRT(MAX(0.D0,EE**2-MZ1**2))
      BF=DSQRT(1.D0-4*MF**2/(MZ2**2+MZ1**2-2*E*MZ2))
      SSZZF4=P*BF*(MZ2**2+MZ1**2-2*MZ2*EE-2*MF**2)*
     $(MZ2*EE+SN*MZ2*MZ1)/(MZ2**2+MZ1**2-2*MZ2*EE-MH1**2)/
     $(MZ2**2+MZ1**2-2*MZ2*EE-MH2**2)
      RETURN
      END
CDECK  ID>, SSZZF5. 
        REAL FUNCTION SSZZF5(SP)
C-----------------------------------------------------------------------
C          SSWZBF: ziss -> zjss f fbar
C          Drees' I26 integrand for higgs-sfermion interference
C-----------------------------------------------------------------------
      IMPLICIT NONE
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Temporary parameters for functions
      COMMON/SSTMP/TMP(10),ITMP(10)
      REAL TMP
      INTEGER ITMP
      SAVE /SSTMP/
C
      REAL SP
      DOUBLE PRECISION S,M2,M1,MS,E,QS,MUS,BKT
      DOUBLE PRECISION THZ,TERM,MH,DFI,Q,MF,QP
C
      M2=TMP(1)
      M1=TMP(2)
      MS=TMP(3)
      MH=TMP(5)
      THZ=TMP(4)
      MF=TMP(6)
C
      S=SP
      E=(S+M2**2-M1**2)/2.D0/M2
      QS=E**2-S
      Q=DSQRT(MAX(0.D0,QS))
      QP=Q*DSQRT(1.D0-4*MF**2/S)
      MUS=MS**2+S-M1**2-MF**2
      BKT=S*MS**2-MF**2*(M1**2+M2**2)+THZ*M1*M2*(S-2*MF**2)
      TERM=DLOG((M2*(E+QP)-MUS)/(M2*(E-QP)-MUS))
      DFI=(S*QP/2.D0+BKT*TERM/4.D0/M2)/(S-MH**2)
      SSZZF5=DFI
      RETURN
      END
CDECK  ID>, SUALFE. 
C----------------------------------------------------------------------
      FUNCTION SUALFE(QS)
C----------------------------------------------------------------------
C
C     Returns the running EM coupling alpha_em(q**2)
C
C-----SEE BARGER/PHILLIPS, P. 202 ---------------------------
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
      REAL SUALFE
      REAL PI,MB,SUM,A0,QD,QU,MS,ME,QS,MM,MD,MU,MTAU,MC
      DATA ME/.0005/,MM/.105/,MTAU/1.784/,MU/.01/,MD/.01/
      DATA MS/.5/,MC/1.6/,MB/5.0/,PI/3.1415926/
C
      SUM=0.
      QU=2./3.
      QD=-1./3.
      IF (QS.GT.4*ME**2) SUM=SUM+LOG(QS/4./ME**2)
      IF (QS.GT.4*MM**2) SUM=SUM+LOG(QS/4./MM**2)
      IF (QS.GT.4*MTAU**2) SUM=SUM+LOG(QS/4./MTAU**2)
      IF (QS.GT.4*MU**2) SUM=SUM+3*QU**2*LOG(QS/4./MU**2)
      IF (QS.GT.4*MD**2) SUM=SUM+3*QD**2*LOG(QS/4./MD**2)
      IF (QS.GT.4*MS**2) SUM=SUM+3*QD**2*LOG(QS/4./MS**2)
      IF (QS.GT.4*MC**2) SUM=SUM+3*QU**2*LOG(QS/4./MC**2)
      IF (QS.GT.4*MB**2) SUM=SUM+3*QD**2*LOG(QS/4./MB**2)
      A0=1./137.
      SUALFE=A0/(1.-A0/3./PI*SUM)
      RETURN
      END
CDECK  ID>, SUALFS. 
C----------------------------------------------------------------------
      FUNCTION SUALFS(QSQ,ALAM4,TMASS,LOOP)
C----------------------------------------------------------------------
C
C       This function returns the 1, 2, or 3-loop value of alpha_s
C       Input:
C               QSQ     = Q**2 (real)
C               ALAM4   = Lambda for 4 active quark flavors (real)
C               TMASS   = top quark mass to determine lambda-6 (real)
C               LOOP    = number of loops for alpha_s (= 1, 2 or 3)
C       Parametrization of the strong coupling constant according to
C       LOOP = 1, 2 : from the book;
C       LOOP = 3:     W. J. Marciano, Phys. Rev. D 29 (1984) 580.
C       Note : threshold at 2*Mq
C
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
      REAL SUALFS, QSQ, ALAM4, TMASS
      INTEGER LOOP
      REAL PI, BMASS
      REAL ANF, ALAM, ALAMSQ, ALAM5, T, TT, B0, B1, B2, X, ALPHAS
      DATA PI/3.1415927/, BMASS/5.0/
C
      IF (QSQ .LT. 4.0*BMASS**2) THEN
        ANF   = 4.0
        ALAM  = ALAM4
      ELSE IF (QSQ .LT. 4.0*TMASS**2) THEN
        ANF   = 5.0
        ALAM  = ALAM4*(ALAM4/(2.0*BMASS))**(2.0/23.0)
     1           *(ALOG(4.0*BMASS**2/ALAM4**2))**(-963.0/13225.0)
      ELSE
        ANF   = 6.0
        ALAM5 = ALAM4*(ALAM4/(2.0*BMASS))**(2.0/23.0)
     1           *(ALOG(4.0*BMASS**2/ALAM4**2))**(-963.0/13225.0)
        ALAM  = ALAM5*(ALAM5/(2.0*TMASS))**(2.0/21.0)
     1           *(ALOG(4.0*TMASS**2/ALAM5**2))**(-107.0/1127.0)
      END IF
      B0       = 11.0-2.0/3.0*ANF
      ALAMSQ   = ALAM**2
      T        = ALOG(QSQ/ALAMSQ)
      IF (T .LE. 1.0) T = ALOG(4.0/ALAMSQ)
      ALPHAS   = 4*PI/B0/T
      IF (LOOP .EQ. 1) THEN
        SUALFS = ALPHAS
      ELSE IF (LOOP .EQ. 2) THEN
        B1 = 102.0-38.0/3.0*ANF
        X  = B1/(B0**2*T)
        TT = ALOG(T)
        SUALFS = ALPHAS*(1.0-X*TT)
      ELSE IF (LOOP .EQ. 3) THEN
        B1 = 102.0-38.0/3.0*ANF
        B2 = 0.5*(2857.0-5033.0/9.0*ANF+325.0/27.0*ANF**2)
        X  = B1/(B0**2*T)
        TT = ALOG(T)
        SUALFS = ALPHAS*(1.0-X*TT+X**2*((TT-0.5)**2
     $      +B2*B0/B1**2-1.25))
      ELSE
        WRITE(LOUT,*) ' WRONG LOOP NUMBER IN ALPHA-S EVALUATION!'
        STOP 99
      END IF
C
      RETURN
      END
CDECK  ID>, SUGEFF. 
C-----------------------------------------------------------------
      SUBROUTINE SUGEFF(G0,SIG1,SIG2)
C-----------------------------------------------------------------
C
C     Compute Higgs mass shift due to 1-loop effective potential
C
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
      COMMON /SUGPAS/ XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,NOGOOD,
     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ
      REAL XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,
     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ
      INTEGER NOGOOD
      SAVE /SUGPAS/
C          Frozen couplings from RG equations:
C     GSS( 1) = g_1        GSS( 2) = g_2        GSS( 3) = g_3
C     GSS( 4) = y_tau      GSS( 5) = y_b        GSS( 6) = y_t
C     GSS( 7) = M_1        GSS( 8) = M_2        GSS( 9) = M_3
C     GSS(10) = A_tau      GSS(11) = A_b        GSS(12) = A_t
C     GSS(13) = M_h1^2     GSS(14) = M_h2^2     GSS(15) = M_er^2
C     GSS(16) = M_el^2     GSS(17) = M_dnr^2    GSS(18) = M_upr^2
C     GSS(19) = M_upl^2    GSS(20) = M_taur^2   GSS(21) = M_taul^2
C     GSS(22) = M_btr^2    GSS(23) = M_tpr^2    GSS(24) = M_tpl^2
C     GSS(25) = mu         GSS(26) = B
C          Masses:
C     MSS( 1) = glss     MSS( 2) = upl      MSS( 3) = upr
C     MSS( 4) = dnl      MSS( 5) = dnr      MSS( 6) = stl
C     MSS( 7) = str      MSS( 8) = chl      MSS( 9) = chr
C     MSS(10) = b1       MSS(11) = b2       MSS(12) = t1
C     MSS(13) = t2       MSS(14) = nuel     MSS(15) = numl
C     MSS(16) = nutl     MSS(17) = el-      MSS(18) = er-
C     MSS(19) = mul-     MSS(20) = mur-     MSS(21) = tau1
C     MSS(22) = tau2     MSS(23) = z1ss     MSS(24) = z2ss
C     MSS(25) = z3ss     MSS(26) = z4ss     MSS(27) = w1ss
C     MSS(28) = w2ss     MSS(29) = hl0      MSS(30) = hh0
C     MSS(31) = ha0      MSS(32) = h+
C          Unification:
C     MGUTSS  = M_GUT    GGUTSS  = g_GUT    AGUTSS  = alpha_GUT
      COMMON /SUGMG/ MSS(32),GSS(26),MGUTSS,GGUTSS,AGUTSS
      REAL MSS,GSS,MGUTSS,GGUTSS,AGUTSS
      SAVE /SUGMG/
      REAL G0(26),SIG1,SIG2
      REAL DT1,DELT1S,SIG1T1,DMSDV2,FB,FT,MST2,MSB2,MSB1,SIG2B1,
     $SIG1B1,SIG2B2,SIG1B2,DB1,SIG1T2,SIG2T1,DELB1S,SIG2T2,MST1,COS2W,
     $MT,PI,COTB,TANB,MB,MZ,SIG2B,SIG1B,G,GGP,SIG2T,E,FAC,SIG1T,QS,
     $BETA,SINB,COSB
      DATA MZ/91.187/
C
      G=G2
      TANB=XTANB
      COS2W=1.-XW
      COTB=1./TANB
      BETA=ATAN(TANB)
      SINB=SIN(BETA)
      COSB=COS(BETA)
      PI=4.*ATAN(1.)
      FAC=3./8./PI**2
      E=EXP(1.)
      QS=HIGFRZ**2
C-----CALCULATE TOP AND BOTTOM CONTRIBUTIONS; USE RUNNING MASSES--
      FB=G0(5)
      FT=G0(6)
      MT=FT*VEV*SINB
      MB=FB*VEV*COSB
      SIG1T=0.
      SIG2T=-FAC*MT**2*G0(6)**2*LOG(MT**2/E/QS)
      SIG1B=-FAC*MB**2*G0(5)**2*LOG(MB**2/E/QS)
      SIG2B=0.
      GGP=(G**2+GP**2)/2.
      MST1=MSS(12)
      MST2=MSS(13)
      MSB1=MSS(10)
      MSB2=MSS(11)
C-----CALCULATE STOP_1 CONTRIBUTION -------------------------------
      DELT1S=(.5*(G0(24)-G0(23))+(8*COS2W-5.)*GGP*
     $        (VP*VP-V*V)/12.)**2+G0(6)**2*V*V*(G0(12)-MU*COTB)**2
      DT1=.5*(G0(24)-G0(23))+(8*COS2W-5.)*GGP*
     $       (VP*VP-V*V)/12.
      DMSDV2=GGP/4.-(2*DT1*(8*COS2W-5.)*GGP/12.-
     $        FT**2*MU*(G0(12)*TANB-MU))/2./SQRT(DELT1S)
      SIG1T1=FAC/2.*MST1**2*LOG(MST1**2/E/QS)*DMSDV2
      DMSDV2=-GGP/4.+FT**2-(-2*DT1*(8*COS2W-5.)*GGP/12.+
     $        FT**2*G0(12)*(G0(12)-MU*COTB))/2./SQRT(DELT1S)
      SIG2T1=FAC/2.*MST1**2*LOG(MST1**2/E/QS)*DMSDV2
C-----CALCULATE STOP_2 CONTRIBUTION -------------------------------
      DMSDV2=GGP/4.+(2*DT1*(8*COS2W-5.)*GGP/12.-
     $        FT**2*MU*(G0(12)*TANB-MU))/2./SQRT(DELT1S)
      SIG1T2=FAC/2.*MST2**2*LOG(MST2**2/E/QS)*DMSDV2
      DMSDV2=-GGP/4.+FT**2+(-2*DT1*(8*COS2W-5.)*GGP/12.+
     $        FT**2*G0(12)*(G0(12)-MU*COTB))/2./SQRT(DELT1S)
      SIG2T2=FAC/2.*MST2**2*LOG(MST2**2/E/QS)*DMSDV2
C-----CALCULATE SBOT_1 CONTRIBUTION -------------------------------
      DELB1S=(.5*(G0(24)-G0(22))-(4*COS2W-1.)*GGP*
     $  (VP*VP-V*V)/12.)**2+G0(5)**2*VP*VP*(G0(11)-MU*TANB)**2
      DB1=.5*(G0(24)-G0(22))-(4*COS2W-1.)*GGP*
     $       (VP*VP-V*V)/12.
      DMSDV2=-GGP/4.+FB**2-(-2*DB1*(4*COS2W-1.)*GGP/12.+
     $        FB**2*G0(11)*(G0(11)-MU*TANB))/2./SQRT(DELB1S)
      SIG1B1=FAC/2.*MSB1**2*LOG(MSB1**2/E/QS)*DMSDV2
      DMSDV2=GGP/4.-(2*DB1*(4*COS2W-1.)*GGP/12.-
     $        FB**2*MU*(G0(11)*COTB-MU))/2./SQRT(DELB1S)
      SIG2B1=FAC/2.*MSB1**2*LOG(MSB1**2/E/QS)*DMSDV2
C-----CALCULATE SBOT_2 CONTRIBUTION -------------------------------
      DMSDV2=-GGP/4.+FB**2+(-2*DB1*(4*COS2W-1.)*GGP/12.+
     $        FB**2*G0(11)*(G0(11)-MU*TANB))/2./SQRT(DELB1S)
      SIG1B2=FAC/2.*MSB2**2*LOG(MSB2**2/E/QS)*DMSDV2
      DMSDV2=GGP/4.+(2*DB1*(4*COS2W-1.)*GGP/12.-
     $        FB**2*MU*(G0(11)*COTB-MU))/2./SQRT(DELB1S)
      SIG2B2=FAC/2.*MSB2**2*LOG(MSB2**2/E/QS)*DMSDV2
C-----ADD ALL TERMS ------------------------------------------------
      SIG1=SIG1B+SIG1B1+SIG1B2+SIG1T+SIG1T1+SIG1T2
      SIG2=SIG2B+SIG2B1+SIG2B2+SIG2T+SIG2T1+SIG2T2
      RETURN
      END
CDECK  ID>, SUGFRZ. 
C------------------------------------------------------------------
      SUBROUTINE SUGFRZ(Q,G,G0,IG)
C------------------------------------------------------------------
C
C     Freeze out final soft breaking parameters
C
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
      COMMON /SUGPAS/ XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,NOGOOD,
     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ
      REAL XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,
     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ
      INTEGER NOGOOD
      SAVE /SUGPAS/
      DIMENSION G(26),G0(26)
      INTEGER IG(26)
      REAL Q,MT
      REAL G,G0,MZ,TANB
      INTEGER I
      DATA MZ/91.187/
C
      TANB=XTANB
      MT=AMT
      DO 200 I=1,5
        G0(I)=G(I)
200   CONTINUE
      IF (Q.LT.MT.AND.IG(6).EQ.0) THEN
        G3MT=G(3)
        G0(6)=G(6)
        IG(6)=1
      END IF
C          Freeze out running gluino mass at MGL
      DO 210 I=7,12
        IF (Q.LT.ABS(G(I)).AND.IG(I).EQ.0) THEN
          G0(I)=G(I)
          IG(I)=1
        ELSE IF (IG(I).EQ.0) THEN
          G0(I)=G(I)
        END IF
210   CONTINUE
C          Freeze out Higgs paremeters at HIGFRZ
      DO 211 I=13,14
        IF (Q.LT.HIGFRZ.AND.IG(I).EQ.0) THEN
          G0(I)=G(I)
          IG(I)=1
          G0(I+12)=G(I+12)
          IG(I+12)=1
        ELSE IF (IG(I).EQ.0) THEN
          G0(I)=G(I)
          G0(I+12)=G(I+12)
        END IF
211   CONTINUE
C          Freeze out rest at own masses
      DO 220 I=15,24
        IF (G(I).LT.0.) THEN
          G(I)=0.
          NOGOOD=1
          GO TO 100
        END IF
        IF (Q.LT.SQRT(G(I)).AND.IG(I).EQ.0) THEN
          G0(I)=G(I)
          IG(I)=1
        ELSE IF (IG(I).EQ.0) THEN
          G0(I)=G(I)
        END IF
220   CONTINUE
100   RETURN
      END
CDECK  ID>, SUGMAS. 
C---------------------------------------------------------------
      SUBROUTINE SUGMAS(G0,ILOOP,IMODEL)
C---------------------------------------------------------------
C
C     Compute tree level sparticle masses; output to MSS, XISAIN
C
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
      COMMON /SUGPAS/ XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,NOGOOD,
     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ
      REAL XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,
     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ
      INTEGER NOGOOD
      SAVE /SUGPAS/
C     XSUGIN contains the inputs to SUGRA:
C     XSUGIN(1) = M_0        XSUGIN(2) = M_(1/2)  XSUGIN(3) = A_0
C     XSUGIN(4) = tan(beta)  XSUGIN(5) = sgn(mu)  XSUGIN(6) = M_t
C     XGMIN(1) = LAM         XGMIN(2)  = M_MES    XGMIN(3)  = XN5
C     XISAIN contains the MSSMi inputs in natural order.
      COMMON /SUGXIN/ XISAIN(24),XSUGIN(6),XGMIN(7)
      REAL XISAIN,XSUGIN,XGMIN
      SAVE /SUGXIN/
C          Frozen couplings from RG equations:
C     GSS( 1) = g_1        GSS( 2) = g_2        GSS( 3) = g_3
C     GSS( 4) = y_tau      GSS( 5) = y_b        GSS( 6) = y_t
C     GSS( 7) = M_1        GSS( 8) = M_2        GSS( 9) = M_3
C     GSS(10) = A_tau      GSS(11) = A_b        GSS(12) = A_t
C     GSS(13) = M_h1^2     GSS(14) = M_h2^2     GSS(15) = M_er^2
C     GSS(16) = M_el^2     GSS(17) = M_dnr^2    GSS(18) = M_upr^2
C     GSS(19) = M_upl^2    GSS(20) = M_taur^2   GSS(21) = M_taul^2
C     GSS(22) = M_btr^2    GSS(23) = M_tpr^2    GSS(24) = M_tpl^2
C     GSS(25) = mu         GSS(26) = B
C          Masses:
C     MSS( 1) = glss     MSS( 2) = upl      MSS( 3) = upr
C     MSS( 4) = dnl      MSS( 5) = dnr      MSS( 6) = stl
C     MSS( 7) = str      MSS( 8) = chl      MSS( 9) = chr
C     MSS(10) = b1       MSS(11) = b2       MSS(12) = t1
C     MSS(13) = t2       MSS(14) = nuel     MSS(15) = numl
C     MSS(16) = nutl     MSS(17) = el-      MSS(18) = er-
C     MSS(19) = mul-     MSS(20) = mur-     MSS(21) = tau1
C     MSS(22) = tau2     MSS(23) = z1ss     MSS(24) = z2ss
C     MSS(25) = z3ss     MSS(26) = z4ss     MSS(27) = w1ss
C     MSS(28) = w2ss     MSS(29) = hl0      MSS(30) = hh0
C     MSS(31) = ha0      MSS(32) = h+
C          Unification:
C     MGUTSS  = M_GUT    GGUTSS  = g_GUT    AGUTSS  = alpha_GUT
      COMMON /SUGMG/ MSS(32),GSS(26),MGUTSS,GGUTSS,AGUTSS
      REAL MSS,GSS,MGUTSS,GGUTSS,AGUTSS
      SAVE /SUGMG/
      REAL MSB1,MSB2,MST1,MST2
      REAL G0(26)
      REAL SUGMFN,SUALFS,SSPOLE,MHP,MGLMGL,MHPS,
     $RDEL,ASMGL,DELHPS,M1S,M2S,FNB,FCN,
     $MB,FNT,MT,MW,TANB,BETA,COSB,COTB,SINB,MZ,COS2B,
     $PI,T2S,G,ATAU,MSSS,AT,AB,BRKT,B2S,T1S,TERM,B1S,Q,
     $MBQ,MTAMZ,MTQ,FNL,MSL1,MSL2,ASMB,MBMB,ASMT,MTMT
      REAL AA,BB,CC,DA,DB,DC,L1,L2,EVAL1,RL1,RL2
      DOUBLE PRECISION SSMQCD
      INTEGER IALLOW,ILOOP,MHLNEG,MHCNEG,IMODEL
C
C          Statement function
C
      SUGMFN(Q)=Q**2*(LOG(Q**2/HIGFRZ**2)-1.)
C
      PI=4.*ATAN(1.)
      XW=.232
      G=G2
      TANB=XTANB
      MT=AMT
      MZ=AMZ
      MW=AMW
      AMTP=MT
      BETA=ATAN(TANB)
      COTB=1./TANB
      SINB=SIN(BETA)
      COSB=COS(BETA)
      SIN2B=SIN(2*BETA)
      COS2B=COS(2*BETA)
      AT=G0(12)
      AB=G0(11)
      ATAU=G0(10)
      ASMB=SUALFS(AMBT**2,.36,AMTP,3)
      MBMB=AMBT*(1.-4*ASMB/3./PI)
      MBQ=SSMQCD(DBLE(MBMB),DBLE(HIGFRZ))
      ASMT=SUALFS(AMTP**2,.36,AMTP,3)
      MTMT=AMTP/(1.+4*ASMT/3./PI+(16.11-1.04*(5.-6.63/AMTP))*
     $(ASMT/PI)**2)
      MTQ=SSMQCD(DBLE(MTMT),DBLE(HIGFRZ))
      MTAMZ=FTAMZ*COSB*VEV
C
C          Compute some masses from RGE solution to prepare for SSMASS,
C          which computes the rest.
C
      MSSS=G0(19)+AMUP**2+(.5-2*XW/3.)*MZ**2*COS2B
      IF (MSSS.LE.0.) THEN
        NOGOOD=1
        GO TO 100
      END IF
C          Squark and slepton masses
      MSS(2)=SQRT(MSSS)
      MSS(3)=SQRT(G0(18)+AMUP**2+2./3.*XW*MZ**2*COS2B)
      MSS(4)=SQRT(G0(19)+AMDN**2+(-.5+XW/3.)*MZ**2*COS2B)
      MSS(5)=SQRT(G0(17)+AMDN**2-1./3.*XW*MZ**2*COS2B)
      MSS(6)=SQRT(G0(19)+AMST**2+(-.5+XW/3.)*MZ**2*COS2B)
      MSS(7)=SQRT(G0(17)+AMST**2-1./3.*XW*MZ**2*COS2B)
      MSS(8)=SQRT(G0(19)+AMCH**2+(.5-2*XW/3.)*MZ**2*COS2B)
      MSS(9)=SQRT(G0(18)+AMCH**2+2./3.*XW*MZ**2*COS2B)
      BRKT=(.5*(G0(24)-G0(22))-COS2B*(4*MW**2-MZ**2)/12.)**2+
     $       MBQ**2*(AB-MU*TANB)**2
      TERM=.5*(G0(24)+G0(22))+MBQ**2-MZ**2*COS2B/4.
      B1S=TERM-SQRT(BRKT)
      B2S=TERM+SQRT(BRKT)
      MSS(10)=SQRT(MAX(0.,B1S))
      MSS(11)=SQRT(MAX(0.,B2S))
      BRKT=(.5*(G0(24)-G0(23))+COS2B*(8*MW**2-5*MZ**2)/12.)**2+
     $       MTQ**2*(AT-MU*COTB)**2
      TERM=.5*(G0(24)+G0(23))+MTQ**2+MZ**2*COS2B/4.
      T1S=TERM-SQRT(BRKT)
      IF (T1S.LE.0.) THEN
        NOGOOD=1
        GO TO 100
      END IF
      T2S=TERM+SQRT(BRKT)
      MSS(12)=SQRT(MAX(0.,T1S))
      MSS(13)=SQRT(MAX(0.,T2S))
      MSSS=G0(16)+.5*MZ**2*COS2B
      IF (MSSS.LE.0.) THEN
        NOGOOD=1
        GO TO 100
      END IF
      MSS(14)=SQRT(MSSS)
      MSS(15)=MSS(14)
      MSSS=G0(21)+.5*MZ**2*COS2B
      IF (MSSS.LE.0.) THEN
        NOGOOD=1
        GO TO 100
      END IF
      MSS(16)=SQRT(MSSS)
      MSS(17)=SQRT(G0(16)+AME**2-.5*(2*MW**2-MZ**2)*COS2B)
      MSS(18)=SQRT(G0(15)+AME**2+(MW**2-MZ**2)*COS2B)
      MSS(19)=SQRT(G0(16)+AMMU**2-.5*(2*MW**2-MZ**2)*COS2B)
      MSS(20)=SQRT(G0(15)+AMMU**2+(MW**2-MZ**2)*COS2B)
      BRKT=(.5*(G0(21)-G0(20))-COS2B*(4*MW**2-3*MZ**2)/4.)**2+
     $       MTAMZ**2*(ATAU-MU*TANB)**2
      TERM=.5*(G0(21)+G0(20))+MTAMZ**2-MZ**2*COS2B/4.
      T1S=TERM-SQRT(BRKT)
      IF (T1S.LE.0.) THEN
        NOGOOD=1
        GO TO 100
      END IF
      T2S=TERM+SQRT(BRKT)
      MSS(21)=SQRT(MAX(0.,T1S))
      MSS(22)=SQRT(MAX(0.,T2S))
C          A0 mass
      M1S=MU**2+G0(13)
      M2S=MU**2+G0(14)
      MSB1=MSS(10)
      MSB2=MSS(11)
      MST1=MSS(12)
      MST2=MSS(13)
      MSL1=MSS(21)
      MSL2=MSS(22)
      MB=AMBT
      FNT=(SUGMFN(MST2)-SUGMFN(MST1))/(MST2**2-MST1**2)
     $*AT*MTQ**2/SINB**2
      FNB=(SUGMFN(MSB2)-SUGMFN(MSB1))/(MSB2**2-MSB1**2)
     $*AB*MBQ**2/COSB**2
      FNL=(SUGMFN(MSL2)-SUGMFN(MSL1))/(MSL2**2-MSL1**2)
     $*ATAU*MTAMZ**2/COSB**2
      FCN=FNT+FNB+FNL/3.
      DELHPS=3*G0(2)**2*MU*(COTB+TANB)/32./PI**2/MW**2*FCN
      RDEL=SQRT(ABS(DELHPS))
C          Tree level mhp not needed at this point so fix if negative
      IF (ILOOP.EQ.0) THEN
        MHPS=M1S+M2S
        IF (MHPS.LT.0.) MHPS=0.
      ELSE
        MHPS=B*MU*(COTB+TANB)+DELHPS
        IF (MHPS.LT.0.) THEN
          NOGOOD=3
          MHPS=AMZ**2
        END IF
      END IF
      MHP=SQRT(MHPS)
      MSS(31)=MHP
C     APPLY XERXES' TEST FOR PROPER POTENTIAL SHAPE AT THE ORIGIN
      IF (ILOOP.EQ.1) THEN
      L1=MIN(G0(24),G0(23))
      L2=MAX(G0(24),G0(23))
      RL1=SQRT(L1)
      RL2=SQRT(L2)
      DA=3*G0(6)**2*AT**2/ABS(G0(24)-G0(23))/16./PI**2*
     $(-SUGMFN(RL1)+SUGMFN(RL2))
      DB=3*G0(6)**2/16./PI**2*
     $(SUGMFN(RL1)*(1.-AT**2/ABS(G0(24)-G0(23)))+SUGMFN(RL2)*
     $(1.+AT**2/ABS(G0(24)-G0(23))))
      DC=-3*G0(6)**2*AT*MU/ABS(G0(24)-G0(23))/16./PI**2*
     $(-SUGMFN(RL1)+SUGMFN(RL2))
      AA=M1S+DA
      BB=M2S+DB
      CC=-B*MU+DC
      EVAL1=((AA+BB)-SQRT((AA+BB)**2-4*(AA*BB-CC*CC)))/2.
      IF (EVAL1.GE.0) THEN
        NOGOOD=7
      END IF
      END IF
C
C          Initialize SUSY parameters in /SSPAR/:
C
      AMGLSS=G0(9)
      AMULSS=MSS(2)
      AMURSS=MSS(3)
      AMDLSS=MSS(4)
      AMDRSS=MSS(5)
      AMSLSS=MSS(6)
      AMSRSS=MSS(7)
      AMCLSS=MSS(8)
      AMCRSS=MSS(9)
      AMN1SS=MSS(16)
      AMN2SS=MSS(16)
      AMN3SS=MSS(16)
      AMELSS=MSS(17)
      AMERSS=MSS(18)
      AMMLSS=MSS(19)
      AMMRSS=MSS(20)
      TWOM1=-MU
      RV2V1=1./TANB
      AMTLSS=SQRT(G0(24))
      AMTRSS=SQRT(G0(23))
      AMBLSS=SQRT(G0(24))
      AMBRSS=SQRT(G0(22))
      AMLLSS=SQRT(G0(21))
      AMLRSS=SQRT(G0(20))
      AAT=G0(12)
      AAB=G0(11)
      AAL=G0(10)
      AMHA=MHP
C
C          Use SSMASS to diagonalize neutralino and chargino mass
C          matrices and calculate Higgs masses.
C
      MHLNEG=0
      MHCNEG=0
      CALL SSMASS(G0(7),G0(8),IALLOW,ILOOP,MHLNEG,MHCNEG,IMODEL)
      IF(MHLNEG.EQ.1.OR.MHCNEG.EQ.1) THEN
        NOGOOD=8
      ENDIF
      IF(IALLOW.NE.0) THEN
        NOGOOD=5
        GO TO 100
      ENDIF
C
C          Save results also in MSS
C
      MSS(23)=AMZ1SS
      MSS(24)=AMZ2SS
      MSS(25)=AMZ3SS
      MSS(26)=AMZ4SS
      MSS(27)=AMW1SS
      MSS(28)=AMW2SS
      MSS(29)=AMHL
      MSS(30)=AMHH
      MSS(31)=AMHA
      MSS(32)=AMHC
C          Gluino pole mass
      MGLMGL=G0(9)
      ASMGL=SUALFS(MGLMGL**2,.36,MT,3)
      MSS(1)=SSPOLE(MGLMGL,MGLMGL**2,ASMGL)
      AMGLSS=MSS(1)
C
100   RETURN
      END
CDECK  ID>, SUGRA.  
C--------------------------------------------------------------------
      SUBROUTINE SUGRA(M0,MHF,A0,TANB,SGNMU,MT,IMODEL)
C--------------------------------------------------------------------
C
C     Calculate supergravity spectra for ISAJET using as inputs
C     M0    = M_0       = common scalar mass at GUT scale
C     MHF   = M_(1/2)   = common gaugino mass at GUT scale
C     A0    = A_0       = trilinear soft breaking parameter at GUT scale
C     TANB  = tan(beta) = ratio of vacuum expectation values v_1/v_2
C     SGNMU = sgn(mu)   = +-1 = sign of Higgsino mass term
C     MT    = M_t       = mass of t quark
C     If IMODEL=2, then do instead gauge mediated model
C     M0    = Lambda    = ratio of vevs <F>/<S>
C     MHF   = M_Mes     = messenger scale
C     A0    = n_5       = number of messenger fields

C
C     Uses Runge-Kutta method to integrate RGE's from M_Z to M_GUT
C     and back, putting in correct thresholds. For the first iteration
C     only the first 6 couplings are included and a common threshold
C     is used.
C
C     See /SUGMG/ for definitions of couplings and masses.
C
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          SUSY parameters
C          AMGLSS               = gluino mass
C          AMULSS               = up-left squark mass
C          AMELSS               = left-selectron mass
C          AMERSS               = right-slepton mass
C          AMNiSS               = sneutrino mass for generation i
C          TWOM1                = Higgsino mass = - mu
C          RV2V1                = ratio v2/v1 of vev's
C          AMTLSS,AMTRSS        = left,right stop masses
C          AMT1SS,AMT2SS        = light,heavy stop masses
C          AMBLSS,AMBRSS        = left,right sbottom masses
C          AMB1SS,AMB2SS        = light,heavy sbottom masses
C          AMLLSS,AMLRSS        = left,right stau masses
C          AML1SS,AML2SS        = light,heavy stau masses
C          AMZiSS               = signed mass of Zi
C          ZMIXSS               = Zi mixing matrix
C          AMWiSS               = signed Wi mass
C          GAMMAL,GAMMAR        = Wi left, right mixing angles
C          AMHL,AMHH,AMHA       = neutral Higgs h0, H0, A0 masses
C          AMHC                 = charged Higgs H+ mass
C          ALFAH                = Higgs mixing angle
C          AAT                  = stop trilinear term
C          THETAT               = stop mixing angle
C          AAB                  = sbottom trilinear term
C          THETAB               = sbottom mixing angle
C          AAL                  = stau trilinear term
C          THETAL               = stau mixing angle
C          AMGVSS               = gravitino mass
      COMMON/SSPAR/AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS(4,4)
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMGLSS,AMULSS,AMURSS,AMDLSS,AMDRSS,AMSLSS
     $,AMSRSS,AMCLSS,AMCRSS,AMBLSS,AMBRSS,AMB1SS,AMB2SS
     $,AMTLSS,AMTRSS,AMT1SS,AMT2SS,AMELSS,AMERSS,AMMLSS,AMMRSS
     $,AMLLSS,AMLRSS,AML1SS,AML2SS,AMN1SS,AMN2SS,AMN3SS
     $,TWOM1,RV2V1,AMZ1SS,AMZ2SS,AMZ3SS,AMZ4SS,ZMIXSS
     $,AMW1SS,AMW2SS
     $,GAMMAL,GAMMAR,AMHL,AMHH,AMHA,AMHC,ALFAH,AAT,THETAT
     $,AAB,THETAB,AAL,THETAL,AMGVSS
      REAL AMZISS(4)
      EQUIVALENCE (AMZISS(1),AMZ1SS)
      SAVE /SSPAR/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
C     XSUGIN contains the inputs to SUGRA:
C     XSUGIN(1) = M_0        XSUGIN(2) = M_(1/2)  XSUGIN(3) = A_0
C     XSUGIN(4) = tan(beta)  XSUGIN(5) = sgn(mu)  XSUGIN(6) = M_t
C     XGMIN(1) = LAM         XGMIN(2)  = M_MES    XGMIN(3)  = XN5
C     XISAIN contains the MSSMi inputs in natural order.
      COMMON /SUGXIN/ XISAIN(24),XSUGIN(6),XGMIN(7)
      REAL XISAIN,XSUGIN,XGMIN
      SAVE /SUGXIN/
C          Frozen couplings from RG equations:
C     GSS( 1) = g_1        GSS( 2) = g_2        GSS( 3) = g_3
C     GSS( 4) = y_tau      GSS( 5) = y_b        GSS( 6) = y_t
C     GSS( 7) = M_1        GSS( 8) = M_2        GSS( 9) = M_3
C     GSS(10) = A_tau      GSS(11) = A_b        GSS(12) = A_t
C     GSS(13) = M_h1^2     GSS(14) = M_h2^2     GSS(15) = M_er^2
C     GSS(16) = M_el^2     GSS(17) = M_dnr^2    GSS(18) = M_upr^2
C     GSS(19) = M_upl^2    GSS(20) = M_taur^2   GSS(21) = M_taul^2
C     GSS(22) = M_btr^2    GSS(23) = M_tpr^2    GSS(24) = M_tpl^2
C     GSS(25) = mu         GSS(26) = B
C          Masses:
C     MSS( 1) = glss     MSS( 2) = upl      MSS( 3) = upr
C     MSS( 4) = dnl      MSS( 5) = dnr      MSS( 6) = stl
C     MSS( 7) = str      MSS( 8) = chl      MSS( 9) = chr
C     MSS(10) = b1       MSS(11) = b2       MSS(12) = t1
C     MSS(13) = t2       MSS(14) = nuel     MSS(15) = numl
C     MSS(16) = nutl     MSS(17) = el-      MSS(18) = er-
C     MSS(19) = mul-     MSS(20) = mur-     MSS(21) = tau1
C     MSS(22) = tau2     MSS(23) = z1ss     MSS(24) = z2ss
C     MSS(25) = z3ss     MSS(26) = z4ss     MSS(27) = w1ss
C     MSS(28) = w2ss     MSS(29) = hl0      MSS(30) = hh0
C     MSS(31) = ha0      MSS(32) = h+
C          Unification:
C     MGUTSS  = M_GUT    GGUTSS  = g_GUT    AGUTSS  = alpha_GUT
      COMMON /SUGMG/ MSS(32),GSS(26),MGUTSS,GGUTSS,AGUTSS
      REAL MSS,GSS,MGUTSS,GGUTSS,AGUTSS
      SAVE /SUGMG/
      COMMON /SUGPAS/ XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,NOGOOD,
     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ
      REAL XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,
     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ
      INTEGER NOGOOD
      SAVE /SUGPAS/
C     XNUSUG contains non-universal GUT scale soft terms for SUGRA:
C     XNUSUG(1)=M1 XNUSUG(2)=M2 XNUSUG(3)=M3
C     XNUSUG(4)=A_tau XNUSUG(5)=A_b XNUSUG(6)=A_t
C     XNUSUG(7)=m_Hd XNUSUG(8)=m_Hu XNUSUG(9)=m_eR XNUSUG(10)=m_eL
C     XNUSUG(11)=m_dR XNUSUG(12)=m_uR XNUSUG(13)=m_uL XNUSUG(14)=m_lR
C     XNUSUG(15)=m_lL XNUSUG(16)=m_bR XNUSUG(17)=m_tR XNUSUG(18)=m_tL
C
      COMMON /SUGNU/ XNUSUG(18)
      REAL XNUSUG
      SAVE /SUGNU/
      REAL GY(6),W1(18),G(26),W2(78)
      REAL G0(26)
      INTEGER IG(26)
      EXTERNAL SURG06,SURG26
      REAL M0,MHF,A0,TANB,SGNMU,MT,XLAMGM,XMESGM,XN5GM
      INTEGER NSTEP
      REAL M2,SUALFE,SUALFS,Q,T,A1I,AGUT,A3I,A2I,MTMT,ASMT,DT,
     $TGUT,TZ,GGUT,SIG2,SIG1,MH1S,MH2S,FBGUT,FTAGUT,AGUTI,
     $FTGUT,MUS,MBMZ,MB,MTAU,MZ,MW,SR2,PI,ALEM,MTAMZ,
     $MTAMB,MTAMTA,MBMB,ASMB,BETA,COTB,SINB,COS2B,COSB,XC
      INTEGER II,I,J,IMODEL
      REAL G0SAVE(26),DELG0,DELLIM
      INTEGER MXITER,NSTEP0
C
      DATA MZ/91.187/,MTAU/1.784/,MB/4.9/,ALEM/.0078186/
C          This choice is a compromise between precision and speed:
      DATA MXITER/20/,NSTEP0/200/,DELLIM/2.E-2/
C
C          Save input parameters
C
      XSUGIN(1)=M0
      XSUGIN(2)=MHF
      XSUGIN(3)=A0
      XSUGIN(4)=TANB
      XSUGIN(5)=SGNMU
      XSUGIN(6)=MT
      XLAMGM=M0
      XMESGM=MHF
      XN5GM=A0
      XGMIN(1)=XLAMGM
      XGMIN(2)=XMESGM
      XGMIN(3)=XN5GM
      XGMIN(4)=TANB
      XGMIN(5)=SGNMU
      XGMIN(6)=MT
C
C          Initialize standard model parameters in /SSSM/:
C
      AMUP=0.0056
      AMDN=0.0099
      AMST=0.199
      AMCH=1.35
      AMBT=5.0
      AMTP=MT
      AMT=MT
      AME=0.511E-3
      AMMU=0.105
      AMTAU=1.784
      AMZ=91.17
      GAMW=2.12
      GAMZ=2.487
      ALFAEM=1./128.
      SN2THW=0.232
      ALFA2=ALFAEM/SN2THW
      ALQCD4=0.177
      ALFA3=0.12
C
      NOGOOD=0
      PI=4.*ATAN(1.)
      SR2=SQRT(2.)
      XW=.2324-1.03E-7*(MT**2-138.**2)
      MW=MZ*SQRT(1.-XW)
      AMW=MW
      A1MZ=5*ALEM/3./(1.-XW)
      A2MZ=ALEM/XW
      G2=SQRT(4*PI*A2MZ)
      GP=SQRT(3./5.*A1MZ*4.*PI)
      XTANB=TANB
      COTB=1./TANB
      BETA=ATAN(TANB)
      SINB=SIN(BETA)
      COSB=COS(BETA)
      SIN2B=SIN(2*BETA)
      COS2B=COS(2*BETA)
      V=SQRT(2*MW**2/G2**2/(1.+COTB**2))
      VP=V/TANB
      VEV=SQRT(V**2+VP**2)
      IF (IMODEL.EQ.1) THEN
        MSUSY=2.3*MHF
      ELSE IF (IMODEL.EQ.2) THEN
        MSUSY=XLAMGM/100.
      END IF
C
C          Compute m(tau), m(b) at z scale using qcd, qed
C
      MTAMTA=MTAU*(1.-SUALFE(MTAU**2)/PI)
      MTAMB=MTAMTA*(SUALFE(MB**2)/SUALFE(MTAU**2))**(-27./76.)
      MTAMZ=MTAMB*(SUALFE(MZ**2)/SUALFE(MB**2))**(-27./80.)
      FTAMZ=MTAMZ/COSB/VEV
      ASMB=SUALFS(MB**2,.36,MT,3)
      MBMB=MB*(1.-4*ASMB/3./PI)
      ASMZ=SUALFS(MZ**2,.36,MT,3)
      MBMZ=MBMB*(ASMZ/ASMB)**(12./23.)*
     $      (SUALFE(MZ**2)/SUALFE(MB**2))**(-3./80.)
      FBMZ=MBMZ/COSB/VEV
      ASMT=SUALFS(MT**2,.36,MT,3)
      MTMT=MT/(1.+4*ASMT/3./PI+(16.11-1.04*(5.-6.63/MT))*(ASMT/PI)**2)
      FTMT=MTMT/SINB/VEV
C
C          Run the 3 gauge and 3 Yukawa's up to find M_GUT ,A_GUT and
C          Yukawa_GUT
C
C
      NSTEP=NSTEP0
      GY(1)=SQRT(4*PI*A1MZ)
      GY(2)=SQRT(4*PI*A2MZ)
      GY(3)=SQRT(4*PI*ASMZ)
      GY(4)=FTAMZ
      GY(5)=FBMZ
      GY(6)=0.
      IF (IMODEL.EQ.1) THEN
        MGUT=1.E19
      ELSE IF (IMODEL.EQ.2) THEN
        MGUT=XMESGM
      END IF
      TZ=LOG(MZ/MGUT)
      TGUT=0.
      DT=(TGUT-TZ)/FLOAT(NSTEP)
      DO 200 II=1,NSTEP
        T=TZ+(TGUT-TZ)*FLOAT(II-1)/FLOAT(NSTEP)
        Q=MGUT*EXP(T)
        IF (Q.GT.MT.AND.GY(6).EQ.0.) GY(6)=FTMT
        CALL RKSTP(6,DT,T,GY,SURG06,W1)
        A1I=4*PI/GY(1)**2
        A2I=4*PI/GY(2)**2
        A3I=4*PI/GY(3)**2
        IF (GY(5).GT.100..OR.GY(6).GT.100.) THEN
          NOGOOD=4
          GO TO 100
        END IF
        IF (A1I.LT.A2I) GO TO 10
200   CONTINUE
      IF (IMODEL.EQ.1) THEN
      WRITE(LOUT,*) 'SUGRA: NO UNIFICATION FOUND'
      GO TO 100
      END IF
10    MGUT=Q
      AGUT=(GY(1)**2/4./PI+GY(2)**2/4./PI)/2.
      GGUT=SQRT(4*PI*AGUT)
      AGUTI=1./AGUT
      FTAGUT=GY(4)
      FBGUT=GY(5)
      FTGUT=GY(6)
C
C          Define parameters at GUT scale
C
      DO 210 J=1,3
        IF (IMODEL.EQ.1) THEN
          G(J)=GGUT
          G(J+6)=MHF
          G(J+9)=A0
        ELSE IF (IMODEL.EQ.2) THEN
          G(J)=GY(J)
          G(J+6)=XN5GM*(GY(J)/4./PI)**2*XLAMGM
          G(J+9)=0.
        END IF
210   CONTINUE
      G(4)=FTAGUT
      G(5)=FBGUT
      G(6)=FTGUT
      IF (IMODEL.EQ.1) THEN
        DO 220 J=13,24
          G(J)=M0**2
220     CONTINUE
C       Set possible non-universal boundary conditions
      DO 230 J=1,6
        IF (XNUSUG(J).LT.1.E19) THEN
          G(J+6)=XNUSUG(J)
        END IF
230   CONTINUE
      DO 231 J=7,18
        IF (XNUSUG(J).LT.1.E19) THEN
          G(J+6)=XNUSUG(J)**2
        END IF
231   CONTINUE
      ELSE IF (IMODEL.EQ.2) THEN
       XC=2*XN5GM*XLAMGM**2
       G(13)=XC*(.75*(GY(2)/4./PI)**4+.6*.25*(GY(1)/4./PI)**4)
       G(14)=G(13)
       G(15)=XC*(.6*(GY(1)/4./PI)**4)
       G(16)=G(13)
       G(17)=XC*(4*(GY(3)/4./PI)**4/3.+.6*(GY(1)/4./PI)**4/9.)
       G(18)=XC*(4*(GY(3)/4./PI)**4/3.+.6*4*(GY(1)/4./PI)**4/9.)
       G(19)=XC*(4*(GY(3)/4./PI)**4/3.+.75*(GY(2)/4./PI)**4+
     ,           .6*(GY(1)/4./PI)**4/36.)
       G(20)=G(15)
       G(21)=G(16)
       G(22)=G(17)
       G(23)=G(18)
       G(24)=G(19)
      END IF
      G(25)=0.
      G(26)=0.
      DO 235 I=1,26
        IG(I)=0
235   CONTINUE
C
C          Initialize thresholds
C
      MSS(1)=MSUSY
      MSS(2)=MSUSY
      MSS(17)=MSUSY
      MSS(27)=MSUSY
      MSS(31)=MSUSY
      MU=MSUSY
C
C          Evolve parameters from mgut to mz
C
      TZ=LOG(MZ/MGUT)
      TGUT=0.
      DT=(TZ-TGUT)/FLOAT(NSTEP)
C          Freeze Higgs parameters at HIGFRZ = Drees' value
C          AMTLSS, AMTRSS initialized to 0 for later use in HIGFRZ
      IF (IMODEL.EQ.1) THEN
        HIGFRZ=SQRT(M0**2+3*MHF**2)
      ELSE IF (IMODEL.EQ.2) THEN
        HIGFRZ=MSUSY
      END IF
      AMTLSS=0
      AMTRSS=0
      DO 240 II=1,NSTEP+2
        T=TGUT+(TZ-TGUT)*FLOAT(II-1)/FLOAT(NSTEP)
        Q=MGUT*EXP(T)
        CALL RKSTP(26,DT,T,G,SURG26,W2)
        CALL SUGFRZ(Q,G,G0,IG)
        IF (NOGOOD.NE.0) GO TO 100
        IF (Q.LT.MZ) GO TO 20
240   CONTINUE
20    CONTINUE
      ASMZ=G0(3)**2/4./PI
C          Electroweak breaking constraints; tree level
      MUS=(G0(13)-G0(14)*TANB**2)/(TANB**2-1.)-MZ**2/2.
      IF (MUS.LT.0.) THEN
        NOGOOD=2
        GO TO 100
      END IF
      MU=SQRT(MUS)*SIGN(1.,SGNMU)
      B=(G0(13)+G0(14)+2*MUS)*SIN2B/MU/2.
C          Compute tree level masses
      CALL SUGMAS(G0,0,IMODEL)
      IF (NOGOOD.NE.0) GO TO 100
C          Compute effective potential corrections
      CALL SUGEFF(G0,SIG1,SIG2)
      MH1S=G0(13)+SIG1
      MH2S=G0(14)+SIG2
      MUS=(MH1S-MH2S*TANB**2)/(TANB**2-1.)-MZ**2/2.
      IF (MUS.LT.0.) THEN
        NOGOOD=2
        GO TO 100
      END IF
      MU=SQRT(MUS)*SIGN(1.,SGNMU)
      B=(MH1S+MH2S+2*MUS)*SIN2B/MU/2.
C
C          Iterate entire process, increasing NSTEP each time
C          This time, freeze out parameters at sqrt(t_l t_r)
C
      HIGFRZ=MAX(AMZ,(G0(23)*G0(24))**0.25)
      DO 300 I=1,MXITER
        DO 310 J=1,26
310     G0SAVE(J)=G0(J)
        NSTEP=1.2*NSTEP
        CALL SUGRGE(M0,MHF,A0,TANB,SGNMU,MT,G,G0,IG,W2,NSTEP,IMODEL)
        IF(NOGOOD.NE.0) GO TO 100
        DELG0=0.
        DO 320 J=1,24
320     DELG0=MAX(DELG0,ABS((G0(J)-G0SAVE(J))/G0(J)))
        IF(DELG0.LT.DELLIM) GO TO 400
300   CONTINUE
      WRITE(LOUT,1000) MXITER
1000  FORMAT(/' SUGRA WARNING: NO CONVERGENCE IN',I4,' ITERATIONS')
C
C          Save results
C
400   DO 410 I=1,26
        GSS(I)=G0(I)
410   CONTINUE
      MGUTSS=MGUT
      AGUTSS=AGUT
      GGUTSS=GGUT
C          Fill xisain common block
C
      XISAIN(1)=MSS(1)
      XISAIN(2)=MU
      XISAIN(3)=MSS(31)
      XISAIN(4)=TANB
      XISAIN(5)=SQRT(G0(19))
      XISAIN(6)=SQRT(G0(17))
      XISAIN(7)=SQRT(G0(18))
      XISAIN(8)=SQRT(G0(16))
      XISAIN(9)=SQRT(G0(15))
      XISAIN(10)=XISAIN(5)
      XISAIN(11)=XISAIN(6)
      XISAIN(12)=XISAIN(7)
      XISAIN(13)=XISAIN(8)
      XISAIN(14)=XISAIN(9)
      XISAIN(15)=SQRT(G0(24))
      XISAIN(16)=SQRT(G0(22))
      XISAIN(17)=SQRT(G0(23))
      XISAIN(18)=SQRT(G0(21))
      XISAIN(19)=SQRT(G0(20))
      XISAIN(20)=G0(12)
      XISAIN(21)=G0(11)
      XISAIN(22)=G0(10)
      XISAIN(23)=G0(7)
      XISAIN(24)=G0(8)
      M2=G0(8)
100   RETURN
      END
CDECK  ID>, SUGRGE. 
      SUBROUTINE SUGRGE(M0,MHF,A0,TANB,SGNMU,MT,G,G0,IG,W2
     $,NSTEP,IMODEL)
C
C          Make one complete iteration of the renormalization group
C          equations from MZ to MGUT and back, setting the boundary
C          conditions on each end.
C
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          Standard model parameters
C          AMUP,...,AMTP        = quark masses
C          AME,AMMU,AMTAU       = lepton masses
C          AMW,AMZ              = W,Z masses
C          GAMW,GAMZ            = W,Z widths
C          ALFAEM,SN2THW,ALFA3  = SM couplings
C          ALQCD4               = 4 flavor lambda
      COMMON/SSSM/AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      REAL AMUP,AMDN,AMST,AMCH,AMBT,AMTP,AME,AMMU,AMTAU
     $,AMW,AMZ,GAMW,GAMZ,ALFAEM,SN2THW,ALFA2,ALFA3,ALQCD4
      SAVE /SSSM/
      COMMON /SUGPAS/ XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,NOGOOD,
     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ
      REAL XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,
     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ
      INTEGER NOGOOD
      SAVE /SUGPAS/
C     XNUSUG contains non-universal GUT scale soft terms for SUGRA:
C     XNUSUG(1)=M1 XNUSUG(2)=M2 XNUSUG(3)=M3
C     XNUSUG(4)=A_tau XNUSUG(5)=A_b XNUSUG(6)=A_t
C     XNUSUG(7)=m_Hd XNUSUG(8)=m_Hu XNUSUG(9)=m_eR XNUSUG(10)=m_eL
C     XNUSUG(11)=m_dR XNUSUG(12)=m_uR XNUSUG(13)=m_uL XNUSUG(14)=m_lR
C     XNUSUG(15)=m_lL XNUSUG(16)=m_bR XNUSUG(17)=m_tR XNUSUG(18)=m_tL
C
      COMMON /SUGNU/ XNUSUG(18)
      REAL XNUSUG
      SAVE /SUGNU/
C
      EXTERNAL SURG26
      REAL M0,MHF,A0,TANB,SGNMU,MT,G(26),G0(26),W2(78)
      INTEGER IG(26),NSTEP,IMODEL
      REAL PI,TZ,A1I,A2I,A3I,FBGUT,GGUT,AGUTI,FTAGUT,SIG1,SIG2,
     $MH1S,MH2S,MUS,T,MZ,TGUT,DT,AGUT,Q,FTGUT,ASMT,MTMT,SINB,
     $BETA,QOLD,XLAMGM,XMESGM,XN5GM,XC
      INTEGER I,II
      DATA MZ/91.187/
C
C          Re-initialize weak scale parameters
C
      XLAMGM=M0
      XMESGM=MHF
      XN5GM=A0
      PI=4.*ATAN(1.)
      BETA=ATAN(XTANB)
      SINB=SIN(BETA)
      ASMZ=G0(3)**2/4./PI
      ASMT=G3MT**2/4./PI
      MTMT=MT/(1.+4*ASMT/3./PI+(16.11-1.04*(5.-6.63/MT))*(ASMT/PI)**2)
      FTMT=MTMT/SINB/VEV
      G(1)=SQRT(4*PI*A1MZ)
      G(2)=SQRT(4*PI*A2MZ)
      G(3)=SQRT(4*PI*ASMZ)
      G(4)=FTAMZ
      G(5)=FBMZ
      G(6)=G(6)
      G(25)=MU
      G(26)=B
C
C          Run back up to mgut with approximate susy spectra
C
      IF (IMODEL.EQ.1) THEN
        MGUT=1.E19
      ELSE IF (IMODEL.EQ.2) THEN
        MGUT=XMESGM
      END IF
      TZ=LOG(MZ/MGUT)
      TGUT=0.
      DT=(TGUT-TZ)/FLOAT(NSTEP)
      DO 250 II=1,NSTEP
        T=TZ+(TGUT-TZ)*FLOAT(II-1)/FLOAT(NSTEP)
        QOLD=Q
        Q=MGUT*EXP(T)
        IF (QOLD.LE.MT.AND.Q.GT.MT) G(6)=FTMT
        CALL RKSTP(26,DT,T,G,SURG26,W2)
        A1I=4*PI/G(1)**2
        A2I=4*PI/G(2)**2
        A3I=4*PI/G(3)**2
        IF (G(5).GT.100..OR.G(6).GT.100.) THEN
          NOGOOD=4
          GO TO 100
        END IF
        IF (A1I.LT.A2I) GO TO 30
250   CONTINUE
      IF (IMODEL.EQ.1) THEN
        WRITE(LOUT,*) 'SUGRGE ERROR: NO UNIFICATION FOUND'
        NOGOOD=1
        GO TO 100
      END IF
30    MGUT=Q
      AGUT=(G(1)**2/4./PI+G(2)**2/4./PI)/2.
      GGUT=SQRT(4*PI*AGUT)
      AGUTI=1./AGUT
      FTAGUT=G(4)
      FBGUT=G(5)
      FTGUT=G(6)
C
C          Set GUT boundary condition
C
      DO 260 I=1,3
        IF (IMODEL.EQ.1) THEN
          G(I)=GGUT
          G(I+6)=MHF
          G(I+9)=A0
        ELSE IF (IMODEL.EQ.2) THEN
          G(I)=G(I)
          G(I+6)=XN5GM*(G(I)/4./PI)**2*XLAMGM
          G(I+9)=0.
        END IF
260   CONTINUE
      IF (IMODEL.EQ.1) THEN
        DO 270 I=13,24
          G(I)=M0**2
270     CONTINUE
C     Set possible non-universal GUT scale boundary conditions
      DO 280 I=1,6
        IF (XNUSUG(I).LT.1.E19) THEN
          G(I+6)=XNUSUG(I)
        END IF
280   CONTINUE
      DO 281 I=7,18
        IF (XNUSUG(I).LT.1.E19) THEN
          G(I+6)=XNUSUG(I)**2
        END IF
281   CONTINUE
      ELSE IF (IMODEL.EQ.2) THEN
       XC=2*XN5GM*XLAMGM**2
       G(13)=XC*(.75*(G(2)/4./PI)**4+.6*.25*(G(1)/4./PI)**4)
       G(14)=G(13)
       G(15)=XC*(.6*(G(1)/4./PI)**4)
       G(16)=G(13)
       G(17)=XC*(4*(G(3)/4./PI)**4/3.+.6*(G(1)/4./PI)**4/9.)
       G(18)=XC*(4*(G(3)/4./PI)**4/3.+.6*4*(G(1)/4./PI)**4/9.)
       G(19)=XC*(4*(G(3)/4./PI)**4/3.+.75*(G(2)/4./PI)**4+
     ,           .6*(G(1)/4./PI)**4/36.)
       G(20)=G(15)
       G(21)=G(16)
       G(22)=G(17)
       G(23)=G(18)
       G(24)=G(19)
      END IF
      DO 285 I=1,26
        IG(I)=0
285   CONTINUE
C
C          Run back down to weak scale
C
      TZ=LOG(MZ/MGUT)
      TGUT=0.
      DT=(TZ-TGUT)/FLOAT(NSTEP)
      DO 290 II=1,NSTEP+2
        T=TGUT+(TZ-TGUT)*FLOAT(II-1)/FLOAT(NSTEP)
        Q=MGUT*EXP(T)
        CALL RKSTP(26,DT,T,G,SURG26,W2)
        CALL SUGFRZ(Q,G,G0,IG)
        IF (NOGOOD.NE.0) GO TO 100
        IF (Q.LT.MZ) GO TO 40
290   CONTINUE
40    CONTINUE
C
C          Electroweak breaking constraints; tree level
C
      MUS=(G0(13)-G0(14)*TANB**2)/(TANB**2-1.)-MZ**2/2.
      IF (MUS.LT.0.) THEN
        NOGOOD=2
        GO TO 100
      END IF
      MU=SQRT(MUS)*SIGN(1.,SGNMU)
      B=(G0(13)+G0(14)+2*MUS)*SIN2B/MU/2.
      CALL SUGMAS(G0,0,IMODEL)
      IF (NOGOOD.NE.0) GO TO 100
C
C           Electroweak breaking constraints; loop level
C
      CALL SUGEFF(G0,SIG1,SIG2)
      MH1S=G0(13)+SIG1
      MH2S=G0(14)+SIG2
      MUS=(MH1S-MH2S*TANB**2)/(TANB**2-1.)-MZ**2/2.
      IF (MUS.LT.0.) THEN
        NOGOOD=2
        GO TO 100
      END IF
      MU=SQRT(MUS)*SIGN(1.,SGNMU)
      B=(MH1S+MH2S+2*MUS)*SIN2B/MU/2.
      CALL SUGMAS(G0,1,IMODEL)
C
100   RETURN
      END
CDECK  ID>, SURG06. 
C-----------------------------------------------------------------
      SUBROUTINE SURG06(T,GY,F)
C-----------------------------------------------------------------
C
C     Right hand side of truncated renormalization group equations
C          dG_i/dT = F_i(G)
C     using a single common scale MSUSY for SUSY mass thresholds.
C
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
      COMMON /SUGPAS/ XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,NOGOOD,
     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ
      REAL XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,
     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ
      INTEGER NOGOOD
      SAVE /SUGPAS/
      REAL T,GY(6),F(6)
      REAL SINB,BETA,COSB,B1,THTOP,B3,B2,TH2LP,B12,B11,B21,B13,
     $MZ,MT,TANB,PI,Q,B33,B23,B22,B32,B31
      REAL A11,A12,A13,A21,A22,A23,A31,A32,A33
      REAL C11,C12,C13,C21,C22,C23,C31,C32,C33
      REAL D11,D12,D13,D21,D22,D23,D31,D32,D33
      INTEGER NSL,NSD,NSH,NSE,NSU,NSQ,NU,NSG,NSW,NH,NN,NE,ND
      DATA MZ/91.17/
      DATA ND/3/,NE/3/,NN/3/
      DATA B11/7.96/,B12/5.4/,B13/17.6/,B21/1.8/,B22/25./,B23/24./
      DATA B31/2.2/,B32/9./,B33/14./
      DATA A11/5.2/,A12/2.8/,A13/3.6/,A21/6./,A22/6./,A23/2./
      DATA A31/4./,A32/4./,A33/0./
      DATA C11/1.7/,C12/.5/,C13/1.5/,C21/1.5/,C22/1.5/,C23/.5/
      DATA C31/2./,C32/2./,C33/0./
      DATA D11/3.98/,D12/2.7/,D13/8.8/,D21/.9/,D22/5.833/,D23/12./
      DATA D31/1.1/,D32/4.5/,D33/-26./
      TANB=XTANB
      MT=AMT
C-----THESE ARE VALID FROM MZ TO MGUT
      Q=MGUT*EXP(T)
      PI=4.*ATAN(1.)
      BETA=ATAN(TANB)
      SINB=SIN(BETA)
      COSB=SQRT(1.-SINB**2)
      IF (Q.GT.MSUSY) THEN
        NSQ=3
        NSU=3
        NSD=3
        NSL=3
        NSE=3
        NSH=2
        NSW=1
        NSG=1
        NH=2
        TH2LP=1.
      ELSE
        NSQ=0
        NSU=0
        NSD=0
        NSL=0
        NSE=0
        NSH=0
        NSW=0
        NSG=0
        NH=1
        TH2LP=0.
      END IF
      IF (Q.GT.MT) THEN
        NU=3
        THTOP=1.
      ELSE
        NU=2
        THTOP=0.
      END IF
      TH2LP=1.
      THTOP=1.
      B1=2.*(17*NU/12.+5*ND/12.+5*NE/4.+NN/4.)/5.+
     $ NSQ/30.+4*NSU/15.+NSD/15.+NSL/10.+NSE/5.+
     $ 1.*NSH/5.+1.*NH/10.
      B2=-22./3.+.5*(NU+ND)+1.*(NE+NN)/6.+
     $ 1.*NSQ/2.+1.*NSL/6.+1.*NSH/3.+1.*NH/6.+4.*NSW/3.
      B3=2.*(NU+ND)/3.+1.*NSQ/3.+1.*NSU/6.+1.*NSD/6.+2.*NSG-11.
      IF (Q.GT.MSUSY) THEN
      F(1)=GY(1)/16./PI**2*(B1*GY(1)**2+TH2LP/16./PI**2*GY(1)**2*
     $(B11*GY(1)**2+B12*GY(2)**2+B13*GY(3)**2-A11*GY(6)**2-A12*GY(5)**2
     $-A13*GY(4)**2))
      F(2)=GY(2)/16./PI**2*(B2*GY(2)**2+TH2LP/16./PI**2*GY(2)**2*
     $(B21*GY(1)**2+B22*GY(2)**2+B23*GY(3)**2-A21*GY(6)**2-A22*GY(5)**2
     $-A23*GY(4)**2))
      F(3)=GY(3)/16./PI**2*(B3*GY(3)**2+TH2LP/16./PI**2*GY(3)**2*
     $(B31*GY(1)**2+B32*GY(2)**2+B33*GY(3)**2-A31*GY(6)**2-A32*GY(5)**2
     $-A33*GY(4)**2))
      ELSE
      F(1)=GY(1)/16./PI**2*(B1*GY(1)**2+TH2LP/16./PI**2*GY(1)**2*
     $(D11*GY(1)**2+D12*GY(2)**2+D13*GY(3)**2-C11*GY(6)**2-C12*GY(5)**2
     $-C13*GY(4)**2))
      F(2)=GY(2)/16./PI**2*(B2*GY(2)**2+TH2LP/16./PI**2*GY(2)**2*
     $(D21*GY(1)**2+D22*GY(2)**2+D23*GY(3)**2-C21*GY(6)**2-C22*GY(5)**2
     $-C23*GY(4)**2))
      F(3)=GY(3)/16./PI**2*(B3*GY(3)**2+TH2LP/16./PI**2*GY(3)**2*
     $(D31*GY(1)**2+D32*GY(2)**2+D33*GY(3)**2-C31*GY(6)**2-C32*GY(5)**2
     $-C33*GY(4)**2))
      ENDIF
      IF (Q.LT.MSUSY) THEN
        F(4)=GY(4)/16./PI**2*(5*GY(4)**2*COSB**2/2.+3*GY(6)**2*SINB**2*
     $   THTOP+3*GY(5)**2*COSB**2-9*GY(1)**2/4.-9*GY(2)**2/4.
     $   -SINB**2*(3*GY(6)**2*THTOP-3*GY(5)**2-GY(4)**2))
        F(5)=GY(5)/16./PI**2*(9*GY(5)**2*COSB**2/2.+3*GY(6)**2*SINB**2*
     $   THTOP/2.+GY(4)**2*COSB**2-GY(1)**2/4.-9*GY(2)**2/4.
     $   -8*GY(3)**2-SINB**2*(3*GY(6)**2*THTOP-3*GY(5)**2-GY(4)**2))
        F(6)=GY(6)/16./PI**2*(9*GY(6)**2*SINB**2/2.*THTOP+
     $   3*GY(5)**2*COSB**2/2.+GY(4)**2*COSB**2-17.*GY(1)**2/20.
     $   -9*GY(2)**2/4.-8*GY(3)**2+COSB**2*
     $   (3*GY(6)**2*THTOP-3*GY(5)**2-GY(4)**2))
      ELSE
        F(4)=GY(4)/16./PI**2*(4*GY(4)**2+3*GY(5)**2-
     $        9*GY(1)**2/5.-3*GY(2)**2)
        F(5)=GY(5)/16./PI**2*(6*GY(5)**2+GY(6)**2*THTOP+
     $        GY(4)**2-7*GY(1)**2/15.-3*GY(2)**2-16*GY(3)**2/3.)
        F(6)=GY(6)/16./PI**2*(6*GY(6)**2*THTOP+GY(5)**2-
     $        13*GY(1)**2/15.-3*GY(2)**2-16*GY(3)**2/3.)
      END IF
      RETURN
      END
CDECK  ID>, SURG26. 
C-----------------------------------------------------------------
      SUBROUTINE SURG26(T,G,F)
C-----------------------------------------------------------------
C
C     Right hand side of full renormalization group equations
C          dG_i/dT = F_i(G)
C     using the thresholds MSS for each mass calculated with the
C     couplings G0 frozen by SUGFRZ.
C
      IMPLICIT NONE
      COMMON/SSLUN/LOUT
      INTEGER LOUT
      SAVE /SSLUN/
C          Frozen couplings from RG equations:
C     GSS( 1) = g_1        GSS( 2) = g_2        GSS( 3) = g_3
C     GSS( 4) = y_tau      GSS( 5) = y_b        GSS( 6) = y_t
C     GSS( 7) = M_1        GSS( 8) = M_2        GSS( 9) = M_3
C     GSS(10) = A_tau      GSS(11) = A_b        GSS(12) = A_t
C     GSS(13) = M_h1^2     GSS(14) = M_h2^2     GSS(15) = M_er^2
C     GSS(16) = M_el^2     GSS(17) = M_dnr^2    GSS(18) = M_upr^2
C     GSS(19) = M_upl^2    GSS(20) = M_taur^2   GSS(21) = M_taul^2
C     GSS(22) = M_btr^2    GSS(23) = M_tpr^2    GSS(24) = M_tpl^2
C     GSS(25) = mu         GSS(26) = B
C          Masses:
C     MSS( 1) = glss     MSS( 2) = upl      MSS( 3) = upr
C     MSS( 4) = dnl      MSS( 5) = dnr      MSS( 6) = stl
C     MSS( 7) = str      MSS( 8) = chl      MSS( 9) = chr
C     MSS(10) = b1       MSS(11) = b2       MSS(12) = t1
C     MSS(13) = t2       MSS(14) = nuel     MSS(15) = numl
C     MSS(16) = nutl     MSS(17) = el-      MSS(18) = er-
C     MSS(19) = mul-     MSS(20) = mur-     MSS(21) = tau1
C     MSS(22) = tau2     MSS(23) = z1ss     MSS(24) = z2ss
C     MSS(25) = z3ss     MSS(26) = z4ss     MSS(27) = w1ss
C     MSS(28) = w2ss     MSS(29) = hl0      MSS(30) = hh0
C     MSS(31) = ha0      MSS(32) = h+
C          Unification:
C     MGUTSS  = M_GUT    GGUTSS  = g_GUT    AGUTSS  = alpha_GUT
      COMMON /SUGMG/ MSS(32),GSS(26),MGUTSS,GGUTSS,AGUTSS
      REAL MSS,GSS,MGUTSS,GGUTSS,AGUTSS
      SAVE /SUGMG/
      COMMON /SUGPAS/ XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,NOGOOD,
     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ
      REAL XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,
     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ
      INTEGER NOGOOD
      SAVE /SUGPAS/
      REAL T,G(26),F(26)
      REAL FAC,COSB,TH2LP,B3,B2,XTAU,XT,XB,B1,THTOP,B12,B11,TANB,MT,
     $MZ,Q,B33,B32,PI,SINB,BETA,B21,B13,B22,B31,B23
      REAL A11,A12,A13,A21,A22,A23,A31,A32,A33
      REAL C11,C12,C13,C21,C22,C23,C31,C32,C33
      REAL D11,D12,D13,D21,D22,D23,D31,D32,D33
      INTEGER NSL,NSD,NSE,NSW,NSH,NSU,NSQ,NH,NSG,NU,NE,ND,NN
C
      DATA MZ/91.17/
      DATA ND/3/,NE/3/,NN/3/
      DATA B11/7.96/,B12/5.4/,B13/17.6/,B21/1.8/,B22/25./,B23/24./
      DATA B31/2.2/,B32/9./,B33/14./
      DATA A11/5.2/,A12/2.8/,A13/3.6/,A21/6./,A22/6./,A23/2./
      DATA A31/4./,A32/4./,A33/0./
      DATA C11/1.7/,C12/.5/,C13/1.5/,C21/1.5/,C22/1.5/,C23/.5/
      DATA C31/2./,C32/2./,C33/0./
      DATA D11/3.98/,D12/2.7/,D13/8.8/,D21/.9/,D22/5.833/,D23/12./
      DATA D31/1.1/,D32/4.5/,D33/-26./
C
C-----THESE ARE VALID FROM MZ TO MGUT --------------------------------
      PI=4.*ATAN(1.)
      TANB=XTANB
      MT=AMT
      Q=MGUT*EXP(T)
      BETA=ATAN(TANB)
      SINB=SIN(BETA)
      COSB=SQRT(1.-SINB**2)
      FAC=2./16./PI**2
C-----CALCULATE 1-LOOP THRESHOLD EFFECTS -----------------------------
      IF (Q.GT.MSUSY) THEN
        TH2LP=1.
      ELSE
        TH2LP=0.
      END IF
      IF (Q.GT.MSS(2)) THEN
        NSQ=3
        NSU=3
        NSD=3
      ELSE
        NSQ=0
        NSU=0
        NSD=0
      END IF
      IF (Q.GT.MSS(17)) THEN
        NSL=3
        NSE=3
      ELSE
        NSL=0
        NSE=0
      END IF
      IF (Q.GT.ABS(MU)) THEN
        NSH=2
      ELSE
        NSH=0
      END IF
      IF (Q.GT.ABS(MSS(27))) THEN
        NSW=1
      ELSE
        NSW=0
      END IF
      IF (Q.GT.MSS(1)) THEN
        NSG=1
      ELSE
        NSG=0
      END IF
      IF (Q.GT.MSS(31)) THEN
        NH=2
      ELSE
        NH=1
      END IF
      IF (Q.GT.MT) THEN
        NU=3
        THTOP=1.
      ELSE
        NU=2
        THTOP=0.
      END IF
      TH2LP=1.
      THTOP=1.
      B1=2.*(17*NU/12.+5*ND/12.+5*NE/4.+NN/4.)/5.+
     $ NSQ/30.+4*NSU/15.+NSD/15.+NSL/10.+NSE/5.+
     $ 1.*NSH/5.+1.*NH/10.
      B2=-22./3.+.5*(NU+ND)+1.*(NE+NN)/6.+
     $ 1.*NSQ/2.+1.*NSL/6.+1.*NSH/3.+1.*NH/6.+4.*NSW/3.
      B3=2.*(NU+ND)/3.+1.*NSQ/3.+1.*NSU/6.+1.*NSD/6.+2.*NSG-11.
      IF (Q.GT.MSUSY) THEN
      F(1)=G(1)/16./PI**2*(B1*G(1)**2+TH2LP/16./PI**2*G(1)**2*
     $(B11*G(1)**2+B12*G(2)**2+B13*G(3)**2-A11*G(6)**2-A12*G(5)**2
     $-A13*G(4)**2))
      F(2)=G(2)/16./PI**2*(B2*G(2)**2+TH2LP/16./PI**2*G(2)**2*
     $(B21*G(1)**2+B22*G(2)**2+B23*G(3)**2-A21*G(6)**2-A22*G(5)**2
     $-A23*G(4)**2))
      F(3)=G(3)/16./PI**2*(B3*G(3)**2+TH2LP/16./PI**2*G(3)**2*
     $(B31*G(1)**2+B32*G(2)**2+B33*G(3)**2-A31*G(6)**2-A32*G(5)**2
     $-A33*G(4)**2))
      ELSE
      F(1)=G(1)/16./PI**2*(B1*G(1)**2+TH2LP/16./PI**2*G(1)**2*
     $(D11*G(1)**2+D12*G(2)**2+D13*G(3)**2-C11*G(6)**2-C12*G(5)**2
     $-C13*G(4)**2))
      F(2)=G(2)/16./PI**2*(B2*G(2)**2+TH2LP/16./PI**2*G(2)**2*
     $(D21*G(1)**2+D22*G(2)**2+D23*G(3)**2-C21*G(6)**2-C22*G(5)**2
     $-C23*G(4)**2))
      F(3)=G(3)/16./PI**2*(B3*G(3)**2+TH2LP/16./PI**2*G(3)**2*
     $(D31*G(1)**2+D32*G(2)**2+D33*G(3)**2-C31*G(6)**2-C32*G(5)**2
     $-C33*G(4)**2))
      ENDIF
      IF (Q.LT.MSUSY) THEN
        F(4)=G(4)/16./PI**2*(5*G(4)**2*COSB**2/2.+3*G(6)**2*SINB**2*
     $   THTOP+3*G(5)**2*COSB**2-9*G(1)**2/4.-9*G(2)**2/4.
     $   -SINB**2*(3*G(6)**2*THTOP-3*G(5)**2-G(4)**2))
        F(5)=G(5)/16./PI**2*(9*G(5)**2*COSB**2/2.+3*G(6)**2*SINB**2*
     $   THTOP/2.+G(4)**2*COSB**2-G(1)**2/4.-9*G(2)**2/4.
     $   -8*G(3)**2-SINB**2*(3*G(6)**2*THTOP-3*G(5)**2-G(4)**2))
        F(6)=G(6)/16./PI**2*(9*G(6)**2*SINB**2/2.*THTOP+
     $   3*G(5)**2*COSB**2/2.+G(4)**2*COSB**2-17.*G(1)**2/20.
     $   -9*G(2)**2/4.-8*G(3)**2+COSB**2*
     $   (3*G(6)**2*THTOP-3*G(5)**2-G(4)**2))
      ELSE
        F(4)=G(4)/16./PI**2*(4*G(4)**2+3*G(5)**2-
     $        9*G(1)**2/5.-3*G(2)**2)
        F(5)=G(5)/16./PI**2*(6*G(5)**2+G(6)**2*THTOP+
     $        G(4)**2-7*G(1)**2/15.-3*G(2)**2-16*G(3)**2/3.)
        F(6)=G(6)/16./PI**2*(6*G(6)**2*THTOP+G(5)**2-
     $        13*G(1)**2/15.-3*G(2)**2-16*G(3)**2/3.)
      END IF
      F(7)=FAC*B1*G(1)**2*G(7)
      F(8)=FAC*B2*G(2)**2*G(8)
      F(9)=FAC*B3*G(3)**2*G(9)
      F(10)=FAC*(9*G(1)**2*G(7)/5.+3*G(2)**2*G(8)+3*G(5)**2*G(11)+
     $       4*G(4)**2*G(10))
      F(11)=FAC*(7*G(1)**2*G(7)/15.+3*G(2)**2*G(8)+16*G(3)**2*G(9)/3.+
     $       6*G(5)**2*G(11)+G(6)**2*G(12)+G(4)**2*G(10))
      F(12)=FAC*(13*G(1)**2*G(7)/15.+3*G(2)**2*G(8)+16*G(3)**2*G(9)/3.+
     $       G(5)**2*G(11)+6*G(6)**2*G(12))
      XTAU=G(21)+G(20)+G(13)+G(10)**2
      XB=G(24)+G(22)+G(13)+G(11)**2
      XT=G(24)+G(23)+G(14)+G(12)**2
      F(13)=FAC*(-.6*G(1)**2*G(7)**2-3*G(2)**2*G(8)**2+
     $       3*G(5)**2*XB+G(4)**2*XTAU)
      F(14)=FAC*(-.6*G(1)**2*G(7)**2-3*G(2)**2*G(8)**2+3*G(6)**2*XT)
      F(15)=-2.4*FAC*G(1)**2*G(7)**2
      F(16)=FAC*(-.6*G(1)**2*G(7)**2-3*G(2)**2*G(8)**2)
      F(17)=FAC*(-4*G(1)**2*G(7)**2/15.-16*G(3)**2*G(9)**2/3.)
      F(18)=FAC*(-16*G(1)**2*G(7)**2/15.-16*G(3)**2*G(9)**2/3.)
      F(19)=FAC*(-G(1)**2*G(7)**2/15.-3*G(2)**2*G(8)**2-
     $       16*G(3)**2*G(9)**2/3.)
      F(20)=FAC*(-2.4*G(1)**2*G(7)**2+2*G(4)**2*XTAU)
      F(21)=FAC*(-.6*G(1)**2*G(7)**2-3*G(2)**2*G(8)**2+G(4)**2*XTAU)
      F(22)=FAC*(-4*G(1)**2*G(7)**2/15.-16*G(3)**2*G(9)**2/3.+
     $       2*G(5)**2*XB)
      F(23)=FAC*(-16*G(1)**2*G(7)**2/15.-16*G(3)**2*G(9)**2/3.+
     $       2*G(6)**2*XT)
      F(24)=FAC*(-G(1)**2*G(7)**2/15.-3*G(2)**2*G(8)**2-
     $       16*G(3)**2*G(9)**2/3.+G(6)**2*XT+G(5)**2*XB)
      F(25)=FAC*G(25)/2.*(-.6*G(1)**2-3*G(2)**2+3*G(6)**2+
     $       3*G(5)**2+G(4)**2)
      F(26)=FAC*(.6*G(1)**2*G(7)+3*G(2)**2*G(8)+3*G(6)**2*G(12)+
     $       3*G(5)**2*G(11)+G(4)**2*G(10))
      RETURN
      END
CDECK  ID>, TQL2.   
      SUBROUTINE TQL2(NM,N,D,E,Z,IERR)
C     FROM CERN PROGRAM LIBRARY
      IMPLICIT NONE
      INTEGER I,J,K,L,M,N,II,NM,MML,IERR
      REAL D(N),E(N),Z(NM,N)
      REAL B,C,F,G,H,P,R,S,MACHEP
      MACHEP=2.**(-23)
      IERR = 0
      IF (N .EQ. 1) GO TO 1001
      DO 100 I = 2, N
  100 E(I-1) = E(I)
      F = 0.0
      B = 0.0
      E(N) = 0.0
      DO 240 L = 1, N
         J = 0
         H = MACHEP * (ABS(D(L)) + ABS(E(L)))
         IF (B .LT. H) B = H
         DO 110 M = L, N
            IF (ABS(E(M)) .LE. B) GO TO 120
  110    CONTINUE
  120    IF (M .EQ. L) GO TO 220
  130    IF (J .EQ. 30) GO TO 1000
         J = J + 1
         P = (D(L+1) - D(L)) / (2.0 * E(L))
         R = SQRT(P*P+1.0)
         H = D(L) - E(L) / (P + SIGN(R,P))
         DO 140 I = L, N
  140    D(I) = D(I) - H
         F = F + H
         P = D(M)
         C = 1.0
         S = 0.0
         MML = M - L
         DO 200 II = 1, MML
            I = M - II
            G = C * E(I)
            H = C * P
            IF (ABS(P) .LT. ABS(E(I))) GO TO 150
            C = E(I) / P
            R = SQRT(C*C+1.0)
            E(I+1) = S * P * R
            S = C / R
            C = 1.0 / R
            GO TO 160
  150       C = P / E(I)
            R = SQRT(C*C+1.0)
            E(I+1) = S * E(I) * R
            S = 1.0 / R
            C = C * S
  160       P = C * D(I) - S * G
            D(I+1) = H + S * (C * G + S * D(I))
            DO 180 K = 1, N
               H = Z(K,I+1)
               Z(K,I+1) = S * Z(K,I) + C * H
               Z(K,I) = C * Z(K,I) - S * H
  180       CONTINUE
  200    CONTINUE
         E(L) = S * P
         D(L) = C * P
         IF (ABS(E(L)) .GT. B) GO TO 130
  220    D(L) = D(L) + F
  240 CONTINUE
      DO 300 II = 2, N
         I = II - 1
         K = I
         P = D(I)
         DO 260 J = II, N
            IF (D(J) .GE. P) GO TO 260
            K = J
            P = D(J)
  260    CONTINUE
         IF (K .EQ. I) GO TO 300
         D(K) = D(I)
         D(I) = P
         DO 280 J = 1, N
            P = Z(J,I)
            Z(J,I) = Z(J,K)
            Z(J,K) = P
  280    CONTINUE
  300 CONTINUE
      GO TO 1001
 1000 IERR = L
 1001 RETURN
      END
CDECK  ID>, TRED2.  
      SUBROUTINE TRED2(NM,N,A,D,E,Z)
C     FROM CERN PROGRAM LIBRARY
      IMPLICIT NONE
      INTEGER I,J,K,L,N,II,NM,JP1
      REAL A(NM,N),D(N),E(N),Z(NM,N)
      REAL F,G,H,HH,SCALE
      DO 100 I = 1, N
         DO 100 J = 1, I
            Z(I,J) = A(I,J)
  100 CONTINUE
      IF (N .EQ. 1) GO TO 320
      DO 300 II = 2, N
         I = N + 2 - II
         L = I - 1
         H = 0.0
         SCALE = 0.0
         IF (L .LT. 2) GO TO 130
         DO 120 K = 1, L
  120    SCALE = SCALE + ABS(Z(I,K))
         IF (SCALE .NE. 0.0) GO TO 140
  130    E(I) = Z(I,L)
         GO TO 290
  140    DO 150 K = 1, L
            Z(I,K) = Z(I,K) / SCALE
            H = H + Z(I,K) * Z(I,K)
  150    CONTINUE
         F = Z(I,L)
         G = -SIGN(SQRT(H),F)
         E(I) = SCALE * G
         H = H - F * G
         Z(I,L) = F - G
         F = 0.0
         DO 240 J = 1, L
            Z(J,I) = Z(I,J) / (SCALE * H)
            G = 0.0
            DO 180 K = 1, J
  180       G = G + Z(J,K) * Z(I,K)
            JP1 = J + 1
            IF (L .LT. JP1) GO TO 220
            DO 200 K = JP1, L
  200       G = G + Z(K,J) * Z(I,K)
  220       E(J) = G / H
            F = F + E(J) * Z(I,J)
  240    CONTINUE
         HH = F / (H + H)
         DO 260 J = 1, L
            F = Z(I,J)
            G = E(J) - HH * F
            E(J) = G
            DO 260 K = 1, J
               Z(J,K) = Z(J,K) - F * E(K) - G * Z(I,K)
  260    CONTINUE
         DO 280 K = 1, L
  280    Z(I,K) = SCALE * Z(I,K)
  290    D(I) = H
  300 CONTINUE
  320 D(1) = 0.0
      E(1) = 0.0
      DO 500 I = 1, N
         L = I - 1
         IF (D(I) .EQ. 0.0) GO TO 380
         DO 360 J = 1, L
            G = 0.0
            DO 340 K = 1, L
  340       G = G + Z(I,K) * Z(K,J)
            DO 360 K = 1, L
               Z(K,J) = Z(K,J) - G * Z(K,I)
  360    CONTINUE
  380    D(I) = Z(I,I)
         Z(I,I) = 1.0
         IF (L .LT. 1) GO TO 500
         DO 400 J = 1, L
            Z(I,J) = 0.0
            Z(J,I) = 0.0
  400    CONTINUE
  500 CONTINUE
      RETURN
      END
CDECK  ID>, BUFIN.  
      SUBROUTINE BUFIN(IL,IFLAG)
C
C          INVERSE OF BUFOUT.
C          IF CDCPACK IS USED, READ INPUT RECORD INTO ZVOUT AND
C          UNPACK EACH ZVOUT WORD INTO TWO ZEVEL WORDS BY CALL EXPAIR.
C          OTHERWISE, READ ONE INPUT RECORD INTO ZEVEL.
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/ITA/ITA,ITB
      SAVE /ITA/
      INTEGER   ITA,ITB
      INTEGER   MAXLEN
      PARAMETER (MAXLEN=1024)
      COMMON/ZEVEL/IZEVEL(MAXLEN)
      SAVE /ZEVEL/
      EQUIVALENCE(ZEVEL(1),IZEVEL(1))
      EQUIVALENCE(LZEVEL(1),IZEVEL(1))
      EQUIVALENCE (IZVL1,IZEVEL(1))
      EQUIVALENCE (IZVL2,IZEVEL(2))
      INTEGER   IZEVEL,IZVL1,IZVL2
      REAL      ZEVEL(MAXLEN)
      LOGICAL   LZEVEL(MAXLEN)
      COMMON/ZVOUT/ZVOUT(512)
      SAVE /ZVOUT/
      REAL      ZVOUT
      DIMENSION W(2),IW(2)
      EQUIVALENCE(W(1),IW(1))
      DATA NPARR/0/
    1 CONTINUE
C          STANDARD FORTRAN 77 READ.
      CALL ZEROL(ZEVEL,MAXLEN)
      READ(ITB,ERR=100,END=200) IZVL1,IZVL2,(ZEVEL(JJ),JJ=3,IZVL2)
      GO TO 300
C            TAPE READ ERROR
  100 WRITE(ITLIS,10) ITB
      NPARR=NPARR+1
   10 FORMAT(1X,' TAPE READ ERROR ON TAPE',I3)
      IFLAG=1
      IF(NPARR.LT.20) GOTO 1
C            END OF FILE
  200 IFLAG=-1
      RETURN
C            GOOD RECORD
  300 IFLAG=0
      IL=3
      RETURN
      END
CDECK  ID>, BUFOUT. 
      SUBROUTINE BUFOUT(IL)
C
C          INVERSE OF BUFIN.
C          IF CDCPACK IS USED, PACK TWO ZEVEL WORDS INTO EACH ZVOUT WORD
C          BY CALL PAIRPAK AND BUFFER OUT ZVOUT ARRAY.
C          OTHERWISE WRITE OUT ZEVEL.
C
C          NRECS INCREMENTED BY 1
C          IL SET TO 3


      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/FINAL/NKINF,SIGF,ALUM,ACCEPT,NRECS
      SAVE /FINAL/
      INTEGER   NKINF,NRECS
      REAL      SIGF,ALUM,ACCEPT
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      INTEGER   MAXLEN
      PARAMETER (MAXLEN=1024)
      COMMON/ZEVEL/IZEVEL(MAXLEN)
      SAVE /ZEVEL/
      EQUIVALENCE(ZEVEL(1),IZEVEL(1))
      EQUIVALENCE(LZEVEL(1),IZEVEL(1))
      EQUIVALENCE (IZVL1,IZEVEL(1))
      EQUIVALENCE (IZVL2,IZEVEL(2))
      INTEGER   IZEVEL,IZVL1,IZVL2
      REAL      ZEVEL(MAXLEN)
      LOGICAL   LZEVEL(MAXLEN)
      COMMON/ZVOUT/ZVOUT(512)
      SAVE /ZVOUT/
      REAL      ZVOUT
      DIMENSION W(2),IW(2)
      EQUIVALENCE(W(1),IW(1))
C          THESE ARE NOW INITIALIZED IN BLOCK DATA
      ITA=IABS(ITEVT)
C          STANDARD FORTRAN 77 WRITE.
      IZEVEL(2)=IL
      WRITE(ITA,ERR=11) (ZEVEL(I),I=1,IL)
      IL=3
      NRECS=NRECS+1
   10 RETURN
   11 WRITE(ITLIS,200) IEVT,IDG
  200 FORMAT(//'  BAD WRITE, EVENT NO.',I10,5X,'EVENT ID',2I10)
      RETURN
      END
CDECK  ID>, EDIT.   
      LOGICAL FUNCTION EDIT(I)
C          DUMMY ROUTINE FOR USER DEFINED LOGICAL FUNCTION
C          EDIT=.TRUE. TO WRITE EVENT ON TAPE
C          EDIT=.FALSE. TO SUPPRESS WRITING
      EDIT=.TRUE.
      RETURN
      END
CDECK  ID>, ISAHEP. 
      SUBROUTINE ISAHEP(MCONV)
C
C...Purpose: to convert ISAJET event record contents to or from
C...the standard event record common block.
C
C   Thanks to Lynn Garren, Fermilab.
C
      IMPLICIT NONE
      INTEGER NMXHEP
      PARAMETER (NMXHEP=4000)
      COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     $JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
      INTEGER NEVHEP,NHEP,ISTHEP,IDHEP,JMOHEP,JDAHEP
      REAL PHEP,VHEP
      SAVE /HEPEVT/
C...      NEVHEP       - event number
C...      NHEP         - number of entries in this event
C...      ISTHEP(..)   - status code
C...      IDHEP(..)    - particle ID, P.D.G. standard
C...      JMOHEP(1,..) - position of mother particle in list
C...      JMOHEP(2,..) - position of second mother particle in list
C...      JDAHEP(1,..) - position of first daughter in list
C...      JDAHEP(2,..) - position of last daughter in list
C...      PHEP(1,..)   - x momentum in GeV/c
C...      PHEP(2,..)   - y momentum in GeV/c
C...      PHEP(3,..)   - z momentum in GeV/c
C...      PHEP(4,..)   - energy in GeV
C...      PHEP(5,..)   - mass in GeV/c**2
C...      VHEP(1,..)   - x vertex position in mm
C...      VHEP(2,..)   - y vertex position in mm
C...      VHEP(3,..)   - z vertex position in mm
C...      VHEP(4,..)   - production time in mm/c
C
C...for event number
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
C...initial partons
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
C...partons created during decay
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
C...particles created in the decay, including final state particles
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
C
      INTEGER MCONV
      INTEGER ITRANS
      INTEGER I1,IHP,MPART,JET,NPOFF,NJHEP,NWHEP,IMO,IJT
      INTEGER JPMO(2,MXJSET),JPDA(2,MXJSET),JMX(MXJSET),JMN(MXJSET)
      INTEGER JTMO(2,MXPTCL),JTDA(2,MXPTCL)
      INTEGER IP,IJ3,IJ2,IJ1,NSUM2,NSUM1,IPT,I,J,KST,KND,K
C
C
C...Conversion from ISAJET to standard
C
      IF(MCONV.EQ.1) THEN
        NEVHEP = IEVT
C...initial jets
        NHEP = 0
C... W or Z
        IF(IDENTW.NE.0)THEN
          NHEP = NHEP + 1
          ISTHEP(NHEP)=12
          JMOHEP(1,NHEP)=0
          JMOHEP(2,NHEP)=0
          JDAHEP(1,NHEP)= 2
          JDAHEP(2,NHEP)= NJET + 1
          IDHEP(NHEP) = ITRANS(IDENTW,1)
          DO 100 J=1,5
 100        PHEP(J,NHEP) = QWJET(J)
        ENDIF
        NWHEP = NHEP
C... jets
        IF(NJET.GT.0)THEN
          DO 120 I=1,NJET
            NHEP = NHEP + 1
            ISTHEP(NHEP)=11
            JMOHEP(1,NHEP)=0
            IF(IDENTW.NE.0) JMOHEP(1,NHEP) = 1
            JMOHEP(2,NHEP)= I
            JDAHEP(1,NHEP)=0
            JDAHEP(2,NHEP)=0
            IDHEP(NHEP) = ITRANS(IDJETS(I),1)
            DO 110 J=1,5
 110          PHEP(J,NHEP) = PJETS(J,I)
 120      CONTINUE
        ENDIF
        NJHEP = NHEP
C... pairs
        IF(NPAIR.GT.0)THEN
          DO 150 I=1,NPAIR
            NHEP = NHEP + 1
            ISTHEP(NHEP)=13
            JMOHEP(1,NHEP)= JPAIR(I) + NWHEP
            JMOHEP(2,NHEP)= JPAIR(I)
            JDAHEP(1,NHEP)=0
            JDAHEP(2,NHEP)=0
            IDHEP(NHEP) = ITRANS(IDPAIR(I),1)
            DO 140 J=1,5
 140          PHEP(J,NHEP) = PPAIR(J,I)
 150      CONTINUE
        ENDIF
        DO 160 I=1,NHEP
          DO 160 J=1,4
 160        VHEP(J,I) = 0.
C...save offset into hep list
        NPOFF = NHEP
C...partons
        DO 200 I=1,NJSET
          IHP = NHEP + I
C...use JMX and JMN to find daughters in hadron list
          JMX(I) = 0
          JMN(I) = NHEP + NPTCL + 1
          IDHEP(IHP) = ITRANS(JTYPE(I),1)
          MPART=MOD(JORIG(I),JPACK)
          JMOHEP(1,IHP)=0
          IJT = JORIG(I)/JPACK
          IF(MPART.NE.0)THEN
            JMOHEP(1,IHP)=MPART+NHEP
          ELSEIF(MPART.EQ.0 .AND. IJT.LT.10)THEN
C...find mother in jet/pair list
            IMO = IJT + NWHEP
            IF(NJHEP.LT.NPOFF)THEN
              KST = NJHEP + 1
              DO 170 K=KST,NPOFF
                IF(IDHEP(K).EQ.IDHEP(IHP)) IMO=K
 170          CONTINUE
            ENDIF
            JMOHEP(1,IHP)= IMO
            IF(JDAHEP(1,IMO).EQ.0) JDAHEP(1,IMO)=IHP
            JDAHEP(1,IMO) = MIN(IHP,JDAHEP(1,IMO))
            JDAHEP(2,IMO) = MAX(IHP,JDAHEP(2,IMO))
C...amend information if a parton thinks this is it's daughter
            KND = IHP-1
            DO 175 K=NPOFF,KND
              IF(IHP.GE.JDAHEP(1,K) .AND. IHP.LE.JDAHEP(2,K))
     1             JMOHEP(1,IHP)=K
 175        CONTINUE
          ENDIF
          JMOHEP(2,IHP)= IJT
          IF(JDCAY(I).EQ.0)THEN
            ISTHEP(IHP) = 21
            JDAHEP(1,IHP)=0
            JDAHEP(2,IHP)=0
          ELSE
            ISTHEP(IHP) = 22
            JDAHEP(1,IHP) = JDCAY(I)/JPACK + NHEP
            JDAHEP(2,IHP) = MOD(JDCAY(I),JPACK) + NHEP
          ENDIF
          DO 180 J=1,5
 180        PHEP(J,IHP) = PJSET(J,I)
          DO 190 J=1,4
 190        VHEP(J,IHP) = 0.
 200    CONTINUE
        NHEP = NHEP + NJSET
C...hadrons
        DO 250 I=1,NPTCL
          IHP = NHEP + I
          IDHEP(IHP) = ITRANS(IDENT(I),1)
          I1 = MOD(IABS(IORIG(I)),IPACK)
          JMOHEP(1,IHP)=0
          JMOHEP(2,IHP)=IABS(IORIG(I))/IPACK
C...mother is pomeron
          IF(I1.EQ.0)THEN
C...mother is in parton list
          ELSEIF(IORIG(I).LT.0)THEN
            JMOHEP(1,IHP) = I1 + NPOFF
            JMN(I1) = MIN(JMN(I1),I)
            JMX(I1) = MAX(JMX(I1),I)
C...mother is in hadron list
          ELSEIF(IORIG(I).GT.0)THEN
            JMOHEP(1,IHP) = I1 + NHEP
          ENDIF
          IF(IDCAY(I).EQ.0)THEN
            ISTHEP(IHP) = 1
            JDAHEP(1,IHP)=0
            JDAHEP(2,IHP)=0
          ELSE
            ISTHEP(IHP) = 2
            JDAHEP(1,IHP) = IDCAY(I)/IPACK + NHEP
            JDAHEP(2,IHP) = MOD(IDCAY(I),IPACK) + NHEP
          ENDIF
          DO 210 J=1,5
 210        PHEP(J,IHP) = PPTCL(J,I)
          DO 220 J=1,4
 220        VHEP(J,IHP) = 0.
 250    CONTINUE
        NHEP = NHEP + NPTCL
C...fill in missing daughter info for partons
        DO 270 I=1,NJSET
          IF(JMX(I).NE.0)THEN
            JDAHEP(1,I+NPOFF) = JMN(I) + NPOFF + NJSET
            JDAHEP(2,I+NPOFF) = JMX(I) + NPOFF + NJSET
          ENDIF
 270    CONTINUE
C
C...Conversion from standard to ISAJET
C
      ELSEIF(MCONV.EQ.2)THEN
        IEVT = NEVHEP
C...        missing information
        IDENTW = 0
        NPAIR = 0
        DO 330 I=1,5
          QWJET(I) = 0.
          DO 330 J=1,4
            PPAIR(I,J) = 0.
 330    CONTINUE
        DO 340 I=1,4
          IDPAIR(I) = 0
 340      JPAIR(I) = 0
C...zero counters
        IJ1 = 0
        IJ2 = 0
        IJ3 = 0
        IP = 0
        IPT = 0
        DO 500 I=1,NHEP
C...initial jets
C... jets
          IF(ISTHEP(I).EQ.11)THEN
            IJ1 = IJ1 + 1
            IDJETS(IJ1) = ITRANS(IDHEP(I),2)
            DO 410 J=1,5
 410          PJETS(J,IJ1) = PHEP(J,I)
C... W
          ELSEIF(ISTHEP(I).EQ.12)THEN
            IJ2 = IJ2 + 1
            IDENTW = ITRANS(IDHEP(I),2)
            DO 420 J=1,5
 420          QWJET(J) = PHEP(J,I)
C... pairs
          ELSEIF(ISTHEP(I).EQ.13)THEN
            IJ3 = IJ3 + 1
            IDPAIR(IJ3) = ITRANS(IDHEP(I),2)
            JPAIR(IJ3) = JMOHEP(2,I)
            DO 430 J=1,5
 430          PPAIR(J,IJ3) = PHEP(J,I)
C...partons
          ELSEIF(ISTHEP(I).EQ.21 .OR. ISTHEP(I).EQ.22)THEN
            IP = IP + 1
            JTYPE(IP) = ITRANS(IDHEP(I),2)
            DO 440 J=1,5
 440          PJSET(J,IP) = PHEP(J,I)
C...      temporary storage until have counts
            JPMO(1,IP) = JMOHEP(1,I)
            JPMO(2,IP) = JMOHEP(2,I)
            JPDA(1,IP) = JDAHEP(1,I)
            JPDA(2,IP) = JDAHEP(2,I)
C...hadrons
          ELSE
            IPT = IPT + 1
            IDENT(IPT) = ITRANS(IDHEP(I),2)
            DO 450 J=1,5
 450          PPTCL(J,IPT) = PHEP(J,I)
C...      temporary storage until have counts
            JTMO(1,IPT) = JMOHEP(1,I)
            JTMO(2,IPT) = JMOHEP(2,I)
            JTDA(1,IPT) = JDAHEP(1,I)
            JTDA(2,IPT) = JDAHEP(2,I)
          ENDIF
 500    CONTINUE
C...completed counts
        NJET = IJ1
        NPAIR = IJ3
        NJSET = IP
        NPTCL = IPT
C...get mother/daughter information
        NSUM1 = NJET + IJ2 + NPAIR
        NSUM2 = NSUM1 + NJSET
        DO 520 I=1,NJSET
          IF(JPDA(1,I).EQ.0)THEN
            JDCAY(I) = 0
          ELSEIF(JPDA(1,I).GT.NSUM2)THEN
            JDCAY(I) = 0
          ELSE
            JDCAY(I) = JPACK*(JPDA(1,I)-NSUM1) + JPDA(2,I)-NSUM1
          ENDIF
          IF(JPMO(1,I).LE.NSUM1)THEN
            JORIG(I) = JPACK*JPMO(2,I)
          ELSE
            JORIG(I) = JPACK*JPMO(2,I) + JPMO(1,I)-NSUM1
          ENDIF
 520    CONTINUE
        DO 550 I=1,NPTCL
          IF(JTDA(1,I).EQ.0)THEN
            IDCAY(I) = 0
          ELSE
            IDCAY(I) = IPACK*(JTDA(1,I)-NSUM2) + JTDA(2,I)-NSUM2
          ENDIF
          IF(JTMO(1,I).LE.NSUM1)THEN
            IORIG(I) = JTMO(2,I)*IPACK + 0
          ELSEIF(JTMO(1,I).LE.NSUM2)THEN
            IORIG(I) = -(JTMO(2,I)*IPACK + JTMO(1,I)-NSUM1)
          ELSE
            IORIG(I) = JTMO(2,I)*IPACK + JTMO(1,I)-NSUM2
          ENDIF
 550    CONTINUE
      ENDIF
      RETURN
      END
CDECK  ID>, ISAWBG. 
      SUBROUTINE ISAWBG
C
C          Write initial record (type 200)
C          Inverse of RDBEG
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/FRGPAR/PUD,PBARY,SIGQT,PEND,XGEN(8),PSPIN1(8),
     $PMIX1(3,2),PMIX2(3,2),XGENSS(9)
      SAVE /FRGPAR/
      EQUIVALENCE (PMIX1(1,1),PMIXX1(1))
      EQUIVALENCE (PMIX2(1,1),PMIXX2(1))
      EQUIVALENCE(FRPAR(1),PUD)
      REAL      PUD,PBARY,SIGQT,PEND,XGEN,PSPIN1,PMIX1,PMIX2,XGENSS,
     +          PMIXX1(6),PMIXX2(6),FRPAR(32)
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/QLMASS/AMLEP(100),NQLEP,NMES,NBARY
      SAVE /QLMASS/
      INTEGER   NQLEP,NMES,NBARY
      REAL      AMLEP
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/TYPES/LOC(100),NTYP,NJTTYP(3),NWWTYP(2),NWMODE(3)
      COMMON/XTYPES/PARTYP(40),TITLE(10),JETYP(30,3),WWTYP(30,2)
     $,WMODES(30,3)
      SAVE /TYPES/,/XTYPES/
      CHARACTER*8 JETYP,WWTYP,TITLE,PARTYP,WMODES
      INTEGER   LOC,NTYP,NJTTYP,NWWTYP,NWMODE
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C
      COMMON/ZVOUT/ZVOUT(512)
      SAVE /ZVOUT/
      REAL      ZVOUT
      INTEGER   MAXLEN
      PARAMETER (MAXLEN=1024)
      COMMON/ZEVEL/IZEVEL(MAXLEN)
      SAVE /ZEVEL/
      EQUIVALENCE(ZEVEL(1),IZEVEL(1))
      EQUIVALENCE(LZEVEL(1),IZEVEL(1))
      EQUIVALENCE (IZVL1,IZEVEL(1))
      EQUIVALENCE (IZVL2,IZEVEL(2))
      INTEGER   IZEVEL,IZVL1,IZVL2
      REAL      ZEVEL(MAXLEN)
      LOGICAL   LZEVEL(MAXLEN)
      COMMON/FINAL/NKINF,SIGF,ALUM,ACCEPT,NRECS
      SAVE /FINAL/
      INTEGER   NKINF,NRECS
      REAL      SIGF,ALUM,ACCEPT
C
      INTEGER NL,IL,ITA
C
C       Keep entry point WRBEG for backward compatibility
      ENTRY WRBEG
C
      ITA=IABS(ITEVT)
      NKINF=0
      SIGF=0.
      ALUM=0.
      ACCEPT=0.
      NRECS=0
      CALL ZEROL(ZEVEL,MAXLEN)
      IL=3
      CALL MOVLEI(IDVER,IZEVEL(IL),4)
      IL=IL+4
      CALL MOVLEI(NJET,IZEVEL(IL),7)
      IL=IL+7
      NL=NJET*MXGOQ
      IF(NJET.NE.0) CALL MOVLEL(GOQ(1,1),LZEVEL(IL),NL)
      IL=IL+NL
      CALL MOVLEL(KEYS(1),LZEVEL(IL),10)
      IL=IL+10
      CALL MOVLEV(PMIN(1),ZEVEL(IL),36)
      IL=IL+36
      IF(.NOT.KEYS(3)) GOTO 11
      CALL MOVLEV(QMIN,ZEVEL(IL),12)
      IL=IL+12
   11 CONTINUE
      CALL MOVLEL(GODY(1),LZEVEL(IL),5)
      IL=IL+5
      CALL MOVLEV(PUD,ZEVEL(IL),22)
      IL=IL+22
      CALL MOVLEV(ALAM,ZEVEL(IL),4)
      IL=IL+4
      CALL MOVLEV(AMLEP(6),ZEVEL(IL),3)
      IL=IL+3
      CALL MOVLEI(LOC(1),IZEVEL(IL),100)
      IL=IL+100
      CALL MOVLEL(GOMSSM,LZEVEL(IL),1)
      IL=IL+1
      CALL MOVLEV(XGLSS,ZEVEL(IL),11)
      IL=IL+11
      CALL MOVLEL(GOSUG,LZEVEL(IL),1)
      IL=IL+1
      CALL MOVLEV(XM0SU,ZEVEL(IL),5)
      IL=IL+5
C
      IZEVEL(1)=200
      IZEVEL(2)=1
      CALL BUFOUT(IL)
      RETURN
      END
CDECK  ID>, ISAWEV. 
      SUBROUTINE ISAWEV
C
C          WRITE OUT MONTECARLO DATA IF EDIT IS TRUE
C
      LOGICAL EDIT
C
C        keep entry point WRTAPE for backward compatibility
      ENTRY WRTAPE
      IF(.NOT.EDIT(I)) RETURN
      CALL WGENS
      RETURN
      END
CDECK  ID>, ISAWND. 
      SUBROUTINE ISAWND
C
C          WRITE END RECORD, TYPE 300
C          CONTAINS CROSS SECTIONS AND LUMINOSITY
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/FINAL/NKINF,SIGF,ALUM,ACCEPT,NRECS
      SAVE /FINAL/
      INTEGER   NKINF,NRECS
      REAL      SIGF,ALUM,ACCEPT
      COMMON/TOTALS/NKINPT,NWGEN,NKEEP,SUMWT,WT
      SAVE /TOTALS/
      INTEGER   NKINPT,NWGEN,NKEEP
      REAL      SUMWT,WT
      INTEGER   MAXLEN
      PARAMETER (MAXLEN=1024)
      COMMON/ZEVEL/IZEVEL(MAXLEN)
      SAVE /ZEVEL/
      EQUIVALENCE(ZEVEL(1),IZEVEL(1))
      EQUIVALENCE(LZEVEL(1),IZEVEL(1))
      EQUIVALENCE (IZVL1,IZEVEL(1))
      EQUIVALENCE (IZVL2,IZEVEL(2))
      INTEGER   IZEVEL,IZVL1,IZVL2
      REAL      ZEVEL(MAXLEN)
      LOGICAL   LZEVEL(MAXLEN)
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
C
C       keep entry point WREND for backward compatibility
      ENTRY WREND
      ITA=IABS(ITEVT)
      IZEVEL(1)=300
      IZEVEL(2)=1
      IZEVEL(3)=NKINF
      ZEVEL(4)=SIGF
      ZEVEL(5)=ALUM
      ZEVEL(6)=ACCEPT
      IZEVEL(7)=NRECS
      IL=7
      CALL BUFOUT(IL)
      WRITE(ITLIS,1010) NRECS,ITA
1010  FORMAT(////' THIS RUN WROTE',I10,
     1' PHYSICAL RECORDS ON TAPE',I3)
      RETURN
      END
CDECK  ID>, ITRANS. 
      INTEGER FUNCTION ITRANS(ID,MCONV)
C
C...convert (MCONV=1) from ISAJET numbering to PDG numbering
C...     or (MCONV=2) from PDG  numbering to ISAJET numbering
C...
C...Ver 7.21: add extra mesons with IABS(ID) > 10000; these only occur
C...          in a few B decays.
C
C...Thanks to Lynn Garren, Fermilab.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
C
      INTEGER ID,MCONV
      INTEGER I2,I3,J,IDA,IF1,IF2,IND,ITMP,IF3,JS,J1,IS1,IS2,IS3,I4,I1
C
C... ITABI(I) converts miscellaneous ISAJET particle ID's to standard
C... scheme
      INTEGER ITABI(99,2), NOANT(15)
      SAVE ITABI,NOANT
      DATA ITABI/2,1,3,4,5,6,7,8,21,22,
     1           12,11,14,13,16,15,0,0,0,310,
     2           42,41,43,44,45,46,0,0,47,67,
     3           52,51,54,53,56,55,0,0,77,68,
     4           62,61,63,64,65,66,0,0,78,69,
     5           72,71,74,73,76,75,0,0,0,70,
     6           0,0,0,0,0,0,0,0,0,0,
     7           0,0,0,0,0,0,0,0,0,24,
     8           25,57,58,59,40,33,37,34,38,23,
     9           0,0,0,0,0,0,0,0,0,
     *           2,1,3,4,5,6,7,8,0,0,
     1           12,11,14,13,16,15,0,0,0,0,
     2           9,10,90,80,81,0,0,0,0,0,
     3           0,82,86,88,0,83,87,89,84,85,
     4           22,21,23,24,25,26,29,0,0,0,
     5           32,31,34,33,36,35,82,83,84,0,
     6           42,41,43,44,45,46,30,40,50,60,
     7           52,51,54,53,56,55,39,49,0,0,
     8           0,0,0,0,0,0,0,0,0,0,
     9           0,0,0,0,0,0,0,0,0/
      DATA NOANT/-21,-22,-23,-25,-30,-35,-47,-48,-57,-58,-59,
     1           -67,-68,-69,-70/
C
      IDA=IABS(ID)
      ITRANS=0
      IF(MCONV.NE.1) GO TO 200
C...ISAJET algorithm routine
      CALL FLAVOR(ID,IF1,IF2,IF3,JS,IND)
      IF(IDA.EQ.0) THEN
        WRITE(ITLIS,*) ' ITRANS: particle ID is zero'
      ELSEIF(IDA.LT.100) THEN
        ITRANS=ISIGN(ITABI(IDA,1),ID)
        IF(ID.EQ.-20) ITRANS=130
C...check for illegal antiparticles
        ITMP=ITRANS
        IF(ITMP.LT.0) THEN
          DO 101 J=1,15
            IF(ITMP.EQ.NOANT(J)) ITRANS=0
 101      CONTINUE
        ENDIF
      ELSEIF(IND.NE.0.AND.IDA.LT.10000) THEN
        IS1=IABS(IF1)
        IS2=IABS(IF2)
        IS3=IABS(IF3)
C...mesons
        IF(IS1.EQ.0) THEN
          IF(IS2.LE.2 .AND. IS3.LE.2) THEN
C...         don't change
          ELSE
C...         u and d have opposite definitions
            IF(IS2.LE.2) IS2=ITABI(IS2,1)
            IF(IS3.LE.2) IS3=ITABI(IS3,1)
          ENDIF
          ITRANS=IS3*100 + IS2*10 + 2*JS+1
          ITRANS=ISIGN(ITRANS,ID)
C...         charmed and top mesons have wrong sign
          IF(IS3.EQ.4 .AND. IS2.NE.4) ITRANS=-ITRANS
          IF(IS3.EQ.6 .AND. IS2.NE.6 .AND. IS2.NE.4) ITRANS=-ITRANS
C...check for illegal antiparticles
          IF(IS2.EQ.IS3 .AND. ID.LT.0) ITRANS=0
C...diquarks
        ELSEIF(IS3.EQ.0) THEN
C...         u and d have opposite definitions
          IF(IS1.LE.2) IS1=ITABI(IS1,1)
          IF(IS2.LE.2) IS2=ITABI(IS2,1)
          IF(IS2.LT.IS1) THEN
            ITRANS=IS1*1000 + IS2*100 + 2*JS+1
          ELSE
            ITRANS=IS2*1000 + IS1*100 + 2*JS+1
          ENDIF
          ITRANS=ISIGN(ITRANS,ID)
C...         charmed and top mesons have wrong sign
          IF(IS2.EQ.4 .AND. IS1.NE.4) ITRANS=-ITRANS
          IF(IS2.EQ.6 .AND. IS1.NE.6 .AND. IS1.NE.4) ITRANS=-ITRANS
C...baryons
        ELSE
C...         u and d have opposite definitions
          IF(IS1.LE.2) IS1=ITABI(IS1,1)
          IF(IS2.LE.2) IS2=ITABI(IS2,1)
          IF(IS3.LE.2) IS3=ITABI(IS3,1)
          IF(IS3.LE.2) THEN
            ITRANS=IS1*1000 + IS2*100 + IS3*10 + 2*JS+2
          ELSEIF(IS1.LE.2 .AND. IS2.LE.2) THEN
            ITRANS=IS3*1000 + IS1*100 + IS2*10 + 2*JS+2
          ELSE
            ITRANS=IS3*1000 + IS2*100 + IS1*10 + 2*JS+2
          ENDIF
          ITRANS=ISIGN(ITRANS,ID)
        ENDIF
      ELSEIF(IND.GT.0.AND.IDA.GT.10000) THEN
C...Special mesons.
        IF(ID.EQ.10121) THEN
          ITRANS=20213
        ELSEIF(ID.EQ.10111) THEN
          ITRANS=20113
        ELSEIF(ID.EQ.10131) THEN
          ITRANS=10323
        ELSEIF(ID.EQ.10231) THEN
          ITRANS=10313
        ELSEIF(ID.EQ.30131) THEN
          ITRANS=30323
        ELSEIF(ID.EQ.30231) THEN
          ITRANS=30313
        ELSEIF(ID.EQ.10110) THEN
          ITRANS=10221
        ELSEIF(ID.EQ.10441) THEN
          ITRANS=20443
        ELSEIF(ID.EQ.20440) THEN
          ITRANS=10441
        ELSEIF(ID.EQ.20441) THEN
          ITRANS=10443
        ELSEIF(ID.EQ.20442) THEN
          ITRANS=445
        ELSE
          ITRANS=ID
        ENDIF
      ENDIF
      GO TO 300
C
 200  IF(MCONV.NE.2) GO TO 300
      J1=MOD(IDA,10)
      I1=MOD(IDA/10,10)
      I2=MOD(IDA/100,10)
      I3=MOD(IDA/1000,10)
      I4=MOD(IDA/10000,10)
      IF(IDA.EQ.0) THEN
        WRITE(ITLIS,*) ' ITRANS: particle ID is zero'
C...elementary particles
      ELSEIF(IDA.LT.100) THEN
        ITRANS=ISIGN(ITABI(IDA,2),ID)
C...check for illegal antiparticles
        IF(ID.LT.0) THEN
          DO 201 J=1,15
            IF(ID.EQ.NOANT(J)) ITRANS=0
 201      CONTINUE
        ENDIF
C...K short and K long
      ELSEIF(ID.EQ.130) THEN
        ITRANS=-20
      ELSEIF(ID.EQ.310) THEN
        ITRANS=20
C...mesons
      ELSEIF(I3.EQ.0) THEN
          IF(I1.LE.2 .AND. I2.LE.2) THEN
C...         don't change
          ELSE
C...         u and d have opposite definitions
            IF(I1.LE.2) I1=ITABI(I1,2)
            IF(I2.LE.2) I2=ITABI(I2,2)
          ENDIF
          ITRANS=I1*100 + I2*10 + (J1-1)/2
          ITRANS=ISIGN(ITRANS,ID)
C...         charmed and top mesons have wrong sign
          IF(I2.EQ.4 .AND. I1.NE.4) ITRANS=-ITRANS
          IF(I2.EQ.6 .AND. I1.NE.6 .AND. I1.NE.4) ITRANS=-ITRANS
C...check for illegal antiparticles
          IF(I2.EQ.I1 .AND. ID.LT.0) ITRANS=0
C...diquarks
      ELSEIF(I1.EQ.0) THEN
C...         u and d have opposite definitions
          IF(I3.LE.2) I3=ITABI(I3,2)
          IF(I2.LE.2) I2=ITABI(I2,2)
          IF(I3.LT.I2) THEN
            ITRANS=I3*1000 + I2*100 + (J1-1)/2
          ELSE
            ITRANS=I2*1000 + I3*100 + (J1-1)/2
          ENDIF
          ITRANS=ISIGN(ITRANS,ID)
C...         charmed and top mesons have wrong sign
          IF(I2.EQ.4 .AND. I3.NE.4) ITRANS=-ITRANS
          IF(I2.EQ.6 .AND. I3.NE.6 .AND. I3.NE.4) ITRANS=-ITRANS
C...baryons
      ELSE
C...         u and d have opposite definitions
          IF(I3.LE.2) I3=ITABI(I3,2)
          IF(I2.LE.2) I2=ITABI(I2,2)
          IF(I1.LE.2) I1=ITABI(I1,2)
          IF(I3.LE.2) THEN
            ITRANS=I3*1000 + I2*100 + I1*10 + (J1-2)/2
          ELSEIF(I1.LE.2 .AND. I2.LE.2) THEN
            ITRANS=I2*1000 + I1*100 + I3*10 + (J1-2)/2
          ELSE
            ITRANS=I1*1000 + I2*100 + I3*10 + (J1-2)/2
          ENDIF
          ITRANS=ISIGN(ITRANS,ID)
      ENDIF

 300  RETURN
      END
CDECK  ID>, MOVLEV. 
      SUBROUTINE MOVLEV(A,B,N)
C
C          Replacement for CDC system routine.
C          Move N consecutive locations from A to B.
C          Ver. 7.02: Separate entry points for real, integer, logical
C                     to comply with strict Fortran standard.
C                     Hence incompatible with CDC -- CDC version is
C                     therefore obsolete, like the computer.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER N,I
      REAL A(N),B(N)
      INTEGER IA(N),IB(N)
      LOGICAL LA(N),LB(N)
C          Reals
      DO 100 I=1,N
        B(I)=A(I)
100   CONTINUE
      RETURN
C          Integers
      ENTRY MOVLEI(IA,IB,N)
      DO 200 I=1,N
        IB(I)=IA(I)
200   CONTINUE
      RETURN
C          Logicals
      ENTRY MOVLEL(LA,LB,N)
      DO 300 I=1,N
        LB(I)=LA(I)
300   CONTINUE
      RETURN
      END
CDECK  ID>, PRTLST. 
      SUBROUTINE PRTLST(JTLIS,AMY,AMX)
C
C          List defined particles. AMY, AMX are the masses of the
C          fourth generation quarks. If a negative mass is given,
C          then these are not listed.
C          This must be linked with ISAJET, including ALDATA.
C
      IMPLICIT NONE
      COMMON/QLMASS/AMLEP(100),NQLEP,NMES,NBARY
      SAVE /QLMASS/
      INTEGER   NQLEP,NMES,NBARY
      REAL      AMLEP
      COMMON/WCON/SIN2W,WMASS(4),WGAM(4),AQ(12,4),BQ(12,4),COUT(4),
     1MATCH(25,4),WCBR(25,4),CUTOFF,CUTPOW,TBRWW(4,2),RBRWW(12,4,2),EZ,
     2AQDP(12,4),BQDP(12,4),EZDP,WFUDGE
      SAVE /WCON/
      DOUBLE PRECISION AQDP,BQDP,EZDP
      INTEGER   MATCH
      REAL      SIN2W,WMASS,WGAM,AQ,BQ,COUT,WCBR,CUTOFF,CUTPOW,TBRWW,
     +          RBRWW,EZ,WFUDGE
      COMMON/WCON2/CUMWBR(25,3)
      REAL CUMWBR
      INTEGER JTLIS
      REAL AMY,AMX
      INTEGER IFL1,IFL2,IFL3,JSPIN,INDEX,I,ID
      REAL AM,CG,AMASS,CHARGE
      CHARACTER*8 LB,LABEL
C
C          Initialize SUSY masses to 0. Remember offset of 1 from KL.
C
      DO 100 I=22,NQLEP
        AMLEP(I)=0.
100   CONTINUE
      AMLEP(7)=AMY
      AMLEP(8)=AMX
      CALL FLAVOR(80,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=WMASS(2)
      CALL FLAVOR(90,IFL1,IFL2,IFL3,JSPIN,INDEX)
      AMLEP(INDEX)=WMASS(4)
      WRITE(JTLIS,101) AMY,AMX
C
C          Loop over IDENT's
C
      DO 200 I=1,40000
        ID = I
        CALL FLAVOR(ID,IFL1,IFL2,IFL3,JSPIN,INDEX)
        IF(AMX.LT.0..OR.AMY.LT.0.) THEN
          IF(IABS(IFL1).GT.6.OR.IABS(IFL2).GT.6.OR.IABS(IFL3).GT.6)
     $    GO TO 200
        ENDIF
        IF(INDEX.GT.0) THEN
          LB = LABEL(ID)
          IF(LB.NE.'ERR') THEN
            AM = AMASS(ID)
            CG = CHARGE(ID)
            WRITE(JTLIS,102) ID,LB,AM,CG,IFL1,IFL2,IFL3,JSPIN,INDEX
          ENDIF
        ENDIF
        ID = -I
        CALL FLAVOR(ID,IFL1,IFL2,IFL3,JSPIN,INDEX)
C          Eliminate bad ID's:
        IF(INDEX.GT.0) THEN
          LB = LABEL(ID)
          IF(LB.NE.'ERR') THEN
            AM = AMASS(ID)
            CG = CHARGE(ID)
            WRITE(JTLIS,102) ID,LB,AM,CG,IFL1,IFL2,IFL3,JSPIN,INDEX
          ENDIF
        ENDIF
 200  CONTINUE
      RETURN
 101  FORMAT(10X,'ISAJET PARTICLES, M(Y) =',F10.3,'  M(X) =',F10.3//
     1 5X,'ID',4X,'PARTICLE',8X,'MASS',4X,'CHARGE',
     2 4X,'---FLAVOR---',4X,'SPIN',4X,'INDEX')
 102  FORMAT(1X,I6,4X,A8,F12.6,F10.2,4X,3I4,I8,I9)
      END
CDECK  ID>, RDBEG.  
      SUBROUTINE RDBEG
C
C          Read first record (type 200)
C          Inverse of WRBEG
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/DYLIM/QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     2  THWMAX,PHWMIN,PHWMAX
     3  ,SETLMQ(12)
      SAVE /DYLIM/
      LOGICAL SETLMQ
      EQUIVALENCE(BLIM1(1),QMIN)
      REAL      QMIN,QMAX,QTMIN,QTMAX,YWMIN,YWMAX,XWMIN,XWMAX,THWMIN,
     +          THWMAX,PHWMIN,PHWMAX,BLIM1(12)
      COMMON/FRGPAR/PUD,PBARY,SIGQT,PEND,XGEN(8),PSPIN1(8),
     $PMIX1(3,2),PMIX2(3,2),XGENSS(9)
      SAVE /FRGPAR/
      EQUIVALENCE (PMIX1(1,1),PMIXX1(1))
      EQUIVALENCE (PMIX2(1,1),PMIXX2(1))
      EQUIVALENCE(FRPAR(1),PUD)
      REAL      PUD,PBARY,SIGQT,PEND,XGEN,PSPIN1,PMIX1,PMIX2,XGENSS,
     +          PMIXX1(6),PMIXX2(6),FRPAR(32)
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/JETLIM/PMIN(3),PMAX(3),PTMIN(3),PTMAX(3),YJMIN(3),YJMAX(3)
     1 ,PHIMIN(3),PHIMAX(3),XJMIN(3),XJMAX(3),THMIN(3),THMAX(3)
     2 ,SETLMJ(36)
      SAVE /JETLIM/
      EQUIVALENCE(BLIMS(1),PMIN(1))
      LOGICAL SETLMJ
      COMMON/FIXPAR/FIXP(3),FIXPT(3),FIXYJ(3),FIXPHI(3),FIXXJ(3)
     2   ,FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXQM,FIXQT,FIXYW,FIXXW,FIXPHW
      LOGICAL FIXP,FIXPT,FIXYJ,FIXPHI,FIXXJ
      COMMON/SGNPAR/CTHS(2,3),THS(2,3),YJS(2,3),XJS(2,3)
      REAL      PMIN,PMAX,PTMIN,PTMAX,YJMIN,YJMAX,PHIMIN,PHIMAX,XJMIN,
     +          XJMAX,THMIN,THMAX,BLIMS(36),CTHS,THS,YJS,XJS
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      COMMON/QCDPAR/ALAM,ALAM2,CUTJET,ISTRUC
      SAVE /QCDPAR/
      INTEGER   ISTRUC
      REAL      ALAM,ALAM2,CUTJET
      COMMON/QLMASS/AMLEP(100),NQLEP,NMES,NBARY
      SAVE /QLMASS/
      INTEGER   NQLEP,NMES,NBARY
      REAL      AMLEP
      INTEGER MXGOQ
      PARAMETER (MXGOQ=85)
      COMMON/Q1Q2/GOQ(MXGOQ,3),GOALL(3),GODY(4),STDDY,GOWW(25,2),
     $ALLWW(2),GOWMOD(25,3)
      SAVE /Q1Q2/
      LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
      COMMON/TYPES/LOC(100),NTYP,NJTTYP(3),NWWTYP(2),NWMODE(3)
      COMMON/XTYPES/PARTYP(40),TITLE(10),JETYP(30,3),WWTYP(30,2)
     $,WMODES(30,3)
      SAVE /TYPES/,/XTYPES/
      CHARACTER*8 JETYP,WWTYP,TITLE,PARTYP,WMODES
      INTEGER   LOC,NTYP,NJTTYP,NWWTYP,NWMODE
      COMMON/XMSSM/GOMSSM,GOSUG,GOGMSB
     $,XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      SAVE /XMSSM/
      REAL XGLSS,XMUSS,XHASS,XTBSS
     $,XQ1SS,XDRSS,XURSS,XL1SS,XERSS
     $,XQ2SS,XSRSS,XCRSS,XL2SS,XMRSS
     $,XQ3SS,XBRSS,XTRSS,XL3SS,XTARSS,XATSS,XABSS,XATASS
     $,XM1SS,XM2SS
     $,XM0SU,XMHSU,XA0SU,XTGBSU,XSMUSU
     $,XLAMGM,XMESGM,XN5GM,XCMGV,XMGVTO
      LOGICAL GOMSSM,GOSUG,GOGMSB

C
      INTEGER   MAXLEN
      PARAMETER (MAXLEN=1024)
      COMMON/ZEVEL/IZEVEL(MAXLEN)
      SAVE /ZEVEL/
      EQUIVALENCE(ZEVEL(1),IZEVEL(1))
      EQUIVALENCE(LZEVEL(1),IZEVEL(1))
      EQUIVALENCE (IZVL1,IZEVEL(1))
      EQUIVALENCE (IZVL2,IZEVEL(2))
      INTEGER   IZEVEL,IZVL1,IZVL2
      REAL      ZEVEL(MAXLEN)
      LOGICAL   LZEVEL(MAXLEN)
C
      INTEGER NL,IDSAVE,IL
C
      IL=3
      IDSAVE=IDVER
      CALL MOVLEI(IZEVEL(IL),IDVER,4)
      IF(IDVER.NE.IDSAVE) WRITE(ITLIS,1777) IDVER,IDSAVE
1777  FORMAT(///,
     $' WARNING:  DATA WERE GENERATED WITH VERSION',I5,/,
     $'           DATA ARE BEING READ WITH VERSION',I5,/,
     $' RESULTS CANNOT BE PREDICTED.'///)
      IL=IL+4
      CALL MOVLEI(IZEVEL(IL),NJET,7)
      IL=IL+7
      NL=NJET*MXGOQ
      IF(NJET.NE.0) CALL MOVLEL(LZEVEL(IL),GOQ(1,1),NL)
      IL=14+NL
      CALL MOVLEL(LZEVEL(IL),KEYS(1),10)
      IL=IL+10
      CALL MOVLEV(ZEVEL(IL),PMIN(1),36)
      IL=IL+36
      IF(.NOT.KEYS(3)) GO TO 11
      CALL MOVLEV(ZEVEL(IL),QMIN,12)
      IL=IL+12
11    CONTINUE
      CALL MOVLEL(LZEVEL(IL),GODY(1),5)
      IL=IL+5
      CALL MOVLEV(ZEVEL(IL),PUD,22)
      IL=IL+22
      CALL MOVLEV(ZEVEL(IL),ALAM,4)
      IL=IL+4
      CALL MOVLEV(ZEVEL(IL),AMLEP(6),3)
      IL=IL+3
      CALL MOVLEI(IZEVEL(IL),LOC(1),100)
      IL=IL+100
      CALL MOVLEL(LZEVEL(IL),GOMSSM,1)
      IL=IL+1
      CALL MOVLEV(ZEVEL(IL),XGLSS,11)
      IL=IL+11
      CALL MOVLEL(LZEVEL(IL),GOSUG,1)
      IL=IL+1
      CALL MOVLEV(ZEVEL(IL),XM0SU,5)
      IL=IL+5
C
      RETURN
      END
CDECK  ID>, RDTAPE. 
      SUBROUTINE RDTAPE(IDEV,IFL)
C
C          CALL ROUTINES TO READ AND UNPACK ISAJET DATA
C          RGENS FOR EVENTS
C          RDBEG FOR BEGINNING RECORD
C          REND FOR END RECORD
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/ITA/ITA,ITB
      SAVE /ITA/
      INTEGER   ITA,ITB
      COMMON/RECTP/IRECTP,IREC
      SAVE /RECTP/
      INTEGER   IRECTP,IREC
      INTEGER   MAXLEN
      PARAMETER (MAXLEN=1024)
      COMMON/ZEVEL/IZEVEL(MAXLEN)
      SAVE /ZEVEL/
      EQUIVALENCE(ZEVEL(1),IZEVEL(1))
      EQUIVALENCE(LZEVEL(1),IZEVEL(1))
      EQUIVALENCE (IZVL1,IZEVEL(1))
      EQUIVALENCE (IZVL2,IZEVEL(2))
      INTEGER   IZEVEL,IZVL1,IZVL2
      REAL      ZEVEL(MAXLEN)
      LOGICAL   LZEVEL(MAXLEN)
      ITB=IABS(IDEV)
      CALL RGENS(IFL)
      IF(IFL.NE.0) RETURN
      IF(IRECTP.EQ.200) CALL RDBEG
      IF(IRECTP.EQ.300) CALL REND
      RETURN
      END
CDECK  ID>, REND.   
      SUBROUTINE REND
C
C          INVERSE OF WREND
C          READ END RECORD (TYPE 300)
C
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/FINAL/NKINF,SIGF,ALUM,ACCEPT,NRECS
      SAVE /FINAL/
      INTEGER   NKINF,NRECS
      REAL      SIGF,ALUM,ACCEPT
      INTEGER   MAXLEN
      PARAMETER (MAXLEN=1024)
      COMMON/ZEVEL/IZEVEL(MAXLEN)
      SAVE /ZEVEL/
      EQUIVALENCE(ZEVEL(1),IZEVEL(1))
      EQUIVALENCE(LZEVEL(1),IZEVEL(1))
      EQUIVALENCE (IZVL1,IZEVEL(1))
      EQUIVALENCE (IZVL2,IZEVEL(2))
      INTEGER   IZEVEL,IZVL1,IZVL2
      REAL      ZEVEL(MAXLEN)
      LOGICAL   LZEVEL(MAXLEN)
      NKINF=IZEVEL(3)
      SIGF=ZEVEL(4)
      ALUM=ZEVEL(5)
      ACCEPT=ZEVEL(6)
      NRECS=IZEVEL(7)
      RETURN
      END
CDECK  ID>, RGENS.  
      SUBROUTINE RGENS(IFLAG)
C
C          Inverse of WRGEN
C          Read a record by a call BUFIN
C          If record type is not event type return.
C          If RGENS called with IFLAG=10 return without unpacking.
C          Unpack ZEVEL into appropriate common blocks.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   LIMPOM
      PARAMETER (LIMPOM=20)
      COMMON/MBGEN/POMWT(LIMPOM),POMGEN(LIMPOM),MNPOM,MXPOM,PDIFFR,
     $NPOM,XBARY(2),DXBARY(2),XPOM(LIMPOM,2)
      SAVE /MBGEN/
      INTEGER   MNPOM,MXPOM,NPOM
      REAL      POMWT,POMGEN,PDIFFR,XBARY,DXBARY,XPOM
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/RECTP/IRECTP,IREC
      SAVE /RECTP/
      INTEGER   IRECTP,IREC
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PINITS/PINITS(5,2),IDINIT(2)
      SAVE /PINITS/
      INTEGER   IDINIT
      REAL      PINITS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER   MAXLEN
      PARAMETER (MAXLEN=1024)
      COMMON/ZEVEL/IZEVEL(MAXLEN)
      SAVE /ZEVEL/
      EQUIVALENCE(ZEVEL(1),IZEVEL(1))
      EQUIVALENCE(LZEVEL(1),IZEVEL(1))
      EQUIVALENCE (IZVL1,IZEVEL(1))
      EQUIVALENCE (IZVL2,IZEVEL(2))
      INTEGER   IZEVEL,IZVL1,IZVL2
      REAL      ZEVEL(MAXLEN)
      LOGICAL   LZEVEL(MAXLEN)
      COMMON/TOTALS/NKINPT,NWGEN,NKEEP,SUMWT,WT
      SAVE /TOTALS/
      INTEGER   NKINPT,NWGEN,NKEEP
      REAL      SUMWT,WT
      COMMON/WSIG/SIGLLQ
      SAVE /WSIG/
      REAL      SIGLLQ
      COMMON/FINAL/NKINF,SIGF,ALUM,ACCEPT,NRECS
      SAVE /FINAL/
      INTEGER   NKINF,NRECS
      REAL      SIGF,ALUM,ACCEPT
C
      INTEGER IFLAG
      INTEGER I,IEX,IZ5,K,IFL,ISAV,IL
C
      IFL=IFLAG
      CALL BUFIN(IL,IFLAG)
      IF(IFLAG.NE.0) RETURN
      ISAV=IZEVEL(1)/100
      IRECTP=ISAV*100
      IREC=MOD(IZEVEL(1),100)
      IF(IRECTP.EQ.200) RETURN
      IF(IRECTP.EQ.300) RETURN
      IF(IFL.EQ.10) RETURN
      IL=3
      CALL MOVLEI(IZEVEL(IL),IDVER,4)
      IL=IL+4
      CALL MOVLEL(LZEVEL(IL),KEYS(1),10)
      IL=IL+10
      NJET=IZEVEL(IL)
      IL=IL+1
      CALL MOVLEV(ZEVEL(IL),P(1),59)
      IL=IL+59
      CALL MOVLEV(ZEVEL(IL),SIGF,1)
      IL=IL+1
      IF(.NOT.KEYS(4)) THEN
        SIGMA=ZEVEL(IL)
        SIGEVT=ZEVEL(IL+1)
        WT=ZEVEL(IL+2)
        IL=IL+3
      ENDIF
      NPTCL=IZEVEL(IL)
      IL=IL+1
      IF(NJET.GT.0) THEN
        IEX=NJET*5
        CALL MOVLEV(ZEVEL(IL),PJETS(1,1),IEX)
        IL=IL+IEX
        CALL MOVLEI(IZEVEL(IL),IDJETS(1),NJET)
        IL=IL+NJET
      ENDIF
      IF(KEYS(3).OR.KEYS(7)) THEN
        CALL MOVLEV(ZEVEL(IL),QWJET(1),6)
        IL=IL+6
        CALL MOVLEV(ZEVEL(IL),QMW,16)
        IL=IL+16
        SIGLLQ=ZEVEL(IL)
        IL=IL+1
      ENDIF
      IF(KEYS(6).OR.KEYS(7)) THEN
        NPAIR=IZEVEL(IL)
        IL=IL+1
        IF(NPAIR.NE.0) THEN
          CALL MOVLEV(ZEVEL(IL),PPAIR(1,1),5*NPAIR)
          IL=IL+5*NPAIR
          CALL MOVLEI(IZEVEL(IL),IDPAIR(1),NPAIR)
          IL=IL+NPAIR
          CALL MOVLEI(IZEVEL(IL),JPAIR(1),NPAIR)
          IL=IL+NPAIR
        ENDIF
      ENDIF
      NJSET=IZEVEL(IL)
      IL=IL+1
      CALL MOVLEI(IZEVEL(IL),NKINPT,5)
      IL=IL+5
      CALL MOVLEI(IZEVEL(IL),NPOM,1)
      IL=IL+1
C
C          /JETSET/ COMMON BLOCK
      IF(NJSET.LT.1) GOTO 12
      DO 50 I=1,NJSET
      CALL MOVLEV(ZEVEL(IL),PJSET(1,I),5)
      IL=IL+5
      JORIG(I)=IZEVEL(IL)
      JTYPE(I)=IZEVEL(IL+1)
      JDCAY(I)=IZEVEL(IL+2)
      IL=IL+3
      IF(IL.LE.MAXLEN-9) GO TO 50
      IF(I.EQ.NJSET.AND.NPTCL.EQ.0) GO TO 12
      CALL BUFIN(IL,IFLAG)
      IF(IFLAG.NE.0) RETURN
50    CONTINUE
C
C          /PARTCL/ COMMON BLOCK
C          NPTCL.LT.0 IMPLIES ONLY STABLE PARTICLES ON THIS FILE
C          ORIGIN AND DECAY INFORMATION SUPPRESSED
12    IF(NPTCL.EQ.0) GOTO 999
      IF(NPTCL.GT.0) GOTO 997
C          ONLY STABLE PARTICLES
      NPTCL=-NPTCL
      DO 992 K=1,NPTCL
      CALL MOVLEV(ZEVEL(IL),PPTCL(1,K),5)
      IZ5=IABS(IZEVEL(IL+5))
      IORIG(K)=(IZ5/10000)*1000
      IDENT(K)=MOD(IZ5,10000)*ISIGN(1,IZEVEL(IL+5))
      IDCAY(K)=0
      IL=IL+6
      IF(IL.LE.MAXLEN-6) GOTO 992
      IF(K.EQ.NPTCL) RETURN
      CALL BUFIN(IL,IFLAG)
      IF(IFLAG.NE.0) RETURN
  992 CONTINUE
      RETURN
C          ALL PARTICLES
C          NOTE THAT IDCAY CAN EXCEED 2**24 LIMIT OF PAIRPAK
  997 CONTINUE
      DO 998 K=1,NPTCL
      CALL MOVLEV(ZEVEL(IL),PPTCL(1,K),5)
      IORIG(K)=IZEVEL(IL+5)
      IDENT(K)=IZEVEL(IL+6)
      IDCAY(K)=IZEVEL(IL+7)*IPACK+IZEVEL(IL+8)
      IL=IL+9
      IF(IL.LE.MAXLEN-9) GOTO 998
      IF(K.EQ.NPTCL) RETURN
      CALL BUFIN(IL,IFLAG)
      IF(IFLAG.NE.0) RETURN
  998 CONTINUE
  999 CONTINUE
      RETURN
      END
CDECK  ID>, WGENS.  
      SUBROUTINE WGENS
C
C          Copy event information into ZEVEL and call BUFOUT.
C          If number of words required exceeds MAXLEN-8, the number
C          of records written=no. of words/(MAXLEN-8)+1
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   LIMPOM
      PARAMETER (LIMPOM=20)
      COMMON/MBGEN/POMWT(LIMPOM),POMGEN(LIMPOM),MNPOM,MXPOM,PDIFFR,
     $NPOM,XBARY(2),DXBARY(2),XPOM(LIMPOM,2)
      SAVE /MBGEN/
      INTEGER   MNPOM,MXPOM,NPOM
      REAL      POMWT,POMGEN,PDIFFR,XBARY,DXBARY,XPOM
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/JETPAR/P(3),PT(3),YJ(3),PHI(3),XJ(3),TH(3),CTH(3),STH(3)
     1 ,JETTYP(3),SHAT,THAT,UHAT,QSQ,X1,X2,PBEAM(2)
     2 ,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,JWTYP
     3 ,ALFQSQ,CTHW,STHW,Q0W
     4 ,INITYP(2),ISIGS,PBEAMS(5)
      SAVE /JETPAR/
      INTEGER   JETTYP,JWTYP,INITYP,ISIGS
      REAL      P,PT,YJ,PHI,XJ,TH,CTH,STH,SHAT,THAT,UHAT,QSQ,X1,X2,
     +          PBEAM,QMW,QW,QTW,YW,XW,THW,QTMW,PHIW,SHAT1,THAT1,UHAT1,
     +          ALFQSQ,CTHW,STHW,Q0W,PBEAMS
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      INTEGER   MXSIGS,IOPAK
      PARAMETER (MXSIGS=3000,IOPAK=100)
      COMMON/JETSIG/SIGMA,SIGS(MXSIGS),NSIGS,INOUT(MXSIGS),SIGEVT
      SAVE /JETSIG/
      INTEGER   NSIGS,INOUT
      REAL      SIGMA,SIGS,SIGEVT
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      COMMON/PINITS/PINITS(5,2),IDINIT(2)
      SAVE /PINITS/
      INTEGER   IDINIT
      REAL      PINITS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER   MAXLEN
      PARAMETER (MAXLEN=1024)
      COMMON/ZEVEL/IZEVEL(MAXLEN)
      SAVE /ZEVEL/
      EQUIVALENCE(ZEVEL(1),IZEVEL(1))
      EQUIVALENCE(LZEVEL(1),IZEVEL(1))
      EQUIVALENCE (IZVL1,IZEVEL(1))
      EQUIVALENCE (IZVL2,IZEVEL(2))
      INTEGER   IZEVEL,IZVL1,IZVL2
      REAL      ZEVEL(MAXLEN)
      LOGICAL   LZEVEL(MAXLEN)
      COMMON/FINAL/NKINF,SIGF,ALUM,ACCEPT,NRECS
      SAVE /FINAL/
      INTEGER   NKINF,NRECS
      REAL      SIGF,ALUM,ACCEPT
      COMMON/TOTALS/NKINPT,NWGEN,NKEEP,SUMWT,WT
      SAVE /TOTALS/
      INTEGER   NKINPT,NWGEN,NKEEP
      REAL      SUMWT,WT
      COMMON/WSIG/SIGLLQ
      SAVE /WSIG/
      REAL      SIGLLQ
C
      INTEGER I2,I1,JET,K,IEX,IL,ITA,I,NPSTA
C
      ITA=IABS(ITEVT)
      IZEVEL(1)=100
      IZEVEL(2)=1
      IL=3
      CALL MOVLEI(IDVER,IZEVEL(IL),4)
      IL=IL+4
      CALL MOVLEL(KEYS(1),LZEVEL(IL),10)
      IL=IL+10
      IZEVEL(IL)=NJET
      IL=IL+1
      CALL MOVLEV(P(1),ZEVEL(IL),59)
      IL=IL+59
      CALL MOVLEV(SIGF,ZEVEL(IL),1)
      IL=IL+1
      IF(.NOT.KEYS(4)) THEN
        ZEVEL(IL)=SIGMA
        ZEVEL(IL+1)=SIGEVT
        ZEVEL(IL+2)=WT
        IL=IL+3
      ENDIF
C          IF ITEVT.LT.0 WRITE ONLY STABLE PARTICLES AND FLAG
C          BY NPTCL=-(NO. OF STABLE PARTICLES)
      IF(ITEVT.GT.0) THEN
        IZEVEL(IL)=NPTCL
      ELSE
        NPSTA=0
        DO 990 I=1,NPTCL
990     IF(IDCAY(I).EQ.0) NPSTA=NPSTA+1
        IZEVEL(IL)=-NPSTA
      ENDIF
      IL=IL+1
      IF(NJET.GT.0) THEN
        IEX=NJET*5
        CALL MOVLEV(PJETS(1,1),ZEVEL(IL),IEX)
        IL=IL+IEX
        CALL MOVLEI(IDJETS(1),IZEVEL(IL),NJET)
        IL=IL+NJET
      ENDIF
      IF(KEYS(3).OR.KEYS(7)) THEN
        CALL MOVLEV(QWJET(1),ZEVEL(IL),6)
        IL=IL+6
        CALL MOVLEV(QMW,ZEVEL(IL),16)
        IL=IL+16
        I1=JWTYP
        I2=JETTYP(3)
        IZEVEL(IL)=SIGLLQ
        IL=IL+1
      ENDIF
      IF(KEYS(6).OR.KEYS(7)) THEN
        IZEVEL(IL)=NPAIR
        IL=IL+1
        IF(NPAIR.NE.0) THEN
          CALL MOVLEV(PPAIR(1,1),ZEVEL(IL),5*NPAIR)
          IL=IL+5*NPAIR
          CALL MOVLEI(IDPAIR(1),IZEVEL(IL),NPAIR)
          IL=IL+NPAIR
          CALL MOVLEI(JPAIR(1),IZEVEL(IL),NPAIR)
          IL=IL+NPAIR
        ENDIF
      ENDIF
      IZEVEL(IL)=NJSET
      IL=IL+1
      CALL MOVLEI(NKINPT,IZEVEL(IL),5)
      IL=IL+5
      CALL MOVLEI(NPOM,IZEVEL(IL),1)
      IL=IL+1
C
C          /JETSET/ COMMON BLOCK
      IF(NJSET.LT.1) GOTO 12
      DO 50 I=1,NJSET
      CALL MOVLEV(PJSET(1,I),ZEVEL(IL),5)
      IL=IL+5
      IZEVEL(IL)=JORIG(I)
      IZEVEL(IL+1)=JTYPE(I)
      IZEVEL(IL+2)=JDCAY(I)
      IL=IL+3
      IF(IL.LE.MAXLEN-9) GO TO 50
      IZEVEL(1)=IZEVEL(1)+1
      CALL BUFOUT(IL)
      IF(I.EQ.NJSET) GO TO 12
50    CONTINUE
C
C          /PARTCL/ COMMON BLOCK
C          IF ITEVT.LT.0, WRITE OUT ONLY STABLE PARTICLES
C          FLAG BY NPTCL=-(NO. OF STABLE PARTICLES)
C          SUPPRESS ORIGIN AND DECAY INFORMATION
12    IF(NPTCL.EQ.0) GOTO 999
      IF(ITEVT.GT.0) GOTO 997
C          ONLY STABLE PARTICLES
      DO 992 K=1,NPTCL
      IF(IDCAY(K).NE.0) GOTO 992
      JET=IABS(IORIG(K))/1000
      CALL MOVLEV(PPTCL(1,K),ZEVEL(IL),5)
      IZEVEL(IL+5)=(JET*10000+IABS(IDENT(K)))*ISIGN(1,IDENT(K))
      IL=IL+6
      IF(IL.LE.MAXLEN-6) GOTO 992
      IZEVEL(1)=IZEVEL(1)+1
      CALL BUFOUT(IL)
      IF(K.EQ.NPTCL) RETURN
  992 CONTINUE
      GOTO 999
  997 CONTINUE
C          ALL PARTICLES
C          NOTE IDCAY CAN EXCEED 2**24 LIMIT OF PAIRPAK
      DO 998 K=1,NPTCL
      CALL MOVLEV(PPTCL(1,K),ZEVEL(IL),5)
      IZEVEL(IL+5)=IORIG(K)
      IZEVEL(IL+6)=IDENT(K)
      IZEVEL(IL+7)=IDCAY(K)/IPACK
      IZEVEL(IL+8)=MOD(IDCAY(K),IPACK)
      IL=IL+9
      IF(IL.LE.MAXLEN-9) GOTO 998
      IZEVEL(1)=IZEVEL(1)+1
      CALL BUFOUT(IL)
      IF(K.EQ.NPTCL) RETURN
  998 CONTINUE
  999 CONTINUE
      IZEVEL(1)=IZEVEL(1)+1
      CALL BUFOUT(IL)
      RETURN
      END
CDECK  ID>, ZEROL.  
      SUBROUTINE ZEROL(Z,N)
C          SET N VALUES OF Z IN LEVEL2 TO ZERO
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      DIMENSION Z(N)
      DO 1 I=1,N
    1 Z(I)=0
      RETURN
      END
CDECK  ID>, CALINI. 
      SUBROUTINE CALINI
C
C          Initialize calorimeter for CALSIM and GETJET.  Note that
C          because the initialization is separate, CALSIM can be
C          called more than once to simulate pileup of several events.
C
      IMPLICIT NONE
C          ISAJET common blocks
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
C
C          ISAPLT common blocks
      REAL      DELY,YCMIN,YCMAX
      INTEGER   NCY
      PARAMETER (NCY=80,DELY=.1,YCMIN=-4.,YCMAX=4.)
      REAL      DELPHI
      INTEGER   NCPHI
      PARAMETER (NCPHI=72,DELPHI=.087267)
      COMMON/CALOR/ET(NCY,NCPHI),ETEM(NCY,NCPHI),
     $CTHCAL(NCY),STHCAL(NCY),CPHCAL(NCPHI),SPHCAL(NCPHI)
      SAVE /CALOR/
      REAL      ET,ETEM,CTHCAL,STHCAL,CPHCAL,SPHCAL
      INTEGER   NJMAX
      PARAMETER (NJMAX=50)
      COMMON/GETCOM/JETNO(NCY,NCPHI),NCJET,PCJET(4,NJMAX),ETJET(NJMAX)
      SAVE /GETCOM/
      INTEGER   JETNO,NCJET
      REAL      PCJET,ETJET
C
      INTEGER IPHI,IY
      REAL PHIX,YX,THX
C          Initialize ET array.
      DO 100 IPHI=1,NCPHI
      DO 100 IY=1,NCY
        ET(IY,IPHI)=0.
        ETEM(IY,IPHI)=0.
100   CONTINUE
C
C          Calculate trig. functions.
      DO 200 IPHI=1,NCPHI
        PHIX=DELPHI*(IPHI-.5)
        CPHCAL(IPHI)=COS(PHIX)
        SPHCAL(IPHI)=SIN(PHIX)
200   CONTINUE
      DO 300 IY=1,NCY
        YX=DELY*(IY-.5)+YCMIN
        THX=2.*ATAN(EXP(-YX))
        CTHCAL(IY)=COS(THX)
        STHCAL(IY)=SIN(THX)
300   CONTINUE
      RETURN
      END
CDECK  ID>, CALSIM. 
      SUBROUTINE CALSIM(RESEM,RESHAD)
C
C          Trivial calorimeter simulation. Deposit energy
C            ET(IY,IPHI)   = total energy in bin (IY,IPHI)
C            ETEM(IY,IPHI) = electromagnetic energy in bin (IY,IPHI)
C          in cells with uniform Y and PHI bins and energy resolutions
C            SIGMA/E=RESEM/SQRT(E)  for electrons and photons
C            SIGMA/E=RESHAD/SQRT(E) for hadrons
C          and with no shower spreading. Note that muons deposit their
C          full energy with hadronic resolution.
C
C          Ver 7.33: Treat gravitino = 91 as non-interacting.
C
      IMPLICIT NONE
C          ISAJET common blocks
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
C
C          ISAPLT common blocks
      REAL      DELY,YCMIN,YCMAX
      INTEGER   NCY
      PARAMETER (NCY=80,DELY=.1,YCMIN=-4.,YCMAX=4.)
      REAL      DELPHI
      INTEGER   NCPHI
      PARAMETER (NCPHI=72,DELPHI=.087267)
      COMMON/CALOR/ET(NCY,NCPHI),ETEM(NCY,NCPHI),
     $CTHCAL(NCY),STHCAL(NCY),CPHCAL(NCPHI),SPHCAL(NCPHI)
      SAVE /CALOR/
      REAL      ET,ETEM,CTHCAL,STHCAL,CPHCAL,SPHCAL
      INTEGER   NJMAX
      PARAMETER (NJMAX=50)
      COMMON/GETCOM/JETNO(NCY,NCPHI),NCJET,PCJET(4,NJMAX),ETJET(NJMAX)
      SAVE /GETCOM/
      INTEGER   JETNO,NCJET
      REAL      PCJET,ETJET
C
      INTEGER IP,IY,IPHI,IDABS
      REAL PI,PTIP,PIP,PPLUS,PMINUS,YIP,PHIIP,EIP,RGEN1,RGEN2,RANF,R1,
     $RESEM,RESHAD
C
C          Fill calorimeter
C
      PI=4.*ATAN(1.)
      DO 200 IP=1,NPTCL
        IF(IDCAY(IP).NE.0) GO TO 200
        IDABS=IABS(IDENT(IP))
        IF(IDABS.EQ.11.OR.IDABS.EQ.13.OR.IDABS.EQ.15.OR.IDABS.EQ.30
     $  .OR.IDABS.EQ.91) GO TO 200
        PTIP=SQRT(PPTCL(1,IP)**2+PPTCL(2,IP)**2)
        PIP=SQRT(PTIP**2+PPTCL(3,IP)**2)
        PPLUS=PPTCL(4,IP)+PPTCL(3,IP)
        PMINUS=PPTCL(4,IP)-PPTCL(3,IP)
        IF(PPLUS.LE.0..OR.PMINUS.LE.0.) GO TO 200
        YIP=.5*ALOG(PPLUS/PMINUS)
        PHIIP=ATAN2(PPTCL(2,IP),PPTCL(1,IP))
        IF(PHIIP.LT.0.) PHIIP=PHIIP+2.*PI
        IF(YIP.LT.YCMIN.OR.YIP.GT.YCMAX) GO TO 200
        IY=INT((YIP-YCMIN)/DELY)+1
        IPHI=INT(PHIIP/DELPHI)+1
        EIP=PPTCL(4,IP)
C
C          Smear energy
        RGEN1=SQRT(-2.*ALOG(RANF()))
        RGEN2=2.*PI*RANF()
        R1=RGEN1*COS(RGEN2)
        IF(IDABS.EQ.10.OR.IDABS.EQ.12.OR.IDABS.EQ.110.OR.
     $  IDABS.EQ.220) THEN
          EIP=EIP+(RESEM*SQRT(EIP))*R1
          ET(IY,IPHI)=ET(IY,IPHI)+EIP*STHCAL(IY)
          ETEM(IY,IPHI)=ETEM(IY,IPHI)+EIP*STHCAL(IY)
        ELSE
          EIP=EIP+(RESHAD*SQRT(EIP))*R1
          ET(IY,IPHI)=ET(IY,IPHI)+EIP*STHCAL(IY)
        ENDIF
200   CONTINUE
      RETURN
      END
CDECK  ID>, EHIST.  
      SUBROUTINE EHIST
C
C          Print HBOOK histograms with contents and errors in E format.
C          Supports both HBOOK3 and HBOOK4.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/MYHIST/MXHIST,NHSHFT
      SAVE /MYHIST/
      INTEGER   MXHIST,NHSHFT
C
      LOGICAL HEXIST
      CHARACTER*1 APRNT(10,120)
      CHARACTER*10 WORD
      CHARACTER*80 TITLE
      INTEGER ID1,ID,NWT,NY,NX,IAD,NCH,J,K
      REAL XMIN,XMAX,YMIN,YMAX,ZMIN,ZMAX,HMIN,HMAX,Y,HI,HIE
C
C          Print histogram index
      CALL HINDEX
C
C          Loop over weighted histograms
C
      DO 1000 ID1=1,MXHIST
        ID=ID1+NHSHFT
        IF(.NOT.HEXIST(ID)) GO TO 1000
C          Print histogram in standard way
        CALL HPRINT(ID)
C
C          Check for 2 dimensional histogram
        NWT=8
        NY=0
        CALL HGIVE(ID,TITLE,NX,XMIN,XMAX,NY,YMIN,YMAX,NWT,IAD)
        IF(NY.NE.0) THEN
          ZMAX=HMAX(ID)
          ZMIN=HMIN(ID)
          WRITE(ITLIS,2010) ZMIN,ZMAX
2010      FORMAT(/'  * CONTENT MIN = ',E12.5,'  MAX = ',E12.5)
          GO TO 1000
        ENDIF
C
C          Print 1-dimensional channel contents in E format.
C
        NCH=NX
        IF(NCH.GT.100) NCH=100
C          Clear APRNT array
        DO 100 J=1,100
        DO 100 K=1,10
100     APRNT(K,J)=' '
C          Extract contents and convert to E format
        DO 110 J=1,NCH
          Y=HI(ID,J)
          WRITE(WORD,'(E10.4)') Y
          READ(WORD,'(10A1)') (APRNT(K,J),K=1,10)
110     CONTINUE
C          Print channel marks
        WRITE(ITLIS,121)
121     FORMAT('1'//
     1  ' CHANNELS',6X,'0',99X,'1'/
     2  15X,'0',9X,'1',9X,'2',9X,'3',9X,'4',9X,'5',9X,'6',9X,'7',9X,'8',
     3  9X,'9',9X,'0'/
     4  15X,'0',10('1234567890')/)
C          Print channel contents
        DO 130 K=1,10
          IF(K.EQ.1) WRITE(ITLIS,131) (APRNT(K,J),J=1,NCH)
131       FORMAT(' CONTENTS',7X,100A1)
          IF(K.GT.1) WRITE(ITLIS,132) (APRNT(K,J),J=1,NCH)
132       FORMAT(16X,100A1)
130     CONTINUE
C
C          Print 1-dimensional errors in E format.
C
C          Clear APRNT array
        DO 200 J=1,100
        DO 200 K=1,10
200     APRNT(K,J)=' '
C          Extract errors and convert to E format
        DO 210 J=1,NCH
          Y=HIE(ID,J)
          WRITE(WORD,'(E10.4)') Y
          READ(WORD,'(10A1)') (APRNT(K,J),K=1,10)
202       FORMAT(10A1)
210     CONTINUE
C          Print channel marks
        WRITE(ITLIS,221)
221     FORMAT(//
     1  ' CHANNELS',6X,'0',99X,'1'/
     2  15X,'0',9X,'1',9X,'2',9X,'3',9X,'4',9X,'5',9X,'6',9X,'7',9X,'8',
     3  9X,'9',9X,'0'/
     4  15X,'0',10('1234567890')/)
C          Print channel errors
        DO 230 K=1,10
          IF(K.EQ.1) WRITE(ITLIS,231) (APRNT(K,J),J=1,NCH)
231       FORMAT(' ERRORS  ',7X,100A1)
          IF(K.GT.1) WRITE(ITLIS,232) (APRNT(K,J),J=1,NCH)
232       FORMAT(16X,100A1)
230     CONTINUE
1000  CONTINUE
C
      RETURN
      END
CDECK  ID>, GETJET. 
      SUBROUTINE GETJET(RJET,EJCUT)
C
C          Simple jet-finding algorithm (similar to UA1).
C          Find highest remaining cell > ETSTOP and sum surrounding
C          cells with--
C            DELTA(Y)**2+DELTA(PHI)**2<RJET**2
C            ET>ECCUT.
C          Keep jets with ET>EJCUT.
C          The UA1 parameters are RJET=1.0 and EJCUT=5.0
C
      IMPLICIT NONE
C
C          ISAPLT common blocks
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      REAL      DELY,YCMIN,YCMAX
      INTEGER   NCY
      PARAMETER (NCY=80,DELY=.1,YCMIN=-4.,YCMAX=4.)
      REAL      DELPHI
      INTEGER   NCPHI
      PARAMETER (NCPHI=72,DELPHI=.087267)
      COMMON/CALOR/ET(NCY,NCPHI),ETEM(NCY,NCPHI),
     $CTHCAL(NCY),STHCAL(NCY),CPHCAL(NCPHI),SPHCAL(NCPHI)
      SAVE /CALOR/
      REAL      ET,ETEM,CTHCAL,STHCAL,CPHCAL,SPHCAL
      INTEGER   NJMAX
      PARAMETER (NJMAX=50)
      COMMON/GETCOM/JETNO(NCY,NCPHI),NCJET,PCJET(4,NJMAX),ETJET(NJMAX)
      SAVE /GETCOM/
      INTEGER   JETNO,NCJET
      REAL      PCJET,ETJET
C
      INTEGER IPHI,IY,J,K,NPHI1,NPHI2,NY1,NY2,IPASS,IYMX,IPHIMX,IPHI1,
     $IPHIX,IY1,IYX
      REAL    RJET,ETMAX,ETSTOP,RR,ECCUT,PX,EJCUT
C          Parameters
      DATA ECCUT/.5/
      DATA ETSTOP/1./
C
C          Initialize
C
      DO 100 IPHI=1,NCPHI
      DO 100 IY=1,NCY
100   JETNO(IY,IPHI)=0
      DO 110 J=1,NJMAX
        ETJET(J)=0.
        DO 110 K=1,4
111     PCJET(K,J)=0.
110   CONTINUE
      NCJET=0
      NPHI1=RJET/DELPHI
      NPHI2=2*NPHI1+1
      NY1=RJET/DELY
      NY2=2*NY1+1
      IPASS=0
C
C          Find highest cell remaining
C
1     ETMAX=0.
      DO 200 IPHI=1,NCPHI
        DO 210 IY=1,NCY
          IF(JETNO(IY,IPHI).NE.0) GO TO 210
          IF(ET(IY,IPHI).LT.ETMAX) GO TO 210
          ETMAX=ET(IY,IPHI)
          IYMX=IY
          IPHIMX=IPHI
210     CONTINUE
200   CONTINUE
      IF(ETMAX.LT.ETSTOP) RETURN
C
C          Sum cells
C
      IPASS=IPASS+1
      IF(IPASS.GT.NCY*NCPHI) THEN
        WRITE(ITLIS,8888) IPASS
8888    FORMAT(//' ERROR IN GETJET...IPASS > ',I6)
        STOP 99
      ENDIF
      NCJET=NCJET+1
      IF(NCJET.GT.NJMAX) THEN
        WRITE(ITLIS,9999) NCJET
9999    FORMAT(//' ERROR IN GETJET...NCJET > ',I5)
        STOP 99
      ENDIF
      DO 300 IPHI1=1,NPHI2
        IPHIX=IPHIMX-NPHI1-1+IPHI1
        IF(IPHIX.LE.0) IPHIX=IPHIX+NCPHI
        IF(IPHIX.GT.NCPHI) IPHIX=IPHIX-NCPHI
        DO 310 IY1=1,NY2
          IYX=IYMX-NY1-1+IY1
          IF(IYX.LE.0) GO TO 310
          IF(IYX.GT.NCY) GO TO 310
          IF(JETNO(IYX,IPHIX).NE.0) GO TO 310
          RR=(DELY*(IY1-NY1-1))**2+(DELPHI*(IPHI1-NPHI1-1))**2
          IF(RR.GT.RJET**2) GO TO 310
          IF(ET(IYX,IPHIX).LT.ECCUT) GO TO 310
          PX=ET(IYX,IPHIX)/STHCAL(IYX)
C          Add cell to jet
          PCJET(1,NCJET)=PCJET(1,NCJET)+PX*STHCAL(IYX)*CPHCAL(IPHIX)
          PCJET(2,NCJET)=PCJET(2,NCJET)+PX*STHCAL(IYX)*SPHCAL(IPHIX)
          PCJET(3,NCJET)=PCJET(3,NCJET)+PX*CTHCAL(IYX)
          PCJET(4,NCJET)=PCJET(4,NCJET)+PX
          ETJET(NCJET)=ETJET(NCJET)+ET(IYX,IPHIX)
          JETNO(IYX,IPHIX)=NCJET
310     CONTINUE
300   CONTINUE
C
C          Discard jet if ET < EJCUT.
C
      IF(ETJET(NCJET).GT.EJCUT) GO TO 1
      ETJET(NCJET)=0.
      DO 400 K=1,4
400   PCJET(K,NCJET)=0.
      NCJET=NCJET-1
      GO TO 1
C
      END
CDECK  ID>, ISAPLT. 
      SUBROUTINE ISAPLT(JTIN,JTLIS)
C
C          Skeleton of a job to analyse ISAJET events from tape JTIN
C          with a trivial calorimeter simulation and a simple UA1
C          jet-finding algorithm.
C
C          Histogram results with CERN HBOOK 3 or 4. Each histogram
C          should be booked in SETUP with 1 < ID < 100. A second
C          histogram is then automatically booked with ID + 100. The
C          first histogram is filled in USER. At the end of a run, the
C          cross section SIGF is used to fill the second histogram with
C          the proper weight, and the first histogram is cleared.
C
C          Print 1-dim histograms with contents and errors in E format.
C          Print 2-dim histograms with automatic scaling.
C          All printing is on tape JTLIS.
C
      IMPLICIT NONE
C          ISAJET common blocks
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/RECTP/IRECTP,IREC
      SAVE /RECTP/
      INTEGER   IRECTP,IREC
      COMMON/FINAL/NKINF,SIGF,ALUM,ACCEPT,NRECS
      SAVE /FINAL/
      INTEGER   NKINF,NRECS
      REAL      SIGF,ALUM,ACCEPT
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
C
C          ISAPLT common blocks
      COMMON/MYHIST/MXHIST,NHSHFT
      SAVE /MYHIST/
      INTEGER   MXHIST,NHSHFT
C
C          HBOOK and other variables. NWMEMO = number of words for
C          histograms; it may have to be increased.
      INTEGER NWMEMO
      PARAMETER (NWMEMO=10000)
      COMMON/PAWC/HMEMOR(NWMEMO)
      REAL HMEMOR
      LOGICAL HEXIST
      CHARACTER*40 V,VISAJE
      INTEGER JTIN,JTLIS,ITAPE,IFL,I
      REAL SIGWT
C
C          Initialize
      V=VISAJE()
      CALL HLIMIT(NWMEMO)
      ITLIS=IABS(JTLIS)
      ITAPE=IABS(JTIN)
      CALL HOUTPU(ITLIS)
      CALL HERMES(ITLIS)
C
C          Set up histograms
      CALL SETUP
C
C          Read next record until eof encountered
      REWIND ITAPE
1     CONTINUE
      IFL=0
      CALL RDTAPE(ITAPE,IFL)
      IF(IFL.EQ.-1) GO TO 3
      IF(IRECTP.EQ.200) GO TO 1
      IF(IRECTP.EQ.300) GO TO 2
C
C          Event record
      CALL USER
      GO TO 1
C
C          End of run record. Weight histograms.
2     CONTINUE
      SIGWT=SIGF/FLOAT(NEVENT)
      IF(SIGWT.EQ.0.) SIGWT=1.
      DO 100 I=1,MXHIST
        IF(.NOT.HEXIST(I)) GO TO 100
        CALL HOPERA(I,'+',I+NHSHFT,I+NHSHFT,SIGWT,1.)
        CALL HRESET(I,' ')
100   CONTINUE
      GO TO 1
C
C          End of job. Output histograms.
3     CALL EHIST
      RETURN
      END
CDECK  ID>, SETUP.  
      SUBROUTINE SETUP
C
C          User routine to book histograms for HBOOK 3 or 4.
C
C          Sets up two histograms for each plot.
C          Histogram I, 1<I<MXHIST, is unweighted and never printed.
C          Histogram I+NHSHFT is weighted by SIGF/NEVENT unless SIGF=0.
C          Scatter plots are automatically scaled.
C
      IMPLICIT NONE
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/MYHIST/MXHIST,NHSHFT
      SAVE /MYHIST/
      INTEGER   MXHIST,NHSHFT
C
      LOGICAL HEXIST
      INTEGER I
C
C          MXHIST=maximum unweighted histogram ID.
      MXHIST=100
      NHSHFT=100
C
C          Book unweighted histograms with HBOOK1 and HBOOK2 below.
C          ID should be less than MXHIST.
C          2-DIM histograms *MUST* be booked with 1 word/channel.
C-----------------------------------------------------------------------
C-
C-
C-
C-
C-
C-----------------------------------------------------------------------
C
C          Provide automatic scaling for scatter plots.
      CALL HSCALE(0,0.)
C
C          Create copies of histograms with ID2=ID1+NHSHFT
C          Set error bar mode to display errors.
      DO 100 I=1,MXHIST
        IF(.NOT.HEXIST(I)) GO TO 100
        CALL HCOPY(I,I+NHSHFT,' ')
        CALL HBARX(I)
        CALL HBARX(I+NHSHFT)
100   CONTINUE
      RETURN
      END
CDECK  ID>, USER.   
      SUBROUTINE USER
C
C          User routine to do analysis for each event.
C
C          All histograms should be booked in SETUP and filled with
C          HFILL using weight 1. The correct weight SIGF/NEVENT will
C          be inserted by ISAPLT.
C
C          For a trivial calorimeter simulation with resolutions
C            SIGMA(E)/E = RESEM/SQRT(E)  for electromagnetic
C            SIGMA(E)/E = RESHAD/SQRT(E) for hadronic
C            (RESEM = .15, RESHAD = .35  for uranium calorimeter)
C            (RESEM = .15, RESHAD = .70  for iron calorimeter)
C          use
C
C     CALL CALINI
C     CALL CALSIM(RESEM,RESHAD)
C
C          Then to find jets with a simplified version of the UA1 jet
C          algorithm with jet radius RJET and minimum scalar transverse
C          energy EJCUT (RJET=1., EJCUT=5. for UA1) use
C
C     CALL GETJET(RJET,EJCUT)
C
C          See CALINI, CALSIM, and GETJET for additional comments.
C
C          ISAJET common blocks
      COMMON/ITAPES/ITDKY,ITEVT,ITCOM,ITLIS
      SAVE /ITAPES/
      INTEGER   ITDKY,ITEVT,ITCOM,ITLIS
      COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA
      SAVE /PRIMAR/
      INTEGER   NJET,IDIN,NEVENT,NTRIES,NSIGMA
      REAL      SCM,HALFE,ECM
      INTEGER MXJETS
      PARAMETER (MXJETS=10)
      COMMON/PJETS/PJETS(5,MXJETS),IDJETS(MXJETS),QWJET(5),IDENTW
     $,PPAIR(5,4),IDPAIR(4),JPAIR(4),NPAIR,IFRAME(MXJETS)
      SAVE /PJETS/
      INTEGER   IDJETS,IDENTW,IDPAIR,JPAIR,NPAIR,IFRAME
      REAL      PJETS,QWJET,PPAIR
      INTEGER   MXPTCL,IPACK
      PARAMETER (MXPTCL=4000,IPACK=10000)
      COMMON/PARTCL/NPTCL,PPTCL(5,MXPTCL),IORIG(MXPTCL),IDENT(MXPTCL)
     1,IDCAY(MXPTCL)
      SAVE /PARTCL/
      INTEGER   NPTCL,IORIG,IDENT,IDCAY
      REAL      PPTCL
      INTEGER   MXJSET,JPACK
      PARAMETER (MXJSET=400,JPACK=1000)
      COMMON/JETSET/NJSET,PJSET(5,MXJSET),JORIG(MXJSET),JTYPE(MXJSET),
     $JDCAY(MXJSET)
      SAVE /JETSET/
      INTEGER   NJSET,JORIG,JTYPE,JDCAY
      REAL      PJSET
      COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
      SAVE /IDRUN/
      INTEGER   IDVER,IDG,IEVT,IEVGEN
      COMMON/KEYS/IKEYS,KEYON,KEYS(10)
      COMMON/XKEYS/REAC
      SAVE /KEYS/,/XKEYS/
      LOGICAL KEYS
      LOGICAL KEYON
      CHARACTER*8 REAC
      INTEGER   IKEYS
      COMMON/FINAL/NKINF,SIGF,ALUM,ACCEPT,NRECS
      SAVE /FINAL/
      INTEGER   NKINF,NRECS
      REAL      SIGF,ALUM,ACCEPT
C
C          ISAPLT common blocks
      REAL      DELY,YCMIN,YCMAX
      INTEGER   NCY
      PARAMETER (NCY=80,DELY=.1,YCMIN=-4.,YCMAX=4.)
      REAL      DELPHI
      INTEGER   NCPHI
      PARAMETER (NCPHI=72,DELPHI=.087267)
      COMMON/CALOR/ET(NCY,NCPHI),ETEM(NCY,NCPHI),
     $CTHCAL(NCY),STHCAL(NCY),CPHCAL(NCPHI),SPHCAL(NCPHI)
      SAVE /CALOR/
      REAL      ET,ETEM,CTHCAL,STHCAL,CPHCAL,SPHCAL
      INTEGER   NJMAX
      PARAMETER (NJMAX=50)
      COMMON/GETCOM/JETNO(NCY,NCPHI),NCJET,PCJET(4,NJMAX),ETJET(NJMAX)
      SAVE /GETCOM/
      INTEGER   JETNO,NCJET
      REAL      PCJET,ETJET
C
C          Calculate desired quantities below and fill histograms
C          with HFILL.
C-----------------------------------------------------------------------
C-
C-
C-
C-
C-
C-----------------------------------------------------------------------
      RETURN
      END
