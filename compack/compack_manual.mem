    

                                    COMPACK,

                A Command Input Package for Interactive Programs.

                               Programmers Manual.

                              Software Version 4.20

                                  J. S. Hoftun
                                Brown University
                                   31 May 1989

          Introduction.

        The  command  input  package  COMPACK  described  in  this  manual,
      consists of a set of utility routines used to input commands and data
      in a selfconsistent way.  In addition, command parsing  routines  and
      screen manipulation routines are built into the package.

        All the setup information  is  read  in  from  a  file  at  program
      startup; this makes it easier for an application programmer to change
      the order of commands, to add commands  or  to  delete  commands.   A
      utility (written in COMPACK) exists to facilitate easy change of this
      setup information.

        The commands currently implemented are mostly separate tasks to  be
      performed  on request.  In some cases (under VAX/VMS) a subprocess is
      spawned to perform a completely  independent  task;  in  other  cases
      submenus  are  presented  for  further choice.  Template routines for
      creating such tasks also exist.  An appllication  programmer  adds  a
      new  command by including an ELSEIF block usually 2-3 lines long in a
      dispatching type routine.  This makes  sure  that  the  name  of  the
      subroutine  performing  the  task  is  included in the linking of the
      program.  The utility which makes up the setup files (MENU_MAKER) may
      also be used to make a first version of the 'dispatch' routine.

        Under VAX/VMS the user of the program has the choice of whether  to
      use  a full screen MENU MODE or a line oriented input mode.  The mode
      may be selected at the start of the program or by  switching  when  a
      menu  or command prompt line is displayed.  The program will also run
      in batch mode and is able to read commands  from  an  external  file.
      The  full screen mode is currently only available on a terminal known
      to VMS as a VT100 compatible terminal (including the VT200 series and
      VAXstations).   The  program  gets  this terminal identification from
      VMS.

        The  package  is  written  in  VAX-11  FORTRAN,  but  in   standard
      FORTRAN-77 as much as possible.  The MENU MODE part uses VAX Run Time
      Library  routines  very  extensively  (especially  the   SMG   screen
      manipulation  routines),  but  it should be possible to transport the
      LINE MODE part to other operating systems.
                                   CONTENTS



CHAPTER 1       GUIDE TO PROGRAMMING 

        1.1     Overview of the Package  . . . . . . . . . . . . . 1-1
        1.2     Main Program . . . . . . . . . . . . . . . . . . . 1-2
        1.3     The Dispatching Loop.  . . . . . . . . . . . . . . 1-3
        1.4     System Commands. . . . . . . . . . . . . . . . . . 1-3
        1.5     Adding a New Command . . . . . . . . . . . . . . . 1-4


CHAPTER 2       DESCRIPTION OF ROUTINES AND FUNCTIONS.

        2.1     ABOMEN . . . . . . . . . . . . . . . . . . . . . . 2-1
        2.2     BROADC . . . . . . . . . . . . . . . . . . . . . . 2-2
        2.3     CANMEN   . . . . . . . . . . . . . . . . . . . . . 2-2
        2.4     CONHEX . . . . . . . . . . . . . . . . . . . . . . 2-2
        2.5     CONINT . . . . . . . . . . . . . . . . . . . . . . 2-3
        2.6     CONREA . . . . . . . . . . . . . . . . . . . . . . 2-3
        2.7     DEFCOL . . . . . . . . . . . . . . . . . . . . . . 2-4
        2.8     DEFSPA . . . . . . . . . . . . . . . . . . . . . . 2-4
        2.9     DISABL . . . . . . . . . . . . . . . . . . . . . . 2-4
        2.10    DMPMSG . . . . . . . . . . . . . . . . . . . . . . 2-5
        2.11    ENDDMP . . . . . . . . . . . . . . . . . . . . . . 2-5
        2.12    ENDSPL . . . . . . . . . . . . . . . . . . . . . . 2-5
        2.13    ENDSTA . . . . . . . . . . . . . . . . . . . . . . 2-6
        2.14    EVEFIL . . . . . . . . . . . . . . . . . . . . . . 2-6
        2.15    EVESAV . . . . . . . . . . . . . . . . . . . . . . 2-6
        2.16    EXIMEN . . . . . . . . . . . . . . . . . . . . . . 2-7
        2.17    FILLST . . . . . . . . . . . . . . . . . . . . . . 2-7
        2.18    FNDFIL . . . . . . . . . . . . . . . . . . . . . . 2-8
        2.19    FULMOD . . . . . . . . . . . . . . . . . . . . . . 2-8
        2.20    GETARR . . . . . . . . . . . . . . . . . . . . . . 2-9
        2.21    GETDEV . . . . . . . . . . . . . . . . . . . . .  2-10
        2.22    GETDIS . . . . . . . . . . . . . . . . . . . . .  2-11
        2.23    GETOPT . . . . . . . . . . . . . . . . . . . . .  2-12
        2.24    GETPAR   . . . . . . . . . . . . . . . . . . . .  2-13
        2.25    GETSCR . . . . . . . . . . . . . . . . . . . . .  2-14
        2.26    GETSPL . . . . . . . . . . . . . . . . . . . . .  2-14
        2.27    GETSTA . . . . . . . . . . . . . . . . . . . . .  2-14
        2.28    GETSYI . . . . . . . . . . . . . . . . . . . . .  2-15
        2.29    GETWTA . . . . . . . . . . . . . . . . . . . . .  2-15
        2.30    GOTOP  . . . . . . . . . . . . . . . . . . . . .  2-15
        2.31    GTUNIT   . . . . . . . . . . . . . . . . . . . .  2-16
        2.32    INPCMD . . . . . . . . . . . . . . . . . . . . .  2-16
        2.33    INPTRM . . . . . . . . . . . . . . . . . . . . .  2-16
        2.34    INTAST . . . . . . . . . . . . . . . . . . . . .  2-17
        2.35    INTMEN . . . . . . . . . . . . . . . . . . . . .  2-17
        2.36    INTMSG . . . . . . . . . . . . . . . . . . . . .  2-18
        2.37    LENINT . . . . . . . . . . . . . . . . . . . . .  2-18
        2.38    LIBREP . . . . . . . . . . . . . . . . . . . . .  2-19
        2.39    LINGET . . . . . . . . . . . . . . . . . . . . .  2-19
        2.40    LSPAWN . . . . . . . . . . . . . . . . . . . . .  2-20
        2.41    MENADD . . . . . . . . . . . . . . . . . . . . .  2-20
        2.42    MENMAI . . . . . . . . . . . . . . . . . . . . .  2-21
        2.43    MENNEW . . . . . . . . . . . . . . . . . . . . .  2-21
        2.44    MENSET . . . . . . . . . . . . . . . . . . . . .  2-21
        2.45    MENUDO . . . . . . . . . . . . . . . . . . . . .  2-22
        2.46    MSGSCR . . . . . . . . . . . . . . . . . . . . .  2-22
        2.47    OUTMSG . . . . . . . . . . . . . . . . . . . . .  2-23
        2.48    OUTSAV   . . . . . . . . . . . . . . . . . . . .  2-23
        2.49    PARSFI . . . . . . . . . . . . . . . . . . . . .  2-24
        2.50    PFGET  . . . . . . . . . . . . . . . . . . . . .  2-24
        2.51    PFLABL . . . . . . . . . . . . . . . . . . . . .  2-25
        2.52    PFNUM  . . . . . . . . . . . . . . . . . . . . .  2-25
        2.53    PFWAIT . . . . . . . . . . . . . . . . . . . . .  2-25
        2.54    READPF . . . . . . . . . . . . . . . . . . . . .  2-26
        2.55    REASAV   . . . . . . . . . . . . . . . . . . . .  2-26
        2.56    RLUNIT . . . . . . . . . . . . . . . . . . . . .  2-27
        2.57    SETCHK . . . . . . . . . . . . . . . . . . . . .  2-27
        2.58    SETCOM . . . . . . . . . . . . . . . . . . . . .  2-28
        2.59    SETDMP . . . . . . . . . . . . . . . . . . . . .  2-28
        2.60    SETFLG   . . . . . . . . . . . . . . . . . . . .  2-29
        2.61    SETLIN   . . . . . . . . . . . . . . . . . . . .  2-29
        2.62    SETMOD . . . . . . . . . . . . . . . . . . . . .  2-30
        2.63    SETQIO . . . . . . . . . . . . . . . . . . . . .  2-30
        2.64    SETSTA . . . . . . . . . . . . . . . . . . . . .  2-31
        2.65    SPAWIT . . . . . . . . . . . . . . . . . . . . .  2-31
        2.66    SPLSTA . . . . . . . . . . . . . . . . . . . . .  2-31
        2.67    SPLTIT . . . . . . . . . . . . . . . . . . . . .  2-32
        2.68    STAMSG . . . . . . . . . . . . . . . . . . . . .  2-32
        2.69    TABDIS . . . . . . . . . . . . . . . . . . . . .  2-33
        2.70    TIMDIS . . . . . . . . . . . . . . . . . . . . .  2-33
        2.71    TRALOG . . . . . . . . . . . . . . . . . . . . .  2-34
        2.72    TRANUP . . . . . . . . . . . . . . . . . . . . .  2-34
        2.73    TRULEN . . . . . . . . . . . . . . . . . . . . .  2-35
        2.74    WAIBIT . . . . . . . . . . . . . . . . . . . . .  2-35
        2.75    WAITIT . . . . . . . . . . . . . . . . . . . . .  2-35


CHAPTER 3       DESCRIPTION OF USER-SUPPLIED ROUTINES.

        3.1     EXIUSR . . . . . . . . . . . . . . . . . . . . . . 3-1
        3.2     USRCHK . . . . . . . . . . . . . . . . . . . . . . 3-1


CHAPTER 4       DESCRIPTION OF QUALIFIER PARSING ROUTINES

        4.1     GCOMND . . . . . . . . . . . . . . . . . . . . . . 4-2
        4.2     GCONFI . . . . . . . . . . . . . . . . . . . . . . 4-2
        4.3     GFULSC . . . . . . . . . . . . . . . . . . . . . . 4-2
        4.4     GINCOM . . . . . . . . . . . . . . . . . . . . . . 4-3
        4.5     GJOURN . . . . . . . . . . . . . . . . . . . . . . 4-3
        4.6     GNOSMG . . . . . . . . . . . . . . . . . . . . . . 4-3
        4.7     GSPLIT . . . . . . . . . . . . . . . . . . . . . . 4-4
        4.8     GSTATU . . . . . . . . . . . . . . . . . . . . . . 4-4
        4.9     GUSERM . . . . . . . . . . . . . . . . . . . . . . 4-4
CHAPTER 5       EXAMPLES

        5.1     Main Program   . . . . . . . . . . . . . . . . . . 5-1
        5.2     Typical Dispatch Type Routine.   . . . . . . . . . 5-3
        5.3     Typical Command Interface Routine  . . . . . . . . 5-4
        5.4     Typical Setup Input File . . . . . . . . . . . . . 5-5
        5.5     Typical Definitions for a Program  . . . . . . . . 5-7
        5.6     Typical VMS-HELP File for a Program  . . . . . . . 5-8












                                 CHAPTER 1

                           GUIDE TO PROGRAMMING



          Following is a description of the method of  building  a  program
        using  this  package,  how to add commands and a description of the
        standard routines and functions used to do I/O in a  selfconsistent
        way.




        1.1   Overview of the Package


          The package consists of the following main parts:

         *  A set of routines used by an application  program  to  do  menu
            manipulations as well as other I/O operations.

         *  A set of routines to perform system type commands which may  be
            included in the program.

         *  A set of library routines called from the above routines to  do
            lower level I/O.

         *  A set of files with menu and help information  to  be  read  in
            when the program starts up.

         *  A menu-driven facility to change the above setup information.


          A program starts up by (possibly) reading  one  or  more  of  the
        setup  files  by  calling  the routine MENSET.  Each call to MENSET
        defines one menu level (the level is identified uniquely by a label
        of up to 32 characters).  The order of the calls to MENSET does not
        matter, the program will use the first call to MENUDO to  find  the
        main  menu  level.  The routine MENMAI may be used to override this
        assignment of main level.  The combination MENNEW  and  MENADD  may
        also be used to define menu levels and add menu items to a level.



                                 1-1
          Inside a command-interpretation loop the routine MENUDO is called
        to get the next command.  If the command-parser determines that the
        command is of a system type, it will  call  a  dispatching  routine
        internally  without  returning  to  the application level.  It will
        only return when it has a command to perform or when EXIT  or  BACK
        is indicated.

          The program will determine what kind of a terminal is being  used
        and  look  at  the  command  line  for qualifiers.  The menu or the
        command prompt line is then presented and commands will be executed
        as  the  user enters them.  Under VMS the standard type-ahead is in
        effect in line mode, as is recalling previously entered commands by
        using the "up-arrow" or "down-arrow" keys.

          To  avoid  problems  with  screen  operations  while  using   the
        debugger, a special qualifier /NOSMG has been implemented.  See the
        USERSGUIDE for information.

          Processing tasks may be performed (under VMS) by  setting  up  an
        Asynchronous   System   Trap   (AST)   structure  for  the  command
        interpretation.  Routines to handle this AST structure are included
        in the package.




        1.2   Main Program


          A typical main program for a new application using  this  package
        consists  of  calls  to  MENSET  or  MENNEW  to set up menu levels,
        possibly calls to MENADD to add menu items and either a call  to  a
        dispatching  type  routine  or  a  dispatching  loop with a call to
        MENUDO for the top level menu.  Other kinds of initialization  etc.
        should be done before the call to the dispatching routine.

          Setup of COMPACK may also be done separately by a call to SETCHK.
        It may be called several times, but will keep track internally such
        that the actual initialization is done only once.  SETCHK  is  also
        useful  in programs which needs some of the COMPACK utilities (like
        GETPAR), but does not need  menus,  and  therefore  does  not  call
        MENSET.   There  is  a  way for the programmer to check for special
        qualifiers on the original command line by adding a special version
        of the USRCHK routine.  See below for details.

          Exit type processing may be done after  the  command  interpreter
        has  indicated  EXIT,  the  dispatching  loop MUST end when EXIT is
        returned as the command string.  The program should always exit  by
        calling  the EXIMEN routine.  Since EXIMEN may be called from other
        places in the program, a  hook  for  exit  processing  is  included
        there.  See EXIUSR below for details.

          The examples at the end of this manual includes  a  typical  main
        program.



                                 1-2
        1.3   The Dispatching Loop.


          The programmer should provide  a  loop,  preferably  in  its  own
        subroutine,  for  getting  the  next command and dispatching to the
        task indicated by the command.  In order to avoid  "cluttering  up"
        this  routine, it should basically be a series of ELSEIF statements
        followed by one call statement to make sure the action routines get
        called.  The utility program MENU_MAKER may be used to make a first
        version of such a dispatch routine.

          See the examples for an exaple of such a routine  generated  with
        MENU_MAKER.




        1.4   System Commands.


          A number of commands are available to do standard operations like
        manipulating indirect command files (set them up, edit them and run
        them), changing attributes of the menu display (split screen,  line
        spacing,  number of columns etc.), automatic spawn of a subprocess,
        adding of VMS commands to a menu and others.   For  now  the  setup
        information  for  any of these commands has to included in the .SET
        file by copying it from an existing file.

          The number of commands in a single menu may become  quite  large.
        To  reduce this number, a standard submenu of the above system type
        commands has been implemented.  You get that menu by just including
        the entry for it in the .SET file for the menu level which needs to
        use it.

          See the examples for how this submenu  is  defined  in  the  .SET
        file.  Notice that it does NOT use the CALL in front of MENCTR even
        though it is really a  system  command.   This  is  to  return  the
        command  as  far  as  possible  before MENCTR is actually called to
        avoid recursive calling of routines.


















                                 1-3
        1.5   Adding a New Command


          Here are step-by-step instructions of how to add a new command to
        a program:

        1.  Write the subroutine that will ultimately be called to  perform
            the  task.   The routines GETPAR, GETDIS, GETARR or GETOPT must
            be used to get parameters for the  command.   GETPAR  gets  the
            parameters  either  from  the  command  line  or  by prompting.
            Prompting is turned off while reading from an indirect  command
            file.   GETDIS  gets  the parameters the user selects to change
            from either a full screen type  display  very  similar  to  the
            normal MENU MODE screen or by the user typing the number of the
            parameter and the new value in the LINE MODE case.  GETOPT lets
            the  user  choose  an  option from a predetermined set for each
            parameter.  In MENU MODE this is done withe  the  'arrow'-keys,
            in  line  mode  by  typing  the number of the parameter and the
            number of chosen option.  .le;Run  the  MENU_MAKER  program  to
            edit  the setup information and possibly produce a new dispatch
            routine.  The dispatching routine may be edited  afterwards  to
            change the action defined for each command.  A VMS command MENU
            should be set up for running this  program.   Notice  that  the
            symbol  in  this  case  points to a command file which uses the
            first parameter as the name of the file to be edited and starts
            the   program  in  full  screen  mode.   Any  standard  COMPACK
            qualifiers (like /NOFULL and /NOSMG) may be added as the second
            parameter  when  running  the  command file.  This program will
            either translate the setup file to a  direct  access  file  (of
            type  .MENU)  which  is read in at the start of the program, or
            writes a FORTRAN subroutine which uses MENADD to enter the menu
            information.   If  such  a  routine  is  made,  the call may be
            automatically included in  the  dispatch  routine  (before  the
            actual dispatch loop).

              MENNEW and MENADD may be used as an alternate way to add  the
            setup information.

        2.  Compile the changed routine(s) and link the  program  including
            the  libraries  needed.  COMPACK is self-contained, it does not
            need any other libraries.
















                                 1-4












                                 CHAPTER 2

                  DESCRIPTION OF ROUTINES AND FUNCTIONS.



          Following are descriptions of the subroutines and functions which
        may be used to do the input of parameters in a standard way as well
        as the subroutines the programmer should call to  communicate  with
        the package and some of the utility routines used in the package.




        2.1   ABOMEN


          Purpose:  Abort  a  program  by  only  reporting  error  (without
                    traceback).

          Calling sequence:  CALL ABOMEN(ISTAT,EXVAR)

          Argument(s):  ISTAT:   Status  to  report  and  take  action  on.
                                (INTEGER)
                        EXVAR:  String to be used to indicate  where  error
                                ocurred.  (CHARACTER)

          Notes:  Only when ISTAT is EVEN will the program actually exit.

                  Normal exit processing is done.















                                 2-1
        2.2   BROADC


          Purpose:  Turn off or on trapping of braodcast messages.

          Calling sequence:  CALL BROADC(ONOFF)

          Argument(s):  ONOFF:  Flag to decide whether  to  turn  broadcast
                                trapping on (ONOFF=.TRUE.) or off.

          Notes:  This routine must be called before a spawn can work.   It
                  is done automatically for LSPAWN and SPAWIT.

                  It may also be useful  to  call  this  routine  when  the
                  non-split  mode  is  important  to  maintain,  since  the
                  trapping of broadcast messages will force a split  screen
                  mode.




        2.3   CANMEN


          Purpose:  Cancel an interrupt mode menu setup.

          Calling sequence:  CALL CANMEN

          Argument(s):  None

          Notes:  Must be called when the  task  issuing  the  INTMEN  call
                  finishes.   It  may  be  called  from inside the dispatch
                  routine for the interrupt menu.




        2.4   CONHEX


          Purpose:  Convert a character string in hexadecimal  form  to  an
                    integer.

          Declaration:    INTEGER*4 CONHEX

          Calling sequence:  I=CONHEX(TXT)   (I is any integer variable)

          Return value:  The integer corresponding to TXT.

          Argument(s):  TXT:   Character string to be converted.

          Notes:  The validity of the string as an hexadecimal integer will
                  be checked, if a character other than digits (0-9,A-F) or
                  signs (+,-) is found, an error message is typed.



                                 2-2
        2.5   CONINT


          Purpose:  Convert a character string to an integer.

          Declaration:    INTEGER*4 CONINT

          Calling sequence:  I=CONINT(TXT)   (I is any integer variable)

          Return value:  The integer corresponding to TXT.

          Argument(s):  TXT:   Character string to be converted.

          Notes:  The validity of the string as an integer will be checked,
                  if  a character other than digits (0-9) or signs (+,-) is
                  found, an error message is typed.




        2.6   CONREA


          Purpose:  Convert a character string to a real number.

          Declaration:    REAL*4 CONREA

          Calling sequence:  X=CONREA(TXT)   (X is any REAL*4 variable)

          Return value:  The real number corresponding to TXT.

          Argument(s):  TXT:   Character string to be converted.

          Notes:  The validity of the string  as  a  real  number  will  be
                  checked,  if  a  character other than digits (0-9), signs
                  (+,-) or decimal point (.) is found, an error message  is
                  typed.  An error is also issued if two decimal points are
                  found.   The  returned  value  in  case   of   error   is
                  -999999.99.


















                                 2-3
        2.7   DEFCOL


          Purpose:  Set number of columns in menu display.

          Calling sequence:  CALL DEFCOL(NUMCOL)

          Argument(s):  NUMCOL: Number of columns to use.

          Notes:  Only 1 or 2 columns work well for a normal screen.   This
                  routine  may be called before a call to INTMEN to set the
                  column number to 1, it will then be easier for  the  user
                  to move around in a short menu.




        2.8   DEFSPA


          Purpose:  Set the line spacing in menu display.

          Calling sequence:  CALL DEFSPA(NUMSPA)

          Argument(s):  NUMSPA: Spacing of menu lines.

          Notes:  Only 1, 2 or 3 (single, double and  triple  spacing)  are
                  currently allowed.

                  This routine may be called before a call to SPLTIT to set
                  the  spacing to 1, it will then be easier for the user to
                  move around in a short menu.




        2.9   DISABL


          Purpose:  Disable unsolicited input from terminal.

          Calling sequence:  CALL DISABL

          Argument(s):  None

          Notes:  Should ONLY be called if  you  have  to  call  LSPAWN  or
                  SPAWIT  to  perform a special VMS command from within the
                  interrupt menu part of a program.  LSPAWN and SPAWIT will
                  NOT work unless unsolicited input has been disabled.  Use
                  SETQIO to re-enable unsolicited input after the  call  to
                  LSPAWN or SPAWIT.






                                 2-4
        2.10   DMPMSG


          Purpose:  Write a line to a dump file.

          Calling sequence:  CALL DMPMSG(IUNI,LINOUT)

          Argument(s):  IUNI:   Unit number to dump to.  (INTEGER)
                        LINOUT: Line to write out.  (CHARACTER)

          Notes:  See SETDMP for how to open IUNI.




        2.11   ENDDMP


          Purpose:  End dumping to file.

          Calling sequence:  CALL ENDDMP(IUNI)

          Argument(s):  IUNI:   Unit having been used for dump.

          Notes:  If IUNI=6, EVESAV will be called to edit the dump file.

                  See SETDMP for how to start such a dump, and  DMPMSG  for
                  how to write to it.




        2.12   ENDSPL


          Purpose:  Go back to single display mode.

          Calling sequence:  CALL ENDSPL

          Argument(s):  None

          Notes:  Use SPLTIT to set up split screen mode.

                  Single Screen is also available as a system command.













                                 2-5
        2.13   ENDSTA


          Purpose:  Take away status display on top of screen.

          Calling sequence:  CALL ENDSTA

          Argument(s):  None

          Notes:  Use SPLSTA to set up status display.




        2.14   EVEFIL


          Purpose:  Edit a file from inside a program.

          Calling sequence:  CALL EVEFIL(FILNAM)

          Argument(s):  FILNAM: Name of file to edit.  (CHARACTER)

          Notes:  Currently this is a VAX specific routine, calling the TPU
                  editor  internally.   The standard EVE+ interface will be
                  used if the section file is defined properly.




        2.15   EVESAV


          Purpose:  Edit information written to unit 6 while in SAVE mode.

          Calling sequence:  CALL EVESAV

          Argument(s):  None.

          Notes:  Calls EVEFIL internally.

                  See OUTSAV for how to start saving output.















                                 2-6
        2.16   EXIMEN


          Purpose:  Exit from program with screen restored to "normal".

          Calling sequence:  CALL EXIMEN(STATUS,LEVEL)

          Argument(s):  STATUS: An integer VAX status message.
                        LEVEL:  Integer to indicate which  menu  level  the
                                call was issued from.

          Notes:  STATUS=1 indicates normal exit.
                  Use LEVEL=1 to indicate the top level menu.

                  A call to the routine EXIUSR is made inside this routine.
                  Replace  the  dummy  one  supplied  with a special one if
                  clean-up, timing print-out etc.  is needed.




        2.17   FILLST


          Purpose:   Return  a  list  of  files  satisfying  a  given  name
                    criterion.

          Calling sequence:  CALL FILLST(FILTYP,MAXITM,MAXFIL,ITEMS)

          Argument(s):  FILTYP: String  giving  the   filename   criterion.
                                (CHARACTER)
                        MAXITM: Maximum  number  of  files  to  look   for.
                                (INTEGER)
                        MAXFILS: Number of files actually found.  (INTEGER)
                        ITEMS:  Array of character  strings  returning  the
                                file names.

          Notes:  ITEMS must be declared with at least MAXITM elements.

                  Use TABDIS to display this list  if  needed  or  possibly
                  GETOPT to select from the set.  See also FNDFIL below for
                  how to select from such a list.















                                 2-7
        2.18   FNDFIL


          Purpose:  Present  a  list  of  files  satisfying  a  given  name
                    criterion and let the user choose a file from the list.

          Calling sequence:  CALL FNDFIL(POSI,MAXITM,FILTYP,TOPS,ITEMS)

          Argument(s):  POSI:   Number of the file within  the  list  which
                                was chosen.  (INTEGER)
                        MAXITM: Maximum  number  of  files  to  look   for.
                                (INTEGER)
                        FILTYP: Character  string   giving   the   filename
                                criterion.
                        TOPS:   Character string giving the title line  for
                                the display.
                        ITEMS:  Array of character  strings  returning  the
                                file names.

          Notes:  ITEMS must be declared with at least MAXITM elements.  If
                  POSI.eq.0  on  return,  no  choice  was  entered  and the
                  function  PFNUM  should  be  used  to  determine  further
                  action.  Only PNUM().EQ.2 or PFNUM().EQ.3 should be acted
                  upon, one with HELP and the other  with  a  list  of  the
                  files.

                  Calls FILLST internally to get the actual list of files.




        2.19   FULMOD


          Purpose:  Access the variable FULSCR without including the common
                    blocks.

          Declaration:    LOGICAL FULMOD

          Calling sequence:  L=FULMOD()

          Return value:  The current value of FULSCR.

          Notes:  Should be used if special action like calling  PFLABL  is
                  needed  when the system is in full screen mode (FULSCR is
                  true).











                                 2-8
        2.20   GETARR


          Purpose:  Get parameters for a command selectively from a  screen
                    display using an array for returning the parameters.

          Calling sequence:
                CALL GETARR(NUMPAR,LABELS,TYPARR,LIMITS,PARAM)

          Argument(s):  NUMPAR: Number of parameters needed.  (INTEGER)
                        LABELS: Array of label strings
                                (using NUMPAR elements).
                        TYPARR: Array of CHARACTER*1 type identifiers.
                        LIMITS: Array of limits for variables.
                                (INTEGER (2,NUMPAR))
                        PARAM: The parameters to be returned (array  of  at
                                least NUMPAR elements).

          Notes:  The valid types are:  'R' for real.
                                        'I' for integer.
                                        'L' for logical.

                  The  LIMITS  array  MUST  be  present,  and   should   be
                  equivaleneced to a REAL array if limit checking is needed
                  for type 'R'.  Only when lower limit  is  different  from
                  upper limit is the range checked.  A message is issued if
                  the parameter entered is outside the limits.

                  Validity of the entered values is checked for  types  'I'
                  and  'R',  and  a  message issued if a "bad" character is
                  found.

                  See GETDIS for a way to get  individual  parameters  from
                  such  a  screen display, it is also able to get CHARACTER
                  parameters.






















                                 2-9
        2.21   GETDEV


          Purpose:  Get the device type of the user's terminal from VMS.

          Declaration:    LOGICAL*1 GETDEV

          Calling sequence:  L=GETDEV()    (L is any logical variable)

          Return value:   .TRUE.  if a VT100-series or a VT200-series
                          terminal is found, .FALSE.  otherwise.

          Argument(s):  None

          Notes:  The device type is as defined by SET  TERMINAL/DEVICE  or
                  equivalent.

                  A VAXstation with a VT200 window will also return .TRUE.







































                                 2-10
        2.22   GETDIS


          Purpose:  Get parameters for a  command  by  selectively  from  a
                    screen display.

          Calling sequence:
                CALL GETDIS(NUMPAR,LABELS,TYPARR,LIMITS,PAR1,PAR2...PARN)

          Argument(s):  NUMPAR: Number of parameters needed.  (INTEGER)
                        LABELS: Array of label strings
                                (using NUMPAR elements).
                        TYPARR: Array of CHARACTER*1 type identifiers.
                        LIMITS: Array of limits for variables.
                                (INTEGER (2,NUMPAR))
                        PAR1...PARN: The   individual   parameters    (must
                                specify NUMPAR of them).

          Notes:  The valid types are:  'R' for REAL.
                                        'I' for INTEGER.
                                        'L' for LOGICAL.
                                        'C' for CHARACTER variable.
                                        'U'   for   upper-case    CHARACTER
                  variable.

                  The  LIMITS  array  MUST  be  present,  and   should   be
                  equivaleneced to a REAL array if limit checking is needed
                  for type 'R'.  Only when lower limit  is  different  from
                  upper limit is the range checked.  A message is issued if
                  the parameter entered is outside the limits.

                  Character variables are handled correctly  internally  in
                  this routine.

                  Currently 30 parameters are possible.

                  Validity of the entered values is checked for  types  'I'
                  and  'R',  and  a  message issued if a "bad" character is
                  found.

                  See GETARR for an alternate way to get parameters in this
                  way but by using an array for returning the parameters.















                                 2-11
        2.23   GETOPT


          Purpose:  Get parameters for a command from a screen  display  of
                    predefined options.

          Calling sequence:
                CALL GETOPT(NUMPAR,LABELS,OPTNUM,OPTION,OUTNUM)

          Argument(s):  NUMPAR: Number of parameters needed.  (INTEGER)
                        LABELS: Array of label strings
                                (using NUMPAR elements).
                        OPTNUM: Array with the number of options
                                for each parameter.  (INTEGER (NUMPAR))
                        OPTION: Two  dimensional  array   of   the   actual
                                options.
                                (CHARACTER(MAX(OPTNUM's),NUMPAR))
                        OUTNUM: Array with the number of the chosen option
                                for each parameter.  (INTEGER (NUMPAR))

          Notes:  When NUMPAR=1 the display in full screen mode will behave
                  very much like a normal menu display.

                  When NUMPAR>1, the number of options  (OPTNUM)  for  each
                  parameter  should be relatively small to make the display
                  readable.































                                 2-12
        2.24   GETPAR


          Purpose:  Get parameters for a command, doing all the checks etc.
                    needed.

          Calling sequence:
                  CALL GETPAR(NUMPAR,PROMPT,TYPARR,PAR1,PAR2...PARN)

          Argument(s):  NUMPAR: Number of parameters needed.  (INTEGER)
                        PROMPT: Array  of  prompt  strings  (using   NUMPAR
                                elements).
                        TYPARR: Array of 1 character type identifiers.
                        PAR1...PARN: The   individual   parameters    (must
                                specify NUMPAR of them).

          Notes:  The valid types are:  'R' for REAL.
                                        'I' for INTEGER.
                                        'H' for hexidecimal INTEGER.
                                        'L' for LOGICAL.
                                        'C' for CHARACTER variable.
                                        'U' for upper-case CHARACTER.
                                        'A' for rest of the line.

                  Currently only 10 parameters are possible.   If  more  is
                  needed, one should use GETDIS instead.

                  Character variables are handled correctly  internally  in
                  this routine.

                  Type 'U'  uses  the  function  TRANUP  to  translate  the
                  entered string to uppercase before returning.

                  Validity of the entered values is checked for types 'I' ,
                  'H' and 'R', and prompt issued again if a "bad" character
                  is found.

                  GETPAR may be called  more  than  once  within  the  same
                  command  action routine.  This is accomplished by using a
                  NEGATIVE number in NUMPAR for the second and later calls.
                  The  internal  counter  is then not reset, and a complete
                  command typed in line mode will be parsed correctly.

                  When a <CR> is struck, the current value of  a  parameter
                  is  kept  as  the default.  This is only true for numeric
                  parameters  ('I','H','R','L'),  GETPAR  does   NOT   move
                  anything into the parameters in this case.










                                 2-13
        2.25   GETSCR


          Purpose:  Get the number of rows and columns in display.

          Calling sequence:  CALL GETSCR(ROWS,COLUMS)

          Argument(s):  ROWS:   Number of rows in display.  (INTEGER)
                        COLUMS: Number of columns in display.  (INTEGER)

          Notes:  This routine is useful before a call to SETLIN to  decide
                  how to split the screen.




        2.26   GETSPL


          Purpose:  Access the flag SPLFLG  without  including  the  common
                    blocks.

          Declaration:    LOGICAL GETSPL

          Calling sequence:  L=GETSPL()

          Return value:  The current value of SPLFLG.

          Notes:  Should be used if  special  action  is  needed  when  the
                  system is in split screen mode (SPLFLG is .TRUE.).




        2.27   GETSTA


          Purpose:  Access the flag STAFLG  without  including  the  common
                    blocks.

          Declaration:    LOGICAL GETSTA

          Calling sequence:  L=GETSTA()

          Return value:  The current value of STAFLG.

          Notes:  Should be used if  special  action  is  needed  when  the
                  system has a status area (STAFLG is .TRUE.).









                                 2-14
        2.28   GETSYI


          Purpose:  Get system information.

          Calling sequence:  CALL GETSYI(NODNAM,HWTYPE,AREA,NODNUM,VMSVER)

          Argument(s):  NODNAM: Name  of  DECNET  node.   (CHARACTER*15  at
                                least)
                        HWTYPE: CPU type.  (CHARACTER*4)
                        AREA:   DECNET area.  (INTEGER)
                        NODNUM: DECNET node number.  (INTEGER)
                        VMSVER: Version of VMS being run.  (CHARACTER*8)

          Notes:  This is a very VAX specific routine, calling  the  GETSYI
                  system service internally.




        2.29   GETWTA


          Purpose:  Find if program is being run on a VAXstation.

          Declaration:    LOGICAL GETWTA

          Calling sequence:  L=GETWTA()

          Return value:  TRUE if running on a VAXstation in VT200 mode.

          Notes:  VAX specific routine using the fact that the device  name
                  for a VAXstation window in VT200 mode starts with WTA.




        2.30   GOTOP


          Purpose:  Check a flag indicating direct jump to the top menu.

          Declaration:    LOGICAL GOTOP

          Calling sequence:  L=GOTOP()

          Notes:  ALL routines doing dispatching tasks at lower menu levels
                  MUST  check  this  flag if a "Go to Top Level" command is
                  implemented.








                                 2-15
        2.31   GTUNIT


          Purpose:  Get a FORTRAN unit number for use without conflict.

          Calling sequence:  CALL GTUNIT(IUSER,IUNIT,IERR)

          Argument(s):  IUSER:  User id of the calling  routine.   Used  to
                                resolve conflicts.  (INTEGER)
                        IUNIT:  Next available unit number.
                        IERR:   Error code (0 if OK) (INTEGER)

          Notes:  ALL routines doing FORTRAN I/O should use this routine to
                  get  the  next  available  unit number to use.  This will
                  avoid conflicts when routines  from  different  libraries
                  are included in the same program.




        2.32   INPCMD


          Purpose:  Change input source to be  an  already  opened  command
                    file.

          Calling sequence:  CALL INPCMD()

          Notes:  To be used when you need to toggle between getting  input
                  from  terminal  and  command file.  If no command file is
                  active  then  current  input  source  is   not   changed.
                  Repeated calls are screened out.




        2.33   INPTRM


          Purpose:  Change input source to be the terminal.

          Calling sequence:  CALL INPTRM()

          Notes:  To be used when you need to toggle between getting  input
                  from  terminal  and  command  file.   Repeated  calls are
                  screened out.











                                 2-16
        2.34   INTAST


          Purpose:  Check a flag  indicating  that  an  interrupt  menu  is
                    active.

          Declaration:    LOGICAL INTAST

          Calling sequence:  L=INTAST()

          Notes:  To be used when you need to know that the interrupt  menu
                  is active to take special action.
                  The flag is .FALSE.  when the program is in a submenu  of
                  the  interrupt  menu  (the  main  task  is paused at that
                  point).




        2.35   INTMEN


          Purpose:  Set up a menu for interrupt mode menu interactions.

          Calling sequence:  CALL INTMEN(TOPS,USENAM,DISPAT)

          Argument(s):  TOPS:   Character string containing the title  line
                                for the main menu.
                        USENAM: Character string corresponding  to  one  of
                                the names used in a call to MENSET.
                        DISPAT: Name  of  dispatching  routine   for   this
                                menu-level.

          Notes:  The DISPAT routine here must NOT have a loop in it,  just
                  dispatch  to the single command which appears as the only
                  argument to this routine.

                  An input request is issued to the terminal and control is
                  returned  to  the  calling  routine.   When  anything  is
                  entered on the keyboard, the main  task  is  interrupted,
                  the action indicated by the key(s) are taken, after which
                  the main task continues from where it was interrupted.















                                 2-17
        2.36   INTMSG


          Purpose:  Output messages to the top half of a split screen.

          Calling sequence:  CALL INTMSG(STRING)

          Argument(s):  STRING: Character string containing the message  to
                                be written to the screen.

          Notes:  The first  character  in  STRING  is  used  for  carriage
                  control.

                  If split screen has been set up either directly or by use
                  of  the  ENTER  key,  these  messages  will appear in the
                  special display on the top half  of  the  screen.   These
                  messages  are saved and output again if the split display
                  is removed and then restored again.  If split screen  has
                  NOT  been  established,  this  routine works identical to
                  OUTMSG.




        2.37   LENINT


          Purpose:  Find number of characters needed to print an integer.

          Declaration:    INTEGER LENINT

          Calling sequence:  I=LENINT(INT)

          Return value:  The number of characters needed to print integer.

          Argument(s):  INT:  Integer to find length of.

          Notes:  Meant to be used in FORMAT statments  to  print  integers
                  exactly filling the space wanted.  In VAX-FORTRAN one may
                  use <INTEGER-expression> anywhere a number of digits etc.
                  is  allowed  in a FORMAT statement.  This is particularly
                  useful in writing default or current values into a prompt
                  string before passing it to GETPAR.














                                 2-18
        2.38   LIBREP


          Purpose:  Refresh the screen if NON-SMG output has been used.

          Declaration:    INTEGER LIBREP

          Calling sequence:  I=LIBREP()

          Return value:  The return status of an SMG routine.

          Notes:  Should be used if the  programmer  suspect  that  NON-SMG
                  output  may  have over-written the screen.  A return of 1
                  means success.




        2.39   LINGET


          Purpose:  Get what is written to a line in the display.

          Declaration:    INTEGER LINGET

          Calling sequence:  I=LINGET(LINNUM,OUTSTR)

          Return value:  The return status of the SMG routine used.

          Argument(s):  LINNUM: The  line  to  get  the  information  from.
                                (INTEGER)
                        OUTSTR: String corresponding to the LINNUM line  in
                                the display.

          Notes:  VAX specific routine, use FULMOD  to  check  if  in  full
                  screen mode before using this function.

                  This function is useful if the content of a line needs to
                  be saved such that it can easily be restored later.


















                                 2-19
        2.40   LSPAWN


          Purpose:  Spawn subprocess to perform operating system command.

          Declaration:    INTEGER LSPAWN

          Calling sequence:  I=LSPAWN(CMDLIN,INFILE)

          Return value:  The return status of the spawn process.

          Argument(s):  CMDLIN: Character string containing the command  to
                                be performed in subprocess.
                        INFILE: Character string corresponding to the  file
                                used   for   input   of   commands  to  the
                                subprocess.

          Notes:  If CMDLIN is empty, commands will be read from INFILE.
                  If both CMDLIN and INFILE are empty strings,  the  user's
                  terminal will be used for input.
                  See SPAWIT for a similar spawn with the output saved  for
                  display via INTMSG.




        2.41   MENADD


          Purpose:  Add setup information for one item.

          Calling                                           sequence:  CALL
        MENADD(MENNAM,NOTITL,ITMNAM,ACTION,HLPTXT)

          Argument(s):  MENNAM: Character string containing the name of the
                                menu level.
                        NOTITL: Flag indicating whether main  title  should
                                be displayed or not.  (LOGICAL)
                        ITMNAM: Name of item for menu display.  (CHARACTER)
                        ACTION: Action name which is returned when  command
                                is to be executed.  (CHARACTER)
                        HLPTXT: Help information for the item.  (CHARACTER)

          Notes:  The  MENNAM  argument  must  correspond  to   a   defined
                  menulevel.  (See MENNEW below.)

                  To make a new paragraph in the help information, use  two
                  'blank' spaces after the period of the previous sentence.









                                 2-20
        2.42   MENMAI


          Purpose:  Set up main menu level.

          Calling sequence:  CALL MENMAI(MENNAM)

          Argument(s):  MENNAM: Character  string  containing  the  logical
                                name of the file of setup information to be
                                read in.

          Notes:  The MENNAM must have been used in a  call  to  MENSET  or
                  MENNEW, the program will exit otherwise.





        2.43   MENNEW


          Purpose:  Define a new menu level.

          Calling sequence:  CALL MENNEW(MENNAM)

          Argument(s):  MENNAM: String containing  the  name  of  the  menu
                                level.  (CHARACTER)

          Notes:  The MENNAM argument must be unique, a fatal error will be
                  issued if the name already exists.




        2.44   MENSET


          Purpose:  Read in a setup information file and create a new  menu
                    level.

          Calling sequence:  CALL MENSET(MENNAM)

          Argument(s):  MENNAM: Character  string  containing  the  logical
                                name of the file of setup information to be
                                read in.

          Notes:  The MENNAM must be a logical name for a  file.   This  is
                  both because the name is used internally as an identifier
                  of the menu level and because  it  is  then  possible  to
                  change  the  real  file  without recompiling the program.
                  This is also very important for offline  programs  to  be
                  used on machines other than a VAX.

                  For offline programs the length of this string should  be
                  8 characters or less.


                                 2-21
                  The order of the calls to MENSET  does  NOT  matter,  the
                  first  call to MENUDO will determine the main menu level.
                  MENMAI may also be used to set the main menu level.

                  The MENNAM argument must be unique, a fatal error will be
                  issued if the name already exists.




        2.45   MENUDO


          Purpose:  Get the next command at a given menu level.

          Calling sequence:  CALL MENUDO(TOPS,USENAM,COMOUT)

          Argument(s):  TOPS: Character string containing  the  title  line
                                for the main menu.
                        USENAM: Character string corresponding  to  one  of
                                the names used in a call to MENSET.
                        COMOUT: Character variable  for  returning  command
                                string.

          Notes:  COMOUT is set to 'BLANK' on entry and is changed  to  the
                  unique  command  identifer from the setup file if it does
                  NOT have a 'CALL' in it or to 'EXIT' if exit or BACK  was
                  entered as the command.

                  If TOPS is given as ' ' (one space), the system will  use
                  the  command  line  which  gave  rise to this menu as the
                  title.  The program name will also be added to the  right
                  side of the title.




        2.46   MSGSCR


          Purpose:  Interpret a VAX status message and  output  it  on  the
                    screen.

          Calling sequence:  CALL MSGSCR(STATUS,STRING)

          Argument(s):  STATUS: Integer VAX status message.
                        STRING: Character string containing a SHORT message
                                to be written to the screen in front of the
                                actual VAX message.

          Notes:  STATUS is normally returned from a VAX System Service  or
                  Run Time Library function call.





                                 2-22
        2.47   OUTMSG


          Purpose:  Output messages to the screen in an orderly fashion.

          Calling sequence:  CALL OUTMSG(STRING)

          Argument(s):  STRING: Character string containing the message  to
                                be written to the screen.

          Notes:  The first  character  in  STRING  is  used  for  carriage
                  control.   In  MENU  MODE  the  display  will stay in the
                  middle part of the screen and scroll  if  more  than  the
                  number  of  lines  which  will fit on the screen are used
                  (screen erased when going back to menu).   The  scrolling
                  part  of  the  screen  may be cleared by using '1' as the
                  first character in STRING.  A '$' works correctly as used
                  in  connection  with  a  prompt,  but  not  always like a
                  FORTRAN write.




        2.48   OUTSAV


          Purpose:  Save all output to FORTRAN unit 6 in a temporary file.

          Calling sequence:  CALL OUTSAV

          Argument(s):  None

          Notes:  The use of FORTRAN unit 6 (SYS$OUTPUT) in WRITE or  PRINT
                  statements  is  STRONGLY  discouraged.   But if a program
                  uses library routines which write to unit 6, this routine
                  may be used to avoid strange screen behaviour.  It should
                  be called BEFORE any use of unit 6 is expected, and  then
                  the  routine  REASAV should be called to display the text
                  on the screen AFTER the use of unit  6  has  ended.   See
                  also EVESAV on how to edit this information.

















                                 2-23
        2.49   PARSFI


          Purpose:  Get a complete file description for a VAX/VMS file.

          Declaration:    INTEGER PARSFI

          Calling sequence:  I=PARSFI(FILSPC,NODSPC,NODLEN,DEVSPC,DEVLEN,
                           *    DIRSPC,DIRLEN,NAMSPC,NAMLEN,TYPSPC,TYPLEN)

          Return value:  The status return of the $PARSE system service.

          Argument(s):  FILSPC:  File   specification   to   be   expanded.
                                (CHARACTER)
                        NODSPC: Node name.  (CHARACTER)
                        NODLEN: Length of node name.  (INTEGER)
                        DEVSPC: Device name.  (CHARACTER)
                        DEVLEN: Length of device name.  (INTEGER)
                        DIRSPC: Directory name.  (CHARACTER)
                        DIRLEN: Length of directory name.  (INTEGER)
                        NAMSPC: File name.  (CHARACTER)
                        NAMLEN: Length of file name.  (INTEGER)
                        TYPSPC: File type.  (CHARACTER)
                        TYPLEN: Length of file type.  (INTEGER)

          Notes:  Useful when the full file specification is needed in  the
                  program.  The call to $PARSE is complicated from FORTRAN.
                  This is a very VAX-specific routine, use it with caution.
                  It will just return 0 on other machines.




        2.50   PFGET


          Purpose:  Get current PF-labels.

          Calling sequence:  CALL PFGET(LABELS)

          Argument(s):  LABELS: Current labels.  (CHARACTER array (4))

          Notes:  This routine is useful before a call to PFLABL to be able
                  to restore the old labels at a later time.













                                 2-24
        2.51   PFLABL


          Purpose:  Output labels for the 4 PF keys on bottom of screen.

          Calling sequence:  CALL PFLABL(PFL1,PFL2,PFL3,PFL4)

          Argument(s):  PFL1-4: Character strings containing the labels for
                                each of the four PF keys.

          Notes:  The labels are output on the bottom line of the screen.
                  Use this routine in connection with READPF if you want  a
                  special use of the PF keys.




        2.52   PFNUM


          Purpose:  Check if a PF-key was entered.

          Declaration:    INTEGER PFNUM

          Calling sequence:  I=PFNUM()

          Return value:  The number of the PF-key if any, 0 otherwise.

          Notes:  Should be used after a call to GETPAR to see if a PF  key
                  was struck while a list of parameters were being prompted
                  for.  Actions should NOT be taken if  PFNUM().NE.0  since
                  not all parameters will be available then.




        2.53   PFWAIT


          Purpose:  Wait for a PF key to be struck in full screen mode.

          Calling sequence:  CALL PFWAIT

          Argument(s):  None

          Notes:  This routine should be used in all action routines  which
                  may have produced output the user have to read before the
                  menu is redisplayed.  In line  mode  this  routines  does
                  nothing.








                                 2-25
        2.54   READPF


          Purpose:  Read keyboard input and check for any PF key entered.

          Declaration:    INTEGER*4 READPF

          Calling sequence:  I=READPF()

          Return value:  The number of the PF key struck.

          Argument(s):  None

          Notes:  Only returns when a PF key is struck.




        2.55   REASAV


          Purpose:  Display output which has  been  saved  in  a  temporary
                    file.

          Calling sequence:  CALL REASAV

          Argument(s):  None

          Notes:  The use of FORTRAN unit 6 (SYS$OUTPUT) in WRITE or  PRINT
                  statements  are  STRONGLY  discouraged.  But if a program
                  uses library routines  which  use  unit  6,  the  routine
                  OUTSAV  may  be  used to open unit 6 as a temporary file.
                  This routine closes unit 6 and reads in,  line  by  line,
                  what  has  been  written to it.  It displays each line on
                  the screen using INTMSG.






















                                 2-26
        2.56   RLUNIT


          Purpose:  Release a FORTRAN unit number gotten from GTUNIT.

          Calling sequence:  CALL RLUNIT(IUSER,IUNIT,IERR)

          Argument(s):  IUSER:  User id of the calling  routine.   Must  be
                                the  same  as  the  one who reserved IUNIT.
                                (INTEGER)
                        IUNIT:  Next available unit number.
                        IERR:   Error code (0 if OK) (INTEGER)

          Notes:  This is a companion routine to GTUNIT.

                  ALL routines doing FORTRAN I/O should use GTUNIT  to  get
                  the  next  available unit number to use.  This will avoid
                  conflicts when  routines  from  different  libraries  are
                  included in the same program.




        2.57   SETCHK


          Purpose:  Initialization routine for all of COMPACK.

          Calling sequence:  CALL SETCHK

          Argument(s):  None

          Notes:  This routine is called internally  at  the  time  of  the
                  first call to MENSET or MENNEW (also used when menu setup
                  is done from routine made by the MENU_MAKER program).  If
                  the  initialization has already been done, it will not be
                  done again.

                  This routine should be called explicitly if a call  to  a
                  COMPACK  routine (like GETPAR) is needed before the first
                  call to MENSET, or in a program which does not need menus
                  and therefore does not call MENSET.















                                 2-27
        2.58   SETCOM


          Purpose:  Initialization routine for all of COMPACK.

          Calling sequence:  CALL SETCOM

          Argument(s):  None

          Notes:  This  routine  is  an  alternate   way   of   doing   the
                  initialization  without  parsing  any commmand qualifiers
                  etc.   entered  on  the  original  command  lined.    Any
                  subsequent calls to SETCHK will also be ignored.

                  This routine should be used if the program does  its  own
                  parsing  for qualifiers etc.  A set of interface routines
                  for standard COMPACK qualifiers is available, see CHAPTER
                  4 for details.

                  It may also be used in  a  very  simple  program  without
                  menus  etc.  which needs some COMPACK routines for screen
                  based I/O.




        2.59   SETDMP


          Purpose:  Set up dumping output to a file.

          Calling sequence:  CALL SETDMP(IUNI,FILNAM)

          Argument(s):  IUNI:   Unit to dump to.
                        FILNAM: Name of file to to dump to.  (CHARACTER)

          Notes:  Use GTUNIT to get IUNI when not using unit 6.

                  When IUNI=6 the special dump initiated by OUTSAV is used,
                  and FILNAM is not used (must be in call).

                  See DMPMSG for how to actually write to  this  file,  and
                  ENDDMP for how to stop such a dump.














                                 2-28
        2.60   SETFLG


          Purpose:  Tell the system NOT to display menu after a command.

          Calling sequence:  CALL SETFLG

          Argument(s):  None

          Notes:  The flag stays active for  only  ONE  call  to  the  menu
                  display routine.

                  This routine should be used in all action routines called
                  from  an  interrupt  dispatch  routine when the interrupt
                  menu will be terminated as soon as  the  main  code  gets
                  control  again.   This  prevents  the interrupt menu from
                  flashing on the screen for a  brief  moment  just  to  be
                  taken  away  by a call to CANMEN shortly afterwards.  See
                  the example in TYPEND as used in TYPROG.  It may also  be
                  used  in  action  routines  called from in interrupt mode
                  when you do not want the menu to appear immendiately.   A
                  label  line  will  appear to tell the user how to get the
                  menu back.




        2.61   SETLIN


          Purpose:  Set number of lines to be used in split screen mode.

          Calling sequence:  CALL SETLIN(NUMLIN)

          Argument(s):  NUMLIN: Number of lines INCLUDING border to be used
                                for the split screen.

          Notes:  Because of the border, 3  lines  is  the  minimum  useful
                  number of lines to ask for.


















                                 2-29
        2.62   SETMOD


          Purpose:  Access a flag indicating SETUP MODE.

          Declaration:    LOGICAL SETMOD

          Calling sequence:  L=SETMOD()

          Return value:  .TRUE.  if in SETUP MODE.

          Notes:  Should be used after a call to GETPAR to see  if  in  the
                  program is setting up a command file.  Actions should NOT
                  be taken when in this mode.  The entered parameters  have
                  already been written to the command file.

                  See PFNUM as well.




        2.63   SETQIO


          Purpose:  Enable unsolicited input from keyboard.

          Calling sequence:  CALL SETQIO(DSPNAM)

          Argument(s):  DSPNAM: Dispatch routine name.  (EXTERNAL)

          Notes:  The routine DSPNAM has to be  declared  EXTERNAL  in  the
                  calling routine.
                  The calling sequence for DSPNAM is:   CALL DSPNAM(COMAND)
                  where  COMAND  is  the unique command identifier from the
                  .SET file.  It should perform the task  of  that  command
                  and nothing else.
                  Use this call  explicitely  ONLY  if  DISABL  has  to  be
                  called.



















                                 2-30
        2.64   SETSTA


          Purpose:  Set number of lines to be used in status display.

          Calling sequence:  CALL SETSTA(NUMLIN)

          Argument(s):  NUMLIN: Number of lines INCLUDING border to be used
                                for the status display.

          Notes:  Because of the border, 3  lines  is  the  minimum  useful
                  number  of lines to ask for.  5 is currently the maximum.
                  Only important status messages should be put on this part
                  anyway.




        2.65   SPAWIT


          Purpose:  Spawn subprocess to perform a single  operating  system
                    command, with output saved and displayed via INTMSG.

          Declaration:    INTEGER SPAWIT

          Calling sequence:  I=SPAWIT(CMDLIN)

          Return value:  The return status of the spawn process.

          Argument(s):  CMDLIN: Character string containing the command  to
                                be performed in subprocess.

          Notes:  If CMDLIN is empty, commands will be read from  the  user
                  terminal.
                  See LSPAWN for a similar spawn with the output NOT saved.




        2.66   SPLSTA


          Purpose:  Set up status display mode.

          Calling sequence:  CALL SPLSTA

          Argument(s):  None

          Notes:  The routine SETSTA may be called before the call to  this
                  routine  to  set  up  the  number  of lines in the status
                  display.

                  Use STAMSG to output messages to this display.



                                 2-31
                  Use ENDSTA or Kypad 0 to take  away  the  status  display
                  again.

                  Status Screen is also available as a system command.




        2.67   SPLTIT


          Purpose:  Set up split screen mode.

          Calling sequence:  CALL SPLTIT

          Argument(s):  None

          Notes:  The routine SETLIN may be called before the call to  this
                  routine  to  set  up  the  number of lines in the message
                  display.

                  Use INTMSG to output messages to this part of the screen.

                  Use ENDSPL or ENTER key to go back to  a  single  display
                  again.

                  Split Screen is also available as a system command.




        2.68   STAMSG


          Purpose:  Output messages to the status area on top of screen.

          Calling sequence:  CALL STAMSG(STRING)

          Argument(s):  STRING: Character string containing the message  to
                                be written to the screen.

          Notes:  The first  character  in  STRING  is  used  for  carriage
                  control.   In  particular use a '+' to overwrite the last
                  message on the bottom of the  display  if  the  top  line
                  should be left intact.

                  If status screen has been set up either  directly  or  by
                  use  of  the  Keypad 0 key, these messages will appear in
                  the special display on the top half of the screen.  These
                  messages are saved and output again if the status display
                  is removed and then restored again.  If status screen has
                  NOT  been  established,  this  routine works identical to
                  INTMSG.




                                 2-32
        2.69   TABDIS


          Purpose:  Display an array of integers or reals on screen.

          Calling sequence:
                CALL TABDIS(ARRAY,NUMENT,NUMSPA,NMBCOL,TYPE,LABEL,FMTSTR)

          Argument(s):  ARRAY:  Array to be displayed.  (INTEGER or REAL)
                        NUMENT: Number of elements to display.  (INTEGER)
                        NUMSPA: Vertical   spacing   of   display   (1..n).
                                (INTEGER)
                        NMBCOL: Number  of  columns  in   display   (1..n).
                                (INTEGER)
                        TYPE:   Type of array ('I' or 'R').
                        LABEL:  Label for top of display.
                        FMTSTR: FORTRAN format descriptor for each  element
                                (ex:  'I10').

          Notes:  The valid types are:  'R' for real.
                                        'I' for integer.
                                        'C' for character.

                  The FMTSTR and NMBCOL variables MUST be chosen such  that
                  the line doesn't become wider than the screen (usually 78
                  characters available).

                  For type 'C', the FMTSTR should be 'A' and NMBCOL usually
                  1.




        2.70   TIMDIS


          Purpose:  Redo a specific display (or  other  operation)  with  a
                    specified time interval.

          Calling sequence:   CALL TIMDIS(DISPIT,TIMDEF)

          Argument(s):  DISPIT:  Name of routine to be called
                                at the end of each interval.  (EXTERNAL)
                        TIMDEF: Default time interval in
                                'DD HH:MM:SEC.HUND' format.

          Notes:  This is a VAX specific routine and should only be used in
                  'online' programs.









                                 2-33
        2.71   TRALOG


          Purpose:  Translate a VAX/VMS logical name.

          Declaration:    INTEGER TRALOG

          Calling sequence:  I=TRALOG(LOGIN,LOGOUT,OUTLEN)

          Return value:  The status return of the $TRNLM system service.

          Argument(s):  LOGIN:  Logical name to be translated.  (CHARACTER)
                        LOGOUT: Translated name.  (CHARACTER)
                        OUTLEN: Length of translated name.  (INTEGER)

          Notes:  Useful when the translated name is needed in the program.
                  The  call to $TRNLM is complicated from FORTRAN.  This is
                  a very VAX-specific routine, use it with caution.




        2.72   TRANUP


          Purpose:  Translate a character string to upper case.

          Declaration:    CHARACTER*(*) TRANUP

          Calling sequence:  CH=TRANUP(INTXT)

          Return value:  The translated string.

          Argument(s):  INTXT:  Character string containing the  characters
                                to be translated.

          Notes:  Useful  for   making   parameters   and   commands   case
                  insensitive.

                  The length of the string should be less than or equal  to
                  the declaration of TRANUP in the routine calling it.
















                                 2-34
        2.73   TRULEN


          Purpose:  Find the length of a character string.

          Declaration:    INTEGER TRULEN

          Calling sequence:  I=TRULEN(INTXT)

          Return value:  The number of characters in the string, excluding
                         trailing blanks.

          Argument(s):  INTXT:  Character string to find the length of.

          Notes:  Useful when actual length of a string is needed.




        2.74   WAIBIT


          Purpose:  Wait a certain number of seconds before going  on  with
                    the
        program.

          Calling sequence:  CALL WAIBIT(SEC)

          Argument(s):  SEC:    Number of seconds to wait.  (INTEGER)

          Notes:  Must use:  0 < SEC < 60
                  It is recommended to use WAITIT for  more  accurate  wait
                  periods.




        2.75   WAITIT


          Purpose:  Wait a certain number of seconds before going  on  with
                    the program.

          Calling sequence:  CALL WAITIT(RSEC)

          Argument(s):  RSEC:    Number of seconds to wait.  (REAL)

          Notes:  RSEC may be as small as .01 and as large as 100000.0 sec.









                                 2-35












                                 CHAPTER 3

                  DESCRIPTION OF USER-SUPPLIED ROUTINES.



          Following  are  detailed  descriptions  of  routines  which   the
        programmer   may   supply   to   do  special  processing.   Default
        (do-nothing)  routines  are  included  in  the  library  to   avoid
        undefined names at link time.




        3.1   EXIUSR


          Purpose:  Do exit processing.

          Declaration:    SUBROUTINE EXIUSR

          Argument(s):  None

          Notes:  Useful when processing time or other types  of  summaries
                  are needed.




        3.2   USRCHK


          Purpose:  Parse special qualifiers entered  on  original  command
                    line.

          Declaration:    SUBROUTINE USRCHK(NUMQ,CHRQUA)

          Argument(s):  NUMQ:   Number of different qualifiers found.
                        CHRQUA: Array (NUMQ elements used) of the qualifier
                                strings.  (CHARACTER)

          Notes:  This routine  is  called  from  SETCHK  when  the  /USER=
                  qualifier  was  entered  on  the original command line in


                                 3-1
                  VMS.

                  More than one qualifier may be entered by separating  the
                  inividual  ones  by commas and enclosing the whole set in
                  parenthesis '()'.

                  A dummy version which types each qualifier on the screen,
                  is included in the package and may be used as a template.

















































                                 3-2












                                 CHAPTER 4

                 DESCRIPTION OF QUALIFIER PARSING ROUTINES



          Most programs will be able to use the standard set of  qualifiers
        described  in  the  USERS_GUIDE  and  in  the  HELP information for
        TYPROG.  But it may  be  desirable  for  special  programs  to  use
        other/more  qualifiers  than  the standard COMPACK ones.  In such a
        case the programmer should write a section of code which  does  the
        parsing  for qualifiers.  The routine SETCHK in the COMPACK library
        is an example of how this should be done.  For each of the standard
        qualifiers  there is a routine described below which will check for
        the presence of the qualifier on the command line.  Every qualifier
        from  the standard set have to be included in the .CLD file for the
        program.  The definitions for the COMPACK qualifiers  which  should
        be  included  MUST  be  copied  from the file COMPACKCLD.CLD in the
        COMPACK source library.  Notice that some of the routines  (GFULSC,
        GNOSMG and GINCOM) should be called BEFORE the call to SETCOM (must
        be used instead of SETCHK in such a program).  This is in order for
        the  setup  of  the terminal to be done correctly.  The rest of the
        set should be called  AFTER  the  call  to  SETCOM  such  that  the
        terminal is already set up when they are called.

          See the examples for how to set up a  HELP  file  for  a  program
        using some of the standard qualifiers.


















                                 4-1
        4.1   GCOMND


          Purpose:  Check for the /COMMAND=file_name qualifier.

          Calling sequence:  CALL GCOMND

          Argument(s):  None

          Notes:  This qualifier will make the program read a command  file
                  before going to normal menu mode.




        4.2   GCONFI


          Purpose:  Check for the /CONFIRM_END qualifier.

          Calling sequence:  CALL GCONFI

          Argument(s):  None

          Notes:  This qualifier will make the program ask for confirmation
                  before  exiting  from  full-screen mode.  It is useful to
                  use /NOCONFIRM when a program  is  run  in  a  subprocess
                  spawned   form   inside   another  program.   Default  is
                  /CONFIRM_END.




        4.3   GFULSC


          Purpose:  Check for the /FULLSCREEN qualifier.

          Calling sequence:  CALL GFULSC

          Argument(s):  None

          Notes:  This  qualifier  will  make  the  program  start  up   in
                  FULL-SCREEN  mode.   This is useful when defining symbols
                  for running programs where the user may not remember  the
                  commands.  Default is /NOFULLSCREEN.











                                 4-2
        4.4   GINCOM


          Purpose:  Check for a command entered directly.

          Calling sequence:  CALL GINCOM(COMAND)

          Argument(s):  COMAND: Character string with  the  whole  original
                                command line as gotten from LIB$GETFOREIGN.

          Notes:  If a command is found this way, a flag will be  set  such
                  that  the  program will ONLY perform this one command and
                  immediately exit.




        4.5   GJOURN


          Purpose:  Check for the /JOURNAL=[file_name] qualifier.

          Calling sequence:  CALL GJOURN

          Argument(s):  None

          Notes:  This qualifier will make the program start up in  LOGGING
                  mode  where  all commands and parameters are written to a
                  file which later may be used  as  a  command  file.   The
                  file_name   part   is   optional   and  will  default  to
                  LAST_JOURNAL if not included.  When the file is  actually
                  opened,  the  name of the menu plus a '$' is added before
                  the file_name to uniquely identify the file.  Default  is
                  /NOJOURNAL.




        4.6   GNOSMG


          Purpose:  Check for the /NOSMG_MODE qualifier.

          Calling sequence:  CALL GNOSMG

          Argument(s):  None

          Notes:  If /NOSMG_MODE is found,  the  screen  I/O  via  the  SMG
                  library  of  routines  will  be disabled.  This is useful
                  when debugging a program to  avoid  interference  on  the
                  screen  between  the  debugger  and  the  output from the
                  program.  Default is /SMG_MODE





                                 4-3
        4.7   GSPLIT


          Purpose:  Check for the /SPLITMODE qualifier.

          Calling sequence:  CALL GSPLIT

          Argument(s):  None

          Notes:  This qualifier will start the program in  a  split-screen
                  mode,  where the upper half is used for message displays.
                  This qualifier should only be used  when  SPLTIT  is  not
                  called in the program.




        4.8   GSTATU


          Purpose:  Check for the /STATUSPART qualifier.

          Calling sequence:  CALL GSTATU

          Argument(s):  None

          Notes:  This qualifier will start the program with a small status
                  display  on  top of the screen.  Messages which should be
                  displayed for a long time may be written to this display.
                  This  qualifier  should  only  be used when SPLSTA is not
                  called in the program.




        4.9   GUSERM


          Purpose:  Check for the /USER=(par1...parn) qualifier.

          Calling sequence:  CALL GUSERM

          Argument(s):  None

          Notes:  The parts of this qualifier will be split apart  and  the
                  routine  USRCHK described in the previous chapter will be
                  called.










                                 4-4












                                 CHAPTER 5

                                 EXAMPLES



          Following is a set of examples  for  setting  up  a  prototypical
        program  using this package.  The program understands 4 commands at
        the top level, and has one sublevel.




        5.1   Main Program




              PROGRAM TYPROG
        C----------------------------------------------------------------------
        C-
        C-   Purpose and Methods : Demonstrate and test COMPACK facilities
        C-
        C-   Created  20-SEP-1988   Jan S. Hoftun
        C-
        C----------------------------------------------------------------------
              IMPLICIT NONE
              INTEGER STALIN
              DATA STALIN/3/
        C----------------------------------------------------------------------
        C
        C     Set up menus -- the rest of them are set up as needed internally
        C
              CALL MENSET('MENUDEF')
              CALL MENSET('ASTMODE')
              CALL MENSET('ASTMODE1')
        C
        C     Test STATUS screen
        C
              CALL SETSTA(STALIN)
              CALL SPLSTA
              CALL STAMSG(' Welcome to the COMPACK Protoype Program',.TRUE.)
              CALL SPLTIT


                                 5-1
        C
        C     Put user initialization here
        C
              CALL MENGET         !Call menu dispatching routine
              CALL EXIMEN
              STOP
              END


















































                                 5-2
        5.2   Typical Dispatch Type Routine.




              SUBROUTINE MENGET
        C----------------------------------------------------------------------
        C-
        C-   Purpose and Methods : Dispatch routine for TYPROG
        C-
        C-   Inputs :  None
        C-   Outputs : None
        C-
        C-   Created   23-MAY-89   by MENU_MAKER
        C-
        C----------------------------------------------------------------------
              IMPLICIT NONE
              CHARACTER*40 COMAND
              LOGICAL GOTOP
              LOGICAL FIRST
              DATA FIRST/.TRUE./
        C----------------------------------------------------------------------
              IF(FIRST) THEN
                FIRST=.FALSE.
                CALL TYPDEF
              ENDIF
              COMAND=' '
            1 CONTINUE
              IF (COMAND.NE.'EXIT') THEN
                CALL MENUDO('Prototype COMPACK Program ','TYPROG',COMAND)
                IF(COMAND.EQ.'TYPDIS') THEN
                  CALL TYPDIS
                ELSEIF(COMAND.EQ.'TYPGO') THEN
                  CALL TYPGO
                ELSEIF(COMAND.EQ.'TYPOPT') THEN
                  CALL TYPOPT
                ELSEIF(COMAND.EQ.'SUBLV1') THEN
                  CALL SUBLV1
                ELSEIF(COMAND.NE.'EXIT'.AND.COMAND.NE.'BLANK') THEN
                  CALL OUTMSG('0No ACTION defined for that command'//CHAR(7))
                ENDIF
                GOTO 1
              ENDIF
              RETURN
              END












                                 5-3
        5.3   Typical Command Interface Routine





                SUBROUTINE TYPGET
                 
        C        
        C      FUNCTIONAL DESCRIPTION:  
        C
        C              Get a TYPICAL set of parameters for a command.
        C
                IMPLICIT NONE
                INTEGER NUMPAR
                PARAMETER (NUMPAR=5)
                CHARACTER*40 PROMPT(NUMPAR)
                CHARACTER*1 TYPARR(NUMPAR)
                CHARACTER*40 CHARS,ACHAR
                CHARACTER*80 CHROUT
                REAL*4 XIN
                LOGICAL LIN,GETDEV
                INTEGER I,TRULEN,NEX,IN,PFNUM,LENINT
                LOGICAL SETMOD
                DATA TYPARR/'U','R','H','L','A'/
                DATA XIN/100.0/,IN/999/,LIN/.TRUE./
                WRITE(PROMPT(1),1) 
        1       FORMAT(' Enter characters > ')
                WRITE(PROMPT(2),2) XIN 
        2       FORMAT(' Enter a real number [',F<LENINT(INT(XIN))+4>.3,
             *         '] > ')
                WRITE(PROMPT(3),3) IN 
        3       FORMAT(' Enter an integer in HEX [',I<LENINT(IN)>,'] > ')
                WRITE(PROMPT(4),4) LIN 
        4       FORMAT(' Enter a logical flag [',L1,'] > ')
                WRITE(PROMPT(5),5) 
        5       FORMAT(' Enter characters for rest of line > ')
                CALL GETPAR(NUMPAR,PROMPT,TYPARR,CHARS,XIN,IN,LIN,ACHAR)
                IF(.NOT.SETMOD().AND.PFNUM().EQ.0) THEN
                   WRITE(CHROUT,100) CHARS
        100        FORMAT('0Returned parameters:   CHARS: ',A40)
                   CALL INTMSG(CHROUT)
                   CHROUT=' '
                   WRITE(CHROUT,101) XIN,IN,LIN
        101        FORMAT(' XIN=',F<LENINT(INT(XIN))+4>.3,
             *           '   IN=',I<LENINT(IN)>,'    LIN=',L3)
                   CALL INTMSG(CHROUT)
                   WRITE(CHROUT,102) ACHAR
        102        FORMAT(' ACHAR: ',A40)
                   CALL INTMSG(CHROUT)
                   CALL PFWAIT
                ENDIF
                RETURN
                END



                                 5-4
        5.4   Typical Setup Input File



        Item #   1.000
        Get Typical Parameters
        TYPDIS
         This command will prompt for the four possible types of parameters and print 
        them on the screen for inspection.                                              
        Item #   2.000
        Do Typical Computation
        TYPGO
         This command will prompt for a number of calculations to do. It then sets up a 
        submenu for user interaction and starts a calculation loop in the foreground. 
        Use End Calculation in the submenu to stop the loop.                            
        Item #   3.000
        Option Display
        TYPOPT
         This command will display a set of parameters in option-format, where one of 
        the options may be chosen from the list.                                        
        Item #   4.000,NO TITLE
        Go to Second Level
        SUBLV1
         This command will go down to the second level of menus.                        
        Item #   5.000,NO TITLE
        Run Command File
        CALL RUNCOM
         This command will prompt for the name of a command file to be run. The file 
        must contain commands spelled out enough to be unique and the required input 
        for each command as separate lines.  See SET UP COMMAND FILE for help on how to 
        create such a file.  If the file is not found or cannot be opened for some 
        other reason, a message will be typed, including the IOSTAT number.             
        Item #   6.000,NO TITLE
        Edit Command File
        CALL EVECOM
         This command will prompt for the name of a command file to be edited.  The 
        standard D0 editor, EVE+, will be used.                                         
        Item #   7.000
        Set up Command File
        CALL RUNSET
         This command will prompt for the name of a command file to be set up.  The 
        program will then go into a normal menu mode, but instead of actually doing the 
        commands it will save each input line in the command file.  You finish this 
        input mode by using BACK as usual.                                              
        Item #   8.000
        Start Logging to File
        CALL RUNLOG
         This command will prompt for the name of a command file for the  commands to 
        be saved in.  Each command will then be saved in this file which may be used as 
        a command file later.  You finish this logging mode by using the END LOGGING 
        command.                                                                        
        Item #   9.000,NO TITLE
        Stop Logging to File
        CALL ENDLOG
         This command will end the logging of commands to a file.                       


                                 5-5
        Item #  10.000
        Add Menu Item
        CALL ADDITM
         This command will let you add a VMS one-line command as a menu item. You will 
        be prompted for the name of the command. The name will appear in the menu list. 
        You will then be prompted for the command to be executed. A complicated command 
        may be performed by using a command file.  The same restrictions as under SPAWN 
        above are valid here as well.                                                   
        Item #  11.000,NO TITLE
        Control of Menu
        MENCTR
         This command will produce a secondary menu for controlling the layout of the 
        menu and adding new commands etc.  You go back up to the main menu by using 
        EXIT as usual.                                                                  











































                                 5-6
        5.5   Typical Definitions for a Program


          Here are two .COM files used in setting up a program.  The  first
        one  is used to define the logical names for the menu files and the
        second one (which calls the first one) is used to define a  program
        as  a  new  VMS command.  HELP information about the new command in
        should also be put into a site-specific help library.


        $! To set up menu definitions for TYPROG
        $!
        $ ASSIGN D0$COMPACK$MENU:ASTMODE.MENU ASTMODE
        $ ASSIGN D0$COMPACK$MENU:ASTMODE1.MENU ASTMODE1




        $! To set up TYPROG as a know command
        $!
        $ @D0$COMPACK$SOURCE:TYPROG_MENUS
        $ TYPROG :== $D0$COMPACK:TYPROG



































                                 5-7
        5.6   Typical VMS-HELP File for a Program


          Below is an example for how to set  up  a  VMS-HELP  file  for  a
        typical  program.   It  must  be  inserted into an appropriate .HLB
        library in order to be available to users.


        1 TYPROG

              This program is a prototype of a program using the COMPACK
        command-menu package. It is mainly used to test out new features, but
        is also useful for demonstration purposes as well as for examples of
        the interfaces to COMPACK. 

        2 Parameters

           Any valid command for this program. The given command (which may be
           running a command file) will then be the ONLY executed command and
           the program will exit directly. 

        2 Qualifiers

        /COMMAND=file_name

           Run the command file FILE_NAME before getting into the normal menu
           mode. 

        /CONFIRM_END (D)
          /NOCONFIRM_END

           Program will ask for confirmation before exiting when in
           FULL-SCREEN mode. 

        /FULLSCREEN
          /NOFULLSCREEN (D)

           Program should be started in FULL-SCREEN mode if possible.
           Incompatible with /NOSMG 

        /JOURNAL[=file_name]

           Program will go directly to LOGGING mode where all commands and
           parameters entered are saved in the file given by FILE_NAME. If no
           name is given, LAST_LOGFILE will be used. The name of the menu
           level is added to the front of the file_name to identify the file. 

        /SMG_MODE (D)
          /NOSMG_MODE

           Program will use the SMG package of routines for handling screen
           I/O. NOSMG_MODE is useful when debugging a program to avoid
           interference between the debugger and the SMG output. 

        /SPLITMODE


                                 5-8
           Start the program in SPLIT-SCREEN mode where an upper part is used
           for message reporting. 

        /STATUSPART

           Start the program with a small STATUS part for displaying
           long-lasting status messages. 

        /USER=(part1,part2,....partn)

           Special qualifiers for passing to a user part of the program. Will
           just type out the PART1...PARTn parameters here. 













































                                 5-9
