


                                                      Herbert Greenlee
                                                           18-Oct-1994




















                     ________ ___________ __ __ _____ _____                     Lossless Compression of D0 Zebra Data.
                                                                          Page 2


          1  Introduction.

          This document describes the COMPRESS_ZEBRA and program
          builder package, which is a general purpose lossless data
          compression utility for D0 Zebra data.  The general features
          of this package are as follows:

          1.  COMPRESS_ZEBRA reduces the the amount of disk space
              required to store D0 Zebra data by a factor of typically
              0.5 to 0.7.

          2.  Any kind of Zebra data may be compressed including RAW,
              STA, DST and microDST.

          3.  Compression is lossless with respect to both Zebra data
              and links.  Lossy compression by rounding floating point
              numbers may be selected by an RCP switch (see below).

          4.  The output generated by COMPRESS_ZEBRA, is an ordinary
              event-structured FZ file which can be operated on by
              general purpose FZ file utilities, such as ZFTP and
              COPY_FZ.

          5.  The compressed FZ file retains the HEAD bank and header
              vector of the uncompressed file.  Data from all other
              banks is stored in a single bank called ZDST that hangs
              under HEAD.

          6.  Decompression happens automatically when an event is
              read in using the D0 event utility, or by calling the
              subroutine UNCOMPRESS_ZEBRA.

          7.  Compressed FZ files are transportable between VMS and
              UNIX.

          8.  The events in compressed FZ files may be read out of
              sequence (e.g. using D0DAD or on the UNIX farm) provided
              they were compressed in random access mode (see below).




          2  How COMPRESS_ZEBRA And UNCOMPRESS_ZEBRA Work.

          COMPRESS_ZEBRA first converts an arbitrary Zebra tree
          structure into a linear data array which is then compressed
          using one of several off-the-shelf data compression
          algorithm.  The compressed data are stored in a single Zebra
          bank called ZDST, which hangs below the original HEAD bank.
          The original HEAD bank is not compressed or modified.  All
          banks other than HEAD and ZDST are dropped.
          UNCOMPRESS_ZEBRA reverses the process by reconstituting the
          original Zebra tree from the ZDST bank and dropping ZDST.
                                                                          Page 3


               The transition between a linked Zebra tree and a linear
          data array is accomplished by calling FZIN or FZOUT with
          input or output directed to a memory buffer (FZFILE M
          option).  The linearized Zebra data created by this method
          consists of ordinary Zebra exchange format physical records.
          The padding at the end of the last physical record is
          truncated from the data that are compressed and saved.

               The compression algorithms view the uncompressed data
          as a stream of characters or bytes and the compressed data
          as a stream of variable-bit-length tokens.  The packing of
          bytes and tokens into 32-bit words is handled consistently
          with respect to byte-order in such a way that the ZDST bank
          has an all-integer I/O characteristic and as such is
          transportable between VMS and UNIX by the standard methods.

               The ZDST bank includes the length and a checksum of the
          linearized data prior to compression.  Both of these are
          checked by UNCOMPRESS_ZEBRA and a fatal error is generated
          if either check fails.



          2.1  Compression Algorithms.

          The current implementation of COMPRESS_ZEBRA has three
          RCP-selectable compression algorithms.  These are the LZSS
          (Lempel-Ziv-Storer-Szymanski) variant [3] of the LZ77
          sliding-window algorithm [4], the LZW (Lempel-Ziv-Welch)
          variant [5] or the LZ78 algorithm [6], and the GNU zip
          (gzip) version 1.2.4 algorithm, which is another variant of
          LZ77 with a HUFFMAN coding post-processing phase.

               The gzip algorithm appears to be the best (fastest and
          best compression) of the three, and is the default.



          2.2  Settable Compression Parameters.

          The COMPRESS_ZEBRA package has a number of RCP-settable
          parameters that control the way data is compressed.  In
          addition to selecting the algorithm (LZSS or LZW), there are
          algorithm specific parameters which are described below.
          Regardless of the parameter settings used during
          decompression, UNCOMPRESS_ZEBRA automatically adapts without
          having to know how the data was compressed.  That is, any
          parameters needed for decompression, such as which algorithm
          to use, are stored in the header of the ZDST bank or in the
          compressed data itself.
                                                                          Page 4


               For the LZSS algorithm, one can separately set the
          number of bits used to point to phrases in the sliding
          window (RCP parameter LZSS_INDEX_BITS) and the number of
          bits used to encode the length of the phrase (RCP parameter
          LZSS_LENGTH_BITS).  The first parameter sets the size of the
          sliding window.  The second parameter sets the size of the
          look-ahead buffer.  In random access mode especially, these
          parameters need to be tuned to keep the size of the sliding
          window smaller than the size of a typical event.

               The LZW algorithm has just one parameter (RCP parameter
          LZW_DICTIONARY_BITS) that sets the maximum size of
          dictionary tokens and controls the maximum size to which the
          dictionary can grow.  This parameter has no effect on the
          compression ratio until the dictionary reaches the maximum
          size.  In general a larger dictionary will give better
          compression.  In random access mode, there is no advantage
          of making the dictionary size larger than the event size.
          During compression, a larger dictionary size costs memory
          and cpu time whether or not the entire dictionary is used.

               The gzip algorithm has just one parameter called the
          "pack level" (RCP parameter ZIP_PACK_LEVEL).  This parameter
          varies the compression algorithm in a complicated way.
          Higher number supposedly give more compression, but are
          slower.  In general, the effect of this parameter on speed
          is much more noticable than the effect on the amount of
          compression.  The default value is five, and there appears
          not to be much benefit from varying it.



          2.3  Sequential Versus Random Access.

          General purpose compression utilities, such as UNIX comrpess
          or PKZIP, treat files as unstructured byte streams.
          COMPRESS_ZEBRA and UNCOMPRESS_ZEBRA do not quite do this.
          They view data as event-structured byte streams.  From the
          point of view of the compression routines, there are two
          ways to split a file into events.

               The first method is random access.  In this method,
          events are completely separate.  Compression starts from
          scratch, with an empty dictionary, for each new event.
          Random access mode has the advantage of allowing the events
          to be read back in any order.  Random access is a
          requirement for some kinds of data, such as virtually
          streamed (D0DAD) data, or data that is to be processed on
          the farm.

               The other method is Sequential access.  In this method,
          each event inherits the dictionary that has been built up
          from previous events.  This method can give better
                                                                          Page 5


          compression, especially for data types with small events,
          but requires that events be decompressed in the same order
          that they were compressed.

               LZSS and LZW can used used in either mode.  ZIP always
          operates in random access mode, regardless of the RCP
          parameters.  Random or sequential access is selected by the
          RCP parameter RANDOM.



          2.4  Floating Point Rounding

          An additional feature of COMPRESS_ZEBRA is the ability to do
          lossy compression by rounding floating point numbers.  The
          rounding of floating point numbers reduces the total amount
          of information in an event, making greater compression
          possible.  The rounding of floating point numbers is
          controlled by the RCP parameters ROUND_FLOATING and
          FLOATING_BITS.

               The rounding of floating point numbers is done in such
          a way that bits to the left of the binary point are not
          rounded.  This means that integers that are encoded as
          floating point numbers, as in the microDST, are immune from
          rounding.

               If floating point rounding is selected, all of the
          Zebra banks in the event are scanned prior to linearization.
          The Zebra I/O characteristic is used to determine which
          Zebra words are floating point numbers.



          3  Usage

          This section contains intructions on how to use the package
          COMPRESS_ZEBRA and UMCOMPRESS_ZEBRA.



          3.1  Linking

          COMPRESS_ZEBRA is a program builder package with its own
          .PBD file and can be linked into a program builder frame
          like any other package.  UNCOMPRESS_ZEBRA is called
          automatically from EVTIN and doesn't need to be explicitly
          linked in to a framework.  Normally, the COMPRESS_ZEBRA
          should come after any other package.  The following is a
          typical package order:

          CALOR
          UDST_TO_DST
                                                                          Page 6


          ..
          <analysis packages>
          ..
          MAKE_UDST
          COMPRESS_ZEBRA




          3.2  Setup

          The COMPRESS_ZEBRA package is controlled by the RCP file
          COMPRESS_ZEBRA.RCP.  The following is a summary of the main
          RCP parameters in COMPRESS_ZEBRA.RCP that users may wish to
          modify:

          D0_COMPRESS_ZEBRA - Overall package flag (.TRUE./.FALSE.)

          COMP_ALG          - Algorithm 
                                0=none
                                1=LZSS
                                2=LZW
                                3=ZIP

          RANDOM            - .TRUE. = random access 
                              .FALSE.= sequential access.

          STA_MODE          - .TRUE. = Compress during PROCESS_EVENT
                                       hook.
          DST_MODE          - .TRUE. = Compress during DROP_EVENT_DST 
                                       hook.

          ROUND_FLOATING    - .TRUE. = Round floating point numbers.
                              .FALSE.= Do not round floating point
                                       numbers.
          FLOATING_BITS     - Minimum number of bits or precision to 
                              keep in rounded numbers.

          KEEP_HSTR         - .TRUE. = Do not compress HSTR bank.

          RECYCLE_ZDST      - Re-use ZDST bank from previous event
                              instead of recompressing (for OMNI)

          LZSS_INDEX_BITS   - LZSS parameter.
          LZSS_LENGTH_BITS  - LZSS parameter.

          LZW_DICTIONARY_BITS - LZW parameter.

          ZIP_PACK_LEVEL    - ZIP parameter.

                                                                          Page 7


          3.3  Output Streams.

          STA or DST output stream data may be compressed
          independently.  This is controlled by the RCP parameters
          STA_MODE and DST_MODE.  Normally, setting STA_MODE to .TRUE.
          will result in the STA output stream being compressed and
          similarly for DST_MODE.  Both STA and DST streams may be
          compressed by setting both parameters to .TRUE.  If STA_MODE
          is selected and a DST output stream is also defined, then
          UNCOMPRESS_ZEBRA is called from the event output utility
          EVTWOS to allow the dropping of ZEBRA banks.



          4  An Acknoledgment.

          To my knowledge, the original idea for software compression
          of D0 Zebra data is due Qiuwen Wu, who made a presentation
          at the November 1993 General Software Meeting (I think --
          but I couldn't find his talk in the agenda that was posted
          on D0NEWS).  This presentation is where I and others got the
          idea for this type of compression.  I thought that it was a
          good idea at the time and I still think that it is a good
          idea.



          5  References.

          The first two references are books.  Both contain
          descriptions of the LZSS and LZW algorithms.  The Nelson
          book (Ref. 1) was my main source of information, and also of
          the c source codes that were the basis of the LZSS and LZW
          compression modules included in the d0library packages.  The
          Storer book (Ref. 2) is more theoretical and is available in
          the Fermilab library.

          1.  Nelson, Mark, The Data Compression Book, M & T Books,
              San Mateo, CA (1992).

          2.  Steror, James A., Data Compression Methods and Theory,
              Computer Science Press, Rockville, MD (1988).

          The following are the original journal references for the
          various compression algorithms.  However, I have not looked
          them up as they are not in the Fermilab library.

          3.  Storer, J. A. and T. G. Szymanski, "Data Compression Via
              Textual Substitution," Journal of the ACM 29, 928-951
              (1982).
                                                                          Page 8


          4.  Ziv, J. and A. Lempel, "A Universal Algorithm for
              Sequential Data Compression," IEEE Transactions on
              Information Theory, 23, 337-343 (1977).

          5.  Welch, Terry, "A Technique for High-Performance Data
              Compresion," IEEE Computer, 17, 8-19 (1984).

          6.  Ziv, J. and A. Lempel, "Compression of Individual
              Sequences Via Variable-Rate Coding," IEEE Transactions
              on Information Theory, 24, 530-536 (1978).

