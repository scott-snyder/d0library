      PROGRAM FZSCRAMBLE
C-----------------------------------------------------------------------
C-
C-   Purpose and Methods: Sort an FZ exchange mode D0 data file.
C-                        Use with the program fzsort.
C-
C-   Inputs  :
C-   Outputs :
C-   Controls:
C-
C-   Usage:
C-
C    fzscramble $in_file $out_file $list_file
C-
C-   Fzscramble copies events from the specified input file to the 
C-   specified output file in random order as specified by the list file.
C-   The list file should be generated by fzsort, and may be sorted.
C-   In unix, Output from fzsort may be piped directly to fzscramble:
C-
C-   % fzsort $input | sort | fzscramble $input $output
C-
C-   Created  20-Mar-1995   Adam L. Lyon
C-
C-----------------------------------------------------------------------
      IMPLICIT NONE
      INCLUDE 'D0$INC:ZEBCOM.INC'
      INCLUDE 'D0$INC:QUEST.INC'

      CHARACTER*256, list_file, in_file, out_file
      LOGICAL list_stdin
      CHARACTER*4, chopt
      INTEGER in_unit, out_unit, list_unit, ilen, ios, ixwipe, cptr
      INTEGER srun, sevent, run, event, runno, evonum, ier
      INTEGER recw1, recw2
      EXTERNAL runno, evonum
      LOGICAL ok
      REAL r
      INTEGER xmode, lrec
C-
C- For command line scanning
C-
      CHARACTER*1024 line         ! Command line input buffer
      INTEGER*2 llen              ! Number of characters in command line
      CHARACTER*40 prompt         ! User prompt
      INTEGER force               ! Force prompt flag
      INTEGER i, j, n
      INTEGER trulen
      LOGICAL lib$get_foreign
      
C-----------------------------------------------------------------------
      
C*****Initialize zebra
      CALL MZEBRA(-3)            ! Init zebra
      CALL FZDIFF_INZCOM(2)      ! Setup /ZEBCOM/
      CALL INZSTP                ! Setup /ZEBSTP/
      
C*****Get input file name.
      FORCE = 0
      PROMPT = 'Enter input file: '
      OK = LIB$GET_FOREIGN(LINE, PROMPT(1:TRULEN(PROMPT)+1),
     &     LLEN, FORCE)
      CALL WORD(LINE(1:LLEN), I, J, N)
      IF(N.EQ.0.OR..NOT.OK)THEN
        PRINT*, 'No input file specified'
        STOP
      ENDIF
      IN_FILE = LINE(I:J)
      LINE(I:J) = ' '

C*****Get output file name.
      PROMPT = 'Enter output file: '
      CALL WORD(LINE(1:LLEN), I, J, N)
      IF(N.EQ.0)THEN
        OK = LIB$GET_FOREIGN(LINE, PROMPT(1:TRULEN(PROMPT)+1),
     &       LLEN, FORCE)
        CALL WORD(LINE(1:LLEN), I, J, N)
      ENDIF
      IF(N.EQ.0.OR..NOT.OK)THEN
        PRINT*, 'No output file specified'
        STOP
      ENDIF
      OUT_FILE = LINE(I:J)
      LINE(I:J) = ' '

C*****Get list file name.
      PROMPT = 'Enter lise file: '
      CALL WORD(LINE(1:LLEN), I, J, N)
      IF(N.EQ.0)THEN
        OK = LIB$GET_FOREIGN(LINE, PROMPT(1:TRULEN(PROMPT)+1),
     &       LLEN, FORCE)
        CALL WORD(LINE(1:LLEN), I, J, N)
      ENDIF
      IF(N.EQ.0.OR..NOT.OK)THEN
        LIST_FILE = '-'
      ELSE
        LIST_FILE = LINE(I:J)
      ENDIF
      LIST_STDIN = LIST_FILE(1:TRULEN(LIST_FILE)).EQ.'-'

C*****Make sure that input file is exchange mode.  Get record length.
      IN_UNIT = 20
      CALL XCHKER(IN_UNIT, IN_FILE(1:TRULEN(IN_FILE)), XMODE, LREC, OK)
      IF(XMODE.NE.1 .OR. .NOT.OK)THEN
        PRINT*, 'File is not exchange mode'
        STOP
      ENDIF

C*****Open input file and declare it to Zebra.  We use CFOPEN rather than
C     D0OPEN since the former is machine independent and allows random
C     access on all machines.
      CALL CFOPEN(cptr, 0, lrec, 'r', 0, in_file, ier)
      IF(ier.ne.0)THEN
        PRINT*, 'Cannot open in file'
        STOP
      ENDIF
      IQUEST(1) = CPTR
      CHOPT = 'DLI'
      CALL FZFILE(in_unit, lrec, chopt)

C*****Open the output file
      OUT_UNIT = 21
      CALL D0OPEN(out_unit, out_file, 'OX', ok)
      IF ( .NOT. ok ) THEN
        PRINT*, 'Could not open output file'
        STOP
      ENDIF

C*****Delcare it to zebra
      CALL XZRECL(ilen, chopt)
      CALL FZFILE(out_unit, ilen, chopt)     

C*****Open the list file
      IF(.NOT.LIST_STDIN)THEN
        LIST_UNIT = 22
        CALL D0OPEN(list_unit,list_file, 'IF', ok)
        IF ( .NOT. ok ) THEN
          PRINT*, 'Could not open list file'
          STOP
        ENDIF
      ENDIF

C*****LOOP: Read in the list file to get run and event number to search for
 400  CONTINUE
      IF(LIST_STDIN)THEN
        READ(*,200,END=500) srun, sevent, r, recw1, recw2
      ELSE
        READ(list_unit,200,END=500) srun, sevent, r, recw1, recw2
      ENDIF
 200  FORMAT (1X,I6,1X,I6,4X,Z8,1X,I6,1X,I6)


C*****  Clear out previous event
      IXWIPE = IXMAIN
      CALL MZWIPE(IXWIPE)
        
C*****  Get the event
      CALL FZINXT(in_unit,recw1, recw2)
      CALL FZIN(in_unit,ixmain,lhead,1,' ',0,0)
        
C*****  Get the data type
      IOS = IQUEST(1)
      IF ( IOS .EQ. 0 ) THEN
        IOS=MOD(IQ(LHEAD+1),1000)
        IF(IOS.GT.4) IOS=0
      ENDIF

C*****  Check the IOS result
      IF ( ios .LT. 0 ) THEN    ! Read error
        PRINT*, 'Read error on in file'
        STOP
      ENDIF
          
      IF ( ios .EQ. 0 ) THEN    ! Got an event
        run = RUNNO()
        event = EVONUM()
        
        IF ( run .EQ. srun .AND. event .EQ. sevent ) THEN ! Write it
          CALL WREVNT(out_unit)
          PRINT*, 'Written run,event', run, event
          GOTO 450
        ENDIF

      ENDIF

      IF ( ios .GE. 3 ) THEN    ! End of file
        PRINT*, 'Cannot find run,event', srun, sevent
        GOTO 450
      ENDIF
        
C*****  Ready to look for next run,event in list: close input file
 450  CONTINUE

C*****Get next in list
      GOTO 400

C*****All done, close all files
 500  CONTINUE
      CALL FZENDI(in_unit, 'T')
      CALL CFCLOS(in_unit,0)
      CALL FZENDO(out_unit, 'T')
      CALL D0CLOSE(out_unit, ' ', ok)
      CALL D0CLOSE(list_unit, ' ',ok)
     
      STOP


 999  CONTINUE
      END
