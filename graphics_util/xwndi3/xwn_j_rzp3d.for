      SUBROUTINE J_RZP3D
C  ROUTINE TO CREATE AND MANAGE A 3D ROTATE-ZOOM-PAN MOUSE
C  SELECTED CHART AND THE ASSOCIATED INTERRUPT ROUTINES
C
      INCLUDE 'SYS$LIBRARY:DECW$XLIBDEF.FOR'
      INCLUDE 'D0$GRAPHICS_UTIL$XWNDI3:XWNEMU.INC'
      INTEGER XPNT,YPNT
      INTEGER ATBR,ATBF
      INTEGER VD_IDB,WD_IDB
      COMMON/BTNCOM/VXX,VYY,IBTN
      COMMON/FONTSZ/XSZZZ,YSZZZ
      COMMON/RZINIT/UPVEC0(3),UVEC0(3),VNORM0(3),VPROJ0(3),
     &  VDIST0,ANG1,ANG10,FRACT
      REAL X0(21),Y0(21),X1,X2,Y1,Y2
      DATA X0/0.,4.,8.,12.,4*6.,0.,12.,11*0./
      DATA Y0/4*39.,33.,36.,42.,45.,30.,30.,27.,24.,21.,18.,
     &  15.,12.,9.,6.,3.,0.,-3./
C
      LOGICAL DISCARD
      INTEGER GC_MASK
      INTEGER SCREEN                ! screen id
      INTEGER ATTR_MASK             ! attributes mask
      INTEGER FONT                  ! font id
      INTEGER WD_IDX,WD_IDY         ! window origin
      INTEGER WD_IDW,WD_IDH         ! window WIDTH, HEIGHT
      INTEGER DEPTH                 ! number of planes
      INTEGER FUNC, STATUS          ! synchronous behavior
C
      RECORD /X$VISUAL/ VISUAL            ! visual type
      RECORD /X$SET_WIN_ATTRIBUTES/ XSWDA ! window attributes
      RECORD /X$GC_VALUES/ XGB        ! gc values
      RECORD /X$SIZE_HINTS/ XSZHN         ! hints
      RECORD /X$COLOR/ XCOLORS(10)             ! COLOR
      RECORD /X$EVENT/ EVENT              ! input event
C
      CHARACTER*60 FONT_NAME
      DATA FONT_NAME
     &/'-ADOBE-NEW CENTURY SCHOOLBOOK-MEDIUM-R-NORMAL--*-140-*-*-P-*'/
C--------------------------------------------
C  INITIALIZE DISPLAY AND SCREEN ID
      VD_IDB=X$OPEN_DISPLAY()
      SCREEN=X$DEFAULT_SCREEN_OF_DISPLAY(VD_IDB)
C!!!      STATUS=X$SYNCHRONIZE(VD_IDB,1,FUNC)
C  CREATE RZP3D WINDOW
      SCRX=X$WIDTH_OF_SCREEN(SCREEN)
      SCRY=X$HEIGHT_OF_SCREEN(SCREEN)
      DEPTH=X$DEFAULT_DEPTH_OF_SCREEN(SCREEN)
      WIDTHB=.093*SCRX
      HEIGHB=.42*SCRY
      SCAL=.9*HEIGHB/50.
      YOFF=4.
      XSZZZ=.16*SCAL
      YSZZZ=.28*SCAL
      XORGN=SCRX-1.1*WIDTHB
      YORGN=.03*SCRY
      WD_IDH=HEIGHB
      WD_IDW=WIDTHB
      WD_IDX=XORGN
      WD_IDY=YORGN
      XSZHN.X$L_SZHN_X=XORGN
      XSZHN.X$L_SZHN_Y=YORGN
      XSZHN.X$L_SZHN_WIDTH=WIDTHB
      XSZHN.X$L_SZHN_HEIGHT=HEIGHB
      XSZHN.X$L_SZHN_FLAGS=X$M_P_POSITION .OR. X$M_P_SIZE
      CALL X$DEFAULT_VISUAL_OF_SCREEN(SCREEN,VISUAL)
      ATTR_MASK=X$M_CW_EVENT_MASK.OR.X$M_CW_BACK_PIXEL.OR.
     &          X$M_CW_BACKING_STORE
      XSWDA.X$L_SWDA_EVENT_MASK=X$M_EXPOSURE.OR.X$M_BUTTON_PRESS
      XSWDA.X$L_SWDA_BACKING_STORE=X$S_CW_BACKING_STORE
C      XSWDA.X$L_SWDA_BACKGROUND_PIXEL =
C      TYPE 222,VD_IDB,SCREEN,WD_IDX,WD_IDY,WD_IDW,WD_IDH,DEPTH
C 222  FORMAT('VD,SCR,WX,WY,WW,WH,DE:',/,7I)
      WD_IDB=X$CREATE_WINDOW(VD_IDB,X$ROOT_WINDOW_OF_SCREEN(SCREEN),
     &     WD_IDX,WD_IDY,WD_IDW,WD_IDH,0,
     &     DEPTH,X$C_INPUT_OUTPUT,VISUAL,ATTR_MASK,XSWDA)
      CALL X$SET_NORMAL_HINTS(VD_IDB,WD_IDB,XSZHN)
      CALL X$STORE_NAME(VD_IDB,WD_IDB,'3D')
C  MAP THE WINDOW
      CALL X$MAP_WINDOW(VD_IDB,WD_IDB)
C  Wait here for the window to expose
  111 CALL X$NEXT_EVENT(VD_IDB,EVENT)
      IF(EVENT.EVNT_TYPE.NE.X$C_EXPOSE
     &  .OR. EVENT.EVNT_EXPOSE.X$L_EXEV_WINDOW.NE.WD_IDB) GO TO 111
C  CREATE GRAPHICS CONTEXT--WHITE FOREGROUND
      XGB.X$L_GCVL_FOREGROUND=X$WHITE_PIXEL_OF_SCREEN(SCREEN)
C  BLACK BACKGROUND
      XGB.X$L_GCVL_BACKGROUND=X$BLACK_PIXEL_OF_SCREEN(SCREEN)
C  MAKE THE GC
      GC_MASK=X$M_GC_FOREGROUND .OR. X$M_GC_BACKGROUND
      ATBR=X$CREATE_GC(VD_IDB,WD_IDB,GC_MASK,XGB)
C
C  SAVE INITIAL SETTINGS
      DO I=1,3
        UVEC0(I)=UVEC(I)
        UPVEC0(I)=UPVEC(I)
        VPROJ0(I)=VPROJ(I)
        VNORM0(I)=NVEC(I)
      ENDDO
      VDIST0=VDIST
C
C  INITIAL INCREMENTS (ROUNDOFF PROBLEMS NEAR PI/2 FOR EVEN ANGLES)
      ANG1=1.001
      ANG10=15.001
      FRACT=.1
C
      MODWIN=.FALSE.
C
C  DO LABELS
      CALL X$SYNC(VD_IDB,DISCARD)
      CALL J_RZTEXT('ROTATE',4.,48.)
      CALL J_RZTEXT('SPIN',5.,30.)
      CALL J_RZTEXT('ZOOM>>ZOOM',3.,27.)
      CALL J_RZTEXT('UNZOOM/PAN',3.,24.)
      CALL J_RZTEXT('PAN',3.,21.)
      CALL J_RZTEXT('SIDE VIEW',3.,18.)
      CALL J_RZTEXT('TOP VIEW',3.,15.)
      CALL J_RZTEXT('END VIEW',3.,12.)
      CALL J_RZTEXT('PERSP/PARA',3.,9.)
      CALL J_RZTEXT('INIT VIEW',3.,6.)
      CALL J_RZTEXT('SETTINGS',3.,3.)
      CALL J_RZTEXT('HARDCOPY',3.,0.)
      CALL J_RZTEXT('EXIT',3.,-3.)
      CALL X$SYNC(VD_IDB,DISCARD)
C
C  SET UP TASK RECTANGLES AND AST REGIONS
      DO I=1,21
        X1=X0(I)
        X2=X0(I)+2.
        Y1=Y0(I)
        Y2=Y0(I)+2.
        CALL J_RZRECT(X1,Y1,X2,Y2)
      ENDDO
C
C  Get input focus
C!!!BAD PARAMETER HERE SOMEWHERE
C!!!      CALL X$SET_INPUT_FOCUS(VD_IDB,WD_IDB,IREVRT,ISTAMP)
C
C  EVENT LOOP
  200 CONTINUE
      DO WHILE (.TRUE.)
        CALL X$NEXT_EVENT(VD_IDB,EVENT)
        IF(EVENT.EVNT_TYPE.EQ.X$C_BUTTON_PRESS.AND.
     &   EVENT.EVNT_BUTTON.X$L_BTEV_BUTTON.EQ.X$C_BUTTON1) THEN
          RESULT_RETURN=X$QUERY_POINTER(VD_IDB,WD_IDB,IRID,
     &             ICID,IRX,IRY,IWX,IWY,STATE_MASK)
          GO TO 205
        ENDIF
      ENDDO
C
C  BUTTON WAS PUSHED,WAS POINTER INSIDE A TASK RECTANGLE?
  205 ITASK=0
C  CONVERT TO LOCAL COORDINATES
      SCAL=.9*HEIGHB/50.
      XPNT=FLOAT(IWX)/SCAL
      YPNT=(HEIGHB-FLOAT(IWY))/SCAL-YOFF
C      TYPE *,' XPNT,YPNT:',XPNT,YPNT
      DO 210 I=1,21
        X1=X0(I)
        IF(XPNT.LT.X1) GO TO 210
        X2=X0(I)+2.
        IF(XPNT.GT.X2) GO TO 210
        Y1=Y0(I)
        IF(YPNT.LT.Y1) GO TO 210
        Y2=Y0(I)+2.
        IF(YPNT.GT.Y2) GO TO 210
        ITASK=I
        GO TO 220
  210 ENDDO
      GO TO 200
  220 IF(ITASK.EQ.21) GO TO 1200
C
C  GO EXECUTE THE RZP3D MENU TASKS
      CALL J_RZEXEC(ITASK)
      GO TO 200
 1200 CALL X$UNMAP_WINDOW(VD_IDB,WD_IDB)
      CALL X$DESTROY_WINDOW(VD_IDB,WD_IDB)
      CALL X$CLOSE_DISPLAY(VD_IDB)
      RETURN
C
C  ENTRY FOR RZTEXT TO DO LINES
      ENTRY J_RZLINE2(XX1,YY1,XX2,YY2)
C  XWINDOWS ORIGIN IS AT UPPER LEFT.  (REVENGE OF THE BRASS RAT.)
      SCAL=.9*HEIGHB/50.
      IX1=XX1*SCAL
      IY1=HEIGHB-(YY1+YOFF)*SCAL
      IX2=XX2*SCAL
      IY2=HEIGHB-(YY2+YOFF)*SCAL
      IF(IDEBUG.GT.30) THEN
        TYPE *,' X$DRAW_LINE-X1,Y1,X2,Y2,IX1,IY1,IX2,IY2:',
     &                       X1,Y1,X2,Y2,IX1,IY1,IX2,IY2
      ENDIF
      CALL X$DRAW_LINE(VD_IDB,WD_IDB,ATBR,IX1,IY1,IX2,IY2)
      END
