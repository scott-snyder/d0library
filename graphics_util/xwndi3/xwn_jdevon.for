      SUBROUTINE JDEVON(IDEVI)
C----------------------------------------------------------------------
C-  SUBROUTINE FOR TURNING ON DISPLAY DEVICE.
C-  THIS ROUTINE FOR VAX WORKSTATION RUNNING DECWINDOWS.
C-   Modified  16-OCT-1995   Nobuaki Oshima
C-     Use PX_SYSTEM_RCP to define the window size on the screen.
C----------------------------------------------------------------------
C-
      INCLUDE 'SYS$LIBRARY:DECW$XLIBDEF.FOR'
      INCLUDE 'D0$GRAPHICS_UTIL$XWNDI3:XWNEMU.INC'
C  INITIALIZE NON-STANDARD FEATURES (SEE VAX_NONSTANDARD)
      DATA STFONT,RZPOFF,STRENA/.TRUE.,.TRUE.,.TRUE./
C  COMMON CONNECTING TO JWINDW
      COMMON/JWCOMM/VPX1,VPX2,VPY1,VPY2
C  /DIWNDW/ USED TO SET ABSOLUTE WINDOW POSITION IN FRACTIONS OF
C           SCRX,SCRY
      COMMON/DIWNDW/IEXTW,FX0,FY0,FWID,FHEI
      COMMON/SCRSIZ/SCRX,SCRY
C
      INTEGER DISCARD
      INTEGER GC_MASK
      INTEGER SCREEN                      ! screen id
      INTEGER ATTR_MASK                   ! attributes mask
      INTEGER FONT                        ! font id
      INTEGER WD_IDX,WD_IDY               ! window origin
      INTEGER DEPTH                       ! number of planes
      INTEGER FUNC, STATUS                ! asynchronous behavior
      INTEGER WD_IDH,WD_IDW
C-
      INTEGER IDEV
      REAL    DXMIN,DXMAX,DYMIN,DYMAX
C
      RECORD /X$VISUAL/ VISUAL            ! visual type
      RECORD /X$SET_WIN_ATTRIBUTES/ XSWDA ! window attributes
      RECORD /X$GC_VALUES/ XGCVL          ! gc values
      RECORD /X$SIZE_HINTS/ XSZHN         ! hints
      INTEGER FLAGS
      RECORD /X$EVENT/ EVENT              ! input event
C*****BEGIN NAMED COLORS
      RECORD /X$COLOR/ SCRNCOL
      INTEGER STR_SIZE, COLMAP
      INTEGER DEFCOL
      CHARACTER*15 COLNAM(8)
      DATA COLNAM/
     &     'RED            ','GREEN          ','YELLOW         ',
     &     'BLUE           ','MAGENTA        ','CYAN           ',
     &     'WHITE          ','BLACK          '/
C*****BEGIN RGB COLORS
C      RECORD /X$COLOR/ XCOLORS(256)        ! COLOR
C      COMMON/CCOUNT/MXCLRS,MONO,NUMCLR
C*****END COLORS
C
C  Following used for hardcopy RGB tables
C                 BLACK, RED, GREEN, YELLOW, BLUE
C                 MAGENTA, CYAN, WHITE, BLACK, ORANGE, LIME
C                 INDIGO, DARK-GRAY, WHITE
C                 LIGHT-RED, LIGHT-GREEN, LIGHT-BLUE
      DATA RVEC/
     &            0,255,31,255,31,
     &            255,31,255,0,255,127,
     &            127,127,255,
     &            255,127,127,33*0/
      DATA GVEC/
     &            0,31,255,255,31,
     &            31,255,255,0,127,255,
     &            31,127,255,
     &            127,255,127,33*0/
      DATA BVEC/
     &            0,31,31,31,255,
     &            255,255,255,0,31,31,
     &            255,127,255,
     &            127,127,255,33*0/
C
      CHARACTER*8 WINDOW_NAME
      DATA WINDOW_NAME/'DI3TURBO'/
      DATA W_DX,W_DY/.9,.9/
      CHARACTER*60 FONT_NAME
      DATA FONT_NAME
     &/'-ADOBE-NEW CENTURY SCHOOLBOOK-MEDIUM-R-NORMAL--*-140-*-*-P-*'/
      LOGICAL FIRST
      DATA FIRST/.TRUE./
C----------------------------------------------------------------------
C-
C  CHECK FOR DEVICE 2 (HARDCOPY)
      IDEVIC=IDEVI
      IF(IDEVIC.EQ.2) GO TO 2000
C
C  INITIALIZE DISPLAY AND SCREEN
      IF(.NOT.FIRST) RETURN
      FIRST=.FALSE.
      VD_ID=X$OPEN_DISPLAY()
      IF(VD_ID.LE.0) THEN
	TYPE *,' DISPLAY NOT INITIALIZED:'
        TYPE *,'    set display/create/node=XXXXXXX, and/or'
        TYPE *,'    check security at remote node'
        STOP
      ELSE
        IF(IDEBUG.GT.0) TYPE *,' JDEVON: VD_ID,IDEVI',VD_ID,IDEVI
      ENDIF
      SCREEN=X$DEFAULT_SCREEN_OF_DISPLAY(VD_ID)
C  CREATE THE MAIN WINDOW
      SCRX=X$WIDTH_OF_SCREEN(SCREEN)
      SCRY=X$HEIGHT_OF_SCREEN(SCREEN)
      DEPTH=X$DEFAULT_DEPTH_OF_SCREEN(SCREEN)
C      TYPE *,' DEPTH OF SCREEN',DEPTH
C  WIDTH AND HEIGHT OF WINDOW IN FRACTIONS OF SCREEN
      WIDTH=W_DX*SCRX
      HEIGHT=W_DY*SCRY
C---
      SCRX = WIDTH
      SCRY = HEIGHT
C  INITIALIZE VIEWSPACE AND VIEWPORT COORDS
      RASP=HEIGHT/WIDTH
      XMARG=0.
      YMARG=0.
      CALL JVSPAC(-1.,1.,-1.,1.)
C  PROVIDE WINDOW POSITIONS
      XORGN=0.
      YORGN=0.
C      XORGN=.08*SCRX
C      YORGN=.05*SCRY
      XSZHN.X$L_SZHN_X=XORGN
      XSZHN.X$L_SZHN_Y=YORGN
      WD_IDH=HEIGHT
      WD_IDW=WIDTH
      WD_IDX=XORGN
      WD_IDY=YORGN
C  SET UP WINDOWS
      XSZHN.X$L_SZHN_WIDTH=WIDTH
      XSZHN.X$L_SZHN_HEIGHT=HEIGHT
      XSZHN.X$L_SZHN_FLAGS=X$M_P_POSITION.OR.X$M_P_SIZE
      CALL X$DEFAULT_VISUAL_OF_SCREEN(SCREEN,VISUAL)
      ATTR_MASK=X$M_CW_EVENT_MASK.OR.X$M_CW_BACK_PIXEL.OR.
     &          X$M_CW_BACKING_STORE
      XSWDA.X$L_SWDA_EVENT_MASK=X$M_EXPOSURE.OR.X$M_BUTTON_PRESS
      XSWDA.X$L_SWDA_BACKING_STORE=X$S_CW_BACKING_STORE
C      XSWDA.X$L_SWDA_BACKGROUND_PIXEL =
C*****BEGIN RGB COLOR SETUP
C        FLAGS=X$M_DO_RED.OR.X$M_DO_GREEN.OR.X$M_DO_BLUE
C        VCM_ID=X$DEFAULT_COLORMAP_OF_SCREEN(SCREEN)
C        DO KC=1,10
C          XCOLORS(KC).X$B_COLR_FLAGS=FLAGS
C          XCOLORS(KC).X$W_COLR_RED=RVEC(KC)*65280
C          XCOLORS(KC).X$W_COLR_BLUE=BVEC(KC)*65280
C          XCOLORS(KC).X$W_COLR_GREEN=GVEC(KC)*65280
C          STATUS=X$STORE_COLOR(VD_ID,IVCMID,XCOLORS(KC))
C        ENDDO
C        CALL X$INSTALL_COLORMAP(VD_ID,IVCMID)
C*****END COLORS
C
C  CREATE WINDOW
      WD_ID=X$CREATE_WINDOW(VD_ID,X$ROOT_WINDOW_OF_SCREEN(SCREEN),
     &     WD_IDX,WD_IDY,WD_IDW,WD_IDH,0,
     &     DEPTH,X$C_INPUT_OUTPUT,VISUAL,ATTR_MASK,XSWDA)
C
      CALL X$SET_NORMAL_HINTS(VD_ID,WD_ID,XSZHN)
      CALL X$STORE_NAME(VD_ID,WD_ID,'XWN_DI3 Emulator')
C  SET ACTIVE DEVICE NUMBER
      DI3ADV=IDEVI
C  MAP THE WINDOW
 3000 CALL X$MAP_WINDOW(VD_ID,WD_ID)
C  Wait here for the window to expose
  111 CALL X$NEXT_EVENT(VD_ID,EVENT)
      IF(EVENT.EVNT_TYPE.NE.X$C_EXPOSE
     & .OR. EVENT.EVNT_EXPOSE.X$L_EXEV_WINDOW.NE.WD_ID) GO TO 111
C  CREATE GRAPHICS CONTEXT
C  WHITE FOREGROUND
      XGCVL.X$L_GCVL_FOREGROUND=X$WHITE_PIXEL_OF_SCREEN(SCREEN)
C  BLACK BACKGROUND
      XGCVL.X$L_GCVL_BACKGROUND=X$BLACK_PIXEL_OF_SCREEN(SCREEN)
C  MAKE THE GC
      GC_MASK=X$M_GC_FOREGROUND .OR. X$M_GC_BACKGROUND
      ATB(ILINE)=X$CREATE_GC(VD_ID,WD_ID,GC_MASK,XGCVL)
      IATB=ILINE
C  LOAD THE FONT FOR TEXT WRITING
      FONT=X$LOAD_FONT(VD_ID,FONT_NAME)
      ATB(IFONT)=X$CREATE_GC(VD_ID,WD_ID,X$M_GC_FOREGROUND,XGCVL)
      CALL X$SET_FONT(VD_ID,ATB(IFONT),FONT)
      ATB(IPLGN)=X$CREATE_GC(VD_ID,WD_ID,GC_MASK,XGCVL)
      CALL X$SET_FILL_STYLE(VD_ID,ATB(IPLGN),X$C_FILL_SOLID)
      ATB(ITEXT)=X$CREATE_GC(VD_ID,WD_ID,GC_MASK,XGCVL)
      CALL X$SET_FONT(VD_ID,ATB(ITEXT),FONT)
      ATB_LOC=X$CREATE_GC(VD_ID,WD_ID,GC_MASK,XGCVL)
C
C  SET INITIAL COLOR TO WHITE
      IC=7
      STATUS=X$SYNCHRONIZE(VD_ID,0,FUNC)  ! Turn off permanent synch.
      CALL X$FLUSH(VD_ID)                 ! Flush the buffer now
C!!!      CALL X$SYNC(VD_ID,0)                ! Synchronize now
C!!!      CALL X$SYNC(VD_ID,DISCARD)          ! Synchronize now
      GO TO 60
C
C  HARDCOPY INIT
 2000 CONTINUE
      PUTS=.FALSE.
      ICOL=1
      CALL J_HCOPY_BEGIN('XWN PIXIE GRAPHICS',ICOL,IERR)
      RETURN
C-
C-----------------------------------------------------------(JCOLOR)---
C-
      ENTRY JCOLOR(ICC)
C  SET THE CURRENT COLOR PRIMITIVE ATTRIBUTE
      IC=ICC
   60 IF(IDEBUG.GT.0) TYPE *,' JCOLOR, IC = ',IC
      ICOLOR=IC
      IF (IC.EQ.8 .OR. IC.NE.CUR_COLOR) THEN
        CUR_COLOR=IC
        IF(IC.LE.0) IC=7
        IF(IC.GT.8) THEN
          IF(IC.EQ.9) THEN
C  COMPLEMENT
            IF(HCPY) THEN
              IC=7
            ELSE
              IC=8
            ENDIF
C  MAP THE EXTENDED COLOR TABLE
          ELSEIF(IC.EQ.10) THEN
            IC=5
          ELSEIF(IC.EQ.11) THEN
            IC=5
          ELSEIF(IC.EQ.12) THEN
            IC=4
          ELSEIF(IC.EQ.13) THEN
            IC=6
          ELSEIF(IC.EQ.14) THEN
            IC=2
          ELSEIF(IC.EQ.15) THEN
            IC=4
          ELSEIF(IC.EQ.16) THEN
            IC=1
          ELSEIF(IC.EQ.17) THEN
            IC=5
          ELSEIF(IC.EQ.18) THEN
            IC=1
          ELSE
            IC=7
          ENDIF
        ENDIF
C  DO HARDCOPY COLOR
        IF(HCPY) THEN
          CALL DEV_COLOR(IC)
          RETURN
        ENDIF
C
C  No color
        IF(DEPTH.EQ.1) THEN
           ICOTYP=2
C          IF (IC.EQ.0.OR.IC.EQ.8) THEN
C            DEFCOL=X$BLACK_PIXEL_OF_SCREEN(SCREEN)
C          ELSE
            DEFCOL=X$WHITE_PIXEL_OF_SCREEN(SCREEN)
C          ENDIF
          GO TO 70
        ENDIF
C
        IF (VISUAL.X$L_VISU_CLASS .EQ. X$C_TRUE_COLOR .OR.
     &     VISUAL.X$L_VISU_CLASS .EQ. X$C_PSEUDO_COLOR .OR.
     &     VISUAL.X$L_VISU_CLASS .EQ. X$C_DIRECT_COLOR .OR.
     &     VISUAL.X$L_VISU_CLASS .EQ. X$C_GRAY_SCALE .OR.
     &     VISUAL.X$L_VISU_CLASS .EQ. X$C_STATIC_GRAY .OR.
     &     VISUAL.X$L_VISU_CLASS .EQ. X$C_STATIC_COLOR) THEN
C
          ICOTYP=1
          COLMAP=X$DEFAULT_COLORMAP_OF_SCREEN(SCREEN)
          STATUS=STR$TRIM(COLNAM(IC),COLNAM(IC),STR_SIZE)
          STATUS=X$ALLOC_NAMED_COLOR(VD_ID,COLMAP,
     &                   COLNAM(IC)(1:STR_SIZE),SCRNCOL)
          IF (STATUS) THEN
            DEFCOL=SCRNCOL.X$L_COLR_PIXEL
          ELSE
C  Bad color
            WRITE(6,*) 'Color not allocated!'
            CALL LIB$SIGNAL(%VAL(STATUS))
            IF(IC.EQ.0.OR.IC.EQ.8) THEN
              DEFCOL=X$BLACK_PIXEL_OF_SCREEN(SCREEN)
            ELSE
              DEFCOL=X$WHITE_PIXEL_OF_SCREEN(SCREEN)
            ENDIF
            ICOTYP=2
          ENDIF
        ELSE
C  No color
          ICOTYP=2
          IF (IC.EQ.0.OR.IC.EQ.8) THEN
            DEFCOL=X$BLACK_PIXEL_OF_SCREEN(SCREEN)
          ELSE
            DEFCOL=X$WHITE_PIXEL_OF_SCREEN(SCREEN)
          ENDIF
        ENDIF
C
C  CHANGE THE GC COLORS
  70    CONTINUE
        XGCVL.X$L_GCVL_FOREGROUND=DEFCOL
C*****FOR RGB COLORS, PULL MUCH OF ABOVE, THEN
C        XGCVL.X$L_GCVL_FOREGROUND=XCOLORS(IC+1).X$L_COLR_PIXEL
C  BLACK AND WHITE MAY NEED SPECIAL TREATMENT
C*****END RGB COLORS
        CALL X$CHANGE_GC(VD_ID,ATB(ILINE),GC_MASK,XGCVL)
        CALL X$CHANGE_GC(VD_ID,ATB(ITEXT),GC_MASK,XGCVL)
        CALL X$CHANGE_GC(VD_ID,ATB(IFONT),X$M_GC_FOREGROUND,XGCVL)
        CALL X$CHANGE_GC(VD_ID,ATB(IPLGN),GC_MASK,XGCVL)
      ENDIF
      IF(.NOT.PUTS)RETURN
      CALL J_PUTSG(-IJCOLR,IC)
      RETURN
C-
C-----------------------------------------------------------(JLOCAT)---
C-
      ENTRY JLOCAT(IDSP,IPHY,IECH,IBUTTN,VX,VY)
C  "INVOKE THE VIRTUAL LOCATOR INPUT FUNCTION"
C   (VIRTUOUSLY LOQUACIOUS!)
C
      IF(HCPY) RETURN
      IBTN=0
      IECHO=IECH+1
      IF(IECHO.LT.0.OR.IECHO.GT.9) RETURN
C
C  Get input focus
      CALL X$SET_INPUT_FOCUS(VD_ID,WD_ID,IREVRT,ISTAMP)
C
C  Loop waiting for mouse
      CALL X$BELL(VD_ID,20)
      DO WHILE (.TRUE.)
        CALL X$NEXT_EVENT(VD_ID,EVENT)
        IF(EVENT.EVNT_TYPE.EQ.X$C_BUTTON_PRESS.AND.
     &   EVENT.EVNT_BUTTON.X$L_BTEV_BUTTON.EQ.X$C_BUTTON1) THEN
          RESULT_RETURN=X$QUERY_POINTER(VD_ID,WD_ID,IRID,ICID,
     &          IRX,IRY,IWX,IWY,STATE_MASK)
          GO TO 7001
        ENDIF
      ENDDO
C
 7001 CONTINUE
      GO TO (7100,7200,7300,7400,7500,7600,7700,7800,7900) IECHO
 7100 CONTINUE
      GO TO 7010
C  POINTER SQUARE
 7200 CONTINUE
      GO TO 7010
C  LINE FROM X1,Y1 TO X2,Y2
 7300 CONTINUE
      GO TO 7010
C  HORIZONTAL LINE INDICATOR
 7400 CONTINUE
      CALL X$DRAW_LINE(VD_ID,WD_ID,ATB_LOC,IWX-100,IWY,IWX+100,IWY)
      GO TO 7010
C  VERTICAL LINE INDICATOR
 7500 CONTINUE
      CALL X$DRAW_LINE(VD_ID,WD_ID,ATB_LOC,IWX,IWY-100,IWX,IWY+100)
      GO TO 7010
C  VERT. AND HORIZ. LINE INDICATORS
 7600 CONTINUE
      CALL X$DRAW_LINE(VD_ID,WD_ID,ATB_LOC,IWX-100,IWY,IWX+100,IWY)
      CALL X$DRAW_LINE(VD_ID,WD_ID,ATB_LOC,IWX,IWY-100,IWX,IWY+100)
      GO TO 7010
C  RECTANGLE FROM X1,Y1 TO X2,Y2
 7700 CONTINUE
C  DRAG SEGMENT
      GO TO 7010
C  ????
 7800 CONTINUE
      GO TO 7010
C  ????
 7900 CONTINUE
      GO TO 7010
C
C  FROM SCREEN TO VIEWPORT
 7010 XP=(FLOAT(IWX)-XMARG)/XSCALS+VCXMN
      YP=(HEIGHT-FLOAT(IWY)-YMARG)/YSCALS+VCYMN
      VX=XP
      VY=YP
      RETURN
C-
C-----------------------------------------------------------(JDEVVP)---
C-    Pick window size definition from PX_SYSTEM_RCP. (Nobu. 10-OCT-95)
C-
      ENTRY JDEVVP(IDEV,DXMIN,DXMAX,DYMIN,DYMAX)
      W_DX=DXMAX
      W_DY=DYMAX
      RETURN
      END
