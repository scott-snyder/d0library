!!!      OPTIONS /EXTEND_SOURCE (NOT NECESSARY ANYMORE    SA)
c-cancel ungranted lock requests.
c-in doc: using it as data saver
c  - gbl sec mode avoids insufficient working set errors.
c  - emphasize SYSGBL priv is needed for G mode
c-strange global mode behaviour
c-gbl mode enhancements. Node mask, node checking.
c************************************************************************
c*
c*       CLUSCOM package
c*
c*       A set of routines to provide interprocess memory sharing (of
c*       common blocks) between any processes running on any CPUs within
c*       any VAXcluster.
c*
c*       Commons are mapped to disk files using QIOs to disk or
c*       global sections. Access is coordinated using the distributed
c*       lock manager.
c*
c*       Can also be used simply for fast-and-easy saving of data in
c*       a common block on a file.
c*
c*       Usage notes:
c*         - documentation obtainable from the author
c*         - SYSGBL priv is needed to use 'G' mode (gbl section mode)
c*         - SYSLCK is needed to use 'Y' option (system-wide sections)
c*         - The last word in the common should be followed by at
c*           least 512 bytes of unused space: eg.
c*              COMMON /MYCOM/ IFIRST, MYVARIABLES, ILAST(128)
c*           This is to ensure that ILAST is followed by unused space up
c*           to the next page boundary. This region is overwritten in
c*           disk-to-memory operations.
c*         - when you change the size of a common, by adding stuff for
c*           example, you must delete the old MAPCOM file or use the
c*           C option of CC_SETUP to ensure a new copy is created.
c*         - options should be specified in UPPER CASE.
c*         - example link:
c*              $ LINK/DEB myprogram,CPC$DIR:CPC/LIB/INCL=CPC
c*
c*       Present version: DEV
c*
c* 1.3 -> DEV changes:   Feb 90
c*  - modified by Mike Capell to do multiple I/Os for large sections.
c*    Does I/O in blocks of 512 pages. This avoids overflowing the
c*    working set when trying to read in a big section all at once.
c*  - closing of section file with a Fortran CLOSE (freeing the LUN)
c*    is now done immediately after opening.
c* 1.3 -> 1.4 changes:   July 89
c*  - RAB removed from the cluscom structure.
c*  - Logical unit LUN added to the structure.
c*  - CC_CLOSE to close a CLUSCOM section introduced.
c*  - CC_SET_LAST implemented for global mode (but global mode is still
c*    behaving strangely --also for old versions which used to work fine in
c*    gbl mode)
c*  - LIB$WAIT -> L3_WAIT
c*
c* 1.2 -> 1.3 changes:    Apr 89
c*  - event flag allocated/deallocated in CC_LOCKUP, so EFs are
c*    no longer carried by each CC section.
c*  - use qio instead of block io.
c*    added by Mike Capell, Feb 89.
c*  - CC_SET_LAST routine added. To read/write only part of a
c*    common (eg when only the first few hundred words of a
c*    big common have to be updated) to save time.
c*  - cache timeouts increased and error message made more comprehensible
c*    (VS 2000s are slow!)
c*  - CC_LOCKUP split into AST and NON-AST routines.
c*  - all I/O uses QIOs in this version. Global section mode will reappear
c*    with improvements in the next version.
c*
c*       1.1 -> 1.2 changes:    Jan 89
c*           - under FORTRAN V5, alignment of commons can be done in-line,
c*             eliminating the need to specify it in the link
c*           - read access only is needed to the disk file if READONLY
c*             mode is used
c*           - MAPCOM files always created with group and world
c*             write access
c*           - 'Y' (system) option in booking, to create system cache
c*             instead of UIC-specific cache. Requires SYSLCK.
c*           - 'L3%' prefix added to cache names, to avoid interference.
c*             Invisible to user
c*
c*       1.0 -> 1.1 changes:    Nov 88
c*           - error handling improved. Errors generated by the MESSAGE
c*             utility are returned in IERR. LIB$SIGNAL can be used to
c*             display them (message info is in the CPC library).
c*             LIB$SIGNAL is used internally so all errors generate
c*             an output message.
c*             Error codes are in the file L3$MODEL:[CPC]CPCERR.FOR.
c*             IERR=0 as before if the routine executed error-free.
c*           - global section mode added. Selected with G option in
c*             CC_SETUP. It is faster than block IO when flushing to disk,
c*             and so is useful for programs which do a lot of writing
c*             to CLUSCOM sections. Try both and use whichever is fastest
c*             for your application.
c*           - when READONLY mode is selected (option 'R'), the program
c*             needs only read access to the MAPCOM file.
c*           - LENOCC -> LST, where LST is a function in the CPC library,
c*             so the CERN libraries are no longer needed in the link
c*           - maximum length of ID names increased to 20
c*
c*
c*       Still to do, or in progress:
c*         - G mode enhancements; store node id of latest changer, updater.
c*           check to see whether change, update was made on local node
c*           before updating gbl section
c*         - HBOOK test
c*
c*                                       T. Wenaus  EP/L3  July 1988
c*
c************************************************************************
      SUBROUTINE CC_SETUP(COMID,FNAME,IFIRST,ILAST,CHOPT,IERR)
c************************************************************************
c*
c*       SUBR. CC_SETUP
c*
c*       Declares a shared common to the system. The specified file
c*       is opened and mapped to the common.
c*       By default, an existing map file is opened, otherwise a new
c*       file is created.
c*
c*       Options:
c*          'G'   global section mode
c*          'R'   readonly
c*          'W'   write mode
c*          'C'   force creation of new map file
c*          'O'   open old map file (error if it doesn't exist)
c*          'Y'   system mode. Cache is recognised across all UICs.
c*                Requires SYSLCK privilege.
c*          'M'   by default, when an existing map file is opened,
c*                memory is initialized from disk rather than vice
c*                versa. To initialize disk from memory, use this
c*                option.
c*          'X'   do not use lock mechanism for access coordination
c*                For testing and single-process applications only
c*
c************************************************************************
      IMPLICIT INTEGER (A-Z)
      CHARACTER COMID*(*), FNAME*(*), CHOPT*(*)
      INCLUDE '($LCKDEF)'
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
      LOGICAL EXIST
      CHARACTER MPOPT*5
      EXTERNAL CCF_CREATE
      EXTERNAL CCF_OPEN
      LOGICAL FIRST /.TRUE./
c*
c*       ----------------------------------------------------------------
c*
      IERR=0
      IF (LST(COMID).GT.CC__MAXLEN) THEN
c*           common identifier too long
        CALL LIB$SIGNAL(%VAL(CC_E_BADNAME),%VAL(1),%VAL(CC__MAXLEN))
        IERR=CC_E_BADNAME
        RETURN
      ENDIF
      IF (LST(FNAME).GT.CC__MAXFIL) THEN
c*           filename too long
        CALL LIB$SIGNAL(%VAL(CC_E_BADFILE),%VAL(2),FNAME(:LST(FNAME)),
     +      %VAL(CC__MAXFIL))
        IERR=CC_E_BADFILE
        RETURN
      ENDIF
      IF (NCCOM.GE.CC__MAXCOM) THEN
c*           too many mapped commons
        CALL LIB$SIGNAL(%VAL(CC_E_MAXEX),%VAL(1),%VAL(CC__MAXCOM))
        IERR=CC_E_MAXEX
        CALL CC_LIST
        RETURN
      ENDIF
      IF (MOD(%LOC(IFIRST),512).NE.0) THEN
c*           common not page aligned
        CALL LIB$SIGNAL(%VAL(CC_E_PAGALIGN),%VAL(1),COMID(:LST(COMID)))
        IERR=CC_E_PAGALIGN
        RETURN
      ENDIF
c*         count of number of known commons
      IF (FIRST) THEN
        FIRST=.FALSE.
        NCCOM=1
        NCOM=1
      ELSE
c**          first look for a hole
        NCOM=0
        DO K=1,NCCOM
          IF(CCOM(K).REV.EQ.-1) THEN
            NCOM=K
            GOTO 123
          ENDIF
        ENDDO
  123   IF (NCOM.EQ.0) THEN
          NCCOM = NCCOM +1
          NCOM = NCCOM
        ENDIF
      ENDIF
c*         index of common currently in use
      NCURRENT = NCOM
c*         set the mode to block IO (now uses QIOs, not RMS)
      CCOM(NCOM).IO = 'B'
CCC not yet        IF (INDEX(CHOPT,'G').NE.0) CCOM(NCOM).IO = 'G'
c*
      CCOM(NCOM).COMID = COMID(:LST(COMID)) ! ID of the common
      CCOM(NCOM).LKST.NAME = 'CC_'//COMID(:LST(COMID))
                                               ! name of the lock resource
      CCOM(NCOM).FNAME = FNAME(:LST(FNAME)) ! filename of map file
      IFPAGE = %LOC(IFIRST)
c*         find the first page break after ILAST
c*         set to the byte just before the page break
      ILPAGE = %LOC(ILAST) + (512-MOD(%LOC(ILAST),512)) -1
      CCOM(NCOM).IFIRST = IFPAGE
      CCOM(NCOM).ILAST  = ILPAGE
      CCOM(NCOM).ILPAGE = ILPAGE
      CCOM(NCOM).REV = 0
      IF (MOD(ILPAGE-IFPAGE+1,512).NE.0) THEN
c*         total screwup
        CALL LIB$SIGNAL(%VAL(CC_E_TOTSCREW),%VAL(1),
     +    CCOM(NCOM).COMID(:LST(CCOM(NCOM).COMID)))
        IERR=CC_E_TOTSCREW
        RETURN
      ENDIF
      CCOM(NCOM).AUTH  = 0              ! authorization code
      IF (INDEX(CHOPT,'R').NE.0) THEN
c*           readonly bit
        CCOM(NCOM).AUTH  = CCOM(NCOM).AUTH .OR. 1
      ENDIF
      IF (INDEX(CHOPT,'Y').NE.0) THEN
c*           system mode bit
        CCOM(NCOM).AUTH  = CCOM(NCOM).AUTH .OR. 2
      ENDIF
      IF (INDEX(CHOPT,'X').NE.0) THEN
        CCOM(NCOM).LOCK  = -1
      ELSE
c**         create the lock resource, and get a null lock
        CALL CC_LOCKMAKE(NCOM,IREV,IERR)
        IF (IERR.NE.0) GOTO 999
      ENDIF
D     TYPE *,'Set up lock ',CCOM(NCOM).COMID(:LST(CCOM(NCOM).COMID)),
D    +  '  File ',FNAME(:LST(CCOM(NCOM).FNAME)),
D    +  '   Opt "',CHOPT,'" #',NCOM
c*
c**        open the file to map
      IF (INDEX(CHOPT,'C').NE.0) THEN
        EXIST=.FALSE.
      ELSE
        EXIST=.TRUE.
        INQUIRE (FILE=FNAME, EXIST=EXIST)
      ENDIF
c**          get length of common, in blocks
      LENGTH = ( CCOM(NCOM).ILAST - CCOM(NCOM).IFIRST + 1 ) /512
      IF (.NOT.EXIST) THEN
        IF (INDEX(CHOPT,'O').NE.0) THEN
          CALL LIB$SIGNAL(%VAL(CC_E_NOFILE),%VAL(1),FNAME(1:LST(FNAME)))
          IERR=CC_E_NOFILE
          RETURN
        ENDIF
c**          open the shared file
        IF (CCOM(NCOM).IO.EQ.'B') THEN
          ISTAT = LIB$GET_LUN(LUN)
          IF (.NOT.ISTAT) THEN
            CALL LIB$SIGNAL(%VAL(ISTAT))
            IERR = ISTAT
            GOTO 999
          ENDIF
          CCOM(NCOM).LUN = LUN
          OPEN(UNIT=LUN,FILE=FNAME,STATUS='NEW',INITIALSIZE=
     +        LENGTH,USEROPEN=CCF_CREATE,SHARED)
c**            initialize the new file with the current common
          CLOSE(UNIT=LUN,IOSTAT=ISTAT)
          CALL LIB$FREE_LUN(LUN)
          CALL CC_WRITE(NCOM,IERR)
          IF (IERR.NE.0) GOTO 999
        ENDIF
      ELSE
        IF (CCOM(NCOM).IO.EQ.'B') THEN
          ISTAT = LIB$GET_LUN(LUN)
          IF (.NOT.ISTAT) THEN
            CALL LIB$SIGNAL(%VAL(ISTAT))
            IERR = ISTAT
            GOTO 999
          ENDIF
          CCOM(NCOM).LUN = LUN
c**            open the shared file
          IF (MOD(CCOM(NCOM).AUTH,2).EQ.1) THEN
            OPEN(UNIT=LUN,FILE=FNAME,STATUS='OLD',INITIALSIZE=
     +          LENGTH,USEROPEN=CCF_OPEN,READONLY,SHARED)
            CALL CC_READ(NCOM,IERR)
            IF (IERR.NE.0) GOTO 999
          ELSE
            OPEN(UNIT=LUN,FILE=FNAME,STATUS='OLD',INITIALSIZE=
     +          LENGTH,USEROPEN=CCF_OPEN)
            IF (INDEX(CHOPT,'M').EQ.0) THEN
c*                 initialize memory from disk unless 'M' option is selected
              CALL CC_READ(NCOM,IERR)
              IF (IERR.NE.0) GOTO 999
            ELSE
              CALL CC_WRITE(NCOM,IERR)
              IF (IERR.NE.0) GOTO 999
            ENDIF
          ENDIF
          CLOSE(UNIT=LUN,IOSTAT=ISTAT)
          CALL LIB$FREE_LUN(LUN)
        ENDIF
      ENDIF
      MPOPT='C   '
      IF (MOD(CCOM(NCOM).AUTH,2).EQ.1) THEN
        IF (INDEX(CHOPT,'W').NE.0) THEN
c*             readonly and exclusive write options not compatible
          CALL LIB$SIGNAL(%VAL(CC_E_EXASSUMED),%VAL(1),CCOM(NUM).COMID)
          IERR=CC_E_EXASSUMED
          GOTO 999
        ELSE
D         TYPE *,'Read mode'
          MPOPT=MPOPT(1:LST(MPOPT))//'R'
        ENDIF
      ENDIF
      IF (CCOM(NCOM).IO.EQ.'G') THEN
c*           create or open file, and create mapping to file
        IF (INDEX(CHOPT,'M').NE.0) THEN
c*             zero out common
          MPOPT=MPOPT(1:LST(MPOPT))//'Z'
        ENDIF
        IF (INDEX(CHOPT,'C').NE.0) THEN
c*             force creation of new map file
          MPOPT=MPOPT(1:LST(MPOPT))//'N'
        ENDIF
        CALL CC_MAPCOM(NCOM,
     +    CCOM(NCOM).FNAME,'GS'//CCOM(NCOM).COMID,
     +    CCOM(NCOM).IFIRST,CCOM(NCOM).ILAST,
     +    CCOM(NCOM).IADR,MPOPT,IERR)
        IF (IERR.NE.0) GOTO 999
      ENDIF
      IF (INDEX(CHOPT,'W').NE.0) THEN
c**          convert to write mode
        CALL CC_WRITELOCK_I(NCOM,' ',IERR)
      ENDIF
  999 END
      SUBROUTINE CC_CLOSE(COMID,CHOPT,IERR)
c************************************************************************
c*
c*       SUBR. CC_CLOSE
c*
c*       Close a cluscom section.
c*
c************************************************************************
      CHARACTER*(*) COMID, CHOPT
      INTEGER SYS$DEQ, SYS$DASSGN
      INCLUDE '($SSDEF)'
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
c*
      CALL CC_ID_NUM(COMID,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
c*
c**        close the section file. This is now done immediately
c*         after opening.
C        CLOSE(UNIT=CCOM(NUM).LUN,IOSTAT=ISTAT)
C        IF (ISTAT.NE.0) THEN
C          CALL LIB$SIGNAL(%VAL(ISTAT))
C          IERR = ISTAT
C          GOTO 999
C        ENDIF
C        ISTAT = LIB$FREE_LUN(CCOM(NUM).LUN)
C        IF (.NOT.ISTAT) THEN
C          CALL LIB$SIGNAL(%VAL(ISTAT))
C          IERR = ISTAT
C          GOTO 999
C        ENDIF
      ISTAT = SYS$DASSGN (%VAL (CCOM(NUM).CHAN))
      IF (.NOT.ISTAT) THEN
        CALL LIB$SIGNAL(%VAL(ISTAT))
        IERR = ISTAT
        GOTO 999
      ENDIF
      IF (CCOM(NUM).LOCK.NE.-1) THEN
c**          dequeue lock
        ISTAT = SYS$DEQ(%VAL(CCOM(NUM).LKST.ID),,,)
        IF (ISTAT.NE.SS$_NORMAL) THEN
          CALL LIB$SIGNAL (%VAL(ISTAT))
          IERR = ISTAT
          GOTO 999
        ENDIF
      ENDIF
c**        tag it as dead
      CCOM(NUM).REV = -1
  999 END
      SUBROUTINE CC_SET_LAST(COMID,ILAST,CHOPT,IERR)
c************************************************************************
c*
c*       SUBR. CC_SET_LAST
c*
c*       Sets the final word of a mapped common to write or read. Used
c*       to write/read only part of a common, to save time when only
c*       the region up to ILAST of a large common is used.
c*
c*       eg. if the mapped common is
c*              COMMON /MY/ IFIRST, IARRAY(10000), ILAST(128)
c*       then   CALL CC_SET_LAST(COMID,IARRAY(100),' ',IERR)
c*       will cause /MY/ to be read/written only up to the first page
c*       boundary past IARRAY(100).
c*
c*       NOTE that NO i/o is actually performed by this routine.
c*
c*       Options:
c*          'R'   Reset to read/write the entire common. ILAST ignored.
c*
c************************************************************************
      CHARACTER*(*) COMID, CHOPT
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
c*
      CALL CC_ID_NUM(COMID,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
c* $$$     not implemented for gbl mode yet
CCC        IF (CCOM(NUM).IO.EQ.'G') RETURN
      IF (INDEX(CHOPT,'R').NE.0) THEN
c*           reset
        CCOM(NUM).ILAST  = CCOM(NUM).ILPAGE
      ELSE
        CALL CC_VAR_NUM(ILAST,NUM1,IERR)
        IF (IERR.NE.0) GOTO 999
        IF (NUM1.NE.NUM) THEN
          CALL LIB$SIGNAL(%VAL(CC_E_MISMATCH),%VAL(1),COMID)
          IERR = CC_E_MISMATCH
          GOTO 999
        ENDIF
c*           find the first page break after ILAST
c*           set to the byte just before the page break
        ILPAGE = %LOC(ILAST) + (512-MOD(%LOC(ILAST),512)) -1
        CCOM(NUM).ILAST  = ILPAGE
      ENDIF
  999 END
      SUBROUTINE CC_UPDATE(COMID,CHOPT,IERR)
c************************************************************************
c*
c*       SUBR. CC_UPDATE
c*
c*       Given a shared common identifier, the common is updated from
c*       disk.
c*
c*       CC_UPDATEV: Same as CC_UPDATE, except instead of the ID being
c*                   passed, any non-character variable within the
c*                   common is passed.
c*       CC_UPDATEC: character variable is passed
c*
c*       Options:
c*          'F'   Force the updating from disk. By default, the update
c*                is not done if the revision number has not changed
c*
c************************************************************************
      CHARACTER*(*) COMID, CHOPT
      CALL CC_ID_NUM(COMID,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
      CALL CC_UPDATE_I(NUM,CHOPT,IERR)
  999 END
      SUBROUTINE CC_UPDATEV(VARNAME,CHOPT,IERR)
      CHARACTER*(*) CHOPT
      CALL CC_VAR_NUM(VARNAME,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
      CALL CC_UPDATE_I(NUM,CHOPT,IERR)
  999 END
      SUBROUTINE CC_UPDATEC(CHRNAME,CHOPT,IERR)
      CHARACTER CHRNAME*(*), CHOPT*(*)
      CALL CC_CHR_NUM(CHRNAME,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
      CALL CC_UPDATE_I(NUM,CHOPT,IERR)
  999 END
      SUBROUTINE CC_UPDATE_I(NUM,CHOPT,IERR)
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
      CHARACTER*(*) CHOPT
c*
c**        first the lock is obtained in CR mode. Thus different
c*         processes can simultaneously read from disk, but not
c*         while any process has an exclusive lock for writing.
c*
      IF (CCOM(NUM).LOCK .NE.-1) THEN
        CALL CC_LOCKUP('CR',NUM,IREV,IERR)
        IF (IERR.NE.0) GOTO 999
D       TYPE *,'Read lock obtained. IREV =',IREV
        IF (CCOM(NUM).REV .EQ.IREV.AND.INDEX(CHOPT,'F').EQ.0) THEN
D         TYPE *,'   no update necessary. Rev no. unchanged.'
        ELSE
          CALL CC_READ(NUM,IERR)
          IF (IERR.NE.0) GOTO 999
        ENDIF
        CALL CC_LOCKUP('NL',NUM,IREV,IERR)
      ELSE
        CALL CC_READ(NUM,IERR)
      ENDIF
      IF (IERR.NE.0) GOTO 999
  999 END
      SUBROUTINE CC_SAVE(VARNAME,VALUE,CHOPT,IERR)
c************************************************************************
c*
c*       SUBR. CC_SAVE
c*
c*       A variable name present in any mapped common is passed, together
c*       with its new value. The new value is written to the common.
c*
c*       Before the SAVE is made, an update from disk is performed if
c*       necessary.
c*
c*       CC_SAVEV: Save vector. Number of words to save is also passed.
c*       CC_SAVEC: Save character string.
c*
c*       OPTIONS:
c*           'F'   Force the updating from disk. By default, the update
c*                 is not done if the revision number has not changed
c*
c************************************************************************
      CHARACTER VTYPE*1, CHOPT*(*)
c*
      CALL CC_VAR_NUM(VARNAME,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
c*         get the write lock and update if necessary
      CALL CC_WRITELOCK_I(NUM,CHOPT,IERR)
      IF (IERR.NE.0) GOTO 999
c*         write the variable
      VARNAME = VALUE
c*         write to disk
      CALL CC_WRITE(NUM,IERR)
      IF (IERR.NE.0) GOTO 999
c*         release the write lock and flush
      CALL CC_RELEASE_I(NUM,' ',IERR)
  999 END
      SUBROUTINE CC_SAVEV(ANAME,AVAL,LENGTH,CHOPT,IERR)
      CHARACTER*(*) CHOPT
      INTEGER ANAME(*),AVAL(*)
      CALL CC_VAR_NUM(ANAME,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
c*         get the write lock and update
      CALL CC_WRITELOCK_I(NUM,CHOPT,IERR)
      IF (IERR.NE.0) GOTO 999
c*         write the variable
      DO I=1,LENGTH
        ANAME(I) = AVAL(I)
      ENDDO
c*         write to disk
      CALL CC_WRITE(NUM,IERR)
      IF (IERR.NE.0) GOTO 999
c*         release the write lock and flush
      CALL CC_RELEASE_I(NUM,' ',IERR)
  999 END
      SUBROUTINE CC_SAVEC(CHRNAME,CHRVALUE,CHOPT,IERR)
      CHARACTER CHRNAME*(*), CHRVALUE*(*), CHOPT*(*)
      CALL CC_CHR_NUM(CHRNAME,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
c*         get the write lock and update
      CALL CC_WRITELOCK_I(NUM,CHOPT,IERR)
      IF (IERR.NE.0) GOTO 999
c*         write the variable
      CHRNAME = CHRVALUE
c*         write to disk
      CALL CC_WRITE(NUM,IERR)
      IF (IERR.NE.0) GOTO 999
c*         release the write lock and update
      CALL CC_RELEASE_I(NUM,' ',IERR)
  999 END
      SUBROUTINE CC_WRITELOCK(COMID,CHOPT,IERR)
c************************************************************************
c*
c*       SUBR. CC_WRITELOCK
c*
c*       Given a shared common identifier, the common is updated from
c*       disk and locked in write mode
c*
c*       CC_WRITELOCKV: Same as CC_WRITELOCK, except instead of the ID
c*                      being passed, any non-character variable within
c*                      the common is passed.
c*       CC_WRITELOCKC: character variable is passed
c*
c*       OPTIONS:
c*           'F'   Force the updating from disk. By default, the update
c*                 is not done if the revision number has not changed
c*
c************************************************************************
      CHARACTER*(*) COMID, CHOPT
      CALL CC_ID_NUM(COMID,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
      CALL CC_WRITELOCK_I(NUM,CHOPT,IERR)
  999 END
      SUBROUTINE CC_WRITELOCKV(VARNAME,CHOPT,IERR)
      CHARACTER*(*) CHOPT
      CALL CC_VAR_NUM(VARNAME,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
      CALL CC_WRITELOCK_I(NUM,CHOPT,IERR)
  999 END
      SUBROUTINE CC_WRITELOCKC(CHRNAME,CHOPT,IERR)
      CHARACTER CHRNAME*(*), CHOPT*(*)
      CALL CC_CHR_NUM(CHRNAME,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
      CALL CC_WRITELOCK_I(NUM,CHOPT,IERR)
  999 END
      SUBROUTINE CC_WRITELOCK_I(NUM,CHOPT,IERR)
      CHARACTER CHOPT*(*)
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
c*
c**        obtain write lock
c*
      IF (MOD(CCOM(NUM).AUTH,2).EQ.1) THEN
c*           attempt to write lock a readonly common
        CALL LIB$SIGNAL(%VAL(CC_E_NOWRTLK),%VAL(1),CCOM(NUM).COMID)
        IERR=CC_E_NOWRTLK
        GOTO 999
      ENDIF
      IF (CCOM(NUM).LOCK .NE.-1) THEN
        CALL CC_LOCKUP('EX',NUM,IREV,IERR)
        IF (IERR.NE.0) GOTO 999
D       TYPE *,'Write lock obtained. IREV =',IREV
        IF (CCOM(NUM).REV .EQ.IREV.AND.INDEX(CHOPT,'F').EQ.0) THEN
D         TYPE *,'   no update necessary. Rev no. unchanged.'
        ELSE
D         TYPE *,'   REV changed. Update from disk.'
          CALL CC_READ(NUM,IERR)
          IF (IERR.NE.0) GOTO 999
          CCOM(NUM).REV = IREV
        ENDIF
        CCOM(NUM).LOCK = 1
      ELSE
        CALL CC_READ(NUM,IERR)
        IF (IERR.NE.0) GOTO 999
      ENDIF
  999 END
      SUBROUTINE CC_RELEASE(COMID,CHOPT,IERR)
c************************************************************************
c*
c*       SUBR. CC_RELEASE
c*
c*       Releases write lock mode on common, after flushing.
c*
c*       CC_RELEASEV: Any variable name in common is passed instead of ID.
c*       CC_RELEASEC: Any character variable is passed instead of ID.
c*
c*       OPTIONS:
c*           none at present
c*
c************************************************************************
      CHARACTER*(*) COMID, CHOPT
      CALL CC_ID_NUM(COMID,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
      CALL CC_RELEASE_I(NUM,CHOPT,IERR)
  999 END
      SUBROUTINE CC_RELEASEV(VARNAME,CHOPT,IERR)
      CHARACTER CHOPT*(*)
      CALL CC_VAR_NUM(VARNAME,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
      CALL CC_RELEASE_I(NUM,CHOPT,IERR)
  999 END
      SUBROUTINE CC_RELEASEC(CHRNAME,CHOPT,IERR)
      CHARACTER CHRNAME*(*), CHOPT*(*)
      CALL CC_CHR_NUM(CHRNAME,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
      CALL CC_RELEASE_I(NUM,CHOPT,IERR)
  999 END
c*
      SUBROUTINE CC_RELEASE_I(NUM,CHOPT,IERR)
      CHARACTER CHOPT*(*)
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
      IERR = 0
      IF (CCOM(NUM).LOCK .NE.-1) THEN
        IF (CCOM(NUM).LOCK .NE. 1.AND.INDEX(CHOPT,'F').EQ.0) THEN
c*             attempt to release a common that isn't write locked
          GOTO 999
        ENDIF
      ENDIF
      CALL CC_WRITE(NUM,IERR)
      IF (IERR.NE.0) GOTO 999
      IF (CCOM(NUM).LOCK .NE.-1) THEN
        CALL CC_LOCKUP('NL',NUM,IREV,IERR)
        IF (IERR.NE.0) GOTO 999
D       TYPE *,'Write lock released. IREV=',IREV
        CCOM(NUM).LOCK = 0
        CCOM(NUM).REV = IREV
      ENDIF
  999 END
      SUBROUTINE CC_FLUSH(COMID,CHOPT,IERR)
c************************************************************************
c*
c*       SUBR. CC_FLUSH
c*
c*       Flush memory to disk. If write mode is in place, it remains in
c*       place. If there is no write lock on the common on entry, the
c*       common is write locked during the flush and then unlocked
c*       again.
c*
c*       CC_FLUSHV: Any variable name in common is passed instead of ID.
c*       CC_FLUSHC: Any character variable is passed instead of ID.
c*
c*       OPTIONS:
c*           none at present
c*
c************************************************************************
      CHARACTER*(*) COMID, CHOPT
      CALL CC_ID_NUM(COMID,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
      CALL CC_FLUSH_I(NUM,CHOPT,IERR)
  999 END
      SUBROUTINE CC_FLUSHV(VARNAME,CHOPT,IERR)
      CHARACTER CHOPT*(*)
      CALL CC_VAR_NUM(VARNAME,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
      CALL CC_FLUSH_I(NUM,CHOPT,IERR)
  999 END
      SUBROUTINE CC_FLUSHC(CHRNAME,CHOPT,IERR)
      CHARACTER CHRNAME*(*), CHOPT*(*)
      CALL CC_CHR_NUM(CHRNAME,NUM,IERR)
      IF (IERR.NE.0) GOTO 999
      CALL CC_FLUSH_I(NUM,CHOPT,IERR)
  999 END
c*
      SUBROUTINE CC_FLUSH_I(NUM,CHOPT,IERR)
      CHARACTER CHOPT*(*)
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
      LOGICAL WLOCK
      IF (CCOM(NUM).LOCK .NE.-1) THEN
        IF (CCOM(NUM).LOCK .NE. 1) THEN
          WLOCK = .FALSE.
c*             if common is not write locked, lock it
          CALL CC_WRITELOCK_I(NUM,CHOPT,IERR)
          IF (IERR.NE.0) GOTO 999
        ELSE
          WLOCK = .TRUE.
        ENDIF
      ENDIF
c*         flush
      CALL CC_WRITE(NUM,IERR)
      IF (IERR.NE.0) GOTO 999
      IF (CCOM(NUM).LOCK .NE.-1) THEN
        IF (.NOT.WLOCK) THEN
c*             if common was not write locked on entry, release it
          CALL CC_LOCKUP('NL',NUM,IREV,IERR)
          IF (IERR.NE.0) GOTO 999
D         TYPE *,'CC_FLUSH_I Write lock released. IREV=',IREV
          CCOM(NUM).LOCK = 0
          CCOM(NUM).REV = IREV
        ENDIF
      ENDIF
  999 END
c*
c*=======================================================================
c*       UTILITY ROUTINES
c*=======================================================================
c*
      SUBROUTINE CC_VAR_NUM(VARNAME,NUM,IERR)
c*
c*       Given a variable name, gets the associated common no.
c*
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
c*
      IERR=0
      ILOC = %LOC (VARNAME)
      DO I=1,NCCOM
        IF (ILOC.GE.CCOM(I).IFIRST.AND.ILOC.LE.CCOM(I).ILAST) THEN
          NUM=I
          RETURN
        ENDIF
      ENDDO
      CALL LIB$SIGNAL(%VAL(CC_E_BADVAR))
      IERR=CC_E_BADVAR
      END
c************************************************************************
      SUBROUTINE CC_CHR_NUM(CHRNAME,NUM,IERR)
      CHARACTER*(*) CHRNAME
c*
c*       Given a character variable name, gets the associated common no.
c*
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
c*
      IERR=0
      ILOC = %LOC (CHRNAME)
      DO I=1,NCCOM
        IF (ILOC.GE.CCOM(I).IFIRST.AND.ILOC.LE.CCOM(I).ILAST) THEN
          NUM=I
          RETURN
        ENDIF
      ENDDO
      CALL LIB$SIGNAL(%VAL(CC_E_BADVAR))
      IERR=CC_E_BADVAR
      END
c************************************************************************
      SUBROUTINE CC_ID_NUM(COMID,NUM,IERR)
c*
c*       Given a common ID, gets the associated common no.
c*
      CHARACTER*(*) COMID
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
c*
      IERR=0
      DO I=1,NCCOM
D       TYPE *,'ID_NUM: I,COMID,CCOM.COMID ',I,'"',COMID(:LST(COMID)),
D    +    '"    "',CCOM(I).COMID(1:LST(CCOM(I).COMID)),'"'
        IF (COMID(:LST(COMID)).EQ.CCOM(I).COMID(1:LST(CCOM(I).COMID)))
     &    THEN
c**            REV=-1 is the tag for a dead (closed) CC section.
          IF (CCOM(I).REV.NE.-1) THEN
            NUM=I
            RETURN
          ENDIF
        ENDIF
      ENDDO
      CALL LIB$SIGNAL(%VAL(CC_E_BADID),%VAL(1),COMID)
      IERR=CC_E_BADID
      END
c************************************************************************
      SUBROUTINE CC_LIST
c*
c*       Given a common ID, gets the associated common no.
c*
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
c*
      IERR=0
      TYPE *,'NCCOM:',NCCOM
      DO I=1,MIN(NCCOM,CC__MAXCOM)
c**            REV=-1 is the tag for a dead (closed) CC section.
        IF (CCOM(I).REV.NE.-1) THEN
          TYPE *,'"',CCOM(I).COMID(1:LST(CCOM(I).COMID)),'"'
        ELSE
          TYPE *,'"',CCOM(I).COMID(1:LST(CCOM(I).COMID)),'"  (dead)'
        ENDIF
      ENDDO
      END
c************************************************************************
      SUBROUTINE CC_LOCKMAKE(NUM,IREV,IERR)
c*
c*       Sets up lock NAME (in NL mode)
c*
      IMPLICIT INTEGER (A-Z)
      INCLUDE '($LCKDEF)'
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
      IERR=0
D     TYPE *,'Lock create NUM,NAME',NUM,CCOM(NUM).LKST.NAME
c**         create the lock resource, and get a null lock
      IFLAGS = 0
      IF (MOD(CCOM(NUM).AUTH/2,2).EQ.1) IFLAGS = IFLAGS .OR.
     &  LCK$M_SYSTEM
      ISTAT = SYS$ENQW (,%VAL(LCK$K_NLMODE),CCOM(NUM).LKST,
     +    %VAL(IFLAGS),'L3%'//CCOM(NUM).LKST.NAME,,,,,,)
      IF (.NOT.ISTAT) THEN
        CALL LIB$SIGNAL (%VAL(ISTAT))
        IERR=ISTAT
        GOTO 999
      ENDIF
      IF (.NOT.CCOM(NUM).LKST.STATUS) THEN
        CALL LIB$SIGNAL (%VAL(CCOM(NUM).LKST.STATUS))
        IERR=CCOM(NUM).LKST.STATUS
        GOTO 999
      ENDIF
      IREV = CCOM(NUM).LKST.LVB(1)
  999 END
c************************************************************************
      SUBROUTINE CC_LOCKUP(MODE,NUM,IREV,IERR)
      IMPLICIT INTEGER (A-Z)
      CHARACTER MODE*(*)
      LOGICAL LIB$AST_IN_PROG
      IF (LIB$AST_IN_PROG()) THEN
        CALL CC_LOCKUP_A(MODE,NUM,IREV,IERR)
      ELSE
        CALL CC_LOCKUP_N(MODE,NUM,IREV,IERR)
      ENDIF
      END
c************************************************************************
      SUBROUTINE CC_LOCKUP_A(MODE,NUM,IREV,IERR)
c*
c*       Gets lock NAME in desired mode, and reads rev number
c*       Writes LVB if conversion is EX -> NL
c*
      IMPLICIT INTEGER (A-Z)
      CHARACTER MODE*(*)
      INCLUDE '($LCKDEF)'
      INCLUDE '($SSDEF)'
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
      REAL WTIME, DELAY
c*
D     TYPE *,'CC_LOCKUP: Lock in ',MODE,' mode'
c**         convert mode
      ITER=0
      IF (MODE.EQ.'EX') THEN
        IMODE = LCK$K_EXMODE
      ELSE IF (MODE.EQ.'CR') THEN
        IMODE = LCK$K_CRMODE
      ELSE IF (MODE.EQ.'NL') THEN
        IMODE = LCK$K_NLMODE
      ENDIF
c**         increment the LVB if conversion is from EX mode
      IF (CCOM(NUM).LOCK.EQ.1) THEN
D       TYPE *,'CC_LOCKUP: Convert from EX mode. LVB increment'
        CCOM(NUM).LKST.LVB(1)=CCOM(NUM).LKST.LVB(1)+1
      ENDIF
      ISTAT = LIB$GET_EF(IEF)
      IF (.NOT.ISTAT) THEN
        CALL LIB$SIGNAL (%VAL(ISTAT))
        IERR = ISTAT
        GOTO 999
      ENDIF
      IFLAGS = LCK$M_VALBLK .OR. LCK$M_CONVERT
      IF (MOD(CCOM(NUM).AUTH/2,2).EQ.1) IFLAGS = IFLAGS .OR.
     &  LCK$M_SYSTEM
      ISTAT = SYS$ENQ(
     +     %VAL(IEF),%VAL(IMODE),CCOM(NUM).LKST,
     +     %VAL(IFLAGS),'L3%'//CCOM(NUM).LKST.NAME
     +     ,,,,,,)
      IF (ISTAT.EQ.SS$_VALNOTVALID) THEN
      ELSE IF (.NOT.ISTAT) THEN
        CALL LIB$SIGNAL (%VAL(ISTAT))
        IERR = ISTAT
        GOTO 999
      ENDIF
      WTIME=0.
    1 ISTAT = SYS$READEF (%VAL(IEF),ISTATE)
      IF (ISTAT.EQ.SS$_WASCLR) THEN
        ITER=ITER+1
        IF (ITER.GE.4) THEN
          DELAY = 0.01*(ITER-3)
          IF (DELAY.GT.1.0) DELAY=1.0
          CALL L3_WAIT(DELAY)
          WTIME = WTIME + DELAY
        ENDIF
        IF (WTIME.LE.DEFTIMOUT_CC) GOTO 1
        ITIM = WTIME
        CALL LIB$SIGNAL(%VAL(CC_E_LKFAIL),%VAL(3),
     +      MODE,CCOM(NUM).COMID,%VAL(ITIM))
        IERR=CC_E_LKFAIL
        GOTO 999
      ELSE IF (ISTAT.EQ.SS$_WASSET) THEN
      ELSE
        CALL LIB$SIGNAL (%VAL(ISTAT))
        IERR=ISTAT
        GOTO 999
      ENDIF
      IF (.NOT.CCOM(NUM).LKST.STATUS) THEN
        IF (CCOM(NUM).LKST.STATUS.EQ.SS$_VALNOTVALID) THEN
        ELSE
          CALL LIB$SIGNAL (%VAL(CCOM(NUM).LKST.STATUS))
          IERR=CCOM(NUM).LKST.STATUS
          GOTO 999
        ENDIF
      ENDIF
      IREV = CCOM(NUM).LKST.LVB(1)
  999 ISTAT = LIB$FREE_EF(IEF)
      IF (.NOT.ISTAT) CALL LIB$SIGNAL(%VAL(ISTAT))
      END
c************************************************************************
      SUBROUTINE CC_LOCKUP_N(MODE,NUM,IREV,IERR)
c*
c*       Gets lock NAME in desired mode, and reads rev number
c*       Writes LVB if conversion is EX -> NL
c*
      IMPLICIT INTEGER (A-Z)
      CHARACTER MODE*(*)
      INCLUDE '($LCKDEF)'
      INCLUDE '($SSDEF)'
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
      REAL WTIME, DELAY
c*
D     TYPE *,'CC_LOCKUP: Lock in ',MODE,' mode'
c**         convert mode
      ITER=0
      IF (MODE.EQ.'EX') THEN
        IMODE = LCK$K_EXMODE
      ELSE IF (MODE.EQ.'CR') THEN
        IMODE = LCK$K_CRMODE
      ELSE IF (MODE.EQ.'NL') THEN
        IMODE = LCK$K_NLMODE
      ENDIF
c**         increment the LVB if conversion is from EX mode
      IF (CCOM(NUM).LOCK.EQ.1) THEN
D       TYPE *,'CC_LOCKUP: Convert from EX mode. LVB increment'
        CCOM(NUM).LKST.LVB(1)=CCOM(NUM).LKST.LVB(1)+1
      ENDIF
      ISTAT = LIB$GET_EF(IEF)
      IF (.NOT.ISTAT) THEN
        CALL LIB$SIGNAL (%VAL(ISTAT))
        IERR = ISTAT
        GOTO 999
      ENDIF
      IFLAGS = LCK$M_VALBLK .OR. LCK$M_CONVERT
      IF (MOD(CCOM(NUM).AUTH/2,2).EQ.1) IFLAGS = IFLAGS .OR.
     &  LCK$M_SYSTEM
      ISTAT = SYS$ENQ(
     +     %VAL(IEF),%VAL(IMODE),CCOM(NUM).LKST,
     +     %VAL(IFLAGS),'L3%'//CCOM(NUM).LKST.NAME
     +     ,,,,,,)
      IF (ISTAT.EQ.SS$_VALNOTVALID) THEN
      ELSE IF (.NOT.ISTAT) THEN
        CALL LIB$SIGNAL (%VAL(ISTAT))
        IERR = ISTAT
        GOTO 999
      ENDIF
      WTIME=0.
    1 ISTAT = SYS$READEF (%VAL(IEF),ISTATE)
      IF (ISTAT.EQ.SS$_WASCLR) THEN
        ITER=ITER+1
        IF (ITER.GE.4) THEN
          DELAY = 0.01*(ITER-3)
          IF (DELAY.GT.1.0) DELAY=1.0
          CALL L3_WAIT(DELAY)
          WTIME = WTIME + DELAY
        ENDIF
        IF (WTIME.LE.DEFTIMOUT_CC) GOTO 1
        ITIM = WTIME
        CALL LIB$SIGNAL(%VAL(CC_E_LKFAIL),%VAL(3),
     +      MODE,CCOM(NUM).COMID,%VAL(ITIM))
        IERR=CC_E_LKFAIL
        GOTO 999
      ELSE IF (ISTAT.EQ.SS$_WASSET) THEN
      ELSE
        CALL LIB$SIGNAL (%VAL(ISTAT))
        IERR=ISTAT
        GOTO 999
      ENDIF
      IF (.NOT.CCOM(NUM).LKST.STATUS) THEN
        IF (CCOM(NUM).LKST.STATUS.EQ.SS$_VALNOTVALID) THEN
        ELSE
          CALL LIB$SIGNAL (%VAL(CCOM(NUM).LKST.STATUS))
          IERR=CCOM(NUM).LKST.STATUS
          GOTO 999
        ENDIF
      ENDIF
      IREV = CCOM(NUM).LKST.LVB(1)
  999 ISTAT = LIB$FREE_EF(IEF)
      IF (.NOT.ISTAT) CALL LIB$SIGNAL(%VAL(ISTAT))
      END
c************************************************************************
      SUBROUTINE CC_READ(NUM,IERR)
c*
c*       Reads from disk the common pointed to by NUM
c*       here we always use a qiow read into the global section
c*
      IMPLICIT INTEGER (A-Z)
      INCLUDE '($IODEF)'
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
      STRUCTURE /IOSB_REC/
        INTEGER*2 STAT
        INTEGER*4 BYTES
        INTEGER*2 ZERO
      END STRUCTURE
      RECORD/IOSB_REC/IOSB
      EXTERNAL SYS$DELTVA
      INTEGER IDEL(2)
      CHARACTER MPOPT*1
      INTEGER*4 NUMBYTS, NUMBLKS, IBLK, IADD, IBYT
c*
c*       ----------------------------------------------------------------
c*
      IF (CCOM(NUM).IO.EQ.'G') THEN
        MPOPT=' '
        IF (MOD(CCOM(NUM).AUTH,2).EQ.1) MPOPT='R'
c*           Appalling though it is, deleting the virtual memory and
c*           remapping is the only way to update memory from disk.
CCC          STATUS = SYS$DELTVA(CCOM(NUM).IADR,IDEL,)
        STATUS = SYS$DELTVA(CCOM(NUM).IFIRST,IDEL,)
        IF (IDEL(1).NE.CCOM(NUM).IFIRST.OR.IDEL(2).NE.CCOM(NUM).ILAST)
     &    THEN
          CALL LIB$SIGNAL(%VAL(CC_E_GBLIOERR))
          IERR = CC_E_GBLIOERR
          RETURN
        ENDIF
        IF (.NOT.STATUS) THEN
          CALL LIB$SIGNAL(%VAL(STATUS))
          IERR = STATUS
          RETURN
        ELSE IF (IDEL(1).EQ.-1.AND.IDEL(2).EQ.-1) THEN
          CALL LIB$SIGNAL(%VAL(CC_E_DLVMERR))
          IERR = CC_E_DLVMERR
          RETURN
        ENDIF
D       TYPE *,'Creating shared mem "',CCOM(NUM).COMID,'"'
c*           remap to the file (file is still open)
        CALL CC_MAPCOM(NUM,CCOM(NUM).FNAME,
     +    'GS'//CCOM(NUM).COMID,CCOM(NUM).IFIRST,CCOM(NUM).ILAST,
     +    CCOM(NUM).IADR,MPOPT,IERR)
      ELSE
c*
c* here we may need to split up the i/o if it is too large to go in
c* one shot (Governed by cluscom.inc/parameter cc__maxiop)
        NUMBYTS = CCOM(NUM).ILAST-CCOM(NUM).IFIRST+1  ! total bytes to i/o
        NUMBLKS = (NUMBYTS + 511)/512
c*
        DO IBLK = 1, NUMBLKS, CC__MAXIOP
          IADD = 512*(IBLK-1) + CCOM(NUM).IFIRST                  ! in bytes.
          IBYT = MIN( 512*CC__MAXIOP, CCOM(NUM).ILAST - IADD + 1)  ! in bytes.
          STATUS = SYS$QIOW(,                     ! efn
     +                    %VAL(CCOM(NUM).CHAN),     ! chan no
     +                    %VAL(IO$_READVBLK),       ! read-virtual block(s)
     +                    IOSB,                     ! iosb for status
     +                    ,,                        ! no ast, no astpar
     +                    %VAL(IADD),               ! the buffer address in mem.
     +                    %VAL(IBYT),               ! no bytes to read
     +                    %VAL(IBLK),,,)            ! block no. in file.
          IF (.NOT.STATUS) THEN
            CALL LIB$SIGNAL(%VAL(STATUS))
            IERR = STATUS
            RETURN
          ENDIF
D         TYPE *,'CC_READ bytes read:',IOSB.BYTES
          IF (.NOT.IOSB.STAT) THEN
            CALL LIB$SIGNAL(%VAL(IOSB.STAT))
            IERR = IOSB.STAT
            RETURN
          ENDIF
        ENDDO                      ! IBLK
      ENDIF
      END
c************************************************************************
      SUBROUTINE CC_WRITE(NUM,IERR)
c*
c*       Writes to disk the common pointed to by NUM
c*       Use UpDSecW if in global mode, else use $QIOW
c*
c*
      IMPLICIT INTEGER (A-Z)
      INCLUDE '($IODEF)'
      INCLUDE '($SSDEF)'
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
      STRUCTURE /IOSB_REC/
        INTEGER*2 STAT
        INTEGER*4 BYTES
        INTEGER*2 ZERO
      END STRUCTURE
      RECORD/IOSB_REC/IOSB
      INTEGER MEMAREA(2), MEMSEC(2)
      EXTERNAL SYS$UPDSECW, SYS$WAITFR
      STRUCTURE /IO_BLOCK/
        INTEGER*2 IOSTAT, HARDWARE
        INTEGER*4 BAD_PAGE
      END STRUCTURE
      INTEGER IUPD(2)
      RECORD /IO_BLOCK/ IOSTAT
      INTEGER*4 NUMBYTS, NUMBLKS, IBLK, IADD, IBYT
c*
c*       ----------------------------------------------------------------
c*
      IF (CCOM(NUM).IO.EQ.'G') THEN
CCC          STATUS = SYS$UPDSECW(CCOM(NUM).IADR,,,,,IOSTAT,,)
c*           update flag is set to indicate only modified pages should
c*           be written
        CALL LIB$GET_EF(MYEF)
        CALL SYS$CLREF(%VAL(MYEF))
CCC          STATUS = SYS$UPDSECW(CCOM(NUM).IFIRST,IUPD,,%VAL(1),,IOSTAT,,)
        STATUS = SYS$UPDSEC(CCOM(NUM).IFIRST,IUPD,,%VAL(1),%VAL(MYEF),
     +    IOSTAT,,)
        STATUS = SYS$WAITFR (%VAL(MYEF))
        IF (.NOT.STATUS) THEN
          CALL LIB$SIGNAL(%VAL(STATUS))
          IERR = STATUS
          RETURN
        ENDIF
        CALL LIB$FREE_EF(MYEF)
        IF (IUPD(1).NE.CCOM(NUM).IFIRST.OR.IUPD(2).NE.CCOM(NUM).ILAST)
     &    THEN
          CALL LIB$SIGNAL(%VAL(CC_E_GBLIOERR))
          IERR = CC_E_GBLIOERR
          RETURN
        ENDIF
        IF (.NOT.STATUS) THEN
          CALL LIB$SIGNAL(%VAL(STATUS))
          IERR = STATUS
          RETURN
        ENDIF
        IF (IOSTAT.IOSTAT.NE.SS$_NORMAL) THEN
          ISTAT = IOSTAT.IOSTAT
          CALL LIB$SIGNAL(%VAL(ISTAT))
          IERR = IOSTAT.IOSTAT
          RETURN
        ENDIF
        IF (IOSTAT.BAD_PAGE.NE.CCOM(NUM).ILAST+1) THEN
          CALL LIB$SIGNAL(%VAL(CC_E_UPDSEC),%VAL(2),
     &      %VAL(IOSTAT.BAD_PAGE), %VAL(CCOM(NUM).ILAST))
          IERR = CC_E_UPDSEC
          RETURN
        ENDIF
      ELSE
c*
c* here we may need to split up the i/o if it is too large to go in
c* one shot (Governed by cluscom.inc/parameter cc__maxiop)
        NUMBYTS = CCOM(NUM).ILAST-CCOM(NUM).IFIRST+1  ! total bytes to i/o
        NUMBLKS = (NUMBYTS + 511)/512
c*
        DO IBLK = 1, NUMBLKS, CC__MAXIOP
          IADD = 512*(IBLK-1) + CCOM(NUM).IFIRST                  ! in bytes.
          IBYT = MIN( 512*CC__MAXIOP, CCOM(NUM).ILAST - IADD + 1)  ! in bytes.
          STATUS = SYS$QIOW(,                     ! efn
     +                    %VAL(CCOM(NUM).CHAN),     ! chan no
     +                    %VAL(IO$_WRITEVBLK),      ! write-virtual block(s)
     +                    IOSB,                     ! iosb for status
     +                    ,,                        ! no ast, no astpar
     +                    %VAL(IADD),               ! the buffer address in mem.
     +                    %VAL(IBYT),               ! no bytes to read
     +                    %VAL(IBLK),,,)            ! block no. in file.
          IF (.NOT.STATUS) THEN
            CALL LIB$SIGNAL(%VAL(STATUS))
            IERR = STATUS
            RETURN
          ENDIF
D         TYPE *,'CC_WRITE bytes read:',IOSB.BYTES
          IF (.NOT.IOSB.STAT) THEN
            CALL LIB$SIGNAL(%VAL(IOSB.STAT))
            IERR = IOSB.STAT
            RETURN
          ENDIF
        ENDDO                      ! IBLK
      ENDIF
      END
c************************************************************************
      INTEGER FUNCTION CCF_CREATE(FAB,RAB,LUN)
c*
c*       Sets up user IO to file
c*
      IMPLICIT INTEGER (A-Z)
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
c*         RAB, FAB for local use
      RECORD /RABDEF/ RAB            ! dummy for fortran - not used
      RECORD /FABDEF/ FAB
c*
      INCLUDE '($XABPRODEF)'
      INCLUDE '($XABDEF)'
      STRUCTURE /XABTEMP/
        UNION
          MAP
            RECORD /XABPRODEF1/ XABPRO
          END MAP
          MAP
            RECORD /XABDEF/ XAB
          END MAP
        END UNION
      END STRUCTURE
      RECORD /XABTEMP/ MYXABPRO
c*
c*       ----------------------------------------------------------------
c*
c**        set protection in XAB
      MYXABPRO.XAB.XAB$B_COD = XAB$C_PRO
      MYXABPRO.XAB.XAB$B_BLN = XAB$C_PROLEN
      MYXABPRO.XABPRO.XAB$W_PRO =
     +     XAB$M_NODEL*2**XAB$V_GRP +
     +     XAB$M_NODEL*2**XAB$V_WLD
      MYXABPRO.XAB.XAB$L_NXT = 0
      FAB.FAB$L_XAB = %LOC(MYXABPRO)
c**        multi stream access
C        FAB.FAB$B_SHR = FAB.FAB$B_SHR .OR. FAB$M_SHRMSE .OR. FAB$M_UPI
c**        user file open
      FAB.FAB$L_FOP = FAB.FAB$L_FOP .OR. FAB$M_UFO

      FAB.FAB$B_FAC = FAB.FAB$B_FAC .OR. FAB$M_GET
      FAB.FAB$B_SHR = FAB.FAB$B_SHR .OR. FAB$M_SHRGET .OR. FAB$M_UPI
      IF (MOD(CCOM(NCURRENT).AUTH,2).EQ.0) THEN
c*           write access
        FAB.FAB$B_FAC = FAB.FAB$B_FAC .OR. FAB$M_PUT
        FAB.FAB$B_SHR = FAB.FAB$B_SHR .OR. FAB$M_SHRPUT
      ENDIF
c*
c**        create file
      STATUS = SYS$CREATE(FAB)
      IF (.NOT.STATUS) THEN
        CALL LIB$SIGNAL(%VAL(STATUS))
        GOTO 999
      ENDIF
c**        read channel from FAB status word
      CCOM(NCURRENT).CHAN = FAB.FAB$L_STV
c**        save FAB
      CCOM(NCURRENT).FAB=FAB
c**        return status
  999 CCF_CREATE = STATUS
      END
c************************************************************************
      INTEGER FUNCTION CCF_OPEN(FAB,RAB,LUN)
c*
c*       Sets up user IO to file
c*
      IMPLICIT INTEGER (A-Z)
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
c*         RAB, FAB for local use
      RECORD /RABDEF/ RAB            ! dummy for fortran - not used
      RECORD /FABDEF/ FAB
c*
c*       ----------------------------------------------------------------
c*
c**        multi stream access
C        FAB.FAB$B_SHR = FAB.FAB$B_SHR .OR. FAB$M_SHRMSE .OR. FAB$M_UPI
c**        user file open
      FAB.FAB$L_FOP = FAB.FAB$L_FOP .OR. FAB$M_UFO

      FAB.FAB$B_FAC = FAB.FAB$B_FAC .OR. FAB$M_GET
      FAB.FAB$B_SHR = FAB.FAB$B_SHR .OR. FAB$M_SHRGET .OR. FAB$M_UPI
      IF (MOD(CCOM(NCURRENT).AUTH,2).EQ.0) THEN
c*           write access
        FAB.FAB$B_FAC = FAB.FAB$B_FAC .OR. FAB$M_PUT
        FAB.FAB$B_SHR = FAB.FAB$B_SHR .OR. FAB$M_SHRPUT
      ENDIF
c*
c**        open file
      STATUS = SYS$OPEN(FAB)
      IF (.NOT.STATUS) THEN
        CALL LIB$SIGNAL(%VAL(STATUS))
        GOTO 999
      ENDIF
c**        read channel from FAB status word
      CCOM(NCURRENT).CHAN = FAB.FAB$L_STV
c**        save FAB
      CCOM(NCURRENT).FAB=FAB
c**        return status
  999 CCF_OPEN = STATUS
      END
c************************************************************************
      SUBROUTINE CC_MAPCOM(NUM,FNAME,GSNAME,START,END,IADR,CHOPT,IERR)
c*
c*       Creates mapping to disk file as a global section.
c*
      IMPLICIT INTEGER (A-Z)
      INTEGER IADR(*)
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
      INCLUDE '($SECDEF)'
      EXTERNAL GBL_CREATE, GBL_OPEN, SS$_NORMAL, SS$_NOSUCHSEC
      CHARACTER*(*) FNAME, CHOPT, GSNAME
      INTEGER START, END
      LOGICAL ISTAT, SYS$MGBLSC, SYS$CRMPSC, SYS$CREATE, SECFLG
      CHARACTER FSTAT*7
c*
c*       ----------------------------------------------------------------
c*
      IERR = 0
c*
c**        Try mapping global section (system gbl sec; SYSGBL priv needed)
      IMASK = SEC$M_SYSGBL
c*         readonly or write
      IF (INDEX(CHOPT,'R').EQ.0) IMASK = IMASK .OR. SEC$M_WRT
      ISTAT = SYS$MGBLSC( CCOM(NUM).IFIRST, IADR,, %VAL(IMASK),
     &        GSNAME,,)
      IF ( ISTAT.EQ.%LOC(SS$_NORMAL) ) THEN
c**         If shared region exists, return.
        RETURN
      ELSE IF ( ISTAT .NE. %LOC( SS$_NOSUCHSEC ) ) THEN
        CALL LIB$SIGNAL( %VAL( ISTAT ) )
        IERR = ISTAT
        RETURN
      ENDIF
c*
c***        Map the shared region. Create the section.
      IF (INDEX(CHOPT,'C').NE.0) THEN
c**          Create/open the file.
        LENGTH = ( CCOM(NUM).ILAST - CCOM(NUM).IFIRST +1 )/512  ! # blocks
        IF (INDEX(CHOPT,'N').EQ.0) THEN
          FSTAT = 'UNKNOWN'
        ELSE
          FSTAT = 'NEW    '
        ENDIF
        NCURRENT=NUM
        ISTAT = LIB$GET_LUN(LUN)
        IF (.NOT.ISTAT) THEN
          CALL LIB$SIGNAL( %VAL( ISTAT ) )
          IERR = ISTAT
          RETURN
        ENDIF
        CCOM(NUM).LUN = LUN
        IF (INDEX(CHOPT,'R').EQ.0) THEN
          OPEN(UNIT=LUN,FILE=FNAME,STATUS=FSTAT,INITIALSIZE=
     +      LENGTH,USEROPEN=GBL_CREATE)
        ELSE
          OPEN(UNIT=LUN,FILE=FNAME,STATUS='OLD',INITIALSIZE=
     +      LENGTH,USEROPEN=GBL_OPEN,READONLY)
        ENDIF
        CLOSE(LUN)
        CALL LIB$FREE_LUN(LUN)
      ENDIF
c*
c**        Pages form read/write global section
      SECFLG = SEC$M_GBL .OR. SEC$M_SYSGBL
      IF (INDEX(CHOPT,'R').EQ.0) SECFLG = SECFLG .OR. SEC$M_WRT ! Read/write
c*
c**        Initialize to zero
      IF (INDEX(CHOPT,'Z').NE.0) SECFLG = SECFLG .OR. SEC$M_DZRO
c*
c***       Create mapping between file and common block
      ISTAT = SYS$CRMPSC( CCOM(NUM).IFIRST,IADR,,
     &  %VAL( SECFLG ), GSNAME,,,
     +  %VAL( CCOM(NUM).CHAN ),
     &  %VAL( CCOM(NUM).FAB.FAB$L_ALQ),,, )
      IF (IADR(1).NE.CCOM(NUM).IFIRST.OR.IADR(2).NE.CCOM(NUM).ILAST)
     &  THEN
        CALL LIB$SIGNAL(%VAL(CC_E_GBLIOERR))
        IERR = CC_E_GBLIOERR
        RETURN
      ENDIF
      IF ( ISTAT.NE. %LOC(SS$_NORMAL) ) THEN
        CALL LIB$SIGNAL( %VAL( ISTAT ) )
        IERR = ISTAT
        RETURN
      ENDIF
      END
c************************************************************************
      INTEGER FUNCTION GBL_CREATE(FAB,RAB,LUN)
c*
c*       Sets up block IO to file, storing RAB in data structure pointed
c*       to by NCURRENT
c*
      IMPLICIT INTEGER (A-Z)
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
c*         RAB, FAB for local use
      RECORD /RABDEF/ RAB
      RECORD /FABDEF/ FAB
c*
      INCLUDE '($XABPRODEF)'
      INCLUDE '($XABDEF)'
      STRUCTURE /XABTEMP/
        UNION
          MAP
            RECORD /XABPRODEF1/ XABPRO
          END MAP
          MAP
            RECORD /XABDEF/ XAB
          END MAP
        END UNION
      END STRUCTURE
      RECORD /XABTEMP/ MYXABPRO
c*
c*       ----------------------------------------------------------------
c*
c**        set protection in XAB
      MYXABPRO.XAB.XAB$B_COD = XAB$C_PRO
      MYXABPRO.XAB.XAB$B_BLN = XAB$C_PROLEN
      MYXABPRO.XABPRO.XAB$W_PRO =
     +     XAB$M_NODEL*2**XAB$V_GRP +
     +     XAB$M_NODEL*2**XAB$V_WLD
      MYXABPRO.XAB.XAB$L_NXT = 0
      FAB.FAB$L_XAB = %LOC(MYXABPRO)
c**        multi stream access
C        FAB.FAB$B_SHR = FAB.FAB$B_SHR .OR. FAB$M_SHRMSE .OR. FAB$M_UPI
c**        user file open
      FAB.FAB$L_FOP = FAB.FAB$L_FOP .OR. FAB$M_UFO

      FAB.FAB$B_FAC = FAB.FAB$B_FAC .OR. FAB$M_GET
      FAB.FAB$B_SHR = FAB.FAB$B_SHR .OR. FAB$M_SHRGET .OR. FAB$M_UPI
      IF (MOD(CCOM(NCURRENT).AUTH,2).EQ.0) THEN
c*           write access
        FAB.FAB$B_FAC = FAB.FAB$B_FAC .OR. FAB$M_PUT
        FAB.FAB$B_SHR = FAB.FAB$B_SHR .OR. FAB$M_SHRPUT
      ENDIF

c*
c**        create file
      STATUS = SYS$CREATE(FAB)
      IF (.NOT.STATUS) THEN
        CALL LIB$SIGNAL(%VAL(STATUS))
        GOTO 999
      ENDIF
c**        read channel from FAB status word
      CCOM(NCURRENT).CHAN = FAB.FAB$L_STV
c**        save FAB
      CCOM(NCURRENT).FAB=FAB
c**        return status
  999 GBL_CREATE = STATUS
      END
c************************************************************************
      INTEGER FUNCTION GBL_OPEN(FAB,RAB,LUN)
c*
c*       Sets up block IO to file, storing RAB in data structure pointed
c*       to by NCURRENT
c*
      IMPLICIT INTEGER (A-Z)
      INCLUDE 'D0$PARAMS:CPCERR.PARAMS'
      INCLUDE 'D0$INC:CLUSCOM.INC'
c*         RAB, FAB for local use
      RECORD /RABDEF/ RAB
      RECORD /FABDEF/ FAB
c*
c*       ----------------------------------------------------------------
c*
c**        multi stream access
C        FAB.FAB$B_SHR = FAB.FAB$B_SHR .OR. FAB$M_SHRMSE .OR. FAB$M_UPI
c**        user file open
      FAB.FAB$L_FOP = FAB.FAB$L_FOP .OR. FAB$M_UFO

      FAB.FAB$B_FAC = FAB.FAB$B_FAC .OR. FAB$M_GET
      FAB.FAB$B_SHR = FAB.FAB$B_SHR .OR. FAB$M_SHRGET .OR. FAB$M_UPI
      IF (MOD(CCOM(NCURRENT).AUTH,2).EQ.0) THEN
c*           write access
        FAB.FAB$B_FAC = FAB.FAB$B_FAC .OR. FAB$M_PUT
        FAB.FAB$B_SHR = FAB.FAB$B_SHR .OR. FAB$M_SHRPUT
      ENDIF

c*
c**        open file
      STATUS = SYS$OPEN(FAB)
      IF (.NOT.STATUS) THEN
        CALL LIB$SIGNAL(%VAL(STATUS))
        GOTO 999
      ENDIF
c**        read channel from FAB status word
      CCOM(NCURRENT).CHAN = FAB.FAB$L_STV
c**        save FAB
      CCOM(NCURRENT).FAB=FAB
c**        return status
  999 GBL_OPEN = STATUS
      END
