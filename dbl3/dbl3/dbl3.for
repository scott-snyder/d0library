C- DBL3 VERSION 310
C- Prepared without CPC server option 
C- Prepared with CERN library CNL203
C-                                           (S. Abachi)
C-
      SUBROUTINE DBABRD (PATHN, LBK, LUN, ITIME, KEYS, CHOPT)   
*     ======================================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBABRD (PATHN, *LBK*, LUN, ITIME, KEYS, CHOPT)          *    
*                                                                      *    
*   Prepares the database data structure in memory for any required    *    
*   Pathname (for ASCII objects) and set of Keys, unless already done. *    
*   Returns (optionally) the addresses in memory for the corresponding *    
*   Key banks after checking their validity for the given time and     *    
*   keys. Also writes the ASCII format on a given file specified.      *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     LBK(*)   Address(es) of Keys bank(s) KYDB   (INPUT or OUTPUT)    *    
*              For option 'S' it is the support address of the linear  *    
*              structure                                               *    
*              For option 'M' with selection on user keys 8 and 9,     *    
*              LBK(k) is the address corresponding to the ith Key-8    *    
*              and the jth Key-9 value, where k = KEYS(8) * (j-1) + i  *    
*     LUN      Logical unit number of the file with ASCII data         *    
*              (0 if no output conversion is required)                 *    
*     ITIME    Event data acquisition time (or 0, if Data not wanted)  *    
*     KEYS     Vector of keys. Only the elements declared in CHOPT are *    
*              assumed to contain useful information.                  *    
*              When option 'M' is declared KEYS(n) (when user Key n    *    
*              is selected should contain the number of data objects   *    
*              to be retrieved according to the KEYS(n) values and     *    
*              the values of the key elements for Key-n to be matched  *    
*              should be stored in successive KEYS(i) elements, with   *    
*              i starting from NWKEY+1 (NWKEY is the number of key     *    
*              elements for this directory)                            *    
*     CHOPT    Character string with any of the following characters   *    
*          A   trust LBK address(es) if non-zero                       *    
*          K   read only the keys (no data is required)                *    
*          M   expect multiple Key banks to be returned (only up to    *    
*              a maximum of 5 user keys)                               *    
*          S   expect multiple Key banks satisfying selection on a     *    
*              number of keys (Options S and M are mutually exclusive) *    
*          V   declare the Data as being different in size to what is  *    
*              already resident in memory                              *    
*          3   selects objects with start validity time < KEYS(3)      *    
*              (with option S)                                         *    
*          4   selects objects with end validity time > KEYS(4)        *    
*              (with option S)                                         *    
*          5   specific Program version number required                *    
*          7   select objects with insertion time < KEYS(7)            *    
*          n   consider user key n (where 7 < n < 29 )                 *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =  1 : Illegal character option                        *    
*               =  2 : Illegal path name                               *    
*               =  4 : Illegal key option                              *    
*                                                                      *    
*     If IQUEST(1) =0, IQUEST(2) carries information whether data      *    
*     part had been actually read from the disk or not                 *    
*     IQUEST(2) =  0 : No disk i/o has been performed                  *    
*               =  1 : Data have been refreshed from the disk          *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      DIMENSION       KEYS(9), LBK(9)   
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, KLINE*80   
*   
*     ------------------------------------------------------------------    
*   
* *** Initialize options    
*   
      LREFDB(1) = LBK(1)    
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)     GO TO 999 
      IF (IOPMDA.NE.0 .AND. IOPSDA.NE.0) THEN   
        IQUEST(1) = 1   
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBABRD : Illegal'//    
     +  ' Character option - S/M options are mutually exclusive'')',    
     +  IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Create (or complete) database skeleton in memory  
*                       (banks NODB and KYDB)   
*   
      IF (ITIME.EQ.0 .OR. IOPADA.EQ.0. OR.  
     +   (IOPADA.NE.0. AND. LREFDB(1).EQ.0) )  THEN 
*   
        CALL DBNODE (PATH, LBNODB)  
        IF (IQUEST(1).NE.0)   GO TO 999 
*   
        CALL DBKEYS (LBNODB, KEYS, LBK, ITIME)  
        IF (IQUEST(1).NE.0)   GO TO 999 
        LREFDB(1) = LBK(1)  
*   
*  *    That's it, when only initialisation required    
*   
        IQUEST(2) = 0   
        IF (ITIME.EQ.0)       GO TO 999 
*   
      ELSE  
*   
        CALL RZCDIR (PATH, ' ') 
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1) = 2 
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBABRD : Illeg'//    
     +    'al path name '//PATH(1:80)//''')', IARGDB, 0)    
          GO TO 999 
        ENDIF   
        NKEYDK = IQUEST(7)  
        NWKYDK = IQUEST(8)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
*   
        IF (IOPSDA.NE.0)  THEN  
          LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)  
          CALL DBKEYS (LBNODB, KEYS, LBK, ITIME)    
          IF (IQUEST(1).NE.0) GO TO 999 
          LREFDB(1) = LBK(1)    
        ENDIF   
      ENDIF 
*   
* *** Get number of Data banks needed   
*   
      NKYMX  = 1    
      IF (IOPMDA.NE.0)  THEN    
        IF (NWKYDK.GT.NSYSDK)  THEN 
          DO 60 I = NSYSDK+1, NWKYDK    
            IF (IOKYDA(I).NE.0) THEN    
              IF (KEYS(I).LE.0)  THEN   
*   
*  **           Illegal key option  
*   
                IQUEST(1)  = 4  
                IQUEST(11) = I  
                IQUEST(12) = KEYS(I)    
                IF (IDEBDB.GT.0) THEN   
                  IARGDB(1) = IQUEST(12)    
                  IARGDB(2) = IQUEST(11)    
                  CALL DBPRNT (LPRTDB, '(/,'' DBABRD : Illegal key op'//    
     +                 'tion '',I3,'' for key '',I3,'' with option M'')'    
     +,                IARGDB, 2)   
                ENDIF   
                GO TO 999   
              ENDIF 
*   
              NKYMX  = NKYMX * KEYS(I)  
            ENDIF   
   60     CONTINUE  
        ENDIF   
      ENDIF 
*   
* *** Number of Key banks in S mode 
*   
      IF (IOPSDA.NE.0)  THEN    
        LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)    
        LBKYDB = LREFDB(1)  
        NKYMX  = NZBANK (IDIVDB, LBKYDB)    
      ENDIF 
*   
* *** Create (or update) Data bank(s)   
*   
      IQUEST(2) = 0 
      I = 0 
  100 I = I + 1 
      IF (IOPSDA.EQ.0)  THEN    
        LBKYDB = LBK(I) 
      ENDIF 
      LBDADB = LQ(KOFUDB+LBKYDB-KLDADB) 
      CALL DBCHCK (LBKYDB, ITIME, KEYS, LBDADB) 
      IF (IQUEST(1).NE.0)     GO TO 999 
      IF (LUN.GT.0) THEN    
        IF (LBDADB.GT.0) THEN   
          NDATA  = IQ(KOFUDB+LBDADB-1)  
          IF (NDATA.GT.0) THEN  
*   
*   *       Display data if exists, if it does not, display dummy data  
*   
            NTOT   = 0  
            CALL UCOPY_i (IQ(KOFUDB+LBKYDB+1), KEYVDK(1), NWKYDK) 
            NREC   = 0  
  120       IF (NTOT.LT.NDATA) THEN 
              CALL DBLIND (IQ(KOFUDB+LBDADB+1), NTOT, KLINE, LENG)  
              IF (LENG.GT.0) THEN   
                WRITE (LUN, 1000) KLINE(1:LENG) 
              ELSE  
                WRITE (LUN, *)  
              ENDIF 
              NREC   = NREC + 1 
              GO TO 120 
            ENDIF   
            IF (IDEBDB.GT.1) THEN   
              IARGDB(1) = NREC  
              IARGDB(2) = I 
              CALL DBPRNT (LPRTDB, '(/,'' DBABRD : '',I10,'' records '//    
     +             'written for set '',I4)', IARGDB, 2) 
            ENDIF   
          ENDIF 
        ENDIF   
      ENDIF 
      IF (IOPSDA.EQ.0)  THEN    
        IF (I.LT.NKYMX)       GO TO 100 
      ELSE  
        LBKYDB = LQ(KOFUDB+LBKYDB)  
        IF (LBKYDB.NE.0)      GO TO 100 
      ENDIF 
*   
 1000 FORMAT (A)    
*                                                             END DBABRD    
  999 END   
      SUBROUTINE DBABWR (PATHN, LBK, LUN, NWKEY, KEY, KEYO, CHOPT)  
*     ============================================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBABWR (PATHN, *LBK*, LUN, NWKEY, KEY, KEYO, CHOPT)     *    
*                                                                      *    
*   Stores ASCII data from a disk file to the data base and also enters*    
*   in the memory ala DBUSE in NODE/KEY structure                      *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     LBK(*)   Address of Keys bank KYDB   (INPUT or OUTPUT)           *    
*     LUN      Logical unit number of the file where ASCII data reside *    
*     NWKEY    Number of keys associated with the data bank            *    
*     KEY      Vector of keys                                          *    
*     KEYO     Old vector of keys (for option X only)                  *    
*     CHOPT    Character string with any of the following characters   *    
*          A   trust LBK address if non-zero                           *    
*          B   Save in the special backup file; not in standard Journal*    
*          C   create Node/Key data structure ala DBUSE                *    
*          X   Replaces an old set of keys                             *    
*          7   Insertion time as supplied by user to be honoured       *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 61 : Too many keys                                   *    
*               = 66 : Illegal logical unit number                     *    
*               = 67 : File too long; no space in buffer               *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      COMMON /DZPACK/ PRECDZ, PACKDZ    
      LOGICAL         PACKDZ    
*   
      DIMENSION       KEY(9), KEYO(9), LBK(9)   
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, KLINE*80   
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension nio(9)
*     ------------------------------------------------------------------    
*   
* *** Decode the character option   
*   
      LREFDB(1) = LBK(1)    
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)     GO TO 999 
      PACKDZ = .FALSE.  
*   
      IOPKDA = 0    
      IOPRDA = 1    
      IOPSDA = 0    
      IOPTDA = 1    
      IOPUDA = 0    
      IOPZDA = 0    
*   
* *** Check the number of keys  
*   
      IF (NWKEY.GT.MXDMDK)  THEN    
        IQUEST(1) = 61  
        IQUEST(11)= NWKEY   
        IQUEST(12)= MXDMDK  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBABWR : Too man'//    
     +  'y keys '',I6,'' maximum permitted '',I6)', IQUEST(11), 2)  
        GO TO 999   
      ENDIF 
*   
      IF (LUN.LE.0) THEN    
        IQUEST(1) = 66  
        IQUEST(11)= LUN 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBABWR : Illegal'//    
     +  ' unit number '',I10,'' for ASCII file'')', IQUEST(11), 1)  
        GO TO 999   
      ENDIF 
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
      IF (NWKEY.GE.NSYSDK)  THEN    
        NTKEY  = NWKEY  
      ELSE  
        NTKEY  = NINEDK 
      ENDIF 
*   
* *** Prepare the output with old keys if option X is selected  
*   
      IF (IOPXDA.NE.0) THEN 
        CALL VZERO_i (KEYVDK, MXDMDK) 
        KEYVDK(MBVRDB) = KEY(MBVRDB)    
        KEYVDK(MEVRDB) = KEY(MEVRDB)    
        KEYVDK(MPVSDB) = KEYO(MPVSDB)   
        IOKYDA(MPVSDB) = 1  
        KEYVDK(MFLGDB) = MSBIT1 (KEYVDK(MFLGDB), JIGNDB)    
        IF (IOKYDA(MITMDB).NE.0) KEYVDK(MITMDB) = KEY(MITMDB)   
        IF (NWKEY.GT.NSYSDK) THEN   
          DO 10 NK = NSYSDK+1, NWKEY    
            IOKYDA(NK) = 1  
            KEYVDK(NK) = KEYO(NK)   
   10     CONTINUE  
        ENDIF   
*   
        IF (LSTRDL(3).NE.0) CALL MZDROP (IDISDB, LSTRDL(3), 'L')    
        JBIAS  = 2
        nio(1) = 2
        CALL DBBOOK (IDISDB, LSTRDL(3), LSTRDL(3), JBIAS, 'SAME', 0, 0, 
     +               0, nio, 0)   
        IF (IQUEST(1).NE.0)   GO TO 999 
*   
        CALL DBKOUT (PATH, IDISDB, LSTRDL(3), NTKEY, KEYVDK, 0) 
        IF (IQUEST(1).NE.0)   GO TO 999 
        IF (LSTRDL(3).NE.0) THEN    
          CALL MZDROP (IDISDB, LSTRDL(3), 'L')  
          LSTRDL(3) = 0 
        ENDIF   
      ENDIF 
*   
* *** Prepare the Key vector array  
*   
      CALL VZERO_i (KEYVDK, MXDMDK)   
      KEYVDK(MBVRDB) = KEY(MBVRDB)  
      KEYVDK(MEVRDB) = KEY(MEVRDB)  
      KEYVDK(MPVSDB) = KEY(MPVSDB)  
      IOKYDA(MPVSDB) = 1    
      IF (IOKYDA(MITMDB).NE.0) KEYVDK(MITMDB) = KEY(MITMDB) 
      IF (NWKEY.GT.NSYSDK) THEN 
        DO 20 NK = NSYSDK+1, NWKEY  
          IOKYDA(NK) = 1    
          KEYVDK(NK) = KEY(NK)  
   20   CONTINUE    
      ENDIF 
*   
*  ** Read the data part    
*   
      IF (LSTRDL(3).NE.0) CALL MZDROP (IDIVDB, LSTRDL(3), 'L')  
      NDATA  = NDMXDB   
      JBIAS  = 2
      nio(1) = 1
      CALL DBBOOK (IDIVDB, LSTRDL(3), LSTRDL(3), JBIAS, 'USER', 0, 0,   
     +             NDATA, nio, -1)    
      IF (IQUEST(1).NE.0)     GO TO 999 
*   
*  ** Now read the file 
*   
      NDAT   = 0    
      NREC   = 0    
   25 READ (LUN, 1000, ERR=30, END=30) KLINE    
      NREC   = NREC + 1 
      LENG   = LENOCC (KLINE)   
      CALL DBLINC (KLINE, LENG, IQ(KOFUDB+LSTRDL(3)+1), NDAT)   
      IF (NDAT.GT.NDATA-20) THEN    
        IQUEST(1) = 67  
        IQUEST(11)= NREC    
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBABWR : Buffer '//    
     +  'full after '',I8,'' records'')', IQUEST(11), 1)    
        GO TO 990   
      ENDIF 
      GO TO 25  
*   
   30 NDP    = NDAT - NDATA 
      IF (NDP.LT.0) CALL MZPUSH (IDIVDB, LSTRDL(3), 0, NDP, 'I')    
*   
* *** Write out the data    
*   
      CALL DBKOUT (PATH, IDIVDB, LSTRDL(3), NTKEY, KEYVDK, 0)   
      IF (IQUEST(1).NE.0)     GO TO 990 
*   
* *** Create data bank in memory ala DBUSE  
*   
      IF (IOPCDA.NE.0)  THEN    
*   
*  **   Create database skeleton in memory (banks NODB and KYDB)    
*   
        IF (IOPADA.EQ.0. OR. (IOPADA.NE.0. AND. LREFDB(1).EQ.0) )  THEN 
*   
          CALL DBNODE (PATH, LBNODB)    
          IF (IQUEST(1).NE.0) GO TO 990 
*   
*  *      Switch off M and/or S option of DBUSE 
*   
          IOPMDA = 0    
          IOPSDA = 0    
*   
          CALL DBKEYS (LBNODB, KEYVDK, LBK, KEYVDK(MBVRDB)) 
          IF (IQUEST(1).NE.0) GO TO 990 
          LREFDB(1) = LBK(1)    
          CALL UCOPY_i (KEYVDK(1), IQ(KOFUDB+LREFDB(1)+1), NWKYDK)    
          NDK    = IQ(KOFUDB+LREFDB(1)-1)   
          IQ(KOFUDB+LREFDB(1)+NDK+MKYFRI) = 0   
          IQ(KOFUDB+LREFDB(1)+NWKYDK+1)   = KEYVDK(MEVRDB)  
*   
        ELSE    
*   
          CALL UCOPY_i (KEYVDK(1), IQ(KOFUDB+LREFDB(1)+1), NWKYDK)    
          NDK    = IQ(KOFUDB+LREFDB(1)-1)   
          IQ(KOFUDB+LREFDB(1)+NDK+MKYFRI) = 0   
          IQ(KOFUDB+LREFDB(1)+NWKYDK+1)   = KEYVDK(MEVRDB)  
        ENDIF   
*   
*  **   Now copy the data banks appended at LSUP to the key bank    
*   
        CALL ZSHUNT (IDIVDB, LSTRDL(3), LREFDB(1), -1, 0)   
        LSTRDL(3) = 0   
        IQUEST(1) = 0   
      ENDIF 
*   
  990 IF (LSTRDL(3).NE.0) THEN  
        IERR   = IQUEST(1)  
        CALL MZDROP (IDIVDB, LSTRDL(3), 'L')    
        LSTRDL(3) = 0   
        IQUEST(1) = IERR    
      ENDIF 
*   
 1000 FORMAT (A80)  
*                                                             END DBABWR    
  999 END   
      SUBROUTINE DBCRSD (PATH, NKEX, CHFOR, CHTAG, MXKP, CHOPT) 
*     ========================================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBCRSD (PATH, NKEX, CHFOR, CHTAG, MXKP, CHOPT)          *    
*                                                                      *    
*   Creates a L3 directory with standard keys plus NKEX extra keys     *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATH     Character string describing the pathname                *    
*     NKEX     Number of user keys                                     *    
*     CHFOR    Character string specifying the user key type           *    
*     CHTAG    String of 8-character tags for the user key elements    *    
*     MXKP     Maximum number of objects in a partitioned directory    *    
*     CHOPT    Character string with any of the following characters   *    
*          P   Create partitioned subdirectories for the pathname      *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 43 : Illegal number of user keys                     *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER*(*)   PATH, CHTAG(*), CHFOR, CHOPT  
      CHARACTER       CFOR*100  
*   
*     ------------------------------------------------------------------    
*   
* *** Decode the character option   
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0) GO TO 999 
      KEY7DK = 0    
*   
* *** Check the number of user keys 
*   
      IF (NKEX.LT.0.OR.NKEX.GT.MXDMDK-NSYSDK) THEN  
        IQUEST(1) = 43  
        IQUEST(11)= NKEX    
        IQUEST(12)= MXDMDK - NSYSDK 
        IF (IDEBDB.GT.0) THEN   
          CFOR   = PATH 
          CALL DBPRNT (LPRTDB, '(/,'' DBCRSD : Illegal number of user'//    
     +         ' keys '',2I12,'' for '',/,''        '//CFOR//''')', 
     +         IQUEST(11), 2)   
        ENDIF   
        GO TO 999   
      ENDIF 
*   
* *** Prepare the Tag and Type of the keys  
*   
      CFOR   = CHFTDK(1:NSYSDK) 
      DO 10 I = 1, NSYSDK   
   10 CTAGDK(I) = CHTGDK(I) 
      IF (NKEX.GT.0) THEN   
        DO 20 K = 1, NKEX   
          CTAGDK(NSYSDK+K) = CHTAG(K)   
          CFOR(NSYSDK+K:NSYSDK+K) = CHFOR(K:K)  
   20   CONTINUE    
      ENDIF 
      NWKEY  = NSYSDK + NKEX    
*   
* *** Now create the directory  
*   
      IF (IOPPDA.EQ.0) THEN 
        CALL DBMDIR (PATH, NWKEY, CFOR, CTAGDK) 
      ELSE  
        IF (MXKP.LE.0) THEN 
          MXKPU  = MXKPDK   
        ELSE    
          MXKPU  = MXKP 
        ENDIF   
        CALL DBMDIP (PATH, NWKEY, CFOR, CTAGDK, MXKPU)  
      ENDIF 
*                                                             END DBCRSD    
  999 END   
      SUBROUTINE DBDELT (PATHN, CHOPT)  
*     ================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBDELT (PATHN, CHOPT)                                   *    
*                                                                      *    
*   Deletes the directory from the current level downwards as given    *    
*   in the path name                                                   *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Path name to be deleted                                 *    
*     CHOPT    Character string with any of the following characters   *    
*          B   Save in the special backup file; not in standard Journal*    
*                                                                      *    
*   Called by user,   DBFZUP, DBKEPT, DBACTI                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =171 : Illegal Path name                               *    
*               =172 : Cannot find the top directory for the path name *    
*               =173 : Error in RZ for reading the dictionary object   *    
*               =174 : Error in FZOUT for saving the journal file      *    
*               =175 : Error in RZ in writing the dictionary object    *    
*               =176 : Error in RZ in purging the dictionary directory *    
*               =177 : Error in RZ in deleting the tree                *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NLEVM=20)    
      DIMENSION       NCHD(NLEVM), ISDI(NLEVM)  
      DIMENSION       NKEY(NLEVM), IOPT(NLEVM), NSDI(NLEVM) 
      DIMENSION       IHDIR(4)  
      CHARACTER       PATH*80, PATHX*16, PATHY*80, PATHF*80, PATHZ*16   
      CHARACTER       PATHD*80, PATHN*(*), CHOPT*(*), PATHL*80  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
* *** Load the current directory    
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)           GO TO 999   
      KEY7   = KEY7DK   
      KEY7DK = 0    
      PATHL  = ' '  
      CALL DBSBLC (PATHN, PATH, NCHR)   
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 171 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDELT : Illegal'//    
     +  ' path name '//PATH(1:NCHR)//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL RZCDIR (PATH, 'R')   
      NCHR   = INDEX (PATH, ' ') - 1    
      IF (NCHR.LE.0) NCHR = MAXLDB  
      NCHRT  = INDEX (PATH(3:NCHR), '/') - 1    
      IF (NCHRT.LE.0) NCHRT = NCHR - 2  
      PATHZ  = PATH(3:NCHRT+2)  
      PATHF  = PATH(3:NCHRT+2)//'/DICTIONARY'   
      IF (PATH.EQ.PATHF)            GO TO 999   
      PATHF  = PATH(3:NCHRT+2)//'/HELP' 
      IF (PATH.EQ.PATHF)            GO TO 999   
*   
* *** Find the appropriate top directory name   
*   
      JBIAS  = -KLDICT  
      LBNODB = LTOPDB   
   10 IF (LBNODB.GT.0) THEN 
        NCHRT  = IQ(KOFUDB+LBNODB+MUPNCH)   
        CALL UHTOC (IQ(KOFUDB+LBNODB+MUPNAM), 4, TOPNDI, NCHRT) 
        IF (PATHZ.EQ.TOPNDI(1:NCHRT)) THEN  
          IF (IOPBDA.EQ.0) THEN 
            LUFZDF = IQ(KOFUDB+LBNODB+MUPJFL)   
          ELSE  
            LUFZDF = IQ(KOFUDB+LBNODB+MUPBAK)   
          ENDIF 
          IOUT   = IQ(KOFUDB+LBNODB+MUPFLG) 
          IOPS   = MOD (IQ(KOFUDB+LBNODB+MUPSRV)/10, 10)    
        ELSE    
          LBNODB = LQ(KOFUDB+LBNODB)    
          GO TO 10  
        ENDIF   
      ELSE  
        IQUEST(1) = 172 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDELT : Illegal'//    
     +  ' top directory for '//PATH(1:NCHR)//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
      IF (IOUT.EQ.0) IOPS = 0   
*   
* *** Find the dictionary record    
*   
      PATHD  = '//'//PATHZ(1:NCHRT)//'/DICTIONARY'  
      CALL RZCDIR (PATHD, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        LFIXDB    = 0   
        IQUEST(1) = 173 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDELT : '//   
     +  'RZCDIR error for path name '//PATHD//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      ISTP   = NWKYDK + 1   
      IF (NKEYDK.GT.0) THEN 
        IPNT   = KOFSDB + LCDRDB + IKDRDB   
        IMIN   = IUHUNT (-1, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)    
        IF (IMIN.GT.0) THEN 
          IMIN   = (IMIN - MSERDB) / ISTP + 1   
          CALL DBKEYT   
          CALL DBKEYR (IMIN, NWKYDK, KEYVDK)    
          IF (LQ(KOFUDB+LBNODB+JBIAS).LE.0) THEN    
            CALL DBRZIN (IDIVDB, LBNODB, JBIAS, IMIN, ICYCL, PATHD) 
            IF (IQUEST(1).NE.0)     GO TO 999   
          ENDIF 
          LFIXDB = LQ(KOFUDB+LBNODB+JBIAS)  
        ELSE    
          LFIXDB = 0    
        ENDIF   
      ELSE  
        LFIXDB = 0  
      ENDIF 
*   
* *** Prepare the journal file if needed    
*   
      IF (LUFZDF.GT.0) THEN 
        IF (IOPBDA.EQ.0) THEN   
          NWDOP  = 0    
        ELSE    
          NWDOP  = 1    
        ENDIF   
        NDOP   = (NCHR + 3) / 4 
        IHEADF(MACTDF) = 4  
        IHEADF(MNKYDF) = 0  
        IHEADF(MOPTDF) = NWDOP  
        IHEADF(MPATDF) = NDOP   
        IHEADF(MPREDF) = 0  
        IF (KEY7.LE.0) THEN 
          CALL DATIME (IDATE, ITIME)    
          CALL DBPKTM (IDATE, ITIME, KEY7)  
        ENDIF   
        IHEADF(MINSDF) = KEY7   
        IF (NWDOP.EQ.1) CALL UCTOH ('B   ', IHEADF(MINSDF+1), 4, 4) 
        CALL UCTOH (PATH, IHEADF(MINSDF+NWDOP+1), 4, 4*NDOP)    
        CALL MZIOCH (IOFMDF, NWFMDF, '6I -H')   
        NWDH   = NWDOP + NDOP + MINSDF  
*   
*  **   Now write on the sequential output  
*   
        CALL FZOUT (LUFZDF, IDIVDB, 0, 1, 'Z', IOFMDF, NWDH, IHEADF)    
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1) = 174   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDELT : FZOUT'//    
     +    ' error for path name '//PATH(1:NCHR)//''')', IARGDB, 0)  
          GO TO 999 
        ENDIF   
      ENDIF 
*   
      IQUEST(1) = 0 
*   
* *** Find the level below which all directories are deleted    
*   
   15 NLEV   = 1    
      NCHD(NLEV) = NCHR 
      NCHL   = 0    
      DO 20 I = 1, NCHR 
        NCH    = NCHR - I + 1   
        IF (PATH(NCH:NCH).EQ.'/') THEN  
          NCHL   = NCH  
          GO TO 25  
        ENDIF   
   20 CONTINUE  
   25 IF (NCHL.LE.2)                GO TO 999   
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 171 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDELT : Illegal'//    
     +  ' path name '//PATH(1:NCHR)//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      IF (KEY7.GT.0) THEN   
        CALL DBPKTM (IQUEST(16), IQUEST(17), KEY7N) 
        IF (KEY7.LT.KEY7N)          GO TO 999   
      ENDIF 
*   
* *** Update the dictionary information if it exists    
*   
      IF (LFIXDB.GT.0) THEN 
        NITEM  = IQ(KOFUDB+LFIXDB+MDCNTM)   
        IF (NKEYDK.GT.0) THEN   
          IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)   
        ELSE    
          IOPTP  = 0    
        ENDIF   
*   
*  **   Now scan down to find all the subdirectories    
*   
   30   IF (NLEV.GT.1) THEN 
          PATH   = PATH(1:NCHD(NLEV-1))//'/'//PATHX 
          NCHD(NLEV) = NCHD(NLEV-1) + NCHAR + 1 
          CALL RZCDIR (PATH, ' ')   
          NKEYDK = IQUEST(7)    
          NWKYDK = IQUEST(8)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          IF (NKEYDK.GT.0) THEN 
            IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB) 
          ELSE  
            IOPTP  = 0  
          ENDIF 
        ENDIF   
        NKEY(NLEV) = NKEYDK 
        IOPT(NLEV) = IOPTP  
        ISDI(NLEV) = 0  
        NSDI(NLEV) = IQ(KOFSDB+LCDRDB+KNSDDB)   
*   
   35   ISDI(NLEV) = ISDI(NLEV) + 1 
        IF (ISDI(NLEV).LE.NSDI(NLEV)) THEN  
*   
*  **     If a new subdirectory go down one level   
*   
          LS    = IQ(KOFSDB+LCDRDB+KLSDDB)  
          IPNT  = LS + 7 * (ISDI(NLEV) - 1) 
          CALL ZITOH (IQ(KOFSDB+LCDRDB+IPNT), IHDIR, 4) 
          CALL UHTOC (IHDIR, 4, PATHX, 16)  
          NCHAR = INDEX (PATHX, ' ') - 1    
          IF (NCHAR.LE.0.OR.NCHAR.GT.16) NCHAR = 16 
          IF (IOPTP.NE.0) THEN  
            DO 45 IK = 1, NKEYDK    
              KK     = IK   
              IDIG   = 0    
   40         IF (KK.GT.0) THEN 
                KK     = KK / 10    
                IDIG   = IDIG + 1   
                GO TO 40    
              ENDIF 
              IF (NCHAR.EQ.IDIG) THEN   
                WRITE (PATHY, '(I8)') IK    
                I1     = 8 - IDIG + 1   
                PATHZ  = PATHY(I1:8)    
                IF (PATHZ.EQ.PATHX) GO TO 35    
              ENDIF 
   45       CONTINUE    
          ENDIF 
          NLEV   = NLEV +1  
          GO TO 30  
*   
        ELSE    
*   
*  **     Check if the name is to be deleted    
*   
          PATHY  = PATH(NCHRT+3:NCHD(NLEV)) 
          NCHRU  = NCHD(NLEV) - NCHRT - 2   
          IF (NITEM.GT.0) THEN  
            DO 50 I = 1, NITEM  
              IPNT   = KOFUDB + LFIXDB + (I - 1) * NWITDB + 1   
              NCHF   = IQ(IPNT+MDCNCH)  
              IF (NCHRU.EQ.NCHF) THEN   
                CALL UHTOC (IQ(IPNT+MDCNAM), 4, PATHF, NCHF)    
                PATHF  = PATHF(1:NCHF)  
                IF (PATHY.EQ.PATHF) THEN    
                  IQ(IPNT+MDCITM) = -1  
                  GO TO 55  
                ENDIF   
              ENDIF 
   50       CONTINUE    
          ENDIF 
*   
   55     NLEV   = NLEV - 1 
          IF (NLEV.GE.1) THEN   
            LUP    = LQ(KOFSDB+LCDRDB+1)    
            CALL MZDROP (0, LCDRDB, ' ')    
            LCDRDB = LUP    
            NKEYDK = NKEY(NLEV) 
            IOPTP  = IOPT(NLEV) 
            GO TO 35    
          ENDIF 
        ENDIF   
*   
* *** Lock the directory if necessary   
*   
   60 IF (IOPS.NE.0) THEN   
        CALL RZCDIR (PATHD, ' ')    
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        CALL RZLOCK ('DBDELT')  
        PATHL  = PATHD  
      ENDIF 
*   
*  **   All subdirectories looked at; now store dictionary  
*   
        CALL RZCDIR (PATHD, ' ')    
        CALL RZOUT (IDIVDB, LFIXDB, KEYVDK, ICYCLE, 'S')    
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1) = 175   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDELT : RZOUT'//    
     +    ' error for path name '//PATHD//''')', IARGDB, 0) 
          GO TO 998 
        ENDIF   
        CALL RZPURG (0) 
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1) = 176   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDELT : RZPUR'//    
     +    'G error for path name '//PATHD//''')', IARGDB, 0)    
          GO TO 998 
        ENDIF   
      ENDIF 
*   
* *** Free the directory if locked  
*   
      IF (PATHL.NE.' ') THEN    
        CALL RZCDIR (PATHL, ' ')    
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        CALL RZFREE ('DBDELT')  
        PATHL  = ' '    
      ENDIF 
*   
  100 IQUEST(1) = 0 
      PATHZ  = PATH(NCHL+1:NCHR)    
      PATH   = PATH(1:NCHL-1)   
*   
*  ** Lock the directory if necessary   
*   
      IF (IOPS.NE.0) THEN   
        CALL RZCDIR (PATH, ' ') 
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        CALL RZLOCK ('DBDELT')  
        PATHL  = PATH   
      ELSE  
        CALL RZCDIR (PATH, ' ') 
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
      ENDIF 
      CALL RZDELT (PATHZ)   
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 177 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDELT : RZDELT '//    
     +  'error for path name '//PATH(1:NCHR)//''')', IARGDB, 0) 
      ENDIF 
*   
* *** Free the directory if locked  
*   
  998 IF (PATHL.NE.' ') THEN    
        IERR   = IQUEST(1)  
        CALL RZCDIR (PATHL, ' ')    
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        CALL RZFREE ('DBDELT')  
        IQUEST(1) = IERR    
      ENDIF 
*                                                             END DBDELT    
  999 END   
      SUBROUTINE DBDONT (PATHN, IUDIV, LSUP, NWKEY, KEY, CHOPT) 
*     ========================================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBDONT (PATHN, IUDIV, LSUP, NWKEY, KEY, CHOPT)          *    
*                                                                      *    
*   Stores data from memory to disk. If data exist with the same user  *    
*   keys, the old object is physically replaced. This mode is not      *    
*   recommended for all calibration data.                              *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     IUDIV    Division index of the user data bank                    *    
*     LSUP     Address of bank in memory where data reside             *    
*     NWKEY    Number of keys associated with the data bank            *    
*     KEY      Vector of keys                                          *    
*     CHOPT    Character string with any of the following characters   *    
*          B   Save in the special backup file; not in standard Journal*    
*          7   Insertion time as supplied by user to be honoured       *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 61 : Too many keys                                   *    
*               = 71 : Illegal path name                               *    
*               = 73 : RZ error during writing to disk                 *    
*               = 75 : Cannot find the Top directory name in pathname  *    
*               = 76 : Cannot form the IO descriptor for the FZ header *    
*               = 77 : FZOUT fails to write on to the sequential file  *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NLEVM=20)    
      DIMENSION       KEY(9)
      DIMENSION       KEYV(MXDMDK), KEYO(MXDMDK), KEYN(MXDMDK)  
      CHARACTER       CHOPT*(*), PATHN*(*)  
      CHARACTER       PATH*80, PATHY*80, PATHX*16, PATHL*80, TOPN*16    
      CHARACTER       CFORM(6)*1, CHFOR*100, CHCUR(NLEVM)*1 
      INTEGER         NLCUR(NLEVM)  
      DATA            CFORM /'B', 'I', 'F', 'D', 'H', 'A'/  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension iarg(9)
*     ------------------------------------------------------------------    
*   
* *** Decode the character option (no compression of data)  
*   
      LREFDB(1) = LSUP
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)            GO TO 999  
      IOPRDA = 1    
*   
* *** Check the number of keys  
*   
      IF (NWKEY.GT.MXDMDK)  THEN    
        IQUEST(1) = 61  
        IQUEST(11)= NWKEY   
        IQUEST(12)= MXDMDK
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDONT : Too man'//    
     +  'y keys '',I6,'' maximum permitted '',I6)', IQUEST(11), 2)  
        GO TO 999   
      ENDIF 
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Set the current directory path name   
*   
      PATHX  = ' '  
      PATHY  = PATH 
      PATHL  = ' '  
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0)            GO TO 991  
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      KST    = NWKYDK + 1   
      CALL RZCDIR (PATHY, 'R')  
      CALL DBKYTG   
      IF (NKEYDK.NE.0)  THEN    
        IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)    
        IOPTP  = JBIT (IOPTP, JPRTDB)   
      ELSE  
        IOPTP  = 0  
      ENDIF 
*   
      IF (NWKYDK.NE.NWKEY) THEN 
        IQUEST(1) = 61  
        IQUEST(11)= NWKEY   
        IQUEST(12)= NWKYDK
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDONT : Illegal'//    
     +  ' number of keys '',I10,'' & as in directory'',I6)', IQUEST(11),    
     +  2)  
        GO TO 999   
      ENDIF 
*   
* *** Extract the Top level directory name  
*   
      CALL DBTOPN (PATHY, TOPN, NCH)    
      IF (NCH.EQ.0) THEN    
        IQUEST(1) = 75  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDONT : No top '//    
     +  'directory for '//PATHY//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
* *** See if transcript file is needed  
*   
      LTOP   = LTOPDB   
      IOPS   = 0    
      IOUT   = 0    
      IOPP   = 0    
   10 IF (LTOP.NE.0) THEN   
        NCH    = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCH) 
        TOPNDI = TOPNDI(1:NCH)  
        IF (TOPN.EQ.TOPNDI) THEN    
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)  
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)   
          IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10) 
          IF (IOPBDA.EQ.0) THEN 
            LUFZDF = IQ(KOFUDB+LTOP+MUPJFL) 
          ELSE  
            LUFZDF = IQ(KOFUDB+LTOP+MUPBAK) 
          ENDIF 
        ELSE    
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 10  
        ENDIF   
      ELSE  
        LUFZDF = 0  
        IOPP   = 0  
      ENDIF 
      IF (IOUT.EQ.0) IOPS = 0   
*   
* *** Prepare the Key vector array  
*   
      CALL VZERO_i (KEYVDK, MXDMDK)   
      KEYVDK(MBVRDB) = KEY(MBVRDB)  
      KEYVDK(MEVRDB) = KEY(MEVRDB)  
      KEYVDK(MPVSDB) = KEY(MPVSDB)  
      IF (IOKYDA(MITMDB).NE.0) THEN 
        KEYVDK(MITMDB) = KEY(MITMDB)    
      ELSE  
        CALL DATIME (IDATE, ITIME)  
        CALL DBPKTM (IDATE, ITIME, IDATM)   
        KEYVDK(MITMDB) = IDATM  
      ENDIF 
      IF (NWKEY.GT.NSYSDK) THEN 
        DO 15 NK = NSYSDK+1, NWKEY  
          IOKYDA(NK) = 1    
          KEYVDK(NK) = KEY(NK)  
   15   CONTINUE    
      ENDIF 
*   
* *** Encode the character option, IO descriptor for the header 
*   
      IF (IOPP.NE.0.OR.LUFZDF.GT.0) THEN    
        NDOP   = LENOCC (CHOPT) 
        NDOP   = (NDOP + 3) / 4 
*   
        NLEV   = 1  
        NCUR   = 5  
        IFORO  = 2  
        CHCUR(NLEV) = CFORM(IFORO)  
        DO 20 I = 1, NWKYDK 
          IFORM  = IOTYDK(I)    
          IF (IFORM.EQ.6) IFORM = 5 
          IF (IFORM.EQ.IFORO) THEN  
            NCUR   = NCUR + 1   
          ELSE  
            NLCUR(NLEV) = NCUR  
            IF (NLEV.GE.NLEVM) THEN 
              IQUEST(1) = 76    
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDONT : '// 
     +        'Cannot get IO descriptor '//PATHY//''')', IARGDB, 0) 
              GO TO 999 
            ENDIF   
            NLEV   = NLEV + 1   
            CHCUR(NLEV) = CFORM(IFORM)  
            NCUR   = 1  
            IFORO  = IFORM  
          ENDIF 
   20   CONTINUE    
        NLCUR(NLEV) = NCUR  
*   
        WRITE (CHFOR, 2001) (NLCUR(I), CHCUR(I), I = 1, NLEV)   
        II     = 4 *NLEV    
        CHFOR = CHFOR(1:II)//' -H'  
        CALL MZIOCH (IOFMDF, NWFMDF, CHFOR(1:II+3)) 
*   
*  **   Complete the header 
*   
        NWDP   = (NCHAR + 3) / 4    
        NWDH   = NWDP + NDOP + NWKYDK + 5   
        IHEADF(MACTDF) = 9  
        IHEADF(MNKYDF) = NWKYDK 
        IHEADF(MOPTDF) = NDOP   
        IHEADF(MPATDF) = NWDP   
        IHEADF(MPREDF) = 0  
        IF (NDOP.GT.0)  
     +    CALL UCTOH (CHOPT, IHEADF(MPREDF+NWKYDK+1), 4, 4*NDOP)    
        CALL UCTOH (PATHY, IHEADF(MPREDF+NWKYDK+NDOP+1), 4, 4*NWDP) 
        CALL UCOPY_i (KEYVDK, IHEADF(MPREDF+1), NWKYDK)   
      ENDIF 
*   
*  ** Write the sequential output if needed 
*   
      IF (LUFZDF.GT.0) THEN 
        CALL FZOUT (LUFZDF, IUDIV, LREFDB(1), 1, 'L', IOFMDF, NWDH, 
     +              IHEADF) 
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1)  = 77   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDONT : Error'//    
     +    ' in FZOUT while writing Data for '//PATHY//''')', IARGDB, 0) 
          GO TO 999 
        ENDIF   
      ENDIF 
*   
* *** Lock the directory if necessary   
*   
      IF (IOPP.EQ.0.AND.IOPS.NE.0) THEN 
        CALL RZLOCK ('DBDONT')  
        PATHL  = PATHY  
      ENDIF 
*   
* *** Look if object already exists with similar user keys  
*   
      IF (IOPTP.EQ.0) THEN  
        CALL DBHUNT (KEYV)  
*   
      ELSE  
*   
        NKEYS  = NKEYDK 
        DO 30 JK = 1, NKEYS 
          ICURDT = NKEYS + 1 - JK   
          CALL DBPATH (PATHX, ICURDT)   
          IF (JK.NE.1) THEN 
            CALL RZCDIR (PATHY, ' ')    
            IF (IQUEST(1).NE.0)      GO TO 991  
          ENDIF 
*   
          CALL RZCDIR (PATHX, ' ')  
          IF (IQUEST(1).NE.0)        GO TO 991  
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          CALL DBHUNT (KEYV)    
          IF (KEYV(1).GT.0)          GO TO 35   
*   
   30   CONTINUE    
*   
      ENDIF 
*   
* *** Either update an old record   
*   
   35 IF (KEYV(1).GT.0) THEN    
        CALL RZOUT (IUDIV, LREFDB(1), KEYV, ICYCLE, 'L')    
        IER    = IQUEST(1)  
        CALL RZPURG (0) 
        IF (IER.NE.0) IQUEST(1) = IER   
*   
* *** Or enter a new one    
*   
      ELSE  
*   
*  **   Take necessary action for partitioned and nonpartiitined dataset    
*   
        IF (IOPTP.EQ.0) THEN    
          KOBJ   = 0    
        ELSE    
          CALL RZCDIR (PATHY, ' ')  
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          KPNT   = IUHUNT (NKEYS, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),  
     +                     NKEYS*KST, KST)  
          IF (KPNT.NE.0) THEN   
            NK     = (KPNT - MPSRDB) / KST + 1  
          ELSE  
            NK     = NKEYS  
          ENDIF 
          CALL DBKEYR (NK, NWKYDK, KEYO)    
          KOBJ   = KEYO(MOBJDB) 
          MXKP   = KEYO(MXKPDB) 
          CALL DBPATH (PATHX, NKEYS)    
          CALL RZCDIR (PATHX, ' ')  
          IF (IQUEST(1).NE.0)        GO TO 991  
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
*   
*  **     Make a different subdirectory if there are too many keys  
*   
          IF (NKEYDK.GE.MXKP) THEN  
            NWKEY  = NWKYDK 
            CHFOR = ' ' 
            DO 40 I = 1, NWKEY  
              IF (I.EQ.1) THEN  
                CHFOR  = CFORM(IOTYDK(I))   
              ELSE  
                CHFOR  = CHFOR(1:I-1)//CFORM(IOTYDK(I)) 
              ENDIF 
   40       CONTINUE    
            KEY7DK = KEYVDK(MITMDB) 
            CALL DBMDIP (PATHY, NWKEY, CHFOR, CTAGDK, MXKP) 
            IF (IQUEST(1).NE.0)      GO TO 999  
            CALL RZCDIR (PATHY, ' ')    
            NKEYDK = IQUEST(7)  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
            KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),   
     +                       NKEYDK*KST, KST)   
            IF (KPNT.NE.0) THEN 
              NK     = (KPNT - MPSRDB) / KST + 1    
            ELSE    
              NK     = NKEYDK   
            ENDIF   
            CALL DBKEYR (NK, NWKYDK, KEYO)  
            KOBJ   = KEYO(MOBJDB)   
            CALL DBPATH (PATHX, NKEYDK) 
            CALL RZCDIR (PATHX, ' ')    
            IF (IQUEST(1).NE.0)      GO TO 991  
            NKEYDK = IQUEST(7)  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
          ENDIF 
          CALL UCOPY_i (KEYO, KEYN, NWKYDK)   
*   
        ENDIF   
*   
*  **   Check the number of keys    
*   
        LOBJ   = KOBJ   
        DO 45 IK = 1, NKEYDK    
          IP     = KOFSDB + LCDRDB + IKDRDB + (IK-1)*KST + MSERDB   
          IF (IQ(IP).GT.LOBJ) LOBJ = IQ(IP) 
   45   CONTINUE    
        KEYVDK(MSERDB) = LOBJ + 1   
        KEYVDK(MFLGDB) = MSBIT1 (KEYVDK(MFLGDB), JRZUDB)    
        CALL RZOUT (IUDIV, LREFDB(1), KEYVDK, ICYCLE, 'L')  
        IER    = IQUEST(1)  
        KEYN(MBVRDB) = MIN0 (KEYN(MBVRDB), KEYVDK(MBVRDB))  
        KEYN(MEVRDB) = MAX0 (KEYN(MEVRDB), KEYVDK(MEVRDB))  
        CALL RZRENK (KEYO, KEYN)    
        IF (IER.NE.0) IQUEST(1) = IER   
      ENDIF 
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 73
        iarg(1) = i
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDONT : Error i'//    
     +       'n RZ while writing Data for '//PATHY//PATHX(1:8)//''')'
     &       ,Iarg,0)
      ENDIF 
      GO TO 998 
*   
* *** Error messages    
*   
  991 IQUEST(1) = 71    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDONT : Illegal '// 
     +   'Path Name '//PATHY//PATHX(1:8)//''')', IARGDB, 0) 
*   
  998 IER   = IQUEST(1) 
      IF (PATHL.NE.' ') THEN    
        CALL RZCDIR (PATHL, ' ')    
        CALL RZFREE ('DBDONT')  
      ENDIF 
      IQUEST(1) = IER   
*   
 2001 FORMAT (20(I2,A1,1X)) 
*                                                             END DBDONT    
  999 END   
      SUBROUTINE DBEALI (PATH, ALIAS, IFLAG)    
*     ======================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBEALI (PATH, ALIAS, IFLAG)                             *    
*                                                                      *    
*   Enter the alias name of a given directory either only for this     *    
*   session or permanently in the data base.                           *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATH     Character string specifying the directory path name     *    
*     ALIAS    Character string specifying the alias name              *    
*     IFLAG    Flag (0 if to be entered only for this session;         *    
*                    1 if to be entered for this session and D.B.)     *    
*                                                                      *    
*   Called by user,   DBFZUP, DBAUXI                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =182 : Illegal path name                               *    
*               =185 : Illegal top directory name                      *    
*               =187 : FZOUT fails to write on the sequential file     *    
*               =188 : Error in RZ for writing to the R.A. file        *    
*               =201 : Dictionary directory not found                  *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       PATH*(*), ALIAS*(*), CALI*8, PATHN*80, TOPN*16    
      CHARACTER       PATHD*32, PATHL*80    
*   
*     ------------------------------------------------------------------    
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATH, PATHN, NCHAR)  
      CALI   = ALIAS    
      PATHL  = ' '  
*   
* *** Check if the path name already exists in the help 
*   
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 182 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : Illegal'//    
     +  ' pathname '//PATHN//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL RZCDIR (PATHN, 'R')  
      NCHAR = LENOCC(PATHN) 
*   
* *** Find the unique directory identifier from the pathname    
*   
      CALL DBGPID (PATHN, NCHAR, TOPN, IDN) 
      IF (IDN.LE.0) THEN    
        IQUEST(1) = 182 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : Illegal'//    
     +  ' pathname '//PATHN//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
* *** Modify in memory  
*   
      LTOP   = LTOPDB   
   10 IF (LTOP.GT.0) THEN   
        NCHT   = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHT)    
        TOPNDI = TOPNDI(1:NCHT) 
        IF (TOPN.EQ.TOPNDI) THEN    
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)  
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)   
          LUFZDF = IQ(KOFUDB+LTOP+MUPJFL)   
        ELSE    
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 10  
        ENDIF   
      ELSE  
        IQUEST(1) = 185 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : Illegal'//    
     +  ' top directory name '//PATHN//''')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
      LFIXDB = LQ(KOFUDB+LTOP-KLDICT)   
      IF (LFIXDB.EQ.0) THEN 
        IQUEST(1) = 201 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : DICTION'//    
     +  'ARY not found for '//TOPN//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
      IF (IOUT.EQ.0) IOPS = 0   
*   
      IPNT   = KOFUDB + LFIXDB + (IDN - 1) * NWITDB + 1 
      CALL UCTOH (CALI, IQ(IPNT+MDCALI), 4, 8)  
      IF (IFLAG.EQ.0)  THEN 
        LFIXDB = 0  
        GO TO 999   
      ENDIF 
*   
* *** Get the name of the correct DICTIONARY directory  
*   
      NCTOP  = LENOCC (TOPN)    
      PATHD  = '//'//TOPN(1:NCTOP)//'/DICTIONARY'   
      NCHRD  = NCTOP + 13   
*   
      IF (LUFZDF.GT.0) THEN 
*   
*  **   Prepare the header containing all the information   
*   
        NCHD   = (NCHRD + 3) / 4    
        NCHP   = (NCHAR + 3) / 4    
        CALL MZIOCH (IOFMDF, NWFMDF, '6I -H')   
        IHEADF(MACTDF) = 7  
        IHEADF(MNKYDF) = 0  
        IHEADF(MOPTDF) = 0  
        IHEADF(MPATDF) = NCHD   
        IHEADF(MFLGDF) = IFLAG  
        IHEADF(MWDPDF) = NCHP   
        NPNT1  = NCHD  + MWDPDF + 1 
        NPNT2  = NPNT1 + 2  
        CALL UCTOH (PATHD, IHEADF(MWDPDF+1), 4, 4*NCHD) 
        CALL UCTOH (CALI , IHEADF(NPNT1),    4, 8)  
        CALL UCTOH (PATHN, IHEADF(NPNT2),    4, 4*NCHP) 
        NWDH   = NPNT2 + NCHP - 1   
*   
*  **   Now write on the sequential output  
*   
        CALL FZOUT (LUFZDF, IDIVDB, 0, 1, 'Z', IOFMDF, NWDH, IHEADF)    
        IF (IQUEST(1).NE.0) THEN    
          LFIXDB = 0    
          IQUEST(1) = 187   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : FZOUT'//    
     +    ' error for path name '//PATHN//''')', IARGDB, 0) 
          GO TO 999 
        ENDIF   
      ENDIF 
*   
      IQUEST(1) = 0 
*   
* *** Now save this information in the data base    
*   
      CALL RZCDIR (PATHD, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        LFIXDB = 0  
        IQUEST(1) = 201 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : DICTION'//    
     +  'ARY not found for '//TOPN//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      ISTP   = NWKYDK + 1   
*   
* *** Lock the directory if necessary   
*   
      IF (IOPS.NE.0) THEN   
        CALL RZCDIR (PATHD, ' ')    
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        CALL RZLOCK ('DBEALI')  
        PATHL  = PATHD  
      ENDIF 
*   
      IF (NKEYDK.GT.0) THEN 
        IPNT   = KOFSDB + LCDRDB + IKDRDB   
        IMIN   = IUHUNT (-1, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)    
        IF (IMIN.GT.0) THEN 
          IMIN   = (IMIN - MSERDB) / ISTP + 1   
          CALL DBKEYT   
          CALL DBKEYR (IMIN, NWKYDK, KEYNDK)    
          ISTEP  = 1    
          CALL RZOUT (IDIVDB, LFIXDB, KEYNDK, ICYCLE, 'S')  
          LFIXDB = 0    
          IF (IQUEST(1).NE.0) THEN  
            IQUEST(1) = 188 
            IQUEST(11)= ISTEP   
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : RZ '//    
     +      'error in step '',I3,'' for path name '//PATHD//''')',  
     +      IQUEST(11), 1)  
            GO TO 998   
          ENDIF 
          ISTEP  = 2    
          CALL RZPURG (0)   
          IF (IQUEST(1).NE.0) THEN  
            IQUEST(1) = 188 
            IQUEST(11)= ISTEP   
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : RZ '//    
     +      'error in step '',I3,'' for path name '//PATHD//''')',  
     +      IQUEST(11), 1)  
            GO TO 998   
          ENDIF 
        ENDIF   
      ELSE  
        IMIN   = 0  
      ENDIF 
      LFIXDB = 0    
      IF (IMIN.EQ.0) THEN   
        IQUEST(1) = 201 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : DICTION'//    
     +  'ARY not found for '//TOPN//''')', IARGDB, 0)   
      ELSE  
        IQUEST(1) = 0   
      ENDIF 
*   
* *** Free the locked directory 
*   
  998 IF (PATHL.NE.' ') THEN    
        IERR   = IQUEST(1)  
        CALL RZCDIR (PATHL, ' ')    
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        CALL RZFREE ('DBEALI')  
        IQUEST(1) = IERR    
      ENDIF 
*                                                             END DBEALI    
  999 END   
      SUBROUTINE DBEFOR (TOPN, IDATE, ITIME)    
*     ======================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBEFOR (TOPN, IDATE, ITIME)                             *    
*                                                                      *    
*   Set the maximum insertion time for retrieval of all subsequent     *    
*   data objects for a given top directory                             *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     TOPN     Name of the top directory ('*' means all)               *    
*     IDATE    Date : 6 Decimal integer : YYMMDD                       *    
*     ITIME    Time : 4 Decimal integer : HHMM                         *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      CHARACTER       TOPN*(*), TOP*16  
*   
*     ------------------------------------------------------------------    
*   
      CALL DBPKTM (IDATE, ITIME, KY7M)  
      CALL DBSBLC (TOPN, TOPNDI, NCHR)  
*   
* *** Insert the KY7M value for the appropriate 
*   
      LFIXDB = LTOPDB   
   10 IF (LFIXDB.GT.0) THEN 
        NCH    = IQ(KOFUDB+LFIXDB+MUPNCH)   
        IF (NCH.EQ.NCHR) THEN   
          CALL UHTOC (IQ(KOFUDB+LFIXDB+MUPNAM), 4, TOP, NCH)    
          IF (TOPNDI.EQ.'*'.OR.TOP(1:NCH).EQ.TOPNDI) THEN   
            IQ(KOFUDB+LFIXDB+MUPKY7) = KY7M 
            IF (IDEBDB.GT.0) THEN   
              IARGDB(1) = IDATE 
              IARGDB(2) = ITIME 
              CALL DBPRNT (LPRTDB, '(/,'' DBEFOR : All subsequent ret'//    
     +             'rievals of data objects for '//TOP(1:NCH)//' will'//    
     +             ' test on insertion time before '',2I7)', IARGDB, 2) 
            ENDIF   
          ENDIF 
          LFIXDB = LQ(KOFUDB+LFIXDB)    
          GO TO 10  
        ENDIF   
      ENDIF 
*                                                             END DBEFOR    
      END   
      SUBROUTINE DBEHLP (PATH, LUN) 
*     ============================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBEHLP (PATH, LUN)                                      *    
*                                                                      *    
*   Encode the help information from an ASCII disk file specified by   *    
*   the logical unit number LUN with subroutine DBLINC and enter it    *    
*   into the data base.                                                *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATH     Path name of the help subdirectory                      *    
*     LUN      Logical unit number of the file where ASCII help        *    
*              information reside                                      *    
*                                                                      *    
*   Called by user,   DBAUXI                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 66 : Illegal logical unit number                     *    
*               = 67 : File too long; no space in buffer               *    
*               =182 : Illegal path name                               *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      CHARACTER       PATH*(*), KLINE*80, PATHN*80, TOPN*16 
*
      dimension nio(9), keys(9)
*     ------------------------------------------------------------------    
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATH, PATHN, NCHAR)  
*   
      IF (LUN.LE.0) THEN    
        IQUEST(1) = 66  
        IQUEST(11)= LUN 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEHLP : Illegal'//    
     +  ' unit number '',I10,'' for ASCII file'')', IQUEST(11), 1)  
        GO TO 999   
      ENDIF 
*   
* *** Check if the path name already exists in the help 
*   
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 182 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEHLP : Illegal'//    
     +  ' pathname '//PATHN(1:NCHAR)//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL RZCDIR (PATHN, 'R')  
      NCHAR = LENOCC(PATHN) 
*   
* *** Find the unique directory identifier from the pathname    
*   
      CALL DBGPID (PATHN, NCHAR, TOPN, IDN) 
      IF (IDN.LE.0) THEN    
        IQUEST(1) = 182 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEHLP : Illegal'//    
     +  ' pathname '//PATHN(1:NCHAR)//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
*   
* *** Read the data part    
*   
      IF (LSTRDL(1).NE.0) CALL MZDROP (IDIVDB, LSTRDL(1), 'L')  
      NDATA  = NDMXDB   
      JBIAS  = 2
      nio(1) = 1
      CALL DBBOOK (IDIVDB, LSTRDL(1), LSTRDL(1), JBIAS, 'USER', 0, 0,   
     +             NDATA, nio, -1)    
      IF (IQUEST(1).NE.0)     GO TO 999 
*   
* *** Now read the file 
*   
      NDAT   = 0    
      NREC   = 0    
   25 READ (LUN, 1000, ERR=30, END=30) KLINE    
      NREC   = NREC + 1 
      LENG   = LENOCC (KLINE)   
      CALL DBLINC (KLINE, LENG, IQ(KOFUDB+LSTRDL(1)+1), NDAT)   
      IF (NDAT.GT.NDATA-20) THEN    
        IQUEST(1) = 67  
        IQUEST(11)= NREC    
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEHLP : Buffer '//    
     +  'full after '',I8,'' records'')', IQUEST(11), 1)    
        GO TO 990   
      ENDIF 
      GO TO 25  
*   
   30 NDP    = NDAT - NDATA 
      IF (NDP.LT.0) CALL MZPUSH (IDIVDB, LSTRDL(1), 0, NDP, 'I')    
*   
* *** Now save the bank into the database and drop the bank 
*
      keys(1) = idn
      CALL DBSNAM (1, keys, LSTRDL(1), TOPN, 0)  
*   
  990 IF (LSTRDL(1).NE.0) THEN  
        IERR   = IQUEST(1)  
        CALL MZDROP (IDIVDB, LSTRDL(1), 'L')    
        LSTRDL(1) = 0   
        IQUEST(1) = IERR    
      ENDIF 
*   
 1000 FORMAT (A80)  
*                                                             END DBEHLP    
  999 END   
      SUBROUTINE DBENAM (PATH, NW, CHTAG)   
*     ===================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBENAM (PATH, NW, CHTAG)                                *    
*                                                                      *    
*   Enters the name of the data elements of a given directory inside   *    
*   the data base. The stored information goes in the DICTIONARY       *    
*   directory with KEY(1) set to the unique identifier of this         *    
*   directory.                                                         *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATH     Character string describing the path name               *    
*     NW       Number of data elements                                 *    
*     CHTAG    Name of each data element (assumed to be 8 character)   *    
*                                                                      *    
*   Called by user,   DBAUXI                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =182 : Illegal path name                               *    
*               =183 : Illegal number of data words                    *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      CHARACTER*(*)   CHTAG(*)  
      CHARACTER       CTAG*8, TOPN*16, PATH*(*), PATHN*80   
*
      dimension nio(9), keys(9)
*     ------------------------------------------------------------------    
*   
      IF (NW.LE.0) THEN 
        IQUEST(1) = 183 
        IQUEST(11)= NW  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENAM : Illegal'//    
     +  ' number of data words '',I12)', IQUEST(11), 1) 
        GO TO 999   
      ENDIF 
*   
* *** See if the path name is correct   
*   
      CALL DBSBLC (PATH, PATHN, NCHAR)  
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 182 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENAM : Illegal'//    
     +  ' path name '//PATHN(1:NCHAR)//''')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL RZCDIR (PATHN, 'R')  
      NCHAR = LENOCC (PATHN)    
      CALL DBGPID (PATHN, NCHAR, TOPN, IDN) 
      IF (IDN.LE.0) THEN    
        IQUEST(1) = 182 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENAM : Illegal'//    
     +  ' path name '//PATHN(1:NCHAR)//''')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
*   
* *** Book the bank and fill it up with appropriate information 
*   
      NUM   = 2 * NW    
      IF (LSTRDL(1).NE.0) THEN  
        CALL MZDROP (IDISDB, LSTRDL(1), 'L')    
        LSTRDL(1) = 0   
      ENDIF
      nio(1) = 5
      CALL DBBOOK (IDISDB, LSTRDL(1), LSTRDL(1), 2, 'DNAM', 0, 0, NUM,  
     +             nio, -1)   
      IF (IQUEST(1).NE.0)  GO TO 999    
      IPNT = KOFUDB + LSTRDL(1) 
      DO 10 I = 1, NW   
        CTAG   = CHTAG(I)   
        CALL UCTOH (CTAG, IQ(IPNT+1), 4, 8) 
        IPNT = IPNT + 2 
   10 CONTINUE  
*   
* *** Now store the information inside data base    
*
      keys(1) = idn
      CALL DBSNAM (2, keys, LSTRDL(1), TOPN, 0)  
      IERR = IQUEST(1)  
      CALL MZDROP (IDISDB, LSTRDL(1), 'L')  
      LSTRDL(1) = 0 
      IQUEST(1) = IERR  
*                                                             END DBENAM    
  999 END   
      SUBROUTINE DBEND  
*     ================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBEND                                                   *    
*                                                                      *    
*   Terminates the Data Base utility package                           *    
*                                                                      *    
*   Called by user,   DBMAIN, DBTERM, DBACTI                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      CHARACTER       TOP*16, TOPN*16, PATH*20  
*   
*     ------------------------------------------------------------------    
*   
      IER    = 0    
*   
* *** Call RZEND for all the files opened   
*   
      LFIXDB = LTOPDB   
   10 IF (LFIXDB.EQ.0)  GO TO 20    
      NCH    = IQ(KOFUDB+LFIXDB+MUPNCH) 
      CALL UHTOC (IQ(KOFUDB+LFIXDB+MUPNAM), 4, TOP, NCH)    
      TOPN   = TOP(1:NCH)   
      PATH   = '//'//TOPN   
      CALL RZCDIR (PATH, ' ')   
      CALL RZEND (TOPN) 
      LFIXDB = LQ(KOFUDB+LFIXDB)    
      GO TO 10  
*   
   20 IF (LTOPDB.GT.0) THEN 
        CALL MZDROP (IDIVDB, LTOPDB, 'L')   
        LTOPDB = 0  
      ENDIF 
      IQUEST(1) = IER   
*                                                              END DBEND    
  999 END   
      SUBROUTINE DBENDF (TOPN)  
*     ========================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBENDF (TOPN)                                           *    
*                                                                      *    
*   Closes one data base file given by the top directory name          *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     TOPN     Name of the top directory                               *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*  Modified  FEB-1993   D0 correction
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      CHARACTER       TOP*16, TOPN*(*), PATH*20 
*   
*     ------------------------------------------------------------------    
*   
      CALL DBSBLC (TOPN, TOPNDI, NCHR)  
      IER    = 0    
*   
* *** Make appropriate RZEND call   
*   
      LFIXDB = LTOPDB   
   10 IF (LFIXDB.EQ.0)  GO TO 20    
      NCH    = IQ(KOFUDB+LFIXDB+MUPNCH) 
      IF (NCH.EQ.NCHR) THEN 
        CALL UHTOC (IQ(KOFUDB+LFIXDB+MUPNAM), 4, TOP, NCH)  
        IF (TOP(1:NCH).EQ.TOPNDI(1:NCH)) THEN   
           PATH   = '//'//TOPNDI    
           CALL RZCDIR (PATH, ' ')  
          CALL RZEND (TOPNDI)   
          IF (LTOPDB.EQ.LFIXDB) LTOPDB = LQ(KOFUDB+LFIXDB)  
          CALL MZDROP (IDIVDB, LFIXDB, ' ') 
          GO TO 20  
        ENDIF   
      ENDIF 
      LFIXDB = LQ(KOFUDB+LFIXDB)  
      GO TO 10    
*   
   20 IQUEST(1) = IER   
*                                                             END DBENDF    
      END   
      SUBROUTINE DBENTB (PATHN, IUDIV, LSUP, KEY, NWDIM, NTKEY, IPREC,  
     +                   CHOPT) 
*     ================================================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBENTB (PATHN, IUDIV, LSUP, *KEY*, NWDIM, NTKEY, IPREC, *    
*                      CHOPT)                                          *    
*                                                                      *    
*   Stores data from memory to disk for a number of objects in a go.   *    
*   It is useful in a Batch operation to save real time spent          *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     IUDIV    Division index where the data reside                    *    
*     LSUP     Vector containing the addresses of the banks where      *    
*              data reside                                             *    
*     KEY      Two dimensional array with the first dimension NWDIM,   *    
*              specifying the key elements for each object and the     *    
*              secod dimension NTKEY, specifying the number of objects *    
*              (Keys 3,4,5 and 8 onwards to be filled in by user on    *    
*              input; the DB system keys will be filled in here at the *    
*              time of output)                                         *    
*     NWDIM    First dimension of the array KEY                        *    
*     NTKEY    Number of objects to be inserted                        *    
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *    
*              IPREC significant digits right to the decimal points; if*    
*              IPREC < 0, data are stored with IPREC insignificant     *    
*              digits left to the decimal point.)                      *    
*     CHOPT    Character string with any of the following characters   *    
*          B   Save in the special backup file; not in standard Journal*    
*          F   Updates with a fully matched data object (in user keys) *    
*          R   Store with full RZ option (No compression to be made)   *    
*          S   Create stand alone (master) data                        *    
*          T   Special text type of data (to be used with R)           *    
*          U   Store data uncompressed                                 *    
*          Z   Store only nonzero elements. An element is considered to*    
*              be zero if its absolute is less than IPREC              *    
*          7   Insertion time as supplied by user to be honoured       *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 61 : Too many keys                                   *    
*               = 65 : Illegal number of objects                       *    
*               = 71 : Illegal path name                               *    
*               = 72 : Number of keys does not match with that         *    
*                      specified in the directory                      *    
*               = 73 : RZOUT fails to write on disk                    *    
*               = 74 : Error in RZRENK in updating key values for      *    
*                      partitioned data set                            *    
*               = 75 : Cannot find the Top directory name in pathname  *    
*               = 76 : Cannot form the IO descriptor for the FZ header *    
*               = 77 : FZOUT fails to write on to the sequential file  *    
*               = 78 : Illegal number of keys in data base             *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      COMMON /DZPACK/ PRECDZ, PACKDZ    
      LOGICAL         PACKDZ    
*   
      PARAMETER       (NLEVM=20)    
      INTEGER         NLCUR(NLEVM)  
      DIMENSION       KEY(NWDIM,2), LSUP(9), KEYO(MXDMDK), KEYN(MXDMDK) 
      CHARACTER       PATHY*80, PATHX*16, CHFOR*100, CFORM(6)*1 
      CHARACTER       CHCUR(NLEVM)*1, TOPN*16, CHOP*1   
      CHARACTER       PATHN*(*), CHOPT*(*), CHOP0*80, PATHL*80  
      DATA            CFORM /'B', 'I', 'F', 'D', 'H', 'A'/  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      integer ival
      real fval
      equivalence (ival, fval)
*     ------------------------------------------------------------------    
*   
* *** Decode the character option   
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)          GO TO 999    
      PACKDZ = .FALSE.  
      PATHL  = ' '  
*   
      IF (IOPUDA.NE.0.AND.IOPZDA.NE.0)  THEN    
        IOPZDA = 0  
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Warning'//    
     +  ' - Z option is incompatible with U option - U option will be'//    
     +  ' executed'')', IARGDB, 0)  
*   
      ELSE IF (IOPZDA.NE.0) THEN    
        PACKDZ = .TRUE.
        ival = IPREC
        PRECDZ = fval
      ENDIF 
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATHY, NCHAR) 
*   
* *** Set the current directory path name   
*   
      PATHX  = ' '  
      CALL RZCDIR (PATHY, ' ')  
      IF (IQUEST(1).NE.0)          GO TO 991    
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      KST    = NWKYDK + 1   
      CALL RZCDIR (PATHY, 'R')  
      CALL DBKYTG   
      IF (NKEYDK.NE.0)  THEN    
        IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)    
        IOPTP  = JBIT (IOPTP, JPRTDB)   
      ELSE  
        IOPTP  = 0  
      ENDIF 
*   
* *** Check the number of keys  
*   
      IF (NWDIM.LT.NWKYDK)  THEN    
        IQUEST(1) = 61  
        IQUEST(11)= NWKYDK  
        IQUEST(12)= NWDIM   
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Too man'//    
     +  'y keys '',I6,'' maximum permitted '',I6)', IQUEST(11), 2)  
        GO TO 999   
      ENDIF 
      IF (NTKEY.LE.0) THEN  
        IQUEST(1) = 65  
        IQUEST(11)= NTKEY   
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Too few'//    
     +  ' objects '',I12)', IQUEST(11), 1)  
        GO TO 999   
      ENDIF 
      IF (NWKYDK.LT.NSYSDK.OR.NWKYDK.GT.MXDMDK) THEN    
        IQUEST(1) = 78  
        IQUEST(11)= NWKYDK  
        IQUEST(12)= NSYSDK  
        IQUEST(13)= MXDMDK  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Illegal'//    
     +  ' number of keys '',I10,'' permitted range '',2I6)', IQUEST(11),    
     +  3)  
        GO TO 999   
      ENDIF 
*   
* *** Extract the Top level directory name  
*   
      I1     = 0    
      I11    = 0    
      DO 10 I0 = 1, MAXLDB  
        IF (PATHY(I0:I0).EQ.'/'.OR.PATHY(I0:I0).EQ.' ') THEN    
          IF (I1.GT.0) THEN 
            TOPN   = PATHY(I11:I0-1)    
            GO TO 15    
          ENDIF 
          IF (PATHY(I0:I0).EQ.' ') GO TO 15 
        ELSE    
          IF (I1.EQ.0) I11 = I0 
          I1     = I1 +1    
        ENDIF   
   10 CONTINUE  
   15 IF (I1.EQ.0) THEN 
        IQUEST(1) = 75  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : No top '//    
     +  'directory for '//PATHY//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
* *** Find the appropriate FZ file number   
*   
      LTOP   = LTOPDB   
      IOPP   = 0    
      IOUT   = 0    
   20 IF (LTOP.NE.0) THEN   
        NCH    = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCH) 
        TOPNDI = TOPNDI(1:NCH)  
        IF (TOPN.EQ.TOPNDI) THEN    
          IF (IOPBDA.EQ.0) THEN 
            LUFZDF = IQ(KOFUDB+LTOP+MUPJFL) 
          ELSE  
            LUFZDF = IQ(KOFUDB+LTOP+MUPBAK) 
          ENDIF 
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)  
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)   
        ELSE    
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 20  
        ENDIF   
      ELSE  
        LUFZDF = 0  
        IOPS   = 0  
      ENDIF 
      IF (IOUT.EQ.0) IOPS = 0   
*   
* *** Get the IO descriptor for the header  
*   
      IF (LUFZDF.GT.0) THEN 
        NDOPC  = LENOCC (CHOPT) 
        IF (INDEX (CHOPT, '7') .EQ. 0) THEN 
          CHOP0  = '7'//CHOPT   
          NDOPC  = NDOPC + 1    
        ELSE    
          CHOP0  = CHOPT    
        ENDIF   
        NDOP   = (NDOPC + 3) / 4    
        NLEV   = 1  
        NCUR   = 5  
        IFORO  = 2  
        CHCUR(NLEV) = CFORM(IFORO)  
        IF (PACKDZ.AND.IOPUDA.EQ.0) THEN    
          NLCUR(NLEV) = 4   
          IFORO  = 3    
          NCUR   = 1    
          NLEV   = NLEV + 1 
          CHCUR(NLEV) = CFORM(IFORO)
          fval = PRECDZ
          IHEADF(MPREDF) = ival
        ELSE    
          IHEADF(MPREDF) = IPREC    
        ENDIF   
        DO 25 I = 1, NWKYDK 
          IFORM  = IOTYDK(I)    
          IF (IFORM.EQ.6) IFORM = 5 
          IF (IFORM.EQ.IFORO) THEN  
            NCUR   = NCUR + 1   
          ELSE  
            NLCUR(NLEV) = NCUR  
            IF (NLEV.GE.NLEVM) THEN 
              IQUEST(1) = 76    
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : '// 
     +        'Cannot get IO descriptor '//PATHY//''')', IARGDB, 0) 
              GO TO 999 
            ENDIF   
            NLEV   = NLEV + 1   
            CHCUR(NLEV) = CFORM(IFORM)  
            NCUR   = 1  
            IFORO  = IFORM  
          ENDIF 
   25   CONTINUE    
        NLCUR(NLEV) = NCUR  
*   
        WRITE (CHFOR, 2001) (NLCUR(I), CHCUR(I), I = 1, NLEV)   
        II     = 4 *NLEV    
        CHFOR = CHFOR(1:II)//' -H'  
        CALL MZIOCH (IOFMDF, NWFMDF, CHFOR(1:II+3)) 
*   
*  **   Partially fill up the header    
*   
        NCHR   = INDEX (PATHY, ' ') - 1 
        IF (NCHR.LT.1.OR.NCHR.GT.MAXLDB) NCHR = MAXLDB  
        NWDP   = (NCHR + 3) / 4 
        NWDH   = NWDP + NDOP + NWKYDK + 5   
        IHEADF(MACTDF) = 1  
        IHEADF(MNKYDF) = NWKYDK 
        IHEADF(MOPTDF) = NDOP   
        IHEADF(MPREDF) = NWDP   
        IF (NDOP.GT.0)  
     +    CALL UCTOH (CHOP0, IHEADF(NWKYDK+MPREDF+1), 4, 4*NDOP)    
        CALL UCTOH (PATHY, IHEADF(NWKYDK+NDOP+MPREDF+1), 4, 4*NWDP) 
      ENDIF 
*   
* *** Take necessary action for partitioned and nonpartiitined datasets 
*   
      IF (IOPTP.EQ.0) THEN  
        KOBJ   = 0  
      ELSE  
        KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),   
     +                   NKEYDK*KST, KST)   
        IF (KPNT.NE.0) THEN 
          NK     = (KPNT - MPSRDB) / KST + 1    
        ELSE    
          NK     = NKEYDK   
        ENDIF   
        CALL DBKEYR (NK, NWKYDK, KEYO)  
        KOBJ   = KEYO(MOBJDB)   
        MXKP   = KEYO(MXKPDB)   
        NWKYS  = NWKYDK 
        CHFOR = ' ' 
        DO 30 I = 1, NWKYS  
          IF (I.EQ.1) THEN  
            CHFOR  = CFORM(IOTYDK(I))   
          ELSE  
            CHFOR  = CHFOR(1:I-1)//CFORM(IOTYDK(I)) 
          ENDIF 
   30   CONTINUE    
*   
        CALL DBPATH (PATHX, NKEYDK) 
        CALL RZCDIR (PATHX, ' ')    
        IF (IQUEST(1).NE.0)        GO TO 991    
        NKEYDK = IQUEST(7)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
*   
*  **   Make a different subdirectory if there are too many keys    
*   
        IF (NKEYDK.GE.MXKP) THEN    
          IF (IOKYDA(MITMDB).EQ.0.OR.KEY(MITMDB,1).LE.0) THEN   
            KEY7DK = 0  
          ELSE  
            KEY7DK = KEY(MITMDB,1)  
          ENDIF 
          CALL DBMDIP (PATHY, NWKYS, CHFOR, CTAGDK, MXKP)   
          IF (IQUEST(1).NE.0)      GO TO 999    
          CALL RZCDIR (PATHY, ' ')  
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB), 
     +                     NKEYDK*KST, KST) 
          IF (KPNT.NE.0) THEN   
            NK     = (KPNT - MPSRDB) / KST + 1  
          ELSE  
            NK     = NKEYDK 
          ENDIF 
          CALL DBKEYR (NK, NWKYDK, KEYO)    
          KOBJ   = KEYO(MOBJDB) 
          CALL DBPATH (PATHX, NKEYDK)   
          CALL RZCDIR (PATHX, ' ')  
          IF (IQUEST(1).NE.0)      GO TO 991    
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
        ENDIF   
        CALL UCOPY_i (KEYO, KEYN, NWKYDK) 
*   
      ENDIF 
*   
* *** Get the Serial number of the last object inserted 
*   
      LOBJ   = KOBJ 
      IF (NKEYDK.GT.0) THEN 
        ISTP   = NWKYDK + 1 
        DO 35 IK = 1, NKEYDK    
          IP     = KOFSDB + LCDRDB + IKDRDB + (IK-1)*ISTP + MSERDB  
          IF (IQ(IP).GT.LOBJ) LOBJ = IQ(IP) 
   35   CONTINUE    
      ENDIF 
      NINS   = NKEYDK   
*   
* *** Lock the directory if necessary   
*   
      IF (IOPP.EQ.0.AND.IOPS.NE.0) THEN 
        CALL RZCDIR (PATHY, ' ')    
        NKEYDK = IQUEST(7)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        CALL RZLOCK ('DBENTB')  
        PATHL  = PATHY  
        IF (IOPTP.NE.0) THEN    
          CALL RZCDIR (PATHX, ' ')  
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
        ENDIF   
      ENDIF 
*   
* *** Loop over all the objects 
*   
      DO 40 IOBJ = 1, NTKEY 
        LOBJ   = LOBJ + 1   
        NINS   = NINS + 1   
*   
        IDB    = IDBTYP (LSUP(IOBJ))    
        IF (IDB.EQ.2.OR.IDB.EQ.3) THEN  
          IOPTR  = 0    
        ELSE    
          IOPTR  = 1    
        ENDIF   
*   
        IF (IOPRDA.NE.0 .OR. IOPTR.NE.0 .OR. IOPTDA.NE.0)  THEN 
          IF (IOPTDA.NE.0) THEN 
            CHOP   = 'S'    
          ELSE IF (IOPRDA.NE.0) THEN    
            CHOP   = 'L'    
          ELSE  
            CHOP   = ' '    
          ENDIF 
        ELSE    
          CHOP   = 'S'  
        ENDIF   
*   
*  **   Fill up Key vectors 1,2,6,7 
*   
        KEY(MSERDB,IOBJ) = LOBJ 
        KEY(MUPNDB,IOBJ) = 0    
        KEY(MFLGDB,IOBJ) = MSBIT0 (KEY(MFLGDB,IOBJ), JRZUDB)    
        KEY(MFLGDB,IOBJ) = MSBIT0 (KEY(MFLGDB,IOBJ), JPRTDB)    
        KEY(MFLGDB,IOBJ) = MSBIT0 (KEY(MFLGDB,IOBJ), JASFDB)    
        IF (IOKYDA(MITMDB).EQ.0.OR.KEY(MITMDB,IOBJ).LE.0) THEN  
          CALL DATIME (IDATE, ITIME)    
          CALL DBPKTM (IDATE, ITIME, IDATM) 
          KEY(MITMDB,IOBJ) = IDATM  
        ENDIF   
*   
*  **   Write the sequential output if needed   
*   
        IF (LUFZDF.GT.0) THEN   
          CALL UCOPY_i (KEY(1,IOBJ), IHEADF(MPREDF+1), NWKYDK)    
          CALL FZOUT (LUFZDF, IUDIV, LSUP(IOBJ), 1, CHOP, IOFMDF,   
     +                NWDH, IHEADF) 
          IF (IQUEST(1).NE.0) THEN  
            IQUEST(1)  = 77 
            IQUEST(11) = IOBJ   
            IQUEST(12) = NTKEY  
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Err'//    
     +      'or in FZOUT while writing Data for '',2I12)', IQUEST(11),2)    
            GO TO 997   
          ENDIF 
        ENDIF   
*   
        IF (IOPRDA.NE.0 .OR. IOPTR.NE.0 .OR. IOPTDA.NE.0)  THEN 
*   
*  **     RZ mode output    
*   
          KEY(MFLGDB,IOBJ) = MSBIT1 (KEY(MFLGDB,IOBJ), JRZUDB)  
          IF (IOPTDA.NE.0)  
     +      KEY(MFLGDB,IOBJ) = MSBIT1 (KEY(MFLGDB,IOBJ), JASFDB)    
*   
          IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')   
          CALL RZOUT (IUDIV, LSUP(IOBJ), KEY(1,IOBJ), ICYCLE, CHOP) 
*   
        ELSE    
*   
*  **     Copy data to DB internal store    
*   
*  **     0 Data word : do not pack 
*   
          IF (IQ(KOFUDB+LSUP(IOBJ)-1).EQ.0) IOPUDA = 1  
          CALL DBFRUS (LSUP(IOBJ), LSTRDL(1), IPREC)    
          IF (IQUEST(1).NE.0)      GO TO 997    
*   
*  **     Compress the data if requested    
*   
          IF (IOPUDA.NE.0)  THEN    
            LREFDL(1) = LSTRDL(1)   
          ELSE  
            NOLD   = NKEYDK 
            NKEYDK = NINS - 1   
            CALL DBCOMP (LSTRDL(1), LREFDL(1), KEY(1,IOBJ)) 
            NKEYDK = NOLD   
          ENDIF 
          IF (IQUEST(1).NE.0)      GO TO 997    
*   
*  **     Drop the uncompressed data    
*   
          IF (LREFDL(1).NE.LSTRDL(1)) CALL MZDROP (IDISDB,LSTRDL(1),'L')    
*   
*  **     Write on to disk  
*   
          IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')   
          CALL RZOUT (IDISDB, LREFDL(1), KEY(1,IOBJ), ICYCLE, 'S')  
          IER    = IQUEST(1)    
          CALL MZDROP (IDISDB, LREFDL(1), 'L')  
          IQUEST(1) = IER   
          IF (IER.EQ.77)           GO TO 997    
*   
        ENDIF   
*   
        IF (IOPTP.NE.0) THEN    
          KEYN(MBVRDB) = MIN0 (KEYN(MBVRDB), KEY(MBVRDB,IOBJ))  
          KEYN(MEVRDB) = MAX0 (KEYN(MEVRDB), KEY(MEVRDB,IOBJ))  
        ENDIF   
        IF (IQUEST(1).NE.0)        GO TO 993    
        IF (IDEBDB.GT.1) THEN   
          CALL UCOPY_i (KEY(1,IOBJ), KEYNDK, NWKYDK)  
          IARGDB(1) = IDATE 
          IARGDB(2) = ITIME 
          CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Data was inserted into'//    
     +         '   '//PATHY//''',/,10X,''on the '',I8,'' at '',I6,'' '//    
     +         'with Key-Vector '')', IARGDB, 2)    
          CALL DBKEYT   
          CALL DBPRKY (NWKYDK, KEYNDK, IOTYDK)  
        ENDIF   
        IF (IOPTP.NE.0) THEN    
          IF (NINS.GE.MXKP.AND.IOBJ.LT.NTKEY) THEN  
            CALL RZCDIR (PATHY, ' ')    
            IF (IQUEST(1).NE.0)    GO TO 991    
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
            NKEYDK = IQUEST(7)  
*   
*  **       Rename Keys 3 and 4 of the latest subdirectory  
*   
            CALL RZRENK (KEYO, KEYN)    
            IF (IQUEST(1).NE.0) THEN    
              IQUEST(1) = 74    
              IF (IDEBDB.GT.0) THEN 
                CALL UCOPY_i  (KEYO, IARGDB(1),        NSYSDK)    
                CALL UCOPY_i  (KEYN, IARGDB(NSYSDK+1), NSYSDK)    
                CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Error in RZREN'//  
     +               'K while writing data for '//PATHY//''',/(10X,'//  
     +               '7I12))', IARGDB, 2*NSYSDK)    
              ENDIF 
              GO TO 998 
            ENDIF   
*   
*  **       Make a different subdirectory if there are too many keys    
*   
            IF (IOKYDA(MITMDB).EQ.0.OR.KEY(MITMDB,IOBJ+1).LE.0) THEN    
              KEY7DK = 0    
            ELSE    
              KEY7DK = KEY(MITMDB,IOBJ+1)   
            ENDIF   
            CALL DBMDIP (PATHY, NWKYS, CHFOR, CTAGDK, MXKP) 
            IF (IQUEST(1).NE.0)    GO TO 998    
            CALL RZCDIR (PATHY, ' ')    
            NKEYDK = IQUEST(7)  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
            KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),   
     +                       NKEYDK*KST, KST)   
            IF (KPNT.NE.0) THEN 
              NK     = (KPNT - MPSRDB) / KST + 1    
            ELSE    
              NK     = NKEYDK   
            ENDIF   
            CALL DBKEYR (NK, NWKYDK, KEYO)  
            CALL DBPATH (PATHX, NKEYDK) 
            CALL RZCDIR (PATHX, ' ')    
            IF (IQUEST(1).NE.0)    GO TO 991    
            NKEYDK = IQUEST(7)  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
            NINS   = 0  
            CALL UCOPY_i (KEYO, KEYN, NWKYDK) 
          ENDIF 
        ENDIF   
   40 CONTINUE  
      GO TO 997 
*   
* *** Error messages    
*   
  991 IQUEST(1) = 71    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Illegal '// 
     +   'Path Name '//PATHY//PATHX(1:8)//''')', IARGDB, 0) 
      GO TO 998 
*   
  993 IQUEST(1) = 73    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Error in '//    
     +   'RZOUT while writing Data for '//PATHY//PATHX(1:8)//''')', 
     +   IARGDB, 0) 
*   
  997 IER   = IQUEST(1) 
      IF (IOPTP.NE.0)  THEN 
        IF (NINS.GT.0)  THEN    
          CALL RZCDIR (PATHY, ' ')  
          IF (IQUEST(1).NE.0) THEN  
            IF (IER.EQ.0) THEN  
              GO TO 991 
            ELSE    
              IQUEST(1) = IER   
            ENDIF   
          ELSE  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
            NKEYDK = IQUEST(7)  
            IQUEST(1) = IER 
*   
*  **       Rename Keys 3 and 4 of the latest subdirectory  
*   
            IF (IER.EQ.0) THEN  
              CALL RZRENK (KEYO, KEYN)  
              IF (IQUEST(1).NE.0) THEN  
                IQUEST(1) = 74  
                IF (IDEBDB.GT.0) THEN   
                  CALL UCOPY_i  (KEYO, IARGDB(1),        NSYSDK)  
                  CALL UCOPY_i  (KEYN, IARGDB(NSYSDK+1), NSYSDK)  
                  CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Error in RZREN'//    
     +                 'K while writing data for '//PATHY//''',/(10X,'//    
     +                 '7I12))', IARGDB, 2*NSYSDK)  
                ENDIF   
              ENDIF 
            ENDIF   
          ENDIF 
        ENDIF   
      ENDIF 
*   
*  ** Free the locked directory if any  
*   
  998 CONTINUE  
      IF (PATHL.NE.' ') THEN    
        CALL RZCDIR (PATHL, ' ')    
        NKEYDK = IQUEST(7)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        CALL RZFREE ('DBENTB')  
      ENDIF 
*   
 2001 FORMAT (20(I2,A1,1X)) 
*                                                             END DBENTB    
  999 END   
      SUBROUTINE DBENTR (PATHN, LBK, LBD, IUDIV, LSUP, NWKEY, KEY, IPREC    
     +                 , CHOPT) 
*     ==================================================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBENTR (PATHN, *LBK*, LBD*, IUDIV, LSUP, NWKEY, KEY,    *    
*                      IPREC, CHOPT)                                   *    
*                                                                      *    
*   Stores data from memory to disk and also enters in the memory ala  *    
*   DBUSE in NODE/KEY structure                                        *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     LBK(*)   Address of Keys bank KYDB   (INPUT or OUTPUT)           *    
*     LBD(*)   Address of Data bank                                    *    
*     IUDIV    Division index of the user data bank                    *    
*     LSUP     Address of bank in memory where data reside             *    
*     NWKEY    Number of keys associated with the data bank            *    
*     KEY      Vector of keys                                          *    
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *    
*              IPREC significant digits right to the decimal points; if*    
*              IPREC < 0, data are stored with IPREC insignificant     *    
*              digits left to the decimal point.)                      *    
*     CHOPT    Character string with any of the following characters   *    
*          A   Trust LBK address if non-zero                           *    
*          B   Save in the special backup file; not in standard Journal*    
*          C   Create Node/Key data structure ala DBUSE                *    
*          F   Updates with a fully matched data object (in user keys) *    
*          K   Store data only inside the keys (not yet installed)     *    
*          N   Create new (sub)directory(ies)                          *    
*          P   Create partitioned subdirectories for the pathname      *    
*          R   Store with full RZ option (No compression to be made)   *    
*          S   Create stand alone (master) data                        *    
*          T   Special text type of data (to be used with R)           *    
*          U   Store data uncompressed                                 *    
*          Z   Store only nonzero elements. An element is considered to*    
*              be zero if its absolute value is less than IPREC (real) *    
*          7   Insertion time as supplied by user to be honoured       *    
*                                                                      *    
*   Called by user,   DBAIWR, DBUPKY                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 61 : Too many keys                                   *    
*               = 62 : Too many keys with option N                     *    
*               = 63 : Data base structure in memory clobbered         *    
*               = 64 : Error in MZCOPY while copying Data bank         *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      COMMON /DZPACK/ PRECDZ, PACKDZ    
      LOGICAL         PACKDZ    
*   
      DIMENSION       KEY(9), LBD(9), LBK(9)
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, FPATH*80, CHOP*2   
*
      integer ival
      real fval
      equivalence (ival, fval)
*     ------------------------------------------------------------------    
*   
* *** Decode the character option   
*   
      LREFDB(1) = LBK(1)    
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)          GO TO 999    
      PACKDZ = .FALSE.  
*   
      IF (IOPUDA.NE.0.AND.IOPZDA.NE.0)  THEN    
        IOPZDA = 0  
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBENTR : Warning'//    
     +  ' - Z option is incompatible with U option - U option will be'//    
     +  ' executed'')', IARGDB, 0)  
*   
      ELSE IF (IOPZDA.NE.0)  THEN   
        PACKDZ = .TRUE.
        ival = iprec
        precdz = fval
      ENDIF 
*   
      IF (IOPRDA.NE.0.AND.IOPNDA.NE.0)  THEN    
        IOPNDA = 0  
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBENTR : Warning'//    
     +  ' - R option is incompatible with N option - R option will be'//    
     +  ' executed'')', IARGDB, 0)  
      ENDIF 
*   
* *** Check the number of keys  
*   
      IF (NWKEY.GT.MXDMDK)  THEN    
        IQUEST(1) = 61  
        IQUEST(11)= NWKEY   
        IQUEST(12)= MXDMDK  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTR : Too man'//    
     +  'y keys '',I6,'' maximum permitted '',I6)', IQUEST(11), 2)  
        GO TO 999   
      ENDIF 
*   
      IF (IOPNDA.NE.0.AND.NWKEY.GT.NINEDK)  THEN    
        IQUEST(1) = 62  
        IQUEST(11)= NWKEY   
        IQUEST(12)= NINEDK  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTR : Too man'//    
     +  'y keys '',I6,'' with option N - a maximum of '',I6,'' permit'//    
     +  'ted'')', IQUEST(11), 2)    
        GO TO 999   
      ENDIF 
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Create new subdirectories if needed   
*   
      IF (NWKEY.GE.NSYSDK)  THEN    
        NTKEY  = NWKEY  
      ELSE  
        NTKEY  = NINEDK 
      ENDIF 
      IF (IOPNDA.NE.0)  THEN    
        IF (IOPPDA.EQ.0)  THEN  
          CALL DBMDIR (PATH, NTKEY, CHFTDK, CHTGDK) 
        ELSE    
          KEY7DK = 0    
          CALL DBMDIP (PATH, NTKEY, CHFTDK, CHTGDK, MXKPDK) 
        ENDIF   
        IF (IQUEST(1).NE.0)        GO TO 999    
      ENDIF 
*   
* *** Prepare the Key vector array  
*   
      CALL VZERO_i (KEYVDK, MXDMDK)   
      KEYVDK(MBVRDB) = KEY(MBVRDB)  
      KEYVDK(MEVRDB) = KEY(MEVRDB)  
      KEYVDK(MPVSDB) = KEY(MPVSDB)  
      IOKYDA(MPVSDB) = 1    
      IF (IOKYDA(MITMDB).NE.0) KEYVDK(MITMDB) = KEY(MITMDB) 
      IF (NWKEY.GT.NSYSDK) THEN 
        DO 20 NK = NSYSDK+1, NWKEY  
          IOKYDA(NK) = 1    
          KEYVDK(NK) = KEY(NK)  
   20   CONTINUE    
      ENDIF 
*   
* *** Write out the data    
*   
      CALL DBKOUT (PATH, IUDIV, LSUP, NTKEY, KEYVDK, IPREC)  
      IF (IQUEST(1).NE.0)          GO TO 999    
*   
* *** Create data bank in memory ala DBUSE  
*   
      IF (IOPCDA.NE.0)  THEN    
*   
*  **   Create database skeleton in memory (banks NODB and KYDB)    
*   
        IF (IOPADA.EQ.0. OR. (IOPADA.NE.0. AND. LREFDB(1).EQ.0) )  THEN 
*   
          CALL DBNODE (PATH, LBNODB)    
          IF (IQUEST(1).NE.0)      GO TO 999    
*   
*  *      Switch off M and/or S option of DBUSE 
*   
          ITMPM  = IOPMDA   
          ITMPS  = IOPSDA   
          IOPMDA = 0    
          IOPSDA = 0    
*   
          CALL DBKEYS (LBNODB, KEYVDK, LBK, KEYVDK(MBVRDB)) 
          IF (IQUEST(1).NE.0)      GO TO 999    
          LREFDB(1) = LBK(1)    
          IOPMDA = ITMPM    
          IOPSDA = ITMPS    
          CALL UCOPY_i (KEYVDK(1), IQ(KOFUDB+LREFDB(1)+1), NWKYDK)    
          NDK    = IQ(KOFUDB+LREFDB(1)-1)   
          IQ(KOFUDB+LREFDB(1)+NDK+MKYFRI) = 0   
          IQ(KOFUDB+LREFDB(1)+NWKYDK+1)   = KEYVDK(MEVRDB)  
*   
        ELSE    
*   
          IF (IDEBDB.GT.0) THEN 
            LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)    
            NF     = IQ(KOFUDB+LBNODB+MNDNCH)   
            CALL UHTOC (IQ(KOFUDB+LBNODB+MNDNAM), 4, FPATH, NF) 
            FPATH  = FPATH(1:NF)    
            N = INDEX (PATH, ' ')   
            IF (N.EQ.0)  N = LEN (PATH) + 1 
*   
   50       N = N -1    
            IF (PATH(N:N).NE.FPATH(NF:NF))  THEN    
              IQUEST(1) = 63    
              IQUEST(11)= N 
              CALL DBPRNT (LPRTDB, '(/,'' DBENTR : Database structure'//    
     +             ' in memory clobbered'')', IARGDB, 0)    
              GO TO 999 
            ELSE IF (N.NE.1)  THEN  
              NF = NF -1    
              GO TO 50  
            ENDIF   
          ENDIF 
*   
          CALL UCOPY_i (KEYVDK(1), IQ(KOFUDB+LREFDB(1)+1), NWKYDK)    
          NDK    = IQ(KOFUDB+LREFDB(1)-1)   
          IQ(KOFUDB+LREFDB(1)+NDK+MKYFRI) = 0   
          IQ(KOFUDB+LREFDB(1)+NWKYDK+1)   = KEYVDK(MEVRDB)  
        ENDIF   
*   
*  **   Now copy the data banks appended at LSUP to the key bank    
*   
        IF (IOPRDA.EQ.0)  THEN  
          CHOP   = 'NP' 
        ELSE    
          CHOP   = 'LP' 
        ENDIF   
*   
        IF (IOPKDA.EQ.0 .AND. LSUP.NE.0) THEN    
          CALL MZCOPY (IUDIV, LSUP, IDIVDB, LREFDB(1), -KLDADB, CHOP)    
        ENDIF   
*   
        IF (IQUEST(1).EQ.0)  THEN   
          LBD(1) = LQ(KOFUDB+LREFDB(1)-KLDADB)  
        ELSE    
          IQUEST(11)= IQUEST(1) 
          IQUEST(1) = 64    
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTR : Error'//    
     +    ' '',I6,'' while copying the Data bank in the Node/Key stru'//    
     +    'cture'')', IQUEST(11), 1)    
        ENDIF   
*   
      ENDIF 
*                                                             END DBENTR    
  999 END   
      SUBROUTINE DBFREE (PATHN, LBK, KEYS, CHOPT)   
*     ===========================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBFREE (PATHN, LBK, KEYS, CHOPT)                        *    
*                                                                      *    
*   Declares the given data bank(s) as candidates to be dropped in     *    
*   case space is needed in the database division. Optionally it       *    
*   deletes the Data bank(s) (with option D) or the Keys as well as    *    
*   the Data bank(s) (with option K).                                  *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     LBK(*)   Address(es) of Keys bank(s) KYDB                        *    
*     KEYS     Vector of keys                                          *    
*     CHOPT    Character string with any of the following characters   *    
*          A   trust LBK address(es) if non-zero                       *    
*          D   drop the Data bank(s) supported at link 1 of Key bank(s)*    
*          K   drop the Key bank(s) as well as Data bank(s)            *    
*          M   expect multiple Key banks                               *    
*          S   Key/data was retrieved using 'S' option in DBUSE        *    
*          V   declare the Data as being of variable size              *    
*          3   start valdity time to be < KEYS(3) (with option S)      *    
*          4   end   valdity time to be > KEYS(4) (with option S)      *    
*          5   specific Program version number required                *    
*          7   insertion time to be < KEYS(7)                          *    
*          n   consider user key n (7 < n < 29)                        *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 51 : Illegal character option                        *    
*               = 52 : No access to the Key banks                      *    
*               = 53 : Pathname not found in the RZ directory          *    
*               = 54 : Pathname not matched to that found in bank NODB *    
*               = 55 : Too many keys with option M                     *    
*               = 56 : Illegal Key option                              *    
*               = 57 : Illegal pathname                                *    
*               = 58 : Database structure in memory clobbered          *    
*               = 59 : Some of the expected key banks not found        *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NMLMDM=10)   
      COMMON /DMULOP/ INDXDM(NMLMDM), KEYVDM(NMLMDM), KTYPDM(NMLMDM)    
     +              , LFKYDM(NMLMDM), NOCCDM(NMLMDM)    
*   
      CHARACTER       FPATH*80, FTEMP*80, FTMP1*80, CNODE(20)*16, CHL*16    
      CHARACTER       PATH*80, PATHN*(*), CHOPT*(*) 
      DIMENSION       LBK(9), KEYS(9)   
*   
*     ------------------------------------------------------------------    
*   
* *** Decode all the options    
*   
      LREFDB(1) = LBK(1)    
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)                              GO TO 999    
      IF (IOPMDA.NE.0 .AND. IOPSDA.NE.0)  THEN  
        IQUEST(1) = 51  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFREE : Illegal'//    
     +  ' character option -- Options S/M are mutually exclusive'')',   
     +  IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Check if Key bank address is usable   
*   
      IF (PATH(1:1).NE.'*'.AND.PATH(1:1).NE.' ') THEN   
        IPUSE = 1   
      ELSE  
        IPUSE = 0   
      ENDIF 
      IF (LREFDB(1).NE.0.AND.IOPADA.NE.0) THEN  
        IKUSE = 1   
      ELSE  
        IKUSE = 0   
      ENDIF 
*   
* *** Check if the options are consistent   
*   
      IF (IPUSE+IKUSE.EQ.0)  THEN   
        IQUEST(1) = 52  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFREE : Illegal'//    
     +  ' entry -- No access to Key bank '')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
*   
      IF (IKUSE.NE.0)                                  GO TO 10 
      IF (IPUSE.NE.0)  THEN 
        CALL RZCDIR (PATH, ' ') 
        IF (IQUEST(1).NE.0)  THEN   
          IQUEST(1) = 53    
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFREE : Pathn'//    
     +    'ame '//PATH(1:NCHAR)//' not found in RZ directory'')',   
     +    IARGDB, 0)    
          GO TO 999 
        ENDIF   
        NWKYDK = IQUEST(8)  
        CALL RZCDIR (FPATH, 'R')    
*   
      ELSE  
        LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)    
        NWKYDK = IQ(KOFUDB+LBNODB+MNDNWK)   
      ENDIF 
*   
      IF (IPUSE.NE.0.AND.IKUSE.NE.0)  THEN  
        LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)    
        NCHAR  = IQ(KOFUDB+LBNODB+MNDNCH)   
        IF (NCHAR.GT.MAXLDB) NCHAR  = MAXLDB    
        CALL UHTOC (IQ(KOFUDB+LBNODB+MNDNAM), 4, FTMP1, NCHAR)  
        FTEMP  = FTMP1(1:NCHAR) 
        IF (FTEMP.NE.FPATH)  THEN   
          IQUEST(1) = 54    
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFREE : Pathn'//    
     +    'ame '//FPATH//' not matched to '',/,18X,'' '//FTEMP//' fou'//    
     +    'nd in bank NODB'')', IARGDB, 0)  
          GO TO 999 
        ENDIF   
      ENDIF 
*   
   10 IQUEST(1) = 0 
*   
* *** Get number of key banks needed    
*   
      NMUL   = 0    
      NKYMX  = 1    
      ISTKY  = NWKYDK   
      IF (IOPMDA.NE.0)  THEN    
        IF (NWKYDK.GT.NSYSDK)  THEN 
          DO 15 I = NSYSDK+1, NWKYDK    
            IF (IOKYDA(I).NE.0) THEN    
              IF (NMUL.GE.NMLMDM)  THEN 
*   
*  **           Too many keys with option M 
*   
                IQUEST(1)  = 55 
                IQUEST(11) = NMLMDM + 1 
                IQUEST(12) = I  
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFREE :'//    
     +          ' Too many keys '',I3,'' with M option - Last Key'','// 
     +          'I3)', IQUEST(11), 2)   
                GO TO 999   
              ENDIF 
*   
              IF (KEYS(I).LE.0)  THEN   
*   
*  **           Illegal key option  
*   
                IQUEST(1)  = 56 
                IQUEST(11) = I  
                IQUEST(12) = KEYS(I)    
                IF (IDEBDB.GT.0) THEN   
                  IARGDB(1) = IQUEST(12)    
                  IARGDB(2) = IQUEST(11)    
                  CALL DBPRNT (LPRTDB, '(/,'' DBFREE : Illegal key op'//    
     +                 'tion '',I3,'' for key '',I3,'' with option M'')'    
     +,                IARGDB, 2)   
                ENDIF   
                GO TO 999   
              ENDIF 
*   
*  **         Build up the array of keys used for option M  
*   
              NMUL   = NMUL + 1 
              NOCCDM(NMUL) = KEYS(I)    
              LFKYDM(NMUL) = ISTKY  
              KTYPDM(NMUL) = I  
              ISTKY  = ISTKY + KEYS(I)  
              NKYMX  = NKYMX * KEYS(I)  
            ENDIF   
   15     CONTINUE  
        ENDIF   
      ENDIF 
*   
* *** Get the L-address of the first Key bank   
*   
      IF (IKUSE.NE.0)  THEN 
        LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)    
        LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)   
        ND     = IQ(KOFUDB+LBNODB+MNDNWD)   
      ELSE  
*   
*  **   Get it from the pathname    
*  **   First find the list of Nodes    
*   
        NODES  = 0  
        MAXL   = MAXLDB 
        I0     = 0  
   20   I1     = I0 + 1 
        IF (I1.GT.MAXL)                                GO TO 45 
        DO 25 I0 = I1, MAXL 
          IF (FPATH(I0:I0).EQ.' ')                     GO TO 35 
          IF (FPATH(I0:I0).EQ.'/')                     GO TO 30 
   25   CONTINUE    
        I0     = MAXL + 1   
   30   I2     = I0 - 1 
        GO TO 40    
   35   I2     = I0 - 1 
        I0     = MAXL + 1   
   40   IF (I2.LT.I1)                                  GO TO 20 
        NODES  = NODES + 1  
        CNODE(NODES) = FPATH(I1:I2) 
        GO TO 20    
*   
*  **   Number of Nodes found should be nonzero 
*   
   45   CONTINUE    
        IF (NODES.EQ.0)  THEN   
          IQUEST(1) = 57    
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFREE : Illeg'//    
     +    'al pathname '//FPATH//''')', IARGDB, 0)  
          GO TO 999 
        ENDIF   
*   
*  **   Go through the Nodes to reach the bottom level  
*   
        IN     = 0  
   50   IN     = IN + 1 
*   
*  *    Construct the pathname from the Node names  
*   
        NCHAR  = 2  
        FPATH  = '//'   
        MAXL   = 16 
        DO 60 I = 1, IN 
          CHL    = CNODE(I) 
          DO 55 J = 1, MAXL 
            IF (CHL(J:J).EQ.' ') THEN   
               NMAX   = J - 1   
             ELSE   
               IF (J.NE.MAXL)                          GO TO 55 
               NMAX   = J   
             ENDIF  
*   
            IF (NCHAR+NMAX .GT. MAXLDB) NMAX = MAXLDB - NCHAR   
            IF (I.EQ.1)  THEN   
              FPATH  = '//'//CHL(1:NMAX)    
              NCHAR  = NMAX + 2 
            ELSE    
              FTEMP  = FPATH(1:NCHAR)//'/'//CHL(1:NMAX) 
              FPATH  = FTEMP    
              NCHAR  = NCHAR + NMAX + 1 
            ENDIF   
            IF (NCHAR.EQ.MAXLDB)                       GO TO 65 
            GO TO 60    
   55     CONTINUE  
   60   CONTINUE    
*   
*  *   The first Node should be at the top directory    
*   
   65   I0     = 0  
        IF (IN.EQ.1) THEN   
          NMAX   = NTOPDB   
          LBFXDB = LTOPDB   
        ELSE    
          NMAX   = IQ(KOFUDB+LBKYDB-2)  
        ENDIF   
*   
   70   I0     = I0 + 1 
*   
*  *    No link left for the Node bank  
*   
        IF (I0.GT.NMAX)  THEN   
          IQUEST(1) = 58    
          IQUEST(11)= IN    
          IQUEST(12)= NODES 
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFREE : Node'// 
     +    ' '//CNODE(IN)//' at level '',I3,'' out of '',I3,'' not fou'//    
     +    'nd'')', IQUEST(11), 2)   
          GO TO 999 
        ENDIF   
*   
        IF (IN.EQ.1)  THEN  
          IF (I0.GT.1) LBFXDB = LQ(KOFUDB+LBFXDB)   
          LBNODB = LQ(KOFUDB+LBFXDB-1)  
        ELSE    
          LBNODB = LQ(KOFUDB+LBKYDB-I0) 
        ENDIF   
        IF (LBNODB.EQ.0)                               GO TO 70 
*   
*  *    Check the full pathname in the Node bank name against   
*  *    the current pathname    
*   
        MCHAR  = IQ(KOFUDB+LBNODB+MNDNCH)   
        IF (MCHAR.GT.MAXLDB) MCHAR  = MAXLDB    
        CALL UHTOC (IQ(KOFUDB+LBNODB+MNDNAM), 4, FTMP1, MCHAR)  
        FTEMP  = FTMP1(1:MCHAR) 
        IF (FTEMP.NE.FPATH)                            GO TO 70 
*   
        LBKYDB = LBNODB 
        IF (IN.LT.NODES)                               GO TO 50 
        ND     = IQ(KOFUDB+LBNODB+MNDNWD)   
        LBKYDB = LQ(KOFUDB+LBKYDB)  
      ENDIF 
*   
* *** Number of Key banks to be serviced with option S  
*   
      IF (IOPSDA.NE.0)  THEN    
        NKYMX  = NZBANK (IDIVDB, LBKYDB)    
        NMUL   = 0  
      ENDIF 
*   
* *** Loop over all possible Key Banks  
*   
      NK     = 0    
      IQER1  = 0    
   75 NK     = NK + 1   
*   
*  ** For option 'M', find the corresponding key values 
*   
      IF (NMUL.GT.0)  THEN  
        DO 85 I = 1, NMUL   
          NK0    = NK   
          IF (I.NE.1)  THEN 
            DO 80 J = 1, I-1    
              NK0    = (NK0 - INDXDM(J)) / NOCCDM(J) + 1    
   80       CONTINUE    
          ENDIF 
          NK0    = MOD (NK0, NOCCDM(I)) 
          IF (NK0.EQ.0) NK0 = NOCCDM(I) 
          INDXDM(I) = NK0   
          KEYVDM(I) = KEYS(LFKYDM(I)+NK0)   
   85   CONTINUE    
      ENDIF 
*   
*  ** Check if this Key bank already exists 
*   
      IF (IOPSDA.EQ.0) LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)    
   90 CONTINUE  
      IF (LBKYDB.NE.0)  THEN    
        IF (IOPSDA.EQ.0)  THEN  
          IF (IOKYDA(MPVSDB).NE.0.AND.  
     +        KEYS(MPVSDB).NE.IQ(KOFUDB+LBKYDB+MPVSDB))GO TO 115    
          IF (IOKYDA(MITMDB).NE.0.AND.  
     +        KEYS(MITMDB).LT.IQ(KOFUDB+LBKYDB+MITMDB))GO TO 115    
          IF (NWKYDK.GT.NSYSDK)  THEN   
            IF (NMUL.EQ.0)  THEN    
              DO 95 I = NSYSDK+1, NWKYDK    
                IF (IOKYDA(I).NE.0)  THEN   
                  IF (KEYS(I).NE.IQ(KOFUDB+LBKYDB+I))  GO TO 115    
                ENDIF   
   95         CONTINUE  
            ELSE    
              DO 100 I = 1, NMUL    
                NU     = KTYPDM(I)  
                IF (KEYVDM(I).NE.IQ(KOFUDB+LBKYDB+NU)) GO TO 115    
  100         CONTINUE  
            ENDIF   
          ENDIF 
*   
        ELSE    
*   
          IF (IOKYDA(MBVRDB).NE.0.AND.  
     +        KEYS(MBVRDB).LT.IQ(KOFUDB+LBKYDB+MBVRDB))GO TO 115    
          IF (IOKYDA(MEVRDB).NE.0.AND.  
     +        KEYS(MEVRDB).GT.IQ(KOFUDB+LBKYDB+MEVRDB))GO TO 115    
          IF (IOKYDA(MPVSDB).NE.0.AND.  
     +        KEYS(MPVSDB).NE.IQ(KOFUDB+LBKYDB+MPVSDB))GO TO 115    
          IF (IOKYDA(MITMDB).NE.0.AND.  
     +        KEYS(MITMDB).LT.IQ(KOFUDB+LBKYDB+MITMDB))GO TO 115    
          IF (NWKYDK.GT.NSYSDK)  THEN   
            DO 105 I = NSYSDK+1, NWKYDK 
              IF (IOKYDA(I).NE.0)  THEN 
                IF (KEYS(I).NE.IQ(KOFUDB+LBKYDB+I))    GO TO 115    
              ENDIF 
  105       CONTINUE    
          ENDIF 
        ENDIF   
*   
*  **   Take proper action according to character option    
*   
        IF (IOPKDA.NE.0)  THEN  
*   
*  *      Drop the Key bank 
*   
          LKEY   = LBKYDB   
          LBKYDB = LQ(KOFUDB+LKEY+2)    
          CALL MZDROP (IDIVDB, LKEY, ' ')   
        ELSE IF (IOPDDA.NE.0) THEN  
*   
*  *      Drop the data bank    
*   
          CALL MZDROP (IDIVDB, LBKYDB, 'V') 
        ELSE    
*   
*  *      Set the free bit  
*   
          IQ(KOFUDB+LBKYDB+ND+MKYFRI) = 1   
        ENDIF   
        GO TO 120   
  115   LBKYDB = LQ(KOFUDB+LBKYDB)  
        GO TO 90    
*   
      ELSE  
*   
        IF (IOPSDA.EQ.0) THEN   
          IF (IDEBDB.GT.0.AND.IQER1.EQ.0) CALL DBPRNT (LPRTDB,'(/,'' '//    
     +      'DBFREE : Atleast one of the required key bank(s) not fou'//    
     +      'nd'')', IARGDB, 0) 
          IQER1  = 59   
          IF (IOPMDA.NE.0) LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)    
        ELSE    
          IQUEST(1) = 0 
          GO TO 999 
        ENDIF   
      ENDIF 
*   
  120 CONTINUE  
      IF (IOPSDA.EQ.0)  THEN    
        IF (NK.LT.NKYMX)                               GO TO 75 
      ELSE  
        IF (LBKYDB.NE.0) LBKYDB = LQ(KOFUDB+LBKYDB) 
        IF (LBKYDB.NE.0)                               GO TO 75 
      ENDIF 
      IQUEST(1) = IQER1 
*                                                             END DBFREE    
  999 END   
      SUBROUTINE DBFZOP (LUNFZ, TOPN, CHOPT)    
*     ======================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBFZOP (LUNFZ, TOPN, CHOPT)                             *    
*                                                                      *    
*   Sets the output FZ file number as the sequential backup file for   *    
*   a given top directory. One can have up to two backup files, one    *    
*   for standard journaling, the other for special backups.            *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUNFZ    Logical unit number of the FZ file                      *    
*     TOPN     Top directory name to which the FZ file refers          *    
*     CHOPT    Character string with any of the following characters   *    
*          B   Specify a special backup file                           *    
*                                                                      *    
*   Called by user,   DBACTI                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =140 : Illegal top directory name                      *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      CHARACTER       TOPN1*16, TOPN2*16, TOPN*(*), CHOPT*(*)   
*   
*     ------------------------------------------------------------------    
*   
* *** Decode the character option   
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0) GO TO 999 
      CALL DBSBLC (TOPN, TOPN2, NCHAR)  
*   
* *** Check if the topname matches with any of the existing topnames    
*   
      LTOP   = LTOPDB   
   10 IF (LTOP.GT.0) THEN   
        NCHR   = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPN1, NCHR) 
        TOPN1  = TOPN1(1:NCHR)  
        IF (TOPN2.NE.TOPN1) THEN    
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 10  
        ELSE    
          IF (IOPBDA.EQ.0) THEN 
            IOFF   = MUPJFL 
          ELSE  
            IOFF   = MUPBAK 
          ENDIF 
          LUNOL  = IQ(KOFUDB+LTOP+IOFF) 
          IQ(KOFUDB+LTOP+IOFF) = LUNFZ  
          IF (LUNOL.LE.0.AND.LUNFZ.GT.0) THEN   
            INC    = 1  
          ELSE IF (LUNOL.GT.0.AND.LUNFZ.LE.0) THEN  
            INC    = - 1    
          ELSE  
            INC    = 0  
          ENDIF 
          NUFZDF = NUFZDF + INC 
          IQUEST(1) = 0 
        ENDIF   
      ELSE  
        IQUEST(1) = 140 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZOP : Illegal'//    
     +  ' top directory name '//TOPN2(1:NCHAR)//''')', IARGDB, 0)   
      ENDIF 
*                                                             END DBFZOP    
  999 END   
      SUBROUTINE DBFZUP (LUNFZ, CHOPT)  
*     ================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBFZUP (LUNFZ, CHOPT)                                   *    
*                                                                      *    
*   Updates the data base from transcript file from unit LUNFZ         *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUNFZ    Logical unit number of the FZ file                      *    
*     CHOPT    Character string with any of the following characters   *    
*          F   Force continuation beyond errors                        *    
*          O   Updating journal file is an external source             *    
*          S   Updating journal file in a single record mode           *    
*                                                                      *    
*   Called by user,   DBACTI                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 76 : Cannot form the IO descriptor for the FZ header *    
*               =141 : Read error on the FZ file                       *    
*               =142 : Top directory name illegal in the transcript    *    
*                      file                                            *    
*               =143 : Illegal path name in the transcript file        *    
*               = 78 : Illegal number of keys in journal file          *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NLEVM=20)    
      DIMENSION       NLCUR(NLEVM), KEYN(MXDMDK)    
      CHARACTER       PATHN*80, PATHD*80, TOPN*16, CHOPT*(*)    
      CHARACTER       CHFOR*100, CFORM(6)*1, CHOPF*80, CHCUR(NLEVM)*1   
      CHARACTER       ALIAS*8, PATHZ*80 
      DATA            CFORM / 'B', 'I', 'F', 'D', 'H', 'A' /    
*
      dimension itmp(9)
*     ------------------------------------------------------------------    
*   
      PATHD  = ' '  
      IACTO  = 0    
      CALL UOPTC (CHOPT, 'F', IOPTF)    
      CALL UOPTC (CHOPT, 'O', IOVRD)    
      CALL UOPTC (CHOPT, 'S', ISNGR)    
*   
* *** Read the header record from the FZ file   
*   
   10 NWHEDF = NHEADF   
      CALL FZIN (LUNFZ, IDISDB, 0, 0, 'S', NWHEDF, IHEADF)  
      IF (IQUEST(1).GT.0)                                  GO TO 997    
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(11) = IQUEST(1)  
        IQUEST(1)  = 141    
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZUP : FZ erro'//    
     +  'r type '',I12)', IQUEST(11), 1)    
        IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0)   GO TO 998    
        IQUEST(1) = 0   
        GO TO 10    
      ENDIF 
      IACT   = IHEADF(MACTDF)   
      NWKEY  = IHEADF(MNKYDF)   
      NDOP   = IHEADF(MOPTDF)   
      NWDP   = IHEADF(MPATDF)   
      IF (IACT.EQ.1) THEN   
        NPNT1  = MPREDF + NWKEY + 1 
        NPNT2  = NPNT1 + NDOP   
      ELSE IF (IACT.EQ.2) THEN  
        NPNT1  = MRECDF + 1 
        NCFO   = (NWKEY + 3) / 4    
        NPNT2  = NPNT1 + NDOP + NCFO + 2 * NWKEY    
      ELSE IF (IACT.EQ.3) THEN  
        KEY7DK = IHEADF(MINSDF) 
        NPNT1  = MINSDF + NWKEY + 1 
        NPNT2  = NPNT1 + NDOP   
      ELSE IF (IACT.EQ.4) THEN  
        KEY7DK = IHEADF(MINSDF) 
        NPNT1  = MINSDF + 1 
        NPNT2  = NPNT1 + NDOP   
      ELSE IF (IACT.EQ.5) THEN  
        KEY7DK = 0  
        NPNT1  = MPREDF + 2*NWKEY + 1   
        NPNT2  = NPNT1  
      ELSE IF (IACT.EQ.6) THEN  
        KEY7DK = 0  
        NPNT1  = MFLGDF + NWKEY + 1 
        NPNT2  = NPNT1  
      ELSE IF (IACT.EQ.7) THEN  
        KEY7DK = 0  
        NPNT1  = MWDPDF + 1 
        NPNT2  = NPNT1  
      ELSE IF (IACT.EQ.8) THEN  
        KEY7DK = IHEADF(MDELDF) 
        NPNT1  = MKEPDF + 1 
        NPNT2  = NPNT1 + NDOP   
      ELSE IF (IACT.EQ.9) THEN  
        NPNT1  = MPREDF + NWKEY + 1 
        NPNT2  = NPNT1 + NDOP   
      ELSE  
        IF (LUNFZ.EQ.LUFMDB.OR.ISNGR.NE.0)                 GO TO 997    
        GO TO 10    
      ENDIF 
*   
      IF (IACT.GT.0.AND.IACT.LE.6.AND.IACT.NE.4) THEN   
        IF (NWKEY.LT.NSYSDK.OR.NWKEY.GT.MXDMDK) THEN    
          IQUEST(1) = 78    
          IQUEST(11)= NWKEY 
          IQUEST(12)= NSYSDK    
          IQUEST(13)= MXDMDK    
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZUP : Illeg'//    
     +    'al number of keys '',I10,'' permitted range '',2I6)',    
     +    IQUEST(11),  3)   
          IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0) GO TO 998    
          IQUEST(1) = 0 
          GO TO 10  
        ENDIF   
      ENDIF 
*   
      IF (NDOP.GT.0) THEN   
        NDOP   = MIN0 (NDOP, MAXLDB/4)  
        CALL UHTOC (IHEADF(NPNT1), 4, CHOPF, 4*NDOP)    
        CHOPF  = CHOPF(1:4*NDOP)    
      ELSE  
        CHOPF  = ' '    
      ENDIF 
      CALL DBOPTS (CHOPF)   
      IF (IQUEST(1).GT.0) THEN  
        IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0)   GO TO 998    
        IQUEST(1) = 0   
        GO TO 10    
      ENDIF 
*   
      CALL UHTOC (IHEADF(NPNT2), 4, PATHN, 4*NWDP)  
      PATHN  = PATHN(1:4*NWDP)  
      NCH    = INDEX (PATHN, ' ') - 1   
      IF (NCH.LE.0) NCH = MAXLDB    
*   
* *** Extract the top directory name from the pathname  
*   
      CALL DBTOPN (PATHN, TOPN, I1) 
   20 IF (I1.EQ.0) THEN 
        IQUEST(1) = 142 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZUP : Illegal'//    
     +  ' top directory name '//PATHN//''')', IARGDB, 0)    
        IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0)   GO TO 998    
        IQUEST(1) = 0   
        GO TO 10    
      ENDIF 
*   
* *** Check if the topname matches with any of the existing topnames    
*   
      LTOP   = LTOPDB   
      LREFDB(1) = 0 
      IOPP   = 0    
   25 IF (LTOP.GT.0) THEN   
        NCHR   = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHR)    
        TOPNDI = TOPNDI(1:NCHR) 
        IF (TOPN.NE.TOPNDI) THEN    
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 25  
        ELSE    
          LREFDB(1) = LQ(KOFUDB+LTOP-KLFZDB)    
          IF (IOPBDA.EQ.0) THEN 
            LUFZDF = IQ(KOFUDB+LTOP+MUPJFL) 
          ELSE  
            LUFZDF = IQ(KOFUDB+LTOP+MUPBAK) 
          ENDIF 
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)  
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)   
        ENDIF   
      ELSE  
        IQUEST(1) = 142 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZUP : Illegal'//    
     +  ' top directory name '//PATHN//''')', IARGDB, 0)    
        IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0)   GO TO 998    
        IQUEST(1) = 0   
        GO TO 10    
      ENDIF 
      IF (IOUT.EQ.0) IOPS = 0   
*   
* *** Check if the directory is one in the list 
*   
      IF (LREFDB(1).NE.0) THEN  
        NCUR   = IQ(KOFUDB+LREFDB(1)-5) 
        DO 30 I = 1, NCUR   
          IPNT   = KOFUDB + LREFDB(1) + MFZDIR + (I - 1) * (MXLWDB + 1) 
          NCHZ   = IQ(IPNT) 
          CALL UHTOC (IQ(IPNT+1), 4, PATHZ, NCHZ)   
          IF ((PATHZ(1:NCHZ).EQ.PATHN(1:NCHZ)).AND. 
     +        (PATHN(NCHZ+1:NCHZ+1).EQ.'/'.OR.  
     +         PATHN(NCHZ+1:NCHZ+1).EQ.' '))               GO TO 35 
   30   CONTINUE    
        IQUEST(1) = 0   
        IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0)   GO TO 998    
        GO TO 10    
      ENDIF 
*   
* *** Decide overriding flag    
*   
   35 IOVRDB = IOVRD    
      IF (LBAFDB.NE.0) THEN 
        NCUR   = IQ(KOFUDB+LBAFDB-5)    
        DO 40 I = 1, NCUR   
          IPNT   = KOFUDB + LBAFDB + (I - 1) * (MXLWDB + 1) + 1 
          NCHZ   = IQ(IPNT) 
          CALL UHTOC (IQ(IPNT+1), 4, PATHZ, NCHZ)   
          IF ((PATHZ(1:NCHZ).EQ.PATHN(1:NCHZ)).AND.(NCHZ.EQ.NCH)) THEN  
            IOVRDB = 1  
            GO TO 45    
          ENDIF 
   40   CONTINUE    
      ENDIF 
*   
* *** Check if the current directory is to be changed   
*   
   45 IF (PATHN.NE.PATHD.OR.IACT.NE.IACTO) THEN 
        IF (IACT.NE.2) THEN 
          PATHZ  = PATHN    
        ELSE    
          PATHZ  = '//'//TOPN   
        ENDIF   
        CALL RZCDIR (PATHZ, ' ')    
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1) = 143   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZUP : Illeg'//    
     +    'al path name '//PATHZ//''')', IARGDB, 0) 
          IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0) GO TO 998    
          IQUEST(1) = 0 
          GO TO 10  
        ENDIF   
        IACTO  = IACT   
        NKEYDK = IQUEST(7)  
        NWKYDK = IQUEST(8)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        PATHD  = PATHN  
*   
*  **   Get the IO descriptor for the header    
*   
        IF (LUFZDF.GT.0.AND.IACT.EQ.1) THEN 
          CALL DBKEYT   
          NLEV   = 1    
          NCUR   = 5    
          IFORO  = 2    
          CHCUR(NLEV) = CFORM(IFORO)    
          DO 50 I = 1, NWKYDK   
            IFORM  = IOTYDK(I)  
            IF (IFORM.EQ.6) IFORM = 5   
            IF (IFORM.EQ.IFORO) THEN    
              NCUR   = NCUR + 1 
            ELSE    
              NLCUR(NLEV) = NCUR    
              IF (NLEV.GE.NLEVM) THEN   
                IQUEST(1) = 76  
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZUP :'//    
     +          ' Cannot get IO descriptor '//PATHN//''')', IARGDB, 0)  
                IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0)    
     +                                                     GO TO 998    
                IQUEST(1) = 0   
                GO TO 10    
              ENDIF 
              NLEV   = NLEV + 1 
              CHCUR(NLEV) = CFORM(IFORM)    
              NCUR   = 1    
              IFORO  = IFORM    
            ENDIF   
   50     CONTINUE  
          NLCUR(NLEV) = NCUR    
*   
          WRITE (CHFOR, 2001) (NLCUR(I), CHCUR(I), I = 1, NLEV) 
          II     = 4 *NLEV  
          CHFOR = CHFOR(1:II)//' -H'    
          CALL MZIOCH (IOFMDF, NWFMDF, CHFOR(1:II+3))   
        ENDIF   
      ENDIF 
*   
* *** Take appropriate action as directed by IACT   
*   
      IF (IACT.EQ.1) THEN   
*   
*  **   Enter data  
*   
        CALL DBENFZ (PATHN, LUNFZ, IOPP, TOPN, IOPS)    
        IF (IDEBDB.GT.0) THEN   
          CALL DBUPTM (IARGDB(1), IARGDB(2), IHEADF(MPREDF+MITMDB)) 
          IARGDB(3) = IQUEST(1) 
          CALL DBPRNT (LPRTDB, '('' DBFZUP : enter object in '//    
     +         PATHN(1:60)//' time '',2I8,'' return code '',I6)',   
     +         IARGDB, 3)   
        ENDIF   
        IF (IQUEST(1).LT.0)                                GO TO 997    
*   
      ELSE IF (IACT.EQ.2) THEN  
*   
*  **   Create a new directory  
*   
        IOKYDA(MSERDB) = 1  
        KEY7DK = IHEADF(MINSDF) 
        NPNTF  = NPNT1 + NDOP   
        CALL UHTOC (IHEADF(NPNTF), 4, CHFOR, NWKEY) 
        CHFOR  = CHFOR(1:NWKEY) 
        NPNTF  = NPNTF + NCFO   
        DO 60 IK = 1, NWKEY 
          CALL UHTOC (IHEADF(NPNTF), 4, CTAGDK(IK), 8)  
          NPNTF  = NPNTF + 2    
   60   CONTINUE    
        IF (IOPPDA.EQ.0) THEN   
          CALL DBMDIR (PATHN, NWKEY, CHFOR, CTAGDK) 
        ELSE    
          MXKP   = IHEADF(MXKPDF)   
          CALL DBMDIP (PATHN, NWKEY, CHFOR, CTAGDK, MXKP)   
        ENDIF   
        IOKYDA(MSERDB) = 0  
        IF (IDEBDB.GT.0) THEN   
          CALL DBUPTM (IARGDB(1), IARGDB(2), IHEADF(MINSDF))    
          IARGDB(3) = IQUEST(1) 
          CALL DBPRNT (LPRTDB, '('' DBFZUP : enter new directory '//    
     +         PATHN(1:60)//' time '',2I8,'' return code '',I6)',   
     +         IARGDB, 3)   
        ENDIF   
*   
      ELSE IF (IACT.EQ.3) THEN  
*   
*  **   Delete data objects 
*   
        ITIME  = IHEADF(MTIMDF) 
        IF (ITIME.GT.0) THEN    
          CALL UCOPY_i (IHEADF(MINSDF+1), KEYVDK, NWKEY)  
          CALL DBPURK (PATHN, ITIME, KEYVDK, CHOPF) 
        ELSE    
          KYDAT  = IHEADF(MINSDF+MSERDB)    
          KYTIM  = IHEADF(MINSDF+MUPNDB)    
          CALL DBPURG (PATHN, KYDAT, KYTIM, CHOPF)  
        ENDIF   
        IF (IDEBDB.GT.0) THEN   
          CALL DBUPTM (IARGDB(1), IARGDB(2), IHEADF(MINSDF))    
          IARGDB(3) = IQUEST(1) 
          IARGDB(4) = IQUEST(2) 
          CALL DBPRNT (LPRTDB, '('' DBFZUP : purge data from '//    
     +         PATHN(1:60)//' time '',2I8,'' return code '',I4,I6)',    
     +         IARGDB, 4)   
        ENDIF   
*   
      ELSE IF (IACT.EQ.4) THEN  
*   
*  **   Delete an entire tree   
*   
        CALL DBDELT (PATHN, CHOPF)  
        IF (IDEBDB.GT.0) THEN   
          CALL DBUPTM (IARGDB(1), IARGDB(2), IHEADF(MINSDF))    
          IARGDB(3) = IQUEST(1) 
          CALL DBPRNT (LPRTDB, '('' DBFZUP : delete the tree '//    
     +         PATHN(1:60)//' time '',2I8,'' return code '',I6)',   
     +         IARGDB, 3)   
        ENDIF   
        IF (IQUEST(1).EQ.171) IQUEST(1) = 0 
*   
      ELSE IF (IACT.EQ.5) THEN  
*   
*  **   Rename the keys 
*   
        CALL UCOPY_i  (IHEADF(MPREDF+1), KEYVDK, NWKEY)   
        CALL UCOPY_i  (IHEADF(MPREDF+NWKEY+1), KEYN, NWKEY)   
        CALL DBRENK (PATHN, KEYVDK, KEYN)   
        IF (IDEBDB.GT.0) THEN   
          CALL DBUPTM (IARGDB(1), IARGDB(2), IHEADF(MPREDF+MITMDB)) 
          IARGDB(3) = IQUEST(1) 
          CALL DBPRNT (LPRTDB, '('' DBFZUP : rename keys in '// 
     +         PATHN(1:60)//' time '',2I8,'' return code '',I6)',   
     +         IARGDB, 3)   
        ENDIF   
        IF (IQUEST(1).EQ.192) IQUEST(1) = 0 
*   
      ELSE IF (IACT.EQ.6) THEN  
*   
*  **   Enter the name or help information  
*   
        IFLG   = IHEADF(MFLGDF) 
        CALL UCOPY_i  (IHEADF(MFLGDF+1), KEYVDK, NWKEY)   
        CALL DBSNAM (IFLG, KEYVDK, 0, TOPN, LUNFZ)  
        IF (IDEBDB.GT.0) THEN   
          IARGDB(1) = IHEADF(MFLGDF+MSERDB) 
          CALL DBUPTM (IARGDB(2), IARGDB(3), IHEADF(MFLGDF+MITMDB)) 
          IARGDB(4) = IQUEST(1) 
          IF (IFLG.EQ.1) THEN   
            CALL DBPRNT (LPRTDB, '('' DBFZUP : enter help information'//    
     +           ' for path code '',I6,'' time '',2I8,'' return code'// 
     +           ' '',I6)', IARGDB, 4)  
          ELSE  
            CALL DBPRNT (LPRTDB, '('' DBFZUP : enter name information'//    
     +           ' for path code '',I6,'' time '',2I8,'' return code'// 
     +           ' '',I6)', IARGDB, 4)  
          ENDIF 
        ENDIF   
*   
      ELSE IF (IACT.EQ.7) THEN  
*   
*  **   Rename alias name of a given directory  
*   
        IFLG   = IHEADF(MFLGDF) 
        NWDF   = IHEADF(MWDPDF) 
        ALIAS  = ' '    
        CALL UHTOC  (IHEADF(MWDPDF+NWDP+1), 4, ALIAS, 8)    
        CALL UHTOC  (IHEADF(MWDPDF+NWDP+3), 4, CHOPF, 4*NWDF)   
        CHOPF  = CHOPF(1:4*NWDF)    
        CALL DBEALI (CHOPF, ALIAS, IFLG)    
        IF (IDEBDB.GT.0) THEN   
          CALL DBPRNT (LPRTDB, '('' DBFZUP : enter alias name for pat'//    
     +         'h '//CHOPF(1:60)//' return code '',I6)', IQUEST(1), 1)  
        ENDIF   
        IQUEST(1) = 0   
*   
      ELSE IF (IACT.EQ.8) THEN  
*   
*  **   Delete a few partitions in a partitioned directory  
*   
        IKEEP  = IHEADF(MKEPDF) 
        CALL DBPRGD (PATHN, IKEEP, CHOPF)   
        IF (IDEBDB.GT.0) THEN   
          IARGDB(1) = IKEEP 
          IARGDB(2) = IQUEST(1) 
          CALL DBPRNT (LPRTDB, '('' DBFZUP : delete all but '',I6,'' '//    
     +         'partitions in '//PATHN(1:60)//' return code '',I6)',    
     +         IARGDB, 2)   
        ENDIF   
        IQUEST(1) = 0   
*   
      ELSE IF (IACT.EQ.9) THEN  
*   
*  **   Use the forbidden path for updating data base (replace object)  
*
        itmp(1) = 0
        CALL FZIN (LUNFZ, IDISDB, LFIXDB, 2, 'A', 0, itmp) 
        IF (IQUEST(1).GT.0)                                GO TO 997    
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(11) = IQUEST(1)    
          IQUEST(1)  = 141  
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZUP : FZ er'//    
     +    'ror type '',I12)', IQUEST(11), 1)    
          GO TO 991 
        ENDIF   
        CALL UCOPY_i (IHEADF(MPREDF+1), KEYN, NWKEY)  
        CALL DBDONT (PATHN, IDISDB, LFIXDB, NWKEY, KEYN, CHOPF) 
        IKEEP  = IQUEST(1)  
        CALL MZDROP (IDISDB, LFIXDB, 'L')   
        LFIXDB = 0  
        IQUEST(1) = IKEEP   
        IF (IDEBDB.GT.0) THEN   
          IARGDB(1) = IKEEP 
          CALL DBPRNT (LPRTDB, '('' DBFZUP : updated data base in '//   
     +         'replace mode for '//PATHN(1:60)//' return code '',I6)', 
     +         IARGDB, 1)   
        ENDIF   
*   
      ENDIF 
  991 IF (IQUEST(1).GT.0) THEN  
        IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0)   GO TO 998    
        IQUEST(1) = 0   
        GO TO 10    
      ENDIF 
      IF (LUNFZ.NE.LUFMDB.AND.ISNGR.EQ.0)                  GO TO 10 
*   
  997 IQUEST(1) = 0 
  998 CONTINUE  
*   
 2001 FORMAT (20(I2,A1,1X)) 
*                                                             END DBFZUP    
      END   
      SUBROUTINE DBGET (PATHN, LBK, KEYS, CHOPT)    
*     ==========================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBGET (PATHN, LBK*, KEYS, CHOPT)                        *    
*                                                                      *    
*   Prepares the database data structure in memory for any required    *    
*   Pathname and set of Keys, unless already done.  Returns the        *    
*   in memory for the corresponding Key bank(s) with a selection on    *    
*   a range of start validity time and user keys.                      *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     LBK(*)   Address(es) of Keys bank(s) KYDB. The data bank address *    
*              can be obtained as LQ(LBK-1)                            *    
*              For option 'S' it is the support address of the linear  *    
*              structure                                               *    
*     KEYS     Vector of keys. Only the elements declared in CHOPT are *    
*              assumed to contain useful information.                  *    
*     CHOPT    Character string with any of the following characters   *    
*          K   read only the keys (no data is required)                *    
*          S   expect multiple Key banks satisfying selection on a     *    
*              number of keys                                          *    
*          3   selects objects with start validity time > KEYS(3)      *    
*          4   selects objects with start validity time < KEYS(4)      *    
*          5   specific Program version number required                *    
*          6   select objects with insertion time > KEYS(6)            *    
*          7   select objects with insertion time < KEYS(7)            *    
*          n   consider user key n (where 7 < n < 29 )                 *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =  2 : Illegal path name                               *    
*               = 32 : No keys/data in this directory                  *    
*                                                                      *    
*     If IQUEST(1) =0, IQUEST(2) carries information on number of      *    
*     data objects selected by DBGET                                   *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (NZ=0)    
      DIMENSION       KEYS(9), LBK(9)   
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, PATHY*80, PATHX*16 
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
* *** Initialize options    
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)                                    GO TO 999  
      IOPMDA = 0    
      LBK(1) = 0    
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Create (or complete) database skeleton in memory  
*   
      CALL DBNODE (PATH, LBNODB)    
      IF (IQUEST(1).NE.0)                                    GO TO 999  
*   
*  ** Start from the end of the existing chain  
*   
      IF (LQ(KOFUDB+LBNODB-KLKYDB).NE.0) THEN   
        LFIXDB = LZLAST (IDIVDB, LQ(KOFUDB+LBNODB-KLKYDB))  
        IF (LFIXDB.EQ.0) THEN   
          LFIXDB = LBNODB   
          JBIAS  =-KLKYDB   
        ELSE    
          JBIAS  = 0    
        ENDIF   
      ELSE  
        LFIXDB = LBNODB 
        JBIAS  =-KLKYDB 
      ENDIF 
      NDK    = IQ(KOFUDB+LBNODB+MNDNWD) 
      CALL UCOPY_i (IQ(KOFUDB+LBNODB+MNDIOF), IOKYDB, NWNODB) 
*   
* *** Set the current directory 
*   
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 2   
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGET : Illegal '//    
     +  'path name '//PATH//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
      CALL RZCDIR (PATH, 'R')   
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKEYT   
*   
      IF (NKEYDK.LE.0) THEN 
        IQUEST(1) = 32  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGET : No keys/'//    
     +  'data for  '//PATH//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
*   
      NCHR   = LENOCC (PATH)    
      NCHRT  = INDEX (PATH(3:NCHR), '/') - 1    
      IF (NCHRT.LE.0) NCHRT = NCHR - 2  
      PATHX  = PATH(3:NCHRT+2)  
      LBFXDB = LTOPDB   
    5 IF (LBFXDB.NE.0) THEN 
        NCHRT  = IQ(KOFUDB+LBFXDB+MUPNCH)   
        CALL UHTOC (IQ(KOFUDB+LBFXDB+MUPNAM), 4, TOPNDI, NCHRT) 
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN  
          LBFXDB = LQ(KOFUDB+LBFXDB)    
          GO TO 5   
        ENDIF   
        KY7MDB = IQ(KOFUDB+LBFXDB+MUPKY7)   
      ELSE  
        KY7MDB = 0  
      ENDIF 
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)   
*   
* *** Now create the key bank(s) and optionally the data bank   
*   
      NKB    = 0    
      IF (IOPTP.EQ.0) THEN  
        DO 20 JK = 1, NKEYDK    
          IK     = NKEYDK + 1 - JK  
          CALL DBKEYR (IK, NWKYDK, KEYVDK)  
          IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB))   
     +                                                       GO TO 20   
          IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB))   
     +                                                       GO TO 20   
          IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))   
     +                                                       GO TO 20   
          IF (IOKYDA(MFLGDB).NE.0.AND.KEYVDK(MITMDB).LT.KEYS(MFLGDB))   
     +                                                       GO TO 20   
          IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))   
     +                                                       GO TO 20   
          IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)      GO TO 20   
          IF (NWKYDK.GT.NSYSDK) THEN    
            DO 10 I = NSYSDK+1, NWKYDK  
              IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I))   GO TO 20   
   10       CONTINUE    
          ENDIF 
          IF (JBIT(KEYVDK(MFLGDB),JIGNDB).NE.0)              GO TO 20   
          CALL DBBOOK (IDIVDB, LBKYDB, LFIXDB, JBIAS, 'KYDB', NLKYDB,   
     +                 NSKYDB, NDK, IOKYDB, NZ) 
          IF (IQUEST(1).NE.0)                                GO TO 999  
          LQ(KOFUDB+LBKYDB-KLNODB) = LBNODB 
          LQ(KOFUDB+LBKYDB-KLUPDB) = LBFXDB 
          IQ(KOFUDB+LBKYDB+NDK+MKYFRI) = 0  
          IQ(KOFUDB+LBKYDB+NDK+MKYCRU) = IQ(KOFUDB+LBKYDB+NDK+MKYCRU) +1    
          IQ(KOFUDB+LBKYDB+NDK+MKYCEV) = IQ(KOFUDB+LBKYDB+NDK+MKYCEV) +1    
          NKB    = NKB + 1  
          IF (NKB.EQ.1) LBK(1) = LBKYDB 
          LFIXDB = LBKYDB   
          JBIAS  = 0    
          IF (IOPKDA.EQ.0) THEN 
            CALL VZERO_i (KEYVDK, NWKYDK) 
            KEYVDK(MSERDB) = IK 
            IOKYDA(MSERDB) = 1  
            CALL DBKXIN (ITIME, IDIVDB, LAUXDL(9), LBKYDB, -KLDADB, 
     +                   NWKEY, KEYVDK, IPREC)  
            IOKYDA(MSERDB) = 0  
            LAUXDL(9) = 0   
            IQ(KOFUDB+LBKYDB+NDK+MKYPRE) = IPREC    
            IQ(KOFUDB+LBKYDB+NDK+MKYRID) = IQ(KOFUDB+LBKYDB+NDK+MKYRID) 
     +                                   + 1    
          ENDIF 
          CALL UCOPY_i (KEYVDK(1), IQ(KOFUDB+LBKYDB+1), NWKYDK)   
          IQ(KOFUDB+LBKYDB+NWKYDK+1) = IQ(KOFUDB+LBKYDB+MBVRDB) + 1 
          IF (IQUEST(1).NE.0)                                GO TO 999  
          IF (IOPSDA.EQ.0) THEN 
            IQUEST(2) = NKB 
            GO TO 999   
          ENDIF 
   20   CONTINUE    
*   
      ELSE  
        KST    = NWKYDK + 1 
        NKEYS  = NKEYDK 
        DO 40 JKK = 1, NKEYS    
          IKK    = NKEYS + 1 - JKK  
          KPNT   = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),    
     +                     NKEYS*KST, KST)  
          IF (KPNT.GT.0) THEN   
            KPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB   
          ELSE  
            KPNT   = KOFSDB + LCDRDB + IKDRDB + (IKK - 1) * KST 
          ENDIF 
          IF (IOKYDA(MFLGDB).NE.0) THEN 
            IF (JKK.GT.1.AND.KEY7L.LT.KEYS(MFLGDB))          GO TO 40   
            KEY7L  = IQ(KPNT+MITMDB)    
          ENDIF 
          IF (IOKYDA(MBVRDB).NE.0.AND.IQ(KPNT+MEVRDB).LT.KEYS(MBVRDB))  
     +                                                       GO TO 40   
          IF (IOKYDA(MEVRDB).NE.0.AND.IQ(KPNT+MBVRDB).GT.KEYS(MEVRDB))  
     +                                                       GO TO 40   
          IF (IOKYDA(MITMDB).NE.0.AND.IQ(KPNT+MITMDB).GT.KEYS(MITMDB))  
     +                                                       GO TO 40   
          IF (KY7MDB.GT.0.AND.IQ(KPNT+MITMDB).GT.KY7MDB)     GO TO 40   
*   
          CALL DBPATH (PATHX, IKK)  
          PATHY  = PATH(1:NCHR)//'/'//PATHX 
          CALL RZCDIR (PATHY, ' ')  
          IF (IQUEST(1).NE.0) THEN  
            IQUEST(1) = 2   
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGET : Ille'//    
     +      'gal path name '//PATHY//''')', IARGDB, 0)  
            GO TO 999   
          ENDIF 
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          DO 30 JK = 1, NKEYDK  
            IK     = NKEYDK + 1 - JK    
            CALL DBKEYR (IK, NWKYDK, KEYVDK)    
            IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB)) 
     +                                                       GO TO 30   
            IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB)) 
     +                                                       GO TO 30   
            IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB)) 
     +                                                       GO TO 30   
            IF (IOKYDA(MFLGDB).NE.0.AND.KEYVDK(MITMDB).LT.KEYS(MFLGDB)) 
     +                                                       GO TO 30   
            IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB)) 
     +                                                       GO TO 30   
            IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)    GO TO 30   
            IF (NWKYDK.GT.NSYSDK) THEN  
              DO 25 I = NSYSDK+1, NWKYDK    
                IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I)) GO TO 30   
   25         CONTINUE  
            ENDIF   
            IF (JBIT(KEYVDK(MFLGDB),JIGNDB).NE.0)            GO TO 30   
            CALL DBBOOK (IDIVDB, LBKYDB, LFIXDB, JBIAS, 'KYDB', NLKYDB, 
     +                   NSKYDB, NDK, IOKYDB, NZ)   
            IF (IQUEST(1).NE.0)                              GO TO 999  
            LQ(KOFUDB+LBKYDB-KLNODB) = LBNODB   
            LQ(KOFUDB+LBKYDB-KLUPDB) = LBFXDB   
            IQ(KOFUDB+LBKYDB+NDK+MKYFRI) = 0    
            IQ(KOFUDB+LBKYDB+NDK+MKYCRU) = IQ(KOFUDB+LBKYDB+NDK+MKYCRU) 
     +                                   + 1    
            IQ(KOFUDB+LBKYDB+NDK+MKYCEV) = IQ(KOFUDB+LBKYDB+NDK+MKYCEV) 
     +                                   + 1    
            NKB    = NKB + 1    
            IF (NKB.EQ.1) LBK(1) = LBKYDB   
            LFIXDB = LBKYDB 
            JBIAS  = 0  
            IF (IOPKDA.EQ.0) THEN   
              CALL VZERO_i (KEYVDK, NWKYDK)   
              KEYVDK(MSERDB) = IK   
              IOKYDA(MSERDB) = 1    
              CALL DBKXIN (ITIME, IDIVDB, LAUXDL(9), LBKYDB, -KLDADB,   
     +                     NWKEY, KEYVDK, IPREC)    
              IOKYDA(MSERDB) = 0    
              LAUXDL(9) = 0 
              IQ(KOFUDB+LBKYDB+NDK+MKYPRE) = IPREC  
              IQ(KOFUDB+LBKYDB+NDK+MKYRID) =IQ(KOFUDB+LBKYDB+NDK+MKYRID)    
     +                                     + 1  
            ENDIF   
            CALL UCOPY_i (KEYVDK(1), IQ(KOFUDB+LBKYDB+1), NWKYDK) 
            IQ(KOFUDB+LBKYDB+NWKYDK+1) = IQ(KOFUDB+LBKYDB+MBVRDB) + 1   
            IOKYDA(MSERDB) = 0  
            IF (IQUEST(1).NE.0)                              GO TO 999  
            IF (IOPSDA.EQ.0) THEN   
              IQUEST(2) = NKB   
              GO TO 999 
            ENDIF   
   30     CONTINUE  
          CALL RZCDIR (PATH, ' ')   
          IF (IQUEST(1).NE.0) THEN  
            IQUEST(1) = 2   
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGET : Ille'//    
     +      'gal path name '//PATH//''')', IARGDB, 0)   
            GO TO 999   
          ENDIF 
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
   40   CONTINUE    
*   
      ENDIF 
      IQUEST(2) = NKB   
  999 CONTINUE  
*                                                              END DBGET    
      END   
      SUBROUTINE DBGETS (PATHN, LBK, KEYS, CHOPT)   
*     ===========================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBGETS (PATHN, LBK*, KEYS, CHOPT)                       *    
*                                                                      *    
*   Prepares the database data structure in memory for any required    *    
*   Pathname and serial number(s), unless already done.  Returns the   *    
*   addresses in memory for the corresponding Key bank(s) and loads    *    
*   the data part at link 1 of the Key bank(s).                        *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the path name               *    
*     LBK(*)   Address(es) of Keys bank(s) KYDB. The data bank address *    
*              can be obtained as LQ(LBK-1). For several selected      *    
*              objects, the Keys banks appear in a linear structure    *    
*     KEYS     Vector of keys. KEYS(1) and (2) should contain the      *    
*              two limits on the serial number                         *    
*     CHOPT    Character string with any of the following characters   *    
*          K   read only the keys (no data is required)                *    
*          5   specific Program version number required                *    
*          6   select objects with insertion time > KEYS(6)            *    
*          7   select objects with insertion time < KEYS(7)            *    
*          n   consider user key n (where 7 < n < 29 )                 *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =  2 : Illegal path name                               *    
*               = 32 : No keys/data in this directory                  *    
*                                                                      *    
*     If IQUEST(1) =0, IQUEST(2) carries information on number of      *    
*     data objects selected by DBGETS                                  *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (NZ=0)    
      DIMENSION       LBK(9), KEYS(9)   
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, PATHY*80, PATHX*16 
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
* *** Initialize options    
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)                                    GO TO 999  
      IOPMDA = 0    
      IOPSDA = 0    
      LBK(1) = 0    
      IF (KEYS(MSERDB).LT.1) THEN   
        KYMIN  = 1  
      ELSE  
        KYMIN  = KEYS(MSERDB)   
      ENDIF 
      IF (KEYS(MUPNDB).LT.KYMIN) THEN   
        KYMAX  = KYMIN + 100000 
      ELSE  
        KYMAX  = KEYS(MUPNDB)   
      ENDIF 
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Create (or complete) database skeleton in memory  
*   
      CALL DBNODE (PATH, LBNODB)    
      IF (IQUEST(1).NE.0)                                    GO TO 999  
*   
*  ** Start from the end of the existing chain  
*   
      IF (LQ(KOFUDB+LBNODB-KLKYDB).NE.0) THEN   
        LFIXDB = LZLAST (IDIVDB, LQ(KOFUDB+LBNODB-KLKYDB))  
        IF (LFIXDB.EQ.0) THEN   
          LFIXDB = LBNODB   
          JBIAS  =-KLKYDB   
        ELSE    
          JBIAS  = 0    
        ENDIF   
      ELSE  
        LFIXDB = LBNODB 
        JBIAS  =-KLKYDB 
      ENDIF 
      NDK    = IQ(KOFUDB+LBNODB+MNDNWD) 
      CALL UCOPY_i (IQ(KOFUDB+LBNODB+MNDIOF), IOKYDB, NWNODB) 
*   
* *** Set the current directory 
*   
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 2   
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGETS : Illegal'//    
     +  ' path name '//PATH//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
      CALL RZCDIR (PATH, 'R')   
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKEYT   
*   
      IF (NKEYDK.LE.0) THEN 
        IQUEST(1) = 32  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGETS : No keys'//    
     +  '/data for  '//PATH//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
      NCHR   = LENOCC (PATH)    
      NCHRT  = INDEX (PATH(3:NCHR), '/') - 1    
      IF (NCHRT.LE.0) NCHRT = NCHR - 2  
      PATHX  = PATH(3:NCHRT+2)  
      LBFXDB = LTOPDB   
    5 IF (LBFXDB.NE.0) THEN 
        NCHRT  = IQ(KOFUDB+LBFXDB+MUPNCH)   
        CALL UHTOC (IQ(KOFUDB+LBFXDB+MUPNAM), 4, TOPNDI, NCHRT) 
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN  
          LBFXDB = LQ(KOFUDB+LBFXDB)    
          GO TO 5   
        ENDIF   
        KY7MDB = IQ(KOFUDB+LBFXDB+MUPKY7)   
      ELSE  
        KY7MDB = 0  
      ENDIF 
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)   
*   
* *** Now create the key bank(s) and optionally the data bank   
*   
      NKB    = 0    
      IF (IOPTP.EQ.0) THEN  
        DO 20 JK = 1, NKEYDK    
          IK     = NKEYDK + 1 - JK  
          CALL DBKEYR (IK, NWKYDK, KEYVDK)  
          IF (KEYVDK(MSERDB).LT.KYMIN.OR.KEYVDK(MSERDB).GT.KYMAX)   
     +                                                       GO TO 20   
          IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))   
     +                                                       GO TO 20   
          IF (IOKYDA(MFLGDB).NE.0.AND.KEYVDK(MITMDB).LT.KEYS(MFLGDB))   
     +                                                       GO TO 20   
          IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))   
     +                                                       GO TO 20   
          IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)      GO TO 20   
          IF (NWKYDK.GT.NSYSDK) THEN    
            DO 10 I = NSYSDK+1, NWKYDK  
              IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I))   GO TO 20   
   10       CONTINUE    
          ENDIF 
          IF (JBIT(KEYVDK(MFLGDB),JIGNDB).NE.0)              GO TO 20   
          CALL DBBOOK (IDIVDB, LBKYDB, LFIXDB, JBIAS, 'KYDB', NLKYDB,   
     +                 NSKYDB, NDK, IOKYDB, NZ) 
          IF (IQUEST(1).NE.0)                                GO TO 999  
          LQ(KOFUDB+LBKYDB-KLNODB) = LBNODB 
          LQ(KOFUDB+LBKYDB-KLUPDB) = LBFXDB 
          IQ(KOFUDB+LBKYDB+NDK+MKYFRI) = 0  
          IQ(KOFUDB+LBKYDB+NDK+MKYCRU) = IQ(KOFUDB+LBKYDB+NDK+MKYCRU) +1    
          IQ(KOFUDB+LBKYDB+NDK+MKYCEV) = IQ(KOFUDB+LBKYDB+NDK+MKYCEV) +1    
          NKB    = NKB + 1  
          IF (NKB.EQ.1) LBK(1) = LBKYDB 
          LFIXDB = LBKYDB   
          JBIAS  = 0    
          IF (IOPKDA.EQ.0) THEN 
            CALL VZERO_i (KEYVDK, NWKYDK) 
            KEYVDK(MSERDB) = IK 
            IOKYDA(MSERDB) = 1  
            CALL DBKXIN (ITIME, IDIVDB, LAUXDL(9), LBKYDB, -KLDADB, 
     +                   NWKEY, KEYVDK, IPREC)  
            IOKYDA(MSERDB) = 0  
            LAUXDL(9) = 0   
            IQ(KOFUDB+LBKYDB+NDK+MKYPRE) = IPREC    
            IQ(KOFUDB+LBKYDB+NDK+MKYRID) = IQ(KOFUDB+LBKYDB+NDK+MKYRID) 
     +                                   + 1    
          ENDIF 
          CALL UCOPY_i (KEYVDK(1), IQ(KOFUDB+LBKYDB+1), NWKYDK)   
          IQ(KOFUDB+LBKYDB+NWKYDK+1) = IQ(KOFUDB+LBKYDB+MBVRDB) + 1 
          IF (IQUEST(1).NE.0)                                GO TO 999  
   20   CONTINUE    
*   
      ELSE  
        KST    = NWKYDK + 1 
        NKEYS  = NKEYDK 
        KEY5L  = -1 
        DO 40 JKK = 1, NKEYS    
          IKK    = NKEYS + 1 - JKK  
          KPNT   = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),    
     +                     NKEYS*KST, KST)  
          IF (KPNT.GT.0) THEN   
            KPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB   
          ELSE  
            KPNT   = KOFSDB + LCDRDB + IKDRDB + (IKK - 1) * KST 
          ENDIF 
          IF (IOKYDA(MFLGDB).NE.0) THEN 
            IF (JKK.GT.1.AND.KEY7L.LT.KEYS(MFLGDB))          GO TO 40   
            KEY7L  = IQ(KPNT+MITMDB)    
          ENDIF 
          IF (IQ(KPNT+MOBJDB).GT.KYMAX)                      GO TO 40   
          IF (KEY5L.GE.0.AND.KEY5L.LT.KYMIN)                 GO TO 40   
          KEY5L  = IQ(KPNT+MOBJDB)  
          IF (IOKYDA(MITMDB).NE.0.AND.IQ(KPNT+MITMDB).GT.KEYS(MITMDB))  
     +                                                       GO TO 40   
          IF (KY7MDB.GT.0.AND.IQ(KPNT+MITMDB).GT.KY7MDB)     GO TO 40   
*   
          CALL DBPATH (PATHX, IKK)  
          PATHY  = PATH(1:NCHR)//'/'//PATHX 
          CALL RZCDIR (PATHY, ' ')  
          IF (IQUEST(1).NE.0) THEN  
            IQUEST(1) = 2   
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGETS : Ill'//    
     +      'egal path name '//PATHY//''')', IARGDB, 0) 
            GO TO 999   
          ENDIF 
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          DO 30 JK = 1, NKEYDK  
            IK     = NKEYDK + 1 - JK    
            CALL DBKEYR (IK, NWKYDK, KEYVDK)    
            IF (KEYVDK(MSERDB).LT.KYMIN.OR.KEYVDK(MSERDB).GT.KYMAX) 
     +                                                       GO TO 30   
            IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB)) 
     +                                                       GO TO 30   
            IF (IOKYDA(MFLGDB).NE.0.AND.KEYVDK(MITMDB).LT.KEYS(MFLGDB)) 
     +                                                       GO TO 30   
            IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB)) 
     +                                                       GO TO 30   
            IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)    GO TO 30   
            IF (NWKYDK.GT.NSYSDK) THEN  
              DO 25 I = NSYSDK+1, NWKYDK    
                IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I)) GO TO 30   
   25         CONTINUE  
            ENDIF   
            IF (JBIT(KEYVDK(MFLGDB),JIGNDB).NE.0)            GO TO 30   
            CALL DBBOOK (IDIVDB, LBKYDB, LFIXDB, JBIAS, 'KYDB', NLKYDB, 
     +                   NSKYDB, NDK, IOKYDB, NZ)   
            IF (IQUEST(1).NE.0)                              GO TO 999  
            LQ(KOFUDB+LBKYDB-KLNODB) = LBNODB   
            LQ(KOFUDB+LBKYDB-KLUPDB) = LBFXDB   
            IQ(KOFUDB+LBKYDB+NDK+MKYFRI) = 0    
            IQ(KOFUDB+LBKYDB+NDK+MKYCRU) = IQ(KOFUDB+LBKYDB+NDK+MKYCRU) 
     +                                   + 1    
            IQ(KOFUDB+LBKYDB+NDK+MKYCEV) = IQ(KOFUDB+LBKYDB+NDK+MKYCEV) 
     +                                   + 1    
            NKB    = NKB + 1    
            IF (NKB.EQ.1) LBK(1) = LBKYDB   
            LFIXDB = LBKYDB 
            JBIAS  = 0  
            IF (IOPKDA.EQ.0) THEN   
              CALL VZERO_i (KEYVDK, NWKYDK)   
              KEYVDK(MSERDB) = IK   
              IOKYDA(MSERDB) = 1    
              CALL DBKXIN (ITIME, IDIVDB, LAUXDL(9), LBKYDB, -KLDADB,   
     +                     NWKEY, KEYVDK, IPREC)    
              IOKYDA(MSERDB) = 0    
              LAUXDL(9) = 0 
              IQ(KOFUDB+LBKYDB+NDK+MKYPRE) = IPREC  
              IQ(KOFUDB+LBKYDB+NDK+MKYRID) =IQ(KOFUDB+LBKYDB+NDK+MKYRID)    
     +                                     + 1  
            ENDIF   
            CALL UCOPY_i (KEYVDK(1), IQ(KOFUDB+LBKYDB+1), NWKYDK) 
            IQ(KOFUDB+LBKYDB+NWKYDK+1) = IQ(KOFUDB+LBKYDB+MBVRDB) + 1   
            IOKYDA(MSERDB) = 0  
            IF (IQUEST(1).NE.0)                              GO TO 999  
   30     CONTINUE  
          CALL RZCDIR (PATH, ' ')   
          IF (IQUEST(1).NE.0) THEN  
            IQUEST(1) = 2   
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGETS : Ill'//    
     +      'egal path name '//PATH//''')', IARGDB, 0)  
            GO TO 999   
          ENDIF 
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
   40   CONTINUE    
*   
      ENDIF 
      IQUEST(2) = NKB   
*                                                             END DBGETS    
  999 END   
      SUBROUTINE DBILDF (LUNI, CHOPT)   
*     ===============================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBILDF (LUNI, CHOPT)                                    *    
*                                                                      *    
*   Initializes the List of Directories to be always updated from the  *    
*   journal file (ignore the check of the key 1).                      *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUNI     Logical unit number from which the list is read off     *    
*     CHOPT    Character string with any of the following characters   *    
*          A   Add to the previous information                         *    
*          I   Ignore all previous information (also current file)     *    
*     Default  Overwrite previous information with the current list    *    
*                                                                      *    
*   Called by user,   DBACTI                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =232 : Illegal logical unit number                     *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (NWDS=50) 
      CHARACTER       CHOPT*(*), PATH*80, PATHN*80  
*
      dimension nio(9), iarg(9)
*     ------------------------------------------------------------------    
*   
* *** Decode the character option   
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)     GO TO 999 
*   
* *** Find the address of the bank containing the list of directory 
*   
      LREFDB(1) = LBAFDB    
      IF (LREFDB(1).EQ.0) THEN  
        JBIAS  = 1  
        ND     = NWDS * (MXLWDB + 1)
        nio(1) = iofddb
        CALL DBBOOK (IDIVDB, LBAFDB, LBAFDB, JBIAS, 'FDDB', 0, 0, ND,   
     +               nio, -1)    
        IF (IQUEST(1).NE.0)   GO TO 999 
        IQ(KOFUDB+LBAFDB-5) = 0 
        LREFDB(1) = LBAFDB  
      ENDIF 
*   
* *** Reset the counter if not needed   
*   
      IF (IOPIDA.NE.0.OR.IOPADA.EQ.0) THEN  
        IQ(KOFUDB+LREFDB(1)-5) = 0  
        IF (IOPIDA.NE.0)      GO TO 999 
      ENDIF 
*   
* *** Check input file number   
*   
      IF (LUNI.LE.0) THEN   
        IQUEST(1) = 232
        iarg(1) = luni
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBILDF : Illegal'//    
     +  ' logical unit number'',I12)', iarg, 1) 
        GO TO 999   
      ENDIF 
*   
* *** Now read in the file  
*   
      NWMX   = IQ(KOFUDB+LREFDB(1)-1) / (MXLWDB + 1)    
      NCNT   = 0    
   10 READ (LUNI, 1000, ERR=20, END=20) PATH    
      CALL DBSBLC (PATH, PATHN, NCHR)   
      IF (NCHR.LE.0)          GO TO 10  
      CALL CLTOU (PATHN)    
      NCUR   = IQ(KOFUDB+LREFDB(1)-5) + 1   
      NCNT   = NCNT + 1 
      IF (NCUR.GT.NWMX) THEN    
        CALL ZSHUNT (IDIVDB, LREFDB(1), LREFDB(3), 2, 0)    
        ND     = IQ(KOFUDB+LREFDB(3)-1) + NWDS * (MXLWDB + 1)   
        JBIAS  = 1
        nio(1) = iofddb
        CALL DBBOOK (IDIVDB, LBAFDB, LBAFDB, JBIAS, 'FDDB', 0, 0, ND,   
     +               nio, -1)    
        IF (IQUEST(1).NE.0) THEN    
          IERR   = IQUEST(1)    
          CALL MZDROP (IDIVDB, LREFDB(3), ' ')  
          IQUEST(1) = IERR  
          GO TO 999 
        ENDIF   
        CALL UCOPY_i (IQ(KOFUDB+LREFDB(3)+1), IQ(KOFUDB+LBAFDB+1),    
     +                IQ(KOFUDB+LREFDB(3)-1)) 
        LREFDB(1) = LBAFDB  
        CALL MZDROP (IDIVDB, LREFDB(3), ' ')    
        IQUEST(1) = 0   
        NWMX   = NWMX + NWDS    
      ENDIF 
      IQ(KOFUDB+LREFDB(1)-5) = NCUR 
      IPNT   = KOFUDB + LREFDB(1) + (NCUR - 1) * (MXLWDB + 1) + 1   
      IQ(IPNT) = NCHR   
      CALL UCTOH (PATHN, IQ(IPNT+1), 4, 80) 
      GO TO 10  
*   
   20 IQUEST(11)= NCNT  
      IF (IDEBDB.GT.3) THEN 
        NCUR   = IQ(KOFUDB+LREFDB(1)-5)
        iarg(1) = ncur
        CALL DBPRNT (LPRTDB, '(/,'' DBILDF : '',I8,'' directory names'//    
     +       ' stored for forced updating'')', iarg, 1) 
        DO 30 I = 1, NCUR   
          IPNT   = KOFUDB + LREFDB(1) + (I - 1) * (MXLWDB + 1) + 1  
          CALL UHTOC (IQ(IPNT+1), 4, PATH, 80)
          iarg(1) = i
          CALL DBPRNT (LPRTDB, '(10X,''Directory '',I5,'' '//PATH//''')'    
     +,        Iarg, 1)    
   30   CONTINUE    
      ENDIF 
*   
 1000 FORMAT (A80)  
*                                                             END DBILDF    
  999 END   
      SUBROUTINE DBILDU (LUNI, TOPNM, CHOPT)    
*     ======================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBILDU (LUNI, TOPNM, CHOPT)                             *    
*                                                                      *    
*   Initializes the List of Directories to be Updated from the         *    
*   journal file.                                                      *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUNI     Logical unit number from which the list is read off     *    
*     TOPNM    Name of the Top Directory                               *    
*     CHOPT    Character string with any of the following characters   *    
*          A   Add to the previous information                         *    
*          I   Ignore all previous information (also current file)     *    
*     Default  Overwrite previous information with the current list    *    
*                                                                      *    
*   Called by user,   DBACTI                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =231 : Illegal top directory name                      *    
*               =232 : Illegal logical unit number                     *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (NWDS=50) 
      CHARACTER       CHOPT*(*), TOPNM*(*), TOPN*16, PATH*80, PATHN*80  
*
      dimension nio(9), iarg(9)
*     ------------------------------------------------------------------    
*   
* *** Decode the character option and analyse the top directory name    
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)     GO TO 999 
      CALL DBSBLC (TOPNM, TOPN, NCHT)   
      IF (NCHT.LE.0) THEN   
        IQUEST(1) = 231 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBILDU : Illegal'//    
     +  ' top directory name'')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
*   
* *** Find the address of the bank containing the list of directory 
*  ** for the given topdirectory    
*   
      LREFDB(1) = 0 
      LREFDB(2) = 0 
      LTOP   = LTOPDB   
   10 IF (LTOP.GT.0) THEN   
        NCHR   = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHR)    
        IF (TOPNDI(1:NCHR).NE.TOPN(1:NCHT)) THEN    
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 10  
        ELSE    
          LREFDB(1) = LQ(KOFUDB+LTOP-KLFZDB)    
          LREFDB(2) = LTOP  
        ENDIF   
      ENDIF 
*   
      IF (LREFDB(1).EQ.0) THEN  
        LREFDB(1) = LBADDB  
   20   IF (LREFDB(1).GT.0) THEN    
          CALL UHTOC (IQ(KOFUDB+LREFDB(1)+MFZTOP), 4, TOPNDI, 16)   
          IF (TOPNDI.NE.TOPN) THEN  
            LREFDB(1) = LQ(KOFUDB+LREFDB(1))    
            GO TO 20    
          ENDIF 
        ELSE    
          JBIAS  = 1    
          ND     = NWDS * (MXLWDB + 1) + MFZDIR - 1
          nio(1) = iofzdb
          CALL DBBOOK (IDIVDB, LBADDB, LBADDB, JBIAS, 'FZDB', 0, 0, ND, 
     +                 nio, -1)  
          IF (IQUEST(1).NE.0) GO TO 999 
          IQ(KOFUDB+LBADDB-5) = 0   
          LREFDB(1) = LBADDB    
          IF (LREFDB(2).GT.0) LQ(KOFUDB+LREFDB(2)-KLFZDB) = LBADDB  
          CALL UCTOH (TOPN, IQ(KOFUDB+LBADDB+MFZTOP), 4, 16)    
        ENDIF   
      ENDIF 
*   
* *** Reset the counter if not needed   
*   
      IF (IOPIDA.NE.0.OR.IOPADA.EQ.0) THEN  
        IQ(KOFUDB+LREFDB(1)-5) = 0  
        IF (IOPIDA.NE.0)      GO TO 999 
      ENDIF 
*   
* *** Check input file number   
*   
      IF (LUNI.LE.0) THEN   
        IQUEST(1) = 232
        iarg(1) = luni
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBILDU : Illegal'//    
     +  ' logical unit number'',I12)', iarg, 1) 
        GO TO 999   
      ENDIF 
*   
* *** Now read in the file  
*   
      NWMX   = (IQ(KOFUDB+LREFDB(1)-1) - MFZDIR + 1) / (MXLWDB + 1) 
      NCNT   = 0    
   25 READ (LUNI, 1000, ERR=30, END=30) PATH    
      CALL DBSBLC (PATH, PATHN, NCHR)   
      IF (NCHR.LE.0)          GO TO 25  
      CALL CLTOU (PATHN)    
      NCUR   = IQ(KOFUDB+LREFDB(1)-5) + 1   
      NCNT   = NCNT + 1 
      IF (NCUR.GT.NWMX) THEN    
        CALL ZSHUNT (IDIVDB, LREFDB(1), LREFDB(3), 2, 0)    
        ND     = IQ(KOFUDB+LREFDB(3)-1) + NWDS * (MXLWDB + 1)   
        JBIAS  = 1
        nio(1) = iofzdb
        CALL DBBOOK (IDIVDB, LBADDB, LBADDB, JBIAS, 'FZDB', 0, 0, ND,   
     +               nio, -1)    
        IF (IQUEST(1).NE.0) THEN    
          IERR   = IQUEST(1)    
          CALL MZDROP (IDIVDB, LREFDB(3), ' ')  
          IF (LREFDB(2).GT.0) LQ(KOFUDB+LREFDB(2)-KLFZDB) = 0   
          IQUEST(1) = IERR  
          GO TO 999 
        ENDIF   
        CALL UCOPY_i (IQ(KOFUDB+LREFDB(3)+1), IQ(KOFUDB+LBADDB+1),    
     +                IQ(KOFUDB+LREFDB(3)-1)) 
        LREFDB(1) = LBADDB  
        IF (LREFDB(2).GT.0) LQ(KOFUDB+LREFDB(2)-KLFZDB) = LBADDB    
        CALL MZDROP (IDIVDB, LREFDB(3), ' ')    
        IQUEST(1) = 0   
        NWMX   = NWMX + NWDS    
      ENDIF 
      IQ(KOFUDB+LREFDB(1)-5) = NCUR 
      IPNT   = KOFUDB + LREFDB(1) + MFZDIR + (NCUR - 1) * (MXLWDB + 1)  
      IQ(IPNT) = NCHR   
      CALL UCTOH (PATHN, IQ(IPNT+1), 4, 80) 
      GO TO 25  
*   
   30 IQUEST(11)= NCNT  
      IF (IDEBDB.GT.3) THEN 
        NCUR   = IQ(KOFUDB+LREFDB(1)-5) 
        CALL UHTOC (IQ(KOFUDB+LREFDB(1)+MFZTOP), 4, TOPNDI, 16)
        iarg(1) = ncur
        CALL DBPRNT (LPRTDB, '(/,'' DBILDU : '',I8,'' directory names'//    
     +       ' stored for top directory '//TOPNDI//''')', iarg, 1)  
        DO 40 I = 1, NCUR   
          IPNT   = KOFUDB + LREFDB(1) + MFZDIR + (I - 1) * (MXLWDB + 1) 
          CALL UHTOC (IQ(IPNT+1), 4, PATH, 80)
          iarg(1) = i
          CALL DBPRNT (LPRTDB, '(10X,''Directory '',I5,'' '//PATH//''')'    
     +,        Iarg, 1)    
   40   CONTINUE    
      ENDIF 
*   
 1000 FORMAT (A80)  
*                                                             END DBILDU    
  999 END   
      SUBROUTINE DBIN (PATHN, ITIME, IUDIV, LSUP, IPRVS, NWKEY, KEY,    
     +                 IPREC, CHOPT)    
*     ==============================================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBIN (PATHN, ITIME, IUDIV, LSUP*, IPRVS, NWKEY*, KEY*,  *    
*                    IPREC*, CHOPT)                                    *    
*                                                                      *    
*   Fetches from disk to memory data valid for a given time            *    
*                                                                      *    
*   Restrictions : No selection on user keys can be made               *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     ITIME    Time for which data are required to be valid            *    
*     IUDIV    Division index where bank is expected to be returned    *    
*     LSUP(*)  Address of bank in memory where data have been stored   *    
*     IPRVS    Version number of program used when data were created   *    
*              (if = 0, accept any)                                    *    
*     NWKEY(*) Length of the key vector                                *    
*     KEY(*)   Key vector elements                                     *    
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *    
*              IPREC significant digits right to the decimal points; if*    
*              IPREC < 0, data are stored with IPREC insignificant     *    
*              digits left to the decimal point.)                      *    
*     CHOPT    Character string with any of the following characters   *    
*          N   If data do not exist for ITIME, take the nearest data   *    
*              object in time                                          *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 31 : Illegal path name                               *    
*               = 32 : No keys/data in this directory                  *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      DIMENSION       KEY(9), LSUP(9)   
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, PATHX*16   
*   
*     ------------------------------------------------------------------    
*   
* *** Decode the character option   
* *** Inhibit 'R' option (RZ mode)  
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0) GO TO 999 
      IOPRDA = 0    
      IF (IPRVS.NE.0) IOKYDA(MPVSDB) = 1    
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Set the current directory 
*   
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0)  THEN 
        IQUEST(1) = 31  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBIN : Illegal '// 
     +  'Path Name '//PATH//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKEYT   
*   
* *** Check the number of keys  
*   
      IF (NKEYDK.EQ.0)  THEN    
        IQUEST(1) = 32  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBIN : No key or'//    
     +  ' data for Path Name '//PATH//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
*   
      CALL RZCDIR (PATH, 'R')   
      NCHAR  = INDEX (PATH, ' ') - 1    
      IF (NCHAR.LT.0) NCHAR = MAXLDB    
      NCHRT  = INDEX (PATH(3:NCHAR), '/') - 1   
      IF (NCHRT.LE.0) NCHRT = NCHAR - 2 
      PATHX  = PATH(3:NCHRT+2)  
      LTOP   = LTOPDB   
   10 IF (LTOP.NE.0) THEN   
        NCHRT  = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHRT)   
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN  
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 10  
        ENDIF   
        KY7MDB = IQ(KOFUDB+LTOP+MUPKY7) 
      ELSE  
        KY7MDB = 0  
      ENDIF 
*   
* *** Set up the key vector to be searched  
*   
      DO 20 I = 1, NWKYDK   
        IF (IOKYDA(I).NE.0) THEN    
          KEYVDK(I) = KEY(I)    
        ELSE    
          KEYVDK(I) = 0 
        ENDIF   
   20 CONTINUE  
      KEYVDK(MPVSDB) = IPRVS    
      JBIAS  = 2    
*   
* *** Read in the data  
*   
      CALL DBKXIN (ITIME, IUDIV, LSUP(1), LSUP(1), JBIAS, NWKEY, KEYVDK,    
     +             IPREC)   
      IF (IQUEST(1).NE.0) GO TO 999 
      CALL UCOPY_i (KEYVDK, KEY, NWKEY)   
*                                                               END DBIN    
  999 END   
      SUBROUTINE DBINCT (IDTMI, ISADD, IDTMO)   
*     =======================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBINCT (IDTMI, ISADD, IDTMO*)                           *    
*                                                                      *    
*   Converts packed date and time (ala DBPKTS) to a similar packed     *    
*   number after adding a fixed time in seconds                        *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IDTMI    Packed date-time (ala DBPKTS) on input                  *    
*     ISADD    Incremental time to IDTMI in seconds                    *    
*     IDTMO    Packed date-time (ala DBPKTS) on output                 *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXSEC=61, MXMIN=61, MXHOU=25, MXDAY=32, MXMON=13)    
      INTEGER         IDAYY(20), IDAYM(12,2)    
      SAVE            IDAYY, IDAYM  
      DATA            IDAYY / 366,  731, 1096, 1461, 1827, 2192, 2557,  
     1                       2922, 3288, 3653, 4018, 4383, 4749, 5114,  
     2                       5479, 5844, 6210, 6575, 6940, 7305/    
      DATA            IDAYM / 0,  31,  59,  90, 120, 151, 181, 212, 243,    
     1                      273, 304, 334,   0,  31,  60,  91, 121, 152,    
     2                      182, 213, 244, 274, 305, 335/   
*   
*     ------------------------------------------------------------------    
*   
* *** Get the real Year/Month/Date Hour/Minute/Second   
*   
      III    = IDTMI    
      ISEC   = MOD (III, MXSEC) 
      III    = (III-ISEC)/MXSEC 
      IMIN   = MOD (III, MXMIN) 
      III    = (III-IMIN)/MXMIN 
      IHOU   = MOD (III, MXHOU) 
      III    = (III-IHOU)/MXHOU 
      IDAY   = MOD (III, MXDAY) 
      III    = (III-IDAY)/MXDAY 
      IMON   = MOD (III, MXMON) 
      IYEA   = (III-IMON)/MXMON 
*   
* *** Add the second to real seconds in the day 
*   
      ISECS  = ISEC  + 60*(IMIN + 60*IHOU)  
      ISECS  = ISECS + ISADD    
      IF (ISECS.GE.0.AND.ISECS.LT.86400) THEN   
        ISEC   = MOD (ISECS, 60)    
        ISECS  = (ISECS-ISEC)/60    
        IMIN   = MOD (ISECS, 60)    
        IHOU   = (ISECS-IMIN)/60    
      ELSE  
        IF (ISECS.LT.0) THEN    
          III    = -ISECS   
          IDADD  = -(III/86400 + 1) 
        ELSE    
          IDADD  = ISECS/86400  
        ENDIF   
        ISECS  = ISECS - IDADD*86400    
        ISEC   = MOD (ISECS, 60)    
        ISECS  = (ISECS-ISEC)/60    
        IMIN   = MOD (ISECS, 60)    
        IHOU   = (ISECS-IMIN)/60    
        IF (IYEA.LT.1) THEN 
          IADD   = 0    
          ITYP   = 2    
        ELSE IF (IYEA.GT.20) THEN   
          IADD   = IDAYY(20)    
          ITYP   = 2    
        ELSE    
          IADD   = IDAYY(IYEA)  
          ITYP   = MOD (IYEA, 4)    
          IF (ITYP.EQ.0) THEN   
            ITYP = 2    
          ELSE  
            ITYP = 1    
          ENDIF 
        ENDIF   
        IDAYS  = IDAY + IADD + IDAYM(IMON,ITYP) + IDADD 
        DO 10 I = 1, 20 
          IF (IDAYS.LE.IDAYY(I)) THEN   
            IYEA   = I - 1  
            IF (IYEA.GT.0) IDAYS  = IDAYS - IDAYY(IYEA) 
            GO TO 15    
          ENDIF 
   10   CONTINUE    
        IYEA   = 20 
        IDAYS  = 366    
   15   IF (MOD(IYEA,4).EQ.0) THEN  
          ITYP   = 2    
        ELSE    
          ITYP   = 1    
        ENDIF   
        DO 20 I = 2, 12 
          IF (IDAYS.LE.IDAYM(I,ITYP)) THEN  
            IMON   = I - 1  
            GO TO 25    
          ENDIF 
   20   CONTINUE    
        IMON   = 12 
   25   IDAY   = IDAYS - IDAYM(IMON,ITYP)   
      ENDIF 
*   
* *** Now reconvert into a packed time  
*   
      IDTMO  = ISEC 
      MAXX   = MXSEC    
      IDTMO  = IDTMO + MAXX*IMIN    
      MAXX   = MAXX*MXMIN   
      IDTMO  = IDTMO + MAXX*IHOU    
      MAXX   = MAXX*MXHOU   
      IDTMO  = IDTMO + MAXX*IDAY    
      MAXX   = MAXX*MXDAY   
      IDTMO  = IDTMO + MAXX*IMON    
      MAXX   = MAXX*MXMON   
      IDTMO  = IDTMO + MAXX*IYEA    
*                                                             END DBINCT    
      END   
      SUBROUTINE DBINIT (IDIV, LUNRZ, TOPNM, LTOP, NRECS, CHOPT)    
*     ==========================================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBINIT (IDIV, LUNRZ, TOPNM, LTOP*, NRECS, CHOPT)        *    
*                                                                      *    
*   Initializes of the Data Base Package (for each file)               *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IDIV     User Division                                           *    
*     LUNRZ    RZ file unit                                            *    
*     TOPNM    Name of the Top Directory                               *    
*     LTOP     Address of the top directory                            *    
*     NRECS    Number of records for primary allocation (for RZMAKE)   *    
*              If less than or equal to 0 use existing RZ file (RZFILE)*    
*     CHOPT    Character Option : Same as in RZFILE / RZMAKE           *    
*          Z   Reinitialize the random access file (use RZMAKE)        *    
*              (also NRECS > 0 is required)                            *    
*                                                                      *    
*   Called by user,   DBACTI                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = -1 : Invalid top directory name                      *    
*               = -2 : The file is already open with correct LUNRZ and *    
*                      TOPNM                                           *    
*               = -3 : The file is already open with wrong LUNRZ or    *    
*                      TOPNM                                           *    
*               = -4 : Already a file is opened with the same unique   *    
*                      identifier as requested for this TOPNM          *    
*                                                                      *    
************************************************************************    
*   
      COMMON /ZUNIT/ IQREAD,IQPRNT,IQPR2,IQLOG,IQPNCH,IQTTIN,IQTYPE 
      COMMON /ZUNITZ/IQDLUN,IQFLUN,IQHLUN,  NQUSED  
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NOPRZ=7) 
      CHARACTER       CHOPT*(*), TOPNM*(*)  
      CHARACTER       CHOP*8, COPRZ(NOPRZ)*1, TOP*16, TOP1*16, PATH*18  
      INTEGER         KEYXT(4), IOPRZ(NOPRZ), IACRZ(NOPRZ)
      real fbuf(2)
      SAVE            INIT, NTOPM, IUPDB, KEYXT, fBUF, NBUF, NKYXT  
      SAVE            IVSTR, IVEND, IDTYP, IPRVS, COPRZ, IACRZ  
*   
      DATA            KEYXT /0, 0, 0, 0/, fBUF /0, 0/, NKYXT /4/    
      DATA            IVSTR /0/, IVEND /999999999/, IDTYP /2/, IPRVS /1/    
      DATA            INIT /0/, NBUF /2/    
      DATA            COPRZ /'1', 'D', 'L', 'M', 'S', 'U', 'X'/ 
      DATA            IACRZ /  0,   0,   1,   0,   0,   0,   0/ 
*
      dimension iarg(9), nio(9)
*     ------------------------------------------------------------------    
*   
C ACP_data_retrieval_start  
      LTOP= 0    
      NTOP   = IQUEST(1)    
      IOPTO  = 0    
      CALL UOPTC (CHOPT, 'Z', IOPTZ)    
      IF (NRECS.GT.0.AND.IOPTZ.NE.0) THEN   
        NREC  = NRECS   
        IOPTN = 1   
      ELSE  
        IOPTN = 0   
        NREC  = 0   
      ENDIF 
      DO 5 I = 1, NOPRZ 
        IF (I.EQ.1) THEN    
          CHOP   = COPRZ(I) 
        ELSE    
          CHOP   = CHOP(1:I-1)//COPRZ(I)    
        ENDIF   
    5 CONTINUE  
      CALL UOPTC (CHOPT, CHOP(1:NOPRZ), IOPRZ)  
      IF (IOPRZ(1).NE.0.OR.IOPRZ(6).NE.0) IOPTO = 1 
*   
* *** Remove imbedded blanks from the top directory name    
*   
      CALL DBSBLC (TOPNM, TOPNDI, MAX)  
      IF (MAX.EQ.0) THEN    
        IQUEST(1) = -1  
        TOPNDI = TOPNM  
        CALL DBPRNT (IQPRNT, '(/,'' DBINIT : Illegal Top Directory '//  
     +       'Name '//TOPNDI//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
*   
* *** First pass initialization 
*   
      IF (INIT.EQ.0) THEN   
*   
*  **   DB System initialization    
*   
        NTOPM  = 0  
        CALL DBFRST (IDIV)  
        INIT   = 1  
      ENDIF 
*   
      IOPP   = 0    
      CALL UOPTC (CHOPT, 'S', IOPS) 
*   
* *** Construct the character option    
*   
      CHOP   = ' '  
      II     = 0    
      DO 30 I = 1, NOPRZ    
        IF (IOPRZ(I).NE.0) THEN 
          IF (II.EQ.0) THEN 
            CHOP   = COPRZ(I)   
          ELSE  
            CHOP   = CHOP(1:II)//COPRZ(I)   
          ENDIF 
          II     = II + 1   
        ENDIF   
   30 CONTINUE  
      IFLG   = 0    
      IF (IOPTO.NE.0.OR.IOPTN.NE.0) IFLG = 1    
      IF (IFLG.NE.0.OR.IOPRZ(5).NE.0) THEN  
        KY7M   = 0  
      ELSE  
        CALL DATIME (IDATE, ITIME)  
        CALL DBPKTM (IDATE, ITIME, KY7M)    
      ENDIF 
*   
*  ** Check whether the RZ file has been already initialized    
*   
      IF (LTOPDB.NE.0) THEN 
        LSAVDB = LTOPDB 
   40   LUN    = IQ(KOFUDB+LSAVDB+MUPLUN)   
        NCH    = IQ(KOFUDB+LSAVDB+MUPNCH)   
        CALL UHTOC (IQ(KOFUDB+LSAVDB+MUPNAM), 4, TOP1, NCH) 
        TOP    = TOP1(1:NCH)    
        IF (NTOP.GT.0) THEN 
          IF (NTOP.EQ.IQ(KOFUDB+LSAVDB+MUPDIC)) THEN    
            IQUEST(1) = -4  
            LSAVDB = 0  
            IARGDB(1) = NTOP    
            IARGDB(2) = LUN 
            CALL DBPRNT (LPRTDB, '(/,'' DBINIT : Requested Identifier'//    
     +           ' '',I4,'' for Top Name '//TOPNDI//' clashes with th'//    
     +           'at of '//TOP(1:NCH)//' on unit '',I4)', IARGDB, 2)    
            GO TO 999   
          ENDIF 
        ENDIF   
        IF (TOP.EQ.TOPNDI.AND.LUN.EQ.LUNRZ) THEN    
          IQUEST(1) = -2    
          LSAVDB = 0
          iarg(1) = lunrz
          CALL DBPRNT (LPRTDB, '(/,'' DBINIT : Top Directory '//TOPNDI//    
     +         ' is already open on unit '',I4)', iarg, 1) 
          GO TO 999 
        ENDIF   
        IF (TOP.EQ.TOPNDI.OR. LUN.EQ.LUNRZ) THEN    
          IQUEST(1) = -3    
          LSAVDB = 0    
          IARGDB(1) = LUN   
          IARGDB(2) = LUNRZ 
          CALL DBPRNT (LPRTDB, '(/,'' DBINIT : Top Directory '//TOP//   
     +         ' open on unit '',I4,'' is in conflict with'',/,'' Req'//    
     +         'uested Top Directory '//TOPNDI//' on unit '',5X,I4)',   
     +         IARGDB, 2)   
          GO TO 999 
        ENDIF   
*   
        LSUP   = LSAVDB 
        LSAVDB = LQ(KOFUDB+LSUP)    
        IF (LSAVDB.NE.0)       GO TO 40 
*   
*  **   Create linear structure of the top-directories  
*
        nio(1) = iupdb
        CALL MZBOOK (IDIVDB, LSAVDB, LSUP, 0, 'UPDB', NLUPDB, NSUPDB,   
     +               NDUPDB, nio, -1) 
      ELSE  
        nio(1) = iupdb
        CALL MZBOOK (IDIVDB, LTOPDB, 0, 2, 'UPDB', NLUPDB, NSUPDB,  
     +               NDUPDB, nio, -1) 
        LSAVDB = LTOPDB 
      ENDIF 
*   
*  ** Fill up the top directory bank with user data 
*   
      NTOPDB = NTOPDB + 1   
      IF (NTOP.LE.0) NTOP = NTOPM + 1   
      IF (NTOP.GT.NTOPM) NTOPM = NTOP   
      IQ(KOFUDB+LSAVDB+MUPLUN) = LUNRZ  
      IQ(KOFUDB+LSAVDB+MUPFLG) = IFLG   
      IQ(KOFUDB+LSAVDB+MUPJFL) = 0  
      IQ(KOFUDB+LSAVDB+MUPBAK) = 0  
      IQ(KOFUDB+LSAVDB+MUPDIC) = NTOP   
      IQ(KOFUDB+LSAVDB+MUPNCH) = MAX    
      IQ(KOFUDB+LSAVDB+MUPSRV) = IOPS*10 + IOPP 
      IQ(KOFUDB+LSAVDB+MUPKY7) = KY7M   
      CALL UCTOH (TOPNDI, IQ(KOFUDB+LSAVDB+MUPNAM), 4, MAX) 
*   
      IQUEST(1) = 0 
      IF (IOPTN.NE.0)  THEN 
*   
*  **   Create file on mass storage and create the 1st pass directories 
*   
        CALL RZMAKE (LUNRZ, TOPNDI, NINEDK, CHFTDK, CHTGDK, NREC, CHOP) 
*   
      ELSE  
*   
*  **   Reopen the RZ-file on the mass storage for read and write   
*   
        CALL RZFILE (LUNRZ, TOPNDI, CHOP)   
*   
      ENDIF 
*   
      IF (IQUEST(1).NE.0)  THEN 
        IF (LTOPDB.EQ.LSAVDB) LTOPDB = 0    
        CALL MZDROP (IDIVDB, LSAVDB, ' ')   
        CALL RZEND  (TOPNDI)    
        IQUEST(1) = -2
        iarg(1) = lunrz
        CALL DBPRNT (LPRTDB, '(/,'' DBINIT : Top Directory '//TOPNDI//  
     +       ' is already open on unit '',I4)', iarg, 1)   
      ELSE  
*   
        IF (IOPTN.NE.0)  THEN   
*   
*   *     Create the version number 
*   
          PATH = '//'//TOPNDI   
          CALL DBVOUT (PATH, IVSTR, IVEND, NBUF, fBUF, IPRVS, NKYXT 
     +               , KEYXT, IDTYP, 0, 'SU')   
          IERR = IQUEST(1)  
          IF (IERR.NE.0) THEN   
            IF (LTOPDB.EQ.LSAVDB) LTOPDB = 0    
            CALL MZDROP (IDIVDB, LSAVDB, ' ')   
            CALL DBSBLC (TOPNM, TOPNDI, MAX)    
            CALL RZEND  (TOPNDI)    
            IQUEST(1) = IERR    
            GO TO 999   
          ENDIF 
        ENDIF   
*   
*   *   Load the dictionary directory   
*   
        CALL DBUDIC (LSAVDB)    
        IERR = IQUEST(1)    
        IF (IERR.NE.0) THEN 
          IF (LTOPDB.EQ.LSAVDB) LTOPDB = 0  
          CALL MZDROP (IDIVDB, LSAVDB, ' ') 
          CALL DBSBLC (TOPNM, TOPNDI, MAX)  
          CALL RZEND  (TOPNDI)  
          IQUEST(1) = IERR  
          GO TO 60  
        ENDIF   
*   
*   *   Link it to the list of directory names to be updated    
*   
        LREFDB(1) = LBADDB  
        CALL DBSBLC (TOPNM, TOP, MAX)   
   50   IF (LREFDB(1).NE.0) THEN    
          CALL UHTOC (IQ(KOFUDB+LREFDB(1)+MFZTOP), 4, TOPNDI, 16)   
          IF (TOPNDI.EQ.TOP) THEN   
            LQ(KOFUDB+LSAVDB-KLFZDB) = LREFDB(1)    
          ELSE  
            LREFDB(1) = LQ(KOFUDB+LREFDB(1))    
            GO TO 50    
          ENDIF 
        ENDIF   
*   
      ENDIF 
*   
      LTOP = LSAVDB  
   60 LSAVDB = 0    
*                                                             END DBINIT    
  999 CONTINUE  
C ACP_data_retrieval_end    
      END   
      SUBROUTINE DBKEPT (PATHS, NPATH, CHOPT)   
*     =======================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBKEPT (PATHS, NPATH, CHOPT)                            *    
*                                                                      *    
*   Deletes all directory trees from the data base except the ones     *    
*   specified by the user                                              *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHS    Path names to be kept                                   *    
*     NPATH    Number of paths to be kept                              *    
*     CHOPT    Character string with any of the following characters   *    
*          B   Save in the special backup file; not in standard Journal*    
*                                                                      *    
*   Called by user,   DBAUXI                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =211 : Illegal number of paths                         *    
*               =212 : Illegal path name                               *    
*               =213 : Conflicting top directory names                 *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NLEVM=20)    
      DIMENSION       NCHL(NLEVM)   
      CHARACTER       PATH*80, PATHX*16, PATHY*80, PATHF*80, PATHZ*16   
      CHARACTER       CNODE(NLEVM)*16   
      CHARACTER*(*)   PATHS(*), CHOPT   
*
      dimension iarg(9)
*     ------------------------------------------------------------------    
*   
* *** Find the top directory name   
*   
      IF (NPATH.LE.0) THEN  
        IQUEST(1) = 211
        iarg(1) = npath
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEPT : Illegal'//    
     +  ' number of paths to be kept '',I12)', iarg, 1)    
        GO TO 999   
      ENDIF 
      PATHX  = ' '  
      DO 10 IP = 1, NPATH   
        CALL DBSBLC (PATHS(IP), PATH, NCHR) 
        IF (NCHR.LT.3.OR.PATH(1:2).NE.'//') THEN    
          IQUEST(1) = 212   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEPT : Illeg'//    
     +    'al path name '//PATH//''')', IARGDB, 0)  
          GO TO 999 
        ENDIF   
        NCHRT  = INDEX (PATH(3:NCHR), '/') - 1  
        IF (NCHRT.LE.0) NCHRT = NCHR - 2    
        PATHZ  = PATH(3:NCHRT+2)    
        IF (PATHX.EQ.' ') THEN  
          PATHX  = PATHZ    
        ELSE IF (PATHZ.NE.PATHX) THEN   
          IQUEST(1) = 213   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEPT : Confl'//    
     +    'icting top-directories '//PATHX//' and '//PATHZ//''')',  
     +    IARGDB, 0)    
          GO TO 999 
        ENDIF   
   10 CONTINUE  
*   
* *** Now prepare the bank with all node names  
*   
      LEVM   = NLEVM    
      PATH   = '//'//PATHX  
      LSAVDB = 0    
      IQUEST(1) = 0 
      CALL DBFPAT (PATH, LEVM, LSAVDB)  
      IF (IQUEST(1).NE.0)                                   GO TO 100   
      IF (LSAVDB.EQ.0) THEN 
        IQUEST(1) = 212 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEPT : Illegal'//    
     +  ' path name '//PATH//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
      NLEV   = IQ(KOFUDB+LSAVDB+MNLVDB) 
      IF (NLEV.LE.0)                                        GO TO 100   
*   
* *** Loop over all the paths to be kept    
*   
      DO 50 IP = 1, NPATH   
        CALL DBSBLC (PATHS(IP), PATH, NCHR) 
*   
*  **   Find all the nodes in the path name 
*   
        NODES  = 0  
        I0     = 0  
   15   I1     = I0 + 1 
        IF (I1.LE.NCHR) THEN    
          DO 20 I0 = I1, NCHR   
            IF (PATH(I0:I0).EQ.' ') THEN    
              I2     = I0 - 1   
              GO TO 25  
            ELSE IF (PATH(I0:I0).EQ.'/') THEN   
              I2     = I0 - 1   
              GO TO 30  
            ENDIF   
   20     CONTINUE  
          I2     = NCHR 
   25     I0     = NCHR + 1 
   30     IF (I2.LT.I1)                                     GO TO 15    
          NODES  = NODES + 1    
          CNODE(NODES) = PATH(I1:I2)    
          NCHL (NODES) = I2 - I1 +1 
          GO TO 15  
        ENDIF   
*   
*  **   Now look up the complete list and mark the nodes to be kept 
*   
        IPNL   = IQ(KOFUDB+LSAVDB+MPNLDB)   
        NLEV0  = MIN0 (NLEV, NODES) 
        IUPN   = 0  
        DO 45 ILEV = 1, NLEV0   
          NNODE  = IQ(KOFUDB+LSAVDB+IPNL+MNODDB)    
          IPNN   = IQ(KOFUDB+LSAVDB+IPNL+MPNNDB)    
          DO 35 INOD = 1, NNODE 
            IF ((IQ(KOFUDB+LSAVDB+IPNN+MNCHDB).EQ.NCHL(ILEV)) .AND. 
     +          (IQ(KOFUDB+LSAVDB+IPNN+MNFNDB).EQ.IUPN)) THEN   
              CALL UHTOC (IQ(KOFUDB+LSAVDB+IPNN+MNAMDB), 4, PATHZ,  
     +                    NCHL(ILEV))   
              IF (PATHZ(1:NCHL(ILEV)).EQ.CNODE(ILEV)) THEN  
                IUPN   = INOD   
                Q(KOFUDB+LSAVDB+IPNN+MYFNDB) = 1.0  
                GO TO 40    
              ENDIF 
            ENDIF   
            IPNN   = IQ(KOFUDB+LSAVDB+IPNN+MPNLDB)  
   35     CONTINUE  
          GO TO 50  
   40     IPNL   = IQ(KOFUDB+LSAVDB+IPNL+MPNLDB)    
   45   CONTINUE    
*   
   50 CONTINUE  
*   
* *** Now delete the unmarked directories   
*   
      IPNL   = IQ(KOFUDB+LSAVDB+MPNLDB) 
      DO 90 ILEV =1, NLEV   
        NNODE  = IQ(KOFUDB+LSAVDB+IPNL+MNODDB)  
        IPNN   = IQ(KOFUDB+LSAVDB+IPNL+MPNNDB)  
        DO 85 INOD = 1, NNODE   
          IF (Q(KOFUDB+LSAVDB+IPNN+MYFNDB).EQ.0.) THEN  
            IF (ILEV.EQ.2) THEN 
              NCHR   = IQ(KOFUDB+LSAVDB+IPNN+MNCHDB)    
              CALL UHTOC (IQ(KOFUDB+LSAVDB+IPNN+MNAMDB), 4, PATHZ, NCHR)    
              IF ((NCHR.EQ.10.AND.PATHZ(1:NCHR).EQ.'DICTIONARY').OR.    
     +            (NCHR.EQ.4 .AND.PATHZ(1:NCHR).EQ.'HELP')) GO TO 80    
            ENDIF   
*   
*  **       Delete the tree from here; construct the path name first    
*   
            IUPN   = INOD   
            NCHRT  = 0  
            PATHY  = ' '    
            DO 65 KLEV = 1, ILEV    
              JLEV   = ILEV + 1 - KLEV  
              IPNLC  = IQ(KOFUDB+LSAVDB+MPNLDB) 
              IF (JLEV.GT.1) THEN   
                DO 55 IL = 2, JLEV  
   55           IPNLC  = IQ(KOFUDB+LSAVDB+IPNLC+MPNLDB) 
              ENDIF 
              IPNNC  = IQ(KOFUDB+LSAVDB+IPNLC+MPNNDB)   
              IF (IUPN.GT.1) THEN   
                DO 60 IN = 2, IUPN  
   60           IPNNC   = IQ(KOFUDB+LSAVDB+IPNNC+MPNLDB)    
              ENDIF 
              NCHR   = IQ(KOFUDB+LSAVDB+IPNNC+MNCHDB)   
              IUPN   = IQ(KOFUDB+LSAVDB+IPNNC+MNFNDB)   
              CALL UHTOC (IQ(KOFUDB+LSAVDB+IPNNC+MNAMDB), 4, PATHZ,NCHR)    
              PATHF  = '/'//PATHZ(1:NCHR)   
              NCHR   = NCHR + 1 
              IF (NCHRT.GT.0) THEN  
                PATH  = PATHF(1:NCHR)//PATHY(1:NCHRT)   
              ELSE  
                PATH   = PATHF  
              ENDIF 
              PATHY  = PATH 
              NCHRT  = NCHRT + NCHR 
   65       CONTINUE    
            PATH  = '/'//PATHY  
*   
*  **       Now delete the tree 
*   
            CALL DBDELT (PATH, CHOPT)   
            IF (IQUEST(1).NE.0)                             GO TO 100   
*   
*  **       Now mark all down nodes from here to be nonexistent 
*   
            NND    = IQ(KOFUDB+LSAVDB+IPNN+MNDWDB)  
            IF (ILEV.LT.NLEV.AND.NND.GT.0) THEN 
              IPNLC  = IQ(KOFUDB+LSAVDB+IPNL+MPNLDB)    
              KLEV   = ILEV + 1 
              NCHL(KLEV) = INOD 
   70         IF (KLEV.GT.ILEV) THEN    
                NODES  = IQ(KOFUDB+LSAVDB+IPNLC+MNODDB) 
                IPNNC  = IQ(KOFUDB+LSAVDB+IPNLC+MPNNDB) 
                DO 75 IN = 1, NODES 
                  IF ((Q(KOFUDB+LSAVDB+IPNNC+MYFNDB).EQ.0.0) .AND.  
     +               (NCHL(KLEV).EQ.IQ(KOFUDB+LSAVDB+IPNNC+MNFNDB)))THEN    
                    Q(KOFUDB+LSAVDB+IPNNC+MYFNDB) = 1.0 
                    NND    = IQ(KOFUDB+LSAVDB+IPNNC+MNDWDB) 
                    IF (KLEV.LT.NLEV.AND.NND.GT.0) THEN 
                      KLEV   = KLEV + 1 
                      IPNLC  = IQ(KOFUDB+LSAVDB+IPNLC+MPNLDB)   
                      NCHL(KLEV) = IN   
                      GO TO 70  
                    ENDIF   
                  ENDIF 
                  IPNNC  = IQ(KOFUDB+LSAVDB+IPNNC+MPNLDB)   
   75           CONTINUE    
                KLEV   = KLEV - 1   
                IPNLC  = IQ(KOFUDB+LSAVDB+IPNLC+MPPLDB) 
                GO TO 70    
              ENDIF 
            ENDIF   
*   
          ENDIF 
   80     IPNN   = IQ(KOFUDB+LSAVDB+IPNN+MPNLDB)    
   85   CONTINUE    
        IPNL   = IQ(KOFUDB+LSAVDB+IPNL+MPNLDB)  
   90 CONTINUE  
      IQUEST(1) = 0 
*   
  100 IF (LSAVDB.NE.0) THEN 
        IERR   = IQUEST(1)  
        CALL MZDROP (IDIVDB, LSAVDB, 'L')   
        LSAVDB = 0  
        IQUEST(1) = IERR    
      ENDIF 
*                                                             END DBKEPT    
  999 END   
      SUBROUTINE DBKIN (PATHN, KEY1S, IUDIV, LBD, LSUP, JBIAS, IPREC)   
*     ===============================================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBKIN (PATHN, KEY1S, IUDIV, LBD*, LSUP, JBIAS, IPREC*)  *    
*                                                                      *    
*   Fetches from disk to a ZEBRA bank data valid for a given Key       *    
*   serial number (as stored inside the directory)                     *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     KEY1S    Serial number of the data to be fetched                 *    
*     IUDIV    Division index where bank is expected                   *    
*     LBD(*)   Address of the bank in memory                           *    
*     LSUP     Supporting link of the bank (see MZBOOK)                *    
*     JBIAS    Link bias for creating the data bank (see MZBOOK)       *    
*     IPREC(*) Precision word; (If IPREC > 0, data are stored with     *    
*              IPREC significant digits right to the decimal points; if*    
*              IPREC < 0, data are stored with IPREC insignificant     *    
*              digits left to the decimal point.)                      *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 31 : Illegal path name                               *    
*               = 32 : No key or data in the path name                 *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      DIMENSION       LSUP(9), LBD(9)   
      CHARACTER       PATH*80, PATHN*(*)    
*   
*     ------------------------------------------------------------------    
*   
* *** Set the character option  
*   
      CALL DBOPTS (' ') 
      IF (IQUEST(1).NE.0) GO TO 999 
      IOKYDA(MSERDB) = 1    
      ITIME  = 1    
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Set the current directory 
*   
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0)  THEN 
        IQUEST(1) = 31  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKIN : Illegal '//    
     +  'Path Name '//PATH(1:NCHAR)//''')', IARGDB, 0)  
        IOKYDA(MSERDB) = 0  
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKEYT   
*   
      IF (NKEYDK.LE.0)  THEN    
        IQUEST(1) = 32  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKIN : No key '// 
     +  'or data for Path Name '//PATH(1:NCHAR)//''')', IARGDB, 0)  
        IOKYDA(MSERDB) = 0  
        GO TO 999   
      ENDIF 
*   
* *** Read in the data  
*   
      CALL VZERO_i (KEYVDK, NWKYDK)   
      KEYVDK(MSERDB) = KEY1S    
      CALL DBKXIN (ITIME, IUDIV, LBD(1), LSUP(1), JBIAS, NWKEY, KEYVDK, 
     +             IPREC)   
      IOKYDA(MSERDB) = 0    
*                                                              END DBKIN    
  999 END   
      SUBROUTINE DBKTYP (PATHN, NKEYS, IOTY, CTAG)  
*     ============================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBKTYP (PATHN, *NKEYS*, IOTY*, CTAG*)                   *    
*                                                                      *    
*   Gets the key types and their tags for a given directory            *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     NKEYS    On input it carries the maximum dimension of IOTY and   *    
*              CTAG; on output it carries number of key elements (if   *    
*              no error; -1 if error)                                  *    
*     IOTY(*)  Type of each key element                                *    
*     CTAG(*)  Tag for each element                                    *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =101 : Illegal path name                               *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER*(*)   CTAG(*)   
      CHARACTER       PATHN*(*), PATH*80    
      DIMENSION       IOTY(9)   
*   
*     ------------------------------------------------------------------    
*   
* *** Set the current directory 
*   
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0)  THEN 
        IQUEST(1) = 101 
        NKEYS  = -1 
        IF (IDEBDB.GT.0) THEN   
          PATH   = PATHN    
          CALL DBPRNT (LPRTDB, '(/,'' DBKTYP : Illegal Path Name '//    
     +         PATH//''')', IARGDB, 0)  
        ENDIF   
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKYTG   
*   
* *** Fill up the user vectors  
*   
      NKMAX  = MIN0 (NKEYS, NWKYDK) 
      DO 10 I = 1, NKMAX    
        IOTY(I) = IOTYDK(I) 
        CTAG(I) = CTAGDK(I) 
   10 CONTINUE  
      NKEYS  = NWKYDK   
*                                                             END DBKTYP    
  999 END   
      SUBROUTINE DBKVIN (PATHN, ITIME, USER, NDAT, IDTYP, IPRVS, NWKEY, 
     +                   KEY, IPREC, CHOPT) 
*     ================================================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBKVIN (PATHN, ITIME, USER*, *NDAT*, IDTYP*, IPRVS,     *    
*                      NWKEY*, *KEY*, IPREC*, CHOPT)                   *    
*                                                                      *    
*   Fetches from disk to a FORTRAN array data valid for a given time   *    
*                                                                      *    
*   Restrictions : USER should contain variables of the same type      *    
*                  (Integer, Real or Holllereith)                      *    
*                  One should be very careful in using this routine.   *    
*                  The use of character option should be handled with  *    
*                  caution.                                            *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     ITIME    Time for which data are required to be valid            *    
*     USER(*)  User array where data are stored                        *    
*     NDAT(*)  Maximum dimension of USER array (on input)              *    
*              Number of data words fetched from disk (on output)      *    
*     IDTYP(*) Type of the data (2 - integer; 3 - real; 5 - Hollereith)*    
*     IPRVS    Program version number for selecting the data           *    
*              (if 0 no selection on program version number to be made)*    
*     NWKEY(*) Length of the key vector                                *    
*     KEY(*)   Key vector elements (If any User key or key 5 is nonzero*    
*              at input, data are retrieved according to that key      *    
*              content; on output it contains key elements for the     *    
*              data)                                                   *    
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *    
*              IPREC significant digits right to the decimal points; if*    
*              IPREC < 0, data are stored with IPREC insignificant     *    
*              digits leftto the decimal point.)                       *    
*     CHOPT    Character string with any of the following characters   *    
*          N   If data do not exist for ITIME, take the nearest data   *    
*              object in time                                          *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 31 : Illegal path name                               *    
*               = 32 : No keys/data in this directory                  *    
*               = 36 : Data bank address zero on return from DBKXIN    *    
*               = 37 : Insufficient space in USER store array          *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      DIMENSION       KEY(9), USER(2)   
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, PATHX*16   
*   
*     ------------------------------------------------------------------    
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0) GO TO 999 
      JBIAS  = 2    
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Set the current directory 
*   
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 31  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKVIN : Illegal'//    
     +  ' Path Name '//PATH(1:NCHAR)//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKEYT   
*   
      CALL RZCDIR (PATH, 'R')   
      NCHAR  = INDEX (PATH, ' ') - 1    
      IF (NCHAR.LT.0) NCHAR = MAXLDB    
      NCHRT  = INDEX (PATH(3:NCHAR), '/') - 1   
      IF (NCHRT.LE.0) NCHRT = NCHAR - 2 
      PATHX  = PATH(3:NCHRT+2)  
      LTOP   = LTOPDB   
   10 IF (LTOP.NE.0) THEN   
        NCHRT  = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHRT)   
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN  
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 10  
        ENDIF   
        KY7MDB = IQ(KOFUDB+LTOP+MUPKY7) 
      ELSE  
        KY7MDB = 0  
      ENDIF 
*   
* *** Check on the number of keys   
*   
      IF (NKEYDK.EQ.0) THEN 
        IQUEST(1) = 32  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKVIN : No key '//    
     +  'or data for Path Name '//PATH(1:NCHAR)//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
* *** Set up the character option   
*   
      IOPRDA = 0    
      IOPSDA = 0    
      DO 15 I = 1, NSYSDK   
   15 IOKYDA(I) = 0 
      IF (IPRVS.NE.0) THEN  
        IOKYDA(MPVSDB) = 1  
        KEY(MPVSDB)    = IPRVS  
      ELSE IF (KEY(MPVSDB).NE.0) THEN   
        IOKYDA(MPVSDB) = 1  
      ELSE  
        IOKYDA(MPVSDB) = 0  
      ENDIF 
      IF (NWKYDK.GT.NSYSDK) THEN    
        DO 20 IK = NSYSDK+1, NWKYDK 
          IF (KEY(IK).NE.0) THEN    
            IOKYDA(IK) = 1  
          ELSE  
            IOKYDA(IK) = 0  
          ENDIF 
   20   CONTINUE    
      ENDIF 
*   
* *** Read in the data  
*   
      CALL DBKXIN (ITIME, IDISDB, LAUXDL(7), LAUXDL(7), JBIAS, NWKEY,   
     +             KEY, IPREC)  
*   
      IF (IQUEST(1).NE.0)  THEN 
*   
*  **   DBKXIN encounters error in retrieving data  
*   
        NDAT      = 0   
*   
      ELSE IF (LAUXDL(7).EQ.0)  THEN    
*   
*  **   DBKXIN has not created the data bank    
*   
        IQUEST(1) = 36  
        NDAT      = 0   
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKVIN : Illegal'//    
     +  ' Bank address from DBKXIN'')', IARGDB, 0)  
*   
      ELSE  
*   
*  **   See if the USER array size is sufficient to store the data  
*   
        L      = LAUXDL(7)  
        ND     = IQ(KOFUDB+L-1) 
        IF (ND.GT.NDAT)  THEN   
*   
*  *      Insufficient space    
*   
          CALL MZDROP (IDISDB, LAUXDL(7), ' ')  
          IQUEST(1) = 37    
          IQUEST(11)= ND    
          IQUEST(12)= NDAT  
          NDAT      = 0 
          IF (IDEBDB.GT.0) THEN 
            IARGDB(1) = IQUEST(12)  
            IARGDB(2) = IQUEST(11)  
            CALL DBPRNT (LPRTDB, '(/,'' DBKVIN : Insufficient space'//  
     +           ' '',I10,'' to store data - a minimum of '',I10,'' '// 
     +           'storage is needed'')', IARGDB, 2) 
          ENDIF 
*   
        ELSE    
*   
*  *      Every thing is OK 
*   
          IQUEST(1) = 0 
          IDTYP     = IDBTYP(L) 
          CALL UCOPY (Q(KOFUDB+L+1), USER(1), ND)   
          NDAT      = ND    
          CALL MZDROP (IDISDB, LAUXDL(7), ' ')  
*   
        ENDIF   
      ENDIF 
*                                                             END DBKVIN    
  999 END   
      LOGICAL FUNCTION DBLAST (LBK) 
*     ============================= 
*   
************************************************************************    
*                                                                      *    
*        FUNC. DBLAST (LBK)                                            *    
*                                                                      *    
*   Checks if the Key bank corresponds to the last inserted object     *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LBK      Address of the key bank                                 *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =131 : Illegal pathname in the Key bank                *    
*               =132 : Illegal number of keys in the directory         *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       PATHN*80, PATHX*16    
      DIMENSION       LBK(9)    
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
* *** Get the path name from the key bank   
*   
      LREFDB(1) = LBK(1)    
      DBLAST = .FALSE.  
      LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)  
      NCH    = IQ(KOFUDB+LBNODB+MNDNCH) 
      CALL UHTOC (IQ(KOFUDB+LBNODB+MNDNAM), 4, PATHN, NCH)  
      PATHN  = PATHN(1:NCH) 
*   
* *** Set the current directory 
*   
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 131 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBLAST : Ill'//    
     +  'egal path name '//PATHN//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
      IF (IQUEST(7).LE.0) THEN  
        IQUEST(1) = 132 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBLAST : Illegal'//    
     +  ' number of keys for '//PATHN//''')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
*   
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      IPNT   = KOFSDB + LCDRDB + IKDRDB 
      ISTP   = NWKYDK + 1   
      IOPTP  = JBIT (IQ(IPNT+MFLGDB), JPRTDB)   
*   
* *** Take different action for partitioned and non-partitioned cases   
*   
      IF (IOPTP.EQ.0) THEN  
        KPNT   = IPNT + (NKEYDK-1) * ISTP   
        KMAX   = IQ(KPNT+MSERDB)    
        DO 10 I = 2, NKEYDK 
          KPNT   = KPNT - ISTP  
          IF (IQ(KPNT+MSERDB).GT.KMAX) KMAX = IQ(KPNT+MSERDB)   
   10   CONTINUE    
      ELSE  
*   
        DO 20 IK = 1, NKEYDK    
          JK     = NKEYDK + 1 - IK  
          CALL DBPATH (PATHX, JK)   
          PATHN  = PATHN(1:NCH)//'/'//PATHX 
          CALL RZCDIR (PATHN, ' ')  
          IF (IQUEST(1).NE.0) THEN  
            IQUEST(1) = 131 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBLAST : Ill'//    
     +      'egal path name '//PATHN//''')', IARGDB, 0) 
            GO TO 999   
          ENDIF 
          NKEYS  = IQUEST(7)    
          IF (NKEYS.GT.0) THEN  
            KPNT   = KOFSDB + IQUEST(11) + IQUEST(13) + (NKEYS-1) * ISTP    
            KMAX   = IQ(KPNT+MSERDB)    
            DO 15 I = 2, NKEYS  
              KPNT   = KPNT - ISTP  
              IF (IQ(KPNT+MSERDB).GT.KMAX) KMAX = IQ(KPNT+MSERDB)   
   15       CONTINUE    
            GO TO 30    
          ENDIF 
   20   CONTINUE    
      ENDIF 
*   
* *** Now compare last Key 1 with that in the Key bank  
*   
   30 IF (IQ(KOFUDB+LREFDB(1)+MSERDB).EQ.KMAX) DBLAST = .TRUE.  
      IQUEST(1) = 0 
*                                                             END DBLAST    
  999 END   
      SUBROUTINE DBLKEY (PATHN, KEY1, IDATE, ITIME) 
*     ============================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBLKEY (PATHN, KEY1*, IDATE*, ITIME*)                   *    
*                                                                      *    
*   Finds the latest inserted object for a given directory             *    
*   (Adapted from P.Bagnaia)                                           *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     KEY1(*)  The highest key(1) of the directory                     *    
*     IDATE(*) Date (YYMMDD) of the insertion of the last element      *    
*     ITIME(*) Time (HHMM)   "   "      "      "  "    "     "         *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =131 : Illegal pathname                                *    
*               =132 : Illegal number of keys in the directory         *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       PATHN*(*), PATHY*80, PATHX*16 
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATHY, NCHAR) 
*   
* *** Set the current directory path name   
*   
      CALL RZCDIR (PATHY, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 131 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBLKEY : Ill'//    
     +  'egal path name '//PATHY//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
      IF (IQUEST(7).LE.0) THEN  
        IQUEST(1) = 132 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBLKEY : Illegal'//    
     +  ' number of keys for '//PATHY//''')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
*   
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      IPNT   = KOFSDB + LCDRDB + IKDRDB 
      ISTP   = NWKYDK + 1   
      IOPTP  = JBIT (IQ(IPNT+MFLGDB), JPRTDB)   
*   
* *** Take different action for partitioned and non-partitioned cases   
*   
      IF (IOPTP.EQ.0) THEN  
        KPNT   = IPNT + (NKEYDK-1) * ISTP   
        KMAX   = IQ(KPNT+MSERDB)    
        JMAX   = NKEYDK 
        DO 10 I = 2, NKEYDK 
          KPNT   = KPNT - ISTP  
          IF (IQ(KPNT+MSERDB).GT.KMAX) THEN 
            KMAX = IQ(KPNT+MSERDB)  
            JMAX = I - 1    
          ENDIF 
   10   CONTINUE    
        KEY7   = IQ(IPNT+(JMAX-1)*ISTP+MITMDB)  
      ELSE  
*   
        CALL RZCDIR (PATHY, 'R')    
        NCH    = INDEX (PATHY, ' ') - 1 
        IF (NCH.LT.1 .OR. NCH.GT.MAXLDB) NCH = MAXLDB   
        DO 20 IK = 1, NKEYDK    
          JK     = NKEYDK + 1 - IK  
          CALL DBPATH (PATHX, JK)   
          PATHN  = PATHY(1:NCH)//'/'//PATHX 
          CALL RZCDIR (PATHY, ' ')  
          IF (IQUEST(1).NE.0) THEN  
            IQUEST(1) = 131 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBLKEY : Ill'//    
     +      'egal path name '//PATHY//''')', IARGDB, 0) 
            GO TO 999   
          ENDIF 
          NKEYS  = IQUEST(7)    
          IF (NKEYS.GT.0) THEN  
            IPNT   = KOFSDB + IQUEST(11) + IQUEST(13)   
            KPNT   = IPNT + (NKEYS-1) * ISTP    
            KMAX   = IQ(KPNT+MSERDB)    
            JMAX   = NKEYS  
            DO 15 I = 2, NKEYS  
              KPNT   = KPNT - ISTP  
              IF (IQ(KPNT+MSERDB).GT.KMAX) THEN 
                KMAX = IQ(KPNT+MSERDB)  
                JMAX = I - 1    
              ENDIF 
   15       CONTINUE    
            KEY7   = IQ(IPNT+(JMAX-1)*ISTP+MITMDB)  
            GO TO 30    
          ENDIF 
   20   CONTINUE    
      ENDIF 
*   
* *** and get the date  
*   
   30 CALL DBUPTM (IDATE, ITIME, KEY7)  
      IQUEST(1) = 0 
      KEY1      = KMAX  
*                                                             END DBLKEY    
  999 END   
      SUBROUTINE DBLMOD (PATHN, IDATE, ITIME)   
*     =======================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBLMOD (PATHN, IDATE*, ITIME*)                          *    
*                                                                      *    
*   Finds the date of last modification in a given directory           *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     IDATE(*) Date (YYMMDD) of last modification                      *    
*     ITIME(*) Time (HHMM) for the last modification                   *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =131 : Illegal pathname                                *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       PATHN*(*), PATHY*80   
*   
*     ------------------------------------------------------------------    
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATHY, NCHAR) 
*   
* *** Set the current directory path name   
*   
      CALL RZCDIR (PATHY, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 131 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBLMOD : Illegal'//    
     +  ' path name '//PATHY//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
      IDATE  = IQUEST(16)   
      ITIME  = IQUEST(17)   
*                                                             END DBLMOD    
  999 END   
      SUBROUTINE DBLOGL (LUNRZ, LOGLV)  
*     ================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBLOGL (LUNRZ, LOGLV)                                   *    
*                                                                      *    
*   Set the level of debug information                                 *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUNRZ    RZ file unit                                            *    
*     LOGLV    Level of debug output                                   *    
*                                                                      *    
*   Called by user,   DBACTI                                           *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
*   
*     ------------------------------------------------------------------    
*   
      CALL RZLOGL (LUNRZ, LOGLV)    
      IDEBDB = LOGLV    
*                                                             END DBLOGL    
      END   
      SUBROUTINE DBMDIP (PATHN, NWKEY, CHFOR, CHTAG, MXKP)  
*     ====================================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBMDIP (PATHN, NWKEY, CHFOR, CHTAG, MXKP)               *    
*                                                                      *    
*   Creates Directories with the conventions of DB package for         *    
*   partitioned data sets                                              *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Path name of the directory                              *    
*     NWKEY    Number of words associated to the keys at the lowest    *    
*              level (If some directory in the pathname at a higher    *    
*              level does not exist, it is created with 9 keys)        *    
*     CHFOR    Character variable describing each element of the key   *    
*              vector at the lowest level (at higher level it is set   *    
*              to default, i.e., 'IIIIIIIII')                          *    
*              The first 7 characters should be 'I'                    *    
*     CHTAG    Character array defined as CHARACTER*8 (NWKEY)          *    
*              The first 7 elements should be :  'SERIAL_#'            *    
*                                                'POINTER '            *    
*                                                'STR_VALI'            *    
*                                                'END_VALI'            *    
*                                                'PRG_VERS'            *    
*                                                'FLAGS   '            *    
*                                                'INS_TIME'            *    
*     MXKP     Maximum number of objects in each partition             *    
*                                                                      *    
*   Called by user,   DBCRSD, DBENTB, DBENTR, DBFZUP, DBNTOP, DBOUT,   *    
*             DBREPL, DBVOUT, DBENFZ, DBKOUT, DBCRDR                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 41 : CHFOR for DB system keys declared wrongly by    *    
*                      user                                            *    
*               = 42 : CHTAG for DB system keys declared wrongly by    *    
*                      user                                            *    
*               = 43 : Too many key elements                           *    
*               = 44 : Cannot find the top directory name              *    
*                      (wrong initialisation)                          *    
*               = 45 : Illegal Path name                               *    
*               = 46 : Top directory name in the Path name does not    *    
*                      match with the Top directory name               *    
*               = 48 : Error in directory search sequence              *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      CHARACTER       CHFOR*(*), PATHN*(*)  
      CHARACTER       PATH*80, PATHX*80, PATHL*80, CHTMP*8  
      CHARACTER*(*)   CHTAG(*)  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension iarg(9), nio(9)
*     ------------------------------------------------------------------    
*   
* *** Check on format and tags of the DB system keys    
*   
      KEY7   = KEY7DK   
      KEY7DK = 0    
      PATHL  = ' '  
      IF (CHFOR(1:NSYSDK) .NE. CHFTDK(1:NSYSDK)) GO TO 991  
      DO 5 I = 1, NSYSDK    
        IF (CHTAG(I) .NE. CHTGDK(I))             GO TO 992  
    5 CONTINUE  
      IF (NWKEY.GT.MXDMDK.OR.NWKEY.LT.NSYSDK)    GO TO 993  
      MXK    = MXKP 
      IF (MXK.LT.1) MXK = MXKPDK    
*   
* *** Find the Top Directory name   
*   
      CALL RZCDIR (PATHX, 'R')  
*   
      IF (IQUEST(1).EQ.0)  THEN 
*   
*  **   From Current directory  
*   
        I0     = 0  
        MAXL   = MAXLDB 
   10   I1     = I0 + 1 
        IF (I1.GT.MAXL)                          GO TO 994  
        DO 15 I0 = I1, MAXL 
          IF (PATHX(I0:I0).EQ.' ')               GO TO 25   
          IF (PATHX(I0:I0).EQ.'/')               GO TO 20   
   15   CONTINUE    
        I0     = MAXL + 1   
   20   I2     = I0 - 1 
        GO TO 30    
   25   I2     = I0 - 1 
        I0     = MAXL + 1   
   30   IF (I2.LT.I1)                            GO TO 10   
        NCHAR  = I2 - I1 + 1    
        TOPNDI = PATHX(I1:I2)   
*   
      ELSE IF (LTOPDB.NE.0)  THEN   
*   
*  **   From the name stored at the first DBINIT call   
*   
        NCHAR  = IQ(KOFUDB+LTOPDB+MUPNCH)   
        CALL UHTOC (IQ(KOFUDB+LTOPDB+MUPNAM), 4, PATHX, NCHAR)  
        PATHX  = PATHX(1:NCHAR) 
        TOPNDI = PATHX  
*   
      ELSE  
*   
*  **   Fatal error 
*   
        GO TO 994   
*   
      ENDIF 
*   
* *** Remove imbedded blanks from the path name 
*   
      CALL DBSBLC (PATHN, PATH, NCH)    
      IF (NCH.EQ.0)                              GO TO 995  
*   
* *** Get the complete path name    
*   
      IDONE  = 0    
      IF (PATH(1:2).EQ.'//')  THEN  
*   
*  **   Check if the Top directory name matches 
*   
        LTOP   = LTOPDB 
   45   IF (LTOP.NE.0) THEN 
          NCHR   = IQ(KOFUDB+LTOP+MUPNCH)   
          CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHR)  
          IF (PATH(3:NCHAR+2).NE.TOPNDI(1:NCHR)) THEN   
            LTOP   = LQ(KOFUDB+LTOP)    
            GO TO 45    
          ENDIF 
          IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10) 
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)  
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)   
          IF (IOUT.EQ.0) IOPS = 0   
          IDONE  = 1    
        ELSE    
          GO TO 996 
        ENDIF   
*   
      ELSE IF (PATH(1:1).EQ.'/') THEN   
        PATH   = '//'//TOPNDI(1:NCHAR)//PATH    
        NCH    = NCH + NCHAR + 2    
*   
      ELSE IF (PATH(1:1).EQ.'\') THEN   
        IL     = 0  
        DO 50 I0 = 1, MAXLDB    
          IF (PATHX(I0:I0).EQ.'/') IL = I0  
   50   CONTINUE    
        IF (IL.LE.1)                             GO TO 995  
        PATH   = PATHX(1:IL-1)//'/'//PATH(2:NCH)    
        NCH    = IL + NCH - 1   
*   
      ELSE IF (PATH(1:1).EQ.'~' .OR. PATH(1:1).EQ.'_') THEN 
*   
        CALL RZNDIR (PATHX, 'R')    
        IF (IQUEST(1).NE.0)                      GO TO 994  
        IL     = 0  
        DO 55 I0 = 1, MAXLDB    
          IF (PATHX(I0:I0).NE.' ') IL = I0  
   55   CONTINUE    
        IF (IL.LE.1)                             GO TO 995  
        PATH   = PATHX(1:IL)//'/'//PATH(2:NCH)  
        NCH    = IL + NCH   
*   
      ELSE  
*   
        IL     = 0  
        DO 60 I0 = 1, MAXLDB    
          IF (PATHX(I0:I0).NE.' ') IL = I0  
   60   CONTINUE    
        IF (IL.LE.1)                             GO TO 995  
        PATH   = PATHX(1:IL)//'/'//PATH(1:NCH)  
        NCH    = IL + NCH + 1   
      ENDIF 
*   
* *** Check if the directory exists as yet  
*   
      IENCH  = NCHAR + 1    
      I      = NCHAR + 2    
      IP     = NCHAR + 3    
      IF (IP.LE.NCH) THEN   
        CALL RZCDIR (PATH, ' ') 
        IF (IQUEST(1).EQ.0) THEN    
          IF (IDONE.EQ.0) THEN  
            NCHRT  = INDEX (PATH(3:NCH), '/') - 1   
            IF (NCHRT.LE.0) NCHRT = NCH - 2 
            LTOP   = LTOPDB 
   62       IF (LTOP.NE.0) THEN 
              NCHR   = IQ(KOFUDB+LTOP+MUPNCH)   
              CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHR)  
              IF (PATH(3:NCHRT+2).NE.TOPNDI(1:NCHR)) THEN   
                LTOP   = LQ(KOFUDB+LTOP)    
                GO TO 62    
              ENDIF 
              IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)  
              IOUT   = IQ(KOFUDB+LTOP+MUPFLG)   
              IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10) 
            ELSE    
              IOPP   = 0    
              IOPS   = 0    
              IOUT   = 0    
            ENDIF   
          ENDIF 
          IF (IOUT.EQ.0) IOPS = 0   
          IF (IOKYDA(MSERDB).EQ.0.AND.IOPP.EQ.0) GO TO 80   
          GO TO 999 
        ENDIF   
      ENDIF 
*   
* *** Save the Directory creation information in the FZ file    
*   
      CALL DBSDIR (PATH, NWKEY, CHFOR, CHTAG, MXK, IOPP, IOPS)  
      IF (IOPP.NE.0)                             GO TO 999  
      IF (IQUEST(1).NE.0)                        GO TO 999  
*   
* *** Create a new (tree of) director(ies) - from the first 
* *** non-existing name 
* *** Go down to the lowest existing directory in PATH  
*   
   65 I      = I + 1    
      IF (PATH(I:I).EQ.'/')  THEN   
        CALL RZCDIR (PATH(1:I-1), ' ')  
        IF (IQUEST(1).NE.0)                      GO TO 68   
        IENCH  = I -1   
      ELSE IF (I.GE.NCH)  THEN  
        CALL RZCDIR (PATH(1:I), ' ')    
        IF (IQUEST(1).NE.0)                      GO TO 68   
        GO TO 80    
      ENDIF 
      GO TO 65  
*   
* *** Lock the directory if needed  
*   
   68 IF (IOPS.NE.0) THEN   
        PATHL  = PATH(1:IENCH)  
        CALL RZCDIR (PATHL, ' ')    
        CALL RZLOCK ('DBMDIP')  
      ENDIF 
*   
* *** Create new directories    
*   
   70 ISTCH  = IENCH + 2    
      IF (ISTCH.GT.NCH)                          GO TO 998  
      PATHX  = PATH(ISTCH:ISTCH)    
      J      = 0    
      ISTCH  = ISTCH + 1    
      I      = ISTCH    
   75 CONTINUE  
      IF (PATH(I:I).EQ.'/')  THEN   
        CALL RZCDIR (PATH(1:IENCH), ' ')    
*   
*  **   Create the intermediate level directory with default values 
*   
        CALL RZMDIR (PATHX, NINEDK, CHFTDK, CHTGDK) 
        IF (IQUEST(1).NE.0)                      GO TO 998  
        IF (PATHL.NE.' ') THEN  
          CALL RZCDIR (PATHL, ' ')  
          CALL RZFREE ('DBMDIP')    
          PATHL  = ' '  
          CALL RZCDIR (PATH(1:IENCH), ' ')  
        ENDIF   
        CALL DBCDIC (PATHX) 
        IF (IQUEST(1).NE.0)                      GO TO 9981 
        IF (IOPS.NE.0) THEN 
          PATHL  = PATH(1:IENCH)    
          CALL RZCDIR (PATHL, ' ')  
          CALL RZLOCK ('DBMDIP')    
        ENDIF   
        IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ') 
        IENCH  = I - 1  
        I      = I + 1  
        PATHX  = PATH(I:I)  
        J      = 0  
*   
      ELSE  
        J      = J + 1  
        PATHX  = PATHX(1:J)//PATH(I:I)  
      ENDIF 
      IF (I.LT.NCH)  THEN   
        I      = I + 1  
        GO TO 75    
      ENDIF 
*   
      IF (IENCH.GE.0) CALL RZCDIR (PATH(1:IENCH),' ')   
      CALL RZMDIR (PATHX, NWKEY, CHFOR, CHTAG)  
      IF (IQUEST(1).NE.0)                        GO TO 998  
      IF (PATHL.NE.' ') THEN    
        CALL RZCDIR (PATHL, ' ')    
        CALL RZFREE ('DBMDIP')  
        PATHL  = ' '    
        IF (IENCH.GE.0) CALL RZCDIR (PATH(1:IENCH), ' ')    
      ENDIF 
      CALL DBCDIC (PATHX)   
      IF (IQUEST(1).NE.0)                        GO TO 9981 
      IF (IOPS.NE.0) THEN   
        PATHL  = PATH(1:IENCH)  
        CALL RZCDIR (PATHL, ' ')    
        CALL RZLOCK ('DBMDIP')  
      ENDIF 
      IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')   
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0)                        GO TO 998  
*   
* *** Now create Partitioned subdirectory   
*   
   80 NK    = IQUEST(7) 
      CALL VZERO_i (KEYNDK, NSYSDK)   
      IF (NK.GT.0) THEN 
*   
*  **   Get the keys of the last data inserted  
*   
        CALL DBPATH (PATHX, NK) 
        CALL RZCDIR (PATHX, ' ')    
        IF (IQUEST(1).NE.0)                      GO TO 998  
        NKEYDK = IQUEST(7)  
        NWKYDK = IQUEST(8)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        ISTP   = NWKYDK + 1 
        IPNT   = KOFSDB + LCDRDB + IKDRDB   
        KEYNDK(MOBJDB) = IQ(IPNT+MSERDB)    
        IF (NKEYDK.GT.1) THEN   
          DO 85 IK = 2, NKEYDK  
            IPNT   = IPNT + ISTP    
            IF (KEYNDK(MOBJDB).LT.IQ(IPNT+MSERDB))  
     +        KEYNDK(MOBJDB) = IQ(IPNT+MSERDB)  
   85     CONTINUE  
        ENDIF   
      ENDIF 
*   
*  ** Fill up the remaining keys    
*   
      KEYNDK(MPSRDB) = NK + 1   
      KEYNDK(MXKPDB) = MXK  
      KEYNDK(MBVRDB) = 900000000    
      KEYNDK(MEVRDB) = 0    
      KEYNDK(MFLGDB) = MSBIT1 (KEYNDK(MFLGDB), JPRTDB)  
      IF (KEY7.EQ.0) THEN   
        CALL DATIME (IDATE, ITIME)  
        CALL DBPKTM (IDATE, ITIME, KEYNDK(MITMDB))  
      ELSE  
        KEYNDK(MITMDB) = KEY7   
      ENDIF 
      IF (NWKEY.GT.NSYSDK) THEN 
        DO 90 IK = NSYSDK+1, NWKEY  
          IF (CHFOR(IK:IK).EQ.'A'.OR.CHFOR(IK:IK).EQ.'H') THEN  
            CALL UCTOH ('    ', KEYNDK(IK), 4, 4)   
          ELSE  
            KEYNDK(IK) = 0  
          ENDIF 
   90   CONTINUE    
      ENDIF 
*   
*  ** Insert a keyname for the new partition    
*   
      CALL RZCDIR (PATH, ' ')   
      IF (IOPS.NE.0) THEN   
        IF (PATHL.EQ.' ') THEN  
          PATHL  = PATH 
          CALL RZLOCK ('DBMDIP')    
        ENDIF   
      ENDIF 
      IF (LSTRDL(3).NE.0) CALL MZDROP (IDISDB, LSTRDL(3), ' ')  
      JBIAS  = 2
      nio(1) = 2
      CALL DBBOOK (IDISDB, LSTRDL(3), LSTRDL(3), JBIAS, 'SAME', 0, 0, 0,    
     +             nio, 0)    
      IF (IQUEST(1).NE.0)                        GO TO 9981 
      CALL RZOUT (IDISDB, LSTRDL(3), KEYNDK, ICYCLE, 'S')   
      CALL MZDROP (IDISDB, LSTRDL(3), ' ')  
      LSTRDL(3) = 0 
      CALL DBPATH (PATHX, KEYNDK(MPSRDB))   
      CALL RZMDIR (PATHX, NWKEY, CHFOR, CHTAG)  
      IF (IQUEST(1).NE.0) THEN  
        CALL RZDELK (KEYNDK, ICYCLE, 'C')   
        GO TO 998   
      ENDIF 
      IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')   
      GO TO 9981    
*   
* *** Error Messages    
*   
  991 IQUEST(1) = 41    
      IF (IDEBDB.GT.0) THEN 
        CHTMP  = CHFOR(1:NSYSDK)    
        CALL DBPRNT (LPRTDB, '(/,'' DBMDIP : The system characters fo'//    
     +       'r CHFOR '//CHTMP//' does not conform with the default '// 
     +       CHFTDK(1:NSYSDK)//''')', IARGDB, 0)    
      ENDIF 
      GO TO 999 
*   
  992 IQUEST(1) = 42    
      IF (IDEBDB.GT.0) THEN 
        CALL DBPRNT (LPRTDB, '(/,'' DBMDIP : The system tags for CHTA'//    
     +       'G does not conform with defaults '')', IARGDB, 0) 
        DO 9921 I = 1, NSYSDK   
          CHTMP = CHTAG(I)
          iarg(1) = i
          CALL DBPRNT (LPRTDB, '(10X,''Key '',I2,'' Supplied '//CHTMP// 
     +         ' Default '//CHTGDK(I)//''')', Iarg, 1) 
 9921   CONTINUE    
      ENDIF 
      GO TO 999 
*   
  993 IQUEST(1) = 43    
      IQUEST(11)= NWKEY 
      IQUEST(12)= MXDMDK
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIP : Too many '//    
     +   'key elements requested = '',I6,'' maximum permitted '',I5)',  
     +   IQUEST(11), 2) 
      GO TO 999 
*   
  994 IQUEST(1) = 44    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIP : Cannot fi'//    
     +   'nd the top directory '')', IARGDB, 0) 
      GO TO 999 
*   
  995 IQUEST(1) = 45    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIP : Illegal '// 
     +   'path name '//PATHX//''')', IARGDB, 0) 
      GO TO 999 
*   
  996 IQUEST(1) = 46    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIP : Top direc'//    
     +   'tory name in path name '//PATHX//''',/,''          does not'//    
     +   ' match with '//TOPNDI//''')', IARGDB, 0)  
      GO TO 999 
*   
  998 IQUEST(1) = 48    
      IQUEST(11)= ISTCH 
      IQUEST(12)= NCH
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIP : Error in '//    
     +   'Directory Search - ISTCH = '',I5,'' NCH = '',I5)', IQUEST(11),
     +   2) 
*   
* *** Unlock the directory if required  
*   
 9981 IF (PATHL.NE.' ') THEN    
        IERR   = IQUEST(1)  
        CALL RZCDIR (PATHL, ' ')    
        CALL RZFREE ('DBMDIP')  
        IQUEST(1) = IERR    
      ENDIF 
*                                                             END DBMDIP    
  999 END   
      SUBROUTINE DBMDIR (PATHN, NWKEY, CHFOR, CHTAG)    
*     ==============================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBMDIR (PATHN, NWKEY, CHFOR, CHTAG)                     *    
*                                                                      *    
*   Creates Directories with the conventions of DB package             *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Path name of the directory                              *    
*     NWKEY    Number of words associated to the keys at the lowest    *    
*              level (If some directory in the pathname at a higher    *    
*              level does not exist, it is created with 9 keys)        *    
*     CHFOR    Character variable describing each element of the key   *    
*              vector at the lowest level (at higher level it is set   *    
*              to default, i.e., 'IIIIIIIII')                          *    
*              The first 7 characters should be 'I'                    *    
*     CHTAG    Character array defined as CHARACTER*8 (NWKEY)          *    
*              The first 7 elements should be :  'SERIAL_#'            *    
*                                                'POINTER '            *    
*                                                'STR_VALI'            *    
*                                                'END_VALI'            *    
*                                                'PRG_VERS'            *    
*                                                'FLAGS   '            *    
*                                                'INS_TIME'            *    
*                                                                      *    
*   Called by user,   DBCRSD, DBENTR, DBFZUP, DBOUT,  DBREPL, DBVOUT,  *    
*             DBCRDR                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 41 : CHFOR for DB system keys declared wrongly by    *    
*                      user                                            *    
*               = 42 : CHTAG for DB system keys declared wrongly by    *    
*                      user                                            *    
*               = 43 : Too many key elements                           *    
*               = 44 : Cannot find the top directory name              *    
*                      (wrong initialisation)                          *    
*               = 45 : Illegal Path name                               *    
*               = 46 : Top directory name in the Path name does not    *    
*                      match with the Top directory name               *    
*               = 47 : The Directory already exists                    *    
*               = 48 : Error in directory search sequence              *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      CHARACTER       CHFOR*(*), PATHN*(*)  
      CHARACTER       PATH*80, PATHX*80, PATHL*80, CHTMP*8  
      CHARACTER*(*)   CHTAG(*)  
*
      dimension iarg(9)
*     ------------------------------------------------------------------    
*   
* *** Check on format and tags of the DB system keys    
*   
      PATHL  = ' '  
      IF (CHFOR(1:NSYSDK) .NE. CHFTDK(1:NSYSDK)) GO TO 991  
      DO 5 I = 1, NSYSDK    
        IF (CHTAG(I) .NE. CHTGDK(I))             GO TO 992  
    5 CONTINUE  
      IF (NWKEY.GT.MXDMDK.OR.NWKEY.LT.NSYSDK)    GO TO 993  
*   
* *** Find the Top Directory name   
*   
      CALL RZCDIR (PATHX, 'R')  
*   
      IF (IQUEST(1).EQ.0)  THEN 
*   
*  **   From Current directory  
*   
        I0     = 0  
        MAXL   = MAXLDB 
   10   I1     = I0 + 1 
        IF (I1.GT.MAXL)                          GO TO 994  
        DO 15 I0 = I1, MAXL 
          IF (PATHX(I0:I0).EQ.' ')               GO TO 25   
          IF (PATHX(I0:I0).EQ.'/')               GO TO 20   
   15   CONTINUE    
        I0     = MAXL + 1   
   20   I2     = I0 - 1 
        GO TO 30    
   25   I2     = I0 - 1 
        I0     = MAXL + 1   
   30   IF (I2.LT.I1)                            GO TO 10   
        NCHAR  = I2 - I1 + 1    
        TOPNDI = PATHX(I1:I2)   
*   
      ELSE IF (LTOPDB.NE.0)  THEN   
*   
*  **   From the name stored at the first DBINIT call   
*   
        NCHAR  = IQ(KOFUDB+LTOPDB+MUPNCH)   
        CALL UHTOC (IQ(KOFUDB+LTOPDB+MUPNAM), 4, PATHX, NCHAR)  
        PATHX  = PATHX(1:NCHAR) 
        TOPNDI = PATHX  
*   
      ELSE  
*   
*  **   Fatal error 
*   
        GO TO 994   
*   
      ENDIF 
*   
* *** Remove imbedded blanks from the path name 
*   
      CALL DBSBLC (PATHN, PATH, NCH)    
      IF (NCH.EQ.0)                              GO TO 995  
*   
* *** Get the complete path name    
*   
      IF (PATH(1:2).EQ.'//')  THEN  
*   
*  **   Check if the Top directory name matches 
*   
        LTOP   = LTOPDB 
   45   IF (LTOP.NE.0) THEN 
          NCHR   = IQ(KOFUDB+LTOP+MUPNCH)   
          CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHR)  
          IF (PATH(3:NCHAR+2).NE.TOPNDI(1:NCHR)) THEN   
            LTOP   = LQ(KOFUDB+LTOP)    
            GO TO 45    
          ENDIF 
        ELSE    
          GO TO 996 
        ENDIF   
*   
      ELSE IF (PATH(1:1).EQ.'/') THEN   
        PATH   = '//'//TOPNDI(1:NCHAR)//PATH    
        NCH    = NCH + NCHAR + 2    
*   
      ELSE IF (PATH(1:1).EQ.'\') THEN   
        IL     = 0  
        DO 50 I0 = 1, MAXLDB    
          IF (PATHX(I0:I0).EQ.'/') IL = I0  
   50   CONTINUE    
        IF (IL.LE.1)                             GO TO 995  
        PATH   = PATHX(1:IL-1)//'/'//PATH(2:NCH)    
        NCH    = IL + NCH - 1   
*   
      ELSE IF (PATH(1:1).EQ.'~' .OR. PATH(1:1).EQ.'_') THEN 
*   
        CALL RZNDIR (PATHX, 'R')    
        IF (IQUEST(1).NE.0)                      GO TO 994  
        IL     = 0  
        DO 55 I0 = 1, MAXLDB    
          IF (PATHX(I0:I0).NE.' ') IL = I0  
   55   CONTINUE    
        IF (IL.LE.1)                             GO TO 995  
        PATH   = PATHX(1:IL)//'/'//PATH(2:NCH)  
        NCH    = IL + NCH   
*   
      ELSE  
*   
        IL     = 0  
        DO 60 I0 = 1, MAXLDB    
          IF (PATHX(I0:I0).NE.' ') IL = I0  
   60   CONTINUE    
        IF (IL.LE.1)                             GO TO 995  
        PATH   = PATHX(1:IL)//'/'//PATH(1:NCH)  
        NCH    = IL + NCH + 1   
      ENDIF 
*   
* *** Check if the directory exists as yet  
*   
      IENCH  = NCHAR + 1    
      I      = NCHAR + 2    
      IP     = NCHAR + 3    
      IF (IP.LE.NCH) THEN   
        CALL RZCDIR (PATH, ' ') 
        IF (IQUEST(1).EQ.0) THEN    
          IF (IOKYDA(MSERDB).EQ.0)               GO TO 997  
          GO TO 999 
        ENDIF   
      ENDIF 
*   
* *** Save the Directory creation information in the FZ file    
*   
      CALL DBSDIR (PATH, NWKEY, CHFOR, CHTAG, 0, IOPP, IOPS)    
      IF (IQUEST(1).NE.0)                        GO TO 999  
      IF (IOPP.NE.0)                             GO TO 999  
*   
* *** Create a new (tree of) director(ies) - from the first 
* *** non-existing name 
* *** Go down to the lowest existing directory in PATH  
*   
   65 I      = I + 1    
      IF (PATH(I:I).EQ.'/')  THEN   
        CALL RZCDIR (PATH(1:I-1), ' ')  
        IF (IQUEST(1).NE.0)                      GO TO 68   
        IENCH  = I -1   
      ELSE IF (I.GE.NCH)  THEN  
        CALL RZCDIR (PATH(1:I), ' ')    
        IF (IQUEST(1).NE.0)                      GO TO 68   
        GO TO 997   
      ENDIF 
      GO TO 65  
*   
* *** Lock the directory if needed  
*   
   68 IF (IOPS.NE.0) THEN   
        PATHL  = PATH(1:IENCH)  
        CALL RZCDIR (PATHL, ' ')    
        CALL RZLOCK ('DBMDIR')  
      ENDIF 
*   
* *** Create new directories    
*   
   70 ISTCH  = IENCH + 2    
      IF (ISTCH.GT.NCH)                          GO TO 998  
      PATHX  = PATH(ISTCH:ISTCH)    
      J      = 0    
      ISTCH  = ISTCH + 1    
      I      = ISTCH    
   75 CONTINUE  
      IF (PATH(I:I).EQ.'/')  THEN   
        CALL RZCDIR (PATH(1:IENCH), ' ')    
*   
*  **   Create the intermediate level directory with default values 
*   
        CALL RZMDIR (PATHX, NINEDK, CHFTDK, CHTGDK) 
        IF (IQUEST(1).NE.0)                      GO TO 998  
        IF (PATHL.NE.' ') THEN  
          CALL RZCDIR (PATHL, ' ')  
          CALL RZFREE ('DBMDIR')    
          PATHL  = ' '  
          CALL RZCDIR (PATH(1:IENCH), ' ')  
        ENDIF   
        CALL DBCDIC (PATHX) 
        IF (IQUEST(1).NE.0)                      GO TO 9981 
        IF (IOPS.NE.0) THEN 
          PATHL  = PATH(1:IENCH)    
          CALL RZCDIR (PATHL, ' ')  
          CALL RZLOCK ('DBMDIR')    
        ENDIF   
        IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ') 
        IENCH  = I - 1  
        I      = I + 1  
        PATHX  = PATH(I:I)  
        J      = 0  
*   
      ELSE  
        J      = J + 1  
        PATHX  = PATHX(1:J)//PATH(I:I)  
      ENDIF 
      IF (I.LT.NCH)  THEN   
        I      = I + 1  
        GO TO 75    
      ENDIF 
*   
      IF (IENCH.GE.0) CALL RZCDIR (PATH(1:IENCH),' ')   
      CALL RZMDIR (PATHX, NWKEY, CHFOR, CHTAG)  
      IF (IQUEST(1).NE.0)                        GO TO 998  
      IF (PATHL.NE.' ') THEN    
        CALL RZCDIR (PATHL, ' ')    
        CALL RZFREE ('DBMDIR')  
        PATHL  = ' '    
        IF (IENCH.GE.0) CALL RZCDIR (PATH(1:IENCH), ' ')    
      ENDIF 
      CALL DBCDIC (PATHX)   
      IF (IQUEST(1).NE.0)                        GO TO 9981 
      IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')   
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0)                        GO TO 998  
      GO TO 9981    
*   
* *** Error Messages    
*   
  991 IQUEST(1) = 41    
      IF (IDEBDB.GT.0) THEN 
        CHTMP  = CHFOR(1:NSYSDK)    
        CALL DBPRNT (LPRTDB, '(/,'' DBMDIR : The system characters fo'//    
     +       'r CHFOR '//CHTMP//' does not conform with the default '// 
     +       CHFTDK(1:NSYSDK)//''')', IARGDB, 0)    
      ENDIF 
      GO TO 999 
*   
  992 IQUEST(1) = 42    
      IF (IDEBDB.GT.0) THEN 
        CALL DBPRNT (LPRTDB, '(/,'' DBMDIR : The system tags for CHTA'//    
     +       'G does not conform with defaults '')', IARGDB, 0) 
        DO 9921 I = 1, NSYSDK   
          CHTMP = CHTAG(I)
          iarg(1) = i
          CALL DBPRNT (LPRTDB, '(10X,''Key '',I2,'' Supplied '//CHTMP// 
     +         ' Default '//CHTGDK(I)//''')', Iarg, 1) 
 9921   CONTINUE    
      ENDIF 
      GO TO 999 
*   
  993 IQUEST(1) = 43    
      IQUEST(11)= NWKEY 
      IQUEST(12)= MXDMDK
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIR : Too many '//    
     +   'key elements requested = '',I6,'' maximum permitted '',I5)',  
     +   IQUEST(11), 2) 
      GO TO 999 
*   
  994 IQUEST(1) = 44    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIR : Cannot fi'//    
     +   'nd the top directory '')', IARGDB, 0) 
      GO TO 999 
*   
  995 IQUEST(1) = 45    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIR : Illegal '// 
     +   'path name '//PATHX//''')', IARGDB, 0) 
      GO TO 999 
*   
  996 IQUEST(1) = 46    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIR : Top direc'//    
     +   'tory name in path name '//PATHX//''',/,''          does not'//    
     +   ' match with '//TOPNDI//''')', IARGDB, 0)  
      GO TO 999 
*   
  997 IQUEST(1) = 47    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIR : Existing '//    
     +   'directory is in conflict with Path name '',/,9X,'' '//PATH//  
     +   ' '')', IARGDB, 0) 
      GO TO 999 
*   
  998 IQUEST(1) = 48    
      IQUEST(11)= ISTCH 
      IQUEST(12)= NCH
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIR : Error in '//    
     +   'Directory Search - ISTCH = '',I5,'' NCH = '',I5)', IQUEST(11),    
     +   2) 
*   
* *** Unlock the directory if required  
*   
 9981 IF (PATHL.NE.' ') THEN    
        IERR   = IQUEST(1)  
        CALL RZCDIR (PATHL, ' ')    
        CALL RZFREE ('DBMDIR')  
        IQUEST(1) = IERR    
      ENDIF 
*                                                             END DBMDIR    
  999 END   
      SUBROUTINE DBNTOP (PATHI, PATHO, MXKP0, NSAV, CHOPT)  
*     ====================================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBNTOP (PATHI, PATHO, MXKP0, NSAV, CHOPT)               *    
*                                                                      *    
*   Transforms the contents of a non-partitioned directory to a        *    
*   partitioned directory.                                             *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHI    Character string describing the input  pathname         *    
*     PATHO    Character string describing the output pathname         *    
*     MXKP0    Maximum number of objects in the partitioned directory  *    
*     NSAV     Maximum number of objects to be entered in one go       *    
*              (default is 20)                                         *    
*     CHOPT    Character string with any of the following characters   *    
*          B   Save in the special backup file; not in standard Journal*    
*          F   Updates with a fully matched data object (in user keys) *    
*                                                                      *    
*   Called by user,   DBACTI                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 68 : Input directory is partitioned                  *    
*               = 71 : Illegal path name                               *    
*               = 73 : RZOUT fails to write on disk                    *    
*               = 74 : Error in RZRENK in updating key values for      *    
*                      partitioned data set                            *    
*               = 75 : Cannot find the Top directory name in pathname  *    
*               = 76 : Cannot form the IO descriptor for the FZ header *    
*               = 77 : FZOUT fails to write on to the sequential file  *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (NSVMDS=50, NSAVDS=20, MXDMDS=100)    
      COMMON /DSAVBK/ NOBJDS, LOBJDS(NSVMDS), KEYSDS(MXDMDS,NSVMDS) 
*   
      COMMON /DZPACK/ PRECDZ, PACKDZ    
      LOGICAL         PACKDZ    
*   
      PARAMETER       (NLEVM=20)    
      INTEGER         NLCUR(NLEVM)  
      DIMENSION       KEYO(MXDMDK), KEYN(MXDMDK)    
      CHARACTER       PATHY*80, PATH*80, PATHX*16, CHFOR*100, CFORM(6)*1    
      CHARACTER       CHCUR(NLEVM)*1, TOPN*16, CHOPS(NSVMDS)*4, CHOP0*4 
      CHARACTER       PATHI*(*), PATHO*(*), CHOPT*(*), CHOP*1, CHFRM*100    
      DATA            CFORM /'B', 'I', 'F', 'D', 'H', 'A'/  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      integer ival
      real fval
      equivalence (ival, fval)
*     ------------------------------------------------------------------    
*   
* *** Suppress blanks from the path name    
*   
      CALL DBOPTS (' ') 
      CALL UOPTC  (CHOPT, 'B', IOPBDA)  
      CALL UOPTC  (CHOPT, 'F', IOPFDA)  
      CALL DBSBLC (PATHI, PATH, NCHRI)  
      CALL DBSBLC (PATHO, PATHY, NCHAR) 
      IF (NSAV.GT.0) THEN   
        NSAVM  = MIN0 (NSAV, NSVMDS)    
      ELSE  
        NSAVM  = NSAVDS 
      ENDIF 
*   
* *** Set the current directory for input path name 
*   
      PATHX  = ' '  
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 71  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Illegal'//    
     +  ' Path Name '//PATH//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      KST    = NWKYDK + 1   
      NWKEY  = NWKYDK   
      CALL RZCDIR (PATH, 'R')   
      CALL DBKYTG   
      IF (NKEYDK.NE.0)  THEN    
        IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)    
        IOPTP  = JBIT (IOPTP, JPRTDB)   
      ELSE  
        IOPTP  = 0  
      ENDIF 
      IF (IOPTP.NE.0) THEN  
        IQUEST(1) = 68  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Directo'//    
     +  'ry '//PATH//' is partitioned '')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
* *** Prepare the partitioned directory 
*   
      NKEYS  = NKEYDK   
      CHFOR  = ' '  
      DO 10 IK = 1, NWKEY   
        IF (IOTYDK(IK).GT.0.AND.IOTYDK(IK).LT.7) THEN   
          CHFOR(IK:IK) = CFORM(IOTYDK(IK))  
        ELSE    
          CHFOR(IK:IK) = CFORM(2)   
        ENDIF   
   10 CONTINUE  
      CALL DBMDIP (PATHY, NWKEY, CHFOR, CTAGDK, MXKP0)  
      IF (IQUEST(1).NE.0)          GO TO 999    
      IF (NKEYS.LE.0)              GO TO 999    
*   
* *** Extract the Top level directory name  
*   
      CALL RZCDIR (PATHY, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 71  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Illegal'//    
     +  ' Path Name '//PATHY//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL RZCDIR (PATHY, 'R')  
      NCHAR  = LENOCC (PATHY)   
      NCHRT  = INDEX  (PATHY(3:NCHAR), '/') - 1 
      IF (NCHRT.LE.0) NCHRT = NCHAR - 2 
      TOPN   = PATHY(3:NCHRT+2) 
      IF (NCHRT.EQ.0) THEN  
        IQUEST(1) = 75  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : No top '//    
     +  'directory for '//PATHY//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
* *** Find the appropriate FZ file number   
*   
      LTOP   = LTOPDB   
      IOPP   = 0    
   15 IF (LTOP.NE.0) THEN   
        NCH    = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCH) 
        TOPNDI = TOPNDI(1:NCH)  
        IF (TOPN.EQ.TOPNDI) THEN    
          IF (IOPBDA.EQ.0) THEN 
            LUFZDF = IQ(KOFUDB+LTOP+MUPJFL) 
          ELSE  
            LUFZDF = IQ(KOFUDB+LTOP+MUPBAK) 
          ENDIF 
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)  
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)   
        ELSE    
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 15  
        ENDIF   
      ELSE  
        LUFZDF = 0  
        IOPS   = 0  
        IOUT   = 0  
      ENDIF 
      IF (IOUT.EQ.0.OR.IOPP.NE.0) IOPS = 0  
*   
* *** Partially fill up the header  
*   
      IF (LUFZDF.GT.0) THEN 
        NDOP   = 1  
        NCHR   = LENOCC (PATHY) 
        NWDP   = (NCHR + 3) / 4 
        NWDH   = NWDP + NDOP + NWKYDK + 5   
        IHEADF(MACTDF) = 1  
        IHEADF(MNKYDF) = NWKYDK 
        IHEADF(MOPTDF) = NDOP   
        IHEADF(MPATDF) = NWDP   
        CALL UCTOH (PATHY, IHEADF(NWKYDK+NDOP+MPREDF+1), 4, 4*NWDP) 
      ENDIF 
*   
* *** Start reading in records from the input file  
*   
      ISTR   = 0    
      ITIME  = 1    
      JBIAS  = 2    
   20 NOBJDS = 0    
      IOPKDA = 0    
      PACKDZ = .FALSE.  
      CALL RZCDIR (PATH, ' ')   
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      DO 25 IK = 1, NSAVM   
        ISTR   = ISTR + 1   
        IF (ISTR.LE.NKEYS) THEN 
          NOBJDS = NOBJDS + 1   
          KEYSDS(MSERDB,NOBJDS) = ISTR  
          IOKYDA(MSERDB) = 1    
          CALL DBKXIN (ITIME, IDISDB, LOBJDS(NOBJDS), LOBJDS(NOBJDS),   
     +                 JBIAS, NWKEY, KEYSDS(1,NOBJDS), IPREC)   
          IOKYDA(MSERDB) = 0    
          IF (IQUEST(1).NE.0)      GO TO 997    
          IF (JBIT(KEYSDS(MFLGDB,NOBJDS),JRZUDB).NE.0) THEN 
            IF (JBIT(KEYSDS(MFLGDB,NOBJDS),JASFDB).NE.0) THEN   
              CHOPS(NOBJDS) = '7RT' 
            ELSE    
              CHOPS(NOBJDS) = '7R'  
            ENDIF   
          ELSE  
            CALL DBRZIN (IDISDB, LSTRDL(2), 2, ISTR, ICYCL, PATH)   
            IF (IQUEST(1).NE.0) THEN    
              IER       = IQUEST(1) 
              CALL MZDROP (IDISDB, LSTRDL(2), 'L')  
              IQUEST(1) = IER   
              GO TO 997 
            ENDIF   
            ixx = iQ(KOFUDB+LSTRDL(2)+3)
            IF (IQ(KOFUDB+LSTRDL(2)+1).EQ.0) THEN   
              IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN  
                CHOPS(NOBJDS) = '7SU'   
              ELSE  
                CHOPS(NOBJDS) = '7U'    
              ENDIF 
            ELSE    
              PACKDZ = (JBIT(IXX,32).EQ.0)  
              IF (PACKDZ) THEN  
                IDTY   = IDBTYP (LSTRDL(2)) 
                IF (IDTY.EQ.3) THEN 
                  PRECDZ =  Q(KOFUDB+LSTRDL(2)+2)   
                ELSE    
                  PRECDZ = IQ(KOFUDB+LSTRDL(2)+2)   
                ENDIF   
                IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN    
                  CHOPS(NOBJDS) = '7ZS' 
                ELSE    
                  CHOPS(NOBJDS) = '7Z'  
                ENDIF   
              ELSE  
                IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN    
                  CHOPS(NOBJDS) = '7S'  
                ELSE    
                  CHOPS(NOBJDS) = '7'   
                ENDIF   
              ENDIF 
            ENDIF   
            CALL MZDROP (IDISDB, LSTRDL(2), 'L')    
          ENDIF 
        ENDIF   
   25 CONTINUE  
*   
* *** Set the current directory to the output directory 
*   
      CALL RZCDIR (PATHY, ' ')  
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB), 
     +                 NKEYDK*KST, KST) 
      IF (KPNT.NE.0) THEN   
        NK     = (KPNT - MPSRDB) / KST + 1  
      ELSE  
        NK     = NKEYDK 
      ENDIF 
      CALL DBKEYR (NK, NWKYDK, KEYO)    
      KOBJ   = KEYO(MOBJDB) 
      MXKP   = KEYO(MXKPDB) 
      NWKYS  = NWKYDK   
      CALL UCOPY_i (KEYO, KEYN, NWKYDK)   
*   
      CALL DBPATH (PATHX, NKEYDK)   
      CALL RZCDIR (PATHX, ' ')  
      IF (IQUEST(1).NE.0)          GO TO 991    
      NKEYDK = IQUEST(7)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
*   
* *** Get the Serial number of the last object inserted 
*   
      LOBJ   = KOBJ 
      IF (NKEYDK.GT.0) THEN 
        DO 30 IK = 1, NKEYDK    
          IP     = KOFSDB + LCDRDB + IKDRDB + (IK-1)*KST + MSERDB   
          IF (IQ(IP).GT.LOBJ) LOBJ = IQ(IP) 
   30   CONTINUE    
      ENDIF 
      NINS   = NKEYDK   
*   
* *** Loop over all the objects 
*   
      DO 50 IOBJ = 1, NOBJDS    
        LOBJ   = LOBJ + 1   
        NINS   = NINS + 1   
        CHOP0  = CHOPS(IOBJ)    
*   
*  **   Fill up Key vectors 1,2 
*   
        KEYSDS(1,IOBJ) = LOBJ   
        KEYSDS(MUPNDB,IOBJ) = 0 
*   
*  **   Write the sequential output if needed   
*   
        IF (LUFZDF.GT.0) THEN   
          NLEV   = 1    
          NCUR   = 5    
          IFORO  = 2    
          CHCUR(NLEV) = CFORM(IFORO)    
          IF (INDEX(CHOP0,'Z').NE.0) THEN   
            NLCUR(NLEV) = 4 
            IFORO  = 3  
            NCUR   = 1  
            NLEV   = NLEV + 1   
            CHCUR(NLEV) = CFORM(IFORO)
            fval = precdz
            iheadf(mpredf) = ival
          ELSE  
            IHEADF(MPREDF) = IPREC  
          ENDIF 
          DO 40 I = 1, NWKYDK   
            IFORM  = IOTYDK(I)  
            IF (IFORM.EQ.6) IFORM = 5   
            IF (IFORM.EQ.IFORO) THEN    
              NCUR   = NCUR + 1 
            ELSE    
              NLCUR(NLEV) = NCUR    
              IF (NLEV.GE.NLEVM) THEN   
                IQUEST(1) = 76  
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNTOP :'//    
     +          ' Cannot get IO descriptor '//PATHY//''')', IARGDB, 0)  
                GO TO 995   
              ENDIF 
              NLEV   = NLEV + 1 
              CHCUR(NLEV) = CFORM(IFORM)    
              NCUR   = 1    
              IFORO  = IFORM    
            ENDIF   
   40     CONTINUE  
          NLCUR(NLEV) = NCUR    
          WRITE (CHFRM, 2001) (NLCUR(I), CHCUR(I), I = 1, NLEV) 
          II     = 4 *NLEV  
          CHFRM = CHFRM(1:II)//' -H'    
          CALL MZIOCH (IOFMDF, NWFMDF, CHFRM(1:II+3))   
          CALL UCTOH (CHOP0, IHEADF(NWKYDK+MPREDF+1), 4, 4*NDOP)    
          CALL UCOPY_i (KEYSDS(1,IOBJ), IHEADF(MPREDF+1), NWKYDK) 
          CALL FZOUT (LUFZDF, IDISDB, LOBJDS(IOBJ), 1, 'L', IOFMDF, 
     +                NWDH, IHEADF) 
          IF (IQUEST(1).NE.0) THEN  
            IQUEST(1)  = 77 
            IQUEST(11) = IOBJ   
            IQUEST(12) = NOBJDS 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Err'//    
     +      'or in FZOUT while writing Data for '',2I12)', IQUEST(11),2)    
            GO TO 995   
          ENDIF 
        ENDIF   
*   
*  **   Make a different subdirectory if there are too many keys    
*   
        IF (NINS.GT.MXKP) THEN  
          CALL RZCDIR (PATHY, ' ')  
          PATHX  = ' '  
          IF (IQUEST(1).NE.0)      GO TO 991    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          NKEYDK = IQUEST(7)    
*   
*  **     Rename Keys 3 and 4 of the latest subdirectory    
*   
          IF (IOPS.NE.0) CALL RZLOCK ('DBNTOP') 
          CALL RZRENK (KEYO, KEYN)  
          IERR   = IQUEST(1)    
          IF (IOPS.NE.0) CALL RZFREE ('DBNTOP') 
          IF (IERR.NE.0) THEN   
            IQUEST(1) = 74  
            IF (IDEBDB.GT.0) THEN   
              CALL UCOPY_i (KEYO, IARGDB(1),        NSYSDK)   
              CALL UCOPY_i (KEYN, IARGDB(NSYSDK+1), NSYSDK)   
              CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Error in RZRENK '//  
     +             'while writing data for '//PATHY//''',/(10X,7I12))', 
     +             IARGDB, 2*NSYSDK)    
            ENDIF   
            GO TO 997   
          ENDIF 
*   
*  **     Make a different subdirectory if there are too many keys  
*   
          KEY7DK = KEYSDS(MITMDB,IOBJ)  
          CALL DBMDIP (PATHY, NWKYS, CHFOR, CTAGDK, MXKP)   
          IF (IQUEST(1).NE.0)      GO TO 997    
          CALL RZCDIR (PATHY, ' ')  
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB), 
     +                     NKEYDK*KST, KST) 
          IF (KPNT.NE.0) THEN   
            NK     = (KPNT - MPSRDB) / KST + 1  
          ELSE  
            NK     = NKEYDK 
          ENDIF 
          CALL DBKEYR (NK, NWKYDK, KEYO)    
          CALL DBPATH (PATHX, NKEYDK)   
          CALL RZCDIR (PATHX, ' ')  
          IF (IQUEST(1).NE.0)      GO TO 991    
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          NINS   = NKEYDK + 1   
          CALL UCOPY_i (KEYO, KEYN, NWKYDK)   
        ENDIF   
*   
        IDB    = IDBTYP (LOBJDS(IOBJ))  
        IF (IDB.EQ.2.OR.IDB.EQ.3) THEN  
          IOPTR  = 0    
        ELSE    
          IOPTR  = 1    
        ENDIF   
*   
        IF (IOPS.NE.0) CALL RZLOCK ('DBNTOP')   
        IF (JBIT(KEYSDS(MFLGDB,IOBJ),JRZUDB).NE.0. OR. IOPTR.NE.0) THEN 
*   
*  **     RZ mode output    
*   
          IF (JBIT(KEYSDS(MFLGDB,IOBJ),JASFDB).NE.0) THEN   
            CHOP   = 'S'    
          ELSE IF (JBIT(KEYSDS(MFLGDB,IOBJ),JRZUDB).NE.0) THEN  
            CHOP   = 'L'    
          ELSE  
            CHOP   = ' '    
          ENDIF 
*   
          IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')   
          CALL RZOUT (IDISDB, LOBJDS(IOBJ), KEYSDS(1,IOBJ), ICYCLE,CHOP)    
*   
        ELSE    
*   
*  **     Copy data to DB internal store    
*   
*  **     0 Data word : do not pack 
*   
          IF (IQ(KOFUDB+LOBJDS(IOBJ)-1).EQ.0 .OR. INDEX(CHOP0,'U').NE.0)    
     +                                                              THEN    
            IOPUDA = 1  
          ELSE  
            IOPUDA = 0  
          ENDIF 
          CALL DBFRUS (LOBJDS(IOBJ), LSTRDL(1), IPREC)  
          IF (IQUEST(1).NE.0)      GO TO 995    
*   
*  **     Compress the data if requested    
*   
          IF (IOPUDA.NE.0)  THEN    
            LREFDL(1) = LSTRDL(1)   
          ELSE  
            IF (INDEX(CHOP0,'S').NE.0) THEN 
              IOPSDA = 1    
            ELSE    
              IOPSDA = 0    
            ENDIF   
            IF (INDEX(CHOP0,'Z').NE.0) THEN 
              PACKDZ = .TRUE.   
            ELSE    
              PACKDZ = .FALSE.  
            ENDIF   
            NOLD   = NKEYDK 
            NKEYDK = NINS - 1   
            CALL DBCOMP (LSTRDL(1), LREFDL(1), KEYSDS(1,IOBJ))  
            NKEYDK = NOLD   
          ENDIF 
          IF (IQUEST(1).NE.0)      GO TO 995    
*   
*  **     Drop the uncompressed data    
*   
          IF (LREFDL(1).NE.LSTRDL(1)) CALL MZDROP (IDISDB,LSTRDL(1),'L')    
*   
*  **     Write on to disk  
*   
          IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')   
          CALL RZOUT (IDISDB, LREFDL(1), KEYSDS(1,IOBJ), ICYCLE, 'S')   
          IER    = IQUEST(1)    
          CALL MZDROP (IDISDB, LREFDL(1), 'L')  
          IQUEST(1) = IER   
        ENDIF   
*   
        IF (IOPS.NE.0) THEN 
          IER    = IQUEST(1)    
          CALL RZFREE ('DBNTOP')    
          IQUEST(1) = IER   
        ENDIF   
*   
        KEYN(MBVRDB) = MIN0 (KEYN(MBVRDB), KEYSDS(MBVRDB,IOBJ)) 
        KEYN(MEVRDB) = MAX0 (KEYN(MEVRDB), KEYSDS(MEVRDB,IOBJ)) 
        IF (IQUEST(1).NE.0)        GO TO 993    
        IF (IDEBDB.GT.1) THEN   
          CALL UCOPY_i (KEYSDS(1,IOBJ), KEYNDK, NWKYDK)   
          CALL DBUPTM (IARGDB(1), IARGDB(2), KEYNDK(MITMDB))    
          CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Data was inserted into'//    
     +         '   '//PATHY//''',/,10X,''on the '',I8,'' at '',I6,'' '//    
     +         'with Key-Vector '')', IARGDB, 2)    
          CALL DBKEYT   
          CALL DBPRKY (NWKYDK, KEYNDK, IOTYDK)  
        ENDIF   
   50 CONTINUE  
      IF (ISTR.GE.NKEYS)           GO TO 995    
      DO 60 IOBJ = 1, NOBJDS    
        IF (LOBJDS(IOBJ).NE.0) CALL MZDROP (IDISDB, LOBJDS(IOBJ), 'L')  
   60 CONTINUE  
*   
*  ** Rename Keys 3 and 4 of the latest subdirectory    
*   
        CALL RZCDIR (PATHY, ' ')    
        PATHX  = ' '    
        IF (IQUEST(1).NE.0)        GO TO 991    
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        NKEYDK = IQUEST(7)  
        IF (IOPS.NE.0) CALL RZLOCK ('DBNTOP')   
        CALL RZRENK (KEYO, KEYN)    
        IERR   = IQUEST(1)  
        IF (IOPS.NE.0) CALL RZFREE ('DBNTOP')   
        IF (IERR.NE.0) THEN 
          IQUEST(1) = 74    
          IF (IDEBDB.GT.0) THEN 
            CALL UCOPY_i (KEYO, IARGDB(1),        NSYSDK) 
            CALL UCOPY_i (KEYN, IARGDB(NSYSDK+1), NSYSDK) 
            CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Error in RZRENK '//    
     +           'while writing data for '//PATHY//''',/(10X,7I12))',   
     +           IARGDB, 2*NSYSDK)  
          ENDIF 
          GO TO 997 
        ENDIF   
      GO TO 20  
*   
* *** Error messages    
*   
  991 IQUEST(1) = 71    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Illegal '// 
     +   'Path Name '//PATHY//PATHX(1:8)//''')', IARGDB, 0) 
      GO TO 997 
*   
  993 IQUEST(1) = 73    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Error in '//    
     +   'RZOUT while writing Data for '//PATHY//PATHX(1:8)//''')', 
     +   IARGDB, 0) 
*   
  995 IER   = IQUEST(1) 
      IF (NINS.GT.0)  THEN  
        CALL RZCDIR (PATHY, ' ')    
        IF (IQUEST(1).NE.0) THEN    
          IF (IER.EQ.0) THEN    
            GO TO 991   
          ELSE  
            IQUEST(1) = IER 
          ENDIF 
        ELSE    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          NKEYDK = IQUEST(7)    
          IQUEST(1) = IER   
*   
*  **     Rename Keys 3 and 4 of the latest subdirectory    
*   
          IF (IER.EQ.0) THEN    
            IF (IOPS.NE.0) CALL RZLOCK ('DBNTOP')   
            CALL RZRENK (KEYO, KEYN)    
            IERR   = IQUEST(1)  
            IF (IOPS.NE.0) CALL RZFREE ('DBNTOP')   
            IF (IERR.NE.0) THEN 
              IQUEST(1) = 74    
              IF (IDEBDB.GT.0) THEN 
                CALL UCOPY_i (KEYO, IARGDB(1),        NSYSDK) 
                CALL UCOPY_i (KEYN, IARGDB(NSYSDK+1), NSYSDK) 
                CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Error in RZRENK '//    
     +               'while writing data for '//PATHY//''',/(10X,7I12))'    
     +,              IARGDB, 2*NSYSDK)  
              ENDIF 
            ENDIF   
          ENDIF 
        ENDIF   
      ENDIF 
*   
* *** Drop the stored banks 
*   
  997 IER    = IQUEST(1)    
      IF (NOBJDS.GT.0) THEN 
        DO 998 IOBJ = 1, NOBJDS 
          CALL MZDROP (IDISDB, LOBJDS(IOBJ), 'L')   
  998   CONTINUE    
        NOBJDS = 0  
        IQUEST(1) = IER 
      ENDIF 
*   
 2001 FORMAT (20(I2,A1,1X)) 
*                                                             END DBNTOP    
  999 END   
      SUBROUTINE DBOUT (PATHN, IVSTR, IVEND, LSUP, IPRVS, NKEXT, KEYXT, 
     +                  IPREC, CHOPT)   
*     ================================================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBOUT (PATHN, IVSTR, IVEND, LSUP, IPRVS, NKEXT, KEYXT,  *    
*                     IPREC, CHOPT)                                    *    
*                                                                      *    
*   Stores data from a ZEBRA bank to disk creating simultaneousely     *    
*   the directories if needed                                          *    
*   Restrictions : Only directories upto 9 keys can be created and     *    
*                  keys should be of type INTEGER                      *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     IVSTR    Start of validity period                                *    
*     IVEND    End of validity period                                  *    
*     LSUP     Address of bank in memory where data reside             *    
*     IPRVS    Version number of program used for creating the data    *    
*     NKEXT    Number of extra keys (Beyond key 5)                     *    
*     KEYXT    Vector of extra keys                                    *    
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *    
*              IPREC significant digits right to the decimal points; if*    
*              IPREC < 0, data are stored with IPREC insignificant     *    
*              digits left to the decimal point.)                      *    
*     CHOPT    Character string with any of the following characters   *    
*          F   Updates with a fully matched data object (in user keys) *    
*          N   Create new (sub)directory(ies)                          *    
*          P   Create partitioned subdirectories for the pathname      *    
*          R   Store with full RZ option (No compression to be made)   *    
*          S   Create stand alone (master) data                        *    
*          U   Store data uncompressed                                 *    
*          Z   Store only nonzero elements. An element is considered to*    
*              be zero if its absolute value is less than IPREC (real) *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 62 : Too many external keys with option N            *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      COMMON /DZPACK/ PRECDZ, PACKDZ    
      LOGICAL         PACKDZ    
*   
      DIMENSION       KEYXT(9), LSUP(9) 
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80 
*
      integer ival
      real fval
      equivalence (ival, fval)
*     ------------------------------------------------------------------    
*   
* *** Decode the character option   
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)   GO TO 999   
      PACKDZ = .FALSE.  
*   
      IF (IOPUDA.NE.0.AND.IOPZDA.NE.0)  THEN    
        IOPZDA = 0  
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBOUT : Warning '//    
     +  '- Z option is incompatible with U option - U option will be '//    
     +  'executed'')', IARGDB, 0)   
*   
      ELSE IF (IOPZDA.NE.0)  THEN   
        PACKDZ = .TRUE.
        ival = IPREC
        PRECDZ = fval
      ENDIF 
*   
      IF (IOPRDA.NE.0.AND.IOPNDA.NE.0)  THEN    
        IOPNDA = 0  
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBOUT : Warning '//    
     +  '- R option is incompatible with N option - R option will be '//    
     +  'executed'')', IARGDB, 0)   
      ENDIF 
*   
      IF (IOPNDA.NE.0.AND.NKEXT+5.GT.NINEDK)  THEN  
        IQUEST(1) = 62  
        IQUEST(11)= NKEXT   
        IQUEST(12)= NINEDK - 5  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBOUT : Too many'//    
     +  ' external keys '',I6,'' with option N - a maximum of '',I6'//  
     +  ','' permitted'')', IQUEST(11), 2)  
        GO TO 999   
      ENDIF 
*   
* *** Prepare the Key vector array  
*   
      CALL VZERO_i (KEYVDK, MXDMDK)   
      IF (NKEXT.GT.2) CALL UCOPY_i (KEYXT(3), KEYVDK(8), NKEXT-2) 
      KEYVDK(MBVRDB) = IVSTR    
      KEYVDK(MEVRDB) = IVEND    
      KEYVDK(MPVSDB) = IPRVS    
      IF (NKEXT.GE.0) THEN  
        NTKEY  = NKEXT + 5  
      ELSE  
        NTKEY  = NINEDK 
      ENDIF 
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Create new subdirectories if needed   
*   
      IF (IOPNDA.NE.0)  THEN    
        IF (IOPPDA.EQ.0)  THEN  
          CALL DBMDIR (PATH, NTKEY, CHFTDK, CHTGDK) 
        ELSE    
          KEY7DK = 0    
          CALL DBMDIP (PATH, NTKEY, CHFTDK, CHTGDK, MXKPDK) 
        ENDIF   
        IF (IQUEST(1).NE.0) GO TO 999   
      ENDIF 
*   
* *** Write out the data    
*   
      CALL DBKOUT (PATH, IDIVDB, LSUP(1), NTKEY, KEYVDK, IPREC) 
*                                                              END DBOUT    
  999 END   
      SUBROUTINE DBPKTM (IDATE, ITIME, IDATM)   
*     =======================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPKTM (IDATE, ITIME, IDATM*)                           *    
*                                                                      *    
*   Packs date and time into one word                                  *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IDATE    Date : 6 Decimal integer : YYMMDD                       *    
*     ITIME    Time : 4 Decimal integer : HHMM                         *    
*     IDATM*   Packed date-time                                        *    
*                                                                      *    
*   Called by user,   DBDELT, DBEFOR, DBENTB, DBINIT, DBMDIP, DBPRGD,  *    
*             DBCDIC, DBENFZ, DBKOUT, DBSDIR, DBSNAM, DBSPUR, DBUDIC,  *    
*             DBPLOB, DBACPL, DBAUXI, DBDCKH, DBDCKV                   *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXSEC=61, MXMIN=61, MXHOU=25, MXDAY=32, MXMON=13)    
      INTEGER         IDAYY(20), IDAYM(12,2)    
      SAVE            IDAYY, IDAYM  
      DATA            IDAYY / 366,  731, 1096, 1461, 1827, 2192, 2557,  
     1                       2922, 3288, 3653, 4018, 4383, 4749, 5114,  
     2                       5479, 5844, 6210, 6575, 6940, 7305/    
      DATA            IDAYM / 0,  31,  59,  90, 120, 151, 181, 212, 243,    
     1                      273, 304, 334,   0,  31,  60,  91, 121, 152,    
     2                      182, 213, 244, 274, 305, 335/   
*   
*     ------------------------------------------------------------------    
*   
      IMIN = MOD(ITIME,100) 
      IHOU = ITIME/100  
*   
      IDAY = MOD(IDATE,100) 
      IYEA = IDATE/100  
      IMON = MOD(IYEA,100)  
      IYEA = IYEA/100   
*   
      IDATM = IMIN  
      MAXX = MXMIN  
      IDATM = IDATM + MAXX*IHOU 
      MAXX = MAXX*MXHOU 
      IDATM = IDATM + MAXX*IDAY 
      MAXX = MAXX*MXDAY 
      IDATM = IDATM + MAXX*IMON 
      MAXX = MAXX*MXMON 
      IDATM = IDATM + MAXX*IYEA 
*                                                             END DBPKTM    
      END   
      SUBROUTINE DBPKTS (IDATE, ITIME, IDATM)   
*     =======================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPKTS (IDATE, ITIME, IDATM*)                           *    
*                                                                      *    
*   Packs date and time into one word                                  *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IDATE    Date : 6 Decimal integer : YYMMDD                       *    
*              (Only Year > 80 allowed)                                *    
*     ITIME    Time : 6 Decimal integer : HHMMSS                       *    
*     IDATM*   Packed date-time                                        *    
*                                                                      *    
*   Called by user,   DBINIT, DBCDIC, DBSNAM, DBUDIC, DBPLNT, DBPLOB,  *    
*             DBPLOV, DBPLTI, DBACPL, DBAUXI, DBDCKH, DBDCKV, DBVIEW   *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXSEC=61, MXMIN=61, MXHOU=25, MXDAY=32, MXMON=13)    
      INTEGER         IDAYY(20), IDAYM(12,2)    
      SAVE            IDAYY, IDAYM  
      DATA            IDAYY / 366,  731, 1096, 1461, 1827, 2192, 2557,  
     1                       2922, 3288, 3653, 4018, 4383, 4749, 5114,  
     2                       5479, 5844, 6210, 6575, 6940, 7305/    
      DATA            IDAYM / 0,  31,  59,  90, 120, 151, 181, 212, 243,    
     1                      273, 304, 334,   0,  31,  60,  91, 121, 152,    
     2                      182, 213, 244, 274, 305, 335/   
*   
*     ------------------------------------------------------------------    
*   
      ISEC = MOD(ITIME,100) 
      IHOU = ITIME/100  
      IMIN = MOD(IHOU,100)  
      IHOU = IHOU/100   
*   
      IDAY = MOD(IDATE,100) 
      IYEA = IDATE/100  
      IMON = MOD(IYEA,100)  
      IYEA = IYEA/100 - 80  
*   
      IDATM = ISEC  
      MAXX = MXSEC  
      IDATM = IDATM + MAXX*IMIN 
      MAXX = MAXX*MXMIN 
      IDATM = IDATM + MAXX*IHOU 
      MAXX = MAXX*MXHOU 
      IDATM = IDATM + MAXX*IDAY 
      MAXX = MAXX*MXDAY 
      IDATM = IDATM + MAXX*IMON 
      MAXX = MAXX*MXMON 
      IDATM = IDATM + MAXX*IYEA 
*                                                             END DBPKTS    
      END   
      SUBROUTINE DBPRGD (PATHN, IKEEP, CHOPT)   
*     =======================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPRGD (PATHN, IKEEP, CHOPT)                            *    
*                                                                      *    
*   Deletes partitions in a partitioned directory excpet the last      *    
*   (first) few ones.                                                  *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     IKEEP    Number of partitions to be preserved                    *    
*              (If -ve the last -IKEEP partitions deleted)             *    
*     CHOPT    Character string with any of the following characters   *    
*          B   Save in the special backup file; not in standard Journal*    
*                                                                      *    
*   Called by user,   DBFZUP, DBAUXI                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 69 : Input directory is not partitioned              *    
*               = 70 : Error in deleting a partition                   *    
*               = 71 : Illegal path name                               *    
*               = 73 : RZOUT fails to write on disk                    *    
*               = 74 : Error in RZRENK in updating key values for      *    
*                      partitioned data set                            *    
*               = 75 : Cannot find the Top directory name in pathname  *    
*               = 77 : FZOUT fails to write on to the sequential file  *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NSVMDS=50, NSAVDS=20, MXDMDS=100)    
      COMMON /DSAVBK/ NOBJDS, LOBJDS(NSVMDS), KEYSDS(MXDMDS,NSVMDS) 
*   
      DIMENSION       KEYO(MXDMDK), KEYN(MXDMDK)    
      CHARACTER       PATHY*80, PATH*80, PATHX*16, TOPN*16, PATHL*80    
      CHARACTER       PATHN*(*), CHOPT*(*)  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*

      dimension kdum(9)
*     ------------------------------------------------------------------    
*   
* *** Suppress blanks from the path name    
*   
      PATHL  = ' '  
      CALL DBOPTS (' ') 
      CALL UOPTC  (CHOPT, 'B', IOPBDA)  
      CALL DBSBLC (PATHN, PATH, NCHAR)  
      NKEEP  = IKEEP    
      KEY7   = KEY7DK   
      KEY7DK = 0    
      IF (NKEEP.EQ.0) NKEEP = 1 
      IF (KEY7.LE.0) THEN   
        CALL DATIME (IDATE, ITIME)  
        CALL DBPKTM (IDATE, ITIME, KEY7)    
      ENDIF 
*   
* *** Set the current directory for input path name 
*   
      PATHX  = ' '  
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 71  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Illeg'//  
     +  'al Path Name '//PATH//''')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      KST    = NWKYDK + 1   
      CALL RZCDIR (PATH, 'R')   
      NCHAR  = LENOCC (PATH)    
      CALL DBKEYT   
      IF (NKEYDK.NE.0)  THEN    
        IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)    
        IOPTP  = JBIT (IOPTP, JPRTDB)   
      ELSE  
        IOPTP  = 0  
      ENDIF 
      IF (IOPTP.EQ.0) THEN  
        IQUEST(1) = 69  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Directo'//    
     +  'ry '//PATH//' is not partitioned '')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
      IF (NKEYDK.LE.NKEEP.AND.NKEEP.GT.0) THEN  
        IQUEST(1) = 0   
        GO TO 999   
      ENDIF 
*   
* *** Extract the Top level directory name  
*   
      NCHRT  = INDEX  (PATH(3:NCHAR), '/') - 1  
      IF (NCHRT.LE.0) NCHRT = NCHAR - 2 
      TOPN   = PATH(3:NCHRT+2)  
      IF (NCHRT.EQ.0) THEN  
        IQUEST(1) = 75  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : No top '//    
     +  'directory for '//PATH//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
*   
* *** Find the appropriate FZ file number   
*   
      LTOP   = LTOPDB   
   10 IF (LTOP.NE.0) THEN   
        NCH    = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCH) 
        TOPNDI = TOPNDI(1:NCH)  
        IF (TOPN.EQ.TOPNDI) THEN    
          IF (IOPBDA.EQ.0) THEN 
            LUFZDF = IQ(KOFUDB+LTOP+MUPJFL) 
          ELSE  
            LUFZDF = IQ(KOFUDB+LTOP+MUPBAK) 
          ENDIF 
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)  
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)   
        ELSE    
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 10  
        ENDIF   
      ELSE  
        LUFZDF = 0  
        IOPS   = 0  
        IOUT   = 0  
      ENDIF 
      IF (IOUT.EQ.0) IOPS = 0   
*   
* *** Partially fill up the header  
*   
      IF (LUFZDF.GT.0) THEN 
        IF (IOPBDA.EQ.0) THEN   
          NDOP   = 0    
        ELSE    
          NDOP   = 1    
        ENDIF   
        NWDP   = (NCHAR + 3) / 4    
        NWDH   = NDOP + NWDP + 6    
        IHEADF(MACTDF) = 8  
        IHEADF(MNKYDF) = 0  
        IHEADF(MOPTDF) = NDOP   
        IHEADF(MPATDF) = NWDP   
        IHEADF(MDELDF) = KEY7   
        IHEADF(MKEPDF) = NKEEP  
        IF (NDOP.EQ.1) CALL UCTOH ('B   ', IHEADF(MKEPDF+1), 4, 4)  
        CALL UCTOH (PATH, IHEADF(MKEPDF+NDOP+1), 4, 4*NWDP) 
        CALL MZIOCH (IOFMDF, NWFMDF, '6I -H')   
*   
*  **   Now write on the sequential file    
*   
        CALL FZOUT (LUFZDF, IDISDB, 0, 1, 'Z', IOFMDF, NWDH, IHEADF)    
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1)  = 77   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Error'//    
     +    ' in FZOUT while writing Data for '//PATH//''')', IARGDB, 0)  
          GO TO 999 
        ENDIF   
      ENDIF 
*   
* *** Check if the directory updated after KEY7 
*   
      NKEYS  = NKEYDK   
      CALL DBPATH (PATHX, NKEYS)    
      PATHY  = PATH(1:NCHAR)//'/'//PATHX    
      CALL RZCDIR (PATHY, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 71  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Illeg'//  
     +  'al Path Name '//PATHY//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      IF (IQ(KOFSDB+LCDRDB+IKDRDB+(NKEYDK-1)*KST+MITMDB).GT.KEY7)   
     +                                                       GO TO 999  
*   
* *** Lock the directory in shared mode 
*   
      IF (IOPS.NE.0) THEN   
        PATHL  = PATH(1:NCHAR)  
        CALL RZCDIR (PATHL, ' ')    
        CALL RZLOCK ('DBPRGD')  
      ENDIF 
      IF (NKEEP.LT.0)                                        GO TO 55   
*   
* *** Now delete all objects in the first few subdirectories    
*   
      DO 15 JKK = NKEEP+1, NKEYS    
        IKK     = JKK - NKEEP   
        CALL DBPATH (PATHX, IKK)    
        PATHY   = PATH(1:NCHAR)//'/'//PATHX 
        CALL RZCDIR (PATHY, ' ')    
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1) = 71    
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Illeg'//    
     +    'al Path Name '//PATHY//''')', IARGDB, 0) 
          GO TO 998 
        ENDIF   
        NKEYDK = IQUEST(7)  
        IF (NKEYDK.GT.0) CALL RZDELK (KDUM, ICDUM, 'K') 
   15 CONTINUE  
*   
* *** Now transfer data from the last parttitions to the first  
* *** NKEEP partitions  
*   
      NOBJDS = 0    
      JBIAS  = 2    
      DO 50 JKK = 1, NKEEP  
        IKK    = NKEYS - NKEEP + JKK    
        ISTR   = 0  
*   
*  **   Set the current directory to the input directory    
*   
   20   CALL DBPATH (PATHX, IKK)    
        PATHY  = PATH(1:NCHAR)//'/'//PATHX  
        CALL RZCDIR (PATHY, ' ')    
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1) = 71    
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Illeg'//    
     +    'al Path Name '//PATHY//''')', IARGDB, 0) 
          GO TO 996 
        ENDIF   
        NKEYDK = IQUEST(7)  
        NWKYDK = IQUEST(8)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        DO 25 IK = 1, NSVMDS    
          ISTR   = ISTR + 1 
          IF (ISTR.LE.NKEYDK) THEN  
            NOBJDS = NOBJDS + 1 
            KEYSDS(MSERDB,NOBJDS) = ISTR    
            ICYCL  = 9999   
            CALL DBRZIN (IDISDB, LOBJDS(NOBJDS), JBIAS, ISTR, ICYCL,    
     +                   PATHY) 
            IF (IQUEST(1).NE.0)                              GO TO 996  
            CALL DBKEYR (ISTR, NWKYDK, KEYSDS(1,NOBJDS))    
          ENDIF 
   25   CONTINUE    
        IF (NOBJDS.EQ.0)                                     GO TO 40   
*   
*  **   Set the current directory to the output directory   
*   
        CALL DBPATH (PATHX, JKK)    
        PATHY  = PATH(1:NCHAR)//'/'//PATHX  
        CALL RZCDIR (PATHY, ' ')    
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1) = 71    
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Illeg'//    
     +    'al Path Name '//PATHY//''')', IARGDB, 0) 
          GO TO 996 
        ENDIF   
        NWKYDK = IQUEST(8)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        DO 30 IK = 1, NOBJDS    
          IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')   
          CALL RZOUT (IDISDB, LOBJDS(IK), KEYSDS(1,IK), ICYCLE, 'L')    
          IF (IQUEST(1).NE.0) THEN  
            IQUEST(1) = 73  
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Err'//    
     +      'or in RZOUT while writing Data for '//PATHY//''')',    
     +      IARGDB, 0)  
            GO TO 996   
          ENDIF 
          IF (IDEBDB.GT.1) THEN 
            CALL UCOPY_i (KEYSDS(1,IK), KEYNDK, NWKYDK)   
            CALL DBUPTM (IARGDB(1), IARGDB(2), KEYNDK(MITMDB))  
            CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Data was inserted in'//    
     +           'to   '//PATHY//''',/,10X,''on the '',I8,'' at '',I6'//    
     +           ','' with Key-Vector '')', IARGDB, 2)  
            CALL DBPRKY (NWKYDK, KEYNDK, IOTYDK)    
          ENDIF 
   30   CONTINUE    
        DO 35 IK = 1, NOBJDS    
          IF (LOBJDS(IK).NE.0) CALL MZDROP (IDISDB, LOBJDS(IK), 'L')    
   35   CONTINUE    
        NOBJDS = 0  
        IF (ISTR.LT.NKEYDK)                                  GO TO 20   
*   
*  **   Now update the keys of the main directory   
*   
   40   CALL RZCDIR (PATH, ' ') 
        NKEYDK = IQUEST(7)  
        NWKYDK = IQUEST(8)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        KPNT   = IUHUNT (JKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),  
     +                   NKEYDK*KST, KST)   
        IF (KPNT.NE.0) THEN 
          NK     = (KPNT - MPSRDB) / KST + 1    
        ELSE    
          NK     = JKK  
        ENDIF   
        CALL DBKEYR (NK, NWKYDK, KEYO)  
        KPNT   = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),  
     +                   NKEYDK*KST, KST)   
        IF (KPNT.NE.0) THEN 
          NK     = (KPNT - MPSRDB) / KST + 1    
        ELSE    
          NK     = IKK  
        ENDIF   
        CALL DBKEYR (NK, NWKYDK, KEYN)  
        KEYN(MPSRDB) = KEYO(MPSRDB) 
        CALL RZRENK (KEYO, KEYN)    
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1) = 74    
          IF (IDEBDB.GT.0) THEN 
            CALL UCOPY_i  (KEYO, IARGDB(1),        NSYSDK)    
            CALL UCOPY_i  (KEYN, IARGDB(NSYSDK+1), NSYSDK)    
            CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Error in RZRENK whil'//    
     +           'e writing data for '//PATHY//''',/(10X,7I12))',   
     +           IARGDB, 2*NSYSDK)  
          ENDIF 
          GO TO 996 
        ENDIF   
   50 CONTINUE  
*   
* *** Now delete the keys and subdirectories beyond NKEEP   
*   
   55 IF (NKEEP.GT.0) THEN  
        NK1    = NKEEP + 1  
      ELSE  
        NK1    = NKEYS + NKEEP + 1  
        IF (NK1.LT.2) NK1  = 2  
        NOBJDS = 0  
      ENDIF 
      DO 60 JKK = NK1, NKEYS    
        IKK    = NKEYS + NK1 - JKK  
        CALL RZCDIR (PATH, ' ') 
        NKEYDK = IQUEST(7)  
        NWKYDK = IQUEST(8)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        KPNT   = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),  
     +                   NKEYDK*KST, KST)   
        IF (KPNT.NE.0) THEN 
          NK     = (KPNT - MPSRDB) / KST + 1    
        ELSE    
          NK     = IKK  
        ENDIF   
        CALL DBKEYR (NK, NWKYDK, KEYN)  
        CALL RZDELK (KEYN, ICDUM, 'C')  
        CALL DBPATH (PATHX, IKK)    
        CALL RZDELT (PATHX) 
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1) = 70    
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Error'//    
     +    ' in deleting partition '//PATHX(1:8)//' in '//PATH//''')',   
     +    IARGDB, 0)    
          GO TO 996 
        ENDIF   
   60 CONTINUE  
*   
      IQUEST(1) = 0 
*   
* *** Drop the stored banks 
*   
  996 IER    = IQUEST(1)    
      IF (NOBJDS.GT.0) THEN 
        DO 997 IK = 1, NOBJDS   
          IF (LOBJDS(IK).NE.0) CALL MZDROP (IDISDB, LOBJDS(IK), 'L')    
  997   CONTINUE    
        IQUEST(1) = IER 
      ENDIF 
  998 IF (PATHL.NE.' ') THEN    
        IER    = IQUEST(1)  
        CALL RZCDIR (PATHL, ' ')    
        CALL RZFREE ('DBPRGD')  
        IQUEST(1) = IER 
      ENDIF 
*                                                             END DBPRGD    
  999 END   
      SUBROUTINE DBPRIN (PATHN, CHOPT)  
*     ================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPRIN (PATHN, CHOPT)                                   *    
*                                                                      *    
*   Prints all objects attached to the directory PATHN                 *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     CHOPT    Character string with any of the following characters   *    
*          I   Print the insertion time as well                        *    
*          K   Print only the keys                                     *    
*          D   Print all data as well as the keys                      *    
*                                                                      *    
*   Called by user,   DBAUXI                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =101 : Illegal path name                               *    
*               =102 : No key or data for the path name                *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      CHARACTER       PATH*80, PATHX*16, PATHY*80, PATHN*(*), CHOPT*(*) 
      CHARACTER       CFMT*130  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
* *** Decode the character option   
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)       GO TO 999   
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Set the current directory 
*   
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0)       GO TO 991   
      CALL RZCDIR (PATHY, 'R')  
      NCHAR  = INDEX (PATHY, ' ') - 1   
      IF (NCHAR.LT.1.OR.NCHAR.GT.MAXLDB) NCHAR = MAXLDB 
      NKEYDK = IQUEST(7)    
*   
* *** Check the number of keys  
*   
      IF (NKEYDK.EQ.0)          GO TO 992   
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKYTG   
*   
* *** Check if it is partitioned    
*   
      KEY6   = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)  
      IOPTP  = JBIT (KEY6, JPRTDB)  
*   
*  ** Print keys    
*   
      IF (IOPKDA.NE.0) IOPDDA = 0   
      IF (IOPKDA.NE.0 .OR. IOPDDA.NE.0)  THEN   
*   
        IF (IOPKDA.NE.0)  THEN  
          CALL DBPRNT (LPRTDB, '(/,''  Keys with Insertion Time in Di'//    
     +         'rectory '//PATH//''')', IARGDB, 0)  
        ELSE IF (IOPDDA.NE.0)  THEN 
          CALL DBPRNT (LPRTDB, '(/,''  Keys and Data with Insertion T'//    
     +         'ime in Directory '//PATH//''')', IARGDB, 0) 
        ENDIF   
        CFMT(1:5)     = '(7X,'''    
        CFMT(129:130) = ''')'   
        DO 10 I1 = 1, NWKYDK, 10    
          I2     = I1 + 9   
          IF (I2.GT.NWKYDK) I2 = NWKYDK 
          CFMT(6:128) = ' ' 
          IFLD   = 6    
          DO 5 I = I1, I2   
            CFMT(IFLD:IFLD+7) = CTAGDK(I)   
            IFLD   = IFLD + 12  
    5     CONTINUE  
          CALL DBPRNT (LPRTDB, CFMT, IARGDB, 0) 
   10   CONTINUE    
        CALL DBPRNT (LPRTDB, '(//)', IARGDB, 0) 
*   
        IF (IOPTP.EQ.0)  THEN   
          CALL DBPRDT   
          IF (IQUEST(1).NE.0)   GO TO 999   
        ELSE    
*   
*  **     Loop over subdirectories  
*   
          NKEYS  = NKEYDK   
          DO 20 IK = 1, NKEYS   
            CALL DBPATH (PATHX, IK) 
            PATH   = PATHY(1:NCHAR)//'/'//PATHX 
            CALL RZCDIR (PATH, ' ') 
            IF (IQUEST(1).NE.0) GO TO 991   
            NKEYDK = IQUEST(7)  
            NWKYDK = IQUEST(8)  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
            CALL DBKEYT 
            CALL DBPRDT 
            IF (IQUEST(1).NE.0) GO TO 999   
   20     CONTINUE  
        ENDIF   
*   
      ENDIF 
      IQUEST(1) = 0 
      GO TO 999 
*   
* *** Error messages    
*   
  991 IQUEST(1) = 101   
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRIN : Illegal '// 
     +   'Path Name '//PATH//''')', IARGDB, 0)  
      GO TO 999 
*   
  992 IQUEST(1) = 102   
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRIN : No key or'//    
     +   ' data for Path Name '//PATH//''')', IARGDB, 0)    
      GO TO 999 
*                                                             END DBPRIN    
  999 END   
      SUBROUTINE DBPURG (PATHN, KYDAT, KYTIM, CHOPT)    
*     ==============================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPURG (PATHN, KYDAT, KYTIM, CHOPT)                     *    
*                                                                      *    
*   Purges/Deletes objects in a directory PATHN                        *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     KYDAT    Key element number (for option K in CHOPT) or           *    
*              Minimum value of Key 1 to be deleted (for option S)     *    
*     KYTIM    Cutoff value for the key (for option K) or              *    
*              Maximum value of Key 1 to be deleted (for option S)     *    
*     CHOPT    Character string with any of the following characters   *    
*          A   Deletes all data objects                                *    
*          B   Save in the special backup file; not in standard Journal*    
*          K   Deletes all data objects for which KEY(KYDAT) .lt. KYTIM*    
*          L   Deletes all but the last (one with highest KEY(1) value)*    
*              data objects                                            *    
*          P   Deletes all data objects with identical start and end   *    
*              validity but those having the highest Program Version   *    
*              number (i.e., KEY(5) value)                             *    
*          S   Deletes all data objects with Serial number (KEY(1)) in *    
*              the range KYDAT-KYTIM (the terminal points included)    *    
*                                                                      *    
*   Called by user,   DBFZUP, DBAUXI                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =111 : Illegal path name                               *    
*               =112 : No key or data for the path name                *    
*                                                                      *    
*     If IQUEST(1) =0, IQUEST(2) carries information on number of      *    
*     data objects deleted in the disk                                 *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       PATHN*(*), CHOPT*(*), PATH*80, PATHX*16, PATHY*80 
      CHARACTER       PATHZ*80  
      INTEGER         KEYS(NSYSDK)  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*

      dimension kdum(9)
*     ------------------------------------------------------------------    
*   
      KEY7   = KEY7DK   
      KEY7DK = 0    
      NDEL   = 0    
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)                         GO TO 999 
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Set the current directory 
*   
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0)                         GO TO 991 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKEYT   
      CALL RZCDIR (PATH, 'R')   
      NCHAR  = INDEX (PATH, ' ') - 1    
      IF (NCHAR.LT.1.OR.NCHAR.GT.MAXLDB) NCHAR = MAXLDB 
      IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)  
      IOPTP  = JBIT (IOPTP, JPRTDB) 
*   
* *** Check the number of keys  
*   
      IF (NKEYDK.EQ.0)                            GO TO 992 
*   
* *** Save the command in the journal file  
*   
      CALL VZERO_i (KEYS, NSYSDK) 
      KEYS(MSERDB) = KYDAT  
      KEYS(MUPNDB) = KYTIM  
      KEY7DK  = KEY7    
      CALL DBSPUR (PATH, NWKYDK, -1, KEYS, CHOPT, IOPP, IOPS)   
      KEY7DK  = 0   
      IF (IQUEST(1).NE.0)                         GO TO 999 
      IF (IOPP.NE.0)                              GO TO 999 
*   
      IF (IOPADA.NE.0)  THEN    
*   
* ***   Delete all keys 
*   
        IF (IOPTP.EQ.0)  THEN   
          IF (KEY7.LE.0) THEN   
            IF (IOPS.NE.0) CALL RZLOCK ('DBPURG')   
            CALL RZDELK (KDUM, ICDUM, 'K')  
            IF (IOPS.NE.0) CALL RZFREE ('DBPURG')   
            NDEL   = NKEYDK 
          ELSE  
            CALL VZERO_i (IPURDK, NKEYDK) 
            IPNT   = KOFSDB + LCDRDB + IKDRDB   
            ISTP   = NWKYDK + 1 
            NKEEP  = 0  
            DO 10 JK = 1, NKEYDK    
              IP     = IPNT + (JK - 1) * ISTP   
              KEY1DK(JK) = IQ(IP+MPSRDB)    
              IF (IQ(IP+MITMDB).GT.KEY7) THEN   
                IPURDK(JK) = 2  
                NKEEP  = NKEEP +1   
              ENDIF 
   10       CONTINUE    
            IF (NKEEP.GT.0) THEN    
              CALL DBDELK (IOPS)    
              NDEL   = IQUEST(2)    
            ELSE    
              IF (IOPS.NE.0) CALL RZLOCK ('DBPURG') 
              CALL RZDELK (KDUM, ICDUM, 'K')    
              IF (IOPS.NE.0) CALL RZFREE ('DBPURG') 
              NDEL   = NKEYDK   
            ENDIF   
          ENDIF 
        ELSE    
          NKEYS  = NKEYDK   
          DO 20 IK = 1, NKEYS   
            CALL DBPATH (PATHX, IK) 
            PATHY  = PATH(1:NCHAR)//'/'//PATHX  
            CALL RZCDIR (PATHY, ' ')    
            IF (IQUEST(1).NE.0)  THEN   
              IQUEST(1) = 111   
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : '// 
     +        'Illegal Path Name '//PATHY//''')', IARGDB, 0)    
              GO TO 999 
            ENDIF   
            NKEYDK = IQUEST(7)  
            IF (NKEYDK.GT.0)  THEN  
              IF (KEY7.LE.0) THEN   
                IF (IOPS.NE.0) CALL RZLOCK ('DBPURG')   
                CALL RZDELK (KDUM, ICDUM, 'K')  
                IF (IOPS.NE.0) CALL RZFREE ('DBPURG')   
                NDEL   = NDEL + NKEYDK  
              ELSE  
                NWKYDK = IQUEST(8)  
                LCDRDB = IQUEST(11) 
                IKDRDB = IQUEST(13) 
                IPNT   = KOFSDB + LCDRDB + IKDRDB   
                ISTP   = NWKYDK + 1 
                CALL VZERO_i (IPURDK, NKEYDK) 
                NKEEP  = 0  
                DO 15 JK = 1, NKEYDK    
                  IP     = IPNT + (JK - 1) * ISTP   
                  KEY1DK(JK) = IQ(IP+MPSRDB)    
                  IF (IQ(IP+MITMDB).GT.KEY7) THEN   
                    IPURDK(JK) = 2  
                    NKEEP  = NKEEP +1   
                  ENDIF 
   15           CONTINUE    
                IF (NKEEP.GT.0) THEN    
                  CALL DBDELK (IOPS)    
                  NDEL   = NDEL + IQUEST(2) 
                ELSE    
                  IF (IOPS.NE.0) CALL RZLOCK ('DBPURG') 
                  CALL RZDELK (KDUM, ICDUM, 'K')    
                  IF (IOPS.NE.0) CALL RZFREE ('DBPURG') 
                  NDEL   = NDEL + NKEYDK    
                ENDIF   
              ENDIF 
            ENDIF   
   20     CONTINUE  
        ENDIF   
*   
      ELSE IF (IOPLDA.NE.0)  THEN   
*   
* ***   Delete all but last keys (except those another key may depend   
*  **   on) Highest number of KEY(1)    
*   
        IF (IOPTP.EQ.0) THEN    
          CALL VZERO_i (IPURDK, NKEYDK)   
          NO1    = 0    
          IPNT   = KOFSDB + LCDRDB + IKDRDB 
          ISTP   = NWKYDK + 1   
          DO 25 IK = 1, NKEYDK  
            IP     = IPNT + (IK - 1) * ISTP 
            KEY1DK(IK) = IQ(IP+MSERDB)  
            IF (KEY7.LE.0) THEN 
              IF (KEY1DK(IK).GT.NO1) NO1 = KEY1DK(IK)   
            ELSE    
              IF (IQ(IP+MITMDB).GT.KEY7) THEN   
                IPURDK(IK) = 2  
              ELSE  
                IF (KEY1DK(IK).GT.NO1) NO1 = KEY1DK(IK) 
              ENDIF 
            ENDIF   
   25     CONTINUE  
*   
          II     = IUCOMP (NO1, KEY1DK, NKEYDK) 
          IF (II.GT.0) IPURDK(II) = 2   
          CALL DBDELK (IOPS)    
          NDEL   = IQUEST(2)    
*   
        ELSE    
*   
          NKEYS  = NKEYDK   
          IFLG   = 0    
          DO 35 JK1 = 1, NKEYS  
            JK     = NKEYS + 1 - JK1    
            CALL DBPATH (PATHX, JK) 
            PATHY  = PATH(1:NCHAR)//'/'//PATHX  
            CALL RZCDIR (PATHY, ' ')    
            IF (IQUEST(1).NE.0)  THEN   
              IQUEST(1) = 111   
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : '// 
     +        'Illegal Path Name '//PATHY//''')', IARGDB, 0)    
              GO TO 999 
            ENDIF   
            NKEYDK = IQUEST(7)  
            IF (NKEYDK.GT.0.AND.IFLG.EQ.0)  THEN    
              NWKYDK = IQUEST(8)    
              LCDRDB = IQUEST(11)   
              IKDRDB = IQUEST(13)   
              IPNT   = KOFSDB + LCDRDB + IKDRDB 
              ISTP   = NWKYDK + 1   
*   
              CALL VZERO_i (IPURDK, NKEYDK)   
              NO1    = 0    
              DO 30 IK = 1, NKEYDK  
                IP     = IPNT + (IK - 1) * ISTP 
                KEY1DK(IK) = IQ(IP+MSERDB)  
                IF (KEY7.LE.0) THEN 
                  IF (KEY1DK(IK).GT.NO1) NO1 = KEY1DK(IK)   
                ELSE    
                  IF (IQ(IP+MITMDB).GT.KEY7) THEN   
                    IPURDK(IK) = 2  
                  ELSE  
                    IF (KEY1DK(IK).GT.NO1) NO1 = KEY1DK(IK) 
                  ENDIF 
                ENDIF   
   30         CONTINUE  
*   
              II     = IUCOMP (NO1, KEY1DK, NKEYDK) 
              IF (II.GT.0) THEN 
                IPURDK(II) = 2  
                IFLG   = 1  
              ENDIF 
              CALL DBDELK (IOPS)    
              NDEL   = NDEL + IQUEST(2) 
*   
            ELSE IF (NKEYDK.GT.0) THEN  
*   
*  *          Delete all keys in the remaining subdirectories   
*   
              IF (IOPS.NE.0) CALL RZLOCK ('DBPURG') 
              CALL RZDELK (KDUM, ICDUM, 'K')    
              IF (IOPS.NE.0) CALL RZFREE ('DBPURG') 
              NDEL   = NDEL + NKEYDK    
*   
            ENDIF   
   35     CONTINUE  
        ENDIF   
*   
      ELSE IF (IOPPDA.NE.0)  THEN   
*   
* ***   Delete all objects with identical start and end validity but    
* ***   those having the highest program version #, i.e. the highest    
* ***   KEY(5)  
*   
        IF (IOPTP.EQ.0)  THEN   
          CALL VZERO_i (IPURDK, NKEYDK)   
*   
*  **     Label by '2' the object of the highest program version #  
*   
          DO 50 IK = 1, NKEYDK  
            IPURDK(IK) = 2  
            CALL DBKEYR (IK, NWKYDK, KEYVDK)    
            KEY1DK(IK) = KEYVDK(MSERDB) 
            IF (KEY7.GT.0) THEN 
              IF (KEYVDK(MITMDB).GT.KEY7)         GO TO 50  
            ENDIF   
            DO 45 JK = 1, NKEYDK    
              IF (IK.EQ.JK.OR.IPURDK(JK).EQ.-1)   GO TO 45  
              CALL DBKEYR (JK, NWKYDK, KEYNDK)  
              DO 40 K = 1, NWKYDK   
                IF (IOKYDA(K).NE.0.AND.KEYNDK(K).NE.KEYVDK(K))  
     +                                            GO TO 45  
   40         CONTINUE  
              IF (KEYNDK(MPVSDB).GT.KEYVDK(MPVSDB))  THEN   
                IPURDK(IK) = -1 
                GO TO 50    
              ENDIF 
   45       CONTINUE    
   50     CONTINUE  
          CALL DBDELK (IOPS)    
          NDEL   = IQUEST(2)    
*   
        ELSE    
*   
          NKEYS  = NKEYDK   
          DO 70 JK2 = 1, NKEYS  
            JK1    = NKEYS + 1 - JK2    
            CALL DBPATH (PATHX, JK1)    
            PATHY  = PATH(1:NCHAR)//'/'//PATHX  
            CALL RZCDIR (PATHY, ' ')    
            IF (IQUEST(1).NE.0)  THEN   
              IQUEST(1) = 111   
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : '// 
     +        'Illegal Path Name '//PATHY//''')', IARGDB, 0)    
              GO TO 999 
            ENDIF   
            NKEYDK = IQUEST(7)  
            IF (NKEYDK.LE.0)                      GO TO 70  
            NWKYDK = IQUEST(8)  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
*   
            CALL VZERO_i (IPURDK, NKEYDK) 
*   
*  **       Label by '2' the object of the highest program version #    
*   
            DO 65 IK = 1, NKEYDK    
              IPURDK(IK) = 2    
              CALL DBKEYR (IK, NWKYDK, KEYVDK)  
              KEY1DK(IK) = KEYVDK(MSERDB)   
              IF (KEY7.GT.0) THEN   
                IF (KEYVDK(MITMDB).GT.KEY7)       GO TO 65  
              ENDIF 
              DO 60 JK = 1, NKEYDK  
                IF (IK.EQ.JK.OR.IPURDK(JK).EQ.-1) GO TO 60  
                CALL DBKEYR (JK, NWKYDK, KEYNDK)    
                DO 55 K = 1, NWKYDK 
                  IF (IOKYDA(K).NE.0.AND.KEYNDK(K).NE.KEYVDK(K))    
     +                                            GO TO 60  
   55           CONTINUE    
                IF (KEYNDK(MPVSDB).GT.KEYVDK(MPVSDB))  THEN 
                  IPURDK(IK) = -1   
                  GO TO 65  
                ENDIF   
   60         CONTINUE  
   65       CONTINUE    
            CALL DBDELK (IOPS)  
            NDEL   = NDEL + IQUEST(2)   
   70     CONTINUE  
*   
*  *      Now delete in one subdirectory from results of other  
*   
          JK2    = NKEYS + 1    
   75     IF (JK2.GT.2)  THEN   
            JK2    = JK2 - 1    
            CALL DBPATH (PATHX, JK2)    
            PATHZ  = PATH(1:NCHAR)//'/'//PATHX  
            CALL RZCDIR (PATHZ, ' ')    
            IF (IQUEST(1).NE.0)  THEN   
              IQUEST(1) = 111   
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : '// 
     +        'Illegal Path Name '//PATHZ//''')', IARGDB, 0)    
              GO TO 999 
            ENDIF   
            NKEY2  = IQUEST(7)  
            IF (NKEY2.EQ.0)                       GO TO 75  
            NWKYDK = IQUEST(8)  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
*   
*  *        Get the master object names in the master subdirectory  
*   
            CALL VZERO_i (INDKDK, NKEY2)  
            DO 90 IK = 1, NKEY2 
              INDKDK(IK) = 2    
              CALL DBKEYR (IK, NWKYDK, KEYVDK)  
              IF (KEY7.GT.0) THEN   
                IF (KEYVDK(MITMDB).GT.KEY7)       GO TO 90  
              ENDIF 
              DO 85 JK = 1, NKEY2   
                IF (IK.EQ.JK.OR.INDKDK(JK).EQ.1)  GO TO 85  
                CALL DBKEYR (JK, NWKYDK, KEYNDK)    
                DO 80 K = 1, NWKYDK 
                  IF (IOKYDA(K).NE.0.AND.KEYVDK(K).NE.KEYNDK(K))    
     +                                            GO TO 85  
   80           CONTINUE    
                IF (KEYNDK(MPVSDB).GT.KEYVDK(MPVSDB))  THEN 
                  INDKDK(IK) = 1    
                  GO TO 90  
                ENDIF   
   85         CONTINUE  
   90       CONTINUE    
            II     = IUCOMP (2, INDKDK, NKEY2)  
            IF (II.EQ.0)                          GO TO 75  
            I1     = 1  
*   
*  *        Loop over slave subdirectories  
*   
            DO 115 JK3 = 1, JK2-1   
              JK1    = JK2 - JK3    
              CALL DBPATH (PATHX, JK1)  
              PATHY  = PATH(1:NCHAR)//'/'//PATHX    
*   
              CALL RZCDIR (PATHY, ' ')  
              IF (IQUEST(1).NE.0)  THEN 
                IQUEST(1) = 111 
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG :'//    
     +          ' Illegal Path Name '//PATHY//''')', IARGDB, 0) 
                GO TO 999   
              ENDIF 
              LCDRDB = IQUEST(11)   
              IKDRDB = IQUEST(13)   
              NKEYDK = IQUEST(7)    
              IF (NKEYDK.EQ.0)                    GO TO 115 
*   
              DO 95 IK = 1, NKEYDK  
                IPURDK(IK) = 2  
   95         CONTINUE  
*   
  100         IF (I1.LE.NKEY2) THEN 
                NN     = NKEY2 - I1 + 1 
                II     = IUCOMP (2, INDKDK(I1), NN) 
                IF (II.GT.0) THEN   
                  II     = II + I1 - 1  
                  I1     = II + 1   
                  CALL RZCDIR (PATHZ, ' ')  
                  IF (IQUEST(1).NE.0)  THEN 
                    IQUEST(1) = 111 
                    IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPU'//    
     +              'RG : Illegal Path Name '//PATHZ//''')', IARGDB, 0) 
                    GO TO 999   
                  ENDIF 
                  LCDRDB = IQUEST(11)   
                  IKDRDB = IQUEST(13)   
                  CALL DBKEYR (II, NWKYDK, KEYVDK)  
                  IF (KEY7.GT.0) THEN   
                    IF (KEYVDK(MITMDB).GT.KEY7)   GO TO 100 
                  ENDIF 
*   
                  CALL RZCDIR (PATHY, ' ')  
                  IF (IQUEST(1).NE.0)  THEN 
                    IQUEST(1) = 111 
                    IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPU'//    
     +              'RG : Illegal Path Name '//PATHY//''')', IARGDB, 0) 
                    GO TO 999   
                  ENDIF 
                  LCDRDB = IQUEST(11)   
                  IKDRDB = IQUEST(13)   
*   
*  *              Check all key elements in the slave subdirectory  
*   
                  DO 110 IK = 1, NKEYDK 
                    CALL DBKEYR (IK, NWKYDK, KEYNDK)    
                    KEY1DK(IK) = KEYNDK(MSERDB) 
                    IF (KEY7.GT.0) THEN 
                      IF (KEYNDK(MITMDB).GT.KEY7) GO TO 110 
                    ENDIF   
                    DO 105 K = 1, NWKYDK    
                      IF (IOKYDA(K).NE.0.AND.KEYVDK(K).NE.KEYNDK(K))    
     +                                            GO TO 110 
  105               CONTINUE    
                    IF (KEYNDK(MPVSDB).LT.KEYVDK(MPVSDB)) IPURDK(IK) = 0    
  110             CONTINUE  
                  GO TO 100 
                ENDIF   
              ENDIF 
              CALL DBDELK (IOPS)    
              NDEL   = NDEL + IQUEST(2) 
*   
  115       CONTINUE    
            GO TO 75    
          ENDIF 
*   
        ENDIF   
*   
      ELSE IF (IOPKDA.NE.0)  THEN   
*   
*  **   Delete all keys for which KEY(KYDAT).le.KYTIM   
*   
        IF (IOPTP.EQ.0)  THEN   
*   
          CALL VZERO_i (IPURDK, NKEYDK)   
*   
*  **     Label by '2' the objects for which KEY(KYDAT).le.KYTIM    
*   
          DO 120 IK = 1, NKEYDK 
            CALL DBKEYR (IK, NWKYDK, KEYNDK)    
            KEY1DK(IK) = KEYNDK(MSERDB) 
            IF (KEY7.LE.0) THEN 
              IF (KEYNDK(KYDAT).GE.KYTIM) IPURDK(IK) = 2    
            ELSE    
              IF (KEYNDK(MITMDB).GT.KEY7) THEN  
                IPURDK(IK) = 2  
              ELSE  
                IF (KEYNDK(KYDAT).GE.KYTIM) IPURDK(IK) = 2  
              ENDIF 
            ENDIF   
  120     CONTINUE  
          CALL DBDELK (IOPS)    
          NDEL   = IQUEST(2)    
*   
        ELSE    
*   
          NKEYS  = NKEYDK   
          DO 130 JK1 = 1, NKEYS 
            JK     = NKEYS + 1 - JK1    
            CALL DBPATH (PATHX, JK) 
            PATHY  = PATH(1:NCHAR)//'/'//PATHX  
            CALL RZCDIR (PATHY, ' ')    
            IF (IQUEST(1).NE.0)  THEN   
              IQUEST(1) = 111   
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : '// 
     +        'Illegal Path Name '//PATHY//''')', IARGDB, 0)    
              GO TO 999 
            ENDIF   
            NKEYDK = IQUEST(7)  
            IF (NKEYDK.LE.0)                      GO TO 130 
            NWKYDK = IQUEST(8)  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
            CALL DBKEYT 
*   
            CALL VZERO_i (IPURDK, NKEYDK) 
*   
*  **       Label by '2' the object for which KEY(KYDAT).le.KYTIM   
*   
            DO 125 IK = 1, NKEYDK   
              CALL DBKEYR (IK, NWKYDK, KEYNDK)  
              KEY1DK(IK) = KEYNDK(MSERDB)   
              IF (KEY7.LE.0) THEN   
                IF (KEYNDK(KYDAT).GE.KYTIM) IPURDK(IK) = 2  
              ELSE  
                IF (KEYNDK(MITMDB).GT.KEY7) THEN    
                  IPURDK(IK) = 2    
                ELSE    
                  IF (KEYNDK(KYDAT).GE.KYTIM) IPURDK(IK) = 2    
                ENDIF   
              ENDIF 
  125       CONTINUE    
            CALL DBDELK (IOPS)  
            NDEL   = NDEL + IQUEST(2)   
  130     CONTINUE  
*   
        ENDIF   
*   
      ELSE IF (IOPSDA.NE.0)  THEN   
*   
*  **   Delete all keys for with KEY(MSERDB) in the range KYDAT-KYTIM   
*   
        IF (IOPTP.EQ.0)  THEN   
*   
          IPNT   = KOFSDB + LCDRDB + IKDRDB 
          ISTP   = NWKYDK + 1   
*   
*  **     Label by '2' objects for which KEY(1) not in range KYDAT-KYTIM    
*   
          DO 140 IK = 1, NKEYDK 
            KEY1DK(IK) = IQ(IPNT+(IK-1)*ISTP+MSERDB)    
            IF (KEY7.LE.0) THEN 
              IF (KEY1DK(IK).GE.KYDAT.AND.KEY1DK(IK).LE.KYTIM) THEN 
                IPURDK(IK) = 0  
              ELSE  
                IPURDK(IK) = 2  
              ENDIF 
            ELSE    
              IF (IQ(IPNT+(IK-1)*ISTP+MITMDB).GT.KEY7) THEN 
                IPURDK(IK) = 2  
              ELSE  
                IF (KEY1DK(IK).GE.KYDAT.AND.KEY1DK(IK).LE.KYTIM) THEN   
                  IPURDK(IK) = 0    
                ELSE    
                  IPURDK(IK) = 2    
                ENDIF   
              ENDIF 
            ENDIF   
  140     CONTINUE  
          CALL DBDELK (IOPS)    
          NDEL   = IQUEST(2)    
*   
        ELSE    
*   
          NKEYS  = NKEYDK   
          KST    = NWKYDK + 1   
          MAXKY  = -1   
          DO 160 JK1 = 1, NKEYS 
            JK     = NKEYS + 1 - JK1    
            IPNT   = KOFSDB + LCDRDB + IKDRDB   
            KPNT   = IUHUNT (JK, IQ(IPNT+MPSRDB), NKEYS*KST, KST)   
            IF (KPNT.GT.0) THEN 
              KPNT   = KPNT + IPNT - MPSRDB 
            ELSE    
              KPNT   = IPNT + (JK - 1) * KST    
            ENDIF   
            MINKY  = IQ(KPNT+MOBJDB) + 1    
            IF (KYTIM.LT.MINKY)                   GO TO 155 
            IF (MAXKY.GT.0.AND.KYDAT.GT.MAXKY)    GO TO 155 
            CALL DBPATH (PATHX, JK) 
            PATHY  = PATH(1:NCHAR)//'/'//PATHX  
            CALL RZCDIR (PATHY, ' ')    
            IF (IQUEST(1).NE.0)  THEN   
              IQUEST(1) = 111   
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : '// 
     +        'Illegal Path Name '//PATHY//''')', IARGDB, 0)    
              GO TO 999 
            ENDIF   
            NKEYDK = IQUEST(7)  
            IF (NKEYDK.LE.0)                      GO TO 150 
            NWKYDK = IQUEST(8)  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
            CALL DBKEYT 
            IPNT   = KOFSDB + LCDRDB + IKDRDB   
            ISTP   = NWKYDK + 1 
*   
*  **       Label by '2' objects with KEY(1) not in range KYDAT-KYTIM   
*   
            DO 145 IK = 1, NKEYDK   
              KEY1DK(IK) = IQ(IPNT+(IK-1)*ISTP+MSERDB)  
              IF (KEY7.LE.0) THEN   
                IF (KEY1DK(IK).GE.KYDAT.AND.KEY1DK(IK).LE.KYTIM) THEN   
                  IPURDK(IK) = 0    
                ELSE    
                  IPURDK(IK) = 2    
                ENDIF   
              ELSE  
                IF (IQ(IPNT+(IK-1)*ISTP+MITMDB).GT.KEY7) THEN   
                  IPURDK(IK) = 2    
                ELSE    
                  IF (KEY1DK(IK).GE.KYDAT.AND.KEY1DK(IK).LE.KYTIM) THEN 
                    IPURDK(IK) = 0  
                  ELSE  
                    IPURDK(IK) = 2  
                  ENDIF 
                ENDIF   
              ENDIF 
  145       CONTINUE    
            CALL DBDELK (IOPS)  
            NDEL   = NDEL + IQUEST(2)   
*   
  150       CALL RZCDIR (PATH, ' ') 
            IF (IQUEST(1).NE.0)  THEN   
              IQUEST(1) = 111   
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : '// 
     +        'Illegal Path Name '//PATH//''')', IARGDB, 0) 
              GO TO 999 
            ENDIF   
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
  155       MAXKY  = MINKY - 1  
  160     CONTINUE  
*   
        ENDIF   
*   
      ENDIF 
*   
      IQUEST(1) = 0 
      IQUEST(2) = NDEL  
      GO TO 999 
*   
* *** Error messages    
*   
  991 IQUEST(1) = 111   
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : Illegal '// 
     +   'Path Name '//PATH(1:NCHAR)//''')', IARGDB, 0) 
      GO TO 999 
*   
  992 IQUEST(1) = 112   
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : No key or'//    
     +   ' data for Path Name '//PATH(1:NCHAR)//''')', IARGDB, 0)   
      GO TO 999 
*                                                             END DBPURG    
  999 END   
      SUBROUTINE DBPURK (PATHN, ITIME, KEYS, CHOPT) 
*     ============================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPURK (PATHN, ITIME, KEYS, CHOPT)                      *    
*                                                                      *    
*   Deletes objects in a directory path name steered by a selection    *    
*   on a number of key elements                                        *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     ITIME    Time of validity of the object                          *    
*     KEYS     Vector of keys. Only the elements declared in CHOPT are *    
*              assumed to contain useful information.                  *    
*     CHOPT    Character string with any of the following characters   *    
*          B   Save in the special backup file; not in standard Journal*    
*          S   expect multiple Key banks satisfying selection on a     *    
*              number of keys                                          *    
*          3   selects objects with start validity time < KEYS(3)      *    
*          4   selects objects with end validity time > KEYS(4)        *    
*          5   specific Program version number required                *    
*          7   select objects with insertion time < KEYS(7)            *    
*          n   consider user key n (where 7 < n < 29 )                 *    
*                                                                      *    
*   Called by user,   DBFZUP                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =111 : Illegal path name                               *    
*               =112 : No key for the path name satisfying the Key     *    
*                      assignments                                     *    
*               =113 : Illegal character option                        *    
*               =114 : Valid data objects in the Node/Key structure    *    
*                                                                      *    
*     If IQUEST(1) =0, IQUEST(2) carries information on number of      *    
*     data objects deleted in the disk                                 *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      DIMENSION       KEYS(9)   
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, PATHX*16, PATHY*80 
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension lbk(9)
*     ------------------------------------------------------------------    
*   
* *** Initialize options    
*   
      KEY7   = KEY7DK   
      KEY7DK = 0    
      NDEL   = 0    
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)                   GO TO 999   
      IF (IOPMDA.NE.0) THEN 
        IQUEST(1) = 113 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURK : Illegal'//    
     +  ' Character option '')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Set the current directory 
*   
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 111 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURK : Illegal'//    
     +  ' Path Name '//PATH//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL RZCDIR (PATH, 'R')   
      NCHAR  = INDEX (PATH, ' ') - 1    
      IF (NCHAR.LT.1.OR.NCHAR.GT.MAXLDB) NCHAR = MAXLDB 
      IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)  
      IOPTP  = JBIT (IOPTP, JPRTDB) 
      IF (NKEYDK.LE.0) THEN 
        IQUEST(1) = 112 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURK : No vali'//    
     +  'd object for Path Name '//PATH//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
      NCHRT  = INDEX (PATH(3:NCHAR), '/') - 1   
      IF (NCHRT.LE.0) NCHRT = NCHAR - 2 
      PATHX  = PATH(3:NCHRT+2)  
      LTOP   = LTOPDB   
    5 IF (LTOP.NE.0) THEN   
        NCHRT  = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHRT)   
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN  
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 5   
        ENDIF   
        KY7MDB = IQ(KOFUDB+LTOP+MUPKY7) 
      ELSE  
        KY7MDB = 0  
      ENDIF 
*   
* *** Save the command in the journal file  
*   
      CALL DBKEYT   
      KEY7DK = KEY7 
      CALL DBSPUR (PATH, NWKYDK, ITIME, KEYS, CHOPT, IOPP, IOPS)    
      KEY7DK = 0    
      IF (IQUEST(1).NE.0)                   GO TO 999   
      IF (IOPP.NE.0)                        GO TO 999   
*   
* *** Prepare the Key banks in memory   
*   
      CALL DBNODE (PATH, LBNODB)    
      IF (IQUEST(1).NE.0)                   GO TO 999   
      IF (LQ(KOFUDB+LBNODB-KLKYDB).NE.0) THEN   
        IQUEST(1) = 114 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURK : Valid '// 
     +  'KYDB exists for Path Name '//PATH//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
*   
      IF (KEY7.GT.0) THEN   
        KEY7O  = KEYS(MITMDB)   
        IF (IOKYDA(MITMDB).NE.0) THEN   
          KEYS(MITMDB) = MIN0 (KEYS(MITMDB), KEY7)  
        ELSE    
          KEYS(MITMDB)   = KEY7 
          IOKYDA(MITMDB) = 1    
        ENDIF   
      ENDIF
      lbk(1) = LBDADB
      CALL DBKEYS (LBNODB, KEYS, lbk, ITIME) 
      IF (IQUEST(1).NE.0) THEN  
        IF (KEY7.GT.0) KEYS(MITMDB) = KEY7O 
        GO TO 999   
      ENDIF 
      IF (LQ(KOFUDB+LBNODB-KLKYDB).LE.0) THEN   
        IF (KEY7.GT.0) KEYS(MITMDB) = KEY7O 
        IQUEST(1) = 112 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURK : No vali'//    
     +  'd object for Path Name '//PATH//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
      LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB) 
      ITEMP  = IOPKDA   
      IOPKDA = 1    
   10 IF (IOPSDA.EQ.0 .AND. LBKYDB.GT.0) THEN   
        DO 15 I = 1, NWKYDK 
          IF (IOKYDA(I).NE.0) THEN  
            IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB.OR.I.EQ.MITMDB) THEN 
              KEYVDK(I) = KEYS(I)   
            ELSE    
              KEYVDK(I) = IQ(KOFUDB+LBKYDB+I)   
            ENDIF   
          ELSE  
            KEYVDK(I) = 0   
          ENDIF 
   15   CONTINUE    
        CALL DBKXIN (ITIME, IDIVDB, LBDADB, LBKYDB, -1, NWKYDK, KEYVDK, 
     +               IPREC) 
        IF (IQUEST(1).NE.0)                 GO TO 100   
        CALL UCOPY_i (KEYVDK(1), IQ(KOFUDB+LBKYDB+1), NWKYDK) 
        LBKYDB = LQ(KOFUDB+LBKYDB)  
        GO TO 10    
      ENDIF 
      IOPKDA = ITEMP    
*   
* *** Now mark the objects which are in the Key banks to be deleted 
*   
      IF (IOPTP.EQ.0) THEN  
*   
        IPNT   = KOFSDB + LCDRDB + IKDRDB   
        ISTP   = NWKYDK + 1 
        DO 20 IK = 1, NKEYDK    
          KEY1DK(IK) = IQ(IPNT+(IK-1)*ISTP+MSERDB)  
          IPURDK(IK) = 2    
   20   CONTINUE    
        LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)   
   25   IF (LBKYDB.GT.0) THEN   
          II     = IUCOMP (IQ(KOFUDB+LBKYDB+MSERDB), KEY1DK, NKEYDK)    
          IF (II.GT.0) IPURDK(II) = 0   
          LBKYDB = LQ(KOFUDB+LBKYDB)    
          GO TO 25  
        ENDIF   
        CALL DBDELK (IOPS)  
        NDEL   = IQUEST(2)  
*   
      ELSE  
*   
        NKEYS  = NKEYDK 
        KST    = NWKYDK + 1 
        MAXKY  = -1 
        LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)   
        MINK   = IQ(KOFUDB+LBKYDB+MSERDB)   
        MAXK   = IQ(KOFUDB+LBKYDB+MSERDB)   
   30   LBKYDB = LQ(KOFUDB+LBKYDB)  
        IF (LBKYDB.GT.0) THEN   
          MINK   = MIN0 (MINK, IQ(KOFUDB+LBKYDB+MSERDB))    
          MAXK   = MAX0 (MAXK, IQ(KOFUDB+LBKYDB+MSERDB))    
          GO TO 30  
        ENDIF   
*   
        DO 55 JK1 = 1, NKEYS    
          JK     = NKEYS + 1 - JK1  
          IPNT   = KOFSDB + LCDRDB + IKDRDB 
          KPNT   = IUHUNT (JK, IQ(IPNT+MPSRDB), NKEYS*KST, KST) 
          IF (KPNT.GT.0) THEN   
            KPNT   = KPNT + IPNT - MPSRDB   
          ELSE  
            KPNT   = IPNT + (JK - 1) * KST  
          ENDIF 
          MINKY  = IQ(KPNT+MOBJDB) + 1  
          IF (MAXK.LT.MINKY)                GO TO 50    
          IF (MAXKY.GT.0.AND.MINK.GT.MAXKY) GO TO 50    
          CALL DBPATH (PATHX, JK)   
          PATHY  = PATH(1:NCHAR)//'/'//PATHX    
          CALL RZCDIR (PATHY, ' ')  
          IF (IQUEST(1).NE.0)  THEN 
            IQUEST(1) = 111 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURK : Ill'//    
     +      'egal Path Name '//PATHY//''')', IARGDB, 0) 
            GO TO 100   
          ENDIF 
          NKEYDK = IQUEST(7)    
          IF (NKEYDK.LE.0)                  GO TO 45    
          NWKYDK = IQUEST(8)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          IPNT   = KOFSDB + LCDRDB + IKDRDB 
          ISTP   = NWKYDK + 1   
*   
          DO 35 IK = 1, NKEYDK  
            KEY1DK(IK) = IQ(IPNT+(IK-1)*ISTP+MSERDB)    
            IPURDK(IK) = 2  
   35     CONTINUE  
          LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB) 
   40     IF (LBKYDB.GT.0) THEN 
            II     = IUCOMP (IQ(KOFUDB+LBKYDB+MSERDB), KEY1DK, NKEYDK)  
            IF (II.GT.0) IPURDK(II) = 0 
            LBKYDB = LQ(KOFUDB+LBKYDB)  
            GO TO 40    
          ENDIF 
          CALL DBDELK (IOPS)    
          NDEL   = NDEL + IQUEST(2) 
*   
   45     CALL RZCDIR (PATH, ' ')   
          IF (IQUEST(1).NE.0)  THEN 
            IQUEST(1) = 111 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURK : Ill'//    
     +      'egal Path Name '//PATH//''')', IARGDB, 0)  
            GO TO 100   
          ENDIF 
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
   50     MAXKY  = MINKY - 1    
   55   CONTINUE    
*   
      ENDIF 
*   
  100 IER    = IQUEST(1)    
      LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB) 
      IF (LBKYDB.GT.0) CALL MZDROP (IDIVDB, LBKYDB, 'L')    
      IQUEST(1) = IER   
      IF (KEY7.GT.0) KEYS(MITMDB) = KEY7O   
      IF (IQUEST(1).EQ.0) IQUEST(2) = NDEL  
*                                                             END DBPURK    
  999 END   
      SUBROUTINE DBRALI (ALIAS, PATH)   
*     ===============================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBRALI (ALIAS, PATH*)                                   *    
*                                                                      *    
*   Retrieve the complete path name from the alias name                *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     ALIAS    Character string specifying the alias name              *    
*     PATH(*)  Character string specifying the directory path name     *    
*                                                                      *    
*   Called by user,   DBACPL, DBAUXI                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =205 : Not a valid alias name                          *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      CHARACTER       PATH*(*), ALIAS*(*), CALI*8, PATHN*80, TOPN*16    
*   
*     ------------------------------------------------------------------    
*   
      PATH   = ' '  
      IQUEST(1) = 0 
*   
* *** Loop over all the top directories 
*   
      LTOP   = LTOPDB   
   10 IF (LTOP.NE.0) THEN   
        LDIC   = LQ(KOFUDB+LTOP-KLDICT) 
        IF (LDIC.NE.0) THEN 
          NITEM  = IQ(KOFUDB+LDIC+MDCNTM)   
          DO 20 I = 1, NITEM    
            IPNT   = KOFUDB + LDIC + (I - 1) * NWITDB + 1   
            IF (IQ(IPNT+MDCITM).GT.0) THEN  
              CALL UHTOC (IQ(IPNT+MDCALI), 4, CALI, 8)  
              IF (ALIAS.EQ.CALI) THEN   
                NCHF   = IQ(IPNT+MDCNCH)    
                CALL UHTOC (IQ(IPNT+MDCNAM), 4, PATHN, NCHF)    
                NCHT   = IQ(KOFUDB+LTOP+MUPNCH) 
                CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPN, NCHT)  
                PATH   = '//'//TOPN(1:NCHT)//PATHN(1:NCHF)  
                GO TO 999   
              ENDIF 
            ENDIF   
   20     CONTINUE  
        ENDIF   
        LTOP   = LQ(KOFUDB+LTOP)    
        GO TO 10    
      ELSE  
        IQUEST(1) = 205 
        IF (IDEBDB.GT.0) THEN   
          CALI   = ALIAS    
          CALL DBPRNT (LPRTDB, '(/,'' DBRALI : Alias name '//CALI// 
     +         ' not found'')', IARGDB, 0)  
        ENDIF   
      ENDIF 
*                                                             END DBRALI    
  999 END   
      SUBROUTINE DBRENK (PATHN, KEYO, KEYN) 
*     ===================================== 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBRENK (PATHN, KEYO, KEYN)                              *    
*                                                                      *    
*   Changes the key elements of an existing object to new values       *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     KEYO     Array containing the old key elements                   *    
*     KEYN     Array containing the new key elements                   *    
*                                                                      *    
*   Called by user,   DBFZUP                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =191 : Illegal path name                               *    
*               =192 : Illegal KEYO values (no matching object)        *    
*               =193 : No top directory found                          *    
*               =194 : Error in getting the IO descriptor              *    
*               =195 : Error in FZOUT in saving the journal file       *    
*               =196 : Error in RZRENK in renaming key values          *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NLEVM=20)    
      INTEGER         NLCUR(NLEVM)  
      DIMENSION       KEYO(9), KEYN(9), KEYOP(MXDMDK), KEYNP(MXDMDK)    
      CHARACTER       PATHY*80, PATHX*16, CHFOR*100, CFORM(6)*1 
      CHARACTER       CHCUR(NLEVM)*1, TOPN*16, PATHN*(*)    
      DATA            CFORM /'B', 'I', 'F', 'D', 'H', 'A'/  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*

      dimension iarg(9)
*     ------------------------------------------------------------------    
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATHY, NCHAR) 
*   
* *** Set the current directory path name   
*   
      PATHX  = ' '  
      CALL RZCDIR (PATHY, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 191 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Illegal'//    
     +  ' Path Name '//PATHY(1:NCHAR)//''')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      KST    = NWKYDK + 1   
      CALL RZCDIR (PATHY, 'R')  
      NCHAR  = INDEX (PATHY, ' ') - 1   
      IF (NCHAR.LT.1.OR.NCHAR.GT.MAXLDB) NCHAR = MAXLDB 
      CALL DBKEYT   
      IF (NKEYDK.NE.0)  THEN    
        IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)    
        IOPTP  = JBIT (IOPTP, JPRTDB)   
      ELSE  
        IQUEST(1) = 192 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Illegal'//    
     +  ' key in Path '//PATHY(1:NCHAR)//PATHX(1:8)//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
* *** See if the key matches with one existing  
*   
      IF (IOPTP.EQ.0) THEN  
        KPNT   = IUHUNT (KEYO(MSERDB), IQ(KOFSDB+LCDRDB+IKDRDB+MSERDB), 
     +                   NKEYDK*KST, KST)   
        IF (KPNT.EQ.0) THEN 
          IQUEST(1) = 192   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Illeg'//    
     +    'al key in Path '//PATHY(1:NCHAR)//PATHX(1:8)//''')',IARGDB,0)    
          GO TO 999 
        ELSE    
          NK     = (KPNT - MSERDB) / KST + 1    
          CALL DBKEYR (NK, NWKYDK, KEYNDK)  
          DO 10 IK = 1, NWKYDK  
            IF (KEYNDK(IK).NE.KEYO(IK)) THEN    
              IQUEST(1) = 192   
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : I'//    
     +        'llegal key in Path '//PATHY(1:NCHAR)//PATHX(1:8)//''')', 
     +        IARGDB, 0)    
              GO TO 999 
            ENDIF   
   10     CONTINUE  
        ENDIF   
*   
      ELSE  
        NKEYS   = NKEYDK    
        DO 20 JK = 1, NKEYS 
          IK     = NKEYS - JK + 1   
          KPNT   = IUHUNT (IK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB), 
     +                     NKEYS*KST, KST)  
          IF (KPNT.GT.0) THEN   
            KPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB   
          ELSE  
            KPNT   = KOFSDB + LCDRDB + IKDRDB + (IK - 1) * KST  
          ENDIF 
          IF (KEYO(MSERDB).LE.IQ(KPNT+MOBJDB)) GO TO 20 
          NK     = (KPNT - KOFSDB - LCDRDB -IKDRDB) / KST + 1   
          CALL DBKEYR (NK, NWKYDK, KEYOP)   
          CALL UCOPY_i (KEYOP, KEYNP, NWKYDK) 
          CALL DBPATH (PATHX, IK)   
          CALL RZCDIR (PATHX, ' ')  
          IF (IQUEST(1).NE.0) THEN  
            IQUEST(1) = 191
            iarg(1) = iq(1)
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Ill'//    
     +           'egal Path Name '//PATHY(1:NCHAR)//PATHX(1:8)//''')',
     &           Iarg, 0)
            GO TO 999   
          ENDIF 
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          KPNT   = IUHUNT (KEYO(MSERDB),IQ(KOFSDB+LCDRDB+IKDRDB+MSERDB),    
     +                     NKEYDK*KST, KST) 
          IF (KPNT.EQ.0) THEN   
            IQUEST(1) = 192 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Ill'//    
     +      'egal key in Path '//PATHY(1:NCHAR)//PATHX(1:8)//''')', 
     +      IARGDB, 0)  
            GO TO 999   
          ELSE  
            NK     = (KPNT - MSERDB) / KST + 1  
            CALL DBKEYR (NK, NWKYDK, KEYNDK)    
            DO 15 IK = 1, NWKYDK    
              IF (KEYNDK(IK).NE.KEYO(IK)) THEN  
                IQUEST(1) = 192 
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK :'//    
     +          ' Illegal key in Path '//PATHY(1:NCHAR)//PATHX(1:8)//   
     +          ''')', IARGDB, 0)   
                GO TO 999   
              ENDIF 
   15       CONTINUE    
            GO TO 25    
          ENDIF 
   20   CONTINUE    
        IQUEST(1) = 192 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Illegal'//    
     +  ' key in Path '//PATHY(1:NCHAR)//PATHX(1:8)//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
* *** Extract the Top level directory name  
*   
   25 I1     = 0    
      I11    = 0    
      DO 30 I0 = 1, NCHAR   
        IF (PATHY(I0:I0).EQ.'/'.OR.PATHY(I0:I0).EQ.' ') THEN    
          IF (I1.GT.0) THEN 
            TOPN   = PATHY(I11:I0-1)    
            GO TO 35    
          ENDIF 
          IF (PATHY(I0:I0).EQ.' ')             GO TO 35 
        ELSE    
          IF (I1.EQ.0) I11 = I0 
          I1     = I1 +1    
        ENDIF   
   30 CONTINUE  
   35 IF (I1.EQ.0) THEN 
        IQUEST(1) = 193 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : No top '//    
     +  'directory for '//PATHY//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
* *** Find the appropriate FZ file number   
*   
      LTOP   = LTOPDB   
      IOPS   = 0    
      IOUT   = 0    
   40 IF (LTOP.NE.0) THEN   
        NCH    = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCH) 
        TOPNDI = TOPNDI(1:NCH)  
        IF (TOPN.EQ.TOPNDI) THEN    
          LUFZDF = IQ(KOFUDB+LTOP+MUPJFL)   
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)  
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)   
        ELSE    
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 40  
        ENDIF   
      ELSE  
        LUFZDF = 0  
      ENDIF 
      IF (IOUT.EQ.0) IOPS = 0   
*   
* *** Get the IO descriptor for the header  
*   
      IF (LUFZDF.GT.0) THEN 
        NLEV   = 1  
        NCUR   = 5  
        IFORO  = 2  
        CHCUR(NLEV) = CFORM(IFORO)  
        DO 50 J = 1, 2  
          DO 45 I = 1, NWKYDK   
            IFORM  = IOTYDK(I)  
            IF (IFORM.EQ.6) IFORM = 5   
            IF (IFORM.EQ.IFORO) THEN    
              NCUR   = NCUR + 1 
            ELSE    
              NLCUR(NLEV) = NCUR    
              IF (NLEV.GE.NLEVM) THEN   
                IQUEST(1) = 194 
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK :'//    
     +          ' Cannot get IO descriptor '//PATHY//''')', IARGDB, 0)  
                GO TO 999   
              ENDIF 
              NLEV   = NLEV + 1 
              CHCUR(NLEV) = CFORM(IFORM)    
              NCUR   = 1    
              IFORO  = IFORM    
            ENDIF   
   45     CONTINUE  
   50   CONTINUE    
        NLCUR(NLEV) = NCUR  
*   
        WRITE (CHFOR, 2001) (NLCUR(I), CHCUR(I), I = 1, NLEV)   
        II     = 4 *NLEV    
        CHFOR = CHFOR(1:II)//' -H'  
        CALL MZIOCH (IOFMDF, NWFMDF, CHFOR(1:II+3)) 
*   
*  **   Fill up the header  
*   
        NWDP   = (NCHAR + 3) / 4    
        NWDH   = NWDP + 2 * NWKYDK + 5  
        IHEADF(MACTDF) = 5  
        IHEADF(MNKYDF) = NWKYDK 
        IHEADF(MOPTDF) = 0  
        IHEADF(MPATDF) = NWDP   
        IHEADF(MPREDF) = 0  
        CALL UCOPY_i (KEYO,  IHEADF(MPREDF+1),        NWKYDK) 
        CALL UCOPY_i (KEYN,  IHEADF(MPREDF+NWKYDK+1), NWKYDK) 
        CALL UCTOH (PATHY, IHEADF(MPREDF+2*NWKYDK+1), 4, 4*NWDP)    
      ENDIF 
*   
*  ** Write the sequential output if needed 
*   
      IF (LUFZDF.GT.0) THEN 
        CALL FZOUT (LUFZDF, IDISDB, 0, 1, 'Z', IOFMDF, NWDH, IHEADF)    
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1)  = 195  
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Error'//    
     +    ' in FZOUT while writing Data for '//PATHY(1:60)//''')',  
     +    IARGDB, 0)    
          GO TO 999 
        ENDIF   
      ENDIF 
*   
* *** Take necessary action for partitioned and nonpartitioned datasets 
*   
      IF (IOPS.NE.0) CALL RZLOCK ('DBRENK') 
      CALL RZRENK (KEYO, KEYN)  
      IERR   = IQUEST(1)    
      IF (IOPS.NE.0) CALL RZFREE ('DBRENK') 
      IF (IERR.NE.0) THEN   
        IQUEST(1) = 196 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Error'//  
     +  ' in RZRENK while writing data for '//PATHY(1:60)//''')',   
     +  IARGDB, 0)  
        GO TO 999   
      ENDIF 
      IF (IOPTP.NE.0) THEN  
        KEYNP(MBVRDB) = MIN0 (KEYNP(MBVRDB), KEYN(MBVRDB))  
        KEYNP(MEVRDB) = MAX0 (KEYNP(MEVRDB), KEYN(MEVRDB))  
        CALL RZCDIR (PATHY, ' ')    
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        NKEYDK = IQUEST(7)  
*   
*  **   Rename Keys 3 and 4 of the latest subdirectory  
*   
        IF (IOPS.NE.0) CALL RZLOCK ('DBRENK')   
        CALL RZRENK (KEYOP, KEYNP)  
        IERR   = IQUEST(1)  
        IF (IOPS.NE.0) CALL RZFREE ('DBRENK')   
        IF (IERR.NE.0) THEN 
          IQUEST(1) = 196   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Error'//    
     +    ' in RZRENK while writing data for '//PATHY(1:60)//''')', 
     +    IARGDB, 0)    
          GO TO 999 
        ENDIF   
      ENDIF 
*   
  998 CONTINUE  
*   
 2001 FORMAT (20(I2,A1,1X)) 
*                                                             END DBRENK    
  999 END   
      SUBROUTINE DBREPL (PATHN, LBK, LBD, IUDIV, LSUP, NWKEY, KEYO, KEYN    
     +                 , IPREC, CHOPT)  
*     ==================================================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBREPL (PATHN, *LBK*, LBD*, IUDIV, LSUP, NWKEY, KEYO,   *    
*                      KEYN, IPREC, CHOPT)                             *    
*                                                                      *    
*   Stores data from memory to disk and also enters in the memory ala  *    
*   DBUSE in NODE/KEY structure. Also replaces an Old set of keys in   *    
*   KEYO by a new set of keys in KEYN                                  *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     LBK(*)   Address of Keys bank KYDB   (INPUT or OUTPUT)           *    
*     LBD(*)   Address of Data bank                                    *    
*     IUDIV    Division index of the user data bank                    *    
*     LSUP     Address of bank in memory where data reside             *    
*     NWKEY    Number of keys associated with the data bank            *    
*     KEYO     Vector of old keys                                      *    
*     KEYN     Vector of new keys                                      *    
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *    
*              IPREC significant digits right to the decimal points; if*    
*              IPREC < 0, data are stored with IPREC insignificant     *    
*              digits left to the decimal point.)                      *    
*     CHOPT    Character string with any of the following characters   *    
*          A   trust LBK address if non-zero                           *    
*          B   Save in the special backup file; not in standard Journal*    
*          C   create Node/Key data structure ala DBUSE                *    
*          F   Updates with a fully matched data object (in user keys) *    
*          K   Store data only inside the keys (not yet installed)     *    
*          N   Create new (sub)directory(ies)                          *    
*          P   Create partitioned subdirectories for the pathname      *    
*          R   Store with full RZ option (No compression to be made)   *    
*          S   Create stand alone (master) data                        *    
*          T   Special text type of data (to be used with R)           *    
*          U   Store data uncompressed                                 *    
*          Z   Store only nonzero elements. An element is considered to*    
*              be zero if its absolute value is less than IPREC (real) *    
*          7   Insertion time as supplied by user to be honoured       *    
*                                                                      *    
*   Called by user,   DBAIWR, DBUPKY                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 61 : Too many keys                                   *    
*               = 62 : Too many keys with option N                     *    
*               = 63 : Data base structure in memory clobbered         *    
*               = 64 : Error in MZCOPY while copying Data bank         *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      COMMON /DZPACK/ PRECDZ, PACKDZ    
      LOGICAL         PACKDZ    
*   
      DIMENSION       KEYN(9), KEYO(9), LBD(9), LBK(9)
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, FPATH*80, CHOP*2   
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension nio(9)
      integer ival
      real fval
      equivalence (ival, fval)
*     ------------------------------------------------------------------    
*   
* *** Decode the character option   
*   
      LREFDB(1) = LBK(1)    
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)     GO TO 999 
      PACKDZ = .FALSE.  
*   
      IF (IOPUDA.NE.0.AND.IOPZDA.NE.0)  THEN    
        IOPZDA = 0  
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBREPL : Warning'//    
     +  ' - Z option is incompatible with U option - U option will be'//    
     +  ' executed'')', IARGDB, 0)  
*   
      ELSE IF (IOPZDA.NE.0)  THEN   
        PACKDZ = .TRUE.
        ival = iprec
        precdz = fval
      ENDIF 
*   
      IF (IOPRDA.NE.0.AND.IOPNDA.NE.0)  THEN    
        IOPNDA = 0  
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBREPL : Warning'//    
     +  ' - R option is incompatible with N option - R option will be'//    
     +  ' executed'')', IARGDB, 0)  
      ENDIF 
*   
* *** Check the number of keys  
*   
      IF (NWKEY.GT.MXDMDK)  THEN    
        IQUEST(1) = 61  
        IQUEST(11)= NWKEY   
        IQUEST(12)= MXDMDK  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBREPL : Too man'//    
     +  'y keys '',I6,'' maximum permitted '',I6)', IQUEST(11), 2)  
        GO TO 999   
      ENDIF 
*   
      IF (IOPNDA.NE.0.AND.NWKEY.GT.NINEDK)  THEN    
        IQUEST(1) = 62  
        IQUEST(11)= NWKEY   
        IQUEST(12)= NINEDK  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBREPL : Too man'//    
     +  'y keys '',I6,'' with option N - a maximum of '',I6,'' permit'//    
     +  'ted'')', IQUEST(11), 2)    
        GO TO 999   
      ENDIF 
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Create new subdirectories if needed   
*   
      IF (NWKEY.GE.NSYSDK)  THEN    
        NTKEY  = NWKEY  
      ELSE  
        NTKEY  = NINEDK 
      ENDIF 
      IF (IOPNDA.NE.0)  THEN    
        IF (IOPPDA.EQ.0)  THEN  
          CALL DBMDIR (PATH, NTKEY, CHFTDK, CHTGDK) 
        ELSE    
          KEY7DK = 0    
          CALL DBMDIP (PATH, NTKEY, CHFTDK, CHTGDK, MXKPDK) 
        ENDIF   
        IF (IQUEST(1).NE.0)   GO TO 999 
      ENDIF 
*   
* *** Prepare the output with the old keys  
*   
      CALL VZERO_i (KEYVDK, MXDMDK)   
      KEYVDK(MBVRDB) = KEYN(MBVRDB) 
      KEYVDK(MEVRDB) = KEYN(MEVRDB) 
      KEYVDK(MPVSDB) = KEYO(MPVSDB) 
      KEYVDK(MFLGDB) = MSBIT1 (KEYVDK(MFLGDB), JIGNDB)  
      IOKYDA(MPVSDB) = 1    
      IF (IOKYDA(MITMDB).NE.0) KEYVDK(MITMDB) = KEYN(MITMDB)    
      IF (NWKEY.GT.NSYSDK) THEN 
        DO 20 NK = NSYSDK+1, NWKEY  
          IOKYDA(NK) = 1    
          KEYVDK(NK) = KEYO(NK) 
   20   CONTINUE    
      ENDIF 
*   
      IF (LSTRDL(3).NE.0) CALL MZDROP (IDISDB, LSTRDL(3), 'L')  
      JBIAS  = 2
      nio(1) = 2
      CALL DBBOOK (IDISDB, LSTRDL(3), LSTRDL(3), JBIAS, 'SAME', 0, 0, 0 
     +           , nio, 0)    
      IF (IQUEST(1).NE.0)     GO TO 999 
*   
      CALL DBKOUT (PATH, IDISDB, LSTRDL(3), NTKEY, KEYVDK, IPREC)   
      IF (IQUEST(1).NE.0)     GO TO 999 
      IF (LSTRDL(3).NE.0) THEN  
        CALL MZDROP (IDISDB, LSTRDL(3), 'L')    
        LSTRDL(3) = 0   
      ENDIF 
*   
* *** Prepare the Key vector array  
*   
      CALL VZERO_i (KEYVDK, MXDMDK)   
      KEYVDK(MBVRDB) = KEYN(MBVRDB) 
      KEYVDK(MEVRDB) = KEYN(MEVRDB) 
      KEYVDK(MPVSDB) = KEYN(MPVSDB) 
      IF (IOKYDA(MITMDB).NE.0) KEYVDK(MITMDB) = KEYN(MITMDB)    
      IF (NWKEY.GT.NSYSDK) THEN 
        DO 30 NK = NSYSDK+1, NWKEY  
   30   KEYVDK(NK) = KEYN(NK)   
      ENDIF 
*   
* *** Write out the data    
*   
      CALL DBKOUT (PATH, IUDIV, LSUP, NTKEY, KEYVDK, IPREC)  
      IF (IQUEST(1).NE.0)     GO TO 999 
*   
* *** Create data bank in memory ala DBUSE  
*   
      IF (IOPCDA.NE.0)  THEN    
*   
*  **   Create database skeleton in memory (banks NODB and KYDB)    
*   
        IF (IOPADA.EQ.0. OR. (IOPADA.NE.0. AND. LREFDB(1).EQ.0) )  THEN 
*   
          CALL DBNODE (PATH, LBNODB)    
          IF (IQUEST(1).NE.0) GO TO 999 
*   
*  *      Switch off M and/or S option of DBUSE 
*   
          ITMPM  = IOPMDA   
          ITMPS  = IOPSDA   
          IOPMDA = 0    
          IOPSDA = 0    
*   
          CALL DBKEYS (LBNODB, KEYVDK, LBK, KEYVDK(MBVRDB)) 
          IF (IQUEST(1).NE.0) GO TO 999 
          LREFDB(1) = LBK(1)    
          IOPMDA = ITMPM    
          IOPSDA = ITMPS    
          CALL UCOPY_i (KEYVDK(1), IQ(KOFUDB+LREFDB(1)+1), NWKYDK)    
          NDK    = IQ(KOFUDB+LREFDB(1)-1)   
          IQ(KOFUDB+LREFDB(1)+NDK+MKYFRI) = 0   
          IQ(KOFUDB+LREFDB(1)+NWKYDK+1)   = KEYVDK(MEVRDB)  
*   
        ELSE    
*   
          IF (IDEBDB.GT.0) THEN 
            LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)    
            NF     = IQ(KOFUDB+LBNODB+MNDNCH)   
            CALL UHTOC (IQ(KOFUDB+LBNODB+MNDNAM), 4, FPATH, NF) 
            FPATH  = FPATH(1:NF)    
            N      = INDEX (PATH, ' ')  
            IF (N.EQ.0)  N = LEN (PATH) + 1 
*   
   50       N      = N -1   
            IF (PATH(N:N).NE.FPATH(NF:NF))  THEN    
              IQUEST(1) = 63    
              IQUEST(11)= N 
              CALL DBPRNT (LPRTDB, '(/,'' DBREPL : Database structure'//    
     +             ' in memory clobbered'')', IARGDB, 0)    
              GO TO 999 
            ELSE IF (N.NE.1)  THEN  
              NF     = NF -1    
              GO TO 50  
            ENDIF   
          ENDIF 
*   
          CALL UCOPY_i (KEYVDK(1), IQ(KOFUDB+LREFDB(1)+1), NWKYDK)    
          NDK    = IQ(KOFUDB+LREFDB(1)-1)   
          IQ(KOFUDB+LREFDB(1)+NDK+MKYFRI) = 0   
          IQ(KOFUDB+LREFDB(1)+NWKYDK+1)   = KEYVDK(MEVRDB)  
        ENDIF   
*   
*  **   Now copy the data banks appended at LSUP to the key bank    
*   
        IF (IOPRDA.EQ.0)  THEN  
          CHOP   = 'NP' 
        ELSE    
          CHOP   = 'LP' 
        ENDIF   
*   
        IF (IOPKDA.EQ.0 .AND. LSUP.NE.0) THEN    
          CALL MZCOPY (IUDIV, LSUP, IDIVDB, LREFDB(1), -KLDADB, CHOP)    
        ENDIF   
*   
        IF (IQUEST(1).EQ.0)  THEN   
          LBD(1) = LQ(KOFUDB+LREFDB(1)-KLDADB)  
        ELSE    
          IQUEST(11)= IQUEST(1) 
          IQUEST(1) = 64    
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBREPL : Error'//    
     +    ' '',I6,'' while copying the Data bank in the Node/Key stru'//    
     +    'cture'')', IQUEST(11), 1)    
        ENDIF   
*   
      ENDIF 
*                                                             END DBREPL    
  999 END   
      SUBROUTINE DBRHLP (PATH, LUN) 
*     ============================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBRHLP (PATH, LUN)                                      *    
*                                                                      *    
*   Retrieve the help information from data base and translate it      *    
*   with Subroutine DBLIND and also write the ASCII format on a        *    
*   given file specified by logical unit number LUN.                   *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATH     Character string describing the pathname                *    
*     LUN      Logical unit number of the file with ASCII data         *    
*                                                                      *    
*   Called by user,   DBACPL, DBAUXI                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 66 : Illegal logical unit number                     *    
*               =182 : The pathname specified does not exist           *    
*               =203 : No help directory inside the data base          *    
*               =204 : No help information for this path stored yet    *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      CHARACTER       PATH*(*), KLINE*80, PATHN*80, TOPN*16, PATHD*32   
*   
*     ------------------------------------------------------------------    
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATH, PATHN, NCHAR)  
*   
      IF (LUN.LE.0) THEN    
        IQUEST(1) = 66  
        IQUEST(11)= LUN 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRHLP : Illegal'//    
     +  ' unit number '',I10,'' for ASCII file'')', IQUEST(11), 1)  
        GO TO 999   
      ENDIF 
*   
* *** Check if the path name already exists in the help 
*   
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 182 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRHLP : Illgeal'//    
     +  ' pathname '//PATHN//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
      CALL RZCDIR (PATHN, 'R')  
      NCHAR = LENOCC(PATHN) 
*   
* *** Find the unique directory identifier from the pathname    
*   
      CALL DBGPID (PATHN, NCHAR, TOPN, IDN) 
      IF (IDN.LE.0) THEN    
      IQUEST(1) = 182   
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRHLP : Illgeal'//    
     +  ' pathname '//PATHN//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
* *** Set the current directory to HELP and retrieve object 
*   
      NCH    = LENOCC (TOPN)    
      PATHD  = '//'//TOPN(1:NCH)//'/HELP'   
      NCH    = NCH + 7  
      CALL RZCDIR (PATHD, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 203 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRHLP : Path na'//    
     +  'me '//PATHD(1:NCH)//' not found'')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKEYT   
      ISTP   = NWKYDK + 1   
      IPNT   = KOFSDB + LCDRDB + IKDRDB 
      KPNT   = IUHUNT (IDN, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP) 
      IF (KPNT.LE.0) THEN   
        IQUEST(1) = 204 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRHLP : No help'//    
     +  ' information for '//PATHN(1:NCHAR)//' available'')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
      KEY1S  = (KPNT - MSERDB) / ISTP + 1   
      CALL VZERO_i (KEYVDK, NWKYDK)   
      KEYVDK(MSERDB) = KEY1S    
      IF (LSTRDL(1).NE.0) THEN  
        CALL MZDROP (IDISDB, LSTRDL(1), 'L')    
        LSTRDL(1) = 0   
      ENDIF 
      IOLD1  = IOKYDA(MSERDB)   
      IOLDK  = IOPKDA   
      IOPKDA = 0    
      IOKYDA(MSERDB) = 1    
      ITIME  = 1    
      CALL DBKXIN (ITIME, IDISDB, LSTRDL(1), LSTRDL(1), 2, NWKYDK,  
     +             KEYVDK, IPREC)   
      IER    = IQUEST(1)    
      IOPKDA = IOLDK    
      IOKYDA(MSERDB) = IOLD1    
      IF (IER.NE.0) THEN    
        CALL MZDROP (IDISDB, LSTRDL(1), 'L')    
        IQUEST(1) = IER 
        GO TO 999   
      ENDIF 
*   
      IF (LSTRDL(1).GT.0) THEN  
        NDATA  = IQ(KOFUDB+LSTRDL(1)-1) 
        IF (NDATA.GT.0) THEN    
*   
*  **     Display data if exists, if it does not, display dummy data    
*   
          NTOT   = 0    
          NREC   = 0    
  120     IF (NTOT.LT.NDATA) THEN   
            CALL DBLIND (IQ(KOFUDB+LSTRDL(1)+1), NTOT, KLINE, LENG) 
            IF (LENG.GT.0) THEN 
              WRITE (LUN, 1000) KLINE(1:LENG)   
            ELSE    
              WRITE (LUN, *)    
            ENDIF   
            NREC   = NREC + 1   
            GO TO 120   
          ENDIF 
          IF (IDEBDB.GT.1) THEN 
            IARGDB(1) = NREC    
            IARGDB(2) = IDN 
            CALL DBPRNT (LPRTDB, '(/,'' DBRHLP : '',I10,'' records wr'//    
     +           'itten for set '',I4)', IARGDB, 2) 
          ENDIF 
        ENDIF   
      ENDIF 
*   
      IF (LSTRDL(1).NE.0) THEN  
        IERR   = IQUEST(1)  
        CALL MZDROP (IDISDB, LSTRDL(1), 'L')    
        LSTRDL(1) = 0   
        IQUEST(1) = IERR    
      ENDIF 
*   
 1000 FORMAT (A)    
*                                                             END DBRHLP    
  999 END   
      SUBROUTINE DBRKY1 (PATHN, KEY1S, NKEY1)   
*     =======================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBRKY1 (PATHN, KEY1S*, *NKEY1*)                         *    
*                                                                      *    
*   Retrieves all the Key 1 values for the directory PATHN             *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     KEY1S(*) Vector containing the Key 1 values                      *    
*     NKEY1    On input contains the maximum number of elements to be  *    
*              stored in KEY1S; on return it will contain the true     *    
*              number of objects                                       *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =101 : Illegal path name                               *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      DIMENSION       KEY1S(9)  
      CHARACTER       PATHN*(*), PATHY*80, PATHX*16 
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
* *** Set the current directory 
*   
      NKMAX  = NKEY1    
      NKEY1  = 0    
      CALL DBSBLC (PATHN, PATHY, NCHAR) 
      CALL RZCDIR (PATHY, ' ')  
      IF (IQUEST(1).NE.0)            GO TO 991  
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      ISTP   = NWKYDK + 1   
      CALL DBKEYT   
      IF (NKEYDK.EQ.0)               GO TO 999  
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)   
      CALL RZCDIR (PATHY, 'R')  
*   
*  ** Find all key 1 values 
*   
      NCHR   = LENOCC (PATHY)   
      IF (IOPTP.EQ.0) THEN  
        IPNT   = KOFSDB + LCDRDB + IKDRDB   
        DO 10 IK = 1, NKEYDK    
          NKEY1  = NKEY1 + 1    
          IF (NKEY1.LE.NKMAX) KEY1S(NKEY1) = IQ(IPNT+MSERDB)    
          IPNT   = IPNT + ISTP  
   10   CONTINUE    
      ELSE  
        NKEYS  = NKEYDK 
        DO 20 IKK = 1, NKEYS    
          CALL DBPATH (PATHX, IKK)  
          PATHY  = PATHY(1:NCHR)//'/'//PATHX    
          CALL RZCDIR (PATHY, ' ')  
          IF (IQUEST(1).NE.0)        GO TO 991  
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          NKEYDK = IQUEST(7)    
          IPNT   = KOFSDB + LCDRDB + IKDRDB 
          DO 15 IK = 1, NKEYDK  
            NKEY1  = NKEY1 + 1  
            IF (NKEY1.LE.NKMAX) KEY1S(NKEY1) = IQ(IPNT+MSERDB)  
            IPNT   = IPNT + ISTP    
   15     CONTINUE  
   20   CONTINUE    
      ENDIF 
*   
      IQUEST(1) = 0 
      GO TO 999 
*   
* *** Error messages    
*   
  991 IQUEST(1) = 101   
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRKY1 : Illegal '// 
     +   'Path Name '//PATHY//''')', IARGDB, 0) 
*                                                             END DBRKY1    
  999 END   
      SUBROUTINE DBRNAM (PATH, NWMAX, CHTAG)    
*     ======================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBRNAM (PATH, *NWMAX*, CHTAG*)                          *    
*                                                                      *    
*   Retrieves the names of the data elements of a given directory      *    
*   from the data base                                                 *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATH     Character string describing the pathname                *    
*     NWMAX    Maximum number of data word elements for CHTAG          *    
*              (on return it contains the number of CHTAG filled in)   *    
*     CHTAG(*) Name of the data elements                               *    
*                                                                      *    
*   Called by user,   DBAUXI                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =182 : Illegal path name                               *    
*               =201 : DICTIONARY directory not found                  *    
*               =202 : No description of data elements for the given   *    
*                      path name exists in the data base               *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      CHARACTER       PATHN*80, CTAG*8, TOPN*16, PATHD*32, PATH*(*) 
      CHARACTER*(*)   CHTAG(*)  
*   
*     ------------------------------------------------------------------    
*   
* *** See if the path name is correct   
*   
      CALL DBSBLC (PATH, PATHN, NCHAR)  
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 182 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRNAM : Illegal'//    
     +  ' path name '//PATHN//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL RZCDIR (PATHN, 'R')  
      NCHAR  = LENOCC (PATHN)   
      CALL DBGPID (PATHN, NCHAR, TOPN, IDN) 
      IF (IDN.LE.0) THEN    
        IQUEST(1) = 182 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRNAM : Illegal'//    
     +  ' path name '//PATHN//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
*   
* *** Set the current directory to DICTIONARY and retrieve object   
*   
      NCH    = LENOCC (TOPN)    
      PATHD  = '//'//TOPN(1:NCH)//'/DICTIONARY' 
      CALL RZCDIR (PATHD, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 201 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRNAM : Path na'//    
     +  'me '//PATHD(1:NCH)//' not found'')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKEYT   
      ISTP   = NWKYDK + 1   
      IPNT   = KOFSDB + LCDRDB + IKDRDB 
      KPNT   = IUHUNT (IDN, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP) 
      IF (KPNT.LE.0) THEN   
        IQUEST(1) = 202 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRNAM : No info'//    
     +  'rmation for '//PATHN(1:NCHAR)//' inside Data Base'')',IARGDB,0)    
        GO TO 999   
      ENDIF 
      KEY1S  = (KPNT - MSERDB) / ISTP + 1   
      CALL VZERO_i (KEYVDK, NWKYDK)   
      KEYVDK(MSERDB) = KEY1S    
      IF (LSTRDL(1).NE.0) THEN  
        CALL MZDROP (IDISDB, LSTRDL(1), 'L')    
        LSTRDL(1) = 0   
      ENDIF 
      IOLD1  = IOKYDA(MSERDB)   
      IOLDK  = IOPKDA   
      IOPKDA = 0    
      IOKYDA(MSERDB) = 1    
      ITIME  = 1    
      CALL DBKXIN (ITIME, IDISDB, LSTRDL(1), LSTRDL(1), 2, NWKYDK,  
     +             KEYVDK, IPREC)   
      IER    = IQUEST(1)    
      IOPKDA = IOLDK    
      IOKYDA(MSERDB) = IOLD1    
      IF (IER.NE.0) THEN    
        CALL MZDROP (IDISDB, LSTRDL(1), 'L')    
        IQUEST(1) = IER 
        GO TO 999   
      ENDIF 
*   
* *** Now store the information in the user array   
*   
      IPNT   = KOFUDB + LSTRDL(1)   
      NWDS   = IQ(IPNT-1) / 2   
      NWMAX  = MIN0 (NWDS, NWMAX)   
      DO 10 I = 1, NWMAX    
        CALL UHTOC (IQ(IPNT+1), 4, CTAG, 8) 
        CHTAG(I) = CTAG 
        IPNT   = IPNT + 2   
   10 CONTINUE  
      CALL MZDROP (IDISDB, LSTRDL(1), 'L')  
      LSTRDL(1) = 0 
      IQUEST(1) = 0 
*                                                             END DBRNAM    
  999 END   
      SUBROUTINE DBRTFZ (PATHI, LUNFZ, K1MIN, K1MAX, CHOPT) 
*     ===================================================== 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBRTFZ (PATHI, LUNFZ, K1MIN, K1MAX, CHOPT)              *    
*                                                                      *    
*   Copies a part of the directory (in the range K1MIN-K1MAX) into a   *    
*   sequential file in the format of the journal file                  *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHI    Character string describing the input  pathname         *    
*     LUNFZ    Logical unit number of the output FZ file               *    
*     K1MIN    Minumum serial number (Key 1 value) to be copied        *    
*     K1MAX    Maximum serial number (Key 1 value) to be copied        *    
*     CHOPT    Character string with any of the following characters   *    
*          F   Updates with a fully matched data object (in user keys) *    
*                                                                      *    
*   Called by user,   DBAUXI                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 71 : Illegal path name                               *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (NSVMDS=50, NSAVDS=20, MXDMDS=100)    
      COMMON /DSAVBK/ NOBJDS, LOBJDS(NSVMDS), KEYSDS(MXDMDS,NSVMDS) 
*   
      COMMON /DZPACK/ PRECDZ, PACKDZ    
      LOGICAL         PACKDZ    
*   
      CHARACTER       PATHY*80, PATH*80, PATHX*16, CHOPS*4  
      CHARACTER       PATHI*(*), CHOPT*(*)  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension ixx(1)
*     ------------------------------------------------------------------    
*   
* *** Suppress blanks from the path name    
*   
      CALL DBOPTS (' ') 
      CALL UOPTC  (CHOPT, 'F', IOPFDA)  
      CALL DBSBLC (PATHI, PATH, NCHRI)  
      LUFZDF = LUNFZ    
      IF (LUFZDF.LE.0)             GO TO 999    
      IF (K1MIN.LT.1) THEN  
        KYMIN  = 1  
      ELSE  
        KYMIN  = K1MIN  
      ENDIF 
      IF (K1MAX.LT.KYMIN) THEN  
        KYMAX  = KYMIN + 100000 
      ELSE  
        KYMAX  = K1MAX  
      ENDIF 
*   
* *** Set the current directory for input path name 
*   
      PATHX  = ' '  
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 71  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRTFZ : Illegal'//    
     +  ' Path Name '//PATH//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      KST    = NWKYDK + 1   
      IF (NKEYDK.LE.0)             GO TO 999    
      CALL RZCDIR (PATH, 'R')   
      NCHRI  = LENOCC (PATH)    
      CALL DBKEYT   
      IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)  
      IOPTP  = JBIT (IOPTP, JPRTDB) 
*   
* *** Partially fill up the header  
*   
      NDOP   = 1    
      NWDP   = (NCHRI + 3) / 4  
      NWHEDF = NWDP + NDOP + NWKYDK + 5 
      IHEADF(MACTDF) = 1    
      IHEADF(MNKYDF) = NWKYDK   
      IHEADF(MOPTDF) = NDOP 
      IHEADF(MPATDF) = NWDP 
      CALL UCTOH (PATH, IHEADF(MPREDF+NWKYDK+NDOP+1), 4, 4*NWDP)    
*   
* *** Start reading in records from the input file  
*   
      ITIME  = 1    
      JBIAS  = 2    
      NOBJDS = 0    
      IF (IOPTP.EQ.0) THEN  
        DO 20 IK = 1, NKEYDK    
          KEY1   = IQ(KOFSDB+LCDRDB+IKDRDB+(IK-1)*KST+MSERDB)   
          IF (KEY1.GE.KYMIN.AND.KEY1.LE.KYMAX) THEN 
            IOPKDA = 0  
            PACKDZ = .FALSE.    
            NOBJDS = 1  
            KEYSDS(MSERDB,NOBJDS) = IK  
            IOKYDA(MSERDB) = 1  
            CALL DBKXIN (ITIME, IDISDB, LOBJDS(NOBJDS), LOBJDS(NOBJDS), 
     +                   JBIAS, NWKEY, KEYSDS(1,NOBJDS), IPREC) 
            IOKYDA(MSERDB) = 0  
            IF (IQUEST(1).NE.0)    GO TO 997    
            IF (JBIT(KEYSDS(MFLGDB,NOBJDS),JRZUDB).NE.0) THEN   
              IF (JBIT(KEYSDS(MFLGDB,NOBJDS),JASFDB).NE.0) THEN 
                CHOPS  = '7RT'  
              ELSE  
                CHOPS  = '7R'   
              ENDIF 
            ELSE    
              CALL DBRZIN (IDISDB, LSTRDL(2), 2, IK, ICYCL, PATH)   
              IF (IQUEST(1).NE.0) THEN  
                IER       = IQUEST(1)   
                CALL MZDROP (IDISDB, LSTRDL(2), 'L')    
                IQUEST(1) = IER 
                GO TO 997   
              ENDIF 
              CALL UCOPY_i (iQ(KOFUDB+LSTRDL(2)+3), IXX, 1)    
              IF (IQ(KOFUDB+LSTRDL(2)+1).EQ.0) THEN 
                IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN    
                  CHOPS  = '7SU'    
                ELSE    
                  CHOPS  = '7U' 
                ENDIF   
              ELSE  
                PACKDZ = (JBIT(IXX(1),32).EQ.0)    
                IF (PACKDZ) THEN    
                  IDTY   = IDBTYP (LSTRDL(2))   
                  IF (IDTY.EQ.3) THEN   
                    PRECDZ =  Q(KOFUDB+LSTRDL(2)+2) 
                  ELSE  
                    PRECDZ = IQ(KOFUDB+LSTRDL(2)+2) 
                  ENDIF 
                  IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN  
                    CHOPS  = '7ZS'  
                  ELSE  
                    CHOPS  = '7Z'   
                  ENDIF 
                ELSE    
                  IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN  
                    CHOPS  = '7S'   
                  ELSE  
                    CHOPS  = '7'    
                  ENDIF 
                ENDIF   
              ENDIF 
              CALL MZDROP (IDISDB, LSTRDL(2), 'L')  
            ENDIF   
            CALL DBFZWR (IPREC, CHOPS)  
            IERR   = IQUEST(1)  
            CALL MZDROP (IDISDB, LOBJDS(NOBJDS), 'L')   
            NOBJDS = 0  
            IQUEST(1) = IERR    
            IF (IQUEST(1).NE.0)    GO TO 997    
          ENDIF 
   20   CONTINUE    
*   
      ELSE  
*   
*   **  Partitioned directory   
*   
        NKEYS  = NKEYDK 
        DO 30 IKK = 1, NKEYS    
          KPNT   = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),    
     +                     NKEYS*KST, KST)  
          IF (KPNT.GT.0) THEN   
            KPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB   
          ELSE  
            KPNT   = KOFSDB + LCDRDB + IKDRDB + (IKK - 1) * KST 
          ENDIF 
          KYMP   = IQ(KPNT+MOBJDB)  
          IF (KYMP.GT.KYMAX)       GO TO 30 
          CALL DBPATH (PATHX, IKK)  
          PATHY  = PATH(1:NCHRI)//'/'//PATHX    
          CALL RZCDIR (PATHY, ' ')  
          IF (IQUEST(1).NE.0) THEN  
            IQUEST(1) = 71  
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRTFZ : Ill'//    
     +      'egal Path Name '//PATHY//''')', IARGDB, 0) 
            GO TO 999   
          ENDIF 
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          DO 25 IK = 1, NKEYDK  
            KEY1   = IQ(KOFSDB+LCDRDB+IKDRDB+(IK-1)*KST+MSERDB) 
            IF (KEY1.GE.KYMIN.AND.KEY1.LE.KYMAX) THEN   
              IOPKDA = 0    
              PACKDZ = .FALSE.  
              NOBJDS = 1    
              KEYSDS(MSERDB,NOBJDS) = IK    
              IOKYDA(MSERDB) = 1    
              CALL DBKXIN (ITIME, IDISDB, LOBJDS(NOBJDS),LOBJDS(NOBJDS),    
     +                     JBIAS, NWKEY, KEYSDS(1,NOBJDS), IPREC)   
              IOKYDA(MSERDB) = 0    
              IF (IQUEST(1).NE.0)  GO TO 997    
              IF (JBIT(KEYSDS(MFLGDB,NOBJDS),JRZUDB).NE.0) THEN 
                IF (JBIT(KEYSDS(MFLGDB,NOBJDS),JASFDB).NE.0) THEN   
                  CHOPS  = '7RT'    
                ELSE    
                  CHOPS  = '7R' 
                ENDIF   
              ELSE  
                CALL DBRZIN (IDISDB, LSTRDL(2), 2, IK, ICYCL, PATHY)    
                IF (IQUEST(1).NE.0) THEN    
                  IER    = IQUEST(1)    
                  CALL MZDROP (IDISDB, LSTRDL(2), 'L')  
                  IQUEST(1) = IER   
                  GO TO 997 
                ENDIF   
                CALL UCOPY_i (iQ(KOFUDB+LSTRDL(2)+3), IXX, 1)  
                IF (IQ(KOFUDB+LSTRDL(2)+1).EQ.0) THEN   
                  IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN  
                    CHOPS  = '7SU'  
                  ELSE  
                    CHOPS  = '7U'   
                  ENDIF 
                ELSE    
                  PACKDZ = (JBIT(IXX(1),32).EQ.0)  
                  IF (PACKDZ) THEN  
                    IDTY   = IDBTYP (LSTRDL(2)) 
                    IF (IDTY.EQ.3) THEN 
                      PRECDZ =  Q(KOFUDB+LSTRDL(2)+2)   
                    ELSE    
                      PRECDZ = IQ(KOFUDB+LSTRDL(2)+2)   
                    ENDIF   
                    IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN    
                      CHOPS  = '7ZS'    
                    ELSE    
                      CHOPS  = '7Z' 
                    ENDIF   
                  ELSE  
                    IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN    
                      CHOPS  = '7S' 
                    ELSE    
                      CHOPS  = '7'  
                    ENDIF   
                  ENDIF 
                ENDIF   
                CALL MZDROP (IDISDB, LSTRDL(2), 'L')    
              ENDIF 
              CALL DBFZWR (IPREC, CHOPS)    
              IERR   = IQUEST(1)    
              CALL MZDROP (IDISDB, LOBJDS(NOBJDS), 'L') 
              NOBJDS = 0    
              IQUEST(1) = IERR  
              IF (IQUEST(1).NE.0)  GO TO 997    
            ENDIF   
   25     CONTINUE  
*   
          CALL RZCDIR (PATH, ' ')   
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
   30   CONTINUE    
*   
      ENDIF 
*   
* *** Drop the stored banks 
*   
  997 IER    = IQUEST(1)    
      IF (NOBJDS.GT.0) THEN 
        DO 998 IOBJ = 1, NOBJDS 
          CALL MZDROP (IDISDB, LOBJDS(IOBJ), 'L')   
  998   CONTINUE    
        NOBJDS = 0  
        IQUEST(1) = IER 
      ENDIF 
*                                                             END DBRTFZ    
  999 END   
      SUBROUTINE DBSAVE 
*     ================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBSAVE                                                  *    
*                                                                      *    
*   Sends the spool file to the server for updating the data base.     *    
*   Useful only for interactive programs running on IBM                *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
*     ------------------------------------------------------------------    
*   
      IQUEST(1) = 0 
*                                                             END DBSAVE    
      END   
      SUBROUTINE DBSRTM (PATHN, MNDAT, MNTIM, MXDAT, MXTIM, IUDIV, LSUP,    
     +                   IPREC) 
*     ==================================================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBSRTM (PATHN, MNDAT, MNTIM, MXDAT, MXTIM, IUDIV, LSUP*,*    
*                      IPREC*)                                         *    
*                                                                      *    
*   Fetches from disk to memory an object inserted between certain     *    
*   time                                                               *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     MNDAT    Minimum date for insertion                              *    
*     MNTIM    Minimum time for insertion                              *    
*     MXDAT    Maximum date for insertion                              *    
*     MXTIM    Maximum time for insertion                              *    
*     IUDIV    Division index where bank is expected                   *    
*     LSUP(*)  Address of the bank in memory                           *    
*     IPREC(*) Precision word; (If IPREC > 0, data are stored with     *    
*              IPREC significant digits right to the decimal points; if*    
*              IPREC < 0, data are stored with IPREC insignificant     *    
*              digits left to the decimal point.)                      *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 31 : Illegal path name                               *    
*               = 32 : No keys/data in this directory                  *    
*               = 33 : No valid data for the given range of insertion  *    
*                      time                                            *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      DIMENSION       LSUP(9)   
      CHARACTER       PATHN*(*), PATH*80, PATHX*16  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
* *** Initialise the option array   
*   
      CALL DBOPTS (' ') 
      IF (IQUEST(1).NE.0)     GO TO 999 
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Set the current directory 
*   
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0)     GO TO 991 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKEYT   
      CALL RZCDIR (PATH, 'R')   
      NCHAR  = INDEX (PATH, ' ') - 1    
      IF (NCHAR.LT.1.OR.NCHAR.GT.MAXLDB) NCHAR = MAXLDB 
      ITIME  = 0    
      JBIAS  = 2    
*   
* *** Check the number of keys  
*   
      IF (NKEYDK.EQ.0)        GO TO 992 
*   
* *** Check the validity limits from the Keys   
*   
      IOKYDA(MSERDB) = 1    
      MRET   = 0    
      IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)  
      IOPTP  = JBIT (IOPTP, JPRTDB) 
      ISTP   = NWKYDK + 1   
*   
      IF (IOPTP.EQ.0)  THEN 
*   
*  **   For non-partitioned dataset 
*   
        DO 20 IK = 1, NKEYDK    
*   
          IPNT   = KOFSDB + LCDRDB + IKDRDB + (IK-1) * ISTP 
          CALL DBUPTM (IDATE, ITIME, IQ(IPNT+MITMDB))   
          IF ((IDATE.GT.MNDAT.AND.IDATE.LT.MXDAT) .OR.  
     +        (IDATE.EQ.MNDAT.AND.ITIME.GE.MNTIM.AND.MNDAT.NE.MXDAT).OR.    
     +        (IDATE.EQ.MXDAT.AND.ITIME.LE.MXTIM.AND.MNDAT.NE.MXDAT).OR.    
     +        (IDATE.EQ.MNDAT.AND.ITIME.GE.MNTIM.AND.ITIME.LE.MXTIM.AND.    
     +         MNDAT.EQ.MXDAT))  THEN   
*   
            IF (MRET.NE.0.AND.MRET.LT.IQ(IPNT+MITMDB))  THEN    
              IF (LSUP(1).NE.0)  THEN   
                CALL MZDROP (IUDIV, LSUP(1), ' ')  
                LSUP(1) = 0 
              ENDIF 
              CALL VZERO_i (KEYVDK, NWKYDK)   
              KEYVDK(MSERDB) = IK   
              CALL DBKXIN (ITIME, IUDIV, LSUP(1), LSUP(1), JBIAS, NWKEY,    
     +                     KEYVDK, IPREC)   
*   
              IF (IQUEST(1).EQ.0)  THEN 
                MRET   = KEYVDK(MITMDB) 
                IF (IDEBDB.GT.1) THEN   
                  CALL UCOPY_i (KEYVDK(1), IARGDB, 5) 
                  IARGDB(6) = IDATE 
                  IARGDB(7) = ITIME 
                  CALL DBPRNT (LPRTDB, '(/,'' DBSRTM : Data with Ke'//  
     +                 'y'',2I8,2I10,I6,'' retrieved for '//PATH(1:40)  
     +                 //''',/,10X,''Created on the '',I8,'' at '','//  
     +                 'I6)', IARGDB, 7)    
                ENDIF   
*   
              ELSE  
                MRET   = 0  
                IF (LSUP(1).NE.0) THEN  
                  CALL MZDROP (IUDIV, LSUP(1), ' ')    
                  LSUP(1) = 0   
                ENDIF   
*   
              ENDIF 
            ENDIF   
*   
          ENDIF 
*   
   20   CONTINUE    
*   
      ELSE  
*   
*  **   For partitioned dataset 
*   
        NKEYS  = NKEYDK 
        KST    = NWKYDK + 1 
        DO 40 JK = 1, NKEYS 
          ICURDT = NKEYS + 1 - JK   
*   
          CALL RZCDIR (PATH, ' ')   
          IF (IQUEST(1).NE.0) GO TO 991 
          NWKYDK = IQUEST(8)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          KPNT   = IUHUNT (ICURDT, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB), 
     +                     NKEYS*KST, KST)  
          IF (KPNT.NE.0) THEN   
            IPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB   
          ELSE  
            IPNT   = KOFSDB + LCDRDB + IKDRDB + (ICURDT - 1) * KST  
          ENDIF 
          CALL DBUPTM (IDATE, ITIME, IQ(IPNT+MITMDB))   
          IF ((IDATE.LT.MNDAT).OR.(IDATE.EQ.MNDAT.AND.ITIME.LT.MNTIM))  
     +                        GO TO 40  
*   
          CALL DBPATH (PATHX, ICURDT)   
          CALL RZCDIR (PATHX, ' ')  
          IF (IQUEST(1).EQ.0)  THEN 
            IQUEST(1) = 31  
            PATH   = PATH(1:NCHAR)//'/'//PATHX  
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBSRTM : Ill'//    
     +      'egal Path Name '//PATH//''')', IARGDB, 0)  
            IOKYDA(MSERDB) = 0  
            GO TO 999   
          ENDIF 
          NKEYDK = IQUEST(7)    
          NWKYDK = IQUEST(8)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          ISTP   = NWKYDK + 1   
          CALL DBKEYT   
          DO 30 IK = 1, NKEYDK  
            IPNT   = KOFSDB + LCDRDB + IKDRDB + (IK-1) * ISTP   
            CALL DBUPTM (IDATE, ITIME, IQ(IPNT+MITMDB)) 
            IF ((IDATE.GT.MNDAT.AND.IDATE.LT.MXDAT) .OR.    
     +          (IDATE.EQ.MNDAT.AND.ITIME.GE.MNTIM.AND.MNDAT.NE.MXDAT)  
     +      .OR.(IDATE.EQ.MXDAT.AND.ITIME.LE.MXTIM.AND.MNDAT.NE.MXDAT)  
     +      .OR.(IDATE.EQ.MNDAT.AND.ITIME.GE.MNTIM.AND.ITIME.LE.MXTIM   
     +           .AND.MNDAT.EQ.MXDAT))  THEN    
*   
              IF (MRET.NE.0.AND.MRET.LT.IQ(IPNT+MITMDB))  THEN  
                IF (LSUP(1).NE.0)  THEN 
                  CALL MZDROP (IUDIV, LSUP(1), ' ')    
                  LSUP(1) = 0   
                ENDIF   
                CALL VZERO_i (KEYVDK, NWKYDK) 
                KEYVDK(MSERDB) = IK 
                CALL DBKXIN (ITIME, IUDIV, LSUP(1), LSUP(1), JBIAS, 
     +                       NWKEY, KEYVDK, IPREC)  
*   
                IF (IQUEST(1).EQ.0)  THEN   
*   
                  MRET   = KEYVDK(MITMDB)   
                  IF (IDEBDB.GT.1) THEN 
                    CALL UCOPY_i (KEYVDK(1), IARGDB, 5)   
                    IARGDB(6) = IDATE   
                    IARGDB(7) = ITIME   
                    CALL DBPRNT (LPRTDB, '(/,'' DBSRTM : Data with Ke'//    
     +                   'y'',2I8,2I10,I6,'' retrieved for '//PATH(1:40)    
     +                   //''',/,10X,''Created on the '',I8,'' at '','//    
     +                   'I6)', IARGDB, 7)  
                  ENDIF 
*   
                ELSE    
*   
                  MRET   = 0    
                  IF (LSUP(1).NE.0) THEN    
                    CALL MZDROP (IUDIV, LSUP(1), ' ')  
                    LSUP(1) = 0 
                  ENDIF 
*   
                ENDIF   
              ENDIF 
*   
            ENDIF   
*   
   30     CONTINUE  
*   
          IF (MRET.NE.0)      GO TO 50  
   40   CONTINUE    
*   
      ENDIF 
   50 IOKYDA(MSERDB) = 0    
      IF (MRET.EQ.0)          GO TO 993 
      GO TO 999 
*   
* *** Error messages    
*   
  991 IQUEST(1) = 31    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBSRTM : Illegal '// 
     +   'Path Name '//PATH//''')', IARGDB, 0)  
      IOKYDA(MSERDB) = 0    
      GO TO 999 
*   
  992 IQUEST(1) = 32    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBSRTM : No key or'//    
     +   ' data for Path Name '//PATH//''')', IARGDB, 0)    
      GO TO 999 
*   
  993 IQUEST(1) = 33    
      IF (IDEBDB.GT.0) THEN 
        IARGDB(1) = MNDAT   
        IARGDB(2) = MNTIM   
        IARGDB(3) = MXDAT   
        IARGDB(4) = MXTIM   
        CALL DBPRNT (LPRTDB, '(/,'' DBSRTM : No data in '//PATH(1:40)// 
     +       ' inserted between '',2I8,'' and '',2I8)', IARGDB, 4)  
      ENDIF 
      GO TO 999 
*                                                             END DBSRTM    
  999 END   
      SUBROUTINE DBTBCR (IUDIV, LAD, LSUP, JBIAS)   
*     ===========================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBTBCR (IUDIV, LAD*, LSUP, JBIAS)                       *    
*                                                                      *    
*   Creates DBTB bank with information of the data base objects used   *    
*   for this event (till the last call to DBTBCR). It stores 2 words   *    
*   per object used, a unique identifier corresponding to the path     *    
*   name and the serial number of the object (KEY(1) value)            *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IUDIV    User division where the DBTB bank has to be created     *    
*     LAD(*)   Address of the DBTB bank (should be in the same store   *    
*              as all DB objects)                                      *    
*     LSUP     Address of the supporting bank                          *    
*     JBIAS    Link bias as described in ZEBRA manual                  *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (NLEVM=20, NDMAX=100) 
      DIMENSION       LSUP(9), LAD(9), ISDI(NLEVM), NSDI(NLEVM) 
*
      dimension nio(9)
*     ------------------------------------------------------------------    
*   
* *** Loop over all top directories 
*   
      LREFDB(1) = LSUP(1)   
      NDAT   = 0    
      LBFXDB = LTOPDB   
   10 IF (LBFXDB.GT.0) THEN 
        NLEV   = 0  
        LBNODB = LQ(KOFUDB+LBFXDB-1)    
*   
*  **   Scan down the nodes to find all the subdirectories  
*   
   15   IF (LBNODB.GT.0) THEN   
          NLEV   = NLEV + 1 
          ISDI(NLEV) = 0    
          NSDI(NLEV) = IQ(KOFUDB+LBNODB-KLNODB) 
*   
   20     ISDI(NLEV) = ISDI(NLEV) + 1   
          IF (ISDI(NLEV).LE.NSDI(NLEV)) THEN    
*   
*  **       If a new subdirectory go down one level 
*   
            LBD    = LQ(KOFUDB+LBNODB-ISDI(NLEV))   
            IF (LBD.GT.0) THEN  
              LBNODB = LBD  
              GO TO 15  
            ELSE    
              GO TO 20  
            ENDIF   
*   
          ELSE  
*   
*  **       Loop over all the key banks 
*   
            NDK    = IQ(KOFUDB+LBNODB+MNDNWD)   
            IDIC   = IQ(KOFUDB+LBNODB+MNDDIC)   
            LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)   
   25       IF (LBKYDB.GT.0) THEN   
              IF (IQ(KOFUDB+LBKYDB+NDK+MKYCEV).GT.0) THEN   
                IF (NDAT.EQ.0) THEN 
                  NDTOT  = NDMAX
                  nio(1) = 2
                  CALL DBBOOK (IUDIV, LAD(1), LREFDB(1), JBIAS, 'DBTB', 
     +                         0, 0, NDTOT, nio, -1)  
                  IF (IQUEST(1).NE.0) GO TO 999 
                  LREFDB(2) = LAD(1)    
                ELSE IF (NDAT.GE.NDTOT) THEN    
                  NDTOT  = NDTOT + NDMAX
                  nio(1) = 2
                  CALL DBBOOK (IUDIV, LAD(1), LREFDB(1), JBIAS, 'DBTB', 
     +                         0, 0, NDTOT, nio, -1)  
                  IF (IQUEST(1).NE.0) GO TO 999 
                  LREFDB(2) = LAD(1)    
                  LBD    = LQ(KOFUDB+LREFDB(1)) 
                  CALL UCOPY_i (IQ(KOFUDB+LBD+1), IQ(KOFUDB+LREFDB(2)+1)
     &                 ,NDAT)
                  CALL MZDROP (IUDIV, LBD, 'L') 
                ENDIF   
                IQ(KOFUDB+LREFDB(2)+NDAT+1) = IDIC  
                IQ(KOFUDB+LREFDB(2)+NDAT+2) = IQ(KOFUDB+LBKYDB+MSERDB)  
                NDAT   = NDAT + 2   
                IQ(KOFUDB+LBKYDB+NDK+MKYCEV)  = 0   
              ENDIF 
              LBKYDB = LQ(KOFUDB+LBKYDB)    
              GO TO 25  
            ENDIF   
*   
*  **       Now go up one level 
*   
   30       NLEV   = NLEV - 1   
            IF (NLEV.GT.0) THEN 
              LBNODB = LQ(KOFUDB+LBNODB+1)  
              GO TO 20  
            ENDIF   
          ENDIF 
        ENDIF   
*   
        LBFXDB = LQ(KOFUDB+LBFXDB)  
        GO TO 10    
      ENDIF 
*   
* *** Now shrink DBTB bank if needed    
*   
      IF (NDAT.GT.0) THEN   
        IF (NDAT.LT.NDTOT) THEN 
          NDPUS  = NDAT - NDTOT 
          CALL MZPUSH (IUDIV, LREFDB(2), 0, NDPUS, 'I') 
        ENDIF   
      ENDIF 
*   
      IQUEST(1) = 0 
*                                                             END DBTBCR    
  999 END   
      SUBROUTINE DBTBPR 
*     ================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBTBPR                                                  *    
*                                                                      *    
*   Prints accumulated summary for the given run with the Data Base    *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 98 : Invalid path name in Node bank                  *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER     PATH*80, CHSTR*132, CFMT*136    
*   
*     ------------------------------------------------------------------    
*   
* *** Loop over all node banks  
*   
      CALL DBPRNT (LPRTDB, '(/,'' DBTBPR : Summary of Database Elemen'//    
     +     'ts used '',/,'' ========================================='//    
     +     '= '')', IARGDB, 0)  
      CALL DBPRNT (LPRTDB, '(/,20X,''Path name'',28X,''DBUSE Call/Dat'//    
     +     'a Read Key 5'',5X,''User Keys'',/)', IARGDB, 0) 
      CFMT(1:2)     = '(''' 
      CFMT(135:136) = ''')' 
      CFMT(3:134)   = ' '   
      LBFXDB = LTOPDB   
   10 IF (LBFXDB.EQ.0)        GO TO 80  
*   
      LBNODB = LQ(KOFUDB+LBFXDB-1)  
      IF (LBNODB.EQ.0)        GO TO 70  
*   
*  ** Store the number of structural links already looked   
*  ** at bank number address    
*   
   20 IQ(KOFUDB+LBNODB-5) = IQ(KOFUDB+LBNODB-2) 
*   
*  *  If all the links have not been looked at; go the next 
*  *  link  
*   
   30 IF (IQ(KOFUDB+LBNODB-5).NE.0) THEN    
        IQ(KOFUDB+LBNODB-5) = IQ(KOFUDB+LBNODB-5) - 1   
        N      = IQ(KOFUDB+LBNODB-2) - IQ(KOFUDB+LBNODB-5)  
        LBAD   = LQ(KOFUDB+LBNODB-N)    
        IF (LBAD.NE.0)  THEN    
          LBNODB = LBAD 
          GO TO 20  
        ELSE    
          GO TO 30  
        ENDIF   
*   
*  *  Otherwise look at this Node bank  
*   
      ELSE  
*   
        NDK    = IQ(KOFUDB+LBNODB+MNDNWD)   
        NCHAR  = IQ(KOFUDB+LBNODB+MNDNCH)   
        CALL UHTOC (IQ(KOFUDB+LBNODB+MNDNAM), 4, PATH, NCHAR)   
        PATH   = PATH(1:NCHAR)  
*   
        CALL RZCDIR (PATH, ' ') 
        IF (IQUEST(1).NE.0)  THEN   
          IQUEST(1) = 98    
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBTBPR : Illeg'//    
     +    'al Path name '//PATH(1:60)//' in node bank'')', IARGDB, 0)   
          GO TO 999 
        ENDIF   
*   
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        NKEYDK = IQUEST(7)  
        NWKYDK = IQUEST(8)  
        CALL DBKEYT 
*   
*  *    Loop over all key banks at this Node    
*   
        LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)   
   40   IF (LBKYDB.EQ.0)      GO TO 60  
*   
*  *    Prepare the header part 
*   
        WRITE (CHSTR, 8001) PATH, IQ(KOFUDB+LBKYDB+NDK+MKYCRU), 
     +                      IQ(KOFUDB+LBKYDB+NDK+MKYRID),   
     +                      IQ(KOFUDB+LBKYDB+MPVSDB)    
        NS1    = 84 
*   
*  *    Loop over user keys 
*   
        IF (NWKYDK.GT.NSYSDK)  THEN 
          DO 50 I = NSYSDK+1, NWKYDK    
            IF (NS1.GT.120)  THEN   
              CFMT(3:134)   = CHSTR 
              CALL DBPRNT (LPRTDB, CFMT, IARGDB, 0) 
              CHSTR  = ' '  
              NS1    = 84   
            ENDIF   
            IF (IOTYDK(I).EQ.2)  THEN   
              NS2    = NS1 + 9  
              WRITE (CHSTR(NS1:NS2), 8002) IQ(KOFUDB+LBKYDB+I)  
            ELSE IF (IOTYDK(I).EQ.5 .OR. IOTYDK(I).EQ.6)  THEN  
              NS2    = NS1 + 7  
              WRITE (CHSTR(NS1:NS2), 8003) IQ(KOFUDB+LBKYDB+I)  
            ELSE    
              NS2    = NS1 + 9  
              WRITE (CHSTR(NS1:NS2), 8004) IQ(KOFUDB+LBKYDB+I)  
            ENDIF   
            NS1    = NS1 + 12   
   50     CONTINUE  
        ENDIF   
*   
        CFMT(3:134)   = CHSTR   
        CALL DBPRNT (LPRTDB, CFMT, IARGDB, 0)   
*   
        LBKYDB = LQ(KOFUDB+LBKYDB)  
        GO TO 40    
*   
   60   LBNODB = LQ(KOFUDB+LBNODB+1)    
        IF (LBNODB.NE.LBFXDB) GO TO 30  
      ENDIF 
*   
   70 LBFXDB = LQ(KOFUDB+LBFXDB)    
      GO TO 10  
   80 CONTINUE  
*   
 8001 FORMAT (1X,A56,2I10,I6)   
 8002 FORMAT (I10)  
 8003 FORMAT (4X,A4)    
 8004 FORMAT (Z10)  
*                                                             END DBTBPR    
  999 END   
      SUBROUTINE DBUPTM (IDATE, ITIME, IDATM)   
*     =======================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBUPTM (IDATE*, ITIME*, IDATM)                          *    
*                                                                      *    
*   Unpacks date and time from one word                                *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IDATE*   Date : 6 Decimal integer : YYMMDD                       *    
*     ITIME*   Time : 4 Decimal integer : HHMM                         *    
*     IDATM    Packed date-time                                        *    
*                                                                      *    
*   Called by user,   DBFZUP, DBLKEY, DBNTOP, DBPRGD, DBSRTM, DBENFZ,  *    
*             DBPLOB, DBDKYH, DBDKYV                                   *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXSEC=61, MXMIN=61, MXHOU=25, MXDAY=32, MXMON=13)    
      INTEGER         IDAYY(20), IDAYM(12,2)    
      SAVE            IDAYY, IDAYM  
      DATA            IDAYY / 366,  731, 1096, 1461, 1827, 2192, 2557,  
     1                       2922, 3288, 3653, 4018, 4383, 4749, 5114,  
     2                       5479, 5844, 6210, 6575, 6940, 7305/    
      DATA            IDAYM / 0,  31,  59,  90, 120, 151, 181, 212, 243,    
     1                      273, 304, 334,   0,  31,  60,  91, 121, 152,    
     2                      182, 213, 244, 274, 305, 335/   
*   
*     ------------------------------------------------------------------    
*   
      III  = IDATM  
      IMIN = MOD(III,MXMIN) 
      III  = (III-IMIN)/MXMIN   
      IHOU = MOD(III,MXHOU) 
      III  = (III-IHOU)/MXHOU   
      IDAY = MOD(III,MXDAY) 
      III  = (III-IDAY)/MXDAY   
      IMON = MOD(III,MXMON) 
      IYEA = (III-IMON)/MXMON   
*   
      IDATE = IDAY + 100*IMON + 10000*IYEA  
      ITIME = IMIN + 100*IHOU   
*                                                             END DBUPTM    
      END   
      SUBROUTINE DBUPTS (IDATE, ITIME, IDATM)   
*     =======================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBUPTS (IDATE*, ITIME*, IDATM)                          *    
*                                                                      *    
*   Unpacks date and time from one word                                *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IDATE*   Date : 6 Decimal integer : YYMMDD                       *    
*     ITIME*   Time : 6 Decimal integer : HHMMSS                       *    
*     IDATM    Packed date-time                                        *    
*                                                                      *    
*   Called by user,   DBPLOB, DBPLOV, DBPLTI, DBAUXI, DBDISD, DBDKYH,  *    
*             DBDKYV                                                   *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXSEC=61, MXMIN=61, MXHOU=25, MXDAY=32, MXMON=13)    
      INTEGER         IDAYY(20), IDAYM(12,2)    
      SAVE            IDAYY, IDAYM  
      DATA            IDAYY / 366,  731, 1096, 1461, 1827, 2192, 2557,  
     1                       2922, 3288, 3653, 4018, 4383, 4749, 5114,  
     2                       5479, 5844, 6210, 6575, 6940, 7305/    
      DATA            IDAYM / 0,  31,  59,  90, 120, 151, 181, 212, 243,    
     1                      273, 304, 334,   0,  31,  60,  91, 121, 152,    
     2                      182, 213, 244, 274, 305, 335/   
*   
*     ------------------------------------------------------------------    
*   
      III  = IDATM  
      ISEC = MOD(III,MXSEC) 
      III  = (III-ISEC)/MXSEC   
      IMIN = MOD(III,MXMIN) 
      III  = (III-IMIN)/MXMIN   
      IHOU = MOD(III,MXHOU) 
      III  = (III-IHOU)/MXHOU   
      IDAY = MOD(III,MXDAY) 
      III  = (III-IDAY)/MXDAY   
      IMON = MOD(III,MXMON) 
      IYEA = (III-IMON)/MXMON   
*   
      IDATE = IDAY + 100*IMON + 10000*(IYEA + 80)   
      ITIME = ISEC + 100*IMIN + 10000*IHOU  
*                                                             END DBUPTS    
      END   
      SUBROUTINE DBUSE (PATHN, LBK, LBD, ITIME, KEYS, CHOPT)    
*     ======================================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBUSE (PATHN, *LBK*, LBD*, ITIME, KEYS, CHOPT)          *    
*                                                                      *    
*   Prepares the database data structure in memory for any required    *    
*   Pathname and set of Keys, unless already done.                     *    
*   Returns (optionally) the addresses in memory for the corresponding *    
*   Key banks and Data banks after checking their validity for the     *    
*   given time and keys.                                               *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     LBK(*)   Address(es) of Keys bank(s) KYDB   (INPUT or OUTPUT)    *    
*              For option 'S' it is the support address of the linear  *    
*              structure                                               *    
*              For option 'M' with selection on user keys 8 and 9,     *    
*              LBK(k) is the address corresponding to the ith Key-8    *    
*              and the jth Key-9 value, where k = KEYS(8) * (j-1) + i  *    
*     LBD(*)   Address(es) of Data bank(s) DADB                        *    
*              For option 'S' the address of the databank can only be  *    
*              obtained from the actual key-address: LK  of the linear *    
*              structure as LBD = LQ(LBK-1)                            *    
*     ITIME    Event data acquisition time (or 0, if Data not wanted)  *    
*     KEYS     Vector of keys. Only the elements declared in CHOPT are *    
*              assumed to contain useful information.                  *    
*              When option 'M' is declared KEYS(n) (when user Key n    *    
*              is selected should contain the number of data objects   *    
*              to be retrieved according to the KEYS(n) values and     *    
*              the values of the key elements for Key-n to be matched  *    
*              should be stored in successive KEYS(i) elements, with   *    
*              i starting from NWKEY+1 (NWKEY is the number of key     *    
*              elements for this directory)                            *    
*     CHOPT    Character string with any of the following characters   *    
*          A   trust LBK address(es) if non-zero                       *    
*          K   read only the keys (no data is required)                *    
*          M   expect multiple Key banks to be returned (only up to    *    
*              a maximum of 5 user keys)                               *    
*          S   expect multiple Key banks satisfying selection on a     *    
*              number of keys (Options S and M are mutually exclusive) *    
*          V   declare the Data as being different in size to what is  *    
*              already resident in memory                              *    
*          3   selects objects with start validity time < KEYS(3)      *    
*              (with option S)                                         *    
*          4   selects objects with end validity time > KEYS(4)        *    
*              (with option S)                                         *    
*          5   specific Program version number required                *    
*          7   select objects with insertion time < KEYS(7)            *    
*          n   consider user key n (where 7 < n < 29 )                 *    
*                                                                      *    
*   Called by user,   DBJOIN, DBVWPR                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =  1 : Illegal character option                        *    
*               =  2 : Illegal path name                               *    
*               =  3 : Data base structure in memory clobbered         *    
*               =  4 : Illegal key option                              *    
*                                                                      *    
*     If IQUEST(1) =0, IQUEST(2) carries information whether data      *    
*     part had been actually read from the disk or not                 *    
*     IQUEST(2) =  0 : No disk i/o has been performed                  *    
*               =  1 : Data have been refreshed from the disk          *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
*     (Arbitary dimension 9 to force transmission by address for scalar)    
      DIMENSION       KEYS(9), LBD(9), LBK(9)   
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, FPATH*80   
*   
*     ------------------------------------------------------------------    
*   
* *** Initialize options    
*   
C ACP_data_retrieval_start  
      LREFDB(1) = LBK(1)    
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)       GO TO 999   
      IF (IOPMDA.NE.0 .AND. IOPSDA.NE.0) THEN   
        IQUEST(1) = 1   
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUSE : Illegal '//    
     +  'Character option - S/M options are mutually exclusive'')', 
     +  IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Create (or complete) database skeleton in memory  
*                       (banks NODB and KYDB)   
*   
      IF (ITIME.EQ.0 .OR. IOPADA.EQ.0. OR.  
     +   (IOPADA.NE.0. AND. LREFDB(1).EQ.0) )  THEN 
*   
        CALL DBNODE (PATH, LBNODB)  
        IF (IQUEST(1).NE.0)     GO TO 999   
*   
        CALL DBKEYS (LBNODB, KEYS, LBK, ITIME)  
        IF (IQUEST(1).NE.0)     GO TO 999   
        LREFDB(1) = LBK(1)  
*   
*  *    That's it, when only initialisation required    
*   
        IQUEST(2) = 0   
        IF (ITIME.EQ.0)         GO TO 999   
*   
      ELSE  
*   
        CALL RZCDIR (PATH, ' ') 
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1) = 2 
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUSE : Illeg'// 
     +    'al path name '//PATH//''')', IARGDB, 0)  
          GO TO 999 
        ENDIF   
        NKEYDK = IQUEST(7)  
        NWKYDK = IQUEST(8)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
*   
        IF (IOPSDA.NE.0)  THEN  
          LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)  
          CALL DBKEYS (LBNODB, KEYS, LBK(1), ITIME) 
          IF (IQUEST(1).NE.0)   GO TO 999   
          LREFDB(1) = LBK(1)    
        ENDIF   
*   
        IF (IDEBDB.GT.0) THEN   
          LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)  
          NF     = IQ(KOFUDB+LBNODB+MNDNCH) 
          CALL UHTOC (IQ(KOFUDB+LBNODB+MNDNAM), 4, FPATH, NF)   
          FPATH  = FPATH(1:NF)  
          N      = INDEX (PATH, ' ')    
          IF (N.EQ.0)  N = LEN (PATH) + 1   
*   
   50     N      = N -1 
          IF (PATH(N:N).NE.FPATH(NF:NF))  THEN  
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUSE : Data'//    
     +      'base structure in memory clobbered'')', IARGDB, 0) 
            IQUEST(1) = 3   
            IQUEST(11)= N   
            GO TO 999   
          ELSE IF (N.NE.1)  THEN    
            NF     = NF -1  
            GO TO 50    
          ENDIF 
        ENDIF   
      ENDIF 
*   
* *** Get number of Data banks needed   
*   
      NKYMX  = 1    
      IF (IOPMDA.NE.0)  THEN    
        IF (NWKYDK.GT.NSYSDK)  THEN 
          DO 60 I = NSYSDK+1, NWKYDK    
            IF (IOKYDA(I).NE.0) THEN    
              IF (KEYS(I).LE.0)  THEN   
*   
*  **           Illegal key option  
*   
                IQUEST(1)  = 4  
                IQUEST(11) = I  
                IQUEST(12) = KEYS(I)    
                IF (IDEBDB.GT.0) THEN   
                  IARGDB(1) = IQUEST(12)    
                  IARGDB(2) = IQUEST(11)    
                  CALL DBPRNT (LPRTDB, '(/,'' DBUSE : Illegal key opt'//    
     +                 'ion '',I3,'' for key '',I3,'' with option M'')',    
     +                 IARGDB, 2)   
                ENDIF   
                GO TO 999   
              ENDIF 
*   
              NKYMX  = NKYMX * KEYS(I)  
            ENDIF   
   60     CONTINUE  
        ENDIF   
      ENDIF 
*   
* *** Number of Key banks in S mode 
*   
      IF (IOPSDA.NE.0)  THEN    
        LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)    
        LBKYDB = LREFDB(1)  
        NKYMX  = NZBANK (IDIVDB, LBKYDB)    
      ENDIF 
*   
* *** Create (or update) Data bank(s)   
*   
      IQUEST(2) = 0 
      IQER1 = 0 
      I     = 0 
  100 I     = I + 1 
      IF (IOPSDA.EQ.0)  THEN    
        LBKYDB = LBK(I) 
      ENDIF 
      LBDADB = LQ(KOFUDB+LBKYDB-KLDADB) 
      CALL DBCHCK (LBKYDB, ITIME, KEYS, LBDADB) 
      IF (IOPSDA.NE.0)  THEN    
        IF (I.EQ.1) LBD(1) = LBDADB 
      ELSE IF (IQUEST(1).NE.0) THEN 
        LBD(I) = 0  
      ELSE  
        LBD(I) = LBDADB 
      ENDIF 
      IF (IQUEST(1).EQ.99) THEN 
         IF (IDEBDB.GT.0) THEN  
           IARGDB(1) = I    
           IARGDB(2) = NKYMX    
           CALL DBPRNT (LPRTDB, '(/,'' DBUSE : Fatal error - No more '//    
     +          'space available to lift bank for'',/,''  '//PATH(1:80) 
     +          //''',2I10)', IARGDB, 2)    
        ENDIF   
      ENDIF 
      IF (IQUEST(1).NE.0) IQER1 = IQUEST(1) 
      IF (IOPSDA.EQ.0)  THEN    
        IF (I.LT.NKYMX)         GO TO 100   
      ELSE  
        IF (IQUEST(1).NE.0)     GO TO 999   
        LBKYDB = LQ(KOFUDB+LBKYDB)  
        IF (LBKYDB.NE.0)        GO TO 100   
      ENDIF 
      IF (IQUEST(1).EQ.0) IQUEST(1) = IQER1 
*                                                              END DBUSE    
  999 CONTINUE  
C ACP_data_retrieval_end    
      END   
      SUBROUTINE DBVIN (PATHN, ITIME, USER, NDAT, IDTYP, IPRVS, NWKEY,  
     +                  KEY, IPREC, CHOPT)  
*     ================================================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBVIN (PATHN, ITIME, USER*, *NDAT*, IDTYP*, IPRVS,      *    
*                   , NWKEY*, KEY*, IPREC*, CHOPT)                     *    
*                                                                      *    
*   Fetches from disk to a FORTRAN array data valid for a given time   *    
*                                                                      *    
*   Restrictions : No selection on user keys can be made               *    
*                  USER should contain variables of the same type      *    
*                  (Integer, Real or Holllereith)                      *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     ITIME    Time for which data are required to be valid            *    
*     NDAT(*)  Maximum dimension of USER array (on input)              *    
*              Number of data words fetched from disk (on output)      *    
*     USER(*)  User array where data are stored                        *    
*     IDTYP(*) Type of the data (2 - integer; 3 - real; 5 - Hollereith)*    
*     IPRVS    Version number of program used when data were created   *    
*              (if = 0, accept any)                                    *    
*     NWKEY(*) Length of the key vector                                *    
*     KEY(*)   Key vector elements                                     *    
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *    
*              IPREC significant digits right to the decimal points; if*    
*              IPREC < 0, data are stored with IPREC insignificant     *    
*              digits left to the decimal point.)                      *    
*     CHOPT    Character string with any of the following characters   *    
*          N   If data do not exist for ITIME, take the nearest data   *    
*              object in time                                          *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 31 : Illegal path name                               *    
*               = 32 : No keys/data in this directory                  *    
*               = 36 : Data bank address zero on return from DBKXIN    *    
*               = 37 : Insufficient space in USER store array          *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      DIMENSION       KEY(9), USER(2)   
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, PATHX*16   
*   
*     ------------------------------------------------------------------    
*   
* *** Decode the character option   
* *** Inhibit 'R' option    
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0) GO TO 999 
      IOPRDA = 0    
      IF (IPRVS.NE.0) IOKYDA(MPVSDB) = 1    
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Set the current directory 
*   
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0)  THEN 
        IQUEST(1) = 31  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBVIN : Illegal '//    
     +  'Path Name '//PATH//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKEYT   
      IF (IQUEST(1).NE.0) GO TO 999 
*   
* *** Check the number of keys  
*   
      IF (NKEYDK.EQ.0)  THEN    
        IQUEST(1) = 32  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBVIN : No key '// 
     +  'or data for Path Name '//PATH//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
*   
      CALL RZCDIR (PATH, 'R')   
      NCHAR  = INDEX (PATH, ' ') - 1    
      IF (NCHAR.LT.0) NCHAR = MAXLDB    
      NCHRT  = INDEX (PATH(3:NCHAR), '/') - 1   
      IF (NCHRT.LE.0) NCHRT = NCHAR - 2 
      PATHX  = PATH(3:NCHRT+2)  
      LTOP   = LTOPDB   
   10 IF (LTOP.NE.0) THEN   
        NCHRT  = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHRT)   
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN  
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 10  
        ENDIF   
        KY7MDB = IQ(KOFUDB+LTOP+MUPKY7) 
      ELSE  
        KY7MDB = 0  
      ENDIF 
*   
* *** Set up the key vector to be searched  
*   
      DO 20 I = 1, NWKYDK   
        IF (IOKYDA(I).NE.0) THEN    
          KEYVDK(I) = KEY(I)    
        ELSE    
          KEYVDK(I) = 0 
        ENDIF   
   20 CONTINUE  
      KEYVDK(MPVSDB) = IPRVS    
      JBIAS  = 2    
*   
* *** Read in the data  
*   
      CALL DBKXIN (ITIME, IDISDB, LAUXDL(7), LAUXDL(7), JBIAS, NWKEY,   
     +             KEYVDK, IPREC)   
*   
      IF (IQUEST(1).NE.0)  THEN 
*   
*  **   DBKXIN encounters error in retrieving data  
*   
        NDAT      = 0   
*   
      ELSE IF (LAUXDL(7).EQ.0)  THEN    
*   
*  **   DBKXIN has not created the data bank    
*   
        IQUEST(1) = 36  
        NDAT      = 0   
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBVIN : Illegal '//    
     +  'Bank address from DBKXIN'')', IARGDB, 0)   
*   
      ELSE  
*   
*  **   See if the USER array size is sufficient to store the data  
*   
        L      = LAUXDL(7)  
        ND     = IQ(KOFUDB+L-1) 
        CALL UCOPY_i (KEYVDK, KEY, NWKEY) 
        IF (ND.GT.NDAT)  THEN   
*   
*  *      Insufficient space    
*   
          CALL MZDROP (IDISDB, LAUXDL(7), ' ')  
          IQUEST(1) = 37    
          IQUEST(11)= ND    
          IQUEST(12)= NDAT  
          NDAT      = 0 
          IF (IDEBDB.GT.0) THEN 
            IARGDB(1) = IQUEST(12)  
            IARGDB(2) = IQUEST(11)  
            CALL DBPRNT (LPRTDB, '(/,'' DBVIN : Insufficient space'//   
     +           ' '',I10,'' to store data - a minimum of '',I10,'' '// 
     +           'storage is needed'')', IARGDB, 2) 
          ENDIF 
*   
        ELSE    
*   
*  *      Every thing is OK 
*   
          IQUEST(1) = 0 
          IDTYP     = IDBTYP(L) 
          CALL UCOPY (Q(KOFUDB+L+1), USER(1), ND)   
          NDAT      = ND    
          CALL MZDROP (IDISDB, LAUXDL(7), ' ')  
*   
        ENDIF   
      ENDIF 
*                                                              END DBVIN    
  999 END   
      SUBROUTINE DBVLDT (ITMIN, ITMAX)  
*     ================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBVLDT (ITMIN*, ITMAX*)                                 *    
*                                                                      *    
*   Finds the overlapping validity range of all data base objects      *    
*   used since the last call to DBTBCR.                                *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     ITMIN(*) Lower bound of the validity range                       *    
*     ITMAX(*) Upper bound of the validity range                       *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (NLEVM=20)    
      DIMENSION       ISDI(NLEVM), NSDI(NLEVM)  
*   
*     ------------------------------------------------------------------    
*   
      ITMAX  = IBIGDB   
      ITMIN  = 0    
*   
* *** Loop over all top directories 
*   
      LBFXDB = LTOPDB   
   10 IF (LBFXDB.GT.0) THEN 
        NLEV   = 0  
        LBNODB = LQ(KOFUDB+LBFXDB-1)    
*   
*  **   Scan down the nodes to find all the subdirectories  
*   
   15   IF (LBNODB.GT.0) THEN   
          NLEV   = NLEV + 1 
          ISDI(NLEV) = 0    
          NSDI(NLEV) = IQ(KOFUDB+LBNODB-2)  
*   
   20     ISDI(NLEV) = ISDI(NLEV) + 1   
          IF (ISDI(NLEV).LE.NSDI(NLEV)) THEN    
*   
*  **       If a new subdirectory go down one level 
*   
            LBD    = LQ(KOFUDB+LBNODB-ISDI(NLEV))   
            IF (LBD.GT.0) THEN  
              LBNODB = LBD  
              GO TO 15  
            ELSE    
              GO TO 20  
            ENDIF   
*   
          ELSE  
*   
*  **       Loop over all the key banks 
*   
            NDK    = IQ(KOFUDB+LBNODB+2)    
            LBKYDB = LQ(KOFUDB+LBNODB)  
   25       IF (LBKYDB.GT.0) THEN   
              IOFF   = KOFUDB + LBKYDB  
              IF (IQ(IOFF+NDK-3).GT.0) THEN 
                IF (IQ(IOFF+MBVRDB).GT.ITMIN) ITMIN = IQ(IOFF+MBVRDB)   
                IF (IQ(IOFF+MEVRDB).LT.ITMAX) ITMAX = IQ(IOFF+MEVRDB)   
              ENDIF 
              LBKYDB = LQ(KOFUDB+LBKYDB)    
              GO TO 25  
            ENDIF   
*   
*  **       Now go up one level 
*   
   30       NLEV   = NLEV - 1   
            IF (NLEV.GT.0) THEN 
              LBNODB = LQ(KOFUDB+LBNODB+1)  
              GO TO 20  
            ENDIF   
          ENDIF 
        ENDIF   
*   
        LBFXDB = LQ(KOFUDB+LBFXDB)  
        GO TO 10    
      ENDIF 
*   
      IQUEST(1) = 0 
*                                                             END DBVLDT    
      END   
      SUBROUTINE DBVOUT (PATHN, IVSTR, IVEND, NDAT, USER, IPRVS, NKEXT, 
     +                   KEYXT, IDTYP, IPREC, CHOPT)    
*     ================================================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBVOUT (PATHN, IVSTR, IVEND, NDAT, USER, IPRVS, NKEXT,  *    
*                      KEYXT, IDTYP, IPREC, CHOPT)                     *    
*                                                                      *    
*   Stores data from a FORTRAN array to disk creating simultaneousely  *    
*   the directories if needed                                          *    
*   Restrictions : Only directories upto 9 keys can be created and     *    
*                  keys should be of type INTEGER                      *    
*                  USER should contain variables of the same type      *    
*                  (Integer, Real or Holllereith)                      *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     IVSTR    Start of validity period                                *    
*     IVEND    End of validity period                                  *    
*     NDAT     Number of data word in the user array                   *    
*     USER     Array of user data words                                *    
*     IPRVS    Version number of program used for creating the data    *    
*     NKEXT    Number of extra keys (Beyond key 5)                     *    
*     KEYXT    Vector of extra keys                                    *    
*     IDTYP    Type of data (2 - Integer; 3 - Real; 5 - Hollerith)     *    
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *    
*              IPREC significant digits right to the decimal points; if*    
*              IPREC < 0, data are stored with IPREC insignificant     *    
*              digits left to the decimal point.)                      *    
*     CHOPT    Character string with any of the following characters   *    
*          F   Updates with a fully matched data object (in user keys) *    
*          N   Create new (sub)directory(ies)                          *    
*          P   Create partitioned subdirectories for the pathname      *    
*          S   Create stand alone (master) data                        *    
*          U   Store data uncompressed                                 *    
*          Z   Store only nonzero elements. An element is considered to*    
*              be zero if its absolute value is less than IPREC (real) *    
*                                                                      *    
*   Called by user,   DBINIT                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 62 : Too many external keys with option N            *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      COMMON /DZPACK/ PRECDZ, PACKDZ    
      LOGICAL         PACKDZ    
*   
      DIMENSION       KEYXT(*) , USER(2)    
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80 
*
      integer ival
      real fval
      equivalence (ival, fval)
      dimension nio(9)
*     ------------------------------------------------------------------    
*   
* *** Decode the character option   
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)   GO TO 999   
      PACKDZ = .FALSE.  
*   
      IF (IOPUDA.NE.0.AND.IOPZDA.NE.0)  THEN    
        IOPZDA = 0  
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBVOUT : Warning'//    
     +  ' - Z option is incompatible with U option - U option will be'//    
     +  ' executed'')', IARGDB, 0)  
*   
      ELSE IF (IOPZDA.NE.0)  THEN   
        PACKDZ = .TRUE.
        ival = iprec
        precdz = fval
      ENDIF 
*   
      IOPRDA = 0    
*   
      IF (IOPNDA.NE.0.AND.NKEXT+5.GT.NINEDK)  THEN  
        IQUEST(1) = 62  
        IQUEST(11)= NKEXT   
        IQUEST(12)= NINEDK - 5  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBVOUT : Too man'//    
     +  'y external keys '',I6,'' with option N - a maximum of '',I6'// 
     +  ','' permitted'')', IQUEST(11), 2)  
        GO TO 999   
      ENDIF 
*   
* *** Prepare the Key vector array  
*   
      CALL VZERO_i (KEYVDK, MXDMDK)   
      IF (NKEXT.GT.2) CALL UCOPY_i (KEYXT(3), KEYVDK(8), NKEXT-2) 
      KEYVDK(MBVRDB) = IVSTR    
      KEYVDK(MEVRDB) = IVEND    
      KEYVDK(MPVSDB) = IPRVS    
      IF (NKEXT.GE.0) THEN  
        NTKEY  = NKEXT + 5  
      ELSE  
        NTKEY  = NINEDK 
      ENDIF 
*   
* *** Suppress blanks from the path name    
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
*   
* *** Create new subdirectories if needed   
*   
      IF (IOPNDA.NE.0)  THEN    
        IF (IOPPDA.EQ.0)  THEN  
          CALL DBMDIR (PATH, NTKEY, CHFTDK, CHTGDK) 
        ELSE    
          KEY7DK = 0    
          CALL DBMDIP (PATH, NTKEY, CHFTDK, CHTGDK, MXKPDK) 
        ENDIF   
        IF (IQUEST(1).NE.0) GO TO 999   
      ENDIF 
*   
* *** Create a temporary bank with the data 
*   
      JBIAS  = 2
      nio(1) = idtyp
      CALL DBBOOK (IDISDB, LAUXDL(7), LAUXDL(7), JBIAS, 'AUX7', 0, 0    
     +           , NDAT, nio, 0)  
      IF (IQUEST(1).NE.0)   GO TO 999   
      CALL UCOPY (USER(1), Q(KOFUDB+LAUXDL(7)+1), NDAT) 
*   
* *** Write out the data    
*   
      CALL DBKOUT (PATH, IDISDB, LAUXDL(7), NTKEY, KEYVDK, IPREC)   
*   
* *** Drop the temporary bank   
*   
      IER       = IQUEST(1) 
      CALL MZDROP (IDISDB, LAUXDL(7), ' ')  
      IQUEST(1) = IER   
*                                                             END DBVOUT    
  999 END   
      SUBROUTINE DBBOOK (IDIV, LAD, LSUP, JBIAS, CHID, NL,NS,ND,NIO, NZ)    
*     ==================================================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBBOOK (IDIV, LAD*, LSUP, JBIAS, CHID, NL,NS,ND, NIO,NZ)*    
*                                                                      *    
*   Creates a bank taking care of total ammount of space available in  *    
*   the division. When not enough space is available after garbage     *    
*   collection, the banks freed by DBFREE are dropped.                 *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IDIV     Division number where the object is to be created       *    
*     LAD      L-address of the bank created                           *    
*     LSUP     L-address of the supporting bank                        *    
*     JBIAS    Link bias as described in ZEBRA manual                  *    
*     CHID     Character string to specify the bank name               *    
*     NL,NS,   Total number of links, number of structural links,      *    
*     ND,NIO,  number of data words, I/O characteristics flag          *    
*     NZ       for initialising the bank (MZBOOK standard)             *    
*                                                                      *    
*   Called by various routines in the DBL3 package                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 99 : No space in memory for creating the bank        *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      CHARACTER       CHID*(*), CHID0*4 
      DIMENSION       NIO(9)
*   
*     ------------------------------------------------------------------    
*   
* *** See if enough space is available in memory    
*   
      NEEDW  = NL + ND + 20   
      CALL MZNEED (IDIV, NEEDW, ' ')    
      IF (IQUEST(11).LT.0)  THEN    
        CALL MZNEED (IDIV, NEEDW, 'G')  
        IF (IQUEST(11).LT.0)  THEN  
          LGO    = 0    
   10     LBFYDB = LZFIDH (IDIV, IHKYDB, LGO)   
          IF (LBFYDB.NE.0)  THEN    
            ND0    = IQ(KOFUDB+LBFYDB-1)    
            IF (IQ(KOFUDB+LBFYDB+ND0+MKYFRI).GT.0)  THEN    
              LDAT   = LQ(KOFUDB+LBFYDB-KLDADB) 
              IF (LDAT.GT.0) CALL MZDROP (IDIV, LDAT, 'L')  
            ENDIF   
            LGO    = LBFYDB 
            GO TO 10    
          ENDIF 
          CALL MZNEED (IDIV, NEEDW, 'G')    
          IF (IQUEST(11).LT.0)  THEN    
            IQUEST(1) = 99  
            IF (IDEBDB.GT.0) THEN   
              CHID0  = CHID 
              CALL DBPRNT (LPRTDB, '(/,'' DBBOOK : No space left for '//    
     +             'creating bank '//CHID0//' space needed '',I12)',    
     +             IQUEST(11), 1)   
            ENDIF   
            GO TO 999   
          ENDIF 
        ENDIF   
      ENDIF 
*   
* *** Create the bank as desired    
*   
      CALL MZBOOK (IDIV, LAD, LSUP, JBIAS, CHID, NL, NS, ND, NIO, 
     +             NZ)  
      IQUEST(1) = 0 
      IQ(KOFUDB+LAD-5) = 0   
*                                                             END DBBOOK    
  999 END   
      SUBROUTINE DBCDIC (PATH)  
*     ========================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBCDIC (PATH)                                           *    
*                                                                      *    
*   Create or updates the dictionary table for the Data base file      *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATH     Path name of the subdirectory                           *    
*                                                                      *    
*   Called by DBMDIP, DBMDIR                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =151 : Cannot find the top directory                   *    
*               =152 : Illegal path name                               *    
*               =153 : Illegal top directory name                      *    
*               =154 : Dictionary directory cannot be loaded           *    
*               =155 : Error in RZ for reading the dictionary object   *    
*               =156 : Pathname already exists in dictionary           *    
*               =157 : Error in RZ in writing the dictionary object    *    
*               =158 : Error in RZ in purging the dictionary directory *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      DIMENSION       KEYN(MXDMDK)  
      CHARACTER       PATHN*80, PATHF*80, PATHY*80, TOPN*16, TOPN1*16   
      CHARACTER       PATHD*80, PATH*(*)    
*
      dimension nio(9)
*     ------------------------------------------------------------------    
*   
      JBIAS  = -KLDICT  
      CALL RZCDIR (PATHN, 'R')  
*   
* *** Split the top directory and the rest  
*   
      IF (PATHN(1:2).NE.'//') THEN  
        IQUEST(1) = 151 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCDIC : No top '//    
     +  'directory in path name '//PATHN//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
      DO 5 I = 3, MAXLDB    
        IF (PATHN(I:I).EQ.' ') THEN 
          NCH    = I - 1    
          GO TO 10  
        ENDIF   
    5 CONTINUE  
      NCH    = MAXLDB   
   10 MAXL   = LEN (PATH)   
      DO 15 I = 1, MAXL 
        IF (PATH(I:I).EQ.' ') THEN  
          NCHD   = I - 1    
          GO TO 20  
        ENDIF   
   15 CONTINUE  
      NCHD   = MAXL 
   20 PATHN  = PATHN(1:NCH)//'/'//PATH(1:NCHD)  
      NCH    = NCH + NCHD + 1   
      DO 30 I = 3, NCH  
        IF (PATHN(I:I).EQ.'/') THEN 
          N1     = I    
          NCHR   = NCH - I + 1  
          GO TO 35  
        ENDIF   
   30 CONTINUE  
      N1     = NCH  
      NCHR   = 0    
   35 IF (NCHR.LE.0) THEN   
        IQUEST(1) = 152 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCDIC : Illegal'//    
     +  ' path name '//PATHN//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
      PATHY  = PATHN(N1:NCH)    
      TOPN   = PATHN(3:N1-1)    
      PATHD  = PATHN(1:N1)//'DICTIONARY'    
*   
* *** Find the corresponding top directory in the list  
*   
      LBNODB = LTOPDB   
   40 IF (LBNODB.GT.0) THEN 
        NCHT   = IQ(KOFUDB+LBNODB+MUPNCH)   
        CALL UHTOC (IQ(KOFUDB+LBNODB+MUPNAM), 4, TOPN1, NCHT)   
        TOPN1  = TOPN1(1:NCHT)  
        IF (TOPN.NE.TOPN1) THEN 
          LBNODB = LQ(KOFUDB+LBNODB)    
          GO TO 40  
        ENDIF   
        IOPS   = MOD (IQ(KOFUDB+LBNODB+MUPSRV)/10, 10)  
        IOUT   = IQ(KOFUDB+LBNODB+MUPFLG)   
      ELSE  
        IQUEST(1) = 153 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCDIC : Illegal'//    
     +  ' top directory name in '//PATHN//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
      IF (IOUT.EQ.0) IOPS = 0   
*   
* *** Check if the path name already exists in the dictionary   
*   
      CALL RZCDIR (PATHD, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 154 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCDIC : Cannot '//    
     +  'set current directory to '//PATHD//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      ISTP   = NWKYDK + 1   
      IF (NKEYDK.GT.0) THEN 
        IPNT   = KOFSDB + LCDRDB + IKDRDB   
        IMIN   = IUHUNT (-1, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)    
        IF (IMIN.GT.0) THEN 
          IMIN   = (IMIN - MSERDB) / ISTP + 1   
          CALL DBKEYT   
          CALL DBKEYR (IMIN, NWKYDK, KEYN)  
          LFIXDB = LQ(KOFUDB+LBNODB+JBIAS)  
          IF (LFIXDB.NE.0) CALL MZDROP (IDIVDB, LFIXDB, ' ')    
          ICYCL  = 9999 
          CALL DBRZIN (IDIVDB, LBNODB, JBIAS, IMIN, ICYCL, PATHD)   
          IF (IQUEST(1).NE.0) GO TO 999 
          LFIXDB = LQ(KOFUDB+LBNODB+JBIAS)  
          NDWD   = IQ(KOFUDB+LFIXDB-1)  
          GO TO 45  
        ENDIF   
      ENDIF 
      KEYN(MSERDB) = -1 
      KEYN(MUPNDB) = 0  
      CALL DATIME (IDATE, ITIME)    
      CALL DBPKTS (IDATE, ITIME*100,  KEYN(MBVRDB)) 
      KEYN(MEVRDB) = IBIGDB 
      KEYN(MPVSDB) = 0  
      KEYN(MFLGDB) = 1  
      CALL DBPKTM (IDATE,  ITIME,  KEYN(MITMDB))    
      LFIXDB = LQ(KOFUDB+LBNODB+JBIAS)  
      IF (LFIXDB.NE.0) CALL MZDROP (IDIVDB, LFIXDB, ' ')    
      NDWD   = NPUSDB*NWITDB + 1
      nio(1) = IODIDB
      CALL DBBOOK (IDIVDB, LFIXDB, LBNODB, JBIAS, 'DIDB', 0, 0, NDWD,   
     +             nio, 0)   
      IF (IQUEST(1).NE.0)     GO TO 999 
*   
   45 NITEM  = IQ(KOFUDB+LFIXDB+MDCNTM) 
      NKEEP  = (NDWD - 1) / NWITDB  
      NFREE  = 0    
      IF (NITEM.GT.0) THEN  
        DO 50 I = 1, NITEM  
          IPNT   = KOFUDB + LFIXDB + (I - 1) * NWITDB + 1   
          NCHF   = IQ(IPNT+MDCNCH)  
          IF (IQ(IPNT+MDCITM).LE.0) THEN    
            IF (NFREE.EQ.0) NFREE = I   
          ELSE  
            IF (NCHR.EQ.NCHF) THEN  
              CALL UHTOC (IQ(IPNT+MDCNAM), 4, PATHF, NCHF)  
              PATHF  = PATHF(1:NCHF)    
              IF (PATHY.EQ.PATHF) THEN  
                IQUEST(1) = 156 
                IQUEST(11)= I   
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCDIC :'//    
     +          ' Path name already in dictionary '//PATHN//''')', IQ,0)    
                GO TO 999   
              ENDIF 
            ENDIF   
          ENDIF 
   50   CONTINUE    
      ENDIF 
*   
* *** Enter the new path name in the dictionary 
*   
      IF (NFREE.EQ.0) THEN  
        NITEM  = NITEM + 1  
        NFREE  = NITEM  
        IF (NITEM.GT.NKEEP) THEN    
          CALL ZSHUNT (IDIVDB, LFIXDB, LBDADB, 2, 0)    
          LBDADB = LFIXDB   
          LFIXDB = 0    
          ND     = NDWD + NPUSDB * NWITDB
          nio(1) = IODIDB
          CALL DBBOOK (IDIVDB, LFIXDB, LBNODB, JBIAS, 'DIDB', 0, 0, ND, 
     +                 nio, -1)  
          IF (IQUEST(1).NE.0) THEN  
            IERR   = IQUEST(1)  
            CALL MZDROP (IDIVDB, LBDADB, ' ')   
            IQUEST(1) = IERR    
            GO TO 999   
          ENDIF 
          CALL UCOPY_i (IQ(KOFUDB+LBDADB+1), IQ(KOFUDB+LFIXDB+1), NDWD)   
          CALL MZDROP (IDIVDB, LBDADB, ' ') 
        ENDIF   
        IQ(KOFUDB+LFIXDB+MDCNTM) = NITEM    
      ENDIF 
      IPNT   = KOFUDB + LFIXDB + (NFREE - 1) * NWITDB + 1   
      IQ(IPNT+MDCITM) = NFREE   
      IQ(IPNT+MDCNCH) = NCHR    
      IQ(IPNT+MDCLUP) = 0   
      CALL UCTOH ('        ', IQ(IPNT+MDCALI), 4, 8)    
      CALL UCTOH (PATHY, IQ(IPNT+MDCNAM), 4, MAXLDB)    
*   
* *** Now update the disk file  
*   
      IF (IOPS.NE.0) CALL RZLOCK ('DBCDIC') 
      CALL RZOUT (IDIVDB, LFIXDB, KEYN, ICYCLE, 'S')    
      IERR   = IQUEST(1)    
      IF (IERR.NE.0) THEN   
        IF (IOPS.NE.0) CALL RZFREE ('DBCDIC')   
        IQUEST(1) = 157 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCDIC : RZOUT '// 
     +  'error for path name '//PATHD//''')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
      CALL RZPURG (0)   
      IERR   = IQUEST(1)    
      IF (IOPS.NE.0) CALL RZFREE ('DBCDIC') 
      IF (IERR.NE.0) THEN   
        IQUEST(1) = 158 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCDIC : RZPURG '//    
     +  'error for path name '//PATHD//''')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
*   
  998 IQUEST(1) = 0 
*                                                             END DBCDIC    
  999 END   
      SUBROUTINE DBCFRI (IAR, CH, NWD, NCH) 
*     ===================================== 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBCFRI (IAR, CH*, NWD, NCH)                             *    
*                                                                      *    
*   Converts integer array IAR (of length NWD) to an output character  *    
*   string CH (of type character and NCH long) via the look-up         *    
*   table stored in CSTRDA                                             *    
*                                                                      *    
*   Called by DBLIND                                                   *    
*                                                                      *    
************************************************************************    
*   
      COMMON /DAOPTI/ CALFDA(62), CSTRDA    
      CHARACTER       CALFDA*1, CSTRDA*132  
      COMMON /DAOPT1/ MPAKDA(2) 
      INTEGER         MPAKDA    
*   
      CHARACTER       CH*(*), CH1*1 
      DIMENSION       IAR(*), IB(4) 
*     ------------------------------------------------------------------    
*   
      DO 10 J = 1, NWD  
        K  = 4*J - 4    
        CALL UPKBYT (IAR(J), 1, IB, 4, MPAKDA)  
        DO 5 I = 1, 4   
          IF (K+I.GT.NCH) GO TO 999 
          CH1 = CSTRDA(63:63)   
          IF (IB(I).GE.32.AND.IB(I).LE.126) CH1 = CSTRDA(IB(I):IB(I))   
          CH(K+I:K+I) = CH1 
    5   CONTINUE    
   10 CONTINUE  
*                                                             END DBCFRI    
  999 END   
      SUBROUTINE DBCHCK (LBK, ITIME, KEYS, LBD) 
*     ========================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBCHCK (LBK, ITIME, KEYS, *LBD*)                        *    
*                                                                      *    
*   Loads data from disk according to validity time and Key values     *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LBK      Address of the bank containing the keys                 *    
*     ITIME    Time for which the valid data are required              *    
*     KEYS     Vector of keys                                          *    
*     LBD      Address of the bank containing the data                 *    
*                                                                      *    
*   Called by DBABRD, DBUSE                                            *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 31 : Path name in Node bank is wrong                 *    
*               = 32 : No keys/data in this directory                  *    
*               = 36 : Data bank address zero on return from DBKXIN    *    
*               = 37 : Insufficient space in USER store array          *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      COMMON /DTKXIN/ ICURDT, IDNRDT, IKYLDT, IMINDT, INRSDT, IPRVDT    
     +              , IUSEDT, KEY6DT, KY6NDT, MNKYDT, NTIMDT    
*   
      DIMENSION       KEYS(9)   
      CHARACTER       PATHN*80, PATH*80, PATHX*16   
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension iarg(9)
*     ------------------------------------------------------------------    
*   
* *** Lock the bank 
*   
      LREFDB(2) = LBK
      IQ2    = IQUEST(2)    
      NDK    = IQ(KOFUDB+LREFDB(2)-1)   
      IQ(KOFUDB+LREFDB(2)+NDK+MKYFRI) = 0   
      IQ(KOFUDB+LREFDB(2)+NDK+MKYCRU) = IQ(KOFUDB+LREFDB(2)+NDK+MKYCRU) 
     +                                + 1   
      IQ(KOFUDB+LREFDB(2)+NDK+MKYCEV) = IQ(KOFUDB+LREFDB(2)+NDK+MKYCEV) 
     +                                + 1   
*   
* *** Get the pathname  
*   
      LBUP   = LQ(KOFUDB+LREFDB(2)-KLUPDB)  
      IF (LBUP.GT.0) THEN   
        KY7MDB = IQ(KOFUDB+LBUP+MUPKY7) 
      ELSE  
        KY7MDB = 0  
      ENDIF 
      LBNODB = LQ(KOFUDB+LREFDB(2)-KLNODB)  
      NCHAR  = IQ(KOFUDB+LBNODB+MNDNCH) 
      CALL UHTOC (IQ(KOFUDB+LBNODB+MNDNAM), 4, PATH, NCHAR) 
      PATHN  = PATH(1:NCHAR)    
*   
* *** Set the current directory 
*   
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0)  THEN 
        IQUEST(1) = 31
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCHCK : '//   
     +  'Path name '//PATHN//' from node bank illegal'')', IQ, 0)   
        GO TO 998   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKEYT   
*   
* *** Check the number of keys  
*   
      IF (NKEYDK.EQ.0)  THEN    
        IQUEST(1) = 32  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCHCK : No key '//    
     +  'or data for Path Name '//PATHN//''')', IARGDB, 0)  
        GO TO 998   
      ENDIF 
*   
      IF (IOPKDA.NE.0 .AND. IOPSDA.NE.0) THEN   
        GO TO 998   
      ENDIF 
*   
      IF (LQ(KOFUDB+LREFDB(2)-KLDADB).EQ.0) THEN    
*   
*  **   The bank does not exist yet - retrieve data from the Data Base  
*  **   Check which keys are to be used 
*   
        IF (IOPSDA.EQ.0)  THEN  
          DO 10 I = 1, NWKYDK   
            IF (IOKYDA(I).NE.0)  THEN   
              IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB.OR.I.EQ.MITMDB) THEN   
                KEYVDK(I) = KEYS(I) 
              ELSE  
                KEYVDK(I) = IQ(KOFUDB+LREFDB(2)+I)  
              ENDIF 
            ELSE    
              KEYVDK(I) = 0 
            ENDIF   
   10     CONTINUE  
        ELSE    
          CALL UCOPY_i (IQ(KOFUDB+LREFDB(2)+1), KEYVDK, NWKYDK)   
        ENDIF   
*   
*  **   Retrieve data   
*   
        CALL DBKXIN (ITIME, IDIVDB, LBD, LBK, -KLDADB, NWKEY, 
     +               KEYVDK, IPREC) 
        IF (IQUEST(1).NE.0)                                    GO TO 998    
        LREFDB(2) = LBK  
        LREFDB(3) = LBD  
        IF (IOPSDA.EQ.0) THEN   
          IF (IQ(KOFUDB+LREFDB(2)+MSERDB).NE.KEYVDK(MSERDB)) IQ2 = 1    
        ELSE    
          IQ2 = 1   
        ENDIF   
*   
*  *    Overwrite keys in key-bank  
*   
        CALL UCOPY_i (KEYVDK(1), IQ(KOFUDB+LREFDB(2)+1), NWKYDK)  
        IQ(KOFUDB+LREFDB(2)+NDK+MKYPRE) = IPREC 
        IQ(KOFUDB+LREFDB(2)+NDK+MKYRID) =IQ(KOFUDB+LREFDB(2)+NDK+MKYRID)    
     +                                  + 1 
        IF (IOPSDA.EQ.0) THEN   
          IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).EQ.0) THEN 
            IQ(KOFUDB+LREFDB(2)+NWKYDK+1) = 
     +        MIN (IQ(KOFUDB+LREFDB(2)+MEVRDB), KY4MDB) 
          ELSE  
            IQ(KOFUDB+LREFDB(2)+NWKYDK+1) = 
     +        IQ(KOFUDB+LREFDB(2)+MBVRDB) + 1   
          ENDIF 
        ENDIF   
*   
      ELSE  
*   
*  **   The data bank exists already    
*   
        LBD = LQ(KOFUDB+LREFDB(2)-KLDADB)    
        LREFDB(3) = LBD  
*   
*  **   Check if data are valid 
*   
        IF (IOPADA.NE.0) THEN   
          IF (IQ(KOFUDB+LREFDB(2)+MBVRDB).LE.ITIME .AND.    
     +        IQ(KOFUDB+LREFDB(2)+NWKYDK+1).GE.ITIME)          GO TO 998    
          KEY6   = IQ(KOFUDB+LREFDB(2)+MFLGDB)  
        ELSE IF (IQ(KOFUDB+LREFDB(2)+MBVRDB).LE.ITIME .AND. 
     +           IQ(KOFUDB+LREFDB(2)+MEVRDB).GE.ITIME)  THEN    
          ISTP   = NWKYDK + 1   
          IPNT   = KOFSDB + LCDRDB + IKDRDB 
          MNKYDT = -998 
          KEY1   = IQ(KOFUDB+LREFDB(2)+MSERDB)  
          KEY6DT = 0    
          IMINDT = 1    
          IOPTP  = IQ(IPNT+MFLGDB)  
          IOPTP  = JBIT (IOPTP, JPRTDB) 
*   
          IF (IOPTP.EQ.0)  THEN 
*   
*  *        For non-partitioned data    
*   
            IMIN   = IUHUNT (KEY1, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)  
            IF (IMIN.GT.0) THEN 
              IMINDT = (IMIN - MSERDB) / ISTP + 1   
            ELSE    
              IMINDT = 1    
            ENDIF   
            CALL DBKEYR (IMINDT, NWKYDK, KEYVDK)    
            DO 15 I = 1, NWKYDK 
              IF (KEYVDK(I).NE.IQ(KOFUDB+LREFDB(2)+I))         GO TO 55 
   15       CONTINUE    
   20       IF (IMINDT.EQ.NKEYDK)                              GO TO 998    
            ICURDT = 1  
            CALL DBCHKY (ITIME, KEYS)   
            IF (KEY1.EQ.MNKYDT.AND.JBIT(KEY6DT,JIGNDB).EQ.0)   GO TO 998    
*   
          ELSE  
*   
*  *        For partitioned data    
*   
            NKEYS  = NKEYDK 
            KST    = NWKYDK + 1 
            ICUR   = NKEYS  
            DO 25 JK = 1, NKEYS 
              KPNT   = IUHUNT (JK, IQ(IPNT+MPSRDB), NKEYS*KST, KST) 
              IF (KPNT.GT.0) THEN   
                KPNT   = KPNT + IPNT - MPSRDB   
              ELSE  
                KPNT   = IPNT + (JK - 1) * KST  
              ENDIF 
              IF (IQ(KPNT+MOBJDB).GT.KEY1) THEN 
                ICUR   = IQ(KPNT+MPSRDB) - 1    
                GO TO 30    
              ENDIF 
   25       CONTINUE    
*   
   30       CALL DBPATH (PATHX, ICUR)   
            PATH   = PATHN(1:NCHAR)//'/'//PATHX 
            CALL RZCDIR (PATH, ' ') 
            IF (IQUEST(1).NE.0)  THEN   
              IQUEST(1) = 31
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCHCK : '// 
     +        'Path name '//PATH//' from node bank illegal'')', IQ, 0)  
              GO TO 998 
            ENDIF   
            NKEYDK = IQUEST(7)  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
            IPNT   = KOFSDB + LCDRDB + IKDRDB   
            ISTP   = NWKYDK + 1 
*   
            IF (NKEYDK.GT.0) THEN   
              IMIN   = IUHUNT (KEY1, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)    
              IF (IMIN.GT.0)  THEN  
                IMINDT = (IMIN - MSERDB) / ISTP + 1 
              ELSE  
                IMINDT = 1  
              ENDIF 
            ENDIF   
            CALL DBKEYR (IMINDT, NWKYDK, KEYVDK)    
            DO 35 I = 1, NWKYDK 
              IF (KEYVDK(I).NE.IQ(KOFUDB+LREFDB(2)+I))         GO TO 55 
   35       CONTINUE    
*   
   40       IF (ICUR.EQ.NKEYS.AND.IMINDT.EQ.NKEYDK)            GO TO 998    
            IMIN   = IMINDT 
            MNKYDT = KEY1   
            IUSEDT = ICUR   
*   
            DO 45 JK = ICUR, NKEYS  
              ICURDT = NKEYS + ICUR - JK    
*   
              CALL RZCDIR (PATHN, ' ')  
              IF (IQUEST(1).NE.0)  THEN 
                IQUEST(1) = 31  
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCHCK :'//    
     +          ' Path name '//PATHN//' from node bank illegal'')',IQ,0)    
                GO TO 998   
              ENDIF 
              NKEYDK = IQUEST(7)    
              LCDRDB = IQUEST(11)   
              IKDRDB = IQUEST(13)   
              KPNT   = IUHUNT (ICURDT, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB), 
     +                         NKEYS*KST, KST)  
              IF (KPNT.NE.0) THEN   
                IPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB   
              ELSE  
                IPNT   = KOFSDB + LCDRDB + IKDRDB + (ICURDT - 1) * KST  
              ENDIF 
              IF (IOKYDA(MITMDB).NE.0.AND.  
     +            IQ(IPNT+MITMDB).GT.KEYS(MITMDB))             GO TO 45 
              IF (KY7MDB.GT.0.AND.IQ(IPNT+MITMDB).GT.KY7MDB)   GO TO 45 
              IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).EQ.0) THEN 
                IF (ITIME.LT.IQ(IPNT+MBVRDB).OR.    
     +              ITIME.GT.IQ(IPNT+MEVRDB))                  GO TO 45 
              ELSE IF (IOKYDA(MBVRDB).NE.0.AND.IOKYDA(MEVRDB).EQ.0) THEN    
                IF (IQ(IPNT+MBVRDB).GT.KEYS(MBVRDB))           GO TO 45 
              ELSE IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).NE.0) THEN    
                IF (IQ(IPNT+MEVRDB).LT.KEYS(MEVRDB))           GO TO 45 
              ELSE  
                IF (IQ(IPNT+MBVRDB).GT.KEYS(MBVRDB).OR. 
     +              IQ(IPNT+MEVRDB).LT.KEYS(MEVRDB))           GO TO 45 
              ENDIF 
*   
              CALL DBPATH (PATHX, ICURDT)   
              PATH   = PATHN(1:NCHAR)//'/'//PATHX   
              CALL RZCDIR (PATH, ' ')   
              IF (IQUEST(1).NE.0)  THEN 
                IQUEST(1) = 31  
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCHCK :'//    
     +          ' Path name '//PATH//' from node bank illegal'')', IQ,0)    
                GO TO 998   
              ENDIF 
              NKEYDK = IQUEST(7)    
              LCDRDB = IQUEST(11)   
              IKDRDB = IQUEST(13)   
              IF (ICURDT.EQ.ICUR) THEN  
                IMINDT = IMIN   
              ELSE  
                IMINDT = 1  
              ENDIF 
*   
              IF (NKEYDK.GE.IMINDT) THEN    
                CALL DBCHKY (ITIME, KEYS)   
                IF (IUSEDT.NE.ICUR.OR.MNKYDT.NE.KEY1)          GO TO 50 
              ENDIF 
   45       CONTINUE    
*   
   50       CALL RZCDIR (PATHN, ' ')    
            IF (IQUEST(1).NE.0)  THEN   
              IQUEST(1) = 31    
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCHCK : '// 
     +        'Path name '//PATHN//' from node bank illegal'')', IQ, 0) 
              GO TO 998 
            ENDIF   
            NKEYDK = IQUEST(7)  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
            IF (IUSEDT.EQ.ICUR.AND.KEY1.EQ.MNKYDT.AND.  
     +          JBIT(KEY6DT,JIGNDB).EQ.0)                      GO TO 998    
*   
          ENDIF 
*   
        ENDIF   
*   
*  *    Data should be refreshed    
*  *    Check which keys are to be used 
*   
   55   IF (IOPSDA.EQ.0)  THEN  
          DO 60 I = 1, NWKYDK   
            IF (IOKYDA(I).NE.0) THEN    
              IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB.OR.I.EQ.MITMDB)  THEN  
                KEYVDK(I) = KEYS(I) 
              ELSE  
                KEYVDK(I) = IQ(KOFUDB+LREFDB(2)+I)  
              ENDIF 
            ELSE    
              KEYVDK(I) = 0 
            ENDIF   
   60     CONTINUE  
        ELSE    
          CALL UCOPY_i (IQ(KOFUDB+LREFDB(2)+1), KEYVDK, NWKYDK)   
        ENDIF   
*   
*  *    Retrieve data   
*   
        IDTYP  = IDBTYP (LREFDB(2)) 
        IF (IOPVDA.NE.0.OR. JBIT(KEY6,JRZUDB).NE.0 . OR.    
     +     (IDTYP.NE.2.AND.IDTYP.NE.3.AND.IDTYP.NE.5)) THEN 
*   
*  *      Variable data length - attach data to a new bank  
*   
          CALL MZDROP (IDIVDB, LREFDB(3), 'L')  
          CALL DBKXIN (ITIME, IDIVDB, LBD, LBK, -KLDADB, NWKEY,   
     +                 KEYVDK, IPREC)   
          IF (IQUEST(1).NE.0)                                  GO TO 998    
          LREFDB(3) = LBD    
          IF (IOPSDA.EQ.0) THEN 
            IF (IQ(KOFUDB+LREFDB(2)+MSERDB).NE.KEYVDK(MSERDB)) IQ2 = 1  
          ELSE  
            IQ2 = 1 
          ENDIF 
*   
        ELSE    
*   
*  *      Fixed length data - overwrite existing data   
*   
          IF (LAUXDL(7).NE.0)  THEN 
            CALL MZDROP (IDISDB, LAUXDL(7), 'L')    
            LAUXDL(7) = 0   
          ENDIF 
          JBIAS  = 2    
          NDAT   = IQ(KOFUDB+LREFDB(3)-1)   
          CALL DBKXIN (ITIME, IDISDB, LAUXDL(7), LAUXDL(7), JBIAS   
     +               , NWKEY, KEYVDK, IPREC)    
          IF (IQUEST(1).NE.0)                                  GO TO 998    
          IF (IOPSDA.EQ.0) THEN 
            IF (IQ(KOFUDB+LREFDB(2)+MSERDB).NE.KEYVDK(MSERDB)) IQ2 = 1  
          ELSE  
            IQ2 = 1 
          ENDIF 
*   
          IF (LAUXDL(7).EQ.0) THEN  
            IQUEST(1) = 36  
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCHCK : Ill'//    
     +      'egal Bank address from DBKXIN'')', IARGDB, 0)  
            GO TO 998   
*   
          ELSE  
*   
*  **       See if the old bank size is sufficient to store the data    
*   
            ND     = IQ(KOFUDB+LAUXDL(7)-1) 
            IF (ND.GT.NDAT) THEN    
*   
*  *          Insufficient space    
*   
              CALL MZDROP (IDISDB, LAUXDL(7), 'L')  
              IQUEST(1) = 37    
              IQUEST(11)= ND    
              IQUEST(12)= NDAT  
              IF (IDEBDB.GT.0) THEN 
                IARGDB(1) = IQUEST(12)  
                IARGDB(2) = IQUEST(11)  
                CALL DBPRNT (LPRTDB, '(/,'' DBCHCK : Insufficient spa'//    
     +               'ce '',I10,'' to store data - a minimum of '','//  
     +               'I10,'' storage is needed'')', IARGDB, 2)  
              ENDIF 
              GO TO 998 
*   
            ELSE    
*   
*  *          Everything is OK  
*   
              CALL UCOPY (Q(KOFUDB+LAUXDL(7)+1), Q(KOFUDB+LREFDB(3)+1), 
     +                    ND)   
              CALL MZDROP (IDISDB, LAUXDL(7), 'L')  
              IQUEST(1) = 0 
*   
            ENDIF   
*   
          ENDIF 
*   
        ENDIF   
*   
*  *    Overwrite keys in key-bank  
*   
  990   CALL UCOPY_i (KEYVDK(1), IQ(KOFUDB+LREFDB(2)+1), NWKYDK)  
        IQ(KOFUDB+LREFDB(2)+NDK+MKYPRE) = IPREC 
        IQ(KOFUDB+LREFDB(2)+NDK+MKYRID) =IQ(KOFUDB+LREFDB(2)+NDK+MKYRID)    
     +                                  + 1 
        IF (IOPSDA.EQ.0) THEN   
          IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).EQ.0) THEN 
            IQ(KOFUDB+LREFDB(2)+NWKYDK+1) = 
     +        MIN (IQ(KOFUDB+LREFDB(2)+MEVRDB), KY4MDB) 
          ELSE  
            IQ(KOFUDB+LREFDB(2)+NWKYDK+1) = 
     +        IQ(KOFUDB+LREFDB(2)+MBVRDB) + 1   
          ENDIF 
        ENDIF   
*   
      ENDIF 
*   
  998 IQUEST(2) = IQ2   
*                                                             END DBCHCK    
  999 END   
      SUBROUTINE DBCHFI (I, CH) 
*     ========================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBCHFI (I, CH*)                                         *    
*                                                                      *    
*   Converts an integer I to an output single character CH (of type    *    
*   Character) via the look-up table stored in CSTRDA                  *    
*   (Adapted from CHTOI from CERN Library)                             *    
*                                                                      *    
*   Called by DBLIND                                                   *    
*                                                                      *    
************************************************************************    
*   
      COMMON /DAOPTI/ CALFDA(62), CSTRDA    
      CHARACTER       CALFDA*1, CSTRDA*132  
      COMMON /DAOPT1/ MPAKDA(2) 
      INTEGER         MPAKDA    
*   
      CHARACTER       CH*1  
*     ------------------------------------------------------------------    
*   
      CH = CSTRDA(63:63)    
      IF (I.LT.32.OR.I.GT.126) GO TO 999    
      CH = CSTRDA(I:I)  
*                                                             END DBCHFI    
  999 END   
      SUBROUTINE DBCHKY (ITIME, KEYS)   
*     ===============================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBCHKY (ITIME, KEYS)                                    *    
*                                                                      *    
*   Checks if the current key bank is still valid                      *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     ITIME    Time for which the valid data are required              *    
*     KEYS     Vector of keys                                          *    
*                                                                      *    
*   Called by DBCHCK                                                   *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DTKXIN/ ICURDT, IDNRDT, IKYLDT, IMINDT, INRSDT, IPRVDT    
     +              , IUSEDT, KEY6DT, KY6NDT, MNKYDT, NTIMDT    
*   
      DIMENSION       KEYS(9)   
*   
*     ------------------------------------------------------------------    
*   
* *** Loop over the keys    
*   
      DO 20 IK = IMINDT, NKEYDK 
        CALL DBKEYR (IK, NWKYDK, KEYVDK)    
*   
        IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).EQ.0) THEN   
          IF (ITIME.LT.KEYVDK(MBVRDB).OR.ITIME.GT.KEYVDK(MEVRDB))   
     +                                                  GO TO 20    
        ELSE IF (IOKYDA(MBVRDB).NE.0.AND.IOKYDA(MEVRDB).EQ.0) THEN  
          IF (KEYVDK(MBVRDB).GT.KEYS(MBVRDB))           GO TO 20    
        ELSE IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).NE.0) THEN  
          IF (KEYVDK(MEVRDB).LT.KEYS(MEVRDB))           GO TO 20    
        ELSE    
          IF (KEYVDK(MBVRDB).GT.KEYS(MBVRDB).OR.    
     +        KEYVDK(MEVRDB).LT.KEYS(MEVRDB))           GO TO 20    
        ENDIF   
        IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.  
     +      IQ(KOFUDB+LREFDB(2)+MPVSDB))                GO TO 20    
        IF (IOKYDA(MITMDB).NE.0.AND.KEYS(MITMDB).LT.KEYVDK(MITMDB)) 
     +                                                  GO TO 20    
        IF (KY7MDB.NE.0.AND.KY7MDB.LT.KEYVDK(MITMDB))   GO TO 20    
        IF (NWKYDK.GT.NSYSDK) THEN  
          DO 10 J = NSYSDK+1, NWKYDK    
            IF (IOKYDA(J).NE.0)  THEN   
              IF (KEYVDK(J).NE.IQ(KOFUDB+LREFDB(2)+J))  GO TO 20    
            ENDIF   
   10     CONTINUE  
        ENDIF   
*   
        IF (MNKYDT.LE.KEYVDK(MSERDB))  THEN 
          MNKYDT = KEYVDK(MSERDB)   
          KEY6DT = KEYVDK(MFLGDB)   
          IUSEDT = ICURDT   
        ENDIF   
   20 CONTINUE  
*                                                             END DBCHKY    
  999 END   
      SUBROUTINE DBCMPR (LB, IADS, IER) 
*     ================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBCMPR (LB, IADS*, IER*)                                *    
*                                                                      *    
*   Compresses data bank defined by LB in the Data Base                *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LB       Address of the bank to be compressed                    *    
*     IADS(*)  Address of the compressed bank as LAUXDL(IADS)          *    
*     IER(*)   Error Code : 0    No error                              *    
*                           1-3  As in DBFLIN/DBININ                   *    
*                           4    Not enough precision for packing      *    
*                           5    Nonstandard Data type                 *    
*                                                                      *    
*   Called by DBCOMP                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IER       =  0 : No error (see above)                            *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      SAVE            IWMX  
      DATA            IWMX /1073741824/ 
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
      MSBIT (MZ,IZW,IZP) = IOR (IAND (IZW, NOT(ISHFT(1,IZP-1)) )    
     +                              , ISHFT(IAND(MZ,1),IZP-1))  
*   
      MCBYT (MZ,IZQ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +        , ISHFT (ISHFT(ISHFT(MZ,-IZQ+1),32-NZB), -33+IZP+NZB) )   
*   
      JBYTET (MZ,IZW,IZP,NZB) = IAND (MZ, IBITS(IZW,IZP-1,NZB)) 
      JBYTOR (MZ,IZW,IZP,NZB) = IOR  (MZ, IBITS(IZW,IZP-1,NZB)) 
      MBYTET (MZ,IZW,IZP,NZB) = IAND (IZW, NOT(ISHFT (  
     +                          ISHFT(NOT(MZ),32-NZB),-33+IZP+NZB)) )   
      MBYTOR (MZ,IZW,IZP,NZB) = IOR (IZW, ISHFT (   
     +                               ISHFT(MZ,32-NZB),-33+IZP+NZB) )    
*
      dimension nio(9), iarg(9)
*     ------------------------------------------------------------------    
*   
* *** Data type ?   
*   
      LREFDB(5) = LB
      IDTYP  = IDBTYP(LREFDB(5))    
      NDA    = IQ(KOFUDB+LREFDB(5)-1)   
      JBIAS  = 2
      nio(1) = 2
      CALL DBBOOK (IDISDB, LAUXDL(IADS), LAUXDL(IADS), JBIAS, 'AUX1', 0,    
     +             0, NDA, nio, 0)    
      IF (IQUEST(1).NE.0) GO TO 999 
      LAUX1  = LAUXDL(IADS) 
      IF (IDTYP.EQ.3) THEN  
*   
*  **   Convert real to integer data and truncate according to precision    
*   
        CALL DBFLIN (Q(KOFUDB+LREFDB(5)+1), IQ(KOFUDB+LAUX1+1), NDA,    
     +               IPREC, IER)    
        IF (IER.NE.0) THEN  
          CALL MZDROP (IDISDB, LAUX1, ' ')  
          GO TO 999 
        ENDIF   
*   
      ELSE IF (IDTYP.EQ.2.OR.IDTYP.EQ.5) THEN   
*   
*  **   Truncate integer data according to the given precision  
*   
        CALL DBININ (IQ(KOFUDB+LREFDB(5)+1), IQ(KOFUDB+LAUX1+1), NDA,   
     +               IPREC, IER)    
        IF (IER.NE.0) THEN  
          CALL MZDROP (IDISDB, LAUX1, ' ')  
          GO TO 999 
        ENDIF   
      ELSE  
*   
*  **   Nonstandard data type   
*   
        IER    = 5  
        CALL MZDROP (IDISDB, LAUX1, ' ')
        iarg(1) = idtyp
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBCMPR : Data-Ty'//    
     +  'pe '',I4,'' incompatible for packing'')', iarg, 1)    
        GO TO 999   
      ENDIF 
*   
* *** Convert signed integer to positive integers   
*   
      ND2    = NDA - 2  
      LAU12  = KOFUDB + LAUX1 + 2   
      IVM    = IQ(LAU12+1)  
      MVM    = IQ(LAU12+1)  
      DO 10 I = 2, ND2  
        IF (IQ(LAU12+I).LT.IVM) IVM = IQ(LAU12+I)   
        IF (IQ(LAU12+I).GT.MVM) MVM = IQ(LAU12+I)   
   10 CONTINUE  
*   
      IF (MVM.GT.IWMX.OR.-IVM.GT.IWMX) THEN 
        IER    = 4  
        CALL MZDROP (IDISDB, LAUXDL(IADS),   ' ')
        iarg(1) = lbitl
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBCMPR : Packing'//    
     +  ' Bit Length is '',I4,'' - No Compression !'')', iarg, 1)  
        GO TO 999   
      ENDIF 
*   
      IF (IVM.LT.0) THEN    
        IVM    = - IVM  
        DO 20 I = 1, ND2    
          IQ(LAU12+I) = IQ(LAU12+I) + IVM   
   20   CONTINUE    
      ELSE  
        IVM    = 0  
      ENDIF 
*   
* *** Pack the positive integers into bit-string choosing optimum   
* *** bit-length    
*   
      ND3    = ND2 + 3  
      JBIAS  = 2
      nio(1) = 1
      CALL DBBOOK (IDISDB, LAUXDL(IADS+1), LAUXDL(IADS+1), JBIAS, 'AUX2'    
     +           , 0, 0, ND3, nio, 0) 
      IF (IQUEST(1).NE.0) GO TO 999 
      CALL DBBOOK (IDISDB, LSTRDL(5), LSTRDL(5), JBIAS, 'WKSP', 0, 0    
     +           , ND3, nio, -1)  
      IF (IQUEST(1).NE.0) GO TO 999 
      LAUX1  = LAUXDL(IADS) 
      LAU13  = LAUX1 + 3    
      LAUX2  = LAUXDL(IADS+1)   
      CALL DBPACK (IQ(KOFUDB+LAU13), ND2, NDO, NAU, LBITL   
     +           , IQ(KOFUDB+LAUX2+4), IQ(KOFUDB+LSTRDL(5)+1))  
      CALL MZDROP (IDISDB, LSTRDL(5), ' ')  
*   
      IF (LBITL.EQ.32) THEN 
        IER    = 4  
        CALL MZDROP (IDISDB, LAUXDL(IADS),   ' ')   
        CALL MZDROP (IDISDB, LAUXDL(IADS+1), ' ')
        iarg(1) = lbitl
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBCMPR : Packing'//    
     +  ' Bit Length is '',I4,'' - No Compression !'')', iarg, 1)  
        GO TO 999   
      ENDIF 
*   
      IPREC  = IPREC + 100  
      IQ(KOFUDB+LAUX2+1) = 10000*ND2 + 1000*IDTYP + IPREC   
      IQ(KOFUDB+LAUX2+2) = IVM  
      LAU    = LAUX2 + 3    
      IQ(KOFUDB+LAU) = NAU  
      IQ(KOFUDB+LAU) = MCBYT (LBITL, 1, IQ(KOFUDB+LAU), 27, 5)  
      IQ(KOFUDB+LAU) = MSBIT1 (IQ(KOFUDB+LAU), 32)  
*   
* *** Rebook AUX1 bank with reduced datalength  
*   
      ND3    = NDO + 3  
      CALL MZDROP (IDISDB, LAUX1, ' ')  
      JBIAS  = 2
      nio(1) = 1
      CALL DBBOOK (IDISDB, LAUXDL(IADS), LAUXDL(IADS), JBIAS, 'AU11', 0,    
     +             0, ND3, nio, 0)    
      IF (IQUEST(1).NE.0) GO TO 999 
      LAUX1  = LAUXDL(IADS) 
      LAUX2  = LAUXDL(IADS+1)   
      CALL UCOPY_i (IQ(KOFUDB+LAUX2+1), IQ(KOFUDB+LAUX1+1), ND3)  
      CALL MZDROP (IDISDB, LAUX2, ' ')  
      IER    = 0    
*                                                             END DBCMPR    
  999 END   
      SUBROUTINE DBCMPZ (LB, IADS, IER) 
*     ================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBCMPZ (LB, IADS*, IER*)                                *    
*                                                                      *    
*   Compresses data bank defined by LB in the Data Base                *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LB       Address of the bank to be compressed                    *    
*     IADS(*)  Address of the compressed bank as LAUXDL(IADS)          *    
*     IER(*)   Error Code : 0    No error                              *    
*                           1    Compression does not result in gaining*    
*                                space                                 *    
*                           5    Nonstandard Data type                 *    
*                                                                      *    
*   Called by DBCOMP                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IER       =  0 : No error (see above)                            *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      COMMON /DZPACK/ PRECDZ, PACKDZ    
      LOGICAL         PACKDZ    
*
      dimension nio(9), iarg(9)
*     ------------------------------------------------------------------    
*   
* *** Data type ?   
*   
      LREFDB(5) = LB
      IDTYP  = IDBTYP (LREFDB(5))   
      NDA    = IQ(KOFUDB+LREFDB(5)-1)   
      ND2    = NDA - 2  
      JBIAS  = 2
      nio(1) = idtyp
      CALL DBBOOK (IDISDB, LAUXDL(IADS), LAUXDL(IADS), JBIAS, 'AUX1', 0,    
     +             0, NDA, nio, 0)    
      IF (IQUEST(1).NE.0)   GO TO 999   
      LAUX1  = LAUXDL(IADS) 
*   
      IF (IDTYP.EQ.3) THEN  
*   
*  **   Compress non-0 real data    
*   
        CALL DBFZIN (Q(KOFUDB+LREFDB(5)+3), ND2, Q(KOFUDB+LAUX1+1), NDO,    
     +               PRECDZ, IER)   
        IF (IER.NE.0) THEN  
          CALL MZDROP (IDISDB, LAUX1, ' ')  
          GO TO 999 
        ENDIF   
*   
*  **   Copy compressed data into reduced array with appropriate header 
*   
        ND3    = NDO + 3    
        JBIAS  = 2
        nio(1) = idtyp
        CALL DBBOOK (IDISDB, LAUXDL(IADS+1), LAUXDL(IADS+1), JBIAS, 
     +               'AUX2', 0, 0, ND3, nio, 0)   
        IF (IQUEST(1).NE.0) GO TO 999   
        LAUX1  = LAUXDL(IADS)   
        LAUX2  = LAUXDL(IADS+1) 
*   
        Q(KOFUDB+LAUX2+1) = ND2 
        Q(KOFUDB+LAUX2+2) = PRECDZ  
        Q(KOFUDB+LAUX2+3) = NDO 
        CALL UCOPY (Q(KOFUDB+LAUX1+1), Q(KOFUDB+LAUX2+4), NDO)  
        CALL MZDROP (IDISDB, LAUX1, ' ')    
        LAUXDL(IADS) = LAUXDL(IADS+1)   
        LAUXDL(IADS+1) = 0  
*   
       ELSE IF (IDTYP.EQ.2.OR.IDTYP.EQ.5) THEN  
*   
*  **   Compress non-0 integer data 
*   
        CALL DBIZIN (IQ(KOFUDB+LREFDB(5)+3), ND2, IQ(KOFUDB+LAUX1+1),   
     +               NDO, PRECDZ, IER)  
        IF (IER.NE.0) THEN  
          CALL MZDROP (IDISDB, LAUX1, ' ')  
          GO TO 999 
        ENDIF   
*   
*  **   Copy compressed data into reduced array with appropriate header 
*   
        ND3    = NDO + 3    
        JBIAS  = 2
        nio(1) = idtyp
        CALL DBBOOK (IDISDB, LAUXDL(IADS+1), LAUXDL(IADS+1), JBIAS, 
     +               'AUX2', 0, 0, ND3, nio, 0)   
        IF (IQUEST(1).NE.0) GO TO 999   
        LAUX1  = LAUXDL(IADS)   
        LAUX2  = LAUXDL(IADS+1) 
*   
        IQ(KOFUDB+LAUX2+1) = ND2    
        IQ(KOFUDB+LAUX2+2) = PRECDZ 
        IQ(KOFUDB+LAUX2+3) = NDO    
        CALL UCOPY_i (IQ(KOFUDB+LAUX1+1), IQ(KOFUDB+LAUX2+4), NDO)    
        CALL MZDROP (IDISDB, LAUX1, ' ')    
        LAUXDL(IADS) = LAUXDL(IADS+1)   
        LAUXDL(IADS+1) = 0  
*   
      ELSE  
*   
*  **   Nonstandard Data type   
*   
        IER    = 5  
        CALL MZDROP (IDISDB, LAUX1, ' ')
        iarg(1) = idtyp
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBCMPZ : Data-Ty'//    
     +  'pe'',I4,'' incompatible for packing'')', iarg, 1) 
        GO TO 999   
      ENDIF 
*   
      IER    = 0    
*                                                             END DBCMPZ    
  999 END   
      SUBROUTINE DBCOMP (LSUP, LUPDA, KEYS) 
*     ===================================== 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBCOMP (LSUP, LUPDA*, *KEYS*)                           *    
*                                                                      *    
*   Compresses data bank defined by LSUP in the Data Base              *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LSUP     Address of the bank to be compressed                    *    
*     LUPDA    Address of the compressed bank                          *    
*     KEYS     Vector of keys; Key 2 on return will contain the        *    
*              pointer to the Key 1 of the object with reference       *    
*              to which the current object has been updated            *    
*                                                                      *    
*   Called by DBENTB, DBNTOP, DBENFZ, DBKOUT                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      COMMON /DZPACK/ PRECDZ, PACKDZ    
      LOGICAL         PACKDZ    
*   
      PARAMETER       (MXNEI=5) 
      DIMENSION       KEYS(9)    
*   
*     ------------------------------------------------------------------    
*   
      IADS      = 1 
      KEYS(MUPNDB)   = 0    
      LREFDB(3) = LSUP
*   
* *** If data is of mixed type, data cannot be compressed ! 
*   
      ITYP   = IDBTYP (LREFDB(3))   
      IF (ITYP.NE.2.AND.ITYP.NE.3)  THEN    
        LUPDA = LREFDB(3)    
        GO TO 999   
      ENDIF 
*   
* *** Compress the data 
*   
      IF (PACKDZ) THEN  
        CALL DBCMPZ (LSUP, IADS, IER)    
      ELSE  
        CALL DBCMPR (LSUP, IADS, IER)    
      ENDIF 
      IF (IQUEST(1).NE.0)             GO TO 999 
*   
* *** If IER .ne. 0 ----> Data cannot be compressed !   
*   
      IF (IER.EQ.0)  THEN   
        LUPDA = LAUXDL(IADS) 
      ELSE  
        LUPDA = LREFDB(3)    
        GOTO  999   
      ENDIF 
*   
      IF (IQUEST(1).NE.0)             GO TO 999 
      IF (IOPSDA.NE.0)                GO TO 999 
      IF (NKEYDK.EQ.0)                GO TO 999 
*   
* *** Can we compress better by taking the difference of the present and    
* ***   neighbouring objects ?  
*   
      ISTP   = NWKYDK + 1   
*   
      LREFDB(4) = LUPDA  
      MINWD  = IQ(KOFUDB+LREFDB(4)-1)   
      IADS   = 9    
      LADR   = -777 
      NEIGH  = 0    
      DO 50 I = 1, NKEYDK   
        J      = NKEYDK + 1 - I 
        IPNT   = KOFSDB + LCDRDB + IKDRDB + (J-1) * ISTP    
        KEY2   = IQ(IPNT+MUPNDB)    
        IF (KEY2.NE.0)                GO TO 50  
        IF (IOPFDA.NE.0) THEN   
          CALL DBKEYR (J, NWKYDK, KEYNDK)   
          DO 10 K = NSYSDK+1, NWKYDK    
            IF (KEYS(K).NE.KEYNDK(K)) GO TO 50  
   10     CONTINUE  
        ENDIF   
        NEIGH  = NEIGH + 1  
        IF (NEIGH.GT.MXNEI)           GO TO 60  
*   
        IF (LSTRDL(4).NE.0) CALL MZDROP (IDISDB, LSTRDL(4), 'L')    
        LSTRDL(4) = 0   
        JBIAS  = 2  
        CALL DBRZIN (IDISDB, LSTRDL(4), JBIAS, J, ICYCL, ' ')   
        IF (IQUEST(1).NE.0)  THEN   
          IF (LSTRDL(4).NE.0) CALL MZDROP (IDISDB, LSTRDL(4), 'L')  
          GO TO 50  
        ENDIF   
*   
        CALL DBKEYR (J, NWKYDK, KEYNDK) 
*   
        LCOM   = LSTRDL(4)  
*   
*  **   Uncompress ?    
*   
        IF (IQ(KOFUDB+LCOM+1).NE.0)  THEN   
          CALL DBUNCP (LSTRDL(4), LREFDL(2), 0) 
          IER    = IQUEST(1)    
          CALL MZDROP (IDISDB, LSTRDL(4), 'L')  
          IF (IER.NE.0) THEN    
            IQUEST(1) = IER 
            GO TO 999   
          ENDIF 
          LCOM   = LREFDL(2)    
        ENDIF   
        LREFDL(7) = LCOM    
*   
*  **   Look if the data are similar - take the most similar master 
*   
        ND1    = IQ(KOFUDB+LREFDB(3) - 1)   
        ND2    = IQ(KOFUDB+LCOM - 1)    
        IF (ND2.EQ.0) THEN  
          IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBCOMP : The '// 
     +    'Data Structure does not contain data'',/)', IARGDB, 0)   
          CALL MZDROP (IDISDB, LCOM, ' ')   
          GO TO 50  
        ENDIF   
*   
        IT1    = IDBTYP(LREFDB(3))  
        IT2    = IDBTYP(LCOM)   
        IF (IT1.NE.IT2)  THEN   
          IF (IDEBDB.GT.1) THEN 
            IARGDB(1) = IT1 
            IARGDB(2) = IT2 
            CALL DBPRNT (LPRTDB, '(/,'' DBCOMP : The 2 Structures hav'//    
     +           'e different data type '',2I4)', IARGDB, 2)    
          ENDIF 
          CALL MZDROP (IDISDB, LCOM, ' ')   
          GO TO 50  
        ENDIF   
        IF (ND1.NE.ND2) THEN    
          IF (IDEBDB.GT.1) THEN 
            IARGDB(1) = ND1 
            IARGDB(2) = ND2 
            CALL DBPRNT (LPRTDB, '(/,'' DBCOMP : The 2 Structures hav'//    
     +      'e different # of data'',2I4)', IARGDB, 2)  
          ENDIF 
          CALL MZDROP (IDISDB, LCOM, ' ')   
          GO TO 50  
        ENDIF   
        IF (IT1.EQ.2.OR.IT1.EQ.5) THEN  
          IQ(KOFUDB+LCOM+2) = IQ(KOFUDB+LREFDB(3)+2)    
          DO 20 ID = 3, ND1 
   20     IQ(KOFUDB+LCOM+ID) =IQ(KOFUDB+LCOM+ID)-IQ(KOFUDB+LREFDB(3)+ID)    
        ELSE    
          Q(KOFUDB+LCOM+2) = Q(KOFUDB+LREFDB(3)+2)  
          DO 30 ID = 3, ND1 
   30     Q(KOFUDB+LCOM+ID) = Q(KOFUDB+LCOM+ID) - Q(KOFUDB+LREFDB(3)+ID)    
        ENDIF   
*   
   40   CONTINUE    
        IF (PACKDZ) THEN    
          CALL DBCMPZ (LREFDL(7), IADS, IER)    
        ELSE    
          CALL DBCMPR (LREFDL(7), IADS, IER)    
        ENDIF   
        IF (IQUEST(1).NE.0) THEN    
          IER       = IQUEST(1) 
          CALL MZDROP (IDISDB, LREFDL(7), ' ')  
          IQUEST(1) = IER   
          GO TO 999 
        ENDIF   
        LCOM   = LREFDL(7)  
        IF (IER.NE.0) THEN  
          CALL MZDROP (IDISDB, LCOM, ' ')   
          GO TO 50  
        ENDIF   
*   
        LADR   = LAUXDL(IADS)   
        NWORD  = IQ(KOFUDB+LADR-1)  
        IF (NWORD.GE.MINWD)  THEN   
          CALL MZDROP (IDISDB, LCOM, ' ')   
          CALL MZDROP (IDISDB, LADR, ' ')   
          GO TO 50  
        ENDIF   
        KEYS(MUPNDB)= KEYNDK(MSERDB)    
        MINWD  = NWORD  
        CALL MZDROP (IDISDB, LCOM, ' ') 
        CALL MZDROP (IDISDB, LREFDB(4), ' ')    
        LUPDA  = LADR    
        LREFDB(4) = LADR    
        IF (IADS.EQ.1)  THEN    
          IADS   = 9    
        ELSE IF (IADS.EQ.9) THEN    
          IADS   = 1    
        ENDIF   
   50 CONTINUE  
   60 CONTINUE  
      IF (LREFDB(4).NE.LADR .AND. LADR.NE.-777) 
     +  CALL MZDROP (IDISDB, LADR, ' ') 
      IQUEST(1) = 0 
*                                                             END DBCOMP    
  999 END   
      SUBROUTINE DBDELK (IOPS)  
*     ========================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBDELK                                                  *    
*                                                                      *    
*   Deletes objects in a given directory taking care the objects with  *    
*   IPURDK(n) set to 2 and those on which these objects depend are     *    
*   preserved                                                          *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IOPS     Shared option (0 if stand alone)                        *    
*                                                                      *    
*   Called by DBPURG, DBPURK                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
*   
*     ------------------------------------------------------------------    
*   
* *** Label by '1' those objects one should not delete  
*   
      IF (IOPS.NE.0) CALL RZLOCK ('DBDELK') 
      IPNT   = KOFSDB + LCDRDB + IKDRDB 
      ISTP   = NWKYDK + 1   
      I1     = 1    
      NDEL   = 0    
   10 IF (I1.LE.NKEYDK)  THEN   
        NN     = NKEYDK - I1 + 1    
        II     = IUCOMP (2, IPURDK(I1), NN) 
        IF (II.GT.0)  THEN  
          II     = II + I1 - 1  
          I1     = II + 1   
   15     IP     = IPNT + (II - 1) * ISTP   
          NO1    = IQ(IP+MUPNDB)    
          II     = IUCOMP (NO1, KEY1DK, NKEYDK) 
          IF (II.GT.0.AND.NO1.NE.0) THEN    
            IF (IPURDK(II).NE.2) IPURDK(II) = 1 
            GO TO 15    
          ENDIF 
          GO TO 10  
        ENDIF   
      ENDIF 
*   
      DO 20 IK1 = 1, NKEYDK 
        IK     = NKEYDK + 1 - IK1   
        IF (IPURDK(IK).LE.0) THEN   
          CALL DBKEYR (IK, NWKYDK, KEYNDK)  
          CALL RZDELK (KEYNDK, ICDUM, 'C')  
          NDEL   = NDEL + 1 
        ENDIF   
   20 CONTINUE  
      IF (IOPS.NE.0) CALL RZFREE ('DBDELK') 
      IQUEST(2) = NDEL  
*                                                             END DBDELK    
  999 END   
      SUBROUTINE DBENFZ (PATHN, LUNFZ, IOPP, TOPN, IOPS)    
*     ==================================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBENFZ (PATHN, LUNFZ, IOPP, TOPN, IOPS)                 *    
*                                                                      *    
*   Enters data objects using either data residing in a FZ file or     *    
*   data hung at address LFIXDB                                        *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     LUNFZ    Logical unit number of the FZ file                      *    
*              or 0 if data does not reside on FZ file                 *    
*     IOPP     Public mode flag in server environment                  *    
*     TOPN     Name of the top directory                               *    
*     IOPS     Flag to indicate shared mode (0 if standalone)          *    
*                                                                      *    
*   Called by DBFZUP                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 77 : FZOUT fails to write on to the sequential file  *    
*               =141 : Read error on the FZ file                       *    
*               =143 : Illegal path name in the transcript file        *    
*               =144 : Error in RZ for saving the data object          *    
*               =145 : Error in RZ for reanming the keys               *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      COMMON /DZPACK/ PRECDZ, PACKDZ    
      LOGICAL         PACKDZ    
*   
      DIMENSION       KEYO(MXDMDK), KEYN(MXDMDK)    
      CHARACTER       PATHN*(*), PATHX*16, PATHY*80, CHFOR*100, CHOP*1  
      CHARACTER       CFORM(6)*1, TOPN*(*)  
      DATA            CFORM / 'B', 'I', 'F', 'D', 'H', 'A' /    
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      integer ival
      real fval
      equivalence (ival, fval)
      dimension iuhead(9)
*     ------------------------------------------------------------------    
*   
      JBIAS  = 2    
      IF (IOPUDA.NE.0) THEN 
        IOPZDA = 0  
        PACKDZ = .FALSE.    
        IPREC  = 0  
      ELSE IF (IOPZDA.NE.0) THEN    
        PACKDZ = .TRUE.
        ival = IHEADF(MPREDF)
        PRECDZ = fval
      ELSE  
        PACKDZ = .FALSE.    
        IPREC  = IHEADF(MPREDF) 
      ENDIF 
      MAXL   = LEN (PATHN)  
      NCH    = INDEX (PATHN(1:MAXL), ' ') - 1   
      IF (NCH.LT.1) NCH = MAXL  
*   
* *** Check if the object already exists in the data base   
*   
      IPNT   = KOFSDB + LCDRDB + IKDRDB 
      ISTP   = NWKYDK + 1   
      IF (NKEYDK.GT.0) THEN 
        IOPTP  = JBIT (IQ(IPNT+MFLGDB), JPRTDB) 
      ELSE  
        IOPTP  = 0  
      ENDIF 
      KEY1   = IHEADF(MPREDF+MSERDB)    
      IF (IOVRDB.NE.0) KEY1 = 0 
      IF (IOPTP.EQ.0) THEN  
        IF (KEY1.GT.0) THEN 
          IFND   = IUHUNT (KEY1, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)    
          IF (IFND.NE.0)                 GO TO 998  
        ELSE    
          KOBJ   = 0    
        ENDIF   
        PATHY  = PATHN  
      ELSE  
        MXKP   = IQ(IPNT+MXKPDB)    
        NKEYS  = NKEYDK 
        CALL DBKYTG 
        DO 15 JK = 1, NKEYS 
          IK     = NKEYS + 1 - JK   
          KPNT   = IUHUNT (IK, IQ(IPNT+MPSRDB), NKEYS*ISTP, ISTP)   
          IF (KPNT.NE.0) THEN   
            KPNT   = IPNT + KPNT - MPSRDB   
          ELSE  
            KPNT   = IPNT + (IK - 1) * ISTP 
          ENDIF 
          IF (KEY1.GT.0) THEN   
            IF (IQ(KPNT+MOBJDB).GE.KEY1) GO TO 15   
          ENDIF 
*   
*  **     Get the appropriate sub-directory 
*   
          NK     = (KPNT - IPNT) / ISTP + 1 
          CALL DBKEYR (NK, NWKYDK, KEYO)    
          CALL DBPATH (PATHX, IK)   
          PATHY  = PATHN(1:NCH)//'/'//PATHX 
          CALL RZCDIR (PATHY, ' ')  
          IF (IQUEST(1).NE.0) THEN  
            IQUEST(1) = 143 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENFZ : Ill'//    
     +      'egal path name '//PATHY//''')', IARGDB, 0) 
            GO TO 999   
          ENDIF 
          NKEYDK = IQUEST(7)    
          NWKYDK = IQUEST(8)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          IPNT   = KOFSDB + LCDRDB + IKDRDB 
          IF (KEY1.NE.0) THEN   
            IFND   = IUHUNT (KEY1, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)  
            IF (IFND.NE.0) THEN 
              PATHY  = PATHN(1:NCH) 
              CALL RZCDIR (PATHY, ' ')  
              IF (IQUEST(1).NE.0) THEN  
                IQUEST(1) = 143 
                GO TO 999   
              ENDIF 
              NKEYDK = IQUEST(7)    
              NWKYDK = IQUEST(8)    
              LCDRDB = IQUEST(11)   
              IKDRDB = IQUEST(13)   
              GO TO 998 
            ENDIF   
          ENDIF 
*   
*  **     Create a new subdirectory if needed   
*   
          IF (IOPP.EQ.0.AND.NKEYDK.GE.MXKP) THEN    
            IF (IK.EQ.NKEYS) THEN   
              CHFOR  = ' '  
              IF (KEY1.NE.0) THEN   
                KEY7DK = IHEADF(MPREDF+MITMDB)  
              ELSE  
                KEY7DK = 0  
              ENDIF 
              DO 10 I = 1, NWKYDK   
                IF (I.EQ.1) THEN    
                  CHFOR  = CFORM(IOTYDK(I)) 
                ELSE    
                  CHFOR  = CHFOR(1:I-1)//CFORM(IOTYDK(I))   
                ENDIF   
   10         CONTINUE  
              CALL DBMDIP (PATHN, NWKYDK, CHFOR, CTAGDK, MXKP)  
              CALL RZCDIR (PATHN, ' ')  
              IF (IQUEST(1).NE.0) THEN  
                IQUEST(1) = 143 
                IF (IDEBDB.GT.0) THEN   
                  PATHY  = PATHN    
                  CALL DBPRNT (LPRTDB, '(/,'' DBENFZ : Illegal path '// 
     +                 'name '//PATHY//''')', IARGDB, 0)    
                ENDIF   
                GO TO 999   
              ENDIF 
              NKEYDK = IQUEST(7)    
              NWKYDK = IQUEST(8)    
              LCDRDB = IQUEST(11)   
              IKDRDB = IQUEST(13)   
              IPNT   = KOFSDB + LCDRDB + IKDRDB 
              NK     = IUHUNT (NKEYDK, IQ(IPNT+MPSRDB),NKEYDK*ISTP,ISTP)    
              IF (NK.GT.0) THEN 
                NK     = (NK - MPSRDB) / ISTP + 1   
              ELSE  
                NK     = NKEYDK 
              ENDIF 
              CALL DBKEYR (NK, NWKYDK, KEYO)    
              CALL DBPATH (PATHX, NKEYDK)   
              PATHY  = PATHN(1:NCH)//'/'//PATHX 
              CALL RZCDIR (PATHY, ' ')  
              IF (IQUEST(1).NE.0) THEN  
                IQUEST(1) = 143 
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENFZ :'//    
     +          ' Illegal path name '//PATHY//''')', IARGDB, 0) 
                GO TO 999   
              ENDIF 
              NKEYDK = IQUEST(7)    
              NWKYDK = IQUEST(8)    
              LCDRDB = IQUEST(11)   
              IKDRDB = IQUEST(13)   
            ENDIF   
          ENDIF 
          GO TO 20  
   15   CONTINUE    
   20   CALL UCOPY_i (KEYO, KEYN, NWKYDK) 
        KOBJ   = KEYO(MOBJDB)   
      ENDIF 
*   
      IF (KEY1.LE.0.AND.IOPP.EQ.0) THEN 
        IF (NKEYDK.GT.0) THEN   
          DO 25 IK = 1, NKEYDK  
            IP     = KOFSDB + LCDRDB + IKDRDB + (IK-1)*ISTP + MSERDB    
            IF (IQ(IP).GT.KOBJ) KOBJ = IQ(IP)   
   25     CONTINUE  
        ENDIF   
        KOBJ   = KOBJ + 1   
        IHEADF(MPREDF+MSERDB) = KOBJ    
      ENDIF 
      IHEADF(MPREDF+MUPNDB) = 0 
      IHEADF(MPREDF+MFLGDB) = MSBIT0 (IHEADF(MPREDF+MFLGDB), JRZUDB)    
      IHEADF(MPREDF+MFLGDB) = MSBIT0 (IHEADF(MPREDF+MFLGDB), JPRTDB)    
      IHEADF(MPREDF+MFLGDB) = MSBIT0 (IHEADF(MPREDF+MFLGDB), JASFDB)    
      IF (IOKYDA(MITMDB).EQ.0.AND.IHEADF(MPREDF+MITMDB).LE.0) THEN  
        CALL DATIME (IDATE, ITIME)  
        CALL DBPKTM (IDATE, ITIME, IHEADF(MPREDF+MITMDB))   
      ENDIF 
*   
* *** Now read the data part of the transcript file 
*   
      IF (LUNFZ.GT.0) THEN
        iuhead(1) = 0
        CALL FZIN (LUNFZ, IDISDB, LFIXDB, JBIAS, 'A', 0, iuhead) 
        IF (IQUEST(1).GT.0) THEN    
          IQUEST(1) = -1    
          GO TO 999 
        ELSE IF (IQUEST(1).NE.0) THEN   
          IQUEST(11) = IQUEST(1)    
          IQUEST(1)  = 141  
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENFZ : FZ er'//    
     +    'ror type '',I12)', IQUEST(11), 1)    
          GO TO 999 
        ENDIF   
      ENDIF 
*   
      IDB    = IDBTYP (LFIXDB)  
      IF (IDB.EQ.2.OR.IDB.EQ.3) THEN    
        IOPTR  = 0  
      ELSE  
        IOPTR  = 1  
      ENDIF 
*   
      IF (IOPRDA.NE.0 .OR. IOPTR.NE.0 .OR. IOPTDA.NE.0) THEN    
        IF (IOPTDA.NE.0) THEN   
          CHOP   = 'S'  
        ELSE IF (IOPRDA.NE.0) THEN  
          CHOP   = 'L'  
        ELSE    
          CHOP   = ' '  
        ENDIF   
      ELSE  
        CHOP   = 'S'    
      ENDIF 
*   
*  ** Write the sequential output if needed 
*   
      IF (LUFZDF.GT.0) THEN 
        CALL FZOUT (LUFZDF, IDISDB, LFIXDB, 1, CHOP, IOFMDF, NWHEDF,    
     +              IHEADF) 
        IER    = IQUEST(1)  
        IF (IER.NE.0) THEN  
          CALL MZDROP (IDISDB, LFIXDB, 'L') 
          IQUEST(1)  = 77   
          IF (IDEBDB.GT.0) THEN 
            PATHY  = PATHN  
            CALL DBPRNT (LPRTDB, '(/,'' DBENFZ : Error in FZOUT for'//  
     +           ' '//PATHY//''')', IARGDB, 0)  
          ENDIF 
          GO TO 999 
        ENDIF   
      ENDIF 
*   
* *** Compress the data if needed   
*   
      IF (IOPRDA.NE.0 .OR. IOPTR.NE.0 .OR. IOPTDA.NE.0) THEN    
        IHEADF(MPREDF+MFLGDB) = MSBIT1 (IHEADF(MPREDF+MFLGDB), JRZUDB)  
        IF (IOPTDA.NE.0)    
     +    IHEADF(MPREDF+MFLGDB) = MSBIT1 (IHEADF(MPREDF+MFLGDB), JASFDB)    
      ELSE  
        LBDADB = LFIXDB 
        LFIXDB = 0  
        IF (IQ(KOFUDB+LBDADB-1).EQ.0) IOPUDA = 1    
        CALL DBFRUS (LBDADB, LSTRDL(1), IPREC)  
        IER    = IQUEST(1)  
        CALL MZDROP (IDISDB, LBDADB, 'L')   
        IF (IER.NE.0) THEN  
          IQUEST(1) = IER   
          GO TO 999 
        ELSE    
          IQUEST(1) = 0 
        ENDIF   
        IF (IOPUDA.NE.0) THEN   
          LFIXDB = LSTRDL(1)    
        ELSE    
          CALL DBCOMP (LSTRDL(1), LFIXDB, IHEADF(MPREDF+1)) 
          IER    = IQUEST(1)    
          IF (LSTRDL(1).NE.LFIXDB) CALL MZDROP (IDISDB, LSTRDL(1),'L')  
          IF (IER.NE.0) THEN    
            IQUEST(1) = IER 
            GO TO 999   
          ELSE  
            IQUEST(1) = 0   
          ENDIF 
        ENDIF   
      ENDIF 
*   
* *** Save the record on data base  
*   
      IF (IOPS.NE.0) CALL RZLOCK ('DBENFZ') 
      CALL RZOUT (IDISDB, LFIXDB, IHEADF(MPREDF+1), ICYCL, CHOP)    
      IER    = IQUEST(1)    
      IF (IOPS.NE.0) CALL RZFREE ('DBENFZ') 
      CALL MZDROP (IDISDB, LFIXDB, 'L') 
      IF (IER.NE.0) THEN    
        IQUEST(1) = 144 
        IF (IDEBDB.GT.0) THEN   
          PATHY  = PATHN    
          CALL DBPRNT (LPRTDB, '(/,'' DBENFZ : RZOUT  error for path '//    
     +         'name '//PATHY//''')', IARGDB, 0)    
        ENDIF   
        GO TO 999   
      ELSE  
        IF (IDEBDB.GT.1) THEN   
          CALL UCOPY_i (IHEADF(MPREDF+1), KEYNDK, NWKYDK) 
          CALL DBUPTM (IARGDB(1), IARGDB(2), KEYNDK(MITMDB))    
          CALL DBPRNT (LPRTDB, '(/,'' DBENFZ : Data was inserted into'//    
     +         '   '//PATHY//''',/,10X,''on the '',I8,'' at '',I6,'' '//    
     +         'with Key-Vector '')', IARGDB, 2)    
          CALL DBKEYT   
          CALL DBPRKY (NWKYDK, KEYNDK, IOTYDK)  
        ENDIF   
        IF (IOPTP.NE.0) THEN    
          KEYN(MBVRDB) = MIN0 (KEYN(MBVRDB), IHEADF(MPREDF+MBVRDB)) 
          KEYN(MEVRDB) = MAX0 (KEYN(MEVRDB), IHEADF(MPREDF+MEVRDB)) 
          CALL RZCDIR (PATHN, ' ')  
          IF (IQUEST(1).NE.0) THEN  
            IQUEST(1) = 143 
            IF (IDEBDB.GT.0) THEN   
              PATHY  = PATHN    
              CALL DBPRNT (LPRTDB, '(/,'' DBENFZ : Illegal path name'// 
     +             ' '//PATHY//''')', IARGDB, 0)    
            ENDIF   
            GO TO 999   
          ENDIF 
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          IF (IOPS.NE.0) CALL RZLOCK ('DBENFZ') 
          CALL RZRENK (KEYO, KEYN)  
          IERR   = IQUEST(1)    
          IF (IOPS.NE.0) CALL RZFREE ('DBENFZ') 
          IF (IERR.NE.0) THEN   
            IQUEST(1) = 145 
            IF (IDEBDB.GT.0) THEN   
              PATHY  = PATHN    
              CALL DBPRNT (LPRTDB, '(/,'' DBENFZ : RZRENK error for '// 
     +             'path name '//PATHY//''')', IARGDB, 0)   
            ENDIF   
            GO TO 999   
          ENDIF 
        ENDIF   
      ENDIF 
*   
  998 IQUEST(1) = 0 
*                                                             END DBENFZ    
  999 END   
      SUBROUTINE DBFLIN (A, IA, N, IPREC, IER)  
*     ========================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBFLIN (A, IA*, N, IPREC, IER*)                         *    
*                                                                      *    
*   Converts floating to signed integer according to the given         *    
*   precision                                                          *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     A        Input array of real numbers                             *    
*     IA(*)    Output array of signed integers                         *    
*     N        Length of the array                                     *    
*     IPREC    Signed precision word; the data are truncated after     *    
*              having multiplied by 10**IPREC                          *    
*     IER(*)   Error Code : 0    No error                              *    
*                           1    Precision not given or not correct    *    
*                           2    Data exceeds 32 bits                  *    
*                           3    Data is not uncompressed              *    
*                                                                      *    
*   Called by DBCMPR                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IER       =  0 : No error (see above)                            *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      DIMENSION       A(N), IA(N)   
*   
      DATA            TOOBIG /2.1474E9/ 
*   
*     ------------------------------------------------------------------    
*   
      IER    = 0    
*   
* *** Is data uncompressed ?    
*   
      IF (A(1).NE.0.) THEN  
        IER    = 3  
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBFLIN : Data is'//    
     +  ' not uncompressed !'')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
*   
* *** Precision ?   
*   
      IPREC  = A(2) 
      IF (IPREC.LT.-99.OR.IPREC.GT.99) THEN 
        IER    = 1  
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBFLIN : Precisi'//    
     +  'on is not correctly given - no compression'',/)', IARGDB, 0)   
        GO TO 999   
      ENDIF 
      IF (IPREC.EQ.0) THEN  
        IER    = 1  
CCC     IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBFLIN : Precisi'//    
CCC  +  'on is not given - Compression cannot be made'',/)', IARGDB, 0) 
        GO TO 999   
      ENDIF 
      IPR1   = 0    
      IPR2   = 0    
      IF (IPREC.GT.0) IPR2 = IPREC  
      IF (IPREC.LT.0) IPR1 = -IPREC 
*   
      IF (IPR1.NE.0) THEN   
        XMULT  = 1./10.**IPR1   
        DO 10 I = 3, N  
          XXX    = A(I)*XMULT   
*   
*  **     Test overflow of IA - if overflow occurs, do not pack !   
*   
          IF (ABS(XXX).GT.TOOBIG) THEN  
            IER    = 2  
            IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBFLIN : Qua'//    
     +      'ntity to be packed exceeds 32-Bit Integer size - no pack'//    
     +      'ing'',/)', IARGDB, 0)  
            GO TO 999   
          ENDIF 
*   
          IA(I) = XXX   
   10   CONTINUE    
      ELSE  
        XMULT  = 10.**IPR2  
        DO 20 I = 3, N  
          XXX    = A(I)*XMULT   
*   
*  **     Test overflow of IA - if overflow occurs, do not pack !   
*   
          IF (ABS(XXX).GT.TOOBIG) THEN  
            IER    = 2  
            IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBFLIN : Qua'//    
     +      'ntity to be packed exceeds 32-Bit Integer size - no pack'//    
     +      'ing'',/)', IARGDB, 0)  
            GO TO 999   
          ENDIF 
*   
          IF (XXX.GE.0.) THEN   
            IA(I) = IFIX (XXX + 0.5)    
          ELSE  
            IA(I) = IFIX (XXX - 0.5)    
          ENDIF 
   20   CONTINUE    
      ENDIF 
*                                                             END DBFLIN    
  999 END   
      SUBROUTINE DBFPAT (CPATH, LEVMX, LAD) 
*     ===================================== 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBFPAT (CPATH, LEVMX, LAD*)                             *    
*                                                                      *    
*   Store the information of the directory tree CPATH in a bank        *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     CPATH    The pathname of the directory tree about which the      *    
*              information has to be provided                          *    
*     LEVMX    Number of levels below CPATH about which information    *    
*              has to be accumulated                                   *    
*     LAD      Address of the bank containing the information          *    
*                                                                      *    
*   Called by DBKEPT, DBACPL                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =161 : Illegal path name                               *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NLEVM=20, NWITM=28, NPUSH=10)    
      PARAMETER       (NWLEV=8, NWNOD=6)    
      DIMENSION       NKEY(NLEVM), NCHD(NLEVM), ISDI(NLEVM) 
      DIMENSION       NSDI(NLEVM), IOPT(NLEVM)  
      DIMENSION       NODES(NLEVM), IHDIR(4)
      CHARACTER       PATHN*80, PATHX*16, PATHY*80, PATHD*80, PATHZ*16  
      CHARACTER       CPATH*(*), PATHF*80   
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension nio(9)
*     ------------------------------------------------------------------    
*   
      IF (LAD.NE.0) THEN 
        CALL MZDROP (IDIVDB, LAD, 'L')   
        LAD = 0  
      ENDIF 
      IF (LEVMX.LE.0) THEN  
        LEVEL  = NLEVM  
      ELSE  
        LEVEL  = LEVMX  
      ENDIF 
      CALL VZERO_i (NODES, NLEVM) 
      CALL DBSBLC (CPATH, PATHN, NCHAR) 
      CALL RZCDIR (PATHD, 'R')  
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 161 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFPAT : Illegal'//    
     +  ' path name '//PATHN//''')', IARGDB, 0) 
        GO TO 100   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      IF (NKEYDK.LE.0) THEN 
        IOPTP  = 0  
      ELSE  
        IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB) 
      ENDIF 
      CALL RZCDIR (PATHN, 'R')  
      NCHR   = INDEX (PATHN, ' ') - 1   
      IF (NCHR.LE.0.OR.NCHR.GT.MAXLDB) NCHR = MAXLDB    
      NLEV   = 1    
      NCHD(NLEV) = NCHR 
*   
* *** Create a temporary bank for storing information   
*   
      NDWD   = NPUSH * NWITM    
      NKEEP  = NPUSH    
      NITEM  = 0    
      NLEVT  = NLEV 
      NWDSN  = 0
      nio(1) = 0
      CALL DBBOOK (IDIVDB, LFIXDB, LFIXDB, 2, 'TEMP', 0, 0, NDWD, nio,
     &     -1)    
      IF (IQUEST(1).NE.0)                 GO TO 100 
*   
* *** Now scan down to find all the subdirectories  
*   
   10 IF (NLEV.GT.1) THEN   
        PATHN  = PATHN(1:NCHD(NLEV-1))//'/'//PATHX  
        NCHD(NLEV) = NCHD(NLEV-1) + NCHR + 1    
        CALL RZCDIR (PATHN, ' ')    
        NKEYDK = IQUEST(7)  
        NWKYDK = IQUEST(8)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        IF (NKEYDK.GT.0) THEN   
          IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)   
        ELSE    
          IOPTP  = 0    
        ENDIF   
      ENDIF 
      NKEY(NLEV) = NKEYDK   
      IOPT(NLEV) = IOPTP    
      ISDI(NLEV) = 0    
      NSDI(NLEV) = IQ(KOFSDB+LCDRDB+KNSDDB) 
      IF (NLEV.EQ.LEVEL) NSDI(NLEV) = 0 
*   
   20 ISDI(NLEV) = ISDI(NLEV) + 1   
      IF (ISDI(NLEV).LE.NSDI(NLEV)) THEN    
*   
*  **   If a new subdirectory go down one level 
*   
        LS    = IQ(KOFSDB+LCDRDB+KLSDDB)    
        IPNT  = LS + 7 * (ISDI(NLEV) - 1)   
        CALL ZITOH (IQ(KOFSDB+LCDRDB+IPNT), IHDIR, 4)   
        CALL UHTOC (IHDIR, 4, PATHX, 16)    
        NCHR  = INDEX (PATHX, ' ') - 1  
        IF (NCHR.LE.0.OR.NCHR.GT.16) NCHR = 16  
        IF (IOPTP.NE.0) THEN    
          DO 30 IK = 1, NKEYDK  
            KK     = IK 
            IDIG   = 0  
   25       IF (KK.GT.0) THEN   
              KK     = KK / 10  
              IDIG   = IDIG + 1 
              GO TO 25  
            ENDIF   
            IF (NCHR.EQ.IDIG) THEN  
              WRITE (PATHY, '(I8)') IK  
              I1     = 8 - IDIG + 1 
              PATHZ  = PATHY(I1:8)  
              IF (PATHZ.EQ.PATHX)         GO TO 20  
            ENDIF   
   30     CONTINUE  
        ENDIF   
        NLEV   = NLEV +1    
        IF (NLEV.GT.NLEVT) NLEVT = NLEV 
        GO TO 10    
*   
      ELSE  
*   
*  **   Enter the new path name in the temporary space  
*   
        IF (NLEV.EQ.1) THEN 
          NSTR   = 2    
          DO 35 I = 3, NCHD(1)  
            IF (PATHN(I:I).EQ.'/') NSTR = I 
   35     CONTINUE  
          PATHZ  = PATHN(NSTR+1:NCHD(NLEV)) 
          NCHR   = NCHD(NLEV) - NSTR    
          NCHRT  = NSTR - 1 
          PATHF  = PATHN(1:NCHRT)   
        ELSE    
          PATHZ  = PATHN(NCHD(NLEV-1)+2:NCHD(NLEV)) 
          NCHR   = NCHD(NLEV) - NCHD(NLEV-1) - 1    
          PATHF  = PATHN(1:NCHD(NLEV-1))    
          NCHRT  = NCHD(NLEV-1) 
        ENDIF   
        NODES(NLEV) = NODES(NLEV) + 1   
*   
        NITEM  = NITEM + 1  
        IF (NITEM.GT.NKEEP) THEN    
          LBDADB = LFIXDB   
          LFIXDB = 0    
          ND     = NDWD + NPUSH * NWITM
          nio(1) = 0
          CALL DBBOOK (IDIVDB, LFIXDB, LFIXDB, 2, 'TEMP', 0,0, ND, nio,
     &         -1) 
          IF (IQUEST(1).NE.0) THEN  
            IERR   = IQUEST(1)  
            CALL MZDROP (IDIVDB, LBDADB, ' ')   
            IQUEST(1) = IERR    
            GO TO 100   
          ENDIF 
          CALL UCOPY_i (IQ(KOFUDB+LBDADB+1), IQ(KOFUDB+LFIXDB+1), NDWD)   
          CALL MZDROP (IDIVDB, LBDADB, ' ') 
          NDWD   = IQ(KOFUDB+LFIXDB-1)  
          NKEEP  = NKEEP + NPUSH    
        ENDIF   
        NWDN   = (NCHR + 3) / 4 
        NWDSN  = NWDSN + NWDN   
        IPNT   = KOFUDB + LFIXDB + (NITEM - 1) * NWITM  
        IQ(IPNT+1) = NLEV   
        IQ(IPNT+2) = NODES(NLEV)    
        IQ(IPNT+3) = NCHR   
        IQ(IPNT+4) = NCHRT  
        CALL UCTOH (PATHZ, IQ(IPNT+5), 4, 16)   
        CALL UCTOH (PATHF, IQ(IPNT+9), 4, 80)   
*   
   50   NLEV   = NLEV - 1   
        IF (NLEV.GE.1) THEN 
          LUP    = LQ(KOFSDB+LCDRDB+1)  
          CALL MZDROP (0, LCDRDB, ' ')  
          LCDRDB = LUP  
          NKEYDK = NKEY(NLEV)   
          IOPTP  = IOPT(NLEV)   
          GO TO 20  
        ENDIF   
      ENDIF 
*   
* *** All subdirectories looked at; now store dictionary if permitted   
*   
   60 IF (NLEVT.GT.0) THEN  
        ND     = 3 + NWLEV*NLEVT + NWNOD*NITEM + NWDSN
        nio(1) = 0
        CALL DBBOOK (IDIVDB, LAD, LAD, 2, 'NAME', 0, 0, ND, nio, -1)    
        IF (IQUEST(1).NE.0) THEN    
          IERR   = IQUEST(1)    
          CALL MZDROP (IDIVDB, LFIXDB, ' ') 
          IQUEST(1) = IERR  
          GO TO 100 
        ENDIF   
        IOFF   = KOFUDB + LAD    
        KPNTL  = 3  
        IQ(IOFF+MPNLDB) = KPNTL 
        IQ(IOFF+MNLVDB) = NLEVT 
         Q(IOFF+MHFMDB) = 0.    
        IQ(IOFF+KPNTL+MPPLDB) = 0   
        DO 90 ILEV = 1, NLEVT   
          KPNTN  = KPNTL + NWLEV    
          NODET  = 0    
          DO 80 IN = 1, NITEM   
            IPNT   = KOFUDB + LFIXDB + (IN - 1) * NWITM 
            IF (IQ(IPNT+1).NE.ILEV)       GO TO 80  
            NODE   = IQ(IPNT+2) 
            NCHR   = IQ(IPNT+3) 
            NCHRT  = IQ(IPNT+4) 
            CALL UHTOC (IQ(IPNT+5), 4, PATHX, 16)   
            CALL UHTOC (IQ(IPNT+9), 4, PATHY, 80)   
            PATHF  = PATHY(1:NCHRT)//'/'//PATHX 
            NCHRP  = NCHRT + NCHR + 1   
            IF (ILEV.EQ.1) THEN 
              IUP    = 0    
            ELSE    
              DO 65 IM = 1, NITEM   
                IPNT   = KOFUDB + LFIXDB + (IM - 1) * NWITM 
                IF (IQ(IPNT+1).NE.ILEV-1) GO TO 65  
                NCHRU  = IQ(IPNT+3) 
                NCHRF  = IQ(IPNT+4) 
                IF (NCHRT.EQ.NCHRU+NCHRF+1) THEN    
                  CALL UHTOC (IQ(IPNT+5), 4, PATHZ, 16) 
                  CALL UHTOC (IQ(IPNT+9), 4, PATHY, 80) 
                  PATHY  = PATHY(1:NCHRF)//'/'//PATHZ   
                  IF (PATHF(1:NCHRT).EQ.PATHY(1:NCHRT)) THEN    
                    IUP    = IQ(IPNT+2) 
                    GO TO 70    
                  ENDIF 
                ENDIF   
   65         CONTINUE  
            ENDIF   
   70       NDOWN   = 0 
            IF (ILEV.LT.NLEVT) THEN 
              DO 75 IM = 1, NITEM   
                IPNT   = KOFUDB + LFIXDB + (IM - 1) * NWITM 
                IF (IQ(IPNT+1).NE.ILEV+1) GO TO 75  
                NCHRU  = IQ(IPNT+4) 
                IF (NCHRP.EQ.NCHRU) THEN    
                  CALL UHTOC (IQ(IPNT+9), 4, PATHY, 80) 
                  IF (PATHF(1:NCHRP).EQ.PATHY(1:NCHRP)) NDOWN = NDOWN +1    
                ENDIF   
   75         CONTINUE  
            ENDIF   
            NWDN   = (NCHR + 3) / 4 
            NTOT   = NWDN + NWNOD   
            NODET  = NODET + 1  
            IPNTN  = KPNTN  
            KPNTN  = IPNTN + NTOT   
            IQ(IOFF+IPNTN+MPNLDB) = KPNTN   
            IQ(IOFF+IPNTN+MNNUDB) = NODE    
            IQ(IOFF+IPNTN+MNFNDB) = IUP 
            IQ(IOFF+IPNTN+MNDWDB) = NDOWN   
            IQ(IOFF+IPNTN+MNCHDB) = NCHR    
             Q(IOFF+IPNTN+MYFNDB) = 0.  
            CALL UCTOH (PATHX, IQ(IOFF+IPNTN+MNAMDB), 4, NCHR)  
   80     CONTINUE  
          IPNTL  = KPNTL    
          KPNTL  = KPNTN    
          IQ(IOFF+IPNTN+MPNLDB) = 0 
          IQ(IOFF+IPNTL+MLEVDB) = ILEV  
          IQ(IOFF+IPNTL+MNODDB) = NODET 
           Q(IOFF+IPNTL+MXOFDB) = 0.    
           Q(IOFF+IPNTL+MXWDDB) = 0.    
           Q(IOFF+IPNTL+MYFLDB) = 0.    
          IF (ILEV.LT.NLEVT) IQ(IOFF+KPNTL+MPPLDB) = IPNTL  
          IF (NODET.GT.0) THEN  
            IQ(IOFF+IPNTL+MPNNDB) = IPNTL + NWLEV   
            IQ(IOFF+IPNTL+MPNLDB) = KPNTL   
          ELSE  
            IQ(IOFF+IPNTL+MPNNDB) = 0   
            IQ(IOFF+IPNTL+MPNLDB) = KPNTL   
          ENDIF 
   90   CONTINUE    
        IQ(IOFF+IPNTL+MPNLDB) = 0   
      ENDIF 
      IF (LFIXDB.GT.0) CALL MZDROP (IDIVDB, LFIXDB, ' ')    
*   
      IQUEST(1) = 0 
  100 IERR   = IQUEST(1)    
      CALL RZCDIR (PATHD, ' ')  
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      IQUEST(1) = IERR  
*                                                             END DBFPAT    
  999 END   
      SUBROUTINE DBFRST (IDIV)  
*     ========================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBFRST (IDIV)                                           *    
*                                                                      *    
*   Initializes of the Data Base Package (for each file)               *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IDIV     User Division                                           *    
*                                                                      *    
*   Called by DBINIT                                                   *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MNSYS = 10000)   
*   
*             ZEBRA system common blocks    
*   
      COMMON /ZUNIT/ IQREAD,IQPRNT,IQPR2,IQLOG,IQPNCH,IQTTIN,IQTYPE 
      COMMON /ZUNITZ/IQDLUN,IQFLUN,IQHLUN,  NQUSED  
      COMMON /MZCB/  JQSTOR,KQT,KQS,  JQDIVI,JQDIVR 
     +,              JQKIND,JQMODE,JQDIVN,JQSHAR,JQSHR1,JQSHR2,NQRESV   
     +,              LQSTOR,NQFEND,NQSTRU,NQREF,NQLINK,NQMINR,LQ2END    
     +,              JQDVLL,JQDVSY,NQLOGL,NQSNAM(6) 
                                       DIMENSION    IQCUR(16)   
                                       EQUIVALENCE (IQCUR(1),LQSTOR)    
      COMMON /MZCC/  LQPSTO,NQPFEN,NQPSTR,NQPREF,NQPLK,NQPMIN,LQP2E 
     +,              JQPDVL,JQPDVS,NQPLOG,NQPNAM(6) 
     +,              LQSYSS(10), LQSYSR(10), IQTDUM(22) 
     +,              LQSTA(21), LQEND(20), NQDMAX(20),IQMODE(20)    
     +,              IQKIND(20),IQRCU(20), IQRTO(20), IQRNO(20) 
     +,              NQDINI(20),NQDWIP(20),NQDGAU(20),NQDGAF(20)    
     +,              NQDPSH(20),NQDRED(20),NQDSIZ(20)   
     +,              IQDN1(20), IQDN2(20),      KQFT, LQFSTA(21)    
                                       DIMENSION    IQTABV(16)  
                                       EQUIVALENCE (IQTABV(1),LQPSTO)   
      COMMON /ZEBQ/  IQFENC(4), LQZEB(100)  
*   
      COMMON /DAOPTI/ CALFDA(62), CSTRDA    
      CHARACTER       CALFDA*1, CSTRDA*132  
      COMMON /DAOPT1/ MPAKDA(2) 
      INTEGER         MPAKDA    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (NSVMDS=50, NSAVDS=20, MXDMDS=100)    
      COMMON /DSAVBK/ NOBJDS, LOBJDS(NSVMDS), KEYSDS(MXDMDS,NSVMDS) 
*   
      CHARACTER       CHFOR*9, CHTAG(NINEDK)*8, CHFRM*20    
      CHARACTER       CHNAM*62  
*   
      DATA            CHFOR /'IIIIIIIII'/   
      DATA            CHTAG /'SERIAL_#', 'POINTER ', 'STR_VALI',    
     +                       'END_VALI', 'PRG_VERS', 'FLAGS   ',    
     +                       'INS_TIME', 'KEY 8   ', 'KEY 9   '/    
      DATA            CHNAM 
     +/'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz'/    
*   
*     ------------------------------------------------------------------    
*   
* *** DB System initialization  
*   
      LPRTDB = IQPRNT   
      IDIVDB = IDIV 
      IDEBDB = 0    
      LQST   = LOCF(LQ(1)) - 1  
      LQZB   = LQST + 1 - LOCF(LQZEB(1))    
      CALL MZSDIV (0, -1)   
      KOFSDB = KQS - LQZB   
      CALL MZSDIV (IDIVDB, -1)  
      KOFUDB = KQS - LQZB   
      MXSYS  = 4*NQDMAX(KQT+1)/5    
      CALL MZDIV  (IDIVDB, IDISDB, 'DB-SYSTM', MNSYS, MXSYS, 'LC')  
      CALL MZLINK (IDIVDB, '/DLINKS/', LSTRDL(1), LSTRDL(1),    
     +             LREFDL(10))  
      CALL MZLINK (IDIVDB, '/DBUSER/', LBADDB, LBDADB, LTOPDB)  
      CALL MZLINK (IDISDB, '/DSAVBK/', LOBJDS(1), LOBJDS(1),    
     +             LOBJDS(NSVMDS))  
      CALL MZLINK (0, '/DBSTOR/', LCDRDB, LCDRDB, LJNKDB)   
*   
* *** Initialize the IO descriptors 
*   
      ICHR0  = ICHAR ('0')  
      CHFRM  = '4I '//CHAR(NWNODB/10+ICHR0)//   
     +                CHAR(MOD(NWNODB,10)+ICHR0)//'B -H'    
      CALL MZFORM ('NODB', CHFRM, IONODB)   
      CALL MZFORM ('UPDB', '8I -H', IUPDB)  
      CALL MZFORM ('DIDB', '1I / 3I 22H', IODIDB)   
      CALL UCTOH  ('KYDB', IHKYDB, 4, 4)    
      CHFRM  = CHAR(MFZDIR+ICHR0-1)//'H / 1I 20H'   
      CALL MZFORM ('FZDB', CHFRM, IOFZDB)   
      CALL MZFORM ('FDDB', '/ 1I 20H', IOFDDB)  
*   
      INSRDB = 0    
      KY7MDB = 0    
      NTOPDB = 0    
      CALL DBPKTS (991231, 235959, IBIGDB)  
*   
      NUFZDF = 0    
      KEY7DK = 0    
      CHFTDK = CHFOR    
      DO 10 I = 1, 9    
   10 CHTGDK(I) = CHTAG(I)  
*   
      DO 15 K = 1, 62   
 15     CALFDA(K) = CHNAM(K:K)
      IOPADA = 0
      IOPBDA = 0
      IOPCDA = 0
      IOPDDA = 0
      IOPEDA = 0
      IOPFDA = 0
      IOPGDA = 0
      IOPHDA = 0
      IOPIDA = 0
      IOPJDA = 0
      IOPKDA = 0
      IOPLDA = 0
      IOPMDA = 0
      IOPNDA = 0
      IOPODA = 0
      IOPPDA = 0
      IOPQDA = 0
      IOPRDA = 0
      IOPSDA = 0
      IOPTDA = 0
      IOPUDA = 0
      IOPVDA = 0
      IOPWDA = 0
      IOPXDA = 0
      IOPYDA = 0
      IOPZDA = 0
      CALL VZERO_i (IOKYDA, MXKYDA)    
      MPAKDA(1) = 8 
      MPAKDA(2) = 4 
      CSTRDA( 32: 47) = ' !"#$%&''()*+,-./' 
      CSTRDA( 48: 57) = '0123456789'    
      CSTRDA( 58: 64) = ':;<=>?@'   
      CSTRDA( 65: 90) = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'    
      CSTRDA( 91: 96) = '[\]^_`'    
      CSTRDA( 97:122) = 'abcdefghijklmnopqrstuvwxyz'    
      CSTRDA(123:126) = '{|}~'  
*   
      TOPLDI = ' '  
*                                                             END DBFRST    
      END   
      SUBROUTINE DBFRUS (LC, LU, IPREC) 
*     ================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBFRUS (LC, LU*, IPREC)                                 *    
*                                                                      *    
*   Copies bank of LC from the user system to bank at LU of the Data   *    
*   Base internal system (where 1st word = 0, 2nd word = IPREC)        *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LC       Address of the input bank                               *    
*     LU(*)    Address of the output bank                              *    
*     IPREC    Signed precision word; the data are truncated after     *    
*              having multiplied by 10**IPREC                          *    
*                                                                      *    
*   Called by DBENTB, DBNTOP, DBENFZ, DBKOUT                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 92 : Nonstandard IO descriptor                       *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DZPACK/ PRECDZ, PACKDZ    
      LOGICAL         PACKDZ    
*   
      DIMENSION       LU(*)
*
      dimension nio(9)
*     ------------------------------------------------------------------    
*   
      LREFDB(4) = LC
      NDU    = IQ(KOFUDB+LREFDB(4)-1) + 2   
      ITU    = IDBTYP (LREFDB(4))   
      IF (ITU.NE.2 .AND. ITU.NE.3 .AND. ITU.NE.5) THEN  
        IQUEST(1) = 92  
        IQUEST(11)= ITU 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFRUS : Illegal'//    
     +  ' Data-type '',I5,/)', IQUEST(11), 1)   
        GO TO 999   
      ENDIF 
      JBIAS  = 2
      nio(1) = itu
      CALL DBBOOK (IDISDB, LU(1), LU(1), JBIAS, 'BASE', 0, 0, NDU, nio, 
     +             0)   
      IF (IQUEST(1).NE.0) GO TO 999 
      IF (ITU.EQ.3) THEN    
        CALL UCOPY (Q(KOFUDB+LREFDB(4)+1), Q(KOFUDB+LU(1)+3), NDU-2)    
        Q (KOFUDB+LU(1)+1) = 0. 
        IF (PACKDZ) THEN    
          Q (KOFUDB+LU(1)+2) = 0.   
        ELSE    
          Q (KOFUDB+LU(1)+2) = IPREC    
        ENDIF   
      ELSE IF (ITU.EQ.2) THEN   
        CALL UCOPY_i (IQ(KOFUDB+LREFDB(4)+1), IQ(KOFUDB+LU(1)+3), NDU-2)  
        IQ(KOFUDB+LU(1)+1) = 0  
        IF (PACKDZ) THEN    
          IQ(KOFUDB+LU(1)+2) = 0    
        ELSE    
          IQ(KOFUDB+LU(1)+2) = IPREC    
        ENDIF   
      ELSE IF (ITU.EQ.5) THEN   
        CALL UCOPY_i (IQ(KOFUDB+LREFDB(4)+1), IQ(KOFUDB+LU(1)+3), NDU-2)  
        IQ(KOFUDB+LU(1)+1) = 0  
        IQ(KOFUDB+LU(1)+2) = 0  
      ENDIF 
*                                                             END DBFRUS    
  999 END   
      SUBROUTINE DBFZIN (AI, NDI, AO, NDO, EPSIL, IER)  
*     ================================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBFZIN (AI, NDI, AO*, NDO*, EPSIL, IER*)                *    
*                                                                      *    
*   Compress floating point data (only nonzero elements are stored).   *    
*   Data are set to 0 if their absolute value is less than EPSIL       *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     AI       Input array to be compressed                            *    
*     NDI      Number of elements in AI                                *    
*     AO(*)    Output array of the nonzero elements                    *    
*     NDO(*)   Number of elements in AO                                *    
*     EPSIL    Cutoff value                                            *    
*     IER(*)   Error Code : 0    No error                              *    
*                           1    NDO .ge. NDI                          *    
*                                                                      *    
*   Called by DBCMPZ                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IER       =  0 : No error (see above)                            *    
*                                                                      *    
************************************************************************    
*   
      DIMENSION       AI(NDI), AO(NDI)  
*   
*     ------------------------------------------------------------------    
*   
      IER    = 0    
*   
      NDO    = 0    
      DO 10 I = 1, NDI  
        IF (ABS(AI(I)).LE.EPSIL) GO TO 10   
        NDO    = NDO + 1    
        IF (NDO.GE.NDI) THEN    
          IER    = 1    
          GO TO 999 
        ENDIF   
        AO(NDO) = I 
        NDO    = NDO + 1    
        IF (NDO.GE.NDI) THEN    
          IER    = 1    
          GO TO 999 
        ENDIF   
        AO(NDO) = AI(I) 
   10 CONTINUE  
*                                                             END DBFZIN    
  999 END   
      SUBROUTINE DBFZWR (IPREC, CHOPT)  
*     ================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBFZWR (IPREC, CHOPT)                                   *    
*                                                                      *    
*   Copies the current data structure in memory into the journal file  *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IPREC    Precision word used in the packing algorithm            *    
*     CHOPT    Character string to be written in the journal file      *    
*                                                                      *    
*   Called by DBRTFZ                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 76 : Cannot form the IO descriptor for the FZ header *    
*               = 77 : FZOUT fails to write on to the sequential file  *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NSVMDS=50, NSAVDS=20, MXDMDS=100)    
      COMMON /DSAVBK/ NOBJDS, LOBJDS(NSVMDS), KEYSDS(MXDMDS,NSVMDS) 
*   
      COMMON /DZPACK/ PRECDZ, PACKDZ    
      LOGICAL         PACKDZ    
*   
      PARAMETER       (NLEVM=20)    
      INTEGER         NLCUR(NLEVM)  
      CHARACTER       CHCUR(NLEVM)*1, CHFRM*100, CFORM(6)*1, CHOP0*4    
      CHARACTER       CHOPT*(*) 
      DATA            CFORM /'B', 'I', 'F', 'D', 'H', 'A'/  
*

      integer ival
      real fval
      equivalence (ival, fval)
*     ------------------------------------------------------------------    
*   
* *** Write the sequential output if needed 
*   
      IF (IOPFDA.EQ.0) THEN 
        CHOP0  = CHOPT  
      ELSE  
        CHOP0  = 'F'//CHOPT 
      ENDIF 
*   
*  ** Find the IO descriptor of the header  
*   
      NLEV   = 1    
      NCUR   = 5    
      IFORO  = 2    
      CHCUR(NLEV) = CFORM(IFORO)    
      IF (INDEX(CHOP0,'Z').NE.0) THEN   
        NLCUR(NLEV) = 4 
        IFORO  = 3  
        NCUR   = 1  
        NLEV   = NLEV + 1   
        CHCUR(NLEV) = CFORM(IFORO)
        fval = precdz
        iheadf(mpredf) = ival
      ELSE  
        IHEADF(MPREDF) = IPREC  
      ENDIF 
      DO 10 I = 1, NWKYDK   
        IFORM  = IOTYDK(I)  
        IF (IFORM.EQ.6) IFORM = 5   
        IF (IFORM.EQ.IFORO) THEN    
          NCUR   = NCUR + 1 
        ELSE    
          NLCUR(NLEV) = NCUR    
          IF (NLEV.GE.NLEVM) THEN   
            IQUEST(1) = 76  
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZWR : Can'//    
     +      'not get IO descriptor '')', IARGDB, 0) 
            GO TO 999   
          ENDIF 
          NLEV   = NLEV + 1 
          CHCUR(NLEV) = CFORM(IFORM)    
          NCUR   = 1    
          IFORO  = IFORM    
        ENDIF   
   10 CONTINUE  
      NLCUR(NLEV) = NCUR    
      WRITE (CHFRM, 2001) (NLCUR(I), CHCUR(I), I = 1, NLEV) 
      II     = 4 *NLEV  
      CHFRM = CHFRM(1:II)//' -H'    
      CALL MZIOCH (IOFMDF, NWFMDF, CHFRM(1:II+3))   
*   
*  ** Write on the FZ file  
*   
      CALL UCTOH (CHOP0, IHEADF(MPREDF+NWKYDK+1), 4, 4) 
      CALL UCOPY_i (KEYSDS(1,1), IHEADF(MPREDF+1), NWKYDK)    
      CALL FZOUT (LUFZDF, IDISDB, LOBJDS(1), 1, 'L', IOFMDF,    
     +            NWHEDF, IHEADF)   
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1)  = 77 
        IQUEST(11) = 1  
        IQUEST(12) = 1  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZWR : Error '// 
     +  'in FZOUT while writing Data'')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
*   
 2001 FORMAT (20(I2,A1,1X)) 
*                                                             END DBFZWR    
  999 END   
      SUBROUTINE DBGNAM (PATH, CHTAG, IOBJ) 
*     ===================================== 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBGNAM (PATH, CHTAG, IOBJ*)                             *    
*                                                                      *    
*   Identifies the object element number from its name and the name    *    
*   of the directory path name                                         *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATH     Character string describing the pathname                *    
*     CHTAG    Name of the data element                                *    
*     IOBJ(*)  Object element number (0 if not found)                  *    
*                                                                      *    
*   Called by DBACPL                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =182 : Illegal path name                               *    
*               =201 : DICTIONARY directory not found                  *    
*               =202 : No description of data elements for the given   *    
*                      path name exists in the data base               *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      CHARACTER       PATHN*80, CTAG*8, TOPN*16, PATHD*32, PATH*(*) 
      CHARACTER       CHTAG*(*) 
*   
*     ------------------------------------------------------------------    
*   
* *** See if the path name is correct   
*   
      IOBJ   = 0    
      CALL DBSBLC (PATH, PATHN, NCHAR)  
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 182 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGNAM : Illegal'//    
     +  ' path name '//PATHN//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL RZCDIR (PATHN, 'R')  
      NCHAR  = LENOCC (PATHN)   
      CALL DBGPID (PATHN, NCHAR, TOPN, IDN) 
      IF (IDN.LE.0) THEN    
        IQUEST(1) = 182 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGNAM : Illegal'//    
     +  ' path name '//PATHN//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
*   
* *** Set the current directory to DICTIONARY and retrieve object   
*   
      NCH    = LENOCC (TOPN)    
      PATHD  = '//'//TOPN(1:NCH)//'/DICTIONARY' 
      CALL RZCDIR (PATHD, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 201 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGNAM : Path na'//    
     +  'me '//PATHD(1:NCH)//' not found'')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKEYT   
      ISTP   = NWKYDK + 1   
      IPNT   = KOFSDB + LCDRDB + IKDRDB 
      KPNT   = IUHUNT (IDN, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP) 
      IF (KPNT.LE.0) THEN   
        IQUEST(1) = 202 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGNAM : No info'//    
     +  'rmation for '//PATHN(1:NCHAR)//' inside Data Base'')',IARGDB,0)    
        GO TO 999   
      ENDIF 
      KEY1S  = (KPNT - MSERDB) / ISTP + 1   
      CALL VZERO_i (KEYVDK, NWKYDK)   
      KEYVDK(1) = KEY1S 
      IF (LSTRDL(1).NE.0) THEN  
        CALL MZDROP (IDISDB, LSTRDL(1), 'L')    
        LSTRDL(1) = 0   
      ENDIF 
      IOLD1  = IOKYDA(MSERDB)   
      IOLDK  = IOPKDA   
      IOPKDA = 0    
      IOKYDA(MSERDB) = 1    
      ITIME  = 1    
      CALL DBKXIN (ITIME, IDISDB, LSTRDL(1), LSTRDL(1), 2, NWKYDK,  
     +             KEYVDK, IPREC)   
      IER    = IQUEST(1)    
      IOPKDA = IOLDK    
      IOKYDA(MSERDB) = IOLD1    
      IF (IER.NE.0) THEN    
        CALL MZDROP (IDISDB, LSTRDL(1), 'L')    
        IQUEST(1) = IER 
        GO TO 999   
      ENDIF 
*   
* *** Now store the information in the user array   
*   
      IPNT   = KOFUDB + LSTRDL(1)   
      NWDS   = IQ(IPNT-1) / 2   
      DO 10 I = 1, NWDS 
        CALL UHTOC (IQ(IPNT+1), 4, CTAG, 8) 
        IF (CTAG.EQ.CHTAG) THEN 
          IOBJ   = I    
          GO TO 20  
        ENDIF   
        IPNT   = IPNT + 2   
   10 CONTINUE  
   20 CALL MZDROP (IDISDB, LSTRDL(1), 'L')  
      LSTRDL(1) = 0 
      IQUEST(1) = 0 
*                                                             END DBGNAM    
  999 END   
      SUBROUTINE DBGPID (PATH, NCHAR, TOPN, IDN)    
*     ==========================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBGPID (PATH, NCHAR, TOPN*, IDN*)                       *    
*                                                                      *    
*   Finds the unique directory identifier from the path name           *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATH     Character string describing the pathname                *    
*     NCHAR    Number of characters in PATH                            *    
*     TOPN(*)  Name of the top directory                               *    
*     IDN(*)   Unique directory identifier                             *    
*                                                                      *    
*   Called by DBEALI, DBEHLP, DBENAM, DBRHLP, DBRNAM, DBGNAM           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IDN       >  0 : No error                                        *    
*               =  0 : No dictionary for directory identifier          *    
*               <  0 : Illegal path name                               *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      CHARACTER       PATHY*80, PATHZ*80, TOPN*(*), PATH*(*)    
*   
*     ------------------------------------------------------------------    
*   
* *** Extract the top directory and the trailing part from the path name    
*   
      IF (NCHAR.LT.3.OR.PATH(1:2).NE.'//') GO TO 999    
      NCHRT  = INDEX (PATH(3:NCHAR), '/') - 1   
      IF (NCHRT.LE.0) NCHRT = NCHAR - 2 
      TOPN   = PATH(3:NCHRT+2)  
      IDN    = -1   
      NCHF   = NCHRT + 2    
      IF (NCHAR.LE.NCHF)                   GO TO 999    
      PATHY  = PATH(NCHF+1:NCHAR)   
      NCHR   = NCHAR - NCHF 
      IDN    = 0    
*   
* *** Find the appropriate dictionary for the directory path name   
*   
      LTOP   = LTOPDB   
   10 IF (LTOP.NE.0) THEN   
        NCH    = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCH) 
        TOPNDI = TOPNDI(1:NCH)  
        IF (TOPN.NE.TOPNDI) THEN    
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 10  
        ENDIF   
      ELSE  
        GO TO 999   
      ENDIF 
      LDIC   = LQ(KOFUDB+LTOP-KLDICT)   
      IF (LDIC.LE.0)                       GO TO 999    
      NITEM  = IQ(KOFUDB+LDIC+MDCNTM)   
*   
* *** Look the current path in the dictionary   
*   
      DO 20 ITEM = 1, NITEM 
        IPNT   = KOFUDB + LDIC + (ITEM - 1) * NWITDB + 1    
        IF (IQ(IPNT+MDCITM).GT.0) THEN  
          IF (NCHR.EQ.IQ(IPNT+MDCNCH)) THEN 
            CALL UHTOC (IQ(IPNT+MDCNAM), 4, PATHZ, NCHR)    
            IF (PATHZ(1:NCHR).EQ.PATHY(1:NCHR)) THEN    
              IDN    = IQ(IPNT+MDCITM)  
              GO TO 999 
            ENDIF   
          ENDIF 
        ENDIF   
   20 CONTINUE  
*                                                             END DBGPID    
  999 END   
      SUBROUTINE DBHUNT (KEYV)  
*     ========================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBHUNT (KEYV*)                                          *    
*                                                                      *    
*   Returns the key elements of an object with matching user keys as   *    
*   in KEYVDK and with Key(2) = 0 (not updated)                        *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     KEYV(*)  Key vector found (if none found, set KEYV(1) = 0)       *    
*                                                                      *    
*   Called by DBDONT                                                   *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      DIMENSION       KEYV(9)   
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
* *** Look at all the keys in the subdirectory  
*   
      DO 20 IK1 = 1, NKEYDK 
        IK     = NKEYDK - IK1 + 1   
        CALL DBKEYR (IK, NWKYDK, KEYV)  
*   
        IF (KEYV(MUPNDB).NE.0)              GO TO 20    
        IF (KEYV(MPVSDB).NE.KEYVDK(MPVSDB)) GO TO 20    
        DO 10 I = NSYSDK+1, NWKYDK  
          IF (KEYV(I).NE.KEYVDK(I))         GO TO 20    
   10   CONTINUE    
        IF (JBIT(KEYV(MFLGDB),JRZUDB).EQ.0) GO TO 20    
        GO TO 999   
   20 CONTINUE  
      KEYV(1) = 0   
*                                                             END DBHUNT    
  999 END   
      SUBROUTINE DBIFCH (CH, I) 
*     ========================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBIFCH (CH, I*)                                         *    
*                                                                      *    
*   Converts single character CH (of type character) to an output      *    
*   integer I via the look-up table stored in CSTRDA                   *    
*   (Adapted from CHTOI from CERN Library)                             *    
*                                                                      *    
*   Called by DBLINC                                                   *    
*                                                                      *    
************************************************************************    
*   
      COMMON /DAOPTI/ CALFDA(62), CSTRDA    
      CHARACTER       CALFDA*1, CSTRDA*132  
      COMMON /DAOPT1/ MPAKDA(2) 
      INTEGER         MPAKDA    
*   
      CHARACTER       CH*1  
*     ------------------------------------------------------------------    
*   
      I = INDEX (CSTRDA(32:126), CH)    
      I = I + 31    
*                                                             END DBIFCH    
      END   
      SUBROUTINE DBIFRC (CH, IAR, NWD, NCH) 
*     ===================================== 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBIFRC (CH, IAR*, NWD, NCH)                             *    
*                                                                      *    
*   Converts character string CH (of type character and NCH long)      *    
*   to an output integer array IAR (of length NWD) via the look-up     *    
*   table stored in CSTRDA                                             *    
*                                                                      *    
*   Called by DBLINC                                                   *    
*                                                                      *    
************************************************************************    
*   
      COMMON /DAOPTI/ CALFDA(62), CSTRDA    
      CHARACTER       CALFDA*1, CSTRDA*132  
      COMMON /DAOPT1/ MPAKDA(2) 
      INTEGER         MPAKDA    
*   
      CHARACTER       CH*(*)    
      DIMENSION       IAR(9), IB(4) 
*     ------------------------------------------------------------------    
*   
      DO 10 J = 1, NWD  
        K   = 4*J - 4   
        DO 5 L = 1, 4   
          IF (K+L.LE.NCH) THEN  
            I = INDEX (CSTRDA(32:126), CH(K+L:K+L)) 
            IB(L) = I + 31  
          ELSE  
            IB(L) = 31  
          ENDIF 
    5   CONTINUE    
        CALL PKBYT (IB, IAR(J), 1, 4, MPAKDA)   
   10 CONTINUE  
*                                                             END DBIFRC    
  999 END   
      SUBROUTINE DBININ (IA1, IA2, N, IPREC, IER)   
*     ===========================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBININ (IA1, IA2*, N, IPREC, IER*)                      *    
*                                                                      *    
*   Truncates integer to signed integer according to the given         *    
*   precision                                                          *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IA1      Input array of integer numbers                          *    
*     IA2(*)   Output array of signed integers                         *    
*     N        Length of the array                                     *    
*     IPREC    Signed precision word; the data are truncated after     *    
*              having multiplied by 10**IPREC                          *    
*     IER(*)   Error Code : 0    No error                              *    
*                           1    Precision not given or not correct    *    
*                           3    Data is not uncompressed              *    
*                                                                      *    
*   Called by DBCMPR                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IER       =  0 : No error (see above)                            *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      DIMENSION       IA1(N), IA2(N)    
*   
*     ------------------------------------------------------------------    
*   
      IER    = 0    
*   
* *** Is data uncompressed ?    
*   
      IF (IA1(1).NE.0) THEN 
        IER    = 3  
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBININ : Data is'//    
     +  ' not uncompressed - no compression'')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
*   
* *** Precision ?   
*   
      IPREC  = IA1(2)   
*   
      IF (IPREC.GT.0) THEN  
        IER    = 1  
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBININ : Precisi'//    
     +  'on is not correctly given - no compression'')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
      IPR1   = -IPREC   
*   
      IF (IPR1.EQ.0) THEN   
        CALL UCOPY_i (IA1, IA2, N)    
        GO TO 999   
      ENDIF 
      XMULT  = 1./10**IPR1  
      DO 10 I = 3, N    
   10 IA2(I) = IA1(I)*XMULT 
      IA2(1) = IA1(1)   
      IA2(2) = IA1(2)   
*                                                             END DBININ    
  999 END   
      SUBROUTINE DBIZIN (IAI, NDI, IAO, NDO, EPSIL, IER)    
*     ==================================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBIZIN (IAI, NDI, IAO*, NDO*, EPSIL, IER*)              *    
*                                                                      *    
*   Compress integer data (only nonzero elements are stored).          *    
*   Data are set to 0 if their absolute value is less than EPSIL       *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IAI      Input array to be compressed                            *    
*     NDI      Number of elements in IAI                               *    
*     IAO(*)   Output array of the nonzero elements                    *    
*     NDO(*)   Number of elements in IAO                               *    
*     EPSIL    Cutoff value                                            *    
*     IER(*)   Error Code : 0    No error                              *    
*                           1    NDO .ge. NDI                          *    
*                                                                      *    
*   Called by DBCMPZ                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IER       =  0 : No error (see above)                            *    
*                                                                      *    
************************************************************************    
*   
      DIMENSION       IAI(NDI), IAO(NDI)    
*   
*     ------------------------------------------------------------------    
*   
      IER    = 0    
      IEPSI  = EPSIL    
*   
      NDO    = 0    
      DO 10 I = 1, NDI  
        IF (IABS(IAI(I)).LE.IEPSI) GO TO 10 
        NDO    = NDO + 1    
        IF (NDO.GE.NDI) THEN    
          IER    = 1    
          GO TO 999 
        ENDIF   
        IAO(NDO) = I    
        NDO    = NDO + 1    
        IF (NDO.GE.NDI) THEN    
          IER    = 1    
          GO TO 999 
        ENDIF   
        IAO(NDO) = IAI(I)   
   10 CONTINUE  
*                                                             END DBIZIN    
  999 END   
      SUBROUTINE DBKEYR (IKEY, NWKEY, KEY)  
*     ====================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBKEYR (IKEY, NWKEY, KEY*)                              *    
*                                                                      *    
*   Loads the Key vector in the array KEY                              *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IKEY     Index of the key                                        *    
*     NWKEY    Number of key elements to be fetched                    *    
*     KEY(*)   The Key vector which will contain the Key elements      *    
*              for key IKEY on output                                  *    
*                                                                      *    
*   Called by DBDLET, DBEALI, DBENTB, DBGET,  DBGETS, DBNTOP, DBPRGD,  *    
*             DBPURG, DBRENK, DBCDIC, DBCHCK, DBCHKY, DBCOMP, DBDELK,  *    
*             DBENFZ, DBKOUT, DBKXIN, DBKYSE, DBPRDT, DBSEKY, DBSNAM,  *    
*             DBUDIC, DBUNCP, DBPLNT, DBPLOB, DBPLOV, DBPLTI           *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      DIMENSION       KEY(9)    
*   
*     ------------------------------------------------------------------    
* *** Retrieve the keys 
*   
      ISTP   = NWKYDK + 1   
      IPNT   = KOFSDB + LCDRDB + IKDRDB + (IKEY - 1) * ISTP 
      DO 10 I = 1, NWKEY    
        IF (IOTYDK(I).EQ.5 .OR. IOTYDK(I).EQ.6)  THEN   
          CALL ZITOH (IQ(IPNT+I), KEY(I), 1)    
        ELSE    
          KEY(I) = IQ(IPNT+I)   
        ENDIF   
   10 CONTINUE  
*                                                             END DBKEYR    
  999 END   
      SUBROUTINE DBKEYS (LBN, KEYS, LBK, ITIME) 
*     ========================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBKEYS (LBN, KEYS, LBK*, ITIME)                         *    
*                                                                      *    
*   Creates or completes the Key banks supported as next of same type  *    
*   to the Node bank                                                   *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LBN      L-address of the Node bank                              *    
*     KEYS     Vector of keys                                          *    
*     LBK(*)   Address(es) of Keys bank(s) KYDB                        *    
*     ITIME    Time for which the valid keys are required              *    
*              (in option S)                                           *    
*                                                                      *    
*   Called by DBABRD, DBABWR, DBENTR, DBPURK, DBREPL, DBUSE            *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 21 : Too many keys with option M                     *    
*               = 22 : Illegal key option                              *    
*               = 23 : Key bank cannot be created; no space in memory  *    
*               = 24 : No Key bank created satisfying key options for  *    
*                      option S                                        *    
*               = 25 : Illegal Path Name                               *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NMLMDM=10)   
      COMMON /DMULOP/ INDXDM(NMLMDM), KEYVDM(NMLMDM), KTYPDM(NMLMDM)    
     +              , LFKYDM(NMLMDM), NOCCDM(NMLMDM)    
*   
      COMMON /DTKXIN/ ICURDT, IDNRDT, IKYLDT, IMINDT, INRSDT, IPRVDT    
     +              , IUSEDT, KEY6DT, KY6NDT, MNKYDT, NTIMDT    
*   
      PARAMETER       (NZ=0)    
      DIMENSION       KEYS(9), LBK(9)   
      CHARACTER       PATH*80, PATHN*80, PATHX*16   
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
      LREFDB(2) = LBN    
      IQUEST(1) = 0 
      NCHR   = IQ(KOFUDB+LREFDB(2)+MNDNCH)  
      CALL UHTOC (IQ(KOFUDB+LREFDB(2)+MNDNAM), 4, PATH, NCHR)   
      PATH   = PATH(1:NCHR) 
      NCHRT  = INDEX (PATH(3:NCHR), '/') - 1    
      IF (NCHRT.LE.0) NCHRT = NCHR - 2  
      PATHX  = PATH(3:NCHRT+2)  
      LBFXDB = LTOPDB   
    5 IF (LBFXDB.NE.0) THEN 
        NCHRT  = IQ(KOFUDB+LBFXDB+MUPNCH)   
        CALL UHTOC (IQ(KOFUDB+LBFXDB+MUPNAM), 4, TOPNDI, NCHRT) 
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN  
          LBFXDB = LQ(KOFUDB+LBFXDB)    
          GO TO 5   
        ENDIF   
        KY7MDB = IQ(KOFUDB+LBFXDB+MUPKY7)   
      ELSE  
        KY7MDB = 0  
      ENDIF 
      IF (IOPSDA.NE.0)                                      GO TO 70    
*   
* *** Get number of key banks needed    
*   
      NMUL   = 0    
      NKYMX  = 1    
      ISTKY  = NWKYDK   
      IF (IOPMDA.NE.0)  THEN    
        IF (NWKYDK.GT.NSYSDK)  THEN 
          DO 10 I = NSYSDK+1, NWKYDK    
            IF (IOKYDA(I).NE.0) THEN    
              IF (NMUL.GE.NMLMDM)  THEN 
*   
*  **           Too many keys with option M 
*   
                IQUEST(1)  = 21 
                IQUEST(11) = NMLMDM + 1 
                IQUEST(12) = I  
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEYS :'//    
     +          ' Too many keys '',I3,'' with M option - Last Key'',I3)'    
     +,         IQUEST(11), 2)  
                GO TO 999   
              ENDIF 
*   
              IF (KEYS(I).LE.0)  THEN   
*   
*  **           Illegal key option  
*   
                IQUEST(1)  = 22 
                IQUEST(11) = I  
                IQUEST(12) = KEYS(I)    
                IF (IDEBDB.GT.0) THEN   
                  IARGDB(1) = IQUEST(12)    
                  IARGDB(2) = IQUEST(11)    
                  CALL DBPRNT (LPRTDB, '(/,'' DBKEYS : Illegal key op'//    
     +                 'tion '',I3,'' for key '',I3,'' with option M'')'    
     +,                IARGDB, 2)   
                ENDIF   
                GO TO 999   
              ENDIF 
*   
*  **         Build up the array of keys used for option M  
*   
              NMUL   = NMUL + 1 
              NOCCDM(NMUL) = KEYS(I)    
              LFKYDM(NMUL) = ISTKY  
              KTYPDM(NMUL) = I  
              ISTKY  = ISTKY + KEYS(I)  
              NKYMX  = NKYMX * KEYS(I)  
            ENDIF   
   10     CONTINUE  
        ENDIF   
      ENDIF 
*   
* *** Loop over all possible Key Banks  
*   
      NK     = 0    
   15 NK     = NK + 1   
*   
*  ** For option 'M', find the corresponding key values 
*   
      IF (NMUL.GT.0)  THEN  
        DO 25 I = 1, NMUL   
          NK0    = NK   
          IF (I.NE.1)  THEN 
            DO 20 J = 1, I-1    
              NK0    = (NK0 - INDXDM(J)) / NOCCDM(J) + 1    
   20       CONTINUE    
          ENDIF 
          NK0    = MOD (NK0, NOCCDM(I)) 
          IF (NK0.EQ.0) NK0 = NOCCDM(I) 
          INDXDM(I) = NK0   
          KEYVDM(I) = KEYS(LFKYDM(I)+NK0)   
   25   CONTINUE    
      ENDIF 
*   
*  ** Check if this Key bank already exists 
*   
      LSAVDB = LREFDB(2)    
      JBIAS  = -KLKYDB  
      ND     = IQ(KOFUDB+LSAVDB+MNDNWD) 
      LBKYDB = LQ(KOFUDB+LSAVDB-KLKYDB) 
   30 IF (LBKYDB.NE.0)  THEN    
        IF (NWKYDK.GT.NSYSDK)  THEN 
          IF (NMUL.EQ.0)  THEN  
            DO 35 I = NSYSDK+1, NWKYDK  
              IF (IOKYDA(I).NE.0)  THEN 
                IF (KEYS(I).NE.IQ(KOFUDB+LBKYDB+I))         GO TO 45    
              ENDIF 
   35       CONTINUE    
            GO TO 50    
          ELSE  
            DO 40 I = 1, NMUL   
              NU     = KTYPDM(I)    
              IF (KEYVDM(I).NE.IQ(KOFUDB+LBKYDB+NU))        GO TO 45    
   40       CONTINUE    
            GO TO 50    
          ENDIF 
        ELSE    
          GO TO 50  
        ENDIF   
   45   LSAVDB = LBKYDB 
        LBKYDB = LQ(KOFUDB+LSAVDB)  
        JBIAS  = 0  
        GO TO 30    
      ELSE  
*   
*  *    The Key bank does not exist, create it  
*   
        CALL UCOPY_i  (IQ(KOFUDB+LREFDB(2)+MNDIOF), IOKYDB, NWNODB)   
        CALL DBBOOK (IDIVDB, LBKYDB, LSAVDB, JBIAS, 'KYDB', NLKYDB, 
     +               NSKYDB, ND, IOKYDB, NZ)    
        IF (IQUEST(1).NE.0)  THEN   
          IQUEST(1) = 23    
          IQUEST(11)= NK    
          IQUEST(12)= NKYMX 
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEYS : No sp'//    
     +    'ace in memory to create Key bank '',I3,'' out of '',I3)',    
     +    IQUEST(11), 2)    
          GO TO 999 
        ENDIF   
        LQ(KOFUDB+LBKYDB-KLNODB) = LREFDB(2)    
        LQ(KOFUDB+LBKYDB-KLUPDB) = LBFXDB   
      ENDIF 
*   
* *** Copy the key vector into Key bank 
*   
   50 LBK(NK) = LBKYDB  
      DO 55 I = 1, NSYSDK   
        IF (IOKYDA(I).NE.0) IQ(KOFUDB+LBKYDB+I) = KEYS(I)   
   55 CONTINUE  
      IF (NWKYDK.GT.NSYSDK)  THEN   
        IF (NMUL.EQ.0)  THEN    
          DO 60 I = NSYSDK+1, NWKYDK    
            IF (IOKYDA(I).NE.0) IQ(KOFUDB+LBKYDB+I) = KEYS(I)   
   60     CONTINUE  
        ELSE    
          DO 65 I = 1, NMUL 
            NU     = KTYPDM(I)  
            IQ(KOFUDB+LBKYDB+NU) = KEYVDM(I)    
   65     CONTINUE  
        ENDIF   
      ENDIF 
*   
      IF (NK.LT.NKYMX)                                      GO TO 15    
      GO TO 999 
*   
* *** 'S' option    
*   
   70 LFIXDB = LREFDB(2)    
*   
*  ** Start from the end of the existing chain  
*   
      IF (LQ(KOFUDB+LFIXDB-KLKYDB).NE.0) THEN   
        LBKYDB = LZLAST (IDIVDB, LQ(KOFUDB+LFIXDB-KLKYDB))  
        IF (LBKYDB.NE.0) LFIXDB = LBKYDB    
      ENDIF 
*   
*  ** Loop over all keys    
*   
      IF (NKEYDK.LE.0)  THEN    
        IQUEST(1) = 24  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEYS : No comp'//    
     +  'atible object for specified options'')', IARGDB, 0)    
        GO TO 999   
      ENDIF 
      LSAVDB = LFIXDB   
      CALL DBKEYT   
      IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)  
      IOPTP  = JBIT (IOPTP, JPRTDB) 
      KY4MDB = IBIGDB   
*   
      IF (IOPTP.EQ.0)  THEN 
        CALL DBKYSE (KEYS, ITIME)   
      ELSE  
        CALL RZCDIR (PATH, 'R') 
        MAXL   = INDEX (PATH, ' ') - 1  
        IF (MAXL.LT.1.OR.MAXL.GT.MAXLDB) MAXL = MAXLDB  
        NKEYS   = NKEYDK    
        KST     = NWKYDK + 1    
*   
*  **   Loop over all subdirectories    
*   
        DO 80 IK = 1, NKEYS 
          ICURDT = NKEYS + 1 - IK   
*   
*  *      Fast selection    
*   
          IF (IK.NE.1) THEN 
            CALL RZCDIR (PATH, ' ') 
            IF (IQUEST(1).NE.0)  THEN   
              IQUEST(1) = 25    
              IF (IDEBDB.NE.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEYS : I'//    
     +        'llegal Path name '//PATH//''')', IARGDB, 0)  
              GO TO 999 
            ENDIF   
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
            NWKYDK = IQUEST(8)  
          ENDIF 
*   
          KPNT   = IUHUNT (ICURDT, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB), 
     +                     NKEYS*KST, KST)  
          IF (KPNT.NE.0) THEN   
            IPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB   
          ELSE  
            IPNT   = KOFSDB + LCDRDB + IKDRDB + (ICURDT - 1) * KST  
          ENDIF 
          IF (IOKYDA(MITMDB).NE.0.AND.IQ(IPNT+MITMDB).GT.KEYS(MITMDB))  
     +                                                      GO TO 80    
          IF (KY7MDB.GT.0.AND.IQ(IPNT+MITMDB).GT.KY7MDB)    GO TO 80    
          IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).EQ.0) THEN 
            IF (ITIME.GT.IQ(IPNT+MEVRDB))                   GO TO 80    
            IF (ITIME.LT.IQ(IPNT+MBVRDB)) THEN  
              IF (KY4MDB.GT.IQ(IPNT+MBVRDB)) KY4MDB = IQ(IPNT+MBVRDB)   
              GO TO 80  
            ENDIF   
          ELSE IF (IOKYDA(MBVRDB).NE.0.AND.IOKYDA(MEVRDB).EQ.0) THEN    
            IF (IQ(IPNT+MBVRDB).GT.KEYS(MBVRDB))            GO TO 80    
          ELSE IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).NE.0) THEN    
            IF (IQ(IPNT+MEVRDB).LT.KEYS(MEVRDB))            GO TO 80    
          ELSE  
            IF (IQ(IPNT+MBVRDB).GT.KEYS(MBVRDB).OR. 
     +          IQ(IPNT+MEVRDB).LT.KEYS(MEVRDB))            GO TO 80    
          ENDIF 
*   
          CALL DBPATH (PATHX, ICURDT)   
          PATHN  = PATH(1:MAXL)//'/'//PATHX 
          CALL RZCDIR (PATHX, ' ')  
          IF (IQUEST(1).NE.0)  THEN 
            IQUEST(1) = 25  
            IF (IDEBDB.NE.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEYS : Ill'//    
     +      'egal Path name '//PATHN//''')', IARGDB, 0) 
            GO TO 100   
          ENDIF 
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          NKEYDK = IQUEST(7)    
          NWKYDK = IQUEST(8)    
          CALL DBKEYT   
          CALL DBKYSE (KEYS, ITIME) 
          IF (IQUEST(1).NE.0)                               GO TO 100   
   80   CONTINUE    
      ENDIF 
*   
* *** Discard all keys with discard bit set 
*   
      LSAVDB = LFIXDB   
      IF (LFIXDB.EQ.LREFDB(2)) THEN 
        LBKYDB = LQ(KOFUDB+LSAVDB-KLKYDB)   
      ELSE  
        LBKYDB = LQ(KOFUDB+LSAVDB)  
      ENDIF 
   90 IF (LBKYDB.NE.0)  THEN    
        KEY6   = IQ(KOFUDB+LBKYDB+MFLGDB)   
        IF (JBIT(KEY6,JIGNDB).NE.0)  THEN   
          CALL MZDROP (IDIVDB, LBKYDB, ' ') 
        ELSE    
          LSAVDB = LBKYDB   
          IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).EQ.0) THEN 
            IQ(KOFUDB+LBKYDB+NWKYDK+1) =    
     +        MIN(IQ(KOFUDB+LBKYDB+MEVRDB),KY4MDB)  
          ENDIF 
        ENDIF   
        LBKYDB = LQ(KOFUDB+LSAVDB)  
        GO TO 90    
      ENDIF 
*   
* *** Reset the current directory if needed 
*   
  100 IER    = IQUEST(1)    
      IF (IOPTP.NE.0)  THEN 
        CALL RZCDIR (PATH, ' ') 
        IF (IQUEST(1).NE.0)  THEN   
          IF (IER.EQ.0)  THEN   
            IQUEST(1) = 25  
            IF (IDEBDB.NE.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEYS : Ill'//    
     +      'egal Path name '//PATH//''')', IARGDB, 0)  
          ELSE  
            IQUEST(1) = IER 
          ENDIF 
        ELSE    
          IQUEST(1) = IER   
          NKEYDK = IQUEST(7)    
          NWKYDK = IQUEST(8)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          CALL DBKEYT   
        ENDIF   
      ENDIF 
*   
      IF (LFIXDB.EQ.LREFDB(2)) THEN 
        LBK(1) = LQ(KOFUDB+LFIXDB-KLKYDB)   
      ELSE  
        LBK(1) = LQ(KOFUDB+LFIXDB)  
      ENDIF 
      IF (LBK(1).EQ.0)  THEN    
        IQUEST(1) = 24  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEYS : No comp'//    
     +  'atible object for specified options'')', IARGDB, 0)    
      ENDIF 
*                                                             END DBKEYS    
  999 END   
      SUBROUTINE DBKEYT 
*     ==================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBKEYT                                                  *    
*                                                                      *    
*   Retrieves the I/O descriptor for the current directory             *    
*                                                                      *    
*   Called by various routines in the DBL3 package                     *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
      DO 10 I = 1, NWKYDK   
        IN     = (I - 1) / 10   
        JB     = 3*I - 30*IN - 2    
        IWD    = IQ(KOFSDB+LCDRDB+IKTYDB+IN)    
        IFORM  = JBYT (IWD, JB, 3)  
        IF (IFORM.EQ.3) THEN    
          IFORM  = 5    
        ELSE IF (IFORM.EQ.4) THEN   
          IFORM  = 6    
        ELSE IF (IFORM.EQ.5)  THEN  
          IFORM  = 3    
        ELSE IF (IFORM.LT.1.OR.IFORM.GT.5)  THEN    
          IFORM  = 2    
        ENDIF   
        IOTYDK(I) = IFORM   
   10 CONTINUE  
*                                                             END DBKEYT    
  999 END   
      SUBROUTINE DBKOUT (PATHN, IUDIV, LSUP, NTKEY, KEY, IPREC) 
*     ========================================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBKOUT (PATHN, IUDIV, LSUP, NTKEY, *KEY*, IPREC)        *    
*                                                                      *    
*   Stores data from memory to disk                                    *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     IUDIV    Division index where the data reside                    *    
*     LSUP     Address of the bank where data reside                   *    
*     NTKEY    Number of key elements                                  *    
*     KEY(*)   Vector of keys (Keys 3,4,5 and 8 onwards to be filled   *    
*              in by user on input; the DB system keys will be filled  *    
*              in here at the time of output)                          *    
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *    
*              IPREC significant digits right to the decimal points; if*    
*              IPREC < 0, data are stored with IPREC insignificant     *    
*              digits left to the decimal point.)                      *    
*                                                                      *    
*   Called by DBABWR, DBENTR, DBOUT, DBREPL, DBVOUT                    *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 71 : Illegal path name                               *    
*               = 72 : Number of keys does not match with that         *    
*                      specified in the directory                      *    
*               = 73 : RZOUT fails to write on disk                    *    
*               = 74 : Error in RZRENK in updating key values for      *    
*                      partitioned data set                            *    
*               = 75 : Cannot find the Top directory name in pathname  *    
*               = 76 : Cannot form the IO descriptor for the FZ header *    
*               = 77 : FZOUT fails to write on to the sequential file  *    
*               = 78 : Illegal number of keys in data base             *    
*                                                                      *    
************************************************************************    
*   
      COMMON /DAOPTI/ CALFDA(62), CSTRDA    
      CHARACTER       CALFDA*1, CSTRDA*132  
      COMMON /DAOPT1/ MPAKDA(2) 
      INTEGER         MPAKDA    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      COMMON /DZPACK/ PRECDZ, PACKDZ    
      LOGICAL         PACKDZ    
*   
      PARAMETER       (NLEVM=20)    
      DIMENSION       KEY(9), KEYO(MXDMDK), KEYN(MXDMDK)   
      CHARACTER       PATHY*80, PATHX*16, CHFOR*100, CFORM(6)*1 
      CHARACTER       CHCUR(NLEVM)*1, TOPN*16, PATHN*(*), CHOPT*28  
      CHARACTER       CHOP*1, PATHL*80  
      INTEGER         NLCUR(NLEVM), IOPTS(26)   
      EQUIVALENCE     (IOPADA, IOPTS(1))    
      DATA            CFORM /'B', 'I', 'F', 'D', 'H', 'A'/  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      integer ival
      real fval
      equivalence (ival, fval)
*     ------------------------------------------------------------------    
*   
* *** Set the current directory path name   
*   
      LREFDB(2) = LSUP   
      PATHX  = ' '  
      PATHY  = PATHN    
      PATHL  = ' '  
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0)          GO TO 991    
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      KST    = NWKYDK + 1   
      CALL RZCDIR (PATHY, 'R')  
      CALL DBKYTG   
      IF (NKEYDK.NE.0)  THEN    
        IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)    
        IOPTP  = JBIT (IOPTP, JPRTDB)   
      ELSE  
        IOPTP  = 0  
      ENDIF 
*   
      IF (NWKYDK.LT.NSYSDK.OR.NWKYDK.GT.MXDMDK) THEN    
        IQUEST(1) = 78  
        IQUEST(11)= NWKYDK  
        IQUEST(12)= NSYSDK  
        IQUEST(13)= MXDMDK  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : Illegal'//    
     +  ' number of keys '',I10,'' permitted range '',2I6)', IQUEST(11),    
     +  3)  
        GO TO 999   
      ENDIF 
*   
* *** Extract the Top level directory name  
*   
      I1     = 0    
      I11    = 0    
      DO 10 I0 = 1, MAXLDB  
        IF (PATHY(I0:I0).EQ.'/'.OR.PATHY(I0:I0).EQ.' ') THEN    
          IF (I1.GT.0) THEN 
            TOPN   = PATHY(I11:I0-1)    
            GO TO 15    
          ENDIF 
          IF (PATHY(I0:I0).EQ.' ') GO TO 15 
        ELSE    
          IF (I1.EQ.0) I11 = I0 
          I1     = I1 +1    
        ENDIF   
   10 CONTINUE  
   15 IF (I1.EQ.0) THEN 
        IQUEST(1) = 75  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : No top '//    
     +  'directory for '//PATHY//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
* *** See if transcript file is needed  
*   
      LTOP   = LTOPDB   
      IOPS   = 0    
      IOUT   = 0    
   20 IF (LTOP.NE.0) THEN   
        NCH    = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCH) 
        TOPNDI = TOPNDI(1:NCH)  
        IF (TOPN.EQ.TOPNDI) THEN    
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)  
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)   
          IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10) 
          IF (IOPBDA.EQ.0) THEN 
            LUFZDF = IQ(KOFUDB+LTOP+MUPJFL) 
          ELSE  
            LUFZDF = IQ(KOFUDB+LTOP+MUPBAK) 
          ENDIF 
        ELSE    
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 20  
        ENDIF   
      ELSE  
        LUFZDF = 0  
        IOPP   = 0  
      ENDIF 
      IF (IOUT.EQ.0) IOPS = 0   
*   
* *** Fill up Key 1, 2, 7   
*   
      KEY(MSERDB) = 0   
      KEY(MUPNDB) = 0   
      IF (IOKYDA(MITMDB).EQ.0.OR.KEY(MITMDB).LE.0) THEN 
        CALL DATIME (IDATE, ITIME)  
        CALL DBPKTM (IDATE, ITIME, IDATM)   
        KEY(MITMDB) = IDATM 
      ENDIF 
*   
      IDB    = IDBTYP (LREFDB(2))   
      IF (IDB.EQ.2.OR.IDB.EQ.3) THEN    
        IOPTR  = 0  
      ELSE  
        IOPTR  = 1  
      ENDIF 
*   
      IF (IOPRDA.NE.0 .OR. IOPTR.NE.0 .OR. IOPTDA.NE.0) THEN    
        IF (IOPTDA.NE.0) THEN   
          CHOP   = 'S'  
        ELSE IF (IOPRDA.NE.0) THEN  
          CHOP   = 'L'  
        ELSE    
          CHOP   = ' '  
        ENDIF   
      ELSE  
        CHOP   = 'S'    
      ENDIF 
*   
* *** Encode the character option, IO descriptor for the header 
*   
      IF (IOPP.NE.0.OR.LUFZDF.GT.0) THEN    
        CHOPT  = '7'    
        NDOP   = 1  
        DO 25 I = 1, 26 
          IF (IOPTS(I).NE.0) THEN   
            IF (NDOP.EQ.0) THEN 
              CHOPT  = CALFDA(I)    
            ELSE    
              CHOPT  = CHOPT(1:NDOP)//CALFDA(I) 
            ENDIF   
            NDOP   = NDOP + 1   
          ENDIF 
   25   CONTINUE    
        NDOP   = (NDOP + 3) / 4 
*   
        NLEV   = 1  
        NCUR   = 5  
        IFORO  = 2  
        CHCUR(NLEV) = CFORM(IFORO)  
        IF (PACKDZ.AND.IOPUDA.EQ.0) THEN    
          NLCUR(NLEV) = 4   
          IFORO  = 3    
          NCUR   = 1    
          NLEV   = NLEV + 1 
          CHCUR(NLEV) = CFORM(IFORO)
          fval = PRECDZ
          IHEADF(MPREDF) = ival
        ELSE    
          IHEADF(MPREDF) = IPREC    
        ENDIF   
        DO 30 I = 1, NWKYDK 
          IFORM  = IOTYDK(I)    
          IF (IFORM.EQ.6) IFORM = 5 
          IF (IFORM.EQ.IFORO) THEN  
            NCUR   = NCUR + 1   
          ELSE  
            NLCUR(NLEV) = NCUR  
            IF (NLEV.GE.NLEVM) THEN 
              IQUEST(1) = 76    
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : '// 
     +        'Cannot get IO descriptor '//PATHY//''')', IARGDB, 0) 
              GO TO 999 
            ENDIF   
            NLEV   = NLEV + 1   
            CHCUR(NLEV) = CFORM(IFORM)  
            NCUR   = 1  
            IFORO  = IFORM  
          ENDIF 
   30   CONTINUE    
        NLCUR(NLEV) = NCUR  
*   
        WRITE (CHFOR, 2001) (NLCUR(I), CHCUR(I), I = 1, NLEV)   
        II     = 4 *NLEV    
        CHFOR = CHFOR(1:II)//' -H'  
        CALL MZIOCH (IOFMDF, NWFMDF, CHFOR(1:II+3)) 
*   
*  **   Complete the header 
*   
        NCHR   = INDEX (PATHY, ' ') - 1 
        IF (NCHR.LT.1.OR.NCHR.GT.MAXLDB) NCHR = MAXLDB  
        NWDP   = (NCHR + 3) / 4 
        NWDH   = NWDP + NDOP + NWKYDK + 5   
        IHEADF(MACTDF) = 1  
        IHEADF(MNKYDF) = NWKYDK 
        IHEADF(MOPTDF) = NDOP   
        IHEADF(MPATDF) = NWDP   
        IF (NDOP.GT.0)  
     +    CALL UCTOH (CHOPT, IHEADF(MPREDF+NWKYDK+1), 4, 4*NDOP)    
        CALL UCTOH (PATHY, IHEADF(MPREDF+NWKYDK+NDOP+1), 4, 4*NWDP) 
        CALL UCOPY_i (KEY, IHEADF(MPREDF+1), NWKYDK)  
      ENDIF 
*   
* *** Take necessary action for partitioned and nonpartiitined datasets 
*   
      IF (IOPTP.EQ.0) THEN  
        KOBJ   = 0  
      ELSE  
        KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),   
     +                   NKEYDK*KST, KST)   
        IF (KPNT.NE.0) THEN 
          NK     = (KPNT - MPSRDB) / KST + 1    
        ELSE    
          NK     = NKEYDK   
        ENDIF   
        CALL DBKEYR (NK, NWKYDK, KEYO)  
        KOBJ   = KEYO(MOBJDB)   
        MXKP   = KEYO(MXKPDB)   
        CALL DBPATH (PATHX, NKEYDK) 
        CALL RZCDIR (PATHX, ' ')    
        IF (IQUEST(1).NE.0)        GO TO 991    
        NKEYDK = IQUEST(7)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
*   
*  **   Make a different subdirectory if there are too many keys    
*   
        IF (NKEYDK.GE.MXKP) THEN    
          NWKEY  = NWKYDK   
          CHFOR = ' '   
          DO 35 I = 1, NWKEY    
            IF (I.EQ.1) THEN    
              CHFOR  = CFORM(IOTYDK(I)) 
            ELSE    
              CHFOR  = CHFOR(1:I-1)//CFORM(IOTYDK(I))   
            ENDIF   
   35     CONTINUE  
          IF (IOKYDA(MITMDB).EQ.0.OR.KEY(MITMDB).LE.0) THEN 
            KEY7DK = 0  
          ELSE  
            KEY7DK = KEY(MITMDB)    
          ENDIF 
          CALL DBMDIP (PATHY, NWKEY, CHFOR, CTAGDK, MXKP)   
          IF (IQUEST(1).NE.0)      GO TO 999    
          CALL RZCDIR (PATHY, ' ')  
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB), 
     +                     NKEYDK*KST, KST) 
          IF (KPNT.NE.0) THEN   
            NK     = (KPNT - MPSRDB) / KST + 1  
          ELSE  
            NK     = NKEYDK 
          ENDIF 
          CALL DBKEYR (NK, NWKYDK, KEYO)    
          KOBJ   = KEYO(MOBJDB) 
          CALL DBPATH (PATHX, NKEYDK)   
          CALL RZCDIR (PATHX, ' ')  
          IF (IQUEST(1).NE.0)      GO TO 991    
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
        ENDIF   
        CALL UCOPY_i (KEYO, KEYN, NWKYDK) 
*   
      ENDIF 
*   
* *** Check the number of keys  
*   
      IF (NTKEY.NE.NWKYDK)         GO TO 992    
      LOBJ   = KOBJ 
      IF (NKEYDK.GT.0) THEN 
        ISTP   = NWKYDK + 1 
        DO 40 IK = 1, NKEYDK    
          IP     = KOFSDB + LCDRDB + IKDRDB + (IK-1)*ISTP + MSERDB  
          IF (IQ(IP).GT.LOBJ) LOBJ = IQ(IP) 
   40   CONTINUE    
      ENDIF 
      LOBJ   = LOBJ + 1 
*   
*  ** Write the sequential output if needed 
*   
      IF (LUFZDF.GT.0) THEN 
        IHEADF(MPREDF+MSERDB) = LOBJ    
        CALL FZOUT (LUFZDF, IUDIV, LREFDB(2), 1, CHOP, IOFMDF, NWDH,    
     +              IHEADF) 
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1)  = 77   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : Error'//    
     +    ' in FZOUT while writing Data for '//PATHY//''')', IARGDB, 0) 
          GO TO 998 
        ENDIF   
      ENDIF 
*   
* *** Fill up Key vectors 1,2,6,7   
*   
      KEY(MSERDB) = LOBJ    
      KEY(MFLGDB) = MSBIT0 (KEY(MFLGDB), JRZUDB)    
      KEY(MFLGDB) = MSBIT0 (KEY(MFLGDB), JPRTDB)    
      KEY(MFLGDB) = MSBIT0 (KEY(MFLGDB), JASFDB)    
*   
* *** Lock the directory if necessary   
*   
      IF (IOPP.EQ.0.AND.IOPS.NE.0) THEN 
        CALL RZCDIR (PATHY, ' ')    
        NKEYDK = IQUEST(7)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        CALL RZLOCK ('DBKOUT')  
        PATHL  = PATHY  
        IF (IOPTP.NE.0) THEN    
          CALL RZCDIR (PATHX, ' ')  
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
        ENDIF   
      ENDIF 
*   
      IF (IOPRDA.NE.0 .OR. IOPTR.NE.0 .OR. IOPTDA.NE.0) THEN    
*   
*  **   RZ mode output  
*   
        KEY(MFLGDB) = MSBIT1 (KEY(MFLGDB), JRZUDB)  
        IF (IOPTDA.NE.0) KEY(MFLGDB) = MSBIT1 (KEY(MFLGDB), JASFDB) 
*   
        IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ') 
        CALL RZOUT (IUDIV, LREFDB(2), KEY, ICYCLE, CHOP)    
*   
      ELSE  
*   
*  **   Copy data to DB internal store  
*   
*  **   0 Data word : do not pack   
*   
        IF (IQ(KOFUDB+LREFDB(2)-1).EQ.0) IOPUDA = 1 
        CALL DBFRUS (LREFDB(2), LSTRDL(1), IPREC)   
        IF (IQUEST(1).NE.0)        GO TO 998    
*   
*  **   Compress the data if requested  
*   
        IF (IOPUDA.NE.0)  THEN  
          LREFDL(1) = LSTRDL(1) 
        ELSE    
          CALL DBCOMP (LSTRDL(1), LREFDL(1), KEY(1))    
        ENDIF   
        IF (IQUEST(1).NE.0)        GO TO 998    
*   
*  **   Drop the uncompressed data  
*   
        IF (LREFDL(1).NE.LSTRDL(1)) CALL MZDROP (IDISDB, LSTRDL(1), 'L')    
*   
*  **   Write on to disk    
*   
        IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ') 
        CALL RZOUT (IDISDB, LREFDL(1), KEY, ICYCLE, 'S')    
        IER       = IQUEST(1)   
        CALL MZDROP (IDISDB, LREFDL(1), 'L')    
        IQUEST(1) = IER 
*   
      ENDIF 
      CALL UCOPY_i (KEY, KEYNDK, NWKYDK)  
*   
      IF (IQUEST(1).NE.0)          GO TO 993    
      IF (IDEBDB.GT.1) THEN 
        IARGDB(1) = IDATE   
        IARGDB(2) = ITIME   
        CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : Data was inserted into'//  
     +       '   '//PATHY//''',/,10X,''on the '',I8,'' at '',I6,'' '//  
     +       'with Key-Vector '')', IARGDB, 2)  
        CALL DBKEYT 
        CALL DBPRKY (NWKYDK, KEYNDK, IOTYDK)    
      ENDIF 
      GO TO 998 
*   
* *** Error messages    
*   
  991 IQUEST(1) = 71    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : Illegal '// 
     +   'Path Name '//PATHY//PATHX(1:8)//''')', IARGDB, 0) 
      GO TO 999 
*   
  992 IQUEST(1) = 72    
      IQUEST(11)= NTKEY 
      IQUEST(12)= NWKYDK    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : Number of'//    
     +   ' keys '',I4,'' does not match with that specified '',I4,'' '//    
     +   'in the directory'')', IQUEST(11), 2)  
      GO TO 998 
*   
  993 IQUEST(1) = 73    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : Error in '//    
     +   'RZOUT while writing Data for '//PATHY//PATHX(1:8)//''')',IQ,0)    
*   
  998 IER   = IQUEST(1) 
      IF (IOPTP.NE.0)  THEN 
        CALL RZCDIR (PATHY, ' ')    
        IF (IQUEST(1).NE.0) THEN    
          IF (IER.EQ.0) THEN    
            IF (PATHL.NE.' ') THEN  
              CALL RZCDIR (PATHL, ' ')  
              CALL RZFREE ('DBKOUT')    
            ENDIF   
            GO TO 991   
          ELSE  
            IQUEST(1) = IER 
          ENDIF 
        ELSE    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          NKEYDK = IQUEST(7)    
          IQUEST(1) = IER   
*   
*  **     Rename Keys 3 and 4 of the latest subdirectory    
*   
          IF (IER.EQ.0) THEN    
            KEYN(MBVRDB) = MIN0 (KEYN(MBVRDB), KEY(MBVRDB)) 
            KEYN(MEVRDB) = MAX0 (KEYN(MEVRDB), KEY(MEVRDB)) 
            CALL RZRENK (KEYO, KEYN)    
            IF (IQUEST(1).NE.0) THEN    
              IQUEST(1) = 74    
              IF (IDEBDB.GT.0) THEN 
                CALL UCOPY_i (KEYO, IARGDB(1),        NSYSDK) 
                CALL UCOPY_i (KEYN, IARGDB(NSYSDK+1), NSYSDK) 
                CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : Error in RZRENK '//    
     +               'while writing data for '//PATHY//''',/(10X,7I12))'    
     +,              IARGDB, 2*NSYSDK)  
              ENDIF 
            ENDIF   
          ENDIF 
        ENDIF   
      ENDIF 
*   
      IF (PATHL.NE.' ') THEN    
        IERR   = IQUEST(1)  
        CALL RZCDIR (PATHL, ' ')    
        CALL RZFREE ('DBKOUT')  
        IQUEST(1) = IERR    
      ENDIF 
*   
 2001 FORMAT (20(I2,A1,1X)) 
*                                                             END DBKOUT    
  999 END   
      SUBROUTINE DBKXIN (ITIME, IUDIV, LU, LSUP, JBIAS, NWKEY, KEY, 
     +                   IPREC) 
*     ============================================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBKXIN (ITIME, IUDIV, LU*, LSUP, JBIAS, NWKEY*, *KEY*,  *    
*                      IPREC*)                                         *    
*                                                                      *    
*   Fetches from disk to a ZEBRA bank data valid for a given time      *    
*                                                                      *    
*   Restrictions : This routine is called internally by other routines *    
*                  in DBL3. One should be very careful in using this   *    
*                  routine. For example, the character option for      *    
*                  special selection scheme like options S or N in     *    
*                  DBUSE is not present in this routine and they can   *    
*                  be switched on or off only by a prior call to DBUSE *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     ITIME    Time for which data are required to be valid            *    
*     IUDIV    Division index where bank is expected                   *    
*     LU       Address of the bank in memory                           *    
*     LSUP     Supporting link of the bank (see MZBOOK)                *    
*     JBIAS    Link bias for creating the data bank (see MZBOOK)       *    
*     NWKEY    Number of key elements                                  *    
*     KEY(*)   Vector of keys (On input if any key beyond element 8 or *    
*              element 5 is nonzero,data are retrieved according to its*    
*              content; on output it contains the key elements for the *    
*              current data)                                           *    
*     IPREC(*) Precision word; (If IPREC > 0, data are stored with     *    
*              IPREC significant digits right to the decimal points; if*    
*              IPREC < 0, data are stored with IPREC insignificant     *    
*              digits left to the decimal point.)                      *    
*                                                                      *    
*   Called by DBIN,   DBGET,  DBGETS, DBKIN,  DBKVIN, DBNTOP, DBPURK,  *    
*             DBRHLP, DBRNAM, DBRTFZ, DBSRTM, DBVIN,  DBCHCK, DBGNAM,  *    
*             DBPRDT, DBPLNT, DBPLOB, DBPLOV, DBAIRD, DBDISD, DBDISH,  *    
*             DBDISV, DBEDKY, DBPEEK                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 31 : Illegal Pathname                                *    
*               = 33 : No valid data for the given set of keys and     *    
*                      program version number                          *    
*               = 35 : Wrong reference to data objects in update mode  *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      COMMON /DTKXIN/ ICURDT, IDNRDT, IKYLDT, IMINDT, INRSDT, IPRVDT    
     +              , IUSEDT, KEY6DT, KY6NDT, MNKYDT, NTIMDT    
*   
      DIMENSION       KEY(*)
      CHARACTER       PATHN*80, PATH*80, PATHX*16   
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
      IPRVDT = KEY(MPVSDB)  
      NWKEY  = NWKYDK   
      NKEYS  = NKEYDK   
      CALL RZCDIR (PATHN, 'R')  
      MAXL   = INDEX (PATHN, ' ') - 1   
      IF (MAXL.LT.1.OR.MAXL.GT.MAXLDB) MAXL = MAXLDB    
*   
* *** Check the validity limits from the Keys   
*   
    2 NTIMDT = 0    
      MNKYDT = -999 
      INRSDT = 100000   
      IDNRDT = 0    
      KEY6DT = 0    
      KY6NDT = 0    
      ICURDT = 1    
      ISTP   = NWKYDK + 1   
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)   
*   
* *** Select by the key number  
*   
      IF (IOKYDA(MSERDB).NE.0)  THEN    
        IKYLDT = KEY(MSERDB)    
        IPRVDT = IKYLDT 
*   
        IF (IOPTP.EQ.0)  THEN   
*   
          IF (IKYLDT.GT.0 .AND. IKYLDT.LE.NKEYDK)  THEN 
            GO TO 25    
          ELSE  
            GO TO 993   
          ENDIF 
*   
        ELSE    
*   
          DO 5 JK = 1, NKEYDK   
            IK     = NKEYDK + 1 - JK    
            KPNT   = IUHUNT (IK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),   
     +                       NKEYDK*ISTP, ISTP) 
            IF (KPNT.NE.0) THEN 
              IPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB 
            ELSE    
              IPNT   = KOFSDB + LCDRDB + IKDRDB + (IK - 1) * ISTP   
            ENDIF   
            KEY5   = IQ(IPNT+MOBJDB)    
            IF (IKYLDT.GT.KEY5)                             GO TO 10    
    5     CONTINUE  
          GO TO 993 
   10     KOFF   = KEY5 
          CALL DBPATH (PATHX, IK)   
          CALL RZCDIR (PATHX, ' ')  
          IF (IQUEST(1).NE.0)                               GO TO 991   
          IKYLDT = KEY(MSERDB) - KOFF   
          IF (IKYLDT.GT.IQUEST(7)) THEN 
            GO TO 993   
          ELSE  
            NKEYDK = IQUEST(7)  
            NWKYDK = IQUEST(8)  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
            CALL DBKEYT 
            ISTP   = NWKYDK + 1 
            GO TO 25    
          ENDIF 
        ENDIF   
*   
      ENDIF 
*   
* *** Select by the Key values  
*   
      KY4MDB = IBIGDB   
      IF (IOPTP.EQ.0)  THEN 
*   
        CALL DBSEKY (ITIME, KEY)    
*   
      ELSE  
*   
        DO 15 JK = 1, NKEYS 
          ICURDT = NKEYS + 1 - JK   
          CALL DBPATH (PATHX, ICURDT)   
          IF (JK.NE.1) THEN 
            CALL RZCDIR (PATHN, ' ')    
            IF (IQUEST(1).NE.0)                             GO TO 991   
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
          ENDIF 
          KPNT   = IUHUNT (ICURDT, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB), 
     +                     NKEYS*ISTP, ISTP)    
          IF (KPNT.NE.0) THEN   
            IPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB   
          ELSE  
            IPNT   = KOFSDB + LCDRDB + IKDRDB + (ICURDT - 1) * ISTP 
          ENDIF 
          IF (IOKYDA(MITMDB).NE.0.AND.KEY(MITMDB).LT.IQ(IPNT+MITMDB))   
     +                                                      GO TO 15    
          IF (KY7MDB.GT.0.AND.KY7MDB.LT.IQ(IPNT+MITMDB))    GO TO 15    
          IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).EQ.0) THEN 
            IF (ITIME.GT.IQ(IPNT+MEVRDB))                   GO TO 15    
            IF (ITIME.LT.IQ(IPNT+MBVRDB)) THEN  
              IF (KY4MDB.GT.IQ(IPNT+MBVRDB)) KY4MDB = IQ(IPNT+MBVRDB)   
              GO TO 15  
            ENDIF   
          ELSE IF (IOKYDA(MBVRDB).NE.0.AND.IOKYDA(MEVRDB).EQ.0) THEN    
            IF (IQ(IPNT+MBVRDB).GT.KEY(MBVRDB))             GO TO 15    
          ELSE IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).NE.0) THEN    
            IF (IQ(IPNT+MEVRDB).LT.KEY(MEVRDB))             GO TO 15    
          ELSE  
            IF (IQ(IPNT+MBVRDB).GT.KEY(MBVRDB).OR.  
     +          IQ(IPNT+MEVRDB).LT.KEY(MEVRDB))             GO TO 15    
          ENDIF 
*   
          CALL RZCDIR (PATHX, ' ')  
          IF (IQUEST(1).NE.0)                               GO TO 991   
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          CALL DBSEKY (ITIME, KEY)  
          IF (NTIMDT.NE.0 .AND. JBIT(KEY6DT,JIGNDB).EQ.0)   GO TO 20    
*   
   15   CONTINUE    
*   
      ENDIF 
*   
* *** Check if valid data exist 
*   
   20 ISTP   = NWKYDK + 1   
      IF (NTIMDT.EQ.0 .OR. JBIT(KEY6DT,JIGNDB).NE.0)  THEN  
*   
        IF (KY6NDT.NE.0)  THEN  
          IKYLDT = KY6NDT   
*   
        ELSE IF (IOPNDA.NE.0 .AND. IDNRDT.NE.0)  THEN   
*   
*  **     Take the nearest neighbour    
*   
          NTIMDT = -1   
          IKYLDT = IDNRDT   
          IF (IOPTP.NE.0 .AND. IUSEDT.NE.ICURDT)  THEN  
            CALL DBPATH (PATHX, IUSEDT) 
            PATH   = PATHN(1:MAXL)//'/'//PATHX  
            CALL RZCDIR (PATH, ' ') 
            IF (IQUEST(1).NE.0)                             GO TO 991   
            NKEYDK = IQUEST(7)  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
          ENDIF 
          IF (IDEBDB.GT.1)  THEN    
            IPNT   = KOFSDB + LCDRDB + IKDRDB + (IDNRDT - 1) * ISTP 
            IARGDB(1) = ITIME   
            IARGDB(2) = IQ(IPNT+MBVRDB) 
            IARGDB(3) = IQ(IPNT+MEVRDB) 
            CALL DBPRNT (LPRTDB, '(/,'' DBKXIN : Warning --> Data val'//    
     +           'id at time '',I10,'' does not exist. Data valid bet'//    
     +           'ween '',2I10,'' are returned'')', IARGDB, 3)  
          ENDIF 
*   
        ELSE    
*   
*  **     None exists; return with error message    
*   
          GO TO 993 
*   
        ENDIF   
*   
      ENDIF 
*   
* *** Read in the data  
*   
   25 ICYCL  = 9999 
      CALL DBKEYR (IKYLDT, NWKYDK, KEYNDK)  
   27 KEY6DT = KEYNDK(MFLGDB)   
      IF (JBIT(KEY6DT,JIGNDB).NE.0)                         GO TO 993   
      KEY(MSERDB) = IKYLDT  
      LSTRDL(2) = 0 
      IF (NTIMDT.EQ.-1) KY4MDB = KEYNDK(MBVRDB) + 1 
*   
      IF (IOPKDA.NE.0)  THEN    
*   
*  **   Only the keys are needed    
*   
        CALL UCOPY_i (KEYNDK, KEY, NWKYDK)    
*   
      ELSE IF (JBIT(KEY6DT,JRZUDB) .NE. 0)  THEN    
*   
*  **   Data are stored in RZ way   
*   
        LSTRDL(2) = LSUP 
        CALL DBRZIN (IUDIV, LSTRDL(2), JBIAS, KEY(1), ICYCL, PATHN)    
        LSUP = LSTRDL(2) 
        LSTRDL(2) = 0   
        IF (JBIAS.GT.0)  THEN   
          LU  = LSUP  
        ELSE    
          LU  = LQ(KOFUDB+LSUP+JBIAS) 
        ENDIF   
        IF (IQUEST(1).NE.0)                                 GO TO 998   
*   
        CALL UCOPY_i (KEYNDK, KEY, NWKYDK)    
*   
      ELSE  
*   
*  **   Read in standard DB format  
*   
        CALL DBRZIN (IDISDB, LSTRDL(2), 2, KEY(1), ICYCL, PATHN)   
        IF (IQUEST(1).NE.0)                                 GO TO 998   
        CALL UCOPY_i (KEYNDK, KEY, NWKYDK)    
*   
*  **   If the data is update - uncompress and proceed updating 
*   
        IF (KEY(MUPNDB).NE.0)  THEN 
          DO 30 I = 1, NKEYDK   
            IPNT   = KOFSDB + LCDRDB + IKDRDB + ISTP * (I-1)    
            IF (KEY(MUPNDB).EQ.IQ(IPNT+MSERDB))  THEN   
              IK     = I    
              GO TO 35  
            ENDIF   
   30     CONTINUE  
          GO TO 995 
*   
   35     CALL DBUNCP (LSTRDL(2), LREFDL(3), IK)    
        ELSE    
          CALL DBUNCP (LSTRDL(2), LREFDL(3), 0) 
        ENDIF   
*   
*  **   Drop the compressed data    
*   
        IER       = IQUEST(1)   
        CALL MZDROP (IDISDB, LSTRDL(2), ' ')    
        IQUEST(1) = IER 
        IF (IQUEST(1).NE.0)                                 GO TO 998   
*   
*  **   Copy from internal Data Base system to user format  
*   
        CALL DBTOUS (LREFDL(3), IUDIV, LU, LSUP, JBIAS, IPREC)    
*   
        IER       = IQUEST(1)   
        CALL MZDROP (IDISDB, LREFDL(3), ' ')    
        IQUEST(1) = IER 
        IF (IQUEST(1).NE.0)                                 GO TO 998   
*   
      ENDIF 
      GO TO 998 
*   
* *** Error messages    
*   
  991 IQUEST(1) = 31    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKXIN : Illegal '// 
     +   'path name '//PATHN//PATHX(1:8)//''')', IARGDB, 0) 
      GO TO 999 
*   
  993 IQUEST(1) = 33    
      IF (IDEBDB.GT.0) THEN 
        IARGDB(1) = ITIME   
        IARGDB(2) = IPRVDT  
        CALL DBPRNT (LPRTDB, '(/,'' DBKXIN : No valid data can be fou'//    
     +       'nd for time'',I10,'' and Program Version'',I6)', IARGDB,2)    
      ENDIF 
      GO TO 998 
*   
  995 IQUEST(1) = 35    
      IQUEST(11)= KEY(MUPNDB)   
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKXIN : Key 2 ref'//    
     +   'erence '',I4,'' cannot be found among the Key 1 values'')',   
     +   IQUEST(11), 1) 
      GO TO 998 
*   
  998 IER   = IQUEST(1) 
      IF (IOPTP.NE.0)  THEN 
        CALL RZCDIR (PATHN, ' ')    
        IF (IQUEST(1).NE.0) THEN    
          IF (IER.EQ.0) THEN    
            GO TO 991   
          ELSE  
            IQUEST(1) = IER 
          ENDIF 
        ELSE    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          NKEYDK = IQUEST(7)    
          NWKYDK = IQUEST(8)    
          IQUEST(1) = IER   
        ENDIF   
      ENDIF 
*                                                             END DBKXIN    
  999 END   
      SUBROUTINE DBKYSE (KEYS, ITIME)   
*     ===============================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBKYSE (KEYS, ITIME)                                    *    
*                                                                      *    
*   Creates or completes the Key banks supported as next of same type  *    
*   to the Node bank for 'S' option                                    *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     KEYS     Vector of keys                                          *    
*     ITIME    Time for which the valid keys are required              *    
*                                                                      *    
*   Called by DBKEYS                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 23 : Key bank cannot be created; no space in memory  *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NZ=0)    
      DIMENSION       KEYS(9)   
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
      IQUEST(1) = 0 
      IF (LFIXDB.EQ.LREFDB(2)) THEN 
        JBIAS  = -KLKYDB    
      ELSE  
        JBIAS  = 0  
      ENDIF 
      ND     = IQ(KOFUDB+LREFDB(2)+MNDNWD)  
      IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).EQ.0)   GO TO 20   
      DO 15 JK = 1, NKEYDK  
*   
*  *    Load the keys for this serial number    
*   
        IK     = NKEYDK + 1 - JK    
        CALL DBKEYR (IK, NWKYDK, KEYNDK)    
*   
*  *    Use the selection   
*   
        DO 10 I = 3, NWKYDK 
*   
*  *      Keys 3, 4, 6 and 7 have special meannings 
*   
          IF (I.EQ.MBVRDB) THEN 
            IF (IOKYDA(I).NE.0.AND.KEYNDK(I).GT.KEYS(I)) GO TO 15   
          ELSE IF (I.EQ.MEVRDB)  THEN   
            IF (IOKYDA(I).NE.0.AND.KEYNDK(I).LT.KEYS(I)) GO TO 15   
          ELSE IF (I.EQ.MITMDB)  THEN   
            IF (IOKYDA(I).NE.0.AND.KEYNDK(I).GT.KEYS(I)) GO TO 15   
            IF (KY7MDB.GT.0.AND.KEYNDK(I).GT.KY7MDB)     GO TO 15   
          ELSE IF (I.EQ.MFLGDB)  THEN   
            IF (JBIT(KEYNDK(I),JIGNDB).NE.0)             GO TO 15   
          ELSE  
            IF (IOKYDA(I).NE.0.AND.KEYNDK(I).NE.KEYS(I)) GO TO 15   
          ENDIF 
   10   CONTINUE    
*   
*  *    Create a new Key bank   
*   
        CALL UCOPY_i  (IQ(KOFUDB+LREFDB(2)+MNDIOF), IOKYDB, NWNODB)   
        CALL DBBOOK (IDIVDB, LBKYDB, LFIXDB, JBIAS, 'KYDB', NLKYDB, 
     +               NSKYDB, ND, IOKYDB, NZ)    
        IF (IQUEST(1).NE.0)  THEN   
          IQUEST(1) = 23    
          IQUEST(11)= IK    
          IQUEST(12)= NKEYDK    
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKYSE : No sp'//    
     +    'ace in memory to create Key bank '',I3,'' out of '',I3)',    
     +    IQUEST(11), 2)    
          GO TO 999 
        ENDIF   
*   
        LQ(KOFUDB+LBKYDB-KLNODB) = LREFDB(2)    
        LQ(KOFUDB+LBKYDB-KLUPDB) = LBFXDB   
        CALL UCOPY_i (KEYNDK, IQ(KOFUDB+LBKYDB+1), NWKYDK)    
        IQ(KOFUDB+LBKYDB+NWKYDK+1) = KEYNDK(MBVRDB) + 1 
*   
   15 CONTINUE  
      GO TO 999 
*   
*  ** S option with time validity (Last inserted ones only) 
*   
   20 LBKYDB = LSAVDB   
      DO 50 JK = 1, NKEYDK  
*   
*  *    Load the keys for this serial number    
*   
        IK     = NKEYDK + 1 - JK    
        CALL DBKEYR (IK, NWKYDK, KEYNDK)    
*   
*  *    Use the selection   
*   
        IF (ITIME.GT.KEYNDK(MEVRDB))                     GO TO 50   
        DO 30 I = 5, NWKYDK 
*   
*  *      Keys (MFLGDB) and (MITMDB) have special meannings 
*   
          IF (I.EQ.MITMDB)  THEN    
            IF (IOKYDA(I).NE.0.AND.KEYNDK(I).GT.KEYS(I)) GO TO 50   
            IF (KY7MDB.GT.0.AND.KEYNDK(I).GT.KY7MDB)     GO TO 50   
          ELSE IF (I.EQ.MFLGDB)  THEN   
            GO TO 30    
          ELSE  
            IF (IOKYDA(I).NE.0.AND.KEYNDK(I).NE.KEYS(I)) GO TO 50   
          ENDIF 
   30   CONTINUE    
        IF (ITIME.LT.KEYNDK(MBVRDB)) THEN   
          IF (KY4MDB.GT.KEYNDK(MBVRDB)) KY4MDB = KEYNDK(MBVRDB) 
          GO TO 50  
        ENDIF   
*   
*  **   See if such Key bank already exists 
*   
        LBKYDB = LFIXDB 
   35   LBKYDB = LQ(KOFUDB+LBKYDB)  
        IF (LBKYDB.NE.0)  THEN  
          DO 40 I = 5, NWKYDK   
            IF (I.EQ.MFLGDB.OR.I.EQ.MITMDB)  THEN   
              GO TO 40  
            ELSE    
              IF (KEYNDK(I).NE.IQ(KOFUDB+LBKYDB+I))      GO TO 35   
            ENDIF   
   40     CONTINUE  
          IF (IQ(KOFUDB+LBKYDB+MSERDB).LT.KEYNDK(MSERDB))  THEN 
            CALL UCOPY_i (KEYNDK, IQ(KOFUDB+LBKYDB+1), NWKYDK)    
          ENDIF 
          GO TO 50  
        ENDIF   
*   
*  *    Create a new Key bank   
*   
        CALL UCOPY_i  (IQ(KOFUDB+LREFDB(2)+MNDIOF), IOKYDB, NWNODB)   
        CALL DBBOOK (IDIVDB, LBKYDB, LFIXDB, JBIAS, 'KYDB', NLKYDB, 
     +               NSKYDB, ND, IOKYDB, NZ)    
        IF (IQUEST(1).NE.0)  THEN   
          IQUEST(1) = 23    
          IQUEST(11)= IK    
          IQUEST(12)= NKEYDK    
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKYSE : No sp'//    
     +    'ace in memory to create Key bank '',I3,'' out of '',I3)',    
     +    IQUEST(11), 2)    
          GO TO 999 
        ENDIF   
*   
        LQ(KOFUDB+LBKYDB-KLNODB) = LREFDB(2)    
        LQ(KOFUDB+LBKYDB-KLUPDB) = LBFXDB   
        CALL UCOPY_i (KEYNDK, IQ(KOFUDB+LBKYDB+1), NWKYDK)    
   50 CONTINUE  
*                                                             END DBKYSE    
  999 END   
      SUBROUTINE DBKYTG 
*     ================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBKYTG                                                  *    
*                                                                      *    
*   Retrieves the I/O descriptor and the Tags of the Key elements      *    
*   of the current directory                                           *    
*                                                                      *    
*   Called by DBENTB, DBKTYP, DBNTOP, DBPRIN, DBENFZ, DBKOUT, DBPLNT,  *    
*             DBPLOB, DBAUXI, DBDISD, DBDISP, DBEDAS, DBJOIN, DBVWPR   *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      DIMENSION       IHTAG(2)  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
      KTAG   = IKTYDB + (NWKYDK-1)/10 + 1   
      DO 10 I = 1, NWKYDK   
        CALL ZITOH (IQ(KOFSDB+LCDRDB+KTAG+2*I-2), IHTAG, 2) 
        CALL UHTOC (IHTAG, 4, CTAGDK(I), 8) 
        IN     = (I - 1) / 10   
        JB     = 3*I - 30*IN - 2    
        IWD    = IQ(KOFSDB+LCDRDB+IKTYDB+IN)    
        IFORM  = JBYT (IWD, JB, 3)  
        IF (IFORM.EQ.3) THEN    
          IFORM  = 5    
        ELSE IF (IFORM.EQ.4) THEN   
          IFORM  = 6    
        ELSE IF (IFORM.EQ.5)  THEN  
          IFORM  = 3    
        ELSE IF (IFORM.LT.1.OR.IFORM.GT.5)  THEN    
          IFORM  = 2    
        ENDIF   
        IOTYDK(I) = IFORM   
   10 CONTINUE  
*                                                             END DBKYTG    
  999 END   
      SUBROUTINE DBLINC (CLINE, LENGTH, IDATA, NDATA)   
*     ===============================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBLINC (CLINE, LENGTH, IDATA*, *NDATA*)                 *    
*                                                                      *    
*   Encodes a character string into a buffer IDATA                     *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     CLINE    Character string of maximum 80 characters               *    
*     LENGTH   Length of the string                                    *    
*     IDATA(*) Array to contain the encoded information                *    
*     NDATA(*) Length of the array IDATA used so far                   *    
*                                                                      *    
*   Called by DBABWR, DBEHLP, DBAIWR                                   *    
*                                                                      *    
*   Original Code : CPLINE in CMZ Package                              *    
*                                                                      *    
************************************************************************    
*   
      CHARACTER       CLINE*(*) 
      CHARACTER*4     FWORD(5), KBLANK  
      CHARACTER*1     KONE, CAR, KTWO*(3)   
      CHARACTER*80    KLINE 
      DIMENSION       LINE(20), ILINE(20)   
      PARAMETER       (IND1=2, IND2=1)  
      CHARACTER       KENDIF*5, KELSE*4, KEND*3, KEYW*8, KCONT*8, KRET*6    
      INTEGER*2       IWD1(2), IWD2(2)  
      EQUIVALENCE     (IWORD1, IWD1(1)) 
      EQUIVALENCE     (IWORD2, IWD2(1)) 
      DIMENSION       IDATA(9), ICODE(6)    
      SAVE            KBLAN, IFIRST 
*   
      DATA            FWORD /'+DEC','+KEE','+SEQ','+CDE','+SEL'/    
      DATA            ICODE /   125,   124,   123,   122,   121,   120/ 
      DATA            KENDIF, KEND, KRET /'ENDIF', 'END', 'RETURN'/ 
      DATA            KELSE, KCONT /'ELSE', 'CONTINUE'/ 
      DATA            KBLANK /'    '/   
      DATA            IFIRST /0/    
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
      MSBIT (MZ,IZW,IZP) = IOR (IAND (IZW, NOT(ISHFT(1,IZP-1)) )    
     +                              , ISHFT(IAND(MZ,1),IZP-1))  
*   
      MCBYT (MZ,IZQ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +        , ISHFT (ISHFT(ISHFT(MZ,-IZQ+1),32-NZB), -33+IZP+NZB) )   
*   
      JBYTET (MZ,IZW,IZP,NZB) = IAND (MZ, IBITS(IZW,IZP-1,NZB)) 
      JBYTOR (MZ,IZW,IZP,NZB) = IOR  (MZ, IBITS(IZW,IZP-1,NZB)) 
      MBYTET (MZ,IZW,IZP,NZB) = IAND (IZW, NOT(ISHFT (  
     +                          ISHFT(NOT(MZ),32-NZB),-33+IZP+NZB)) )   
      MBYTOR (MZ,IZW,IZP,NZB) = IOR (IZW, ISHFT (   
     +                               ISHFT(MZ,32-NZB),-33+IZP+NZB) )    
*   
*     ------------------------------------------------------------------    
*   
      IF (IFIRST.EQ.0) THEN 
        IFIRST = 1  
        CALL UCTOH (KBLANK, KBLAN, 4, 4)    
      ENDIF 
*   
      KLINE = CLINE 
      CALL UCTOH (CLINE, LINE, 4, 80)   
      IF (LENGTH.EQ.0) THEN 
        NDATA = NDATA +1    
        IDATA(NDATA)=0  
        GO TO 999   
      ENDIF 
      IWORD2 = 0    
      KONE   = KLINE(:1)    
      KTWO   = KLINE(2:4)   
      CALL DBIFCH (KONE, IKONE) 
      IWORD1 = IKONE    
      ILASTW = (LENGTH+3)/4 
*   
* *** Treatment of special cases : +DECK, +KEEP, +SEQ, +CDE,+SELF,+SELF.    
*   
      IF (KONE.EQ.'+') THEN 
        DO 10 NCAS = 1, 4   
          IF (KLINE(1:4).EQ.FWORD(NCAS)) THEN   
            IWD1(IND1) = ICODE(NCAS)*128    
            GO TO 20    
          ENDIF 
   10   CONTINUE    
        IF (KLINE(1:4).NE.FWORD(5))         GO TO 40    
        IWD1(IND1) = ICODE(5)*128   
        IF (KLINE(6:6).EQ.'.'.AND.LENGTH.EQ.6) THEN 
          IWD1(IND1) = ICODE(6)*128 
          IDATA(NDATA+1) = IWORD1   
          NDATA = NDATA + 1 
          GO TO 999 
        ENDIF   
   20   IWD1(IND1) = IWD1(IND1) + ILASTW    
        CALL DBIFRC (CLINE, ILINE, ILASTW, 4*ILASTW)    
        DO 30 IW = 2, ILASTW    
          IDATA(NDATA+IW) = ILINE(IW)   
   30   CONTINUE    
        IDATA(NDATA+1) = IWORD1 
        NDATA = NDATA + ILASTW  
        GO TO 999   
      ENDIF 
*   
   40 NWI    = 1    
      IFIRW  = 1    
      IF (ILASTW.EQ.1)                      GO TO 80    
      DO 50 I = 2, 20   
        IF (LINE(I).EQ.KBLAN)               GO TO 50    
        IFIRW = I   
        GO TO 60    
   50 CONTINUE  
   60 CONTINUE  
*   
* *** For ENDIF , ELSE , END (without label) and RETURN (without label),    
* *** use code in bits 24 to 30 = 127, 126, 118, 116    
*   
      IF (KLINE(:6).EQ.' ') THEN    
        NC1 = (IFIRW-1)*4+1 
   70   IF (KLINE(NC1:NC1).EQ.'.') THEN 
          NC1 = NC1 + 1 
          GO TO 70  
        ENDIF   
        IF (LENGTH-NC1.GT.5)                GO TO 170   
        KEYW = KLINE(NC1:LENGTH)    
        CALL CLTOU (KEYW(:LENGTH-NC1+1))    
        IF (KEYW.EQ.KENDIF) THEN    
          IWD1(IND1) = 127*128 + NC1    
        ELSE IF (KEYW.EQ.KELSE) THEN    
          IWD1(IND1) = 126*128 + NC1    
        ELSE IF (KEYW.EQ.KEND) THEN 
          IWD1(IND1) = 118*128 + NC1    
        ELSE IF (KEYW.EQ.KRET) THEN 
          IWD1(IND1) = 116*128 + NC1    
        ELSE    
          GO TO 170 
        ENDIF   
        NDATA = NDATA + 1   
        IDATA(NDATA) = IWORD1   
        GO TO 999   
      ENDIF 
*   
   80 IF (KTWO.NE.' ') THEN 
*   
* ***   Bit 31 = 1  
*   
        IWD1(IND1) = 16384  
        NWI    = 2  
        CALL DBIFRC (KTWO, IDATA(NDATA+2), 1, 3)    
      ENDIF 
*   
      IF (KONE.EQ.'C') THEN 
        ICOM = 4    
      ELSE IF (KONE.EQ.'c') THEN    
        ICOM = 8    
      ELSE IF (KONE.EQ.'*') THEN    
        ICOM = 12   
      ELSE  
        ICOM = 0    
      ENDIF 
      IF (ICOM.NE.0) THEN   
*   
* ***   Bit 32 = 1  and bits 1-4 = 4 or 8 or 12 depending   
* ***                  upon KONE = C or c or *  
*   
        IWORD1  = MSBIT1 (IWORD1, 32)   
*   
        IWD1(IND2) = ICOM   
*   
        IF (KTWO.EQ.'.')THEN    
*   
* ***     Bit 2 =1 and Bit 31 = 0   
*   
          IWORD1  = MSBIT0 (IWORD1, 31) 
          NWI = 1   
          IWD1(IND2) = IWD1(IND2) + 2   
        ENDIF   
        IF (ILASTW.LE.2)                    GO TO 170   
*   
*  **   Is there a box ?    
*  **   Look for last isolated character    
*   
        LEN2 = LENOCC (KLINE(:(LENGTH-1)))  
        IF ((LENGTH-LEN2).GT.7) THEN    
*   
*  **     A box is there ====> Bit 1 =1 
*   
          IWD1(IND2) = IWD1(IND2) + 1   
          ILASTW = (LEN2+3)/4   
          CALL DBIFCH (KLINE(LENGTH:LENGTH), IKLIN) 
          IWD2(IND2) = LENGTH*256 + IKLIN   
*   
*  **     Look for the first isolated character 
*   
          NC1   = (IFIRW-1)*4+1 
          NC2   = NC1+3 
          NKAR  = 0 
          DO 90 IC = NC1, NC2   
            IF (KLINE(IC:IC).EQ.' ')        GO TO 90    
            IPOS = IC   
            NKAR = NKAR+1   
   90     CONTINUE  
          IF (NKAR.EQ.1) THEN   
            DO 100 IST = IFIRW+1, ILASTW    
              IF (LINE(IST).EQ.KBLAN)       GO TO 100   
              IFIRW = IST   
              CALL DBIFCH (KLINE(IPOS:IPOS), IKLIN) 
              IWD2(IND1) = IPOS*256 + IKLIN 
              GO TO 110 
  100       CONTINUE    
          ENDIF 
  110     NWI=NWI+1 
          IDATA(NDATA+NWI) = IWORD2 
        ENDIF   
*   
*  **   Is any character repeated ? 
*   
        IF (ILASTW.EQ.1)                    GO TO 170   
        DO 120 I = IFIRW+2, ILASTW-1    
          IF (LINE(I).NE.LINE(I-1))         GO TO 170   
  120   CONTINUE    
*   
*  **   Are the characters identical ?  
*  **   NFCOL2 = first column number of the second non-blank character  
*  **   NLCOL2 = last    "      "             "       "         "   
*   
        NFCOL2 = IFIRW*4+1  
        NLCOL2 = NFCOL2+3   
        DO 130 I = NFCOL2+1, NLCOL2 
          IF (KLINE(I:I).NE.KLINE(I-1:I-1)) GO TO 170   
  130   CONTINUE    
        CAR    = KLINE(NFCOL2:NFCOL2)   
*   
*  **   Check whether the non-blank characters in the first and 
*  **   the last word are also identical to CAR 
*   
        NFCOL  = (IFIRW-1)*4 + 1    
        NLCOL  = NFCOL + 3  
        NFIRST = NFCOL  
        DO 150 J = 1, 2 
          DO 140 I = NFCOL, NLCOL   
            IF (KLINE(I:I).EQ.' ') THEN 
              IF (J.EQ.1) NFIRST = I + 1    
              GO TO 140 
            ENDIF   
            IF (KLINE(I:I).NE.CAR)          GO TO 170   
            NLAST = I   
  140     CONTINUE  
          NFCOL = (ILASTW-1)*4 + 1  
          NLCOL = NFCOL + 3 
  150   CONTINUE    
*   
*  **   All characters are identical    
*  **   NFIRST = number of the first non-blank character    
*  **   NLAST  =   "           last     "         " 
*   
        IWD1(IND1) = IWD1(IND1) + NLAST*128 + NFIRST    
        CALL DBIFCH (CAR, IKLIN)    
        IWD1(IND2) = IWD1(IND2) + 256*IKLIN 
        IDATA(NDATA+1) = IWORD1 
        NDATA = NDATA + NWI 
        GO TO 999   
      ELSE IF (KONE.NE.'%' .AND. KONE.NE.'+' .AND. KLINE(6:6).EQ.' '    
     +   .AND. LENGTH.GT.7) THEN    
*   
*  **   For cases : CONTINUE , END and RETURN preceded by a label,  
*  **   use code in bits 24 to 30 = 117 , 119 or 115    
*   
        NC1    = 7  
  160   IF (KLINE(NC1:NC1).EQ.' ') THEN 
          NC1  = NC1 + 1    
          GO TO 160 
        ENDIF   
        IF (LENGTH-NC1.GT.7)                GO TO 170   
        KEYW   = KLINE(NC1:LENGTH)  
        CALL CLTOU (KEYW(:LENGTH-NC1+1))    
        IF (KEYW.EQ.KEND) THEN  
          IWD1(IND1) = IWD1(IND1) + 119*128 + NC1   
        ELSE IF(KEYW.EQ.KCONT) THEN 
          IWD1(IND1) = IWD1(IND1) + 117*128 + NC1   
        ELSE IF(KEYW.EQ.KRET) THEN  
          IWD1(IND1) = IWD1(IND1) + 115*128 + NC1   
        ELSE    
          GO TO 170 
        ENDIF   
        CALL DBIFCH (KLINE(5:5), IKLIN) 
        IWD1(IND2) = IWD1(IND2) + 256*IKLIN 
        IDATA(NDATA+1) = IWORD1 
        NDATA = NDATA+NWI   
        GO TO 999   
      ENDIF 
  170 CONTINUE  
      IWD1(IND1) = IWD1(IND1) + ILASTW*128 + IFIRW  
      IDATA(NDATA+1) = IWORD1   
      IF (ILASTW.EQ.1) THEN 
        NDATA = NDATA + NWI 
        GO TO 999   
      ENDIF 
      CALL DBIFRC (CLINE, ILINE, ILASTW, 4*ILASTW)  
      DO 180 IW = IFIRW, ILASTW 
        JW    = NDATA + NWI + IW - IFIRW + 1    
        IDATA(JW) = ILINE(IW)   
  180 CONTINUE  
      NDATA = JW    
*                                                             END DBLINC    
  999 END   
      SUBROUTINE DBLIND (IDATA, NTOT, CLINE, LENGTH)    
*     ==============================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBLIND (IDATA, *NTOT*, CLINE*, LENGTH*)                 *    
*                                                                      *    
*   Decodes an encdoed array into a string of characters               *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IDATA    Array containing the encoded information                *    
*     *NTOT*   Current location of the array IDATA to be decoded       *    
*     CLINE(*) Character string of maximum 80 characters               *    
*     LENGTH(*)Length of the string                                    *    
*                                                                      *    
*   Called by DBABRD, DBRHLP, DBAIRD                                   *    
*                                                                      *    
*   Original Code : DPLINE in CMZ Package                              *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       CLINE*(*), KLINE*80   
      DIMENSION       LINE(20), IDATA(9)    
      CHARACTER*8     KEYW(13)  
      CHARACTER*1     CAR, KONE, KTWO*(3)   
      DIMENSION       NCHKEY(13)    
*   
      DATA            KEYW /'RETURN','RETURN','CONTINUE','END','END',   
     +                      '+SELF.','+SEL','+CDE','+SEQ','+KEE','+DEC',    
     +                      'ELSE','ENDIF'/ 
      DATA            NCHKEY /6, 6, 8, 3, 3, 6, 4, 4, 4, 4, 4, 4, 5/    
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension itwo(1)
*     ------------------------------------------------------------------    
*   
      ICADRE = 0    
      IWORD  = IDATA(NTOT+1)    
      IF (IWORD.EQ.0) THEN  
        LENGTH = 0  
        CLINE  = ' '    
        NTOT   = NTOT + 1   
        GO TO 999   
      ENDIF 
*   
      LENGTH = 0    
      KLINE  = ' '  
      IBIT31 = JBIT (IWORD, 31) 
      IBIT32 = JBIT (IWORD, 32) 
      IF (IBIT31.NE.0) THEN 
        ITWO(1)   = IDATA(NTOT+2)  
        NWI    = 2  
        CALL DBCFRI (ITWO, KTWO, 1, 3)  
      ELSE  
        KTWO   = ' '    
        NWI    = 1  
      ENDIF 
      KCODE  = JBYT (IWORD, 1, 8)   
      IF (IBIT32.NE.0) THEN 
*   
* ***   Study the comment cards 
*   
        ICODE  = KCODE  
        ICADRE = MOD (ICODE, 2) 
        IPOINT = MOD (ICODE, 4) 
        ICMMNT = ICODE/4    
        IF (ICMMNT.EQ.1) THEN   
          KONE   = 'C'  
        ELSE IF (ICMMNT.EQ.2) THEN  
          KONE   = 'c'  
        ELSE    
          KONE   = '*'  
        ENDIF   
        IF (IPOINT.GT.1) THEN   
          KTWO   = '.'  
        ENDIF   
        KLINE  = KONE//KTWO 
        LENGTH = 4  
*   
*  **   Is there a box ?    
*   
        IF (ICADRE.NE.0) THEN   
          NWI    = NWI + 1  
          IPOS1  = JBYT (IDATA(NTOT+NWI), 25, 8)    
          IPOS2  = JBYT (IDATA(NTOT+NWI),  9, 8)    
          IKLIN  = JBYT(IDATA(NTOT+NWI),1,8)    
          CALL DBCHFI (IKLIN, KLINE(IPOS2:IPOS2))   
          LENGTH = IPOS2    
          IF (IPOS1.NE.0) THEN  
            IKLIN  = JBYT(IDATA(NTOT+NWI),17,8) 
            CALL DBCHFI (IKLIN, KLINE(IPOS1:IPOS1)) 
          ENDIF 
        ENDIF   
*   
* ***   Is there a character to repeat? 
*   
        ICAR   = JBYT (IWORD, 9, 8) 
        IF (ICAR.EQ.0) THEN 
*   
*  **     No character to repeat.   
*   
          IFWORD = JBYT (IWORD, 17, 7)  
          ILASTW = JBYT (IWORD, 24, 7)  
          IF (ILASTW.EQ.1) THEN 
            NTOT   = NTOT + NWI 
            GO TO 70    
          ENDIF 
*   
          IF (ILASTW.GT.20 .OR. IFWORD.GT.ILASTW) GO TO 100 
*   
          DO 10 IW = IFWORD, ILASTW 
            JW     = NTOT + NWI + IW - IFWORD + 1   
            LINE(IW) = IDATA(JW)    
   10     CONTINUE  
          NTOT   = JW   
          GO TO 60  
        ELSE    
*   
*  **     Character must be repeated.   
*   
          CALL DBCHFI (ICAR, CAR)   
          IFIRST = JBYT (IWORD, 17, 7)  
          ILAST  = JBYT (IWORD, 24, 7)  
*   
          IF (ILAST.GT.80 .OR. IFIRST.GT.ILAST)   GO TO 100 
*   
          DO 20 I = IFIRST, ILAST   
            KLINE(I:I) = CAR    
   20     CONTINUE  
          NTOT   = NTOT + NWI   
          IF (ICADRE.EQ.0) LENGTH = ILAST   
          GO TO 70  
        ENDIF   
      ELSE  
*   
* ***   Special cases   
*   
        ICODE  = JBYT (IWORD, 24, 7)    
        ICOD   = ICODE - 114    
*   
*  **   Case ENDIF or ELSE or END or CONTINUE or RETURN 
*  **   Case +PATCH,+DECK,+KEEP,+SEQ,+CDE,+SELF 
*   
*        ICODE = 115  ICOD = 1  'RETURN with label' 
*              = 116       = 2  'RETURN without label'  
*              = 117         3  'CONTINUE'  
*              = 118         4  'END without label' 
*              = 119         5  'END with label'    
*              = 120         6  '+SELF.'    
*              = 121         7  '+SELF,'    
*              = 122         8  '+CDE'  
*              = 123         9  '+SEQ'  
*              = 124        10  '+KEEP,'    
*              = 125        11  '+DECK,'    
*              = 126        12  'ELSE'  
*              = 127        13  'ENDIF' 
*   
        IF (ICOD.LE.0)                            GO TO 40  
        IF (ICOD.LT.6 .OR. ICOD.GT.11) THEN 
          IFIRST = JBYT (IWORD, 17, 7)  
          CLINE(1:IFIRST) = ' ' 
          IF (ICOD.EQ.1 .OR. ICOD.EQ.3 .OR. ICOD.EQ.5) THEN 
            CALL DBCHFI (KCODE, KONE)   
            IKLIN = JBYT (IWORD, 9, 8)  
            CALL DBCHFI (IKLIN, CLINE(5:5)) 
            CLINE(:4)  = KONE//KTWO 
          ENDIF 
          LENGTH = IFIRST+NCHKEY(ICOD)-1    
          CLINE(IFIRST:LENGTH) = KEYW(ICOD) 
          NTOT   = NTOT + NWI   
          GO TO 900 
        ENDIF   
*   
* ***   Case +PATCH,+DECK,+KEEP,+SEQ,+CDE,+SELF 
*   
        IF (ICOD .EQ. 6) THEN   
          CLINE(:6) = '+SELF.'  
          NTOT   = NTOT + 1 
          LENGTH = 6    
          GO TO 900 
        ENDIF   
*   
        IFWORD = 2  
        KLINE(1:4) = KEYW(ICOD) 
        ILASTW = JBYT (IWORD, 17, 7)    
        DO 30 IW = 2, ILASTW    
          LINE(IW) = IDATA(NTOT+IW) 
   30   CONTINUE    
        NTOT   = NTOT + ILASTW  
        GO TO 60    
      ENDIF 
*   
   40 CONTINUE  
*   
* *** Normal instructions   
*   
      CALL DBCHFI (KCODE, KONE) 
      KLINE  = KONE//KTWO   
      ILASTW = ICODE    
      IF (ILASTW.LT.2) THEN 
        NTOT   = NTOT+NWI   
        LENGTH = 4  
        GO TO 70    
      ENDIF 
      IFWORD = JBYT (IWORD, 17, 7)  
*   
      IF (ILASTW.GT.20 .OR. IFWORD.GT.ILASTW)     GO TO 100 
*   
      DO 50 IW = IFWORD, ILASTW 
        JW     = NTOT + NWI + IW - IFWORD + 1   
        LINE(IW) = IDATA(JW)    
   50 CONTINUE  
      NTOT   = JW   
   60 CONTINUE  
      NC     = (IFWORD-1)*4 + 1 
      LENGW  = ILASTW-IFWORD+1  
      LENG   = 4*LENGW  
      CALL DBCFRI (LINE(IFWORD), KLINE(NC:), LENGW, LENG)   
      IF (ICADRE.EQ.0) LENGTH = ILASTW*4    
   70 I1     = LENGTH   
      DO 80 I = I1, 1, -1   
        IF (KLINE(I:I).NE.' ')                    GO TO 90  
        LENGTH = LENGTH - 1 
   80 CONTINUE  
*   
   90 CLINE  = KLINE(1:LENGTH)  
      GO TO 900 
*   
  100 CALL DBPRNT (LPRTDB, '('' **** WARNING : Data in deck is corrup'//    
     +     'ted ****'')', IARGDB, 0)    
      CLINE  = ' '  
      LENGTH = 0    
  900 CONTINUE  
*                                                             END DBLIND    
  999 END   
      SUBROUTINE DBNODE (PATH, LBN) 
*     ============================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBNODE (PATH, LBN*)                                     *    
*                                                                      *    
*   Creates a Node structure in memory for given directory pathname    *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATH     Character string describing the pathname                *    
*     LBN      L-address of the lowest level Node bank                 *    
*                                                                      *    
*   Called by DBABRD, DBABWR, DBENTR, DBGET,  DBGETS, DBPURK, DBREPL,  *    
*             DBUSE                                                    *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 11 : Pathname not found in the RZ directory          *    
*               = 12 : Illegal pathname                                *    
*               = 13 : Not enough structural link to support a new Node*    
*               = 14 : No space available to create bank NODB          *    
*               = 15 : Cannot define IO descriptor for Key bank        *    
*               = 16 : Cannot find appropriate top directory           *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NLEVM=20, NWFXM=6, MAXD=1)   
      CHARACTER       CHFRM(5)*1, CFORM*80, CHCUR(NLEVM)*1  
      CHARACTER       FPATH*80, FTEMP*80, FTMP1*80, CNODE(20)*16, CHL*16    
      CHARACTER       PATH*(*)  
      INTEGER         NUCUR(NLEVM), NCHL(NLEVM)
      DATA            CHFRM / 'B', 'I', 'F', 'D', 'H'/,  NZ / 0/    
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension nio(9)
*     ------------------------------------------------------------------    
*   
* *** Get the full pathname 
*   
      LREFDB(2) = LBN    
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1) .NE. 0)  THEN   
        IQUEST(1) = 11  
        IF (IDEBDB.GT.0) THEN   
          FPATH  = PATH 
          CALL DBPRNT (LPRTDB, '(/,'' DBNODE : Pathname '//FPATH//' n'//    
     +         'ot found in RZ directory'')', IARGDB, 0)    
        ENDIF   
        GO TO 999   
      ENDIF 
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      CALL RZCDIR (FPATH, 'R')  
*   
* *** Get list of Nodes 
*   
      NODES  = 0    
      I0     = 0    
   10 I1     = I0 + 1   
      IF (I1.GT.MAXLDB)          GO TO 35   
      DO 15 I0 = I1, MAXLDB 
        IF (FPATH(I0:I0).EQ.' ') GO TO 25   
        IF (FPATH(I0:I0).EQ.'/') GO TO 20   
   15 CONTINUE  
      I0     = MAXLDB + 1   
   20 I2     = I0 - 1   
      GO TO 30  
   25 I2     = I0 - 1   
      I0     = MAXLDB + 1   
   30 IF (I2.LT.I1)              GO TO 10   
      NODES  = NODES + 1    
      CNODE(NODES) = FPATH(I1:I2)   
      NCHL (NODES) = I2 - I1 + 1    
      GO TO 10  
*   
* *** Number of Nodes found should be nonzero   
*   
   35 IF (NODES.EQ.0)  THEN 
        IQUEST(1) = 12  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNODE : Illegal'//    
     +  ' pathname '//FPATH//''')', IARGDB, 0)  
        GO TO 999   
      ENDIF 
*   
* *** Find the appropriate top-directory bank   
*   
      LTOP   = LTOPDB   
   40 IF (LTOP.NE.0)  THEN  
        NCH    = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, CHL, NCH)    
        CHL    = CHL(1:NCH) 
        IF (CHL.EQ.CNODE(1)) THEN   
          IFLG   = IQ(KOFUDB+LTOP+MUPFLG)   
          ITOP   = IQ(KOFUDB+LTOP+MUPDIC)   
          LBFXDB = LTOP 
          LBKYDB = LQ(KOFUDB+LTOP-KLDICT)   
          IF (LBKYDB.GT.0) THEN 
            NITEM  = IQ(KOFUDB+LBKYDB+MDCNTM)   
          ELSE  
            NITEM  = 0  
          ENDIF 
        ELSE    
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 40  
        ENDIF   
      ELSE  
        IQUEST(1) = 16  
        IQUEST(11)= NODES   
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNODE : Cannot '//    
     +  'find top directory '//CNODE(1)//' in tree with'',I6,'' names'//    
     +  ' '')', IQUEST(11), 1)  
        GO TO 999   
      ENDIF 
*   
*  ** Check if all Nodes already exist in memory    
*   
      IN     = 0    
   45 IN     = IN + 1   
*   
*  ** Construct the pathname from the Node names    
*   
      NCHAR  = 1    
      FPATH  = '/'  
      DO 50 I = 1, IN   
        CHL    = CNODE(I)   
        NMAX   = NCHL (I)   
        IF (NCHAR+NMAX .GT. MAXLDB) THEN    
          NMAX  = MAXLDB - NCHAR - 1    
          IF (NMAX.LE.0)         GO TO 50   
        ENDIF   
        FPATH  = FPATH(1:NCHAR)//'/'//CHL(1:NMAX)   
        NCHAR  = NCHAR + NMAX + 1   
        IF (NCHAR.EQ.MAXLDB)     GO TO 55   
   50 CONTINUE  
*   
*  ** The first Node should be at the top directory 
*   
   55 I0     = 0    
      IF (IN.EQ.1) THEN 
        NMAX   = 1  
      ELSE  
        NMAX   = IQ(KOFUDB+LREFDB(2)-2) 
      ENDIF 
*   
   60 I0     = I0 + 1   
*   
*  *  No link left to insert a new Node bank    
*   
      IF (I0.GT.NMAX)  THEN 
        IF (IN.EQ.1.OR.IFLG.EQ.0)  THEN 
          IQUEST(1) = 13    
          IQUEST(11)= IN    
          IQUEST(12)= NODES 
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNODE : No li'//    
     +    'nk left to insert the Node '//CNODE(IN)//' at level '',I3'// 
     +    ','' out of '',I3)', IQUEST(11), 2)   
          GO TO 999 
*   
        ELSE    
*   
          CALL MZPUSH (IDIVDB, LREFDB(2), 1, 0, ' ')    
          LSAVDB = LREFDB(2)    
          JBIAS  = -I0  
          IDIC   = 0    
          GO TO 75  
        ENDIF   
      ENDIF 
*   
      IF (IN.EQ.1)  THEN    
        LSAVDB = LQ(KOFUDB+LBFXDB-1)    
      ELSE  
        LSAVDB = LQ(KOFUDB+LREFDB(2)-I0)    
      ENDIF 
*   
*  *  Check the full pathname in the Node bank name against 
*  *  the current pathname  
*   
      IF (LSAVDB.NE.0)  THEN    
        MCHAR  = IQ(KOFUDB+LSAVDB+MNDNCH)   
        IF (MCHAR.GT.MAXLDB) MCHAR  = MAXLDB    
        CALL UHTOC (IQ(KOFUDB+LSAVDB+MNDNAM), 4, FTMP1, MCHAR)  
        FTEMP  = FTMP1(1:MCHAR) 
        IF (FTEMP.NE.FPATH)      GO TO 60   
        GO TO 90    
      ELSE  
*   
*  *    Find the dictionary number  
*   
        IF (IN.EQ.1)  THEN  
          IDIC   = ITOP * 10000 
          LSAVDB = LBFXDB   
          JBIAS  = -1   
        ELSE    
          LSAVDB = LREFDB(2)    
          JBIAS  = -I0  
          IDIC   = ITOP * 10000 
          IF (NITEM.GT.0) THEN  
            FTEMP  = FPATH(NCHL(1)+3:NCHAR) 
            MCHAR  = NCHAR - NCHL(1) - 2    
            DO 65 ITEM = 1, NITEM   
              IPNT   = KOFUDB + LBKYDB + (ITEM - 1) * NWITDB + 1    
              IF (IQ(IPNT+MDCITM).GT.0) THEN    
                IF (MCHAR.EQ.IQ(IPNT+MDCNCH)) THEN  
                  CALL UHTOC (IQ(IPNT+MDCNAM), 4, FTMP1, MCHAR) 
                  FTMP1  = FTMP1(1:MCHAR)   
                  IF (FTEMP.EQ.FTMP1) THEN  
                    IDIC   = IDIC + IQ(IPNT+MDCITM) 
                    GO TO 70    
                  ENDIF 
                ENDIF   
              ENDIF 
   65       CONTINUE    
          ENDIF 
   70     CONTINUE  
        ENDIF   
      ENDIF 
*   
*  *  The Node bank does not exist; create it   
*   
   75 ND     = NCHAR/4  
      IF (NCHAR.GT.ND*4) ND = ND + 1    
      ND     = ND + NWNODB + 4  
      CALL RZCDIR (FPATH, ' ')  
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      CALL RZRDIR (MAXD, FTMP1, NL) 
      IF (IQUEST(1).EQ.1) NL = IQUEST(11)   
      IF (NKEYDK.GT.0) THEN 
        IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)    
        IOPTP  = JBIT (IOPTP, JPRTDB)   
        IF (IOPTP.NE.0) THEN    
          NL     = NL - NKEYDK  
          IF (NL.LT.0) NL = 0   
        ENDIF   
      ENDIF 
*
      nio(1) = ionodb
      CALL DBBOOK (IDIVDB, LA, LSAVDB, JBIAS, 'NODB', NL, NL, ND,   
     +             nio, NZ)  
      IF (IQUEST(1).NE.0)  THEN 
        IQUEST(1) = 14  
        IQUEST(11)= IN  
        IQUEST(12)= NODES   
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNODE : No sp'//  
     +  'ace in memory to create Node bank '//CNODE(IN)//' at level'//  
     +  ' '',I3,'' out of '',I3)', IQUEST(11), 2)   
        GO TO 999   
      ENDIF 
*   
*  *  Find IO descriptor for the Key banks attached to this Node    
*   
      NLEV   = 0    
      NCUR   = 0    
      IFORO  = 0    
      CALL DBKEYT   
      DO 80 I = 1, NWKYDK   
        IFORM  = IOTYDK(I)  
        IF (IFORM.EQ.6) IFORM = 5   
        IF (IFORM.EQ.IFORO)  THEN   
          NCUR   = NCUR + 1 
        ELSE    
          IF (NLEV.GT.0) NUCUR(NLEV) = NCUR 
          IF (NLEV.GE.NLEVM)  THEN  
            IQUEST(1) = 15  
            IQUEST(11)= I   
            IQUEST(12)= NLEVM   
            IF (IDEBDB.GT.0) THEN   
              IARGDB(1) = IQUEST(12)    
              IARGDB(2) = IQUEST(11)    
              CALL DBPRNT (LPRTDB, '(/,'' DBNODE : Too many type of'//  
     +             ' variables for IO descriptor of Key bank at Key'//  
     +             ' '',I3,'' Maximum level '',I3)', IARGDB, 2) 
            ENDIF   
            GO TO 999   
          ENDIF 
          NLEV   = NLEV + 1 
          CHCUR(NLEV) = CHFRM(IFORM)    
          NCUR   = 1    
          IFORO  = IFORM    
        ENDIF   
   80 CONTINUE  
*   
      IF (NLEV.GT.0)  THEN  
        NUCUR(NLEV) = NCUR  
        IF (CHCUR(NLEV).EQ.CHFRM(2))  THEN  
          NUCUR(NLEV) = NCUR + NWFXM    
        ELSE    
          IF (NLEV.GE.NLEVM)  THEN  
            IQUEST(1) = 15  
            IQUEST(11)= NWKYDK + 1  
            IQUEST(12)= NLEVM   
            IF (IDEBDB.GT.0) THEN   
              IARGDB(1) = IQUEST(12)    
              IARGDB(2) = IQUEST(11)    
              CALL DBPRNT (LPRTDB, '(/,'' DBNODE : Too many type of'//  
     +             ' variables for IO descriptor of Key bank at Key'//  
     +             ' '',I3,'' Maximum level '',I3)', IARGDB, 2) 
            ENDIF   
            GO TO 999   
          ENDIF 
          NLEV   = NLEV + 1 
          CHCUR(NLEV) = CHFRM(2)    
          NUCUR(NLEV) = NWFXM   
        ENDIF   
      ELSE  
        NLEV   = 1  
        CHCUR(NLEV) = CHFRM(2)  
        NUCUR(NLEV) = NWFXM 
      ENDIF 
*   
      WRITE (CFORM, 2001) (NUCUR(I), CHCUR(I), I = 1, NLEV) 
      I      = 4*NLEV   
*   
      LSAVDB = LA   
      IQ(KOFUDB+LSAVDB+MNDNWK) = NWKYDK 
      IQ(KOFUDB+LSAVDB+MNDNWD) = NWKYDK + NWFXM 
      IQ(KOFUDB+LSAVDB+MNDNCH) = NCHAR  
      IQ(KOFUDB+LSAVDB+MNDDIC) = IDIC   
      CALL MZIOCH (IQ(KOFUDB+LSAVDB+MNDIOF), NWNODB, CFORM(1:I))    
      CALL UCTOH (FPATH, IQ(KOFUDB+LSAVDB+MNDNAM), 4, NCHAR)    
*   
   90 LBN = LSAVDB   
      LREFDB(2) = LSAVDB    
      LSAVDB = 0    
      IF (IN.LT.NODES)           GO TO 45   
*   
* *** The Node exists; Normal return    
*   
  100 IQUEST(1) = 0 
*   
 2001 FORMAT (20(I2,A1,1X)) 
*                                                             END DBNODE    
  999 END   
      SUBROUTINE DBOPTS (CHOPT) 
*     ========================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBOPTS (CHOPT)                                          *    
*                                                                      *    
*   Decode the character option and fill up the common block /DAOPTS/  *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     CHOPT    Character option supplied by user                       *    
*                                                                      *    
*   Called by various routines in the DBL3 package                     *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 91 : Illegal Character Option                        *    
*                                                                      *    
************************************************************************    
*   
      COMMON /DAOPTI/ CALFDA(62), CSTRDA    
      CHARACTER       CALFDA*1, CSTRDA*132  
      COMMON /DAOPT1/ MPAKDA(2) 
      INTEGER         MPAKDA    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      CHARACTER       CHOPT*(*), CTEST*1, BLANK*1, CTMP*80  
      DIMENSION       ICOPT(300), IALFA(55) 
      EQUIVALENCE     (IALFA(1), IOPADA)    
      DATA            BLANK / ' '/  
*   
*     ------------------------------------------------------------------    
*   
      IQUEST(1) = 0 
      DO 5 K = 1, 26+29 
        IALFA(K) = 0    
    5 CONTINUE  
*   
* *** Convert CHOPT into a list of integer variables    
*   
      MAXL   = LEN (CHOPT)  
      I1     = 0    
      DO 20 I0 = 1, MAXL    
        CTEST  = CHOPT(I0:I0)   
        DO 10 I = 1, 62 
          IF (CTEST.EQ.CALFDA(I)) GO TO 15  
   10   CONTINUE    
        IF (CTEST.NE.BLANK)       GO TO 991 
        GO TO 20    
   15   I1     = I1 + 1 
        IF (I.GT.36) I = I - 36 
        ICOPT(I1) = I   
   20 CONTINUE  
      MAXU   = I1   
*   
* *** Now fill up the common /DAOPTS/   
*   
      I0     = 0    
   30 I0     = I0 + 1   
      IF (I0.GT.MAXU)             GO TO 999 
      I      = ICOPT(I0)    
*   
*  ** Alphabetic options    
*   
      IF (I.LE.26) THEN 
        IALFA(I) = 1    
        GO TO 30    
      ENDIF 
*   
*  ** Numeric options (at the moment 3-29 only) 
*  ** If first digit = 1 or 2, it has to be a 2 digit number    
*  **                = 3 .. 9, it can only be one digit number  
*  ** First digit can never be 0.   
*   
      I1     = I - 27   
      IF (I1.EQ.0)                GO TO 991 
      IF (I1.GE.3.AND.I1.LE.9) THEN 
        IOKYDA(I1) = 1  
        GO TO 30    
      ENDIF 
      IF (I0.GE.MAXU)             GO TO 991 
      I      = ICOPT(I0+1) - 27 
      IF (I.LT.0)                 GO TO 991 
      IOKYDA(I1*10+I) = 1   
      I0     = I0 + 1   
      GO TO 30  
*   
* *** Illegal Character option  
*   
  991 IQUEST(1)  = 91   
      IQUEST(11) = I0   
      IF (IDEBDB.GT.0) THEN 
        CTMP   = CHOPT  
        CALL DBPRNT (LPRTDB, '('' DBOPTS : Illegal Character option a'//    
     +       'fter '',I2,'' in '//CTMP//''')', IQUEST(11), 1)   
      ENDIF 
*                                                             END DBOPTS    
  999 END   
      SUBROUTINE DBPACK (IAIN, LIN, LOU, LAUX, LBITL, IAOU, IAUX)   
*     ===========================================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPACK (IAIN, LIN, LOU*, LAUX*, LBITL, IAOU*, IAUX)     *    
*                                                                      *    
*   Compresses data from 32 to LBITL bit size                          *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IAIN     Input array                                             *    
*     LIN      Length of the input array                               *    
*     LOU(*)   Length of the output array                              *    
*     LAUX(*)  Number of words exceeding the length LBITL and therefore*    
*              are stored in 32 bits with locations given              *    
*     LBITL    Number of bits to be used for storing                   *    
*     IAOU(*)  Output array                                            *    
*     IAUX     Auxiliary array for internal working space              *    
*                                                                      *    
*   Called by DBCMPR                                                   *    
*                                                                      *    
************************************************************************    
*   
      DIMENSION       IAIN(LIN), IAOU(LIN), IAUX(LIN)   
      DIMENSION       IHB(33), LHB(32), AHB(32) 
      DATA            MINBIT /2/  , IBIG /9999999/  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
      MSBIT (MZ,IZW,IZP) = IOR (IAND (IZW, NOT(ISHFT(1,IZP-1)) )    
     +                              , ISHFT(IAND(MZ,1),IZP-1))  
*   
      MCBYT (MZ,IZQ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +        , ISHFT (ISHFT(ISHFT(MZ,-IZQ+1),32-NZB), -33+IZP+NZB) )   
*   
      JBYTET (MZ,IZW,IZP,NZB) = IAND (MZ, IBITS(IZW,IZP-1,NZB)) 
      JBYTOR (MZ,IZW,IZP,NZB) = IOR  (MZ, IBITS(IZW,IZP-1,NZB)) 
      MBYTET (MZ,IZW,IZP,NZB) = IAND (IZW, NOT(ISHFT (  
     +                          ISHFT(NOT(MZ),32-NZB),-33+IZP+NZB)) )   
      MBYTOR (MZ,IZW,IZP,NZB) = IOR (IZW, ISHFT (   
     +                               ISHFT(MZ,32-NZB),-33+IZP+NZB) )    
*   
*     ------------------------------------------------------------------    
*   
      CALL VZERO_i (IHB, 33)  
      CALL VZERO_i (IAOU, LIN)    
      CALL VFILL (LHB, 32, IBIG)    
*   
* *** Histogram of the input stream bit-length  
*   
      DO 3 I = 1, LIN   
        DO 1 J = 1, 32  
          J1    = 33 - J    
          IF (JBIT(IAIN(I),J1).EQ.1) GO TO 2    
    1   CONTINUE    
    2   IHB(J1) = IHB(J1) + 1   
    3 CONTINUE  
*   
* *** Look for the minimum storage length   
*   
      NW    = 0 
      JJ    = 33 - MINBIT   
      DO 4 J = 1, JJ    
        J1    = 33 - J  
        NW    = NW + IHB(J1+1)  
        LHB(J1) = (LIN*J1-1)/32 + 2*NW  
    4 CONTINUE  
*   
      CALL VFLOAT (LHB, AHB, 32)    
      LBITL = LVMIN (AHB, 32)   
      IF (LHB(LBITL)+1.GE.LIN)       GO TO 991  
*   
      ICOMP = LBITL + 1 
      NCOMP = 32 - LBITL    
*   
* *** Pack the input with LBITL byte size   
* ***    (If input is longer then LBITL, write it in a separate 
* ***     output word at the end of the buffer) 
*   
      LAUX  = 0 
      LOU   = 1 
      IN    = 1 
      IB    = 1 
   11 CONTINUE  
      IF (NCOMP.GT.0) THEN  
        ICHECK = JBYT (IAIN(IN), ICOMP, NCOMP)  
      ELSE  
        ICHECK = 0  
      ENDIF 
      IBA   = IB + LBITL    
      IF (IBA.LE.32) THEN   
        IF (LBITL.GT.0) 
     +  IAOU(LOU) = MSBYT (IAIN(IN), IAOU(LOU), IB, LBITL)  
        IB = IBA    
      ELSE  
        LBIT1 = 32 - IB + 1 
        IF (LBIT1.GT.0) 
     +  IAOU(LOU) = MSBYT (IAIN(IN), IAOU(LOU), IB, LBIT1)  
*       ITEST = JBYT (IAOU(LOU), IB, LBIT1) 
        IB    = IBA - 32    
        LOU   = LOU + 1 
        IF (IB.GT.1)    
     +    IAOU(LOU) = MCBYT (IAIN(IN), LBIT1+1, IAOU(LOU), 1, IB-1) 
*       ITEST = MSBYT (IAOU(LOU), ITEST, LBIT1+1, IB-1) 
      ENDIF 
      IF (ICHECK.NE.0) THEN 
        IF (LAUX+2.GT.LIN)           GO TO 991  
        IAUX(LAUX+1) = IN   
        IAUX(LAUX+2) = IAIN(IN) 
        LAUX  = LAUX + 2    
      ENDIF 
      IF (IN.LT.LIN) THEN   
        IN    = IN + 1  
        GO TO 11    
      ENDIF 
*   
      ICAR  = 0 
      IF (IAOU(LOU+1).NE.0) ICAR = IAOU(LOU+1)  
      IF (LAUX.GT.0) THEN   
        IF (LOU+LAUX.GT.LIN)         GO TO 991  
        DO 21 I = 1, LAUX   
   21   IAOU(LOU+I) = IAUX(I)   
        IF (ICAR.NE.0) IAOU(LIN) = ICAR 
        LOU   = LOU + LAUX  
      ENDIF 
      GO TO 999 
*   
  991 CONTINUE  
      CALL UCOPY_i (IAIN, IAOU, LIN)  
      LOU   = LIN   
      LBITL = 32    
      LAUX  = 0 
*                                                             END DBPACK    
  999 END   
      SUBROUTINE DBPATH (PATHX, IK) 
*     ============================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPATH (PATHX*, IK)                                     *    
*                                                                      *    
*   Get the subdirectory address of a partitioned data set             *    
*   from the Subdirectory number                                       *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHX(*) Character string specifying the subdirectory path name  *    
*     IK       Subdirectory number                                     *    
*                                                                      *    
*   Called by various routines in the DBL3 package                     *    
*                                                                      *    
************************************************************************    
*   
      CHARACTER       PATHX*(*) 
      DATA            I2 / 8/   
*   
*     ------------------------------------------------------------------    
*   
      WRITE (PATHX, '(I8)') IK  
      I3     = 10   
      DO 10 I = 1, I2   
        IF (IK.LT.I3) THEN  
          I1     = I2 + 1 - I   
          PATHX  = PATHX(I1:I2) 
          GO TO 999 
        ENDIF   
        I3     = I3 * 10    
   10 CONTINUE  
*                                                             END DBPATH    
  999 END   
      SUBROUTINE DBPRDT 
*     ================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPRDT                                                  *    
*                                                                      *    
*   Prints all objects for the current subdirectory                    *    
*                                                                      *    
*   Called by DBPRIN                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =104 : Read error in getting the RZ date and time      *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
* *** Find the objects to be printed    
*   
      IOKYDA(MSERDB) = 1    
      ITIME  = 0    
      JBIAS  = 2    
      CALL VZERO_i (INDKDK, NKEYDK)   
      IL     = 1    
   10 IN     = IL   
      MNKYDT = 0    
      DO 20 IK = 1, NKEYDK  
        IF (INDKDK(IK).NE.0)                    GO TO 20    
        CALL DBKEYR (IK, NWKYDK, KEYVDK)    
        IF (MNKYDT.EQ.0)  THEN  
          MNKYDT = KEYVDK(MSERDB)   
          KEY6DT = KEYVDK(MFLGDB)   
        ELSE    
          IF (KEYVDK(MPVSDB).NE.KEYNDK(MPVSDB)) GO TO 20    
          DO 15 I = 3, NWKYDK   
            IF (I.EQ.MFLGDB.OR.I.EQ.MITMDB) THEN    
              GO TO 15  
            ELSE    
              IF (KEYVDK(I).NE.KEYNDK(I))       GO TO 20    
            ENDIF   
   15     CONTINUE  
          IF (MNKYDT.LT.KEYNDK(MSERDB))  THEN   
            MNKYDT = KEYNDK(MSERDB) 
            KEY6DT = KEYNDK(MFLGDB) 
          ENDIF 
        ENDIF   
        INDKDK(IK) = 1  
   20 CONTINUE  
*   
* *** Now print the objects 
*   
      IF (MNKYDT.NE.0)  THEN    
        KEY6   = JBIT (KEY6DT, JIGNDB)  
        IFLG   = 0  
        DO 30 IK = IN, NKEYDK   
          IF (INDKDK(IK).NE.1)  THEN    
            IFLG   = 1  
          ELSE  
            INDKDK(IK) = 2  
            IF (IFLG.EQ.0) IL = IK + 1  
            IF (KEY6.EQ.0)  THEN    
              CALL DBKEYR (IK, NWKYDK, KEYNDK)  
              IF (IOPDDA.NE.0) CALL DBPRNT (LPRTDB, '(//,15X,''======'//    
     +        '====== Keys and Time ============'',/)', IARGDB, 0)  
              CALL DBPRKY (NWKYDK, KEYNDK, IOTYDK)  
              IF (IQUEST(1).NE.0)               GO TO 990   
              IF (IOPIDA.NE.0) THEN 
                JBIAS  = 2  
                CALL RZIN (IDISDB, LDUMM, JBIAS, KEYNDK, 9999, 'C') 
                IF (IQUEST(1).NE.0) THEN    
                  IQUEST(1) = 104   
                  IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRDT'//    
     +            ' : RZIN error in getting the cycle information'')',  
     +            IARGDB, 0)    
                  GO TO 990 
                ENDIF   
                INSTM = IQUEST(14)  
                CALL RZDATE (INSTM, IARGDB(1), IARGDB(2), 1)    
                CALL DBPRNT (LPRTDB, '(12X,''Date : '',I10,''   Time '//    
     +               ': '',I10)', IARGDB, 2)    
              ENDIF 
              IF (IOPDDA.NE.0)  THEN    
                LAUXDL(8) = 0   
                CALL VZERO_i (KEYVDK, NWKYDK) 
                KEYVDK(MSERDB) = IK 
                CALL DBKXIN (ITIME, IDISDB, LAUXDL(8), LAUXDL(8),   
     +                       JBIAS, NWKEY, KEYVDK, IPREC)   
                IER    = IQUEST(1)  
                IF (LAUXDL(8).NE.0) THEN    
                  CALL DZSHOW ('*DBPRDT*', IDISDB, LAUXDL(8), 'BLV',    
     +                         0, 0, 0, 0)  
                  CALL MZDROP (IDISDB, LAUXDL(8), 'L')  
                ENDIF   
                IQUEST(1) = IER 
                IF (IQUEST(1).NE.0)             GO TO 990   
              ENDIF 
            ENDIF   
          ENDIF 
   30   CONTINUE    
*   
        IF (IL.EQ.IN) IL = IN + 1   
        IF (IL.LE.NKEYDK)                       GO TO 10    
      ENDIF 
*   
  990 IOKYDA(MSERDB) = 0    
*                                                             END DBPRDT    
  999 END   
      SUBROUTINE DBPRKY (NW, KY, KT)    
*     ==============================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPRKY (NW, KY, KT)                                     *    
*                                                                      *    
*   Prints a vector KY of elements NW according to its type KT         *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     NW       Number of elements in the array KY (and KT)             *    
*     KY       Vector to be printed                                    *    
*     KT       Type of the vector elements                             *    
*          1 - Binary                                                  *    
*          2   Integer                                                 *    
*          3   Floating                                                *    
*          4   Double Precision (not yet implemented)                  *    
*          5   Hollerith                                               *    
*                                                                      *    
*   Called by DBENTB, DBNTOP, DBPRGD, DBENFZ, DBKOUT, DBPRDT           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =103 : Illegal data type                               *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      CHARACTER       CHPRT*132 
      DIMENSION       KY(NW), KT(NW)    
*
      dimension iarg(9)
*     ------------------------------------------------------------------    
*   
      IPR   = 0 
      I1    = 3 
      CHPRT = ' '   
      DO 10 I = 1, NW   
        IPR   = IPR + 1 
        IF (IPR.GT.10) THEN 
          CALL DBPRNT (LPRTDB, '('''//CHPRT//''')', IARGDB, 0)  
          IPR   = 1 
          I1    = 3 
          CHPRT = ' '   
        ENDIF   
        KK    = KT(I)   
        IF (KK.LT.1.OR.KK.EQ.4.OR.KK.GT.6) GO TO 901    
        GO TO (1,2,3,4,5,5), KK 
    1   CONTINUE    
*   
*  **   Binary  
*   
        I2 = I1 + 11    
        WRITE (CHPRT(I1:I2), '(2X,Z10)') KY(I)  
        I1 = I2 + 1 
        GO TO 10    
    2   CONTINUE    
*   
*  **   Integer 
*   
        I2 = I1 + 11    
        WRITE (CHPRT(I1:I2), '(2X,I10)') KY(I)  
        I1 = I2 + 1 
        GO TO 10    
    3   CONTINUE    
*   
*  **   Floating    
*   
        I2 = I1 + 11    
        WRITE (CHPRT(I1:I2), '(G12.4)') KY(I)   
        I1 = I2 + 1 
        GO TO 10    
    4   CONTINUE    
        GO TO 901   
    5   CONTINUE    
*   
*  **   Hollerith   
*   
        I2 = I1 + 11    
        WRITE (CHPRT(I1:I2), '(8X,A4)') KY(I)   
        I1 = I2 + 1 
        GO TO 10    
*   
   10 CONTINUE  
      IF (I1.GT.3) CALL DBPRNT (LPRTDB, '('''//CHPRT//''')', IARGDB, 0) 
      IQUEST(1) = 0 
      GO TO 999 
*   
* *** Error codes   
*   
  901 CONTINUE  
      IQUEST(1) = 103
      iarg(1) = kk
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRKY : Illegal '// 
     +   'data type to be printed = '',I10/)', iarg, 1)   
      GO TO 999 
*                                                             END DBPRKY    
  999 END   
      SUBROUTINE DBPRNT (LUN, CFORM, IARG, NARG)    
*     ==========================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPRNT (LUN, CFORM, IARG, NARG)                         *    
*                                                                      *    
*   Prints a vector IARG of NARG elements on logical unit LUN          *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUN      Logical unit number of the output                       *    
*     CFORM    Format specification                                    *    
*     IARG     Array of numbers to be printed                          *    
*     NARG     Number of elements in array IARG                        *    
*          2   Integer                                                 *    
*          3   Floating                                                *    
*          4   Double Precision (not yet implemented)                  *    
*          5   Hollerith                                               *    
*                                                                      *    
*   Called by various routines in the DBL3 package                     *    
*                                                                      *    
************************************************************************    
*   
      CHARACTER       CFORM*(*) 
      DIMENSION       IARG(*)   
*   
*     ------------------------------------------------------------------    
*   
      WRITE (LUN, CFORM, ERR=999) (IARG(I), I = 1, NARG)    
*                                                             END DBPRNT    
  999 END   
      SUBROUTINE DBROPN (LUN, CHOPT, CFNAM, NRECL, IOERR)   
*     ===================================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBROPN (LUN, CHOPT, CFNAM, NRECL, IOERR*)               *    
*                                                                      *    
*   Opens a random access file                                         *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUN      Logical unit number                                     *    
*     CHOPT    Character string with any of the following characters   *    
*          O   Output file (default is input)                          *    
*          Z   File to be overwritten if exists                        *    
*     CFNAM    File name                                               *    
*     NRECL    Record length in bytes                                  *    
*     IOERR    Error code (0 if no error)                              *    
*                                                                      *    
*   Called by DBEXAMn                                                  *    
*                                                                      *    
************************************************************************    
*   
      DIMENSION       IOPT(2)   
      CHARACTER       CHOPT*(*), CFNAM*(*), NAME*80, STATE*10   
      EQUIVALENCE     (IOPTO, IOPT(1)), (IOPTZ, IOPT(2))    
*   
*     ------------------------------------------------------------------    
*   
* *** Check if Filename is meaningful   
*   
      NCH    = LENOCC (CFNAM)   
      IF (NCH.LT.1)        GO TO 999    
      NCHM   = MIN (50, NCH)    
      NAME   = CFNAM    
*   
* *** Analyse the option    
*   
      CALL UOPTC  (CHOPT, 'OZ', IOPT)   
      IF (IOPTZ.NE.0) IOPTO = 1 
*   
* *** Decide on the record length   
*   
      IF (NRECL.GT.0) THEN  
        NREC   = NRECL  
      ELSE  
        NREC   = 4096   
      ENDIF 
      NBLK   = NREC 
      NREC   = NREC/4   
*   
* *** Decide on state and form  
*   
      IF (IOPTO.EQ.0) THEN  
        STATE  = 'OLD'  
      ELSE  
        STATE  = 'UNKNOWN'  
      ENDIF 
*   
* *** Now open the file 
*   
      IF (IOPTO.EQ.0) THEN  
C&IF LINUX
C&        OPEN (UNIT=LUN, FILE=NAME, ACCESS='DIRECT', STATUS=STATE,   
C&     +        FORM='UNFORMATTED', ERR=50, 
C&     +        IOSTAT=IOERR) 
C&ELSE
        OPEN (UNIT=LUN, FILE=NAME, ACCESS='DIRECT', STATUS=STATE,   
     +        READONLY, SHARED, FORM='UNFORMATTED', ERR=50, 
     +        IOSTAT=IOERR) 
C&ENDIF
      ELSE  
C&IF LINUX
C&        OPEN (UNIT=LUN, FILE=NAME, ACCESS='DIRECT', STATUS=STATE,   
C&     +        RECL=NREC, FORM='UNFORMATTED', ERR=50,    
C&     +        IOSTAT=IOERR) 
C&ELSE
        OPEN (UNIT=LUN, FILE=NAME, ACCESS='DIRECT', STATUS=STATE,   
     +        SHARED, RECL=NREC, FORM='UNFORMATTED', ERR=50,    
     +        IOSTAT=IOERR) 
C&ENDIF
      ENDIF 
      IOPT(1) = LUN 
      IOPT(2) = NREC    
      CALL DBPRNT (6, '('' DBROPN : '//NAME(1:NCHM)//' opened on Unit'//    
     +     ' '',I4,'' with RECL '',I8)', IOPT, 2)   
      GO TO 999 
*   
   50 IOPT(1) = IOERR   
      IOPT(2) = LUN 
      CALL DBPRNT (6, '('' DBROPN Error : IOSTAT = '',I11,'' in openi'//    
     +     'ng '//NAME(1:NCHM)//' on unit '',I4)', IOPT, 2) 
*                                                             END DBROPN    
  999 END   
      SUBROUTINE DBRZIN (IDIV, LAD, JBIAS, ICUR, ICYCL, PATHN)  
*     ========================================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBRZIN (IDIV, *LAD*, JBIAS, ICUR, ICYCL*, PATHN)        *    
*                                                                      *    
*   Checks if enough space is left in memory before loading the data   *    
*   part of an object. When not enough space is available after        *    
*   garbage collection, the banks freed by DBFREE are dropped.         *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IDIV     Division number where the object is to be created       *    
*     LAD      Address of the data bank as returned by RZIN            *    
*     JBIAS    Link bias as supplied to RZIN                           *    
*     ICUR     RZ key number of the object to be loaded                *    
*     ICYCL    Cycle number of the data object                         *    
*     PATHN    Path name (only needed in the printout)                 *    
*                                                                      *    
*   Called by DBDELT, DBNTOP, DBPRGD, DBRTFZ, DBCDIC, DBCOMP, DBKXIN,  *    
*             DBUDIC, DBUNCP                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 34 : Error in RZ for reading the object              *    
*               = 99 : No space in memory for creating the bank        *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       PATHD*80, PATHN*(*)   
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension keyu(9)
*     ------------------------------------------------------------------    
*   
* *** Find number of data words 
*   
      IPNT   = KOFSDB + LCDRDB + IKDRDB + (ICUR - 1) * (NWKYDK + 1) 
      LCYC   = IQ(IPNT) 
      NWDS   = JBYT (IQ(KOFSDB+LCDRDB+LCYC+3), 1, 20)   
*   
* *** See if enough space is available in memory    
*   
    5 NEEDW  = NWDS + 100   
      CALL MZNEED (IDIV, NEEDW, ' ')    
      IF (IQUEST(11).LT.0)  THEN    
        CALL MZNEED (IDIV, NEEDW, 'G')  
        IF (IQUEST(11).LT.0)  THEN  
          LGO    = 0    
   10     LBFYDB = LZFIDH (IDIV, IHKYDB, LGO)   
          IF (LBFYDB.NE.0)  THEN    
            ND0    = IQ(KOFUDB+LBFYDB-1)    
            IF (IQ(KOFUDB+LBFYDB+ND0+MKYFRI).GT.0)  THEN    
              LDAT   = LQ(KOFUDB+LBFYDB-KLDADB) 
              IF (LDAT.GT.0) CALL MZDROP (IDIV, LDAT, 'L')  
            ENDIF   
            LGO    = LBFYDB 
            GO TO 10    
          ENDIF 
          CALL MZNEED (IDIV, NEEDW, 'G')    
          IF (IQUEST(11).LT.0)  THEN    
            IQUEST(1) = 99  
            IF (IDEBDB.GT.0) THEN   
              CALL DBPRNT (LPRTDB, '(/,'' DBRZIN : No space left for '//    
     +             'loading object from disk == space needed '',I12)',  
     +             IQUEST(11), 1)   
            ENDIF   
            GO TO 999   
          ENDIF 
        ENDIF   
      ENDIF 
*   
* *** Now call RZIN 
*   
      ICYCL  = 999999
      keyu(1) = icur
      CALL RZIN (IDIV, LAD, JBIAS, keyu, ICYCL, 'S') 
  990 IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 34  
        PATHD  = PATHN  
        NCH    = LENOCC (PATHD) 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRZIN : '//   
     +  'RZIN error for path name '//PATHD(1:NCH)//''')', IARGDB, 0)    
      ENDIF 
*                                                             END DBRZIN    
  999 END   
      SUBROUTINE DBSBLC (PATHN, PATH, NCHAR)    
*     ======================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBSBLC (PATHN, PATH*, NCHAR*)                           *    
*                                                                      *    
*   Suppresses the blank characters in a string                        *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Input character string                                  *    
*     PATH(*)  Output character string with all blank characters       *    
*              removed                                                 *    
*     NCHAR(*) Number of non-blank characters in PATH                  *    
*                                                                      *    
*   Called by various routines in the DBL3 package                     *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      CHARACTER       PATHN*(*), PATH*(*)   
*   
*     ------------------------------------------------------------------    
*   
* *** Suppress blanks from the path name    
*   
      MAXL   = MIN (MAXLDB, LEN (PATHN)) + 1    
      NCHAR  = 0    
      ISWT   = 0    
      DO 10 I = 1, MAXL 
        LBLK   = 1  
        IF (I.EQ.MAXL) GO TO 5  
        IF (PATHN(I:I).NE.' ') LBLK = 0 
        IF (ISWT.EQ.0.AND.LBLK.EQ.0) THEN   
          ISWT   = 1    
          I11    = I    
        ENDIF   
    5   IF (ISWT.NE.0.AND.LBLK.NE.0) THEN   
          IF (NCHAR.EQ.0) THEN  
            PATH   = PATHN(I11:I-1) 
            NCHAR  = I - I11    
          ELSE  
            PATH   = PATH(1:NCHAR)//PATHN(I11:I-1)  
            NCHAR  = NCHAR + I - I11    
          ENDIF 
          ISWT   = 0    
        ENDIF   
   10 CONTINUE  
      IF (NCHAR.EQ.0) PATH   = ' '  
*                                                             END DBSBLC    
      END   
      SUBROUTINE DBSDIR (PATHN, NWKEY, CHFOR, CHTAG, MXKP, IOPP, IOPS)  
*     ================================================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBSDIR (PATHN, NWKEY, CHFOR, CHTAG, MXKP, IOPP*, IOPS*) *    
*                                                                      *    
*   Saves the directory creation information in the Journal file.      *    
*   It creates a single header record (with zero data) for each entry. *    
*   The header contains Action Code (2), Number of keys, numbers of    *    
*   charcaters for option and pathname, MXKP, followed by Character    *    
*   option, CHFOR, CHTAG and the pathname                              *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     NWKEY    Number of key elements                                  *    
*     CHFOR    Character variable describing each element of the key   *    
*              vector                                                  *    
*     CHTAG    Character array defined as CHARACTER*8 (NWKEY)          *    
*     MXKP     Maximum number of objects in each partition             *    
*              (0 means non-partitioned directories)                   *    
*     IOPP(*)  Server option (0 means standalone or Server)            *    
*     IOPS(*)  Shared option (0 means standalone)                      *    
*                                                                      *    
*   Called by DBMDIP, DBMDIR                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 49 : FZOUT fails to write on the sequential file     *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       CTAG*8, TOPN*16, PATHN*(*), CHFOR*(*), PATH*80    
      CHARACTER*(*)   CHTAG(*)  
*   
*     ------------------------------------------------------------------    
*   
* *** Find the logical unit number of the Journal file  
*   
      KEY7   = KEY7DK   
      KEY7DK = 0    
      NCHR   = LEN (PATHN)  
      IF (NCHR.GT.MAXLDB) NCHR = MAXLDB 
      I1     = 0    
      I11    = 0    
      I2     = 0    
      NCH    = NCHR 
      DO 10 I0 = 1, NCHR    
        IF (PATHN(I0:I0).EQ.' ') THEN   
          NCH    = I0 - 1   
          GO TO 15  
        ENDIF   
        IF (I2.GT.0)        GO TO 10    
        IF (PATHN(I0:I0).EQ.'/') THEN   
          I2     = I1   
          IF (I1.GT.0) TOPN = PATHN(I11:I0-1)   
        ELSE    
          IF (I1.EQ.0) I11  = I0    
          I1     = I1 + 1   
        ENDIF   
   10 CONTINUE  
*   
   15 LTOP   = LTOPDB   
      IOPS   = 0    
      IOUT   = 0    
   20 IF (LTOP.NE.0) THEN   
        NCHT   = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHT)    
        TOPNDI = TOPNDI(1:NCHT) 
        IF (TOPN.EQ.TOPNDI) THEN    
          LUFZDF = IQ(KOFUDB+LTOP+MUPJFL)   
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)  
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)   
        ELSE    
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 20  
        ENDIF   
      ELSE  
        LUFZDF = 0  
      ENDIF 
      IF (IOUT.EQ.0) IOPS = 0   
*   
      IF (LUFZDF.GT.0) THEN 
*   
*  **   Prepare the header containing all the information   
*   
        NCHD   = (NCH + 3) / 4  
        CALL MZIOCH (IOFMDF, NWFMDF, '7I -H')   
        IHEADF(MACTDF) = 2  
        IHEADF(MNKYDF) = NWKEY  
        IHEADF(MPATDF) = NCHD   
        IF (MXKP.GT.0) THEN 
          IHEADF(MOPTDF) = 1    
          IHEADF(MXKPDF) = MXKP 
          CALL UCTOH ('P   ', IHEADF(MRECDF+1), 4, 4)   
        ELSE    
          IHEADF(MOPTDF) = 0    
          IHEADF(MXKPDF) = 0    
        ENDIF   
        IF (KEY7.LE.0) THEN 
          CALL DATIME (IDATE, ITIME)    
          CALL DBPKTM (IDATE, ITIME, KEY7)  
        ENDIF   
        IHEADF(MINSDF) = KEY7   
        IHEADF(MRECDF) = 0  
        NCFO   = (NWKEY + 3) / 4    
        NPNT   = IHEADF(MOPTDF) + MRECDF + 1    
        CALL UCTOH (CHFOR, IHEADF(NPNT), 4, NWKEY)  
        NPNT   = NPNT + NCFO    
        DO 30 I = 1, NWKEY  
          CTAG   = CHTAG(I) 
          CALL UCTOH (CTAG, IHEADF(NPNT), 4, 8) 
          NPNT   = NPNT + 2 
   30   CONTINUE    
        CALL UCTOH (PATHN, IHEADF(NPNT), 4, 4*NCHD) 
        NWDH   = NPNT + NCHD - 1    
*   
*  **   Now write on the sequential output  
*   
        CALL FZOUT (LUFZDF, IDIVDB, 0, 1, 'Z', IOFMDF, NWDH, IHEADF)    
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1) = 49    
          IF (IDEBDB.GT.0) THEN 
            PATH   = PATHN  
            CALL DBPRNT (LPRTDB, '(/,'' DBSDIR : FZOUT error for path'//    
     +           ' name '//PATH//''')', IARGDB, 0)  
          ENDIF 
          GO TO 999 
        ENDIF   
      ENDIF 
*   
      IQUEST(1) = 0 
*                                                             END DBSDIR    
  999 END   
      SUBROUTINE DBSEKY (ITIME, KEY)    
*     ==============================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBSEKY (ITIME, KEY)                                     *    
*                                                                      *    
*   Select on the values of key elements                               *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     ITIME    Time for which data are required to be valid            *    
*     KEY      Vector of keys (on the basis of which selection is to   *    
*              be made)                                                *    
*                                                                      *    
*   Called by DBKXIN                                                   *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DTKXIN/ ICURDT, IDNRDT, IKYLDT, IMINDT, INRSDT, IPRVDT    
     +              , IUSEDT, KEY6DT, KY6NDT, MNKYDT, NTIMDT    
*   
      DIMENSION       KEY(9)    
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
* *** Look at all the keys in the subdirectory  
*   
      IF (IOPSDA.NE.0) THEN 
        IPNT   = KOFSDB + LCDRDB + IKDRDB   
        ISTP   = NWKYDK + 1 
        KPNT   = IUHUNT (KEY(MSERDB), IQ(IPNT+MSERDB), NKEYDK*ISTP,ISTP)    
        IF (KPNT.GT.0) THEN 
          IK     = (KPNT - MSERDB)/ ISTP + 1    
        ELSE    
          GO TO 999 
        ENDIF   
        CALL DBKEYR (IK, NWKYDK, KEYNDK)    
        NTIMDT = NTIMDT + 1 
        KEY1DK(NTIMDT) = KEYNDK(MSERDB) 
        IF (MNKYDT.LE.KEYNDK(MSERDB))  THEN 
          IKYLDT = IK   
          MNKYDT = KEYNDK(MSERDB)   
          KEY6DT = KEYNDK(MFLGDB)   
        ENDIF   
*   
      ELSE  
*   
        DO 20 IK = 1, NKEYDK    
          CALL DBKEYR (IK, NWKYDK, KEYNDK)  
*   
          IF (IPRVDT.NE.0 .AND. IPRVDT.NE.KEYNDK(MPVSDB))   GO TO 20    
          IF (IOKYDA(MITMDB).NE.0 .AND. KEY(MITMDB).LT.KEYNDK(MITMDB))  
     +                                                      GO TO 20    
          IF (KY7MDB.GT.0  .AND. KY7MDB.LT.KEYNDK(MITMDB))  GO TO 20    
*   
          IF (NWKYDK.GT.NSYSDK)  THEN   
            DO 10 J = NSYSDK+1, NWKYDK  
              IF (IOKYDA(J).NE.0. AND. KEY(J).NE.KEYNDK(J)) GO TO 20    
   10       CONTINUE    
          ENDIF 
*   
          ICLOS  = MIN0 (IABS(ITIME-KEYNDK(MBVRDB)),    
     +                   IABS(ITIME-KEYNDK(MEVRDB)))    
          IF (ICLOS.LT.INRSDT.AND.JBIT(KEYNDK(MFLGDB),JIGNDB).NE.0) THEN    
            IDNRDT = IK 
            INRSDT = ICLOS  
            IUSEDT = ICURDT 
          ENDIF 
*   
          IF ((ITIME.GE.KEYNDK(MBVRDB).AND.ITIME.LE.KEYNDK(MEVRDB)).OR. 
     +        (KEY(MEVRDB).LE.KEYNDK(MEVRDB).AND.IOKYDA(MEVRDB).NE.0)   
     +    .OR.(KEY(MBVRDB).GE.KEYNDK(MBVRDB).AND.IOKYDA(MBVRDB).NE.0))  
     +                                                              THEN    
            NTIMDT = NTIMDT + 1 
            KEY1DK(NTIMDT) = KEYNDK(MSERDB) 
            IF (MNKYDT.LE.KEYNDK(MSERDB))  THEN 
              IKYLDT = IK   
              MNKYDT = KEYNDK(MSERDB)   
              KEY6DT = KEYNDK(MFLGDB)   
              IF (JBIT(KEY6DT,JIGNDB).EQ.0) KY6NDT = IK 
            ENDIF   
          ELSE IF (ITIME.LT.KEYNDK(MBVRDB)) THEN    
            IF (KY4MDB.GT.KEYNDK(MBVRDB)) KY4MDB = KEYNDK(MBVRDB)   
          ENDIF 
   20   CONTINUE    
      ENDIF 
*                                                             END DBSEKY    
  999 END   
      SUBROUTINE DBSNAM (IFLG, KEYS, LBK, TOPN, LUNFZ)  
*     ================================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBSNAM (IFLG, KEYS, LBK, TOPN, LUNFZ)                   *    
*                                                                      *    
*   Saves the help file or name of the data objects in the journal     *    
*   file or/and in the data base. The data part contains the encoded   *    
*   data and the header contains Action code (6), number of keys,      *    
*   number of characters for option (0) and pathname, followed by the  *    
*   flag (1 for help file; 2 for data names), the keys and the path    *    
*   name.                                                              *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IFLG     Flag for help information(1) or name of data elements(2)*    
*     KEYS     Vector of keys                                          *    
*     LBK      Address of the data bank to be stored (or 0)            *    
*     TOPN     Name of the top directory                               *    
*     LUNFZ    Logical unit number of FZ file (or 0)                   *    
*                                                                      *    
*   Called by DBEHLP, DBENAM, DBFZUP                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =184 : Illegal flag (IFLAG)                            *    
*               =185 : Illegal top directory name                      *    
*               =186 : FZIN error for reading the data structure       *    
*               =187 : FZOUT fails to write on the sequential file     *    
*               =188 : Error in RZ for writing to the R.A. file        *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       PATHN*32, TOPN*(*), PATHL*80  
      DIMENSION       KEYO(MXDMDK), KEYS(9) 
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension iuhead(1)
*     ------------------------------------------------------------------    
*   
* *** Find the path name for storing the information    
*   
      LREFDB(2) = LBK
      PATHL  = ' '  
      NCH    = LENOCC (TOPN)    
      IF (IFLG.EQ.1) THEN   
        PATHN  = '//'//TOPN(1:NCH)//'/HELP' 
        NCHAR  = NCH + 7    
      ELSE IF (IFLG.EQ.2) THEN  
        PATHN  = '//'//TOPN(1:NCH)//'/DICTIONARY'   
        NCHAR  = NCH + 13   
      ELSE  
        IQUEST(1) = 184 
        IQUEST(11)= IFLG    
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBSNAM : Illgeal'//    
     +  ' flag '',I12)', IQUEST(11), 1) 
        GO TO 999   
      ENDIF 
*   
* *** Fill up the key vector    
*   
      IF (LUNFZ.GT.0) THEN  
        CALL UCOPY_i (KEYS(1), KEYNDK, NSYSDK)    
      ELSE  
        KEYNDK(MSERDB) = KEYS(MSERDB)   
        KEYNDK(MUPNDB) = 0  
        CALL DATIME (IDATE, ITIME)  
        CALL DBPKTS (IDATE, ITIME*100, KEYNDK(MBVRDB))  
        KEYNDK(MEVRDB) = IBIGDB 
        KEYNDK(MPVSDB) = 0  
        KEYNDK(MFLGDB) = 0  
        KEYNDK(MFLGDB) = MSBIT1 (KEYNDK(MFLGDB), JRZUDB)    
        IF (IFLG.EQ.1) KEYNDK(MFLGDB) = MSBIT1 (KEYNDK(MFLGDB), JASFDB) 
        CALL DBPKTM (IDATE, ITIME, KEYNDK(MITMDB))  
      ENDIF 
*   
* *** Find the logical unit number of the Journal file  
*   
      LTOP   = LTOPDB   
   10 IF (LTOP.NE.0) THEN   
        NCHT   = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHT)    
        IF (TOPN(1:NCH).EQ.TOPNDI(1:NCHT)) THEN 
          LUFZDF = IQ(KOFUDB+LTOP+MUPJFL)   
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)  
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)   
        ELSE    
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 10  
        ENDIF   
      ELSE  
        IQUEST(1) = 185 
        IF (IDEBDB.GT.0) THEN   
          TOPNDI = TOPN 
          CALL DBPRNT (LPRTDB, '(/,'' DBSNAM : Illegal top directory '//    
     +         'name '//TOPNDI//''')', IARGDB, 0)   
        ENDIF   
        GO TO 999   
      ENDIF 
      IF (IOUT.EQ.0) IOPS = 0   
*   
* *** Now get the bank (either supplied by user or from FZ file)    
*   
      IF (LUNFZ.EQ.0) THEN  
        LBDADB = LREFDB(2)  
      ELSE
        iuhead(1) = 0
        CALL FZIN (LUNFZ, IDISDB, LBDADB, 2, 'A', 0, iuhead) 
        IF (IQUEST(1).GT.0) THEN    
          IQUEST(1) = -1    
          GO TO 999 
        ELSE IF (IQUEST(1).NE.0) THEN   
          IQUEST(11)= IQUEST(1) 
          IQUEST(1) = 186   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBSNAM : FZIN '//    
     +    ' error type '',I12)', IQUEST(11), 1) 
          GO TO 999 
        ENDIF   
      ENDIF 
*   
      IF (LUFZDF.GT.0) THEN 
*   
*  **   Prepare the header containing all the information   
*   
        NCHD   = (NCHAR + 3) / 4    
        CALL MZIOCH (IOFMDF, NWFMDF, '12I -H')  
        IHEADF(MACTDF) = 6  
        IHEADF(MNKYDF) = NSYSDK 
        IHEADF(MOPTDF) = 0  
        IHEADF(MPATDF) = NCHD   
        IHEADF(MFLGDF) = IFLG   
        CALL UCOPY_i (KEYNDK, IHEADF(MFLGDF+1), NSYSDK)   
        NPNT   = NSYSDK + MFLGDF + 1    
        CALL UCTOH (PATHN, IHEADF(NPNT), 4, 4*NCHD) 
        NWDH   = NPNT + NCHD - 1    
*   
*  **   Now write on the sequential output  
*   
        CALL FZOUT (LUFZDF, IDISDB, LBDADB, 1, ' ', IOFMDF, NWDH,IHEADF)    
        IF (IQUEST(1).NE.0) THEN    
          IF (LUNFZ.NE.0) CALL MZDROP (IDISDB, LBDADB, 'L') 
          IQUEST(1) = 187   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBSNAM : FZOUT'//    
     +    ' error for path name '//PATHN//''')', IARGDB, 0) 
          GO TO 999 
        ENDIF   
      ENDIF 
*   
      IQUEST(1) = 0 
*   
* *** Enter the bank into data base 
*   
      ISTEP  = 1    
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0)   GO TO 900   
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      IF (IOPS.NE.0) THEN   
        CALL RZLOCK ('DBSNAM')  
        PATHL  = PATHN  
      ENDIF 
      CALL DBKEYT   
      ISTP   = NWKYDK + 1   
      ISTEP  = 2    
      KPNT   = IUHUNT (KEYNDK(MSERDB), IQ(KOFSDB+LCDRDB+IKDRDB+MSERDB), 
     +                 NKEYDK*ISTP, ISTP)   
      IF (KPNT.GT.0) THEN   
        IK     = (KPNT - MSERDB) / ISTP + 1 
        CALL DBKEYR (IK, NWKYDK, KEYO)  
        CALL RZDELK (KEYO, ICDUM, 'C')  
        IF (IQUEST(1).NE.0) GO TO 800   
      ENDIF 
      ISTEP  = 3    
      CALL RZOUT (IDISDB, LBDADB, KEYNDK, ICYCLE, 'S')  
*   
  800 IF (PATHL.NE.' ') THEN    
        IERR   = IQUEST(1)  
        CALL RZCDIR (PATHL, ' ')    
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        CALL RZFREE ('DBSNAM')  
        IQUEST(1) = IERR    
      ENDIF 
  900 IERR   = IQUEST(1)    
      IF (LUNFZ.NE.0) CALL MZDROP (IDISDB, LBDADB, 'L') 
      IF (IERR.NE.0) THEN   
        IQUEST(1) = 188 
        IQUEST(11)= ISTEP   
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBSNAM : RZ erro'//    
     +  'r in step '',I3,'' for path name '//PATHN//''')', IQUEST(11),1)    
      ENDIF 
*                                                             END DBSNAM    
  999 END   
      SUBROUTINE DBSOPN (LUN, CHOPT, CFNAM, NRECL, IOERR)   
*     ===================================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBSOPN (LUN, CHOPT, CFNAM, NRECL, IOERR*)               *    
*                                                                      *    
*   Opens a sequential FZ file                                         *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUN      Logical unit number                                     *    
*     CHOPT    Character string with any of the following characters   *    
*          A   ASCII file format                                       *    
*          O   Output file (default is input)                          *    
*          X   Exchange binary format                                  *    
*          Z   File to be overwritten if exists                        *    
*     CFNAM    File name                                               *    
*     NRECL    Record length in bytes                                  *    
*     IOERR    Error code (0 if no error)                              *    
*                                                                      *    
*   Called by DBEXAMn                                                  *    
*                                                                      *    
************************************************************************    
*   
      DIMENSION       IOPT(5)   
      CHARACTER       CHOPT*(*), CFNAM*(*), NAME*80, STATE*10, FORMT*12 
      CHARACTER       CHOP*8    
      EQUIVALENCE     (IOPTA, IOPT(1)), (IOPTI, IOPT(2))    
     +              , (IOPTO, IOPT(3)), (IOPTX, IOPT(4))    
     +              , (IOPTZ, IOPT(5))  
*   
*     ------------------------------------------------------------------    
*   
* *** Access the file name, etc.    
*   
      NCH    = LENOCC (CFNAM)   
      IF (NCH.LT.1)          GO TO 999  
      NCHM   = MIN (50, NCH)    
      NAME   = CFNAM    
*   
* *** Analyse the option    
*   
      CALL UOPTC  (CHOPT, 'AIOXZ', IOPT)    
*   
* *** Decide on the record length   
*   
      IF (NRECL.GT.0) THEN  
        NREC   = NRECL  
      ELSE IF (IOPTX.NE.0) THEN 
        NREC   = 3600   
      ELSE IF (IOPTA.NE.0) THEN 
        NREC   = 80 
      ELSE  
        NREC   = 10000  
      ENDIF 
      CHOP   = CHOPT    
*   
* *** Decide on state and form  
*   
      IF (IOPTO.EQ.0) THEN  
        STATE  = 'OLD'  
      ELSE  
        IF (IOPTZ.EQ.0) THEN    
          STATE  = 'NEW'    
        ELSE    
          STATE  = 'UNKNOWN'    
        ENDIF   
      ENDIF 
      IF (IOPTA.NE.0) THEN  
        FORMT = 'FORMATTED' 
      ELSE  
        FORMT = 'UNFORMATTED'   
      ENDIF 
*   
* *** Now open the file 
*   
      IF (STATE.EQ.'OLD') THEN  
C&IF LINUX
C&        OPEN (UNIT=LUN, FILE=NAME, FORM=FORMT, STATUS=STATE,    
C&     +        ERR=50, IOSTAT=IOERR)   
C&ELSE
        OPEN (UNIT=LUN, FILE=NAME, FORM=FORMT, STATUS=STATE,    
     +        READONLY, SHARED, ERR=50, IOSTAT=IOERR)   
C&ENDIF
      ELSE IF (IOPTX.NE.0) THEN 
C&IF LINUX
C&        OPEN (UNIT=LUN, FILE=NAME, FORM=FORMT, STATUS=STATE,    
C&     +        RECL=LREC, ERR=50,    
C&     +        IOSTAT=IOERR) 
C&ELSE
        OPEN (UNIT=LUN, FILE=NAME, FORM=FORMT, STATUS=STATE,    
     +        RECORDTYPE='FIXED', RECL=LREC, BLOCKSIZE=NREC, ERR=50,    
     +        IOSTAT=IOERR) 
C&ENDIF
      ELSE  
        OPEN (UNIT=LUN, FILE=NAME, FORM=FORMT, STATUS='UNKNOWN',    
     +        RECL=NREC, ERR=50, IOSTAT=IOERR)  
      ENDIF 
      IOPT(1) = LUN 
      IOPT(2) = NREC    
      CALL DBPRNT (6, '('' DBSOPN : '//NAME(1:NCHM)//' opened on Unit'//    
     +     ' '',I4,'' with RECL '',I8)', IOPT, 2)   
*   
      CALL FZFILE (LUN, LREC, CHOP) 
      GO TO 999 
*   
   50 IOPT(1) = IOERR   
      IOPT(2) = LUN 
      CALL DBPRNT (6, '('' DBSOPN Error : IOSTAT = '',I11,'' in openi'//    
     +     'ng '//NAME(1:NCHM)//' on unit '',I4)', IOPT, 2) 
*                                                             END DBSOPN    
  999 END   
      SUBROUTINE DBSPUR (PATHN, NWKEY, ITIME, KEYS, CHOPT, IOPP, IOPS)  
*     ================================================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBSPUR (PATHN, NWKEY, ITIME, KEYS, CHOPT, IOPP*, IOPS*) *    
*                                                                      *    
*   Saves the object purging information in the Journal file.          *    
*   It creates a single header record (with zero data) for each entry. *    
*   The header contains Action Code (3), Number of keys, numbers of    *    
*   charcaters for option and pathname, ITIME, current time (like Key  *    
*   7), followed by KEYS, Character option and the pathname.           *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     NWKEY    Number of key elements                                  *    
*     ITIME    Flag (If > 0, ITIME value as indicated in DBPURK, or    *    
*              < 0, a call from DBPURG)                                *    
*     KEYS     Vector of keys, if called from DBPURK                   *    
*              Vector containing KYDAT, KYTIM, if called from DBPURG   *    
*     CHOPT    Character option as used in the calls to DBPURG/DBPURK  *    
*     IOPP(*)  Server option (0 means standalone or Server)            *    
*     IOPS(*)  Shared option (0 means standalone)                      *    
*                                                                      *    
*   Called by DBPURG, DBPURK                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =115 : Cannot form the IO descriptor for the FZ header *    
*               =116 : FZOUT fails to write on the sequential file     *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)    
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)  
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)  
      PARAMETER       (NHEADF=300, NWFMDF=16)   
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF    
     +              , NWHEDF    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NLEVM=20)    
      CHARACTER       CHCUR(NLEVM)*1, CHFOR*100, CFORM(6)*1 
      CHARACTER       CHOP*80, TOPN*16, PATHN*(*), CHOPT*(*)    
      DIMENSION       KEYS(*), NLCUR(NLEVM) 
      DATA            CFORM /'B', 'I', 'F', 'D', 'H', 'A'/  
*   
*     ------------------------------------------------------------------    
*   
* *** Find the logical unit number of the Journal file  
*   
      KEY7   = KEY7DK   
      KEY7DK = 0    
      NCH    = INDEX (PATHN, ' ') - 1   
      I1     = 0    
      I11    = 0    
      DO 10 I0 = 1, NCH 
        IF (PATHN(I0:I0).EQ.'/'.OR.PATHN(I0:I0).EQ.' ') THEN    
          IF (I1.GT.0) THEN 
            TOPN   = PATHN(I11:I0-1)    
            GO TO 15    
          ENDIF 
          IF (PATHN(I0:I0).EQ.' ') GO TO 15 
        ELSE    
          IF (I1.EQ.0) I11 = I0 
          I1     = I1 +1    
        ENDIF   
   10 CONTINUE  
*   
   15 LTOP   = LTOPDB   
      IOPS   = 0    
      IOUT   = 0    
   20 IF (LTOP.NE.0) THEN   
        NCHT   = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHT)    
        TOPNDI = TOPNDI(1:NCHT) 
        IF (TOPN.EQ.TOPNDI) THEN    
          IF (IOPBDA.EQ.0) THEN 
            LUFZDF = IQ(KOFUDB+LTOP+MUPJFL) 
          ELSE  
            LUFZDF = IQ(KOFUDB+LTOP+MUPBAK) 
          ENDIF 
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)  
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)   
        ELSE    
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 20  
        ENDIF   
      ELSE  
        LUFZDF = 0  
      ENDIF 
      IF (IOUT.EQ.0) IOPS = 0   
*   
      IF (LUFZDF.GT.0) THEN 
*   
*  **   Prepare the header containing all the information   
*   
        NCHD   = (NCH + 3) / 4  
        IHEADF(MACTDF) = 3  
        IHEADF(MNKYDF) = NWKEY  
        IHEADF(MPATDF) = NCHD   
        IF (ITIME.GT.0) THEN    
          IHEADF(MTIMDF) = ITIME    
          IFLAG          = 1    
        ELSE    
          IHEADF(MTIMDF) = -1   
          IFLAG          = 0    
        ENDIF   
        IF (KEY7.GT.0) THEN 
          IHEADF(MINSDF) = KEY7 
        ELSE    
          CALL DATIME (IDATX, ITIMX)    
          CALL DBPKTM (IDATX, ITIMX, IHEADF(MINSDF))    
        ENDIF   
        NCHP   = LEN (CHOPT)    
        IF (NCHP.GT.MAXLDB) NCHP = MAXLDB   
        NCHOP  = 0  
        DO 25 I = 1, NCHP   
          IF (CHOPT(I:I).NE.' ') THEN   
            IF (NCHOP.EQ.0) THEN    
              CHOP   = CHOPT(I:I)   
            ELSE    
              CHOP   = CHOP(1:NCHOP)//CHOPT(I:I)    
            ENDIF   
            NCHOP  = NCHOP + 1  
          ENDIF 
   25   CONTINUE    
        NWDOP  = (NCHOP + 3) / 4    
        NPNT   = NWKEY + MINSDF + 1 
        IHEADF(MOPTDF) = NWDOP  
        IF (NWDOP.GT.0) CALL UCTOH (CHOP, IHEADF(NPNT), 4, 4*NWDOP) 
        NPNT   = NPNT + NWDOP   
        CALL UCTOH (PATHN, IHEADF(NPNT), 4, 4*NCHD) 
        NWDH   = NPNT + NCHD - 1    
*   
*  **   Get the IO format for the header    
*   
        NLEV   = 1  
        NCUR   = 6  
        IFORO  = 2  
        CHCUR(NLEV) = CFORM(IFORO)  
        DO 30 I = 1, NWKEY  
          IFORM  = IOTYDK(I)    
          IF (IFORM.EQ.6) IFORM = 5 
          IF (IFORM.EQ.IFORO) THEN  
            NCUR   = NCUR + 1   
          ELSE  
            NLCUR(NLEV) = NCUR  
            IF (NLEV.GE.NLEVM) THEN 
              IQUEST(1) = 115   
              IF (IDEBDB.GT.0) THEN 
                CHFOR  = PATHN  
                CALL DBPRNT (LPRTDB, '(/,'' DBSPUR : Cannot form IO '// 
     +               'descriptor '//CHFOR(1:80)//''')', IARGDB, 0)  
              ENDIF 
              GO TO 999 
            ENDIF   
            NLEV   = NLEV + 1   
            CHCUR(NLEV) = CFORM(IFORM)  
            NCUR   = 1  
            IFORO  = IFORM  
          ENDIF 
          IF (IFLAG.NE.0) THEN  
            IHEADF(MINSDF+I) = KEYS(I)  
          ELSE  
            IF (I.LE.NSYSDK) THEN   
              IHEADF(MINSDF+I) = KEYS(I)    
            ELSE IF (IFORM.EQ.5) THEN   
              CALL UCTOH ('    ', IHEADF(MINSDF+I), 4, 4)   
            ELSE    
              IHEADF(MINSDF+I) = 0  
            ENDIF   
          ENDIF 
   30   CONTINUE    
        NLCUR(NLEV) = NCUR  
*   
        WRITE (CHFOR, 2001) (NLCUR(I), CHCUR(I), I = 1, NLEV)   
        II     = 4 *NLEV    
        CHFOR = CHFOR(1:II)//' -H'  
        CALL MZIOCH (IOFMDF, NWFMDF, CHFOR(1:II+3)) 
*   
*  **   Now write on the sequential output  
*   
        CALL FZOUT (LUFZDF, IDIVDB, 0, 1, 'Z', IOFMDF, NWDH, IHEADF)    
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1) = 116   
          IF (IDEBDB.GT.0) THEN 
            CHFOR  = PATHN  
            CALL DBPRNT (LPRTDB, '(/,'' DBSPUR : FZOUT error for path'//    
     +           ' name '//CHFOR(1:80)//''')', IARGDB, 0)   
          ENDIF 
          GO TO 999 
        ENDIF   
      ENDIF 
*   
      IQUEST(1) = 0 
*   
 2001 FORMAT (20(I2,A1,1X)) 
*                                                             END DBSPUR    
  999 END   
      SUBROUTINE DBTOPN (PATHN, TOPN, NCH)  
*     ====================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBTOPN (PATHN, TOPN*, NCH*)                             *    
*                                                                      *    
*   Extracts the top directory name from the path name                 *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     TOPN(*)  Name of the top directory                               *    
*     NCH(*)   Number of characters in TOPN                            *    
*                                                                      *    
*   Called by DBDONT                                                   *    
*                                                                      *    
************************************************************************    
*   
      CHARACTER       PATHN*(*), TOPN*(*)   
*   
*     ------------------------------------------------------------------    
*   
      NCTOT  = LENOCC (PATHN)   
      I1     = 0    
      I11    = 0    
      DO 10 I0 = 1, NCTOT   
        IF (PATHN(I0:I0).EQ.'/') THEN   
          IF (I1.GT.0) THEN 
            TOPN   = PATHN(I11:I0-1)    
            NCH    = I0 - I11   
            GO TO 15    
          ENDIF 
        ELSE    
          IF (I1.EQ.0) I11 = I0 
          I1     = I1 +1    
        ENDIF   
   10 CONTINUE  
      NCH    = 0    
      TOPN   = ' '  
   15 CONTINUE  
*                                                             END DBTOPN    
      END   
      SUBROUTINE DBTOUS (LC, IUDIV, LU, LSUP, JBIAS, IPREC) 
*     ===================================================== 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBTOUS (LC, IUDIV, LU*, LSUP, JBIAS, IPREC)             *    
*                                                                      *    
*   Copies Single Bank at LC from the Data Base system into Bank at LU *    
*   in the user division in the user system                            *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LC       Address of the bank to be copied                        *    
*     IUDIV    Division index of the user division                     *    
*     LU       Address of the copied bank                              *    
*     LSUP     Address of the supporting bank (see MZBOOK)             *    
*     JBIAS    Link Bias (see MZBOOK)                                  *    
*     IPREC    Signed precision word; the data are truncated after     *    
*              having multiplied by 10**IPREC                          *    
*                                                                      *    
*   Called by DBKXIN                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*
      dimension nio(9)
*     ------------------------------------------------------------------    
*   
      LREFDB(4) = LC
      NDU    = IQ(KOFUDB+LREFDB(4)-1) - 2   
      ITU    = IDBTYP (LREFDB(4))
      nio(1) = itu
      CALL DBBOOK (IUDIV, LU, LSUP, JBIAS, 'USER', 0, 0, NDU, nio,    
     +             0)   
      IF (IQUEST(1).NE.0) GO TO 999 
      IF (ITU.EQ.3) THEN    
        CALL UCOPY (Q(KOFUDB+LREFDB(4)+3), Q(KOFUDB+LU+1), NDU)  
        IPREC = Q(KOFUDB+LREFDB(4)+2)   
      ELSE  
        CALL UCOPY_i (IQ(KOFUDB+LREFDB(4)+3), IQ(KOFUDB+LU+1), NDU)    
        IPREC = IQ(KOFUDB+LREFDB(4)+2)  
      ENDIF 
*                                                             END DBTOUS    
  999 END   
      SUBROUTINE DBUCMP (LB, IADS)  
*     ============================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBUCMP (LB, IADS*)                                      *    
*                                                                      *    
*   Uncompresses data bank defined by LB in the Data Base              *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LB       Address of the bank to be uncompressed                  *    
*     IADS(*)  Address of the uncompressed bank as LAUXDL(IADS)        *    
*                                                                      *    
*   Called by DBUNCP                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 81 : Precision is not correctly given                *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension nio(9)
*     ------------------------------------------------------------------    
*   
      LREFDB(7) = LB
      NDI    = IQ(KOFUDB+LREFDB(7)-1) - 3   
      LB3    = LREFDB(7) + 3    
      NAU    = JBYT (IQ(KOFUDB+LB3), 1, 26) 
      LBITL  = JBYT (IQ(KOFUDB+LB3), 27, 5) 
      IVM    = IQ(KOFUDB+LREFDB(7)+2)   
      LB1    = LREFDB(7) + 1    
      NDO    = IQ(KOFUDB+LB1)/10000 
      IDT    = MOD (IQ(KOFUDB+LB1), 10000)  
      IPREC  = MOD (IDT, 1000)  
      IDT    = IDT/1000 
      IPREC  = IPREC - 100  
*   
      ND2    = NDO + 2  
      JBIAS  = 2
      nio(1) = 2
      CALL DBBOOK (IDISDB, LAUXDL(IADS), LAUXDL(IADS), JBIAS, 'AUX3', 0,    
     +             0, ND2, nio, 0)    
      IF (IQUEST(1).NE.0)              GO TO 999    
*   
      LAUX3  = LAUXDL(IADS) 
      LAU33  = LAUX3 + 3    
      CALL DBUPCK (IQ(KOFUDB+LREFDB(7)+4), NDI, NDO, NAU, LBITL,    
     +             IQ(KOFUDB+LAU33))    
*   
      LAU32  = KOFUDB + LAUX3 + 2   
      IF (IVM.GT.0) THEN    
        DO 10 I = 1, NDO    
          IQ(LAU32+I) = IQ(LAU32+I) - IVM   
   10   CONTINUE    
      ENDIF 
*   
* *** Precision 
*   
      IF (IPREC.LT.-99.OR.IPREC.GT.99) GO TO 991    
      IPR1   = 0    
      IPR2   = 0    
      IF (IPREC.GT.0) IPR2 = IPREC  
      IF (IPREC.LT.0) IPR1 = -IPREC 
*   
      IF (IDT.EQ.3) THEN    
        CALL VFLOAT (IQ(KOFUDB+LAU33), Q(KOFUDB+LAU33), NDO)    
        IF (IPR1.GT.0) THEN 
          XMULT  = 10.**IPR1    
          CALL VSCALE (Q(KOFUDB+LAU33), XMULT, Q(KOFUDB+LAU33), NDO)    
        ELSE IF (IPR2.GT.0) THEN    
          XMULT  = 1./10.**IPR2 
          CALL VSCALE (Q(KOFUDB+LAU33), XMULT, Q(KOFUDB+LAU33), NDO)    
        ENDIF   
*   
        JBIAS  = 2
        nio(1) = 3
        CALL DBBOOK (IDISDB, LAUXDL(IADS-1), LAUXDL(IADS-1), JBIAS, 
     +               'AUX4', 0, 0, ND2, nio, 0)   
        IF (IQUEST(1).NE.0)            GO TO 999    
        LAUX3  = LAUXDL(IADS)   
        LAU33  = LAUX3 + 3  
        LAUX4  = LAUXDL(IADS-1) 
        Q(KOFUDB+LAUX4+2) = IPREC   
        CALL UCOPY (Q(KOFUDB+LAU33), Q(KOFUDB+LAUX4+3), NDO)    
        CALL MZDROP (IDISDB, LAUX3, ' ')    
      ELSE IF (IDT.EQ.2 .OR. IDT.EQ.5)  THEN    
        IF (IPR1.GT.0) THEN 
          IMULT  = 10**IPR1 
          DO 20 I = 1, NDO  
            IQ(LAU32+I) = IQ(LAU32+I) * IMULT   
   20     CONTINUE  
        ELSE IF (IPR2.GT.0) THEN    
          XMULT  = 1./10**IPR2  
          DO 30 I = 1, NDO  
            IQ(LAU32+I) = IQ(LAU32+I) * XMULT   
   30     CONTINUE  
        ENDIF   
*   
        JBIAS  = 2
        nio(1) = idt
        CALL DBBOOK (IDISDB, LAUXDL(IADS-1), LAUXDL(IADS-1), JBIAS, 
     +               'AUX4', 0, 0, ND2, nio, 0) 
        IF (IQUEST(1).NE.0)            GO TO 999    
        LAUX3  = LAUXDL(IADS)   
        LAU33  = LAUX3 + 3  
        LAUX4  = LAUXDL(IADS-1) 
        IQ(KOFUDB+LAUX4+2) = IPREC  
        CALL UCOPY (Q(KOFUDB+LAU33), Q(KOFUDB+LAUX4+3), NDO)   
        CALL MZDROP (IDISDB, LAUX3, ' ')    
      ENDIF 
      GO TO 999 
*   
* *** Error Condition   
*   
  991 IQUEST(1) = 81    
      IQUEST(11)= IPREC 
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUCMP : Precision'//    
     +   ' is not correctly given -'',I8,'' no uncompression'')',   
     +   IQUEST(11), 1) 
      GO TO 999 
*                                                             END DBUCMP    
  999 END   
      SUBROUTINE DBUCMZ (LB, IADS)  
*     ============================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBUCMZ (LB, IADS*)                                      *    
*                                                                      *    
*   Uncompresses data bank defined by LB in the Data Base              *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LB       Address of the bank to be uncompressed                  *    
*     IADS(*)  Address of the uncompressed bank as LAUXDL(IADS)        *    
*                                                                      *    
*   Called by DBUNCP                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 82 : Illegal Data Type                               *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      COMMON /DZPACK/ PRECDZ, PACKDZ    
      LOGICAL         PACKDZ    
*   
      dimension nio(9)
*     ------------------------------------------------------------------    
*   
      LREFDB(7) = LB
      IDTYP  = IDBTYP (LREFDB(7))   
*   
      IF (IDTYP.EQ.3) THEN  
        NDI    = IQ(KOFUDB+LREFDB(7)-1) - 3 
        NDO    = Q(KOFUDB+LREFDB(7)+1)  
        PRECDZ = Q(KOFUDB+LREFDB(7)+2)  
        ND2    = NDO + 2    
        JBIAS  = 2
        nio(1) = idtyp
        CALL DBBOOK (IDISDB, LAUXDL(IADS), LAUXDL(IADS), JBIAS, 'AUX3', 
     +               0, 0, ND2, nio, 0)   
        IF (IQUEST(1).NE.0) GO TO 999   
        LAUX3  = LAUXDL(IADS)   
        LAU33  = LAUX3 + 3  
        IF (NDI.LE.0) THEN  
          CALL VZERO (Q(KOFUDB+LAU33), NDO) 
        ELSE    
          CALL DBUPFZ (Q(KOFUDB+LREFDB(7)+4), NDI, Q(KOFUDB+LAU33), NDO)    
        ENDIF   
      ELSE IF (IDTYP.EQ.2.OR.IDTYP.EQ.5) THEN   
        NDI    = IQ(KOFUDB+LREFDB(7)-1) - 3 
        NDO    = IQ(KOFUDB+LREFDB(7)+1) 
        PRECDZ = IQ(KOFUDB+LREFDB(7)+2) 
        ND2    = NDO + 2    
        JBIAS  = 2
        nio(1) = idtyp
        CALL DBBOOK (IDISDB, LAUXDL(IADS), LAUXDL(IADS), JBIAS, 'AUX3', 
     +               0, 0, ND2, nio, 0)   
        IF (IQUEST(1).NE.0) GO TO 999   
        LAUX3  = LAUXDL(IADS)   
        LAU33  = LAUX3 + 3  
        IF (NDI.LE.0) THEN  
          CALL VZERO_i (IQ(KOFUDB+LAU33), NDO)    
        ELSE    
          CALL DBUPIZ (IQ(KOFUDB+LREFDB(7)+4),NDI, IQ(KOFUDB+LAU33),NDO)    
        ENDIF   
      ELSE  
        GO TO 991   
      ENDIF 
      GO TO 999 
*   
* *** Error codes   
*   
  991 IQUEST(1) = 82    
      IQUEST(11)= IDTYP 
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUCMZ : Data-type'//    
     +   ' '',I4,'' illegal for uncompression'')', IQUEST(11), 1)   
      GO TO 999 
*                                                             END DBUCMZ    
  999 END   
      SUBROUTINE DBUDIC (LTOP)  
*     ========================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBUDIC (LTOP)                                           *    
*                                                                      *    
*   Updates the dictionary information if not yet available in the     *    
*   disk file                                                          *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LTOP     Address of the top directory                            *    
*                                                                      *    
*   Called by DBINIT                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =150 : Error in loading Top directory                  *    
*               =155 : Error in RZ for reading the dictionary object   *    
*               =157 : Error in RZ in writing the dictionary object    *    
*               =158 : Error in RZ in purging the dictionary directory *    
*               =159 : Error in creating the DICTIONARY/HELP directory *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NLEVM=20)    
      DIMENSION       KEYN(MXDMDK), NCHD(NLEVM), ISDI(NLEVM)    
      DIMENSION       NKEY(NLEVM), IOPT(NLEVM), NSDI(NLEVM) 
      DIMENSION       IHDIR(4)
      CHARACTER       PATHN*80, PATHX*16, PATHY*80, PATHF*80, PATHZ*16  
      CHARACTER       PATHD*80  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension nio(9)
*     ------------------------------------------------------------------    
*   
      LBNODB = LTOP
      JBIAS  = -KLDICT  
      NLEV   = 1    
      IOUT   = IQ(KOFUDB+LBNODB+MUPFLG) 
      IOPP   = MOD (IQ(KOFUDB+LBNODB+MUPSRV), 10)   
      IOPS   = MOD (IQ(KOFUDB+LBNODB+MUPSRV)/10, 10)    
      IF (IOPP.NE.0) IOUT = 0   
      NCHR   = IQ(KOFUDB+LBNODB+MUPNCH) 
      CALL UHTOC (IQ(KOFUDB+LBNODB+MUPNAM), 4, PATHZ, NCHR) 
      PATHZ  = PATHZ(1:NCHR)    
      PATHN  = '//'//PATHZ  
      NCHD(NLEV) = NCHR + 2 
      PATHD  = PATHN(1:NCHD(NLEV))//'/DICTIONARY'   
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 150 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUDIC : Illegal'//    
     +  ' top directory '//PATHN//''')', IARGDB, 0) 
        GO TO 999   
      ENDIF 
*   
* *** Create the help file if it does not exist 
*   
      IF (IOUT.NE.0) THEN   
        PATHY  = PATHN(1:NCHD(NLEV))//'/HELP'   
        CALL RZCDIR (PATHY, ' ')    
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1) = 0 
          CALL RZCDIR (PATHN, ' ')  
          IF (IOPS.NE.0) CALL RZLOCK ('DBUDIC') 
          CALL RZMDIR ('HELP', NSYSDK, CHFTDK, CHTGDK)  
          IERR   = IQUEST(1)    
          IF (IOPS.NE.0) THEN   
            CALL RZCDIR (PATHN, ' ')    
            CALL RZFREE ('DBUDIC')  
          ENDIF 
          IF (IERR.NE.0) THEN   
            IQUEST(1) = 159 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUDIC : RZM'//    
     +      'DIR error for path name '//PATHY//''')', IARGDB, 0)    
            GO TO 999   
          ENDIF 
        ENDIF   
      ENDIF 
*   
* *** Try to load the dictionary information if it exists   
*   
      CALL RZCDIR (PATHD, ' ')  
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 0   
        IF (IOUT.NE.0) THEN 
          CALL RZCDIR (PATHN, ' ')  
          IF (IOPS.NE.0) CALL RZLOCK ('DBUDIC') 
          CALL RZMDIR ('DICTIONARY', NSYSDK, CHFTDK, CHTGDK)    
          IERR   = IQUEST(1)    
          IF (IOPS.NE.0) THEN   
            CALL RZCDIR (PATHN, ' ')    
            CALL RZFREE ('DBUDIC')  
          ENDIF 
          IF (IERR.NE.0) THEN   
            IQUEST(1) = 159 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUDIC : RZM'//    
     +      'DIR error for path name '//PATHD//''')', IARGDB, 0)    
            GO TO 999   
          ENDIF 
        ENDIF   
        GO TO 5 
      ENDIF 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      ISTP   = NWKYDK + 1   
      IF (NKEYDK.GT.0) THEN 
        IPNT   = KOFSDB + LCDRDB + IKDRDB   
        IMIN   = IUHUNT (-1, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)    
        IF (IMIN.GT.0) THEN 
          IMIN   = (IMIN - MSERDB) / ISTP + 1   
          CALL DBKEYT   
          CALL DBKEYR (IMIN, NWKYDK, KEYN)  
          LFIXDB = LQ(KOFUDB+LBNODB+JBIAS)  
          IF (LFIXDB.NE.0) CALL MZDROP (IDIVDB, LFIXDB, ' ')    
          CALL DBRZIN (IDIVDB, LBNODB, JBIAS, IMIN, ICYCL, PATHD)   
          IF (IQUEST(1).EQ.0)          GO TO 999    
          IOUT   = 0    
        ENDIF   
      ENDIF 
*   
    5 KEYN(MSERDB) = -1 
      KEYN(MUPNDB) = 0  
      CALL DATIME (IDATE, ITIME)    
      CALL DBPKTS (IDATE, ITIME*100,  KEYN(MBVRDB)) 
      KEYN(MEVRDB) = IBIGDB 
      KEYN(MPVSDB) = 0  
      KEYN(MFLGDB) = 1  
      CALL DBPKTM (IDATE,  ITIME,  KEYN(MITMDB))    
      LFIXDB = LQ(KOFUDB+LBNODB+JBIAS)  
      IF (LFIXDB.NE.0) CALL MZDROP (IDIVDB, LFIXDB, ' ')    
      NDWD   = NPUSDB*NWITDB + 1
      nio(1) = iodidb
      CALL DBBOOK (IDIVDB, LFIXDB, LBNODB, JBIAS, 'DIDB', 0, 0, NDWD,   
     +             nio, 0)   
      IF (IQUEST(1).NE.0)              GO TO 999    
      NITEM  = 0    
      NKEEP  = NPUSDB   
      CALL RZCDIR (PATHN, ' ')  
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      IOPTP  = 0    
*   
* *** Now scan down to find all the subdirectories  
*   
   10 IF (NLEV.GT.1) THEN   
        PATHN  = PATHN(1:NCHD(NLEV-1))//'/'//PATHX  
        NCHD(NLEV) = NCHD(NLEV-1) + NCHR + 1    
        CALL RZCDIR (PATHN, ' ')    
        NKEYDK = IQUEST(7)  
        NWKYDK = IQUEST(8)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        IF (NKEYDK.GT.0) THEN   
          IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)   
        ELSE    
          IOPTP  = 0    
        ENDIF   
      ENDIF 
      NKEY(NLEV) = NKEYDK   
      IOPT(NLEV) = IOPTP    
      ISDI(NLEV) = 0    
      NSDI(NLEV) = IQ(KOFSDB+LCDRDB+KNSDDB) 
*   
   20 ISDI(NLEV) = ISDI(NLEV) + 1   
      IF (ISDI(NLEV).LE.NSDI(NLEV)) THEN    
*   
*  **   If a new subdirectory go down one level 
*   
        LS    = IQ(KOFSDB+LCDRDB+KLSDDB)    
        IPNT  = LS + 7 * (ISDI(NLEV) - 1)   
        CALL ZITOH (IQ(KOFSDB+LCDRDB+IPNT), IHDIR, 4)   
        CALL UHTOC (IHDIR, 4, PATHX, 16)    
        NCHR  = INDEX (PATHX, ' ') - 1  
        IF (NCHR.LE.0.OR.NCHR.GT.16) NCHR = 16  
        IF (IOPTP.NE.0) THEN    
          DO 35 IK = 1, NKEYDK  
            KK     = IK 
            IDIG   = 0  
   30       IF (KK.GT.0) THEN   
              KK     = KK / 10  
              IDIG   = IDIG + 1 
              GO TO 30  
            ENDIF   
            IF (NCHR.EQ.IDIG) THEN  
              WRITE (PATHY, '(I8)') IK  
              I1     = 8 - IDIG + 1 
              PATHZ  = PATHY(I1:8)  
              IF (PATHZ.EQ.PATHX)      GO TO 20 
            ENDIF   
   35     CONTINUE  
        ELSE IF (NLEV.EQ.1) THEN    
          IF (NCHR.EQ.10) THEN  
            IF (PATHX.EQ.'DICTIONARY') GO TO 20 
          ENDIF 
        ENDIF   
        NLEV   = NLEV +1    
        GO TO 10    
*   
      ELSE  
*   
*  **   Check if the name is to be entered  
*   
        IF (NLEV.EQ.1)                 GO TO 60 
        IF (NLEV.EQ.2) THEN 
          IF ((NCHD(2)-NCHD(1)-1).EQ.10) THEN   
            PATHZ  = PATHN(NCHD(1)+2:NCHD(2))   
            IF (PATHZ.EQ.'DICTIONARY') GO TO 50 
          ENDIF 
        ENDIF   
        PATHY  = PATHN(NCHD(1)+1:NCHD(NLEV))    
        NCHR   = NCHD(NLEV) - NCHD(1)   
        NFREE  = 0  
        IF (NITEM.GT.0) THEN    
          DO 40 I = 1, NITEM    
            IPNT   = KOFUDB + LFIXDB + (I - 1) * NWITDB + 1 
            NCHF   = IQ(IPNT+MDCNCH)    
            IF (IQ(IPNT+MDCITM).GT.0) THEN  
              IF (NCHR.EQ.NCHF) THEN    
                CALL UHTOC (IQ(IPNT+MDCNAM), 4, PATHF, NCHF)    
                PATHF  = PATHF(1:NCHF)  
                IF (PATHY.EQ.PATHF)    GO TO 50 
              ENDIF 
            ELSE    
              IF (NFREE.EQ.0) NFREE = I 
            ENDIF   
   40     CONTINUE  
        ENDIF   
*   
*  **   Enter the new path name in the dictionary   
*   
        IF (NFREE.EQ.0) THEN    
          NITEM  = NITEM + 1    
          NFREE  = NITEM    
          IF (NITEM.GT.NKEEP) THEN  
            CALL ZSHUNT (IDIVDB, LFIXDB, LBDADB, 2, 0)  
            LBDADB = LFIXDB 
            LFIXDB = 0  
            ND     = NDWD + NPUSDB * NWITDB
            nio(1) = IODIDB
            CALL DBBOOK (IDIVDB, LFIXDB, LBNODB, JBIAS, 'DIDB', 0, 0,   
     +                   ND, nio, -1)    
            IF (IQUEST(1).NE.0) THEN    
              IERR   = IQUEST(1)    
              CALL MZDROP (IDIVDB, LBDADB, ' ') 
              IQUEST(1) = IERR  
               GO TO 999    
            ENDIF   
            CALL UCOPY_i (IQ(KOFUDB+LBDADB+1), IQ(KOFUDB+LFIXDB+1),
     &           NDWD) 
            CALL MZDROP (IDIVDB, LBDADB, ' ')   
            NDWD   = IQ(KOFUDB+LFIXDB-1)    
            NKEEP  = NKEEP + NPUSDB 
          ENDIF 
          IQ(KOFUDB+LFIXDB+MDCNTM) = NITEM  
        ENDIF   
        IPNT   = KOFUDB + LFIXDB + (NFREE - 1) * NWITDB + 1 
        IQ(IPNT+MDCITM) = NFREE 
        IQ(IPNT+MDCNCH) = NCHR  
        IQ(IPNT+MDCLUP) = 0 
        CALL UCTOH ('        ', IQ(IPNT+MDCALI), 4, 8)  
        CALL UCTOH (PATHY, IQ(IPNT+MDCNAM), 4, NCHR)    
*   
   50   NLEV   = NLEV - 1   
        IF (NLEV.GE.1) THEN 
          LUP    = LQ(KOFSDB+LCDRDB+1)  
          CALL MZDROP (0, LCDRDB, ' ')  
          LCDRDB = LUP  
          NKEYDK = NKEY(NLEV)   
          IOPTP  = IOPT(NLEV)   
          GO TO 20  
        ENDIF   
      ENDIF 
*   
   60 CONTINUE  
*   
* *** All subdirectories looked at; now store dictionary if permitted   
*   
      IF (IOUT.NE.0) THEN   
        CALL RZCDIR (PATHD, ' ')    
        IF (IOPS.NE.0) CALL RZLOCK ('DBUDIC')   
        CALL RZOUT (IDIVDB, LFIXDB, KEYN, ICYCLE, 'S')  
        IERR   = IQUEST(1)  
        IF (IERR.NE.0) THEN 
          IF (IOPS.NE.0) CALL RZFREE ('DBUDIC') 
          IQUEST(1) = 157   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUDIC : RZOUT'//    
     +    ' error for path name '//PATHD//''')', IARGDB, 0) 
          GO TO 999 
        ENDIF   
        CALL RZPURG (0) 
        IERR   = IQUEST(1)  
        IF (IOPS.NE.0) CALL RZFREE ('DBUDIC')   
        IF (IERR.NE.0) THEN 
          IQUEST(1) = 158   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUDIC : RZPUR'//    
     +    'G error for path name '//PATHD//''')', IARGDB, 0)    
          GO TO 999 
        ENDIF   
      ENDIF 
*   
  100 IQUEST(1) = 0 
*                                                             END DBUDIC    
  999 END   
      SUBROUTINE DBUNCP (LC, LU, IK)    
*     ==============================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBUNCP (LC, LU*, IK)                                    *    
*                                                                      *    
*   Uncompresses data bank defined by LC in the Data Base              *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LC       Address of the bank to be uncompressed                  *    
*     LU       Address of the uncompressed bank                        *    
*     IK       If nonzero the Key 1 of the master bank with reference  *    
*              to which the bank is to be updated                      *    
*                                                                      *    
*   Called by DBCOMP, DBKXIN                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               = 83 : Data update but uncompreseed                    *    
*               = 84 : The update structure has different number of    *    
*                      data words                                      *    
*               = 85 : No data in the structure                        *    
*               = 86 : The update structure has different data type    *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      COMMON /DZPACK/ PRECDZ, PACKDZ    
      LOGICAL         PACKDZ    
*   
      DIMENSION       KEY(NINEDK) 
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension nio(9)
*     ------------------------------------------------------------------    
*   
      LREFDB(5) = LC 
      ITU    = IDBTYP (LREFDB(5))   
*   
* *** Data uncompressed ?   
*   
      NWKEY  = MIN (NWKYDK, NINEDK) 
      IF (IQ(KOFUDB+LREFDB(5)+1).EQ.0) THEN 
        IF (IK.NE.0)        GO TO 991   
        NDU    = IQ(KOFUDB+LREFDB(5)-1) 
        JBIAS  = 2
        nio(1) = itu
        CALL DBBOOK (IDISDB, LU, LU, JBIAS, 'SAME', 0, 0, NDU,    
     +               nio, 0)    
        IF (IQUEST(1).NE.0) GO TO 999   
        IF (ITU.EQ.3)  THEN 
          CALL UCOPY (Q(KOFUDB+LREFDB(5)+1), Q(KOFUDB+LU+1), NDU)    
        ELSE    
          CALL UCOPY_i (IQ(KOFUDB+LREFDB(5)+1), IQ(KOFUDB+LU+1), NDU)  
        ENDIF   
        GO TO 999   
      ENDIF 
*   
* *** Uncompress data   
* *** Which packing mode ?  
*
      ixx = iQ(KOFUDB+LREFDB(5)+3)
      PACKDZ = (JBIT (IXX, 32)) .EQ. 0  
*   
      IADS   = 5    
*   
      IF (PACKDZ) THEN  
        CALL DBUCMZ (LREFDB(5), IADS)   
        LU = LAUXDL(IADS)    
      ELSE  
        CALL DBUCMP (LREFDB(5), IADS)   
        LU = LAUXDL(IADS-1)  
      ENDIF 
      IF (IQUEST(1).NE.0)   GO TO 999   
*   
      IF (IK.EQ.0)          GO TO 999   
      IF (NKEYDK.EQ.0)      GO TO 999   
*   
      CALL MZDROP (IDISDB, LREFDB(5), ' ')  
*   
      LREFDB(5) = 0 
      LREFDB(6) = LU 
      LC     = 0 
      JBIAS  = 2    
      CALL DBRZIN (IDISDB, LREFDB(5), JBIAS, IK, ICYCL, ' ')    
      IF (IQUEST(1).NE.0)   GO TO 999   
      LC     = LREFDB(5) 
      CALL DBKEYR (IK, NWKEY, KEY)  
   10 LCC    = LREFDB(5)    
*   
* *** Uncompress master ?   
*   
      IF (IQ(KOFUDB+LREFDB(5)+1).NE.0) THEN 
        IADS   = 5  
        IF (PACKDZ) THEN    
          CALL DBUCMZ (LREFDB(5), IADS) 
          LCC    = LAUXDL(IADS) 
        ELSE    
          CALL DBUCMP (LREFDB(5), IADS) 
          LCC    = LAUXDL(IADS-1)   
        ENDIF   
      ENDIF 
      IF (IQUEST(1).NE.0)   GO TO 999   
*   
* *** Update    
* *** Look if the data are similar - STOP if they are not   
*   
      ND1    = IQ(KOFUDB+LREFDB(6) - 1) 
      ND2    = IQ(KOFUDB+LCC - 1)   
      IF (ND1.NE.ND2)       GO TO 992   
      IF (ND1.EQ.0)         GO TO 993   
*   
      IT1    = IDBTYP (LREFDB(6))   
      IT2    = IDBTYP (LCC) 
      IF (IT1.NE.IT2)       GO TO 994   
      IF (IT1.EQ.2.OR.IT1.EQ.5) THEN    
        DO 20 ID = 3, ND1   
          IQ(KOFUDB+LREFDB(6)+ID) = IQ(KOFUDB+LCC+ID)   
     +                            - IQ(KOFUDB+LREFDB(6)+ID) 
   20   CONTINUE    
      ELSE  
        DO 30 ID = 3, ND1   
          Q(KOFUDB+LREFDB(6)+ID) = Q(KOFUDB+LCC+ID) 
     +                           - Q(KOFUDB+LREFDB(6)+ID)   
   30   CONTINUE    
      ENDIF 
   40 IF (LREFDB(5).NE.LCC) CALL MZDROP (IDISDB, LCC, ' ')  
      GO TO 999 
*   
* *** Error codes   
*   
  991 IQUEST(1) = 83    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUNCP : Incompati'//    
     +   'bility - Data is an update but uncompressed'')', IARGDB, 0)   
      GO TO 999 
*   
  992 IQUEST(1) = 84    
      IQUEST(11)= ND1   
      IQUEST(12)= ND2   
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUNCP : The 2 str'//    
     +   'uctures have different number of data = '',2I4)',IQUEST(11),2)    
      GO TO 999 
*   
  993 IQUEST(1) = 85    
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUNCP : The data '//    
     +   'structure does not have data'')', IARGDB, 0)  
      GO TO 999 
*   
  994 IQUEST(1) = 86    
      IQUEST(11)= IT1   
      IQUEST(12)= IT2   
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUNCP : The 2 Str'//    
     +   'uctures have different data type '',2I4)', IQUEST(11), 2) 
      GO TO 999 
*                                                             END DBUNCP    
  999 END   
      SUBROUTINE DBUPCK (IAIN, LIN, LOU, LAUX, LBITL, IAOU) 
*     ===================================================== 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBUPCK (IAIN, LIN, LOU*, LAUX, LBITL, IAOU*)            *    
*                                                                      *    
*   Uncompresses data from LBITL to 32 bit size                        *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IAIN     Input array                                             *    
*     LIN      Length of the input array                               *    
*     LOU(*)   Length of the output array                              *    
*     LAUX     Number of words exceeding the length LBITL and therefore*    
*              are stored in 32 bits with locations given              *    
*     LBITL    Number of bits to be used for storing                   *    
*     IAOU(*)  Output array                                            *    
*                                                                      *    
*   Called by DBUCMP                                                   *    
*                                                                      *    
*                                                                      *    
************************************************************************    
*   
      DIMENSION       IAIN(LIN), IAOU(LIN)  
      LOGICAL         AUXI, AUXIL   
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
      MSBIT (MZ,IZW,IZP) = IOR (IAND (IZW, NOT(ISHFT(1,IZP-1)) )    
     +                              , ISHFT(IAND(MZ,1),IZP-1))  
*   
      MCBYT (MZ,IZQ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +        , ISHFT (ISHFT(ISHFT(MZ,-IZQ+1),32-NZB), -33+IZP+NZB) )   
*   
      JBYTET (MZ,IZW,IZP,NZB) = IAND (MZ, IBITS(IZW,IZP-1,NZB)) 
      JBYTOR (MZ,IZW,IZP,NZB) = IOR  (MZ, IBITS(IZW,IZP-1,NZB)) 
      MBYTET (MZ,IZW,IZP,NZB) = IAND (IZW, NOT(ISHFT (  
     +                          ISHFT(NOT(MZ),32-NZB),-33+IZP+NZB)) )   
      MBYTOR (MZ,IZW,IZP,NZB) = IOR (IZW, ISHFT (   
     +                               ISHFT(MZ,32-NZB),-33+IZP+NZB) )    
*   
*     ------------------------------------------------------------------    
*   
      CALL VZERO_i (IAOU, LOU)    
*   
      AUXI   = LAUX.GT.0    
*   
      LAUX   = LIN - LAUX + 1   
      IN     = 1    
      IB     = 1    
      IO     = 1    
   10 CONTINUE  
      AUXIL  = (AUXI.AND.(IAIN(LAUX).EQ.IO))    
      IF (AUXIL) THEN   
        LAUX   = LAUX + 1   
        IAOU(IO) = IAIN(LAUX)   
        LAUX   = LAUX + 1   
      ENDIF 
      AUXIL  = .NOT.AUXIL   
      IBA    = IB + LBITL   
      IF (IBA.LE.32) THEN   
        IF (AUXIL.AND.LBITL.GT.0) IAOU(IO) = JBYT (IAIN(IN), IB, LBITL) 
        IB     = IBA    
      ELSE  
        LBIT1  = 32 - IB + 1    
        IF (AUXIL.AND.LBIT1.GT.0) IAOU(IO) = JBYT (IAIN(IN), IB, LBIT1) 
        IB     = IBA - 32   
        IN     = IN + 1 
        IF (AUXIL.AND.IB.GT.1)  
     +  IAOU(IO) = MSBYT (IAIN(IN), IAOU(IO), LBIT1+1, IB-1)    
      ENDIF 
      IF (IO.LT.LOU) THEN   
        IO     = IO + 1 
        GO TO 10    
      ENDIF 
*                                                             END DBUPCK    
      END   
      SUBROUTINE DBUPFZ (AI, NDI, AO, NDO)  
*     ====================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBUPFZ (AI, NDI, AO*, NDO)                              *    
*                                                                      *    
*   Unompress floating point data  when only nonzero elements are      *    
*   stored                                                             *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     AI       Input array to be uncompressed                          *    
*     NDI      Number of elements in AI                                *    
*     AO(*)    Output array of the uncompressed elements               *    
*     NDO      Number of elements in AO                                *    
*                                                                      *    
*   Called by DBUCMZ                                                   *    
*                                                                      *    
************************************************************************    
*   
      DIMENSION       AI(NDO), AO(NDO)  
*   
*     ------------------------------------------------------------------    
*   
      CALL VZERO (AO(1), NDO)   
*   
      DO 10 I = 1, NDI  
        I2     = 2*I    
        I1     = I2 - 1 
        J      = AI(I1) 
        AO(J)  = AI(I2) 
   10 CONTINUE  
*                                                             END DBUPFZ    
      END   
      SUBROUTINE DBUPIZ (IAI, NDI, IAO, NDO)    
*     ======================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBUPIZ (IAI, NDI, IAO*, NDO)                            *    
*                                                                      *    
*   Uncompress integer data when only nonzero elements are stored      *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IAI      Input array to be uncompressed                          *    
*     NDI      Number of elements in IAI                               *    
*     IAO(*)   Output array of the uncompressed elements               *    
*     NDO      Number of elements in IAO                               *    
*                                                                      *    
*   Called by DBUCMZ                                                   *    
*                                                                      *    
************************************************************************    
*   
      DIMENSION       IAI(NDO), IAO(NDO)    
*   
*     ------------------------------------------------------------------    
*   
      CALL VZERO_i (IAO(1), NDO)  
*   
      DO 10 I = 1, NDI  
        I2     = 2*I    
        I1     = I2 - 1 
        J      = IAI(I1)    
        IAO(J) = IAI(I2)    
   10 CONTINUE  
*                                                             END DBUPIZ    
      END   
      SUBROUTINE DBUVTX (IDAY, ITIM)    
*     ==============================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBUVTX (IDAY*, ITIM*)                                   *    
*                                                                      *    
*   Returns the current date and time                                  *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IDAY     Date in YYMMDD                                          *    
*     ITIM     Time in seconds                                         *    
*                                                                      *    
*   Called by DBFOPN, DBxxxx in the Example patches                    *    
*                                                                      *    
************************************************************************    
*   
      INTEGER         IDAY, ITIM    
*   
*     ------------------------------------------------------------------    
*   
* ** Get date and time for constructing the return arguments    
*   
      CALL LIB$DAY (IDAY,%val(0),ITIM) 
*                                                             END DBUVTX    
      END   
      FUNCTION IDBTYP (L)   
*     ===================   
*   
************************************************************************    
*                                                                      *    
*        FUNC. IDBTYP (L)                                              *    
*                                                                      *    
*   Gets the bank I/O type from the address of L                       *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     L        Address of the bank                                     *    
*                                                                      *    
*   Called by several DB routines                                      *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
      LST = L - IQ(KOFUDB+L-3) - JBYT(IQ(KOFUDB+L),19,4) - 1    
      IDBTYP = JBYT (LQ(KOFUDB+LST), 17, 16)    
*                                                             END IDBTYP    
      END   
      SUBROUTINE DBIOTY (LAD, NOBJ, KOBJ, IOTY) 
*     ========================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBIOTY (LAD, NOBJ, KOBJ, IOTY*)                         *    
*                                                                      *    
*   Prepares the IO format of a list of elements in a bank from the    *    
*   bank IO descriptor                                                 *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LAD      Address of the data in DBSTOR                           *    
*     NOBJ     Number of elements to be considered                     *    
*     KOBJ     Indices of the elements                                 *    
*     IOTY(*)  Variable type (2 for integer, 3 for floating point,..)  *    
*                                                                      *    
*   Called by DBPLNT, DBPLOB, DBPLOV                                   *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /MZIOC/ NWFOAV,NWFOTT,NWFODN,NWFORE,IFOCON(3)  
     +,              MFOSAV(2),  JFOEND,JFOREP,JFOCUR,MFO(200)  
      DIMENSION       KOBJ(9), IOTY(9)  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
*  ** No data to display    
*   
      IF (NOBJ.LE.0)        GO TO 999   
      DO 5 I = 1, NOBJ  
    5 IOTY(I) = 3   
      IF (LAD.LE.0)         GO TO 999   
      NDAT = IQ(KOFUDB+LAD-1)   
      IF (NDAT.LE.0)        GO TO 999   
*   
*  ** Crack I/O Words into the character description    
*   
      LIO = LAD - IQ(KOFUDB+LAD-3) - JBYT(IQ(KOFUDB+LAD),19,4) - 1  
      CALL MZIOCR (LQ(KOFUDB+LIO))  
*   
*  ** This part (upto the RETURN) is by courtesy of J. Zoll 
*   
      NDONE = 0 
      JFOCUR = 0    
   10 ITYPE = MFO(JFOCUR+1) 
      IF (ITYPE.EQ.7)       GO TO 15    
      NWSEC = MFO(JFOCUR+2) 
      NDO   = NWSEC 
      IT    = ITYPE 
      IF (NDO.GT.0)         GO TO 30    
*   
      IF (NDO.LT.0)  THEN   
*   
*  *    Rest of the bank    
*   
        NDO = NDAT  
      ELSE  
*   
*  *    Dynamic sector  
*   
        NDONE = NDONE + 1   
        NDO   = IQ(KOFUDB+LAD+NDONE)    
      ENDIF 
      GO TO 20  
*   
*  ** Self-describing sector    
*   
   15 NDONE  = NDONE + 1    
      IWORD  = IQ(KOFUDB+LAD+NDONE) 
      IT     = MOD (IWORD,16)   
      NDO    = IWORD/16 
*   
   20 IF (IT.GE.8)          GO TO 999   
      IF (NDO.LT.0)         GO TO 999   
      IF (NDO.EQ.0)         GO TO 999   
*   
   30 JS     = NDONE + 1    
      JE     = MIN (NDONE+NDO, NDAT)    
      DO 35 I = 1, NOBJ 
        IF (KOBJ(I).GE.JS.AND.KOBJ(I).LE.JE) IOTY(I) = IT   
   35 CONTINUE  
      NDONE = JE    
      IF (NDONE.GE.NDAT)    GO TO 999   
*   
      JFOCUR = JFOCUR + 2   
      IF (JFOCUR.LT.JFOEND) GO TO 10    
      JFOCUR = JFOREP   
      GO TO 10  
*                                                             END DBIOTY    
  999 END   
      SUBROUTINE DBPLBK (LAD)   
*     =======================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPLBK (LAD)                                            *    
*                                                                      *    
*   Draw the nodes on the screen as given in the bank addressed by LAD *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LAD      Address of the bank containing the information          *    
*                                                                      *    
*   Called by DBACPL                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      CHARACTER       CHVAR*16  
      DIMENSION       X(5), Y(5)
      PARAMETER       (XRNG=24.0, YRNG=24.0, HIGH=0.5, SMARG=1.0)   
      PARAMETER       (CSIZ=0.6, HSIZ=1.5, GAP=3.5, FRAM=1.2)   
*   
*     ------------------------------------------------------------------    
*   
* *** Derive the number of tree structure levels    
*   
      LREFDB(1) = LAD
      NLEV = IQ(KOFUDB+LREFDB(1)+MNLVDB)    
      IF (NLEV.LE.0)            GO TO 999   
*   
* *** Set the default values first  
*   
      SIZH = HSIZ   
      SIZC = CSIZ   
      GAPH = GAP    
      GAPV = HIGH   
      SGAP = SMARG  
*   
* *** Find the X- and Y- ranges in each level   
*   
      IPNL  = IQ(KOFUDB+LREFDB(1)+MPNLDB)   
      YSIZM = FRAM*25+GAPV*24+SGAP*2+SIZH   
      XSIZE = 0.    
      NTEMP = 0 
      KMAX  = 1 
      DO 15 ILEV  =1, NLEV  
        NODES = IQ(KOFUDB+LREFDB(1)+IPNL+MNODDB)    
        IPNN  = IQ(KOFUDB+LREFDB(1)+IPNL+MPNNDB)    
        MXNCH = 0   
        DO 10 INOD =1, NODES    
          NCHRN = IQ(KOFUDB+LREFDB(1)+IPNN+MNCHDB)  
          IF (NCHRN.GT.MXNCH) MXNCH = NCHRN 
          IPNN  = IQ(KOFUDB+LREFDB(1)+IPNN+MPNLDB)  
   10   CONTINUE    
        XSIZE = XSIZE + SIZC*MXNCH  
        Q(KOFUDB+LREFDB(1)+IPNL+MYFLDB) = NODES*FRAM + (NODES-1)*GAPV   
     +                                  + SGAP*2    
        IF (NTEMP.LT.NODES) THEN    
          NTEMP = NODES 
          KMAX  = ILEV  
        ENDIF   
        IPNL  = IQ(KOFUDB+LREFDB(1)+IPNL+MPNLDB)    
   15 CONTINUE  
      XSIZE = XSIZE+(NLEV-1)*GAPH+SGAP*2    
      NTEMP = NTEMP + 6 
      YSIZE = FRAM*NTEMP + GAPV*(NTEMP-1) + SGAP*2 + SIZH   
      IF (YSIZE.LT.YSIZM) YSIZE = YSIZM 
*   
* *** Now choose the scaling factor 
*   
      SCAL  = XRNG/XSIZE    
      SCL0  = YRNG/YSIZE    
      IF (SCAL.GT.SCL0) THEN    
        SCAL = SCL0 
        XOFF = 0.5*(XRNG-SCAL*XSIZE)    
      ELSE  
        XOFF = 0.   
      ENDIF 
      SIZH  = SCAL*SIZH 
      SIZC  = SCAL*SIZC 
      SGAP  = SCAL*SGAP 
      GAPH  = SCAL*GAPH 
      GAPV  = SCAL*GAPV 
      HFRAM = SCAL*FRAM 
      XVAL  = XOFF+SGAP 
      Q(KOFUDB+LREFDB(1)+MHFMDB) = HFRAM    
      IPNL  = IQ(KOFUDB+LREFDB(1)+MPNLDB)   
      DO 25 ILEV =1, NLEV   
        NODES = IQ(KOFUDB+LREFDB(1)+IPNL+MNODDB)    
        IPNN  = IQ(KOFUDB+LREFDB(1)+IPNL+MPNNDB)    
        MXNCH = 0   
        DO 20 INOD =1, NODES    
          NCHRN = IQ(KOFUDB+LREFDB(1)+IPNN+MNCHDB)  
          IF (NCHRN.GT.MXNCH) MXNCH = NCHRN 
          IPNN  = IQ(KOFUDB+LREFDB(1)+IPNN+MPNLDB)  
   20   CONTINUE    
        YSIZV = Q(KOFUDB+LREFDB(1)+IPNL+MYFLDB) 
        Q(KOFUDB+LREFDB(1)+IPNL+MXOFDB) = XVAL  
        Q(KOFUDB+LREFDB(1)+IPNL+MYFLDB) = YRNG - 2*SGAP 
     +                                  - 0.5*(YRNG-SCAL*YSIZV) 
        Q(KOFUDB+LREFDB(1)+IPNL+MXWDDB) = SIZC*MXNCH    
        XVAL  = XVAL + Q(KOFUDB+LREFDB(1)+IPNL+MXWDDB) + GAPH   
        IPNL  = IQ(KOFUDB+LREFDB(1)+IPNL+MPNLDB)    
   25 CONTINUE  
*   
* *** Now set the range; choose colour, line style, line width  
*   
      CALL IGRNG (XRNG, YRNG)   
      CALL ISPLCI (7)   
      CALL ISLN (1) 
      CALL ISLWSC (2.0) 
*   
* *** Now draw the box and title    
*   
      CALL IGBOX (0., XRNG, 0.,YRNG)    
      CALL IGTEXT (0.5*XRNG, SGAP, 'DBL3 Tree Structure', SIZH, 0., 'C')    
*   
* *** Now arrange the node places into the tree 
*   
      YOFF1 = 0.    
*   
*  ** Start with the level with maximum number of nodes 
*   
      LPNL  = IQ(KOFUDB+LREFDB(1)+MPNLDB)   
      IF (KMAX.GT.1) THEN   
        DO 30 I = 2, KMAX   
   30   LPNL  = IQ(KOFUDB+LREFDB(1)+LPNL+MPNLDB)    
      ENDIF 
      YOFFN =  Q(KOFUDB+LREFDB(1)+LPNL+MYFLDB)  
      IPNN  = IQ(KOFUDB+LREFDB(1)+LPNL+MPNNDB)  
      NODES = IQ(KOFUDB+LREFDB(1)+LPNL+MNODDB)  
      DO 35 INOD = 1, NODES 
        NDOWN = IQ(KOFUDB+LREFDB(1)+IPNN+MNDWDB)    
        IF (NDOWN.GT.0) THEN    
          IF (YOFF1.GT.0) THEN  
            IF (YOFFN.GT.YOFF1) YOFFN = YOFF1   
          ENDIF 
          Q(KOFUDB+LREFDB(1)+IPNN+MYFNDB) = YOFFN   
          HH    = 0.5 * (NDOWN*HFRAM + (NDOWN-1)*GAPV)  
          YOFF1 = YOFFN - HH - GAPV - HFRAM*0.5 
          YOFFN = YOFFN - HFRAM - GAPV  
        ELSE    
          Q(KOFUDB+LREFDB(1)+IPNN+MYFNDB) = YOFFN   
          YOFFN = YOFFN - HFRAM - GAPV  
        ENDIF   
        IPNN  = IQ(KOFUDB+LREFDB(1)+IPNN+MPNLDB)    
   35 CONTINUE  
*   
*  ** Go up with level number from one with maximum nodes   
*   
      YOFFP = 0.    
      KPNL  = LPNL  
      DO 55 ILEV = KMAX+1,  NLEV    
        IPNL  = IQ(KOFUDB+LREFDB(1)+KPNL+MPNLDB)    
        IPNNU = IQ(KOFUDB+LREFDB(1)+KPNL+MPNNDB)    
        KDOWN = 1   
        NODES = IQ(KOFUDB+LREFDB(1)+KPNL+MNODDB)    
        NODEH = IQ(KOFUDB+LREFDB(1)+IPNL+MNODDB)    
        DO 45 IUP = 1, NODES    
          NDOWN = IQ(KOFUDB+LREFDB(1)+IPNNU+MNDWDB) 
          IF (NDOWN.GT.0) THEN  
            HH    = 0.5 * (NDOWN*HFRAM + (NDOWN-1)*GAPV)    
            YOFFN = HH + Q(KOFUDB+LREFDB(1)+IPNNU+MYFNDB) - HFRAM*0.5   
            IF (KDOWN.GT.1) THEN    
              IF (YOFFN.GT.YOFFP) YOFFN = YOFFP 
            ENDIF   
            IPNN  = IQ(KOFUDB+LREFDB(1)+IPNL+MPNNDB)    
            DO 40 INOD = 1, NODEH   
              IF (IQ(KOFUDB+LREFDB(1)+IPNN+MNFNDB).EQ.IUP) THEN 
                Q(KOFUDB+LREFDB(1)+IPNN+MYFNDB) = YOFFN 
                YOFFN = YOFFN - HFRAM - GAPV    
                KDOWN = KDOWN + 1   
              ENDIF 
              IPNN  = IQ(KOFUDB+LREFDB(1)+IPNN+MPNLDB)  
   40       CONTINUE    
            IF (KDOWN.GT.NODEH) GO TO 50    
            YOFFP = YOFFN   
          ENDIF 
          IPNNU = IQ(KOFUDB+LREFDB(1)+IPNNU+MPNLDB) 
   45   CONTINUE    
   50   KPNL  = IPNL    
   55 CONTINUE  
*   
*  ** Now go down with level number from one with maximum nodes 
*   
      KPNL  = LPNL  
      DO 75 ILEV = 1, KMAX-1    
        IPNL  = IQ(KOFUDB+LREFDB(1)+KPNL+MPPLDB)    
        IPNNU = IQ(KOFUDB+LREFDB(1)+IPNL+MPNNDB)    
        YOFFP = 0.  
        NODES = IQ(KOFUDB+LREFDB(1)+IPNL+MNODDB)    
        NODEH = IQ(KOFUDB+LREFDB(1)+KPNL+MNODDB)    
        KCOUN = 0   
        LCOUN = 0   
        DO 65 IUP = 1, NODES    
          NDOWN = IQ(KOFUDB+LREFDB(1)+IPNNU+MNDWDB) 
          IF (NDOWN.GT.0) THEN  
            ICOUN = 0   
            IPNN  = IQ(KOFUDB+LREFDB(1)+KPNL+MPNNDB)    
            DO 60 INOD = 1, NODEH   
              IF (IQ(KOFUDB+LREFDB(1)+IPNN+MNFNDB).EQ.IUP) THEN 
                ICOUN = ICOUN + 1   
                IF (ICOUN.EQ.1) YSTRT = Q(KOFUDB+LREFDB(1)+IPNN+MYFNDB) 
                YSTOP = Q(KOFUDB+LREFDB(1)+IPNN+MYFNDB) 
              ENDIF 
              IPNN  = IQ(KOFUDB+LREFDB(1)+IPNN+MPNLDB)  
   60       CONTINUE    
            YOFFN = (YSTRT+YSTOP)*0.5   
            Q(KOFUDB+LREFDB(1)+IPNNU+MYFNDB) = YOFFN    
            KCOUN = KCOUN + 1   
            IF (KCOUN.EQ.1) YOFFP = YOFFN   
          ELSE  
            IF (KCOUN.GT.0) THEN    
              YOFFN = YOFFN - GAPV - HFRAM  
              Q(KOFUDB+LREFDB(1)+IPNNU+MYFNDB) = YOFFN  
            ELSE    
              LCOUN = LCOUN + 1 
            ENDIF   
          ENDIF 
          IPNNU = IQ(KOFUDB+LREFDB(1)+IPNNU+MPNLDB) 
   65   CONTINUE    
        YOFFN = YOFFP   
        IPNNU = IQ(KOFUDB+LREFDB(1)+IPNL+MPNNDB)    
        DO 70 I = 1, LCOUN  
          Q(KOFUDB+LREFDB(1)+IPNNU+MYFNDB) = YOFFP  
     +                                     + (LCOUN-I+1)*(HFRAM+GAPV)   
          IPNNU = IQ(KOFUDB+LREFDB(1)+IPNNU+MPNLDB) 
   70   CONTINUE    
        KPNL  = IPNL    
   75 CONTINUE  
*   
* *** Now draw the tree structure for DBL3  
*   
      IPNL = IQ(KOFUDB+LREFDB(1)+MPNLDB)    
      DO 95 ILEV = 1, NLEV  
        IPNN  = IQ(KOFUDB+LREFDB(1)+IPNL+MPNNDB)    
        NODES = IQ(KOFUDB+LREFDB(1)+IPNL+MNODDB)    
        XOFF  =  Q(KOFUDB+LREFDB(1)+IPNL+MXOFDB)    
        XWID  =  Q(KOFUDB+LREFDB(1)+IPNL+MXWDDB)    
        IF (ILEV.LT.NLEV) THEN  
          LPNL  = IQ(KOFUDB+LREFDB(1)+IPNL+MPNLDB)  
          XOFFL =  Q(KOFUDB+LREFDB(1)+LPNL+MXOFDB)  
          NODEH = IQ(KOFUDB+LREFDB(1)+LPNL+MNODDB)  
        ENDIF   
        DO 90 INOD = 1, NODES   
          NCH   = IQ(KOFUDB+LREFDB(1)+IPNN+MNCHDB)  
          NDOWN = IQ(KOFUDB+LREFDB(1)+IPNN+MNDWDB)  
          YOFF  =  Q(KOFUDB+LREFDB(1)+IPNN+MYFNDB)  
          X(1)  = XOFF  
          X(2)  = X(1) + XWID   
          X(3)  = X(2)  
          X(4)  = X(1)  
          X(5)  = X(1)  
          XCEN  = 0.5 * (X(1) + X(2))   
          Y(1)  = YOFF  
          Y(2)  = Y(1)  
          Y(3)  = Y(1) + HFRAM  
          Y(4)  = Y(3)  
          Y(5)  = Y(1)  
          YCEN  = Y(1) + 0.5*(HFRAM-SIZC)   
          CALL IPL (5,X,Y)  
          CALL UHTOC (IQ(KOFUDB+LREFDB(1)+IPNN+MNAMDB), 4, CHVAR, NCH)  
          CALL IGTEXT (XCEN, YCEN, CHVAR(1:NCH), SIZC, 0., 'C') 
          IF (ILEV.LT.NLEV.AND.NDOWN.GT.0) THEN 
            IPNND = IQ(KOFUDB+LREFDB(1)+LPNL+MPNNDB)    
            YUP   =  Q(KOFUDB+LREFDB(1)+IPNN+MYFNDB) + HFRAM*0.5    
            XUP   = XOFF + XWID 
            YDOW1 = -1  
            XDOWN = XOFFL   
            XLINE = XDOWN - GAPH/6. 
            DO 80 IDOWN = 1, NODEH  
              ITEMP   =IQ(KOFUDB+LREFDB(1)+IPNND+MNFNDB)    
              IF (INOD.EQ.ITEMP) THEN   
                YDOW2 = Q(KOFUDB+LREFDB(1)+IPNND+MYFNDB) + HFRAM*0.5    
                IF (YDOW1.LT.0.) THEN   
                  YDOW1 = YDOW2 
                  YFRST = YDOW1 
                  Y(1)  = YDOW1 
                  Y(2)  = Y(1)  
                  X(1)  = XDOWN 
                  X(2)  = XLINE 
                  CALL IPL (2, X, Y)    
                ELSE    
                  Y(1)  = YDOW1 
                  Y(2)  = YDOW2 
                  Y(3)  = Y(2)  
                  X(1)  = XLINE 
                  X(2)  = X(1)  
                  X(3)  = XDOWN 
                  CALL IPL (3, X, Y)    
                  YDOW1 = YDOW2 
                ENDIF   
              ENDIF 
              IPNND = IQ(KOFUDB+LREFDB(1)+IPNND+MPNLDB) 
   80       CONTINUE    
            YEND  = YDOW1   
   85       IF (YDOW1.GE.0) THEN    
              Y(1)  = YUP   
              Y(2)  = (YFRST+YEND)*0.5  
              X(1)  = XUP   
              X(2)  = XLINE 
              CALL IPL (2, X, Y)    
            ENDIF   
          ENDIF 
          IPNN  = IQ(KOFUDB+LREFDB(1)+IPNN+MPNLDB)  
   90   CONTINUE    
        IPNL  = IQ(KOFUDB+LREFDB(1)+IPNL+MPNLDB)    
   95 CONTINUE  
*                                                             END DBPLBK    
  999 END   
      SUBROUTINE DBPLNT (NTUP, PATHS, NPATH, NOBJS, KOBJS, NKEYX,   
     +                   KEYXS, KEYS, CHOPT)    
*     ===========================================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPLNT (NTUP, PATHS, NPATH, NOBJS, KOBJS, NKEYX,        *    
*                      KEYXS, KEYS, CHOPT)                             *    
*                                                                      *    
*   Fills an N-tuple with data and key elements from multiple          *    
*   directories as requested by the user                               *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     NTUP     Integer identifier of the ntuple                        *    
*     PATHS    Character array describing the path names               *    
*     NPATH    Number of paths given in PATHS                          *    
*     NOBJS    Array giving the number of data elements to be stored   *    
*              for PATHS(i)                                            *    
*     KOBJS    Vector specifying the element indices to be stored for  *    
*              PATHS(i)                                                *    
*     NKEYX    Array giving the number of key elements to be stored    *    
*              with data for PATHS(i)                                  *    
*     KEYXS    Array giving key element indices to be stored with the  *    
*              data. For a given path, data elements follow the key    *    
*              elements                                                *    
*     KEYS     Vector of keys. Only the elements declared in CHOPT are *    
*              considered to contain useful information. The vector as *    
*              well as CHOPT refers to the PATHS(1). Selections for    *    
*              all subsequent paths is done on the basis of start      *    
*              validity period from path 1 and a correlation table     *    
*              between the user keys.                                  *    
*     CHOPT    Character string with any of the following characters   *    
*          T   Transforms the Keys 3,4,7 to seconds/minutes passed     *    
*              since midnight January 1, 1980                          *    
*          3   selects objects with start validity time > KEYS(3)      *    
*          4   selects objects with start validity time < KEYS(4)      *    
*          5   specific Program version number required                *    
*          7   selects objects with insertion      time < KEYS(7)      *    
*          n   consider user key n (where 7 < n < 30)                  *    
*                                                                      *    
*   Called by user,   DBAUXI                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =161 : Illegal path name                               *    
*               =162 : No keys or data in the directory                *    
*               =163 : Illegal number of objects                       *    
*               =164 : Illegal number of path names                    *    
*               =165 : Illegal object element indices                  *    
*               =166 : Illegal key element indices                     *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (NOBMDP=50, NPLMDP=500, NPMXDP=10)    
      PARAMETER       (NMAXDP=2*NOBMDP) 
      COMMON /DPLOTS/ IBINDP(8), INDXDP(2,NOBMDP), KOBJDP(NMAXDP)   
     +              , NKSMDP(NPMXDP), NKSTDP(NPMXDP), NDSMDP(NPMXDP)    
     +              , NDSTDP(NPMXDP), IBEGDP(NPMXDP), NDEMDP(NPMXDP)    
     +              , IOTYDP(NMAXDP), NSKYDP(NPMXDP), NKEYDP(22,NPMXDP) 
     +              , KKEYDP(22,NPMXDP), VMAXDP, VMINDP 
      COMMON /DPLOCH/ CHRPDP, CTTLDP, DYENDP, DYSTDP    
      CHARACTER       CHRPDP*119, CTTLDP*73, DYENDP*9, DYSTDP*9 
*   
      CHARACTER       PATH*80, PATHX*16, PATHY*80, PATHN*80, CTAG(25)*16    
      CHARACTER*(*)   PATHS(*), CHOPT   
      DIMENSION       KEYS(9), KEYXS(9), KOBJS(9), NKEYX(9), NOBJS(9)   
      DOUBLE PRECISION DVAL
      real fval(2)
      equivalence (fval, dval)
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*

      dimension nio(9)
*     ------------------------------------------------------------------    
*   
* *** Prepare object and key vector specifiers for different paths  
*   
      IF (NPATH.LT.1.OR.NPATH.GT.NPMXDP) THEN   
        IQUEST(1) = 164 
        IQUEST(11)= NPATH   
        IQUEST(12)= NPMXDP  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT : Illegal'//    
     +  ' number of path names '',2I10)', IQUEST(11), 2)    
        GO TO 999   
      ENDIF 
*   
      NDSMDP(1) = 0 
      NKSMDP(1) = 0 
      NKSTDP(1)  = 0    
      DO 10 J = 1, NPATH    
        IF (NKEYX(J).LT.0.OR.NOBJS(J).LT.0.OR.NKEYX(J)+NOBJS(J).LE.0)   
     +                                                              THEN    
          IQUEST(1) = 163   
          IQUEST(11)= MIN0 (NKEYX(J), NOBJS(J)) 
          IQUEST(12)= NOBMDP    
          IF (IDEBDB.GT.0) THEN 
            PATH   = PATHS(J)   
            CALL DBPRNT (LPRTDB, '(/,'' DBPLNT : Illegal number of ob'//    
     +           'jects '',2I9,'' for '//PATH(1:40)//''')',IQUEST(11),2)    
          ENDIF 
          GO TO 999 
        ENDIF   
        IF (J.GT.1) THEN    
          NDSMDP(J) = NDSMDP(J-1) + NOBJS(J-1)  
          NKSMDP(J) = NKSMDP(J-1) + NKEYX(J-1)  
          NKSTDP(J)  = NDSTDP(J-1)  + NOBJS(J-1)    
        ENDIF   
        NDSTDP(J)  = NKSTDP(J)    + NKEYX(J)    
        IBEGDP(J)  = 0  
        NDEMDP(J)  = 0  
        DO 5 I = 1, NOBJS(J)    
          IOBJ   = KOBJS(NDSMDP(J)+I)   
          IF (IOBJ.LT.1) THEN   
            IQUEST(1) = 165 
            IQUEST(11)= IOBJ    
            IQUEST(12)= I   
            IF (IDEBDB.GT.0) THEN   
              PATH   = PATHS(J) 
              CALL DBPRNT (LPRTDB, '(/,'' DBPLNT : Illegal data eleme'//    
     +             'nt index '',2I9,'' for '//PATH(1:40)//''')',    
     +             IQUEST(11), 2)   
            ENDIF   
            GO TO 999   
          ENDIF 
          IF (IOBJ.GT.NDEMDP(J)) NDEMDP(J) = IOBJ   
    5   CONTINUE    
   10 CONTINUE  
      NTOT   = NDSTDP(NPATH) + NOBJS(NPATH) 
      IF (NTOT.LE.0.OR.NTOT.GT.NOBMDP) THEN 
        IQUEST(1) = 163 
        IQUEST(11)= NTOT    
        IQUEST(12)= NOBMDP  
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT : Illegal'//    
     +  ' number of objects '',2I9,'' for All Paths'')', IQUEST(11), 2) 
        GO TO 999   
      ENDIF 
      CALL VZERO_i (IOTYDP, NTOT) 
      NPLM  = NPLMDP    
      CALL HCDIR (PATHN, 'R')   
*   
* *** Decode the character option   
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)                                     GO TO 999 
*   
* *** Find the keys on the basis of which selection is to be made   
*   
      DO 35 NPT = 1, NPATH  
*   
*  **   Suppress blanks from the pathname and set current directory 
*   
        PATHY  = PATHS(NPT) 
        CALL DBSBLC (PATHY, PATH, NCHAR)    
        CALL RZCDIR (PATH, ' ') 
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1) = 161   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT :'//  
     +    ' Illegal pathname '//PATH//''')', IARGDB, 0) 
          GO TO 999 
        ENDIF   
        NKEYDK = IQUEST(7)  
        NWKYDK = IQUEST(8)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        CALL DBKYTG 
*   
        IF (NKEYDK.LE.0) THEN   
          IQUEST(1) = 162   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT : No '//  
     +    'keys in directory '//PATH//''')', IARGDB, 0) 
          GO TO 999 
        ENDIF   
*   
*  **   Load number of user keys to be tested for selection 
*  **   for each path and their indices 
*   
        NSKYDP(NPT) = 0 
        IF (NPT.EQ.1) THEN  
          DO 15 I = NSYSDK + 1, NWKYDK  
            IF (IOKYDA(I).NE.0) THEN    
              NSKYDP(NPT) = NSKYDP(NPT) + 1 
              NKEYDP(NSKYDP(NPT),NPT) = I   
              KKEYDP(NSKYDP(NPT),NPT) = I   
              CTAG(NSKYDP(NPT))     = CTAGDK(I) 
            ENDIF   
   15     CONTINUE  
        ELSE IF (NSKYDP(1).GT.0) THEN   
          DO 25 I = 1, NSKYDP(1)    
            DO 20 J = NSYSDK+1, NWKYDK  
              IF (CTAG(I).EQ.CTAGDK(J)) THEN    
                NSKYDP(NPT) = NSKYDP(NPT) + 1   
                NKEYDP(NSKYDP(NPT),NPT) = J 
                KKEYDP(NSKYDP(NPT),NPT) = NKEYDP(I,1)   
                GO TO 25    
              ENDIF 
   20       CONTINUE    
   25     CONTINUE  
        ENDIF   
*   
*  **   Load the IO type of the keys    
*   
        DO 30 I = 1, NKEYX(NPT) 
          IK     = KEYXS(NKSMDP(NPT)+I) 
          IF (IK.LT.1.OR.IK.GT.NWKYDK) THEN 
            IQUEST(1) = 166 
            IQUEST(11)= I   
            IQUEST(12)= IK  
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT : Ill'//    
     +      'egal key  element index '',2I9,'' for '//PATH(1:40)//''')',    
     +      IQUEST(11), 2)  
            GO TO 999   
          ENDIF 
          IF (IOTYDK(IK).NE.6) THEN 
            IOTYDP(NKSTDP(NPT)+I) = IOTYDK(IK)  
          ELSE  
            IOTYDP(NKSTDP(NPT)+I) = 5   
          ENDIF 
   30   CONTINUE    
*   
*  **   Find maximum number of objects from Path 1  
*   
        IF (NPT.EQ.1) THEN  
          IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)   
          IF (IOPTP.EQ.0)THEN   
            IF (NKEYDK.LT.NPLM) NPLM = NKEYDK   
          ENDIF 
        ENDIF   
   35 CONTINUE  
*   
* *** Prepare temporary storage 
*   
      CALL DATIME (IDATX, ITIMX)    
      CALL DBPKTS (IDATX, ITIMX*100, ITNOW) 
      ND    = (NTOT + 1) * NPLM 
      IF (LAUXDL(10).NE.0) CALL MZDROP (IDISDB, LAUXDL(10), 'L')
      nio(1) = 0
      CALL DBBOOK (IDISDB, LAUXDL(10), LAUXDL(10), 2, 'TEMP', 0, 0, ND, 
     +             nio, -1)   
      IF (IQUEST(1).NE.0)                                     GO TO 999 
      NCUR   = 0    
      NCURD  = 0    
      NBAD   = 0    
      NOLD   = 0    
      NOLDD  = 0    
      JBIAS  = 2    
*   
* *** Load useful data in the temp bank from Path 1 
*   
   40 ITIME  = 1    
      NPL    = 0    
      PATHY  = PATHS(1) 
      CALL DBSBLC (PATHY, PATH, NCHAR)  
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 161 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT :'//    
     +  ' Illegal pathname '//PATH//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
      CALL RZCDIR (PATH, 'R')   
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKEYT   
      NCHR   = INDEX (PATH, ' ') - 1    
      IF (NCHR.LT.1) NCHR = MAXLDB  
      NCHRT  = INDEX (PATH(3:NCHR), '/') - 1    
      IF (NCHRT.LE.0) NCHRT = NCHR - 2  
      PATHX  = PATH(3:NCHRT+2)  
      LTOP   = LTOPDB   
   42 IF (LTOP.NE.0) THEN   
        NCHRT  = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHRT)   
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN  
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 42  
        ENDIF   
        KY7MDB = IQ(KOFUDB+LTOP+MUPKY7) 
      ELSE  
        KY7MDB = 0  
      ENDIF 
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)   
      IF (LAUXDL(9).NE.0) THEN  
        CALL MZDROP (IDISDB, LAUXDL(9), 'L')    
        LAUXDL(9) = 0   
      ENDIF 
*   
      IF (IOPTP.EQ.0) THEN  
*   
*  **   For non-parttioned directories  
*   
        DO 60 IK = NCUR+1, NKEYDK   
          CALL DBKEYR (IK, NWKYDK, KEYVDK)  
*   
*  **     Store the time values for the subsequent loop runs    
*   
          IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB))   
     +                                                        GO TO 60  
          IF (KEYVDK(MBVRDB).GT.ITNOW)                        GO TO 60  
          IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB))   
     +                                                        GO TO 60  
          IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))   
     +                                                        GO TO 60  
          IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))   
     +                                                        GO TO 60  
          IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)       GO TO 60  
          IF (NSKYDP(1).GT.0) THEN  
            DO 45 I = 1, NSKYDP(1)  
              IIK    = NKEYDP(I,1)  
              IF (KEYVDK(IIK).NE.KEYS(IIK))                   GO TO 60  
   45       CONTINUE    
          ENDIF 
          IF (NOBJS(1).GT.0) THEN   
            LAUXDL(9) = 0   
            CALL VZERO_i (KEYVDK, NWKYDK) 
            KEYVDK(MSERDB) = IK 
            IOKYDA(MSERDB) = 1  
            CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9), JBIAS,    
     +                   NWKYDK, KEYVDK, IPREC) 
            IOKYDA(MSERDB) = 0  
            IF (IQUEST(1).NE.0) THEN    
              IF (LAUXDL(9).NE.0) CALL MZDROP (IDISDB, LAUXDL(9), 'L')  
              IQUEST(1) = 0 
              GO TO 60  
            ENDIF   
            IF (NDEMDP(1).GT.IQ(KOFUDB+LAUXDL(9)-1)) THEN   
              NBAD   = NBAD +1  
              CALL MZDROP (IDISDB, LAUXDL(9), 'L')  
              GO TO 60  
            ENDIF   
            IF (IBEGDP(1).EQ.0) THEN    
              IBEGDP(1) = 1 
              CALL DBIOTY (LAUXDL(9), NOBJS(1), KOBJS(NDSMDP(1)+1), 
     +                     IOTYDP(NDSTDP(1)+1)) 
            ENDIF   
          ENDIF 
          NPL    = NPL + 1  
          IF (NPL.GT.NPLM) THEN 
            NPL    = NPLM   
            NCUR   = IK - 1 
            GO TO 100   
          ENDIF 
*   
*  **     Load the requested keys and key(3)    
*   
          IPNT = KOFUDB + LAUXDL(10) + (NPL - 1) * (NTOT + 1)   
          IQ(IPNT+1) = KEYVDK(MBVRDB)   
          DO 50 I = 1, NKEYX(1) 
            IND = KEYXS(NKSMDP(1)+I)    
            IF (IOPTDA.EQ.0.OR.(IND.NE.MBVRDB.AND.IND.NE.MEVRDB.AND.    
     +          IND.NE.MITMDB))                      THEN   
              Q(IPNT+NKSTDP(1)+I+1) = KEYVDK(IND)   
            ELSE IF (IND.EQ.MBVRDB.OR.IND.EQ.MEVRDB) THEN   
              CALL DBUTIS (KEYVDK(IND), IVAL)   
              Q(IPNT+NKSTDP(1)+I+1) = IVAL  
            ELSE    
              CALL DBUTIM (KEYVDK(IND), IVAL)   
              Q(IPNT+NKSTDP(1)+I+1) = IVAL  
            ENDIF   
   50     CONTINUE  
          DO 55 I = 1, NOBJS(1) 
            ID     = NDSTDP(1) + I  
            II     = KOBJS(NDSMDP(1)+I) 
            IF (IOTYDP(ID).EQ.1.OR.IOTYDP(ID).EQ.2.OR.IOTYDP(ID).EQ.5)  
     +                                THEN  
              IVAL   = IQ(KOFUDB+LAUXDL(9)+II)  
              Q(IPNT+ID+1) = IVAL   
            ELSE IF (IOTYDP(ID).EQ.4) THEN  
              CALL UCOPY (Q(KOFUDB+LAUXDL(9)+II), fVAL, 2)  
              Q(IPNT+ID+1) = DVAL   
            ELSE    
              Q(IPNT+ID+1) = Q(KOFUDB+LAUXDL(9)+II) 
            ENDIF   
   55     CONTINUE  
          CALL MZDROP (IDISDB, LAUXDL(9), 'L')  
   60   CONTINUE    
*   
      ELSE  
*   
*   **  Partitioned directory   
*   
        KST    = NWKYDK + 1 
        NKEYS  = NKEYDK 
        NCUS   = NCUR   
        DO 90 IKK = NCURD+1, NKEYS  
          KPNT = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),  
     +                   NKEYS*KST, KST)    
          IF (KPNT.GT.0) THEN   
            KPNT  = KOFSDB + LCDRDB + IKDRDB +KPNT - MPSRDB 
          ELSE  
            KPNT  = KOFSDB + LCDRDB + IKDRDB + (IKK - 1) * KST  
          ENDIF 
          IF (IOKYDA(MBVRDB).NE.0.AND.IQ(KPNT+MEVRDB).LT.KEYS(MBVRDB))  
     +                                                        GO TO 90  
          IF (IQ(KPNT+MBVRDB).GT.ITNOW)                       GO TO 90  
          IF (IOKYDA(MEVRDB).NE.0.AND.IQ(KPNT+MBVRDB).GT.KEYS(MEVRDB))  
     +                                                        GO TO 90  
          IF (IOKYDA(MITMDB).NE.0.AND.IQ(KPNT+MITMDB).GT.KEYS(MITMDB))  
     +                                                        GO TO 90  
          IF (KY7MDB.GT.0.AND.IQ(KPNT+MITMDB).GT.KY7MDB)      GO TO 90  
*   
          CALL DBPATH (PATHX, IKK)  
          PATHY  = PATH(1:NCHR)//'/'//PATHX 
          CALL RZCDIR (PATHY, ' ')  
          IF (IQUEST(1).NE.0) THEN  
            CALL MZDROP (IDISDB, LAUXDL(10), 'L')   
            IQUEST(1) = 161 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT :'//    
     +      ' Illegal pathname '//PATHY//''')', IARGDB, 0)  
            GO TO 999   
          ENDIF 
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
*   
          DO 80 IK = NCUS+1, NKEYDK 
            CALL DBKEYR (IK, NWKYDK, KEYVDK)    
*   
*  **       Store the time values for the subsequent loop runs  
*   
            IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB)) 
     +                                                        GO TO 80  
            IF (KEYVDK(MBVRDB).GT.ITNOW)                      GO TO 80  
            IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB)) 
     +                                                        GO TO 80  
            IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB)) 
     +                                                        GO TO 80  
            IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB)) 
     +                                                        GO TO 80  
            IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)     GO TO 80  
            IF (NSKYDP(1).GT.0) THEN    
              DO 65 I = 1, NSKYDP(1)    
                IIK    = NKEYDP(I,1)    
                IF (KEYVDK(IIK).NE.KEYS(IIK))                 GO TO 80  
   65         CONTINUE  
            ENDIF   
            IF (NOBJS(1).GT.0) THEN 
              LAUXDL(9) = 0 
              CALL VZERO_i (KEYVDK, NWKYDK)   
              KEYVDK(MSERDB) = IK   
              IOKYDA(MSERDB) = 1    
              CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9), JBIAS,  
     +                     NWKYDK, KEYVDK, IPREC)   
              IOKYDA(MSERDB) = 0    
              IF (IQUEST(1).NE.0) THEN  
                IF (LAUXDL(9).NE.0) CALL MZDROP (IDISDB, LAUXDL(9), 'L')    
                IQUEST(1) = 0   
                GO TO 80    
              ENDIF 
              IF (NDEMDP(1).GT.IQ(KOFUDB+LAUXDL(9)-1)) THEN 
                NBAD   = NBAD +1    
                CALL MZDROP (IDISDB, LAUXDL(9), 'L')    
                GO TO 80    
              ENDIF 
              IF (IBEGDP(1).EQ.0) THEN  
                IBEGDP(1) = 1   
                CALL DBIOTY (LAUXDL(9), NOBJS(1), KOBJS(NDSMDP(1)+1),   
     +                       IOTYDP(NDSTDP(1)+1))   
              ENDIF 
            ENDIF   
            NPL    = NPL + 1    
            IF (NPL.GT.NPLM) THEN   
              NPL    = NPLM 
              NCUR   = IK - 1   
              NCURD  = IKK - 1  
              GO TO 100 
            ENDIF   
*   
*  **       Load the requested keys and key(3)  
*   
            IPNT = KOFUDB + LAUXDL(10) + (NPL - 1) * (NTOT + 1) 
            IQ(IPNT+1) = KEYVDK(MBVRDB) 
            DO 70 I = 1, NKEYX(1)   
              IND = KEYXS(NKSMDP(1)+I)  
              IF (IOPTDA.EQ.0.OR.(IND.NE.MBVRDB.AND.IND.NE.MEVRDB.AND.  
     +            IND.NE.MITMDB))                                 THEN  
                Q(IPNT+NKSTDP(1)+I+1) = KEYVDK(IND) 
              ELSE IF (IND.EQ.MBVRDB.OR.IND.EQ.MEVRDB) THEN 
                CALL DBUTIS (KEYVDK(IND), IVAL) 
                Q(IPNT+NKSTDP(1)+I+1) = IVAL    
              ELSE  
                CALL DBUTIM (KEYVDK(IND), IVAL) 
                Q(IPNT+NKSTDP(1)+I+1) = IVAL    
              ENDIF 
   70       CONTINUE    
            DO 75 I = 1, NOBJS(1)   
              ID     = NDSTDP(1) + I    
              II     = KOBJS(NDSMDP(1)+I)   
              IF (IOTYDP(ID).EQ.1.OR.IOTYDP(ID).EQ.2.OR.IOTYDP(ID).EQ.5)    
     +                                  THEN    
                IVAL   = IQ(KOFUDB+LAUXDL(9)+II)    
                Q(IPNT+ID+1) = IVAL 
              ELSE IF (IOTYDP(ID).EQ.4) THEN    
                CALL UCOPY (Q(KOFUDB+LAUXDL(9)+II), fVAL, 2)    
                Q(IPNT+ID+1) = DVAL 
              ELSE  
                Q(IPNT+ID+1) = Q(KOFUDB+LAUXDL(9)+II)   
              ENDIF 
   75       CONTINUE    
            CALL MZDROP (IDISDB, LAUXDL(9), 'L')    
   80     CONTINUE  
*   
          NCUS   = 0    
          CALL RZCDIR (PATH, ' ' )  
          IF (IQUEST(1).NE.0) THEN  
            CALL MZDROP (IDISDB, LAUXDL(10), 'L')   
            IQUEST(1) = 161 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT :'//    
     +      ' Illegal pathname '//PATH//''')', IARGDB, 0)   
            GO TO 999   
          ENDIF 
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
   90   CONTINUE    
      ENDIF 
*   
* ** Check if objects collected 
*   
  100 IF (NPL.EQ.0) THEN    
        CALL MZDROP (IDISDB, LAUXDL(10), 'L')   
        IQUEST(1) = 0   
        GO TO 999   
      ENDIF 
*   
* *** Loop over the secondary directories and fill the rest 
*   
      DO 180 NPT = 2, NPATH 
        PATHY  = PATHS(NPT) 
        CALL DBSBLC (PATHY, PATH, NCHAR)    
        CALL RZCDIR (PATH, ' ') 
        IF (IQUEST(1).NE.0) THEN    
          IQUEST(1) = 161   
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT :'//  
     +    ' Illegal pathname '//PATH//''')', IARGDB, 0) 
          GO TO 999 
        ENDIF   
        CALL RZCDIR (PATH, 'R') 
        NKEYDK = IQUEST(7)  
        NWKYDK = IQUEST(8)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
        CALL DBKEYT 
        NCHR   = INDEX (PATH, ' ') - 1  
        IF (NCHR.LT.1) NCHR = MAXLDB    
        NCHRT  = INDEX (PATH(3:NCHR), '/') - 1  
        IF (NCHRT.LE.0) NCHRT = NCHR - 2    
        PATHX  = PATH(3:NCHRT+2)    
        LTOP   = LTOPDB 
  102   IF (LTOP.NE.0) THEN 
          NCHRT  = IQ(KOFUDB+LTOP+MUPNCH)   
          CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHRT) 
          IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN    
            LTOP   = LQ(KOFUDB+LTOP)    
            GO TO 102   
          ENDIF 
          KY7MDB = IQ(KOFUDB+LTOP+MUPKY7)   
        ELSE    
          KY7MDB = 0    
        ENDIF   
        IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB) 
*   
        DO 170 IO = 1, NPL  
          IPNT   = KOFUDB + LAUXDL(10) + (IO - 1) * (NTOT + 1)  
          ITIME  = IQ(IPNT+1)   
          IF (ITIME.LE.0)                                     GO TO 170 
          IF (IOPTP.EQ.0) THEN  
*   
*  **       For non-parttioned directories  
*   
            DO 120 JK = 1, NKEYDK   
              IK     = NKEYDK + 1 - JK  
              CALL DBKEYR (IK, NWKYDK, KEYVDK)  
*   
*  **         Select on the basis of start validity from Path 1 
*   
              IF (ITIME.LT.KEYVDK(MBVRDB).OR.ITIME.GT.KEYVDK(MEVRDB))   
     +                                                        GO TO 120 
              IF (IOKYDA(MPVSDB).NE.0.AND.  
     +            KEYVDK(MPVSDB).NE.KEYS(MPVSDB))             GO TO 120 
              IF (IOKYDA(MITMDB).NE.0.AND.  
     +            KEYVDK(MITMDB).GT.KEYS(MITMDB))             GO TO 120 
              IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)   GO TO 120 
              IF (NSKYDP(NPT).GT.0) THEN    
                DO 105 I = 1, NSKYDP(NPT)   
                  IIK    = NKEYDP(I,NPT)    
                  IJK    = KKEYDP(I,NPT)    
                  IF (KEYVDK(IIK).NE.KEYS(IJK))               GO TO 120 
  105           CONTINUE    
              ENDIF 
              IF (NOBJS(NPT).GT.0) THEN 
                LAUXDL(9) = 0   
                CALL VZERO_i (KEYVDK, NWKYDK) 
                KEYVDK(MSERDB) = IK 
                IOKYDA(MSERDB) = 1  
                CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9), JBIAS,    
     +                       NWKYDK, KEYVDK, IPREC) 
                IOKYDA(MSERDB) = 0  
                IF (IQUEST(1).NE.0) THEN    
                  NBAD   = NBAD + 1 
                  IF (LAUXDL(9).NE.0)   
     +              CALL MZDROP (IDISDB, LAUXDL(9), 'L')    
                  IQUEST(1) = 0 
                  IPNT   = KOFUDB + LAUXDL(10) + (IO - 1) * (NTOT + 1)  
                  IQ(IPNT+1) = -1   
                  GO TO 170 
                ENDIF   
                IF (NDEMDP(NPT).GT.IQ(KOFUDB+LAUXDL(9)-1)) THEN 
                  NBAD   = NBAD +1  
                  CALL MZDROP (IDISDB, LAUXDL(9), 'L')  
                  IPNT   = KOFUDB + LAUXDL(10) + (IO - 1) * (NTOT + 1)  
                  IQ(IPNT+1) = -1   
                  GO TO 170 
                ENDIF   
                IF (IBEGDP(NPT).EQ.0) THEN  
                  IBEGDP(NPT) = 1   
                  CALL DBIOTY (LAUXDL(9), NOBJS(NPT),   
     +            KOBJS(NDSMDP(NPT)+1), IOTYDP(NDSTDP(NPT)+1))  
                ENDIF   
              ENDIF 
*   
*  **         Load the requested keys and data elements 
*   
              IPNT = KOFUDB + LAUXDL(10) + (IO - 1) * (NTOT + 1)    
              DO 110 I = 1, NKEYX(NPT)  
                IND = KEYXS(NKSMDP(NPT)+I)  
                IF (IOPTDA.EQ.0.OR.(IND.NE.MBVRDB.AND.IND.NE.MEVRDB.AND.    
     +              IND.NE.MITMDB))                                 THEN    
                  Q(IPNT+NKSTDP(NPT)+I+1) = KEYVDK(IND) 
                ELSE IF (IND.EQ.MBVRDB.OR.IND.EQ.MEVRDB) THEN   
                  CALL DBUTIS (KEYVDK(IND), IVAL)   
                  Q(IPNT+NKSTDP(NPT)+I+1) = IVAL    
                ELSE    
                  CALL DBUTIM (KEYVDK(IND), IVAL)   
                  Q(IPNT+NKSTDP(NPT)+I+1) = IVAL    
                ENDIF   
  110         CONTINUE  
              DO 115 I = 1, NOBJS(NPT)  
                ID     = NDSTDP(NPT) + I    
                II     = KOBJS(NDSMDP(NPT)+I)   
                IF (IOTYDP(ID).EQ.1.OR.IOTYDP(ID).EQ.2.OR.  
     +              IOTYDP(ID).EQ.5)      THEN  
                  IVAL   = IQ(KOFUDB+LAUXDL(9)+II)  
                  Q(IPNT+ID+1) = IVAL   
                ELSE IF (IOTYDP(ID).EQ.4) THEN  
                  CALL UCOPY (Q(KOFUDB+LAUXDL(9)+II), fVAL, 2)  
                  Q(IPNT+ID+1) = DVAL   
                ELSE    
                  Q(IPNT+ID+1) = Q(KOFUDB+LAUXDL(9)+II) 
                ENDIF   
  115         CONTINUE  
              IF (LAUXDL(9).NE.0) CALL MZDROP (IDISDB, LAUXDL(9), 'L')  
              GO TO 170 
  120       CONTINUE    
            IPNT   = KOFUDB + LAUXDL(10) + (IO - 1) * (NTOT + 1)    
            IQ(IPNT+1) = -1 
            GO TO 170   
*   
          ELSE  
*   
*   **      Partitioned directory   
*   
            KST    = NWKYDK + 1 
            NKEYS  = NKEYDK 
            DO 150 JKK = 1, NKEYS   
              IKK  = NKEYS + 1 - JKK    
              KPNT = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),  
     +                       NKEYS*KST, KST)    
              IF (KPNT.GT.0) THEN   
                KPNT  = KOFSDB + LCDRDB + IKDRDB +KPNT - MPSRDB 
              ELSE  
                KPNT  = KOFSDB + LCDRDB + IKDRDB + (IKK - 1) * KST  
              ENDIF 
              IF (ITIME.LT.IQ(KPNT+MBVRDB).OR.ITIME.GT.IQ(KPNT+MEVRDB)) 
     +                                                        GO TO 150 
              IF (IOKYDA(MITMDB).NE.0.AND.  
     +            IQ(KPNT+MITMDB).GT.KEYS(MITMDB))            GO TO 150 
              IF (KY7MDB.GT.0.AND.IQ(KPNT+MITMDB).GT.KY7MDB)  GO TO 150 
*   
              CALL DBPATH (PATHX, IKK)  
              PATHY  = PATH(1:NCHR)//'/'//PATHX 
              CALL RZCDIR (PATHY, ' ')  
              IF (IQUEST(1).NE.0) THEN  
                CALL MZDROP (IDISDB, LAUXDL(10), 'L')   
                IQUEST(1) = 161 
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT :'//    
     +          ' Illegal pathname '//PATHY//''')', IARGDB, 0)  
                GO TO 999   
              ENDIF 
              NKEYDK = IQUEST(7)    
              LCDRDB = IQUEST(11)   
              IKDRDB = IQUEST(13)   
*   
              DO 140 JK = 1, NKEYDK 
                IK     = NKEYDK + 1 -JK 
                CALL DBKEYR (IK, NWKYDK, KEYVDK)    
*   
*  **           Select on the basis of start validity from Path 1   
*   
                IF (ITIME.LT.KEYVDK(MBVRDB).OR.ITIME.GT.KEYVDK(MEVRDB)) 
     +                                                        GO TO 140 
                IF (IOKYDA(MPVSDB).NE.0.AND.    
     +              KEYVDK(MPVSDB).NE.KEYS(MPVSDB))           GO TO 140 
                IF (IOKYDA(MITMDB).NE.0.AND.    
     +              KEYVDK(MITMDB).GT.KEYS(MITMDB))           GO TO 140 
                IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB) GO TO 140 
                IF (NSKYDP(NPT).GT.0) THEN  
                  DO 125 I = 1, NSKYDP(NPT) 
                    IIK    = NKEYDP(I,NPT)  
                    IJK    = KKEYDP(I,NPT)  
                    IF (KEYVDK(IIK).NE.KEYS(IJK))             GO TO 140 
  125             CONTINUE  
                ENDIF   
                IF (NOBJS(NPT).GT.0) THEN   
                  LAUXDL(9) = 0 
                  CALL VZERO_i (KEYVDK, NWKYDK)   
                  KEYVDK(MSERDB) = IK   
                  IOKYDA(MSERDB) = 1    
                  CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9), 
     +                         JBIAS, NWKYDK, KEYVDK, IPREC)    
                  IOKYDA(MSERDB) = 0    
                  IF (IQUEST(1).NE.0) THEN  
                    NBAD   = NBAD + 1   
                    IF (LAUXDL(9).NE.0) 
     +                CALL MZDROP (IDISDB, LAUXDL(9), 'L')  
                    IQUEST(1) = 0   
                    IPNT   = KOFUDB + LAUXDL(10) + (IO - 1) * (NTOT + 1)    
                    IQ(IPNT+1) = -1 
                    GO TO 160   
                  ENDIF 
                  IF (NDEMDP(NPT).GT.IQ(KOFUDB+LAUXDL(9)-1)) THEN   
                    NBAD   = NBAD +1    
                    CALL MZDROP (IDISDB, LAUXDL(9), 'L')    
                    IPNT   = KOFUDB + LAUXDL(10) + (IO - 1) * (NTOT + 1)    
                    IQ(IPNT+1) = -1 
                    GO TO 160   
                  ENDIF 
                  IF (IBEGDP(NPT).EQ.0) THEN    
                    IBEGDP(NPT) = 1 
                    CALL DBIOTY (LAUXDL(9), NOBJS(NPT), 
     +              KOBJS(NDSMDP(NPT)+1), IOTYDP(NDSTDP(NPT)+1))    
                  ENDIF 
                ENDIF   
*   
*  **           Load the requested keys and object elements 
*   
                IPNT = KOFUDB + LAUXDL(10) + (NPL - 1) * (NTOT + 1) 
                DO 130 I = 1, NKEYX(NPT)    
                  IND = KEYXS(NKSMDP(NPT)+I)    
                  IF (IOPTDA.EQ.0.OR.(IND.NE.MBVRDB.AND.IND.NE.MEVRDB   
     +                .AND.IND.NE.MITMDB))                       THEN   
                    Q(IPNT+NKSTDP(NPT)+I+1) = KEYVDK(IND)   
                  ELSE IF (IND.EQ.MBVRDB.OR.IND.EQ.MEVRDB) THEN 
                    CALL DBUTIS (KEYVDK(IND), IVAL) 
                    Q(IPNT+NKSTDP(NPT)+I+1) = IVAL  
                  ELSE  
                    CALL DBUTIM (KEYVDK(IND), IVAL) 
                    Q(IPNT+NKSTDP(NPT)+I+1) = IVAL  
                  ENDIF 
  130           CONTINUE    
                DO 135 I = 1, NOBJS(1)  
                  ID     = NDSTDP(1) + I    
                  II     = KOBJS(NDSMDP(1)+I)   
                  IF (IOTYDP(ID).EQ.1.OR.IOTYDP(ID).EQ.2.OR.    
     +                IOTYDP(ID).EQ.5)      THEN    
                    IVAL   = IQ(KOFUDB+LAUXDL(9)+II)    
                    Q(IPNT+ID+1) = IVAL 
                  ELSE IF (IOTYDP(ID).EQ.4) THEN    
                    CALL UCOPY (Q(KOFUDB+LAUXDL(9)+II), fVAL, 2)    
                    Q(IPNT+ID+1) = DVAL 
                  ELSE  
                    Q(IPNT+ID+1) = Q(KOFUDB+LAUXDL(9)+II)   
                  ENDIF 
  135           CONTINUE    
                IF (LAUXDL(9).NE.0) CALL MZDROP (IDISDB, LAUXDL(9), 'L')    
                GO TO 160   
  140         CONTINUE  
*   
              CALL RZCDIR (PATH, ' ' )  
              IF (IQUEST(1).NE.0) THEN  
                CALL MZDROP (IDISDB, LAUXDL(10), 'L')   
                IQUEST(1) = 161 
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT :'//    
     +          ' Illegal pathname '//PATH//''')', IARGDB, 0)   
                GO TO 999   
              ENDIF 
              LCDRDB = IQUEST(11)   
              IKDRDB = IQUEST(13)   
  150       CONTINUE    
          ENDIF 
          IPNT   = KOFUDB + LAUXDL(10) + (NPL - 1) * (NTOT + 1) 
          IQ(IPNT+1) = -1   
*   
  160     CALL RZCDIR (PATH, ' ' )  
          IF (IQUEST(1).NE.0) THEN  
            CALL MZDROP (IDISDB, LAUXDL(10), 'L')   
            IQUEST(1) = 161 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT :'//    
     +      ' Illegal pathname '//PATH//''')', IARGDB, 0)   
            GO TO 999   
          ENDIF 
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
  170   CONTINUE    
  180 CONTINUE  
*   
* *** Fill the N-tuples 
*   
      CALL HCDIR (PATHN, ' ')   
      DO 190 IP = 1, NPL    
        IPNT   = KOFUDB + LAUXDL(10) + (IP - 1) * (NTOT + 1)    
        IF (IQ(IPNT+1).GT.0) THEN   
          CALL HFN (NTUP, Q(IPNT+2))    
        ENDIF   
  190 CONTINUE  
*   
* *** Go back and repeat if not yet completed   
*   
      IF (NOLD.NE.NCUR.OR.NOLDD.NE.NCURD) THEN  
        NOLD   = NCUR   
        NOLDD  = NCURD  
        GO TO 40    
      ENDIF 
*                                                             END DBPLNT    
  999 END   
      SUBROUTINE DBPLOB (PATHN, KEYS, NOBJ, KOBJ, KEX, NST, CHOPT)  
*     ============================================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPLOB (PATHN, KEYS, NOBJ, KOBJ, KEX, NST, CHOPT)       *    
*                                                                      *    
*   Plots data elemnet(s) versus a key element for a given path name   *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     KEYS     Vector of keys. Only the elements declared in CHOPT are *    
*              assumed to contain useful information.                  *    
*     NOBJ     Number of data objects to be plotted                    *    
*     KOBJ     Vector specifying the element numbers to be plotted     *    
*     KEX      Key index for the abcissa                               *    
*     NST      Step size for selection of object number                *    
*     CHOPT    Character string with any of the following characters   *    
*          L   a line to be drawn through the points                   *    
*              (needed only when symbol and line both to be drawn)     *    
*          P   a symbol to be drawn at each point                      *    
*              (Default is a line to be drawn through the points)      *    
*          S   all elements shown on the same plot                     *    
*              (Default is a seperate plot for each variable)          *    
*          3   selects objects with start validity time > KEYS(3)      *    
*          4   selects objects with start validity time < KEYS(4)      *    
*          5   specific Program version number required                *    
*          7   selects objects with insertion      time < KEYS(7)      *    
*          n   consider user key n (where 7 < n < 30)                  *    
*                                                                      *    
*   Called by user,   DBACPL                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =161 : Illegal path name                               *    
*               =162 : No keys or data in the directory                *    
*               =163 : Illegal number of objects                       *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (NOBMDP=50, NPLMDP=500, NPMXDP=10)    
      PARAMETER       (NMAXDP=2*NOBMDP) 
      COMMON /DPLOTS/ IBINDP(8), INDXDP(2,NOBMDP), KOBJDP(NMAXDP)   
     +              , NKSMDP(NPMXDP), NKSTDP(NPMXDP), NDSMDP(NPMXDP)    
     +              , NDSTDP(NPMXDP), IBEGDP(NPMXDP), NDEMDP(NPMXDP)    
     +              , IOTYDP(NMAXDP), NSKYDP(NPMXDP), NKEYDP(22,NPMXDP) 
     +              , KKEYDP(22,NPMXDP), VMAXDP, VMINDP 
      COMMON /DPLOCH/ CHRPDP, CTTLDP, DYENDP, DYSTDP    
      CHARACTER       CHRPDP*119, CTTLDP*73, DYENDP*9, DYSTDP*9 
*   
      PARAMETER       (MXSYM=12)    
      LOGICAL         HEXIST    
      CHARACTER       PATH*80, PATHX*16, PATHY*80, CHTAG(7)*16, CTAG*16 
      CHARACTER       PATHN*(*), CHOPT*(*)  
      DIMENSION       KEYS(9), KOBJ(9), ISYMB(MXSYM)    
      DOUBLE PRECISION DVAL
      real fval(2)
      equivalence (dval, fval)
      DATA            CHTAG /'Serial Number   ', 'Pointer         ',    
     +                       'Start Validity  ', 'End Validity    ',    
     +                       'Program Version ', 'Flags           ',    
     +                       'Insertion Time  '/    
      DATA            ISYMB /20,21,22,23,24,25,26,27,28,29,30,31/   
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension nio(9), iarg(9)
*     ------------------------------------------------------------------    
*   
* *** Decode the character option   
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)                                    GO TO 999  
      IF (KEX.EQ.MBVRDB.OR.KEX.EQ.MEVRDB.OR.KEX.EQ.MITMDB) THEN 
        KABS   = KEX    
      ELSE  
        KABS   = MBVRDB 
      ENDIF 
      IF (NST.GT.0) THEN    
        NSTEP  = NST    
      ELSE  
        NSTEP  = 1  
      ENDIF 
      IF (NOBJ.LT.1.OR.NOBJ.GT.NOBMDP) THEN 
        IQUEST(1) = 163 
        IQUEST(11)= NOBJ    
        IQUEST(12)= NOBMDP
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOB : Illegal'//    
     +  ' number of objects '',2I12)', IQUEST(11), 2)   
        GO TO 999   
      ENDIF 
      NOBM   = KOBJ(1)  
      DO 5 I = 2, NOBJ  
        IF (KOBJ(I).GT.NOBM) NOBM = KOBJ(I) 
    5 CONTINUE  
*   
* *** Suppress blanks from the pathname and sets current directory  
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 161 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOB : Ill'//    
     +  'egal pathname '//PATH//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
      CALL RZCDIR (PATH, 'R')   
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKYTG   
*   
      IF (NKEYDK.LE.0) THEN 
        IQUEST(1) = 162 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOB : No keys'//    
     +  ' in directory '//PATH//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
*   
      NCHR   = INDEX (PATH, ' ') - 1    
      IF (NCHR.LT.1) NCHR = MAXLDB  
      NCHRT  = INDEX (PATH(3:NCHR), '/') - 1    
      IF (NCHRT.LE.0) NCHRT = NCHR - 2  
      PATHX  = PATH(3:NCHRT+2)  
      LTOP   = LTOPDB   
    8 IF (LTOP.NE.0) THEN   
        NCHRT  = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHRT)   
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN  
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 8   
        ENDIF   
        KY7MDB = IQ(KOFUDB+LTOP+MUPKY7) 
      ELSE  
        KY7MDB = 0  
      ENDIF 
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)   
      NTOT   = 0    
      IF (KEX.GT.0.AND.KEX.LE.NWKYDK) THEN  
        KPEX   = KEX    
      ELSE  
        KPEX   = 3  
      ENDIF 
      IF (KPEX.LT.NSYSDK) THEN  
        CTAG   = CHTAG(KPEX)    
      ELSE  
        CTAG   = CTAGDK(KPEX)   
      ENDIF 
*   
* *** Prepare a temporary storage for useful information    
*   
      CALL DATIME (IDATX, ITIMX)    
      IF (KABS.EQ.MITMDB) THEN  
        CALL DBPKTM (IDATX, ITIMX, ITNOW)   
        CALL DBPKTS (IDATX, ITIMX*100, INOWS)   
      ELSE  
        CALL DBPKTS (IDATX, ITIMX*100, ITNOW)   
        INOWS  = ITNOW  
      ENDIF 
      NPLM   = NPLMDP   
      IF (IOPTP.EQ.0) THEN  
        IF (NKEYDK.LT.NPLM) NPLM = NKEYDK   
      ENDIF 
      ND     = (NOBJ + 1) * NPLM    
      NBAD   = 0    
      IF (LAUXDL(10).NE.0) CALL MZDROP (IDISDB, LAUXDL(10), 'L')
      nio(1) = 0
      CALL DBBOOK (IDISDB, LAUXDL(10), LAUXDL(10), 2, 'TEMP', 0, 0, ND, 
     +             nio, -1)   
      IF (IQUEST(1).NE.0)                                    GO TO 999  
      VMINDP = 9.0E20   
      VMAXDP =-9.0E20   
      IF (LAUXDL(9).NE.0) THEN  
        CALL MZDROP (IDISDB, LAUXDL(9), 'L')    
        LAUXDL(9) = 0   
      ENDIF 
*   
* *** Load useful data in the temporary bank    
*   
      IMIN   = ITNOW    
      IMAX   = -1   
      ITIME  = 1    
      JBIAS  = 2    
      NPL    = 0    
      IF (IOPTP.EQ.0) THEN  
        DO 20 JK = 1, NKEYDK    
          IK     = NKEYDK + 1 - JK  
          CALL DBKEYR (IK, NWKYDK, KEYVDK)  
          IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB))   
     +                                                       GO TO 20   
          IF (KEYVDK(MBVRDB).GT.INOWS)                       GO TO 20   
          IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB))   
     +                                                       GO TO 20   
          IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))   
     +                                                       GO TO 20   
          IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))   
     +                                                       GO TO 20   
          IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)      GO TO 20   
          IF (NWKYDK.GT.NSYSDK) THEN    
            DO 10 I = NSYSDK+1, NWKYDK  
              IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I))   GO TO 20   
   10       CONTINUE    
          ENDIF 
          NTOT   = NTOT + 1 
          IF (NSTEP.GT.1) THEN  
            IF (MOD(NTOT,NSTEP).NE.1)                        GO TO 20   
          ENDIF 
          LAUXDL(9) = 0 
          KTIME  = KEYVDK(KABS) 
          KYVAL  = KEYVDK(KPEX) 
          CALL VZERO_i (KEYVDK, NWKYDK)   
          KEYVDK(MSERDB) = IK   
          IOKYDA(MSERDB) = 1    
          CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9), JBIAS,  
     +                 NWKYDK, KEYVDK, IPREC)   
          IOKYDA(MSERDB) = 0    
          IF (IQUEST(1).NE.0) THEN  
            IF (LAUXDL(9).NE.0) 
     +        CALL MZDROP (IDISDB, LAUXDL(9), 'L')  
            NBAD   = NBAD + 1   
            IQUEST(1) = 0   
            GO TO 20    
          ENDIF 
          IF (NOBM.GT.IQ(KOFUDB+LAUXDL(9)-1)) THEN  
            NBAD   = NBAD + 1   
            CALL MZDROP (IDISDB, LAUXDL(9), 'L')    
            GO TO 20    
          ENDIF 
          IF (NPL.EQ.0) CALL DBIOTY (LAUXDL(9), NOBJ, KOBJ, IOTYDP) 
          NPL    = NPL + 1  
          IF (NPL.LE.NPLM) THEN 
            IPNT   = KOFUDB + LAUXDL(10) + (NPL - 1) * (NOBJ + 1)   
            IQ(IPNT+1) = KYVAL  
            DO 15 I = 1, NOBJ   
              IF (IOTYDP(I).EQ.1.OR.IOTYDP(I).EQ.2.OR.IOTYDP(I).EQ.5)   
     +                                                     THEN 
                IVAL   = IQ(KOFUDB+LAUXDL(9)+KOBJ(I))   
                Q(IPNT+I+1) = IVAL  
              ELSE IF (IOTYDP(I).EQ.4) THEN 
                CALL UCOPY (Q(KOFUDB+LAUXDL(9)+KOBJ(I)), fVAL, 2)   
                Q(IPNT+I+1) = DVAL  
              ELSE  
                Q(IPNT+I+1) = Q(KOFUDB+LAUXDL(9)+KOBJ(I))   
              ENDIF 
              IF (Q(IPNT+I+1).GT.VMAXDP) VMAXDP = Q(IPNT+I+1)   
              IF (Q(IPNT+I+1).LT.VMINDP) VMINDP = Q(IPNT+I+1)   
   15       CONTINUE    
            IF (KTIME.LT.IMIN) IMIN = KTIME 
            IF (KTIME.GT.IMAX) IMAX = KTIME 
          ENDIF 
          CALL MZDROP (IDISDB, LAUXDL(9), 'L')  
   20   CONTINUE    
*   
      ELSE  
        KST    = NWKYDK + 1 
        NKEYS  = NKEYDK 
        DO 40 JKK = 1, NKEYS    
          IKK    = NKEYS + 1 - JKK  
          KPNT   = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),    
     +                     NKEYS*KST, KST)  
          IF (KPNT.GT.0) THEN   
            KPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB   
          ELSE  
            KPNT   = KOFSDB + LCDRDB + IKDRDB + (IKK - 1) * KST 
          ENDIF 
          IF (IOKYDA(MBVRDB).NE.0.AND.IQ(KPNT+MEVRDB).LT.KEYS(MBVRDB))  
     +                                                       GO TO 40   
          IF (IQ(KPNT+MBVRDB).GT.INOWS)                      GO TO 40   
          IF (IOKYDA(MEVRDB).NE.0.AND.IQ(KPNT+MBVRDB).GT.KEYS(MEVRDB))  
     +                                                       GO TO 40   
          IF (IOKYDA(MITMDB).NE.0.AND.IQ(KPNT+MITMDB).GT.KEYS(MITMDB))  
     +                                                       GO TO 40   
          IF (KY7MDB.GT.0.AND.IQ(KPNT+MITMDB).GT.KY7MDB)     GO TO 40   
*   
          CALL DBPATH (PATHX, IKK)  
          PATHY  = PATH(1:NCHR)//'/'//PATHX 
          CALL RZCDIR (PATHY, ' ')  
          IF (IQUEST(1).NE.0) THEN  
            CALL MZDROP (IDISDB, LAUXDL(10), ' ')   
            IQUEST(1) = 161 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOB : Ill'//    
     +      'egal pathname '//PATHY//''')', IARGDB, 0)  
            GO TO 999   
          ENDIF 
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          DO 35 JK = 1, NKEYDK  
            IK     = NKEYDK + 1 - JK    
            CALL DBKEYR (IK, NWKYDK, KEYVDK)    
            IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB)) 
     +                                                       GO TO 35   
            IF (KEYVDK(MBVRDB).GT.INOWS)                     GO TO 35   
            IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB)) 
     +                                                       GO TO 35   
            IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB)) 
     +                                                       GO TO 35   
            IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB)) 
     +                                                       GO TO 35   
            IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)    GO TO 35   
            IF (NWKYDK.GT.NSYSDK) THEN  
              DO 25 I = NSYSDK+1, NWKYDK    
                IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I)) GO TO 35   
   25         CONTINUE  
            ENDIF   
            NTOT   = NTOT + 1   
            IF (NSTEP.GT.1) THEN    
              IF (MOD(NTOT,NSTEP).NE.1)                      GO TO 35   
            ENDIF   
            LAUXDL(9) = 0   
            KTIME  = KEYVDK(KABS)   
            KYVAL  = KEYVDK(KPEX)   
            CALL VZERO_i (KEYVDK, NWKYDK) 
            KEYVDK(MSERDB) = IK 
            IOKYDA(MSERDB) = 1  
            CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9), JBIAS,    
     +                   NWKYDK, KEYVDK, IPREC) 
            IOKYDA(MSERDB) = 0  
            IF (IQUEST(1).NE.0) THEN    
              IF (LAUXDL(9).NE.0)   
     +          CALL MZDROP (IDISDB, LAUXDL(9), 'L')    
              NBAD   = NBAD + 1 
              IQUEST(1) = 0 
              GO TO 35  
            ENDIF   
            IF (NOBM.GT.IQ(KOFUDB+LAUXDL(9)-1)) THEN    
              NBAD   = NBAD + 1 
              CALL MZDROP (IDISDB, LAUXDL(9), 'L')  
              GO TO 35  
            ENDIF   
            IF (NPL.EQ.0) CALL DBIOTY (LAUXDL(9), NOBJ, KOBJ, IOTYDP)   
            NPL    = NPL + 1    
            IF (NPL.LE.NPLM) THEN   
              IPNT   = KOFUDB + LAUXDL(10) + (NPL - 1) * (NOBJ + 1) 
              IQ(IPNT+1) = KYVAL    
              DO 30 I = 1, NOBJ 
                IF (IOTYDP(I).EQ.1.OR.IOTYDP(I).EQ.2.OR.IOTYDP(I).EQ.5) 
     +                                                     THEN 
                  IVAL   = IQ(KOFUDB+LAUXDL(9)+KOBJ(I)) 
                  Q(IPNT+I+1) = IVAL    
                ELSE IF (IOTYDP(I).EQ.4) THEN   
                  CALL UCOPY (Q(KOFUDB+LAUXDL(9)+KOBJ(I)), fVAL, 2) 
                  Q(IPNT+I+1) = DVAL    
                ELSE    
                  Q(IPNT+I+1) = Q(KOFUDB+LAUXDL(9)+KOBJ(I)) 
                ENDIF   
                IF (Q(IPNT+I+1).GT.VMAXDP) VMAXDP = Q(IPNT+I+1) 
                IF (Q(IPNT+I+1).LT.VMINDP) VMINDP = Q(IPNT+I+1) 
   30         CONTINUE  
              IF (KTIME.LT.IMIN) IMIN = KTIME   
              IF (KTIME.GT.IMAX) IMAX = KTIME   
            ENDIF   
            CALL MZDROP (IDISDB, LAUXDL(9), 'L')    
   35     CONTINUE  
          CALL RZCDIR (PATH, ' ')   
          IF (IQUEST(1).NE.0) THEN  
            CALL MZDROP (IDISDB, LAUXDL(10), ' ')   
            IQUEST(1) = 161 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOB : Ill'//    
     +      'egal pathname '//PATH//''')', IARGDB, 0)   
            GO TO 999   
          ENDIF 
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          IF (NPL.GT.NPLM)                                   GO TO 45   
   40   CONTINUE    
*   
      ENDIF 
*   
* *** All points collected  
*   
   45 CONTINUE  
      iarg(1) = nbad
      IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBPLOB : Number of'//    
     +   ' bad objects '',I12)', iarg, 1)   
      IF (NPL.EQ.0) THEN    
        CALL MZDROP (IDISDB, LAUXDL(10), ' ')   
        GO TO 999   
      ENDIF 
      IF (NPL.GT.NPLM) THEN 
        IF (IDEBDB.GT.0) THEN   
          IARGDB(1) = NPL   
          IARGDB(2) = NPLM  
          CALL DBPRNT (LPRTDB, '(/,'' DBPLOB : Too many objects '','//  
     +         'I6,'' only '',I6,'' shown'')', IARGDB, 2)   
        ENDIF   
        NPL    = NPLM   
      ENDIF 
*   
* *** Sort the objects in increasing time   
*
      nio(1) = 0
      CALL DBBOOK (IDISDB, LAUXDL(9), LAUXDL(9), 2, 'TIME', 0, 0, 4*NPL,    
     +             nio, -1)   
      IF (IQUEST(1).NE.0) THEN  
        IER    = IQUEST(1)  
        CALL MZDROP (IDISDB, LAUXDL(10), ' ')   
        IQUEST(1) = IER 
        GO TO 999   
      ENDIF 
      DO 50 IK = 1, NPL 
        IQ(KOFUDB+LAUXDL(9)+IK) = IQ(KOFUDB+LAUXDL(10)+(IK-1)*(NOBJ+1)  
     +                              +1) 
   50 CONTINUE  
      CALL SORTZV (IQ(KOFUDB+LAUXDL(9)+1), IQ(KOFUDB+LAUXDL(9)+NPL+1),  
     +             NPL, -1, 0, 0)   
*   
* *** Set up the header 
*   
      IF (IMAX.GT.ITNOW) IMAX = ITNOW   
      IF (KABS.EQ.MITMDB) THEN  
        CALL DBUPTM (IDATX, ITIMX, IMIN)    
        ITIMX  = ITIMX * 100    
      ELSE  
        CALL DBUPTS (IDATX, ITIMX, IMIN)    
      ENDIF 
      CALL DBTIME (IDATX, ITIMX)    
      IBINDP(3) = IDATX/10000 + 1900    
      IBINDP(2) = MOD (IDATX/100, 100)  
      IBINDP(1) = MOD (IDATX    , 100)  
      CALL CALDAT (101, CHRPDP, IBINDP, IRET)   
      DYSTDP = CHRPDP(26:34)    
      IF (KABS.EQ.MITMDB) THEN  
        CALL DBUPTM (IDATX, ITIMX, IMAX)    
        ITIMX  = ITIMX * 100    
      ELSE  
        CALL DBUPTS (IDATX, ITIMX, IMAX)    
      ENDIF 
      CALL DBTIME (IDATX, ITIMX)    
      IBINDP(3) = IDATX/10000 + 1900    
      IBINDP(2) = MOD (IDATX/100, 100)  
      IBINDP(1) = MOD (IDATX    , 100)  
      CALL CALDAT (101, CHRPDP, IBINDP, IRET)   
      DYENDP = CHRPDP(26:34)    
*   
* *** Now setup the x-scale 
*   
      DO 55 IK = 1, NPL 
        IPNT   = IQ(KOFUDB+LAUXDL(9)+NPL+IK)    
        KYVAL  = IQ(KOFUDB+LAUXDL(9)+IPNT)  
        IF (KPEX.EQ.MBVRDB.OR.KPEX.EQ.MEVRDB.OR.KPEX.EQ.MITMDB) THEN    
          IF (KPEX.EQ.MITMDB) THEN  
            CALL DBUPTM (IDATX, ITIMX, KYVAL)   
            ITIMX  = ITIMX * 100    
          ELSE  
            CALL DBUPTS (IDATX, ITIMX, KYVAL)   
          ENDIF 
          CALL DBTIME (IDATX, ITIMX)    
          NHOUR  = ITIMX / 10000    
          NMIN   = MOD (ITIMX/100, 100) 
          NSEC   = MOD (ITIMX    , 100) 
          HOUR   = NHOUR + FLOAT(NMIN)/60.0 + FLOAT(NSEC)/3600.0    
          IBINDP(3) = IDATX/10000 + 1900    
          IBINDP(2) = MOD (IDATX/100, 100)  
          IBINDP(1) = MOD (IDATX    , 100)  
          CALL CALDAT (101, CHRPDP, IBINDP, IRET)   
          IF (IK.EQ.1) IDAY1 = IBINDP(6)    
          IDAY   = IBINDP(6) - IDAY1    
          HOUR   = HOUR + 24.0 * IDAY   
          Q(KOFUDB+LAUXDL(9)+2*NPL+IK) = HOUR   
        ELSE    
          Q(KOFUDB+LAUXDL(9)+2*NPL+IK) = KYVAL  
        ENDIF   
   55 CONTINUE  
      IF (KPEX.EQ.MBVRDB.OR.KPEX.EQ.MEVRDB.OR.KPEX.EQ.MITMDB) THEN  
        XMIN   = Q(KOFUDB+LAUXDL(9)+2*NPL+1) - 0.1  
        XMAX   = Q(KOFUDB+LAUXDL(9)+3*NPL)   + 0.1  
      ELSE  
        XMIN   = Q(KOFUDB+LAUXDL(9)+2*NPL+1) - 0.5  
        XMAX   = Q(KOFUDB+LAUXDL(9)+3*NPL)   + 0.5  
      ENDIF 
      CALL HTITLE (PATH)    
*   
* *** Now plot the object elements  
*   
      YRAN   = 0.1 * (VMAXDP - VMINDP)  
      YMIN   = VMINDP - YRAN    
      YMAX   = VMAXDP + YRAN    
      IF (IOPSDA.NE.0) THEN 
        WRITE (CTTLDP, 2001) KOBJ(1), CTAG, DYSTDP, DYENDP  
        IF (HEXIST(-101)) CALL HDELET (-101)    
        CALL HBOOK1 (-101, CTTLDP, 2, XMIN, XMAX, 0.)   
        CALL HPLOPT ('HORI', 1) 
        CALL HMINIM (-101, YMIN)    
        CALL HMAXIM (-101, YMAX)    
        CALL HPLOT  (-101, ' ', 'HIST', 0)  
      ENDIF 
      DO 70 IK = 1, NOBJ    
        IF (IOPSDA.EQ.0) THEN   
          WRITE (CTTLDP, 2002) KOBJ(IK), CTAG, DYSTDP, DYENDP   
          IF (HEXIST(-101)) CALL HDELET (-101)  
          CALL HBOOK1 (-101, CTTLDP, 2, XMIN, XMAX, 0.) 
          CALL HPLOPT ('HORI', 1)   
          CALL HMINIM (-101, YMIN)  
          CALL HMAXIM (-101, YMAX)  
          CALL HPLOT  (-101, ' ', 'HIST', 0)    
        ENDIF   
        KSYM   = MOD (IK, MXSYM)    
        IF (KSYM.EQ.0) THEN 
          ISYM   = ISYMB(MXSYM) 
        ELSE    
          ISYM   = ISYMB(KSYM)  
        ENDIF   
        DO 60 JK = 1, NPL   
          IPNT   = IQ(KOFUDB+LAUXDL(9)+NPL+JK)  
          KPNT   = (IPNT - 1) * (NOBJ + 1)  
          Q(KOFUDB+LAUXDL(9)+3*NPL+JK) = Q(KOFUDB+LAUXDL(10)+KPNT+IK+1) 
   60   CONTINUE    
        IF (IOPPDA.NE.0) THEN   
          CALL HPLSYM (Q(KOFUDB+LAUXDL(9)+2*NPL+1), 
     +                 Q(KOFUDB+LAUXDL(9)+3*NPL+1), NPL, ISYM, 0.1, ' ')    
        ENDIF   
        IF (IOPPDA.EQ.0.OR.IOPLDA.NE.0) THEN    
          CALL HPLINE (Q(KOFUDB+LAUXDL(9)+2*NPL+1), 
     +                 Q(KOFUDB+LAUXDL(9)+3*NPL+1), NPL, ' ')   
        ENDIF   
        IF (IOPSDA.EQ.0.AND.IK.NE.NOBJ) CALL DBUSIN 
   70 CONTINUE  
*   
   80 IF (LAUXDL(10).NE.0) CALL MZDROP (IDISDB, LAUXDL(10), ' ')    
      IF (LAUXDL(9) .NE.0) CALL MZDROP (IDISDB, LAUXDL(9),  ' ')    
      IF (HEXIST(-101)) CALL HDELET (-101)  
      IQUEST(1) = 0 
*   
 2001 FORMAT ('Object ',I6,',... vs. ',A16,1X,A9,' - ',A9)  
 2002 FORMAT ('Object ',I6,' vs. ',A16,1X,A9,' - ',A9)  
*                                                             END DBPLOB    
  999 END   
      SUBROUTINE DBPLOV (PATHN, KEYS, NOBJ, KOBJ, NST, CHOPT)   
*     =======================================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPLOV (PATHN, KEYS, NOBJ, KOBJ, NST, CHOPT)            *    
*                                                                      *    
*   Plots data elemnet(s) versus data element(s) for a given path name *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     KEYS     Vector of keys. Only the elements declared in CHOPT are *    
*              assumed to contain useful information.                  *    
*     NOBJ     Number of data objects to be plotted                    *    
*     KOBJ     Vector specifying the element numbers to be plotted     *    
*     NST      Step size for selection of object number                *    
*     CHOPT    Character string with any of the following characters   *    
*          L   line to be drawn through the points                     *    
*          P   a symbol to be drawn at each point                      *    
*              (If L or P not chosen, a default marker to be drawn     *    
*               at each point)                                         *    
*          3   selects objects with start validity time > KEYS(3)      *    
*          4   selects objects with start validity time < KEYS(4)      *    
*          5   specific Program version number required                *    
*          7   selects objects with insertion      time < KEYS(7)      *    
*          n   consider user key n (where 7 < n < 30)                  *    
*                                                                      *    
*   Called by user,   DBACPL                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =161 : Illegal path name                               *    
*               =162 : No keys or data in the directory                *    
*               =163 : Illegal number of objects                       *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (NOBMDP=50, NPLMDP=500, NPMXDP=10)    
      PARAMETER       (NMAXDP=2*NOBMDP) 
      COMMON /DPLOTS/ IBINDP(8), INDXDP(2,NOBMDP), KOBJDP(NMAXDP)   
     +              , NKSMDP(NPMXDP), NKSTDP(NPMXDP), NDSMDP(NPMXDP)    
     +              , NDSTDP(NPMXDP), IBEGDP(NPMXDP), NDEMDP(NPMXDP)    
     +              , IOTYDP(NMAXDP), NSKYDP(NPMXDP), NKEYDP(22,NPMXDP) 
     +              , KKEYDP(22,NPMXDP), VMAXDP, VMINDP 
      COMMON /DPLOCH/ CHRPDP, CTTLDP, DYENDP, DYSTDP    
      CHARACTER       CHRPDP*119, CTTLDP*73, DYENDP*9, DYSTDP*9 
*   
      LOGICAL         HEXIST    
      CHARACTER       PATH*80, PATHX*16, PATHY*80   
      CHARACTER       PATHN*(*), CHOPT*(*)  
      DIMENSION       KEYS(9), KOBJ(2,9)    
      DOUBLE PRECISION DVAL
      real fval(2)
      equivalence (dval, fval)
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension nio(9), iarg(9)
*     ------------------------------------------------------------------    
*   
* *** Decode the character option   
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)                                    GO TO 999  
      KABS   = 3    
      IF (NST.GT.0) THEN    
        NSTEP  = NST    
      ELSE  
        NSTEP  = 1  
      ENDIF 
      IF (NOBJ.LT.1.OR.NOBJ.GT.NOBMDP) THEN 
        IQUEST(1) = 163 
        IQUEST(11)= NOBJ    
        IQUEST(12)= NOBMDP
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOV : Illegal'//    
     +  ' number of objects '',2I12)', IQUEST(11), 2)   
        GO TO 999   
      ENDIF 
      NOBJDP = 0    
      NOBM   = KOBJ(1,1)    
      DO 5 IK = 1, NOBJ 
        II     = IUCOMP (KOBJ(1,IK), KOBJDP, NOBJDP)    
        IF (II.EQ.0) THEN   
          NOBJDP = NOBJDP + 1   
          II     = NOBJDP   
          KOBJDP(II) = KOBJ(1,IK)   
          IF (KOBJDP(II).GT.NOBM) NOBM = KOBJDP(II) 
        ENDIF   
        INDXDP(1,IK) = II   
        II     = IUCOMP (KOBJ(2,IK), KOBJDP, NOBJDP)    
        IF (II.EQ.0) THEN   
          NOBJDP = NOBJDP + 1   
          II     = NOBJDP   
          KOBJDP(II) = KOBJ(2,IK)   
        ENDIF   
        INDXDP(2,IK) = II   
    5 CONTINUE  
*   
* *** Suppress blanks from the pathname and sets current directory  
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 161 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOV : Ill'//    
     +  'egal pathname '//PATH//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
      CALL RZCDIR (PATH, 'R')   
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKEYT   
*   
      IF (NKEYDK.LE.0) THEN 
        IQUEST(1) = 162 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOV : No keys'//    
     +  ' in directory '//PATH//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
*   
      NCHR   = INDEX (PATH, ' ') - 1    
      IF (NCHR.LT.1) NCHR = MAXLDB  
      NCHRT  = INDEX (PATH(3:NCHR), '/') - 1    
      IF (NCHRT.LE.0) NCHRT = NCHR - 2  
      PATHX  = PATH(3:NCHRT+2)  
      LTOP   = LTOPDB   
    8 IF (LTOP.NE.0) THEN   
        NCHRT  = IQ(KOFUDB+LTOP+MUPNCH) 
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHRT)   
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN  
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 8   
        ENDIF   
        KY7MDB = IQ(KOFUDB+LTOP+MUPKY7) 
      ELSE  
        KY7MDB = 0  
      ENDIF 
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)   
      NTOT   = 0    
      NBAD   = 0    
*   
* *** Prepare a temporary storage for useful information    
*   
      CALL DATIME (IDATX, ITIMX)    
      CALL DBPKTS (IDATX, ITIMX*100, ITNOW) 
      NPLM   = NPLMDP   
      IF (IOPTP.EQ.0) THEN  
        IF (NKEYDK.LT.NPLM) NPLM = NKEYDK   
      ENDIF 
      ND     = (NOBJDP + 1) * NPLM  
      IF (LAUXDL(10).NE.0) CALL MZDROP (IDISDB, LAUXDL(10), 'L')
      nio(1) = 0
      CALL DBBOOK (IDISDB, LAUXDL(10), LAUXDL(10), 2, 'TEMP', 0, 0, ND, 
     +             nio, -1)   
      IF (IQUEST(1).NE.0)                                    GO TO 999  
      VMINDP = 9.0E20   
      VMAXDP =-9.0E20   
      IF (LAUXDL(9).NE.0) THEN  
        CALL MZDROP (IDISDB, LAUXDL(9), 'L')    
        LAUXDL(9) = 0   
      ENDIF 
*   
* *** Load useful data in the temporary bank    
*   
      IMIN   = ITNOW    
      IMAX   = -1   
      ITIME  = 1    
      JBIAS  = 2    
      NPL    = 0    
      IF (IOPTP.EQ.0) THEN  
        DO 20 JK = 1, NKEYDK    
          IK     = NKEYDK + 1 - JK  
          CALL DBKEYR (IK, NWKYDK, KEYVDK)  
          IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB))   
     +                                                       GO TO 20   
          IF (KEYVDK(MBVRDB).GT.ITNOW)                       GO TO 20   
          IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB))   
     +                                                       GO TO 20   
          IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))   
     +                                                       GO TO 20   
          IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))   
     +                                                       GO TO 20   
          IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)      GO TO 20   
          IF (NWKYDK.GT.NSYSDK) THEN    
            DO 10 I = NSYSDK+1, NWKYDK  
              IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I))   GO TO 20   
   10       CONTINUE    
          ENDIF 
          NTOT   = NTOT + 1 
          IF (NSTEP.GT.1) THEN  
            IF (MOD(NTOT,NSTEP).NE.1)                        GO TO 20   
          ENDIF 
          LAUXDL(9) = 0 
          KTIME  = KEYVDK(KABS) 
          CALL VZERO_i (KEYVDK, NWKYDK)   
          KEYVDK(MSERDB) = IK   
          IOKYDA(MSERDB) = 1    
          CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9), JBIAS,  
     +                 NWKYDK, KEYVDK, IPREC)   
          IOKYDA(MSERDB) = 0    
          IF (IQUEST(1).NE.0) THEN  
            IF (LAUXDL(9).NE.0) 
     +        CALL MZDROP (IDISDB, LAUXDL(9), 'L')  
            IQUEST(1) = 0   
            NBAD   = NBAD + 1   
            GO TO 20    
          ENDIF 
          IF (NOBM.GT.IQ(KOFUDB+LAUXDL(9)-1)) THEN  
            NBAD   = NBAD + 1   
            CALL MZDROP (IDISDB, LAUXDL(9), 'L')    
            GO TO 20    
          ENDIF 
          IF (NPL.EQ.0) CALL DBIOTY (LAUXDL(9), NOBJDP, KOBJDP, IOTYDP) 
          NPL    = NPL + 1  
          IF (NPL.LE.NPLM) THEN 
            IPNT   = KOFUDB + LAUXDL(10) + (NPL - 1) * (NOBJDP + 1) 
            IQ(IPNT+1) = KTIME  
            DO 15 I = 1, NOBJDP 
              IF (IOTYDP(I).EQ.1.OR.IOTYDP(I).EQ.2.OR.IOTYDP(I).EQ.5)   
     +                                                     THEN 
                IVAL   = IQ(KOFUDB+LAUXDL(9)+KOBJDP(I)) 
                Q(IPNT+I+1) = IVAL  
              ELSE IF (IOTYDP(I).EQ.4) THEN 
                CALL UCOPY (Q(KOFUDB+LAUXDL(9)+KOBJDP(I)), fVAL, 2) 
                Q(IPNT+I+1) = DVAL  
              ELSE  
                Q(IPNT+I+1) = Q(KOFUDB+LAUXDL(9)+KOBJDP(I)) 
              ENDIF 
              IF (Q(IPNT+I+1).GT.VMAXDP) VMAXDP = Q(IPNT+I+1)   
              IF (Q(IPNT+I+1).LT.VMINDP) VMINDP = Q(IPNT+I+1)   
   15       CONTINUE    
            IF (KTIME.LT.IMIN) IMIN = KTIME 
            IF (KTIME.GT.IMAX) IMAX = KTIME 
          ENDIF 
          CALL MZDROP (IDISDB, LAUXDL(9), ' ')  
   20   CONTINUE    
*   
      ELSE  
        KST    = NWKYDK + 1 
        NKEYS  = NKEYDK 
        DO 40 JKK = 1, NKEYS    
          IKK    = NKEYS + 1 - JKK  
          KPNT   = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),    
     +                     NKEYS*KST, KST)  
          IF (KPNT.GT.0) THEN   
            KPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB   
          ELSE  
            KPNT   = KOFSDB + LCDRDB + IKDRDB + (IKK - 1) * KST 
          ENDIF 
          IF (IOKYDA(MBVRDB).NE.0.AND.IQ(KPNT+MEVRDB).LT.KEYS(MBVRDB))  
     +                                                       GO TO 40   
          IF (IQ(KPNT+MBVRDB).GT.ITNOW)                      GO TO 40   
          IF (IOKYDA(MEVRDB).NE.0.AND.IQ(KPNT+MBVRDB).GT.KEYS(MEVRDB))  
     +                                                       GO TO 40   
          IF (IOKYDA(MITMDB).NE.0.AND.IQ(KPNT+MITMDB).GT.KEYS(MITMDB))  
     +                                                       GO TO 40   
          IF (KY7MDB.GT.0.AND.IQ(KPNT+MITMDB).GT.KY7MDB)     GO TO 40   
*   
          CALL DBPATH (PATHX, IKK)  
          PATHY  = PATH(1:NCHR)//'/'//PATHX 
          CALL RZCDIR (PATHY, ' ')  
          IF (IQUEST(1).NE.0) THEN  
            CALL MZDROP (IDISDB, LAUXDL(10), ' ')   
            IQUEST(1) = 161 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOV : Ill'//    
     +      'egal pathname '//PATHY//''')', IARGDB, 0)  
            GO TO 999   
          ENDIF 
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          DO 35 JK = 1, NKEYDK  
            IK     = NKEYDK + 1 - JK    
            CALL DBKEYR (IK, NWKYDK, KEYVDK)    
            IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB)) 
     +                                                       GO TO 35   
            IF (KEYVDK(MBVRDB).GT.ITNOW)                     GO TO 35   
            IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB)) 
     +                                                       GO TO 35   
            IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB)) 
     +                                                       GO TO 35   
            IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB)) 
     +                                                       GO TO 35   
            IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)    GO TO 35   
            IF (NWKYDK.GT.NSYSDK) THEN  
              DO 25 I = NSYSDK+1, NWKYDK    
                IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I)) GO TO 35   
   25         CONTINUE  
            ENDIF   
            NTOT   = NTOT + 1   
            IF (NSTEP.GT.1) THEN    
              IF (MOD(NTOT,NSTEP).NE.1)                      GO TO 35   
            ENDIF   
            LAUXDL(9) = 0   
            KTIME  = KEYVDK(KABS)   
            CALL VZERO_i (KEYVDK, NWKYDK) 
            KEYVDK(MSERDB) = IK 
            IOKYDA(MSERDB) = 1  
            CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9), JBIAS,    
     +                   NWKYDK, KEYVDK, IPREC) 
            IOKYDA(MSERDB) = 0  
            IF (IQUEST(1).NE.0) THEN    
              IF (LAUXDL(9).NE.0)   
     +          CALL MZDROP (IDISDB, LAUXDL(9), 'L')    
              IQUEST(1) = 0 
              NBAD   = NBAD + 1 
              GO TO 35  
            ENDIF   
            IF (NOBM.GT.IQ(KOFUDB+LAUXDL(9)-1)) THEN    
              NBAD   = NBAD + 1 
              CALL MZDROP (IDISDB, LAUXDL(9), 'L')  
              GO TO 35  
            ENDIF   
            IF (NPL.EQ.0) CALL DBIOTY (LAUXDL(9), NOBJDP,KOBJDP, IOTYDP)    
            NPL    = NPL + 1    
            IF (NPL.LE.NPLM) THEN   
              IPNT   = KOFUDB + LAUXDL(10) + (NPL - 1) * (NOBJDP + 1)   
              IQ(IPNT+1) = KTIME    
              DO 30 I = 1, NOBJDP   
                IF (IOTYDP(I).EQ.1.OR.IOTYDP(I).EQ.2.OR.IOTYDP(I).EQ.5) 
     +                                                     THEN 
                  IVAL   = IQ(KOFUDB+LAUXDL(9)+KOBJDP(I))   
                  Q(IPNT+I+1) = IVAL    
                ELSE IF (IOTYDP(I).EQ.4) THEN   
                  CALL UCOPY (Q(KOFUDB+LAUXDL(9)+KOBJDP(I)), fVAL, 2)   
                  Q(IPNT+I+1) = DVAL    
                ELSE    
                  Q(IPNT+I+1) = Q(KOFUDB+LAUXDL(9)+KOBJDP(I))   
                ENDIF   
                IF (Q(IPNT+I+1).GT.VMAXDP) VMAXDP = Q(IPNT+I+1) 
                IF (Q(IPNT+I+1).LT.VMINDP) VMINDP = Q(IPNT+I+1) 
   30         CONTINUE  
              IF (KTIME.LT.IMIN) IMIN = KTIME   
              IF (KTIME.GT.IMAX) IMAX = KTIME   
            ENDIF   
            CALL MZDROP (IDISDB, LAUXDL(9), ' ')    
   35     CONTINUE  
          CALL RZCDIR (PATH, ' ')   
          IF (IQUEST(1).NE.0) THEN  
            CALL MZDROP (IDISDB, LAUXDL(10), ' ')   
            IQUEST(1) = 161 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOV : Ill'//    
     +      'egal pathname '//PATH//''')', IARGDB, 0)   
            GO TO 999   
          ENDIF 
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          IF (NPL.GT.NPLM)                                   GO TO 45   
   40   CONTINUE    
*   
      ENDIF 
*   
* *** All points collected  
*   
   45 CONTINUE  
      iarg(1) = nbad
      IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBPLOV : Number of'//    
     +   ' bad objects '',I12)', iarg, 1)   
      IF (NPL.EQ.0) THEN    
        CALL MZDROP (IDISDB, LAUXDL(10), ' ')   
        GO TO 999   
      ENDIF 
      IF (NPL.GT.NPLM) THEN 
        IF (IDEBDB.GT.0) THEN   
          IARGDB(1) = NPL   
          IARGDB(1) = NPLM  
          CALL DBPRNT (LPRTDB, '(/,'' DBPLOV : Too many objects '','//  
     +         'I6,'' only '',I6,'' shown'')', IARGDB, 2)   
        ENDIF   
        NPL    = NPLM   
      ENDIF 
*   
* *** Sort the objects in increasing time   
*
      nio(1) = 0
      CALL DBBOOK (IDISDB, LAUXDL(9), LAUXDL(9), 2, 'TIME', 0, 0, 4*NPL,    
     +             nio, -1)   
      IF (IQUEST(1).NE.0) THEN  
        IER    = IQUEST(1)  
        CALL MZDROP (IDISDB, LAUXDL(10), ' ')   
        IQUEST(1) = IER 
        GO TO 999   
      ENDIF 
      DO 50 IK = 1, NPL 
        IQ(KOFUDB+LAUXDL(9)+IK) = IQ(KOFUDB+LAUXDL(10)+(IK-1)*(NOBJDP+1)    
     +                              +1) 
   50 CONTINUE  
      CALL SORTZV (IQ(KOFUDB+LAUXDL(9)+1), IQ(KOFUDB+LAUXDL(9)+NPL+1),  
     +             NPL, -1, 0, 0)   
*   
* *** Set up the header 
*   
      IF (IMAX.GT.ITNOW) IMAX = ITNOW   
      CALL DBUPTS (IDATX, ITIMX, IMIN)  
      CALL DBTIME (IDATX, ITIMX)    
      IBINDP(3) = IDATX/10000 + 1900    
      IBINDP(2) = MOD (IDATX/100, 100)  
      IBINDP(1) = MOD (IDATX    , 100)  
      CALL CALDAT (101, CHRPDP, IBINDP, IRET)   
      DYSTDP = CHRPDP(26:34)    
      CALL DBUPTS (IDATX, ITIMX, IMAX)  
      CALL DBTIME (IDATX, ITIMX)    
      IBINDP(3) = IDATX/10000 + 1900    
      IBINDP(2) = MOD (IDATX/100, 100)  
      IBINDP(1) = MOD (IDATX    , 100)  
      CALL CALDAT (101, CHRPDP, IBINDP, IRET)   
      DYENDP = CHRPDP(26:34)    
      CALL HTITLE (PATH)    
      CALL HPLOPT ('HORI', 1)   
*   
* *** Now make the plots    
*   
      DO 70 JK = 1, NOBJ    
        IK1    = INDXDP(1,JK)   
        IK2    = INDXDP(2,JK)   
        WRITE (CTTLDP, 2000) KOBJDP(IK2), KOBJDP(IK1), DYSTDP, DYENDP   
        XRAN   = 0.1 * (VMAXDP - VMINDP)    
        IF (XRAN.EQ.0.0) XRAN = 0.01    
        XMIN   = VMINDP - XRAN  
        XMAX   = VMAXDP + XRAN  
        YRAN   = 0.1 * (VMAXDP - VMINDP)    
        IF (YRAN.EQ.0.0) YRAN = 0.01    
        YMIN   = VMINDP - YRAN  
        YMAX   = VMAXDP + YRAN  
        IF (HEXIST(-101)) CALL HDELET (-101)    
        CALL HBOOK1 (-101, CTTLDP, 2, XMIN, XMAX, 0.)   
        CALL HMINIM (-101, YMIN)    
        CALL HMAXIM (-101, YMAX)    
        DO 60 IK = 1, NPL   
          IPNT   = IQ(KOFUDB+LAUXDL(9)+NPL+IK)  
          KPNT   = KOFUDB + LAUXDL(10) + (IPNT - 1) * (NOBJDP + 1) + 1  
          Q(KOFUDB+LAUXDL(9)+2*NPL+IK) = Q(KPNT+IK1)    
          Q(KOFUDB+LAUXDL(9)+3*NPL+IK) = Q(KPNT+IK2)    
   60   CONTINUE    
        CALL HPLOT  (-101, ' ', 'HIST', 0)  
        IF (IOPPDA.NE.0) THEN   
          CALL HPLSYM (Q(KOFUDB+LAUXDL(9)+2*NPL+1), 
     +                 Q(KOFUDB+LAUXDL(9)+3*NPL+1), NPL, 31, 0.1, ' ')  
        ELSE IF (IOPLDA.NE.0) THEN  
          CALL HPLINE (Q(KOFUDB+LAUXDL(9)+2*NPL+1), 
     +                 Q(KOFUDB+LAUXDL(9)+3*NPL+1), NPL, ' ')   
        ELSE    
          CALL HPLSYM (Q(KOFUDB+LAUXDL(9)+2*NPL+1), 
     +                 Q(KOFUDB+LAUXDL(9)+3*NPL+1), NPL, 24, 0.05, ' ') 
        ENDIF   
        IF (JK.NE.NOBJ) CALL DBUSIN 
   70 CONTINUE  
*   
   80 IF (LAUXDL(10).NE.0) CALL MZDROP (IDISDB, LAUXDL(10), ' ')    
      IF (LAUXDL(9) .NE.0) CALL MZDROP (IDISDB, LAUXDL(9),  ' ')    
      IF (HEXIST(-101)) CALL HDELET (-101)  
      IQUEST(1) = 0 
*   
 2000 FORMAT ('Object ',I5,' vs. Object ',I5,5X,A9,' - ',A9)    
*                                                             END DBPLOV    
  999 END   
      SUBROUTINE DBPLTI (PATHN, KEYS, CHOPT)    
*     ======================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPLTI (PATHN, KEYS, CHOPT)                             *    
*                                                                      *    
*   Plots the validity time of data objects in a given directory       *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     KEYS     Vector of keys. Only the elements declared in CHOPT are *    
*              assumed to contain useful information.                  *    
*     CHOPT    Character string with any of the following characters   *    
*          3   selects objects with start validity time > KEYS(3)      *    
*          4   selects objects with start validity time < KEYS(4)      *    
*          5   specific Program version number required                *    
*          7   selects objects with insertion      time < KEYS(7)      *    
*          n   consider user key n (where 7 < n < 30)                  *    
*                                                                      *    
*   Called by user,   DBACPL                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =161 : Illegal path name                               *    
*               =162 : No keys or data in the directory                *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (NOBMDP=50, NPLMDP=500, NPMXDP=10)    
      PARAMETER       (NMAXDP=2*NOBMDP) 
      COMMON /DPLOTS/ IBINDP(8), INDXDP(2,NOBMDP), KOBJDP(NMAXDP)   
     +              , NKSMDP(NPMXDP), NKSTDP(NPMXDP), NDSMDP(NPMXDP)    
     +              , NDSTDP(NPMXDP), IBEGDP(NPMXDP), NDEMDP(NPMXDP)    
     +              , IOTYDP(NMAXDP), NSKYDP(NPMXDP), NKEYDP(22,NPMXDP) 
     +              , KKEYDP(22,NPMXDP), VMAXDP, VMINDP 
      COMMON /DPLOCH/ CHRPDP, CTTLDP, DYENDP, DYSTDP    
      CHARACTER       CHRPDP*119, CTTLDP*73, DYENDP*9, DYSTDP*9 
*   
      LOGICAL         HEXIST    
      CHARACTER       PATH*80, PATHX*16, PATHY*80, PATHN*(*), CHOPT*(*) 
      DIMENSION       KEYS(9), XU(2), YU(2) 
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension nio(9)
*     ------------------------------------------------------------------    
*   
* *** Decode the character option   
*   
      CALL DBOPTS (CHOPT)   
      IF (IQUEST(1).NE.0)                                    GO TO 999  
*   
* *** Suppress blanks from the pathname and sets current directory  
*   
      CALL DBSBLC (PATHN, PATH, NCHAR)  
      CALL RZCDIR (PATH, ' ')   
      IF (IQUEST(1).NE.0) THEN  
        IQUEST(1) = 161 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLTI : Ill'//    
     +  'egal pathname '//PATH//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
      CALL RZCDIR (PATH, 'R')   
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKEYT   
      IF (NKEYDK.LE.0) THEN 
        IQUEST(1) = 162 
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLTI : No keys'//    
     +  ' in directory '//PATH//''')', IARGDB, 0)   
        GO TO 999   
      ENDIF 
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)   
*   
* *** Prepare a temporary storage for useful information    
*   
      CALL DATIME (IDATX, ITIMX)    
      CALL DBPKTS (IDATX, ITIMX*100, ITNOW) 
      NPLM   = NPLMDP   
      IF (IOPTP.EQ.0) THEN  
        IF (NKEYDK.LT.NPLM) NPLM = NKEYDK   
      ENDIF 
      ND     = 3 * NPLM 
      IF (LAUXDL(10).NE.0) CALL MZDROP (IDISDB, LAUXDL(10), 'L')
      nio(1) = 2
      CALL DBBOOK (IDISDB, LAUXDL(10), LAUXDL(10), 2, 'TEMP', 0, 0, ND, 
     +             nio, -1)   
      IF (IQUEST(1).NE.0)                                    GO TO 999  
*   
* *** Load useful data in the temporary bank    
*   
      IMIN   = ITNOW    
      IMAX   = -1   
      NPL    = 0    
      IKMAX  = 0    
      IF (IOPTP.EQ.0) THEN  
        DO 15 JK = 1, NKEYDK    
          IK     = NKEYDK + 1 - JK  
          CALL DBKEYR (IK, NWKYDK, KEYVDK)  
          IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB))   
     +                                                       GO TO 15   
          IF (KEYVDK(MBVRDB).GT.ITNOW)                       GO TO 15   
          IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB))   
     +                                                       GO TO 15   
          IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))   
     +                                                       GO TO 15   
          IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))   
     +                                                       GO TO 15   
          IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)      GO TO 15   
          IF (NWKYDK.GT.NSYSDK) THEN    
            DO 10 I = NSYSDK+1, NWKYDK  
              IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I))   GO TO 15   
   10       CONTINUE    
          ENDIF 
          NPL    = NPL + 1  
          IF (NPL.LE.NPLM) THEN 
            IPNT   = KOFUDB + LAUXDL(10) + (NPL - 1) * 3    
            IQ(IPNT+1) = KEYVDK(MSERDB) 
            IQ(IPNT+2) = KEYVDK(MBVRDB) 
            IQ(IPNT+3) = KEYVDK(MEVRDB) 
            IF (KEYVDK(MEVRDB).GT.IMAX)  IMAX  = KEYVDK(MEVRDB) 
            IF (KEYVDK(MBVRDB).LT.IMIN)  IMIN  = KEYVDK(MBVRDB) 
            IF (IKMAX.LT.KEYVDK(MSERDB)) IKMAX = KEYVDK(MSERDB) 
          ENDIF 
   15   CONTINUE    
*   
      ELSE  
        KST    = NWKYDK + 1 
        NKEYS  = NKEYDK 
        NCHR   = INDEX (PATH, ' ') - 1  
        IF (NCHR.LT.1) NCHR = MAXLDB    
        DO 30 JKK = 1, NKEYS    
          IKK    = NKEYS + 1 - JKK  
          KPNT   = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),    
     +                     NKEYS*KST, KST)  
          IF (KPNT.GT.0) THEN   
            KPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB   
          ELSE  
            KPNT   = KOFSDB + LCDRDB + IKDRDB + (IKK - 1) * KST 
          ENDIF 
          IF (IOKYDA(MBVRDB).NE.0.AND.IQ(KPNT+MEVRDB).LT.KEYS(MBVRDB))  
     +                                                       GO TO 30   
          IF (IQ(KPNT+MBVRDB).GT.ITNOW)                      GO TO 30   
          IF (IOKYDA(MEVRDB).NE.0.AND.IQ(KPNT+MBVRDB).GT.KEYS(MEVRDB))  
     +                                                       GO TO 30   
          IF (IOKYDA(MITMDB).NE.0.AND.IQ(KPNT+MITMDB).GT.KEYS(MITMDB))  
     +                                                       GO TO 30   
          IF (KY7MDB.GT.0.AND.IQ(KPNT+MITMDB).GT.KY7MDB)     GO TO 30   
*   
          CALL DBPATH (PATHX, IKK)  
          PATHY  = PATH(1:NCHR)//'/'//PATHX 
          CALL RZCDIR (PATHY, ' ')  
          IF (IQUEST(1).NE.0) THEN  
            CALL MZDROP (IDISDB, LAUXDL(10), ' ')   
            IQUEST(1) = 161 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLTI : Ill'//    
     +      'egal pathname '//PATHY//''')', IARGDB, 0)  
            GO TO 999   
          ENDIF 
          NKEYDK = IQUEST(7)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          DO 25 JK = 1, NKEYDK  
            IK     = NKEYDK + 1 - JK    
            CALL DBKEYR (IK, NWKYDK, KEYVDK)    
            IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB)) 
     +                                                       GO TO 25   
            IF (KEYVDK(MBVRDB).GT.ITNOW)                     GO TO 25   
            IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB)) 
     +                                                       GO TO 25   
            IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB)) 
     +                                                       GO TO 25   
            IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB)) 
     +                                                       GO TO 25   
            IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)    GO TO 25   
            IF (NWKYDK.GT.NSYSDK) THEN  
              DO 20 I = NSYSDK+1, NWKYDK    
                IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I)) GO TO 25   
   20         CONTINUE  
            ENDIF   
            NPL    = NPL + 1    
            IF (NPL.LE.NPLM) THEN   
              IPNT   = KOFUDB + LAUXDL(10) + (NPL - 1) * 3  
              IQ(IPNT+1) = KEYVDK(MSERDB)   
              IQ(IPNT+2) = KEYVDK(MBVRDB)   
              IQ(IPNT+3) = KEYVDK(MEVRDB)   
              IF (KEYVDK(MEVRDB).GT.IMAX)  IMAX  = KEYVDK(MEVRDB)   
              IF (KEYVDK(MBVRDB).LT.IMIN)  IMIN  = KEYVDK(MBVRDB)   
              IF (IKMAX.LT.KEYVDK(MSERDB)) IKMAX = KEYVDK(MSERDB)   
            ENDIF   
   25     CONTINUE  
          CALL RZCDIR (PATH, ' ')   
          IF (IQUEST(1).NE.0) THEN  
            CALL MZDROP (IDISDB, LAUXDL(10), ' ')   
            IQUEST(1) = 161 
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLTI : Ill'//    
     +      'egal pathname '//PATH//''')', IARGDB, 0)   
            GO TO 999   
          ENDIF 
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          IF (NPL.GT.NPLM)                                   GO TO 35   
   30   CONTINUE    
*   
      ENDIF 
*   
* *** All points collected; now decide the scale and header 
*   
   35 IF (NPL.EQ.0) THEN    
        CALL MZDROP (IDISDB, LAUXDL(10), ' ')   
        GO TO 999   
      ENDIF 
      IF (NPL.GT.NPLM) THEN 
        IF (IDEBDB.GT.0) THEN   
          IARGDB(1) = NPL   
          IARGDB(2) = NPLM  
          CALL DBPRNT (LPRTDB, '(/,'' DBPLTI : Too many objects '','//  
     +         'I6,'' only '',I6,'' shown'')', IARGDB, 2)   
        ENDIF   
        NPL    = NPLM   
      ENDIF 
      IF (IMAX.GT.ITNOW) IMAX = ITNOW   
      CALL DBUPTS (IDATX, ITIMX, IMIN)  
      CALL DBTIME (IDATX, ITIMX)    
      IBINDP(3) = IDATX/10000 + 1900    
      IBINDP(2) = MOD (IDATX/100, 100)  
      IBINDP(1) = MOD (IDATX    , 100)  
      CALL CALDAT (101, CHRPDP, IBINDP, IRET)   
      DYSTDP = CHRPDP(26:34)    
      IDAY1  = IBINDP(6)    
      CALL DBUPTS (IDATX, ITIMX, IMAX)  
      CALL DBTIME (IDATX, ITIMX)    
      IBINDP(3) = IDATX/10000 + 1900    
      IBINDP(2) = MOD (IDATX/100, 100)  
      IBINDP(1) = MOD (IDATX    , 100)  
      CALL CALDAT (101, CHRPDP, IBINDP, IRET)   
      DYENDP = CHRPDP(26:34)    
      IDAY2  = IBINDP(6) - IDAY1 + 1    
      TMAX   = 24.0 * IDAY2 
      WRITE (CTTLDP, 2000) DYSTDP, DYENDP   
      IF (HEXIST(-101)) CALL HDELET (-101)  
      CALL HBOOK1 (-101, CTTLDP, 2, 0., TMAX, 0.)   
      CALL HMINIM (-101, 0.)    
      CALL HMAXIM (-101, FLOAT(IKMAX)+2.)   
      CALL HTITLE (PATH)    
      CALL HPLOPT ('HORI', 1)   
      CALL HPLOT  (-101, ' ', 'HIST', 0)    
*   
* *** Now plot the keys 
*   
      DO 40 JK = 1, NPL 
        IPNT   = KOFUDB + LAUXDL(10) + (JK - 1) * 3 
        IK     = IQ(IPNT+1) 
        CALL DBUPTS (IDATX, ITIMX, IQ(IPNT+2))  
        CALL DBTIME (IDATX, ITIMX)  
        IBINDP(3) = IDATX/10000 + 1900  
        IBINDP(2) = MOD (IDATX/100, 100)    
        IBINDP(1) = MOD (IDATX    , 100)    
        CALL CALDAT (101, CHRPDP, IBINDP, IRET) 
        IDAY   = IBINDP(6) - IDAY1  
        NHOUR  = ITIMX / 10000  
        NMIN   = MOD (ITIMX/100, 100)   
        NSEC   = MOD (ITIMX    , 100)   
        HOURS  = NHOUR + FLOAT(NMIN)/60. + FLOAT(NSEC)/3600.    
        XU(1)  = HOURS + 24.0 * IDAY    
        CALL DBUPTS (IDATX, ITIMX, IQ(IPNT+MBVRDB)) 
        CALL DBTIME (IDATX, ITIMX)  
        IBINDP(3) = IDATX/10000 + 1900  
        IBINDP(2) = MOD (IDATX/100, 100)    
        IBINDP(1) = MOD (IDATX    , 100)    
        CALL CALDAT (101, CHRPDP, IBINDP, IRET) 
        IDAY   = IBINDP(6) - IDAY1  
        NHOUR  = ITIMX / 10000  
        NMIN   = MOD (ITIMX/100, 100)   
        NSEC   = MOD (ITIMX    , 100)   
        HOURS  = NHOUR + FLOAT(NMIN)/60. + FLOAT(NSEC)/3600.    
        XU(2)  = HOURS + 24.0 * IDAY    
        IF (XU(2).GT.TMAX) XU(2) = TMAX 
        YU(1)  = FLOAT(IK)  
        YU(2)  = YU(1)  
        CALL HPLINE (XU, YU, 2, ' ')    
   40 CONTINUE  
*   
   50 IF (LAUXDL(10).NE.0) CALL MZDROP (IDISDB, LAUXDL(10), ' ')    
      IF (HEXIST(-101)) CALL HDELET (-101)  
      IQUEST(1) = 0 
*   
 2000 FORMAT ('Object Validity Range during ',A9,' - ',A9)  
*                                                             END DBPLTI    
  999 END   
      SUBROUTINE DBTIME (IDATX, ITIMX)  
*     ================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBTIME (*IDATX*, *ITIMX*)                               *    
*                                                                      *    
*   Checks the date and time for plotting purpose                      *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IDATX    Date : 6 Decimal integer : YYMMDD                       *    
*     ITIMX    Time : 6 Decimal integer : HHMMSS                       *    
*                                                                      *    
*   Called by DBPLOB, DBPLOV, DBPLTI                                   *    
*                                                                      *    
************************************************************************    
*   
      DIMENSION       IDAYM(12) 
      DATA            IDAYM /31, 28, 31, 30, 31, 30,    
     +                       31, 31, 30, 31, 30, 31/    
*   
*     ------------------------------------------------------------------    
*   
      ISEC = MOD (ITIMX, 100)   
      IMIN = MOD (ITIMX/100, 100)   
      IHOU = MOD (ITIMX/10000, 100) 
*   
      IDAY = MOD (IDATX, 100)   
      IMON = MOD (IDATX/100, 100)   
      IYEA = MOD (IDATX/10000, 100) 
*   
      IF (ISEC.GT.59) THEN  
        ISEC = 59   
      ELSE IF (ISEC.LT.0) THEN  
        ISEC = 0    
      ENDIF 
      IF (IMIN.GT.59) THEN  
        IMIN = 59   
      ELSE IF (IMIN.LT.0) THEN  
        IMIN = 0    
      ENDIF 
      IF (IHOU.GT.23) THEN  
        IHOU = 23   
      ELSE IF (IHOU.LT.0) THEN  
        IHOU = 0    
      ENDIF 
      IF (IMON.LT.1) THEN   
        IMON = 1    
      ELSE IF (IMON.GT.12) THEN 
        IMON = 12   
      ENDIF 
      IF (IDAY.LT.1) THEN   
        IDAY = 1    
      ELSE IF (IDAY.GT.IDAYM(IMON)) THEN    
        IDAY = IDAYM(IMON)  
      ENDIF 
      IDATX = IYEA*10000 + IMON*100 + IDAY  
      ITIMX = IHOU*10000 + IMIN*100 + ISEC  
*                                                             END DBTIME    
      END   
      SUBROUTINE DBUSIN 
*     ================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBUSIN                                                  *    
*                                                                      *    
*   Default user routine for action needed in between 2 plots          *    
*                                                                      *    
*   Called by DBPLOB, DBPLOV                                           *    
*                                                                      *    
************************************************************************    
*   
      IWKST  = 1    
      CALL IGSA (IWKST) 
*                                                             END DBUSIN    
      END   
      SUBROUTINE DBUTIM (IDATM, IMINS)  
*     ================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBUTIM (IDATM, IMINS*)                                  *    
*                                                                      *    
*   Computes number of minutes passed since midnight of January 1,1980 *    
*   from the packed date and time (ala DBPKTM)                         *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IDATM    Packed date-time                                        *    
*     IMINS*   Number of minutes passed from 00.00 on Jan 1, 1980      *    
*                                                                      *    
*   Called by DBPLNT                                                   *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXSEC=61, MXMIN=61, MXHOU=25, MXDAY=32, MXMON=13)    
      INTEGER         IDAYY(20), IDAYM(12,2)    
      SAVE            IDAYY, IDAYM  
      DATA            IDAYY / 366,  731, 1096, 1461, 1827, 2192, 2557,  
     1                       2922, 3288, 3653, 4018, 4383, 4749, 5114,  
     2                       5479, 5844, 6210, 6575, 6940, 7305/    
      DATA            IDAYM / 0,  31,  59,  90, 120, 151, 181, 212, 243,    
     1                      273, 304, 334,   0,  31,  60,  91, 121, 152,    
     2                      182, 213, 244, 274, 305, 335/   
*   
*     ------------------------------------------------------------------    
*   
      III  = IDATM  
      IMIN = MOD (III, MXMIN)   
      III  = (III-IMIN)/MXMIN   
      IHOU = MOD (III, MXHOU)   
      III  = (III-IHOU)/MXHOU   
      IDAY = MOD (III, MXDAY)   
      III  = (III-IDAY)/MXDAY   
      IMON = MOD (III, MXMON)   
      IYEA = (III-IMON)/MXMON - 80  
      IF (IYEA.LT.1) THEN   
        IADD = 0    
        ITYP = 2    
      ELSE IF (IYEA.GT.20) THEN 
        IADD = IDAYY(20)    
        ITYP = 2    
      ELSE  
        IADD = IDAYY(IYEA)  
        ITYP = MOD (IYEA, 4)    
        IF (ITYP.EQ.0) THEN 
          ITYP = 2  
        ELSE    
          ITYP = 1  
        ENDIF   
      ENDIF 
*   
      IDAYS = IDAY + IADD + IDAYM(IMON,ITYP)    
      IMINS = IMIN + 60*(IHOU + 24*IDAYS)   
*                                                             END DBUTIM    
      END   
      SUBROUTINE DBUTIS (IDATM, ISECS)  
*     ================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBUTIS (IDATM, ISECS*)                                  *    
*                                                                      *    
*   Computes number of seconds passed since midnight of January 1,1980 *    
*   from the packed date and time (ala DBPKTS)                         *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IDATM    Packed date-time                                        *    
*     IMINS*   Number of seconds passed from 00.00 on Jan 1, 1980      *    
*                                                                      *    
*   Called by DBPLNT                                                   *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXSEC=61, MXMIN=61, MXHOU=25, MXDAY=32, MXMON=13)    
      INTEGER         IDAYY(20), IDAYM(12,2)    
      SAVE            IDAYY, IDAYM  
      DATA            IDAYY / 366,  731, 1096, 1461, 1827, 2192, 2557,  
     1                       2922, 3288, 3653, 4018, 4383, 4749, 5114,  
     2                       5479, 5844, 6210, 6575, 6940, 7305/    
      DATA            IDAYM / 0,  31,  59,  90, 120, 151, 181, 212, 243,    
     1                      273, 304, 334,   0,  31,  60,  91, 121, 152,    
     2                      182, 213, 244, 274, 305, 335/   
*   
*     ------------------------------------------------------------------    
*   
      III  = IDATM  
      ISEC = MOD (III, MXSEC)   
      III  = (III-ISEC)/MXSEC   
      IMIN = MOD (III, MXMIN)   
      III  = (III-IMIN)/MXMIN   
      IHOU = MOD (III, MXHOU)   
      III  = (III-IHOU)/MXHOU   
      IDAY = MOD (III, MXDAY)   
      III  = (III-IDAY)/MXDAY   
      IMON = MOD (III, MXMON)   
      IYEA = (III-IMON)/MXMON   
      IF (IYEA.LT.1) THEN   
        IADD = 0    
        ITYP = 2    
      ELSE IF (IYEA.GT.20) THEN 
        IADD = IDAYY(20)    
        ITYP = 2    
      ELSE  
        IADD = IDAYY(IYEA)  
        ITYP = MOD (IYEA, 4)    
        IF (ITYP.EQ.0) THEN 
          ITYP = 2  
        ELSE    
          ITYP = 1  
        ENDIF   
      ENDIF 
*   
      IDAYS = IDAY + IADD + IDAYM(IMON,ITYP)    
      ISECS = ISEC + 60*(IMIN + 60*(IHOU + 24*IDAYS))   
*                                                             END DBUTIS    
      END   
      SUBROUTINE DBACPL 
*     ================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBACPL                                                  *    
*                                                                      *    
*   Action Routines for menu /DBL3/PLOT                                *    
*                                                                      *    
*   Allowed Actions :                                                  *    
*                                                                      *    
*     DBHELP, DBPLOB, DBPLOT, DBPLOV, DBPLTI, DBREAD, DBTREE           *    
*                                                                      *    
*   Called by KUIP routine                                             *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NOBMDP=50, NPLMDP=500, NPMXDP=10)    
      PARAMETER       (NMAXDP=2*NOBMDP) 
      COMMON /DPLOTS/ IBINDP(8), INDXDP(2,NOBMDP), KOBJDP(NMAXDP)   
     +              , NKSMDP(NPMXDP), NKSTDP(NPMXDP), NDSMDP(NPMXDP)    
     +              , NDSTDP(NPMXDP), IBEGDP(NPMXDP), NDEMDP(NPMXDP)    
     +              , IOTYDP(NMAXDP), NSKYDP(NPMXDP), NKEYDP(22,NPMXDP) 
     +              , KKEYDP(22,NPMXDP), VMAXDP, VMINDP 
      COMMON /DPLOCH/ CHRPDP, CTTLDP, DYENDP, DYSTDP    
      CHARACTER       CHRPDP*119, CTTLDP*73, DYENDP*9, DYSTDP*9 
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      PARAMETER       (L3WKST=1)    
      DIMENSION       KEYS(100), KOBJ2(2,NOBMDP), KOBJ1(NOBMDP) 
      CHARACTER       CPATL*32, CHOPT*32, PATHN*80  
      CHARACTER       TOPN*16, PATH*80, CFNAM*80, ALIAS*8, CHTAG*8  
      DATA            PATHN /' '/, ALIAS /' '/, CHTAG /' '/ 
*
      dimension iarg(9), kobj(9)
*     ------------------------------------------------------------------    
*   
      CALL KUPATL (CPATL, NPAR) 
*   
      IF (CPATL.EQ.'DBHELP') THEN   
*   
*  **   DBHELP  
*   
        TOPN   = '*'    
        CALL KUGETC (TOPN, NCH) 
        IF (LTOPDB.NE.0) THEN   
          IF (TOPN(1:1).EQ.'*') THEN    
            NCHR   = IQ(KOFUDB+LTOPDB+MUPNCH)   
            CALL UHTOC (IQ(KOFUDB+LTOPDB+MUPNAM), 4, TOPN, NCHR)    
            TOPN   = TOPN(1:NCHR)   
          ENDIF 
          PATHN  = '//'//TOPN   
          CALL DBFPAT (PATHN, 20, LFRSDX)   
          IF (IQUEST(1).EQ.0.AND.LFRSDX.NE.0) THEN  
            CALL IGSG (L3WKST)  
            CALL ICLRWK (1, 1)  
            CALL DBPLBK (LFRSDX)    
            CALL IRQLC (1, 1, IST, NT, X, Y)    
            CALL IGSA (L3WKST)  
            IF (IST.NE.0) THEN  
              CALL DBLOOK (LFRSDX, X, Y, PATH)  
              CALL MZDROP (IDIVDB, LFRSDX, ' ') 
              LFRSDX = 0    
              IF (PATH(1:1).NE.' ') THEN    
                CALL KUGETC (CFNAM, NCF)    
                CALL DBOPEN (LUKYDX, CFNAM, 'UNKNOWN', ISTAT)   
                IF (ISTAT.NE.0) THEN
                  iarg(1) = istat
                  CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error '',I12'//  
     +                 ','' in opening file '//CFNAM(1:NCF)//''')', 
     +                 iarg, 1)    
                  GO TO 999 
                ENDIF   
                CALL DBRHLP (PATH, LUKYDX)  
                IERR = IQUEST(1)
                iarg(1) = ierr
                IF (IERR.NE.0) CALL DBPRNT (LUKYDX, '(/,'' DBACPL : '// 
     +          'Error '',I12,'' in getting help info. for '',/,'' '//  
     +          PATH(1:72)//''')', iarg, 1) 
                CALL DBCLOS (LUKYDX)    
                CALL KUEDIT (CFNAM, IST)    
              ELSE  
                CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Cursor does not '//    
     +               'point to any valid path'')', IARGDB, 0)   
              ENDIF 
            ELSE
              iarg(1) = ist
              CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error '',I12,'' in'//    
     +             ' picking operation'')', iarg, 1) 
            ENDIF   
          ELSE
            iarg(1) = iquest(1)
            CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error '',I12,'' in '// 
     +           'finding the tree for '//TOPN//''')', iarg, 1)    
          ENDIF 
          IF (LFRSDX.NE.0) THEN 
            CALL MZDROP (IDIVDB, LFRSDX, ' ')   
            LFRSDX = 0  
          ENDIF 
        ENDIF   
*   
      ELSE IF (CPATL.EQ.'DBPLOB') THEN  
*   
*  **   DBPLOB  
*   
        CALL KUGETC (PATHN, NCH)    
        CALL KUGETI (NOBJ)  
        IF (NOBJ.LT.1) THEN 
          NOBJ = 1  
        ELSE IF (NOBJ.GT.NOBMDP) THEN   
          NOBJ = NOBMDP 
        ENDIF   
        CALL KUGETI (KEX)   
        CALL KUGETI (NST)   
        CALL KUGETC (CHOPT, NCH)    
        CALL DBOPTS (CHOPT) 
        IF (IQUEST(1).NE.0) THEN    
          CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error in decoding CHOP'//    
     +         'T '//CHOPT(1:NCH)//''')', IARGDB, 0)    
          GO TO 999 
        ENDIF   
        CALL VZERO_i (KEYS, 100)  
        CALL DBRVPL (1, NOBJ, KOBJ1, KOBJ2, KEYS)   
        IF (IQUEST(1).NE.0) GO TO 999   
        CALL IGSG (L3WKST)  
        CALL DBPLOB (PATHN, KEYS, NOBJ, KOBJ1, KEX, NST, CHOPT)
        iarg(1) = iquest(1)
        IF (IQUEST(1).NE.0) CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Erro'//    
     +  'r '',I12,'' in routine DBPLOB'')', iarg, 1)   
        CALL IGSA (L3WKST)  
*   
      ELSE IF (CPATL(1:6).EQ.'DBPLOT') THEN 
*   
*  **   DBPLOT  
*   
        CALL KUGETC (ALIAS, NCH)    
        CALL DBRALI (ALIAS, PATHN)  
        IF (IQUEST(1).NE.0) THEN    
          CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error in the alias nam'//    
     +         'e '//ALIAS//''')', IARGDB, 0)   
          GO TO 999 
        ENDIF   
        CALL KUGETC (CHTAG, NCH)    
        CALL DBGNAM (PATHN, CHTAG, IOBJ)    
        IF (IQUEST(1).NE.0.OR.IOBJ.EQ.0) THEN   
          CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error in the object '//  
     +         'name '//CHTAG//''')', IARGDB, 0)    
          GO TO 999 
        ENDIF   
        CALL KUGETC (CHOPT, NCH)    
        CALL DBOPTS (CHOPT) 
        IF (IQUEST(1).NE.0) THEN    
          CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error in decoding CHOP'//    
     +         'T '//CHOPT(1:NCH)//''')', IARGDB, 0)    
          GO TO 999 
        ENDIF   
        CALL VZERO_i (KEYS, 100)  
        CALL DBRVPL (0, NOBJ, KOBJ1, KOBJ2, KEYS)   
        IF (IQUEST(1).NE.0) GO TO 999   
        NOBJ   = 1  
        KEX    = 3  
        NST    = 1  
        CALL IGSG (L3WKST)
        kobj(1) = iobj
        CALL DBPLOB (PATHN, KEYS, NOBJ, kOBJ, KEX, NST, CHOPT)
        iarg(1) = iquest(1)
        IF (IQUEST(1).NE.0) CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Erro'//    
     +  'r '',I12,'' in routine DBPLOB'')', iarg, 1)   
        CALL IGSA (L3WKST)  
*   
      ELSE IF (CPATL.EQ.'DBPLOV') THEN  
*   
*  **   DBPLOV  
*   
        CALL KUGETC (PATHN, NCH)    
        CALL KUGETI (NOBJ)  
        IF (NOBJ.LT.1) THEN 
          NOBJ = 1  
        ELSE IF (NOBJ.GT.NOBMDP) THEN   
          NOBJ = NOBMDP 
        ENDIF   
        CALL KUGETI (NST)   
        CALL KUGETC (CHOPT, NCH)    
        CALL DBOPTS (CHOPT) 
        IF (IQUEST(1).NE.0) THEN    
          CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error in decoding CHOP'//    
     +         'T '//CHOPT(1:NCH)//''')', IARGDB, 0)    
          GO TO 999 
        ENDIF   
        CALL VZERO_i (KEYS, 100)  
        CALL DBRVPL (2, NOBJ, KOBJ1, KOBJ2, KEYS)   
        IF (IQUEST(1).NE.0) GO TO 999   
        CALL IGSG (L3WKST)  
        CALL DBPLOV (PATHN, KEYS, NOBJ, KOBJ2, NST, CHOPT)
        iarg(1) = iquest(1)
        IF (IQUEST(1).NE.0) CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Erro'//    
     +  'r '',I12,'' in routine DBPLOV'')', iarg, 1)   
        CALL IGSA (L3WKST)  
*   
      ELSE IF (CPATL.EQ.'DBPLTI') THEN  
*   
*  **   DBPLTI  
*   
        CALL KUGETC (PATHN, NCH)    
        CALL KUGETC (CHOPT, NCH)    
        CALL DBOPTS (CHOPT) 
        IF (IQUEST(1).NE.0) THEN    
          CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error in decoding CHOP'//    
     +         'T '//CHOPT(1:NCH)//''')', IARGDB, 0)    
          GO TO 999 
        ENDIF   
        CALL VZERO_i (KEYS, 100)  
        CALL DBRVPL (0, NOBJ, KOBJ1, KOBJ2, KEYS)   
        IF (IQUEST(1).NE.0) GO TO 999   
        CALL IGSG (L3WKST)  
        CALL DBPLTI (PATHN, KEYS, CHOPT)
        iarg(1) = iquest(1)
        IF (IQUEST(1).NE.0) CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Erro'//    
     +  'r '',I12,'' in routine DBPLTI'')', iarg, 1)   
        CALL IGSA (L3WKST)  
*   
      ELSE IF (CPATL.EQ.'DBREAD') THEN  
*   
*  **   DBREAD  
*   
        TOPN   = '*'    
        CALL KUGETC (TOPN, NCH) 
        IF (LTOPDB.NE.0) THEN   
          IF (TOPN(1:1).EQ.'*') THEN    
            NCHR   = IQ(KOFUDB+LTOPDB+MUPNCH)   
            CALL UHTOC (IQ(KOFUDB+LTOPDB+MUPNAM), 4, TOPN, NCHR)    
            TOPN   = TOPN(1:NCHR)   
          ENDIF 
          PATHN  = '//'//TOPN   
          CALL DBFPAT (PATHN, 20, LFRSDX)   
          IF (IQUEST(1).EQ.0.AND.LFRSDX.NE.0) THEN  
            CALL IGSG (L3WKST)  
            CALL ICLRWK (1, 1)  
            CALL DBPLBK (LFRSDX)    
            CALL IRQLC (1, 1, IST, NT, X, Y)    
            CALL IGSA (L3WKST)  
            IF (IST.NE.0) THEN  
              CALL DBLOOK (LFRSDX, X, Y, PATH)  
              CALL MZDROP (IDIVDB, LFRSDX, ' ') 
              LFRSDX = 0    
              IF (PATH(1:1).NE.' ') THEN    
                CALL KUGETC (CFNAM, NCF)    
                CALL DBOPEN (LUKYDX, CFNAM, 'UNKNOWN', ISTAT)   
                IF (ISTAT.NE.0) THEN
                  iarg(1) = istat
                  CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error '',I12'//  
     +                 ','' in opening file '//CFNAM(1:NCF)//''')', 
     +                 iarg, 1)    
                  GO TO 999 
                ENDIF   
                CALL KUGETC (CHOPT, NCH)    
                CALL UOPTC (CHOPT, 'H', IOPHDD) 
                CALL DBPEEK (CFNAM, NCF, PATH)  
              ELSE  
                CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Cursor does not '//    
     +               'point to any valid path'')', IARGDB, 0)   
              ENDIF 
            ELSE
              iarg(1) = ist
              CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error '',I12,'' in'//    
     +             ' picking operation'')', iarg, 1) 
            ENDIF   
          ELSE
            iarg(1) = iquest(1)
            CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error '',I12,'' in '// 
     +           'finding the tree for '//TOPN//''')', iarg, 1)    
          ENDIF 
          IF (LFRSDX.NE.0) THEN 
            CALL MZDROP (IDIVDB, LFRSDX, ' ')   
            LFRSDX = 0  
          ENDIF 
        ENDIF   
*   
      ELSE IF (CPATL.EQ.'DBTREE') THEN  
*   
*  **   DBTREE  
*   
        TOPN   = '*'    
        CALL KUGETC (TOPN, NCH) 
        IF (LTOPDB.NE.0) THEN   
          IF (TOPN(1:1).EQ.'*') THEN    
            NCHR   = IQ(KOFUDB+LTOPDB+MUPNCH)   
            CALL UHTOC (IQ(KOFUDB+LTOPDB+MUPNAM), 4, TOPN, NCHR)    
            TOPN   = TOPN(1:NCHR)   
          ENDIF 
          PATHN  = '//'//TOPN   
          CALL DBFPAT (PATHN, 20, LFRSDX)   
          IF (IQUEST(1).EQ.0.AND.LFRSDX.NE.0) THEN  
            CALL IGSG (L3WKST)  
            CALL ICLRWK (1, 1)  
            CALL DBPLBK (LFRSDX)    
            CALL IGSA (L3WKST)  
          ELSE
            iarg(1) = iquest(1)
            CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error '',I12,'' in '// 
     +           'finding the tree for '//TOPN//''')', iarg, 1)    
          ENDIF 
          IF (LFRSDX.NE.0) THEN 
            CALL MZDROP (IDIVDB, LFRSDX, ' ')   
            LFRSDX = 0  
          ENDIF 
        ENDIF   
*   
      ENDIF 
*                                                             END DBACPL    
  999 END   
      SUBROUTINE DBACTI 
*     ================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBACTI                                                  *    
*                                                                      *    
*   Action Routines for menu /DBL3/INITCLOSE                           *    
*                                                                      *    
*   Allowed Actions :                                                  *    
*                                                                      *    
*     DBCRDR, DBDELT, DBEFOR, DBENFL, DBEND,  DBFZOP, DBFZUP, DBILDF,  *    
*     DBILDU, DBINIT, DBLOGL, DBNTOP, DBOPEN, DBSAVE, DBSETD           *    
*                                                                      *    
*   Called by KUIP routine                                             *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      COMMON /DINITL/ TOPLDI, TOPNDI    
      CHARACTER       TOPNDI*16, TOPLDI*16  
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      PARAMETER       (MXLUN=10)    
      CHARACTER       CPATL*32, CHOPT*32, TOPNM*32, PATHN*80, CHOP*32   
      CHARACTER       PATHI*80, CFNAM*80    
      DIMENSION       LUNRZ(MXLUN)  
      DATA            PATHN /' '/, TOPNM /' '/, CFNAM /' '/, PATHI /' '/    
      DATA            IDATE /800101/, ITIME /0/, LUNF /0/, LUNI /0/ 
*
      dimension iarg(9)
*     ------------------------------------------------------------------    
*   
      CALL KUPATL (CPATL, NPAR) 
*   
      IF (CPATL.EQ.'DBCRDR') THEN   
*   
*  **   DBCRDR  
*   
        CALL KUGETC (PATHN, NCH)    
        CALL DBCRDR (PATHN)
        iarg(1) = iquest(1)
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : Create directory for '//   
     +       PATHN(1:NCH)//''',/,''          return code '',I12)',  
     +       iarg, 1)  
*   
      ELSE IF (CPATL.EQ.'DBDELT') THEN  
*   
*  **   DBDELT  
*   
        CALL KUGETC (PATHN, NCH)    
        CALL DBDELT (PATHN, ' ')
        iarg(1) = iquest(1)
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : Delete the directory tre'//    
     +       'e '//PATHN(1:NCH)//''',/,''          return code '',I12)',    
     +       iarg, 1)  
*   
      ELSE IF (CPATL.EQ.'DBEFOR') THEN  
*   
*  **   DBEFOR  
*   
        CALL KUGETC (TOPNM, NCH)    
        CALL KUGETI (IDATE) 
        CALL KUGETI (ITIME) 
        CALL DBEFOR (TOPNM, IDATE, ITIME)   
        IARGDB(1) = IDATE   
        IARGDB(2) = ITIME   
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : Retrieve data for '//  
     +       TOPNM(1:NCH)//' before '',2I8)', IARGDB, 2)    
*   
      ELSE IF (CPATL.EQ.'DBENFL') THEN  
*   
*  **   DBENFL  
*   
        CALL KUGETC (TOPNM, NCH)    
        NLUNS  = 0  
        LTOP   = LTOPDB 
    5   IF (LTOP.GT.0) THEN 
          NCHR   = IQ(KOFUDB+LTOP+MUPNCH)   
          CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHR)  
          TOPNDI = TOPNDI(1:NCHR)   
          IF (TOPNDI.EQ.TOPNM) THEN 
            NLUNS  = NLUNS + 1  
            LUNRZ(NLUNS) = IQ(KOFUDB+LTOP+MUPLUN)   
            GO TO 10    
          ELSE  
            LTOP   = LQ(KOFUDB+LTOP)    
            GO TO 5 
          ENDIF 
        ENDIF   
   10   CALL DBENDF (TOPNM) 
        IF (NLUNS.GT.0) THEN    
          DO 15 ILUN = 1, NLUNS 
            CALL DBCLOS (LUNRZ(ILUN))   
   15     CONTINUE  
        ENDIF   
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : Close data base file for'//    
     +       ' '//TOPNM//''')', IARGDB, 0)  
*   
      ELSE IF (CPATL.EQ.'DBEND') THEN   
*   
*  **   DBEND   
*   
        NLUNS  = 0  
        LTOP   = LTOPDB 
   20   IF (LTOP.GT.0.AND.NLUNS.LT.MXLUN) THEN  
          NLUNS  = NLUNS + 1    
          LUNRZ(NLUNS) = IQ(KOFUDB+LTOP+MUPLUN) 
          LTOP   = LQ(KOFUDB+LTOP)  
          GO TO 20  
        ENDIF   
        CALL DBEND  
        IF (NLUNS.GT.0) THEN    
          DO 25 ILUN = 1, NLUNS 
            CALL DBCLOS (LUNRZ(ILUN))   
   25     CONTINUE  
        ENDIF   
*   
      ELSE IF (CPATL.EQ.'DBFZOP') THEN  
*   
*  **   DBFZOP  
*   
        CALL KUGETC (TOPNM, NCH)    
        CALL KUGETI (LUNF)  
        CALL KUGETC (CHOPT, NCH)    
        CALL DBFZOP (LUNF, TOPNM, CHOPT)    
        IARGDB(1) = LUNF    
        IARGDB(2) = IQUEST(1)   
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : Open Journal file '',I4'// 
     +       ','' for '//TOPNM(1:10)//CHOPT(1:2)//''',/,''          '// 
     +       'return code '',I12)', IARGDB, 2)  
*   
      ELSE IF (CPATL.EQ.'DBFZUP') THEN  
*   
*  **   DBFZUP  
*   
        CALL KUGETI (LUNF)  
        CALL KUGETC (CHOPT, NCH)    
        CALL DBFZUP (LUNF, CHOPT)   
        IARGDB(1) = LUNF    
        IARGDB(2) = IQUEST(1)   
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : Update from Journal file'//    
     +       ' '',I4,'' return code'',I12)', IARGDB, 2) 
*   
      ELSE IF (CPATL.EQ.'DBILDF') THEN  
*   
*  **   DBILDF  
*   
        CALL KUGETI (LUNI)  
        CALL KUGETC (CFNAM, NCH)    
        CALL DBOPEN (LUNI, CFNAM, 'OLD', ISTAT) 
        IF (ISTAT.EQ.0) THEN    
          CALL KUGETC (CHOPT, NCH)  
          CALL DBILDF (LUNI, CHOPT) 
          CALL DBCLOS (LUNI)    
          IARGDB(1) = IQUEST(11)    
          IARGDB(2) = IQUEST(1) 
          CALL DBPRNT (L3PRDX, '(/,'' DBACTI : list of'',I6,'' direct'//    
     +         'ories read from '//CFNAM(1:40)//' error code'',I12)',   
     +         IARGDB, 2)   
        ELSE
          iarg(1) = lumi
          CALL DBPRNT (L3PRDX, '(/,'' DBACTI : error in opening file '//    
     +         CFNAM(1:40)//' on unit '',I6)', iarg, 1) 
        ENDIF   
*   
      ELSE IF (CPATL.EQ.'DBILDU') THEN  
*   
*  **   DBILDU  
*   
        CALL KUGETI (LUNI)  
        CALL KUGETC (CFNAM, NCH)    
        CALL DBOPEN (LUNI, CFNAM, 'OLD', ISTAT) 
        IF (ISTAT.EQ.0) THEN    
          CALL KUGETC (TOPNM, NCH)  
          CALL KUGETC (CHOPT, NCH)  
          CALL DBILDU (LUNI, TOPNM, CHOPT)  
          CALL DBCLOS (LUNI)    
          IARGDB(1) = IQUEST(11)    
          IARGDB(2) = IQUEST(1) 
          CALL DBPRNT (L3PRDX, '(/,'' DBACTI : list of'',I6,'' direct'//    
     +         'ories read from '//CFNAM(1:40)//' error code'',I12)',   
     +         IARGDB, 2)   
        ELSE
          iarg(1) = luni
          CALL DBPRNT (L3PRDX, '(/,'' DBACTI : error in opening file '//    
     +         CFNAM(1:40)//' on unit '',I6)',  iarg, 1) 
        ENDIF   
*   
      ELSE IF (CPATL.EQ.'DBINIT') THEN  
*   
*  **   DBINIT  
*   
        CALL KUGETI (NREC)  
        IF (NREC.LT.0) NREC = 0 
        IF (NREC.EQ.0) THEN 
          CALL INZROP ('FILE', LUNRZ, CHOPT)    
        ELSE    
          CALL INZROP ('MAKE', LUNRZ, CHOP) 
          CHOPT  = 'Z'//CHOP    
        ENDIF   
        IF (IQUEST(1).NE.0) GO TO 999   
        CALL KUGETI (IDIV)  
        CALL KUGETC (TOPNM, NCH)    
        CALL DBINIT (IDIV, LUNRZ(1), TOPNM, LTOP, NREC, CHOPT) 
        IF (IQUEST(1).NE.0) THEN    
          IERR   = IQUEST(1)    
          CALL DBCLOS (LUNRZ(1))   
          IQUEST(1) = IERR  
        ENDIF   
*   
      ELSE IF (CPATL.EQ.'DBLOGL') THEN  
*   
*  **   DBLOGL  
*   
        CALL KUGETI (LUNRZ(1)) 
        CALL KUGETI (LOGL)  
        CALL DBLOGL (LUNRZ(1), LOGL)   
*   
      ELSE IF (CPATL.EQ.'DBNTOP') THEN  
*   
*  **   DBNTOP  
*   
        CALL KUGETC (PATHI, NCHI)   
        CALL KUGETC (PATHN, NCHO)   
        CALL KUGETI (MXKP)  
        CALL KUGETI (NSAV)  
        CALL KUGETC (CHOPT, NCH)    
        CALL DBNTOP (PATHI, PATHN, MXKP, NSAV, CHOPT)
        iarg(1) = iquest(1)
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : Copies '//PATHI(1:NCHI)//  
     +       ' to '',/,''                 '//PATHN(1:NCHO)//' return '//    
     +       'code '',I12)', iarg, 1)  
*   
      ELSE IF (CPATL.EQ.'DBOPEN') THEN  
*   
*  **   DBOPEN  
*   
        CALL KUGETI (NREC)  
        IF (NREC.LT.0) NREC = 0 
        IF (NREC.EQ.0) THEN 
          CALL INZROP ('FILE', LUNRZ, CHOPT)    
        ELSE    
          CALL INZROP ('MAKE', LUNRZ, CHOPT)    
        ENDIF   
*   
      ELSE IF (CPATL.EQ.'DBSAVE') THEN  
*   
*  **   DBSAVE  
*   
        CALL DBSAVE
        iarg(1) = iquest(1)
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : Saves the changes to '//   
     +       'data base - return code'',I12)', Iarg, 1)    
*   
      ELSE IF (CPATL.EQ.'DBSETD') THEN  
*   
*  **   DBSETD  
*   
        CALL KUGETI (MXDIS) 
        IF (MXDIS.LE.0) THEN    
          MXDPDD = 80   
        ELSE IF (MXDIS.GT.512) THEN 
          MXDPDD = 512  
        ELSE    
          MXDPDD = MXDIS    
        ENDIF   
        WRITE (CFMTDD, '(''(A'',I3,'')'')') MXDPDD
        iarg(1) = mxdpdd
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : MXDIS is set to '',I10)',  
     +       iarg, 1) 
*   
      ENDIF 
*                                                             END DBACTI    
  999 END   
      SUBROUTINE DBAIRD (LUN, PATHN, KEYX, CHOPT)   
*     ===========================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBAIRD (LUN, PATHN, KEYX, CHOPT)                        *    
*                                                                      *    
*   Display the data attached to the directory PATHN and KEY for       *    
*   ASCII type of data                                                 *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUN      Unit number of file for display                         *    
*     PATHN    Character string describing the pathname                *    
*     KEYX     Key-vector                                              *    
*     CHOPT    Character option                                        *    
*          E   Object already exists at LFRSDX                         *    
*          L   The last object to be shown                             *    
*                                                                      *    
*   Called by DBAIWR, DBPEEK                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =101 : Illegal path name                               *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      DIMENSION       KEYX(9), IOPTS(2) 
      CHARACTER       PATHN*(*), CHOPT*(*), PATHY*80, PATHX*16  
      CHARACTER       KLINE*80  
      EQUIVALENCE     (IOPTS(1), IOPTE), (IOPTS(2), IOPTL)  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension iarg(9)
*     ------------------------------------------------------------------    
*   
* *** Set the current directory 
*   
      CALL UOPTC (CHOPT, 'EL', IOPTS)   
      IOPTP  = 0    
      IF (IOPTE.NE.0)                            GO TO 40   
      PATHY  = PATHN    
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0)                        GO TO 991  
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKEYT   
*   
*  ** Find the appropriate object number    
*   
      NCHR   = LEN (PATHN)  
      NCH    = INDEX (PATHN, ' ') - 1   
      IF (NCH.EQ.0) NCH = NCHR  
      IF (NKEYDK.LE.0)                           GO TO 55   
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)   
      ISTP   = NWKYDK + 1   
      IF (IOPTL.EQ.0) THEN  
        IF (IOPTP.EQ.0) THEN    
          IPNT   = KOFSDB + LCDRDB + IKDRDB 
          KPNT   = IUHUNT (KEYX(MSERDB), IQ(IPNT+MSERDB), ISTP*NKEYDK,  
     +                     ISTP)    
          IF (KPNT.GT.0) THEN   
            IKMAX  = (KPNT - MSERDB) / ISTP + 1 
          ELSE  
            IKMAX  = NKEYDK 
          ENDIF 
        ELSE    
          NKEYS  = NKEYDK   
          IPNT   = KOFSDB + LCDRDB + IKDRDB 
          DO 10 JK = 1, NKEYS   
            IK     = NKEYS + 1 - JK 
            KPNT   = IUHUNT (IK, IQ(IPNT+MPSRDB), NKEYS*ISTP, ISTP) 
            IF (KPNT.GT.0) THEN 
              KPNT   = IPNT + KPNT - MPSRDB 
            ELSE    
              KPNT   = IPNT + (IK - 1) * ISTP   
            ENDIF   
            IF (IQ(KPNT+MOBJDB).GT.KEYX(MSERDB)) GO TO 10   
            CALL DBPATH (PATHX, IK) 
            PATHY  = PATHN(1:NCH)//'/'//PATHX   
            CALL RZCDIR (PATHY, ' ')    
            IF (IQUEST(1).NE.0)                  GO TO 991  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
            NKEYDK = IQUEST(7)  
            IPNT   = KOFSDB + LCDRDB + IKDRDB   
            KPNT   = IUHUNT (KEYX(MSERDB), IQ(IPNT+MSERDB), ISTP*NKEYDK,    
     +                       ISTP)  
            IF (KPNT.GT.0) THEN 
              IKMAX  = (KPNT - MSERDB) / ISTP + 1   
            ELSE    
              IKMAX  = NKEYDK   
            ENDIF   
            GO TO 35    
   10     CONTINUE  
        ENDIF   
      ELSE  
        IF (IOPTP.EQ.0) THEN    
          KPNT   = KOFSDB + LCDRDB + IKDRDB + (NKEYDK - 1) * ISTP   
          KMAX   = IQ(KPNT+MSERDB)  
          IKMAX  = NKEYDK   
          DO 20 I = 2, NKEYDK   
            KPNT   = KPNT - ISTP    
            IF (IQ(KPNT+MSERDB).GT.KMAX) THEN   
              KMAX   = IQ(KPNT+MSERDB)  
              IKMAX  = NKEYDK - I + 1   
            ENDIF   
   20     CONTINUE  
        ELSE    
          NKEYS  = NKEYDK   
          DO 30 IK = 1, NKEYS   
            JK     = NKEYS + 1 - IK 
            CALL DBPATH (PATHX, JK) 
            PATHY  = PATHN(1:NCH)//'/'//PATHX   
            CALL RZCDIR (PATHY, ' ')    
            IF (IQUEST(1).NE.0)                  GO TO 991  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
            NKEYDK = IQUEST(7)  
            IF (NKEYDK.GT.0) THEN   
              KPNT   = KOFSDB + LCDRDB + IKDRDB + (NKEYDK-1)*ISTP   
              KMAX   = IQ(KPNT+MSERDB)  
              IKMAX  = NKEYDK   
              DO 25 I = 2, NKEYDK   
                KPNT   = KPNT - ISTP    
                IF (IQ(KPNT+MSERDB).GT.KMAX) THEN   
                  KMAX   = IQ(KPNT+MSERDB)  
                  IKMAX  = NKEYDK - I + 1   
                ENDIF   
   25         CONTINUE  
              GO TO 35  
            ENDIF   
   30     CONTINUE  
        ENDIF   
      ENDIF 
   35 KEYVDK(MSERDB) = IKMAX    
*   
*  ** Read in the data  
*   
      IOLD1  = IOKYDA(MSERDB)   
      IOLDK  = IOPKDA   
      IOKYDA(MSERDB) = 1    
      IOPKDA = 0    
      JBIAS  = 2    
      IF (LFRSDX.GT.0) THEN 
        CALL MZDROP (IDIVDB, LFRSDX, 'L')   
        LFRSDX = 0  
      ENDIF 
      ITIME  = 1    
      CALL DBKXIN (ITIME, IDIVDB, LFRSDX, LFRSDX, JBIAS, NWKYDK, KEYVDK,    
     +             IPREC)   
      IOKYDA(MSERDB) = IOLD1    
      IOPKDA = IOLDK    
      IF (IQUEST(1).NE.0)                        GO TO 55   
   40 IF (LFRSDX.EQ.0)                           GO TO 55   
      NDATA  = IQ(KOFUDB+LFRSDX-1)  
      IF (NDATA.LE.0)                            GO TO 55   
*   
*  ** Display data if exists, if it does not, display dummy data    
*   
   45 NTOT   = 0    
      NREC   = 0    
   50 IF (NTOT.LT.NDATA) THEN   
        CALL DBLIND (IQ(KOFUDB+LFRSDX+1), NTOT, KLINE, LENG)    
        IF (LENG.GT.0) THEN 
          WRITE (LUN, 1001) KLINE(1:LENG)   
        ELSE    
          WRITE (LUN, *)    
        ENDIF   
        NREC   = NREC + 1   
        GO TO 50    
      ENDIF
      iarg(1) = nrec
      IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBAIRD : '',I8,'' '//    
     +   'records written on the file'')', iarg, 1) 
      GO TO 60  
*   
   55 WRITE (LUN, 1001) 'There is no data ' 
   60 IF (IOPTE.EQ.0) THEN  
        IF (LFRSDX.NE.0) CALL MZDROP (IDIVDB, LFRSDX, 'L')  
      ENDIF 
      IF (IOPTP.NE.0) THEN  
        CALL RZCDIR (PATHN, ' ')    
        NKEYDK = IQUEST(7)  
        LCDRDB = IQUEST(11) 
        IKDRDB = IQUEST(13) 
      ENDIF 
      IQUEST(1) = 0 
      GO TO 999 
*   
* *** Error messages    
*   
  991 IQUEST(1) = 101   
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBAIRD : Illegal '// 
     +   'Path Name '//PATHY//''')', IARGDB, 0) 
      GO TO 999 
*   
 1001 FORMAT (A)    
*                                                             END DBAIRD    
  999 END   
      SUBROUTINE DBAIWR (KEYX, KEYO, PATHN, CHOPT)  
*     ============================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBAIWR (KEYX, KEYO, PATHN, CHOPT)                       *    
*                                                                      *    
*   Insert/Update ASCII files in the current working directory         *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     KEYX     Key-Vector containing the new Key values                *    
*     KEYO     Key-Vector containing the old Key values                *    
*     PATHN    Pathname of the directory                               *    
*     CHOPT    Character options                                       *    
*         I    Insert new Key                                          *    
*         X    Replace (update) old key                                *    
*                                                                      *    
*   Called by DBEDKY                                                   *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      DIMENSION       IOPTS(2), KEYX(9), KEYO(9)    
      CHARACTER       CFNAM*80, KLINE*80    
      CHARACTER       PATHN*(*), CHOPT*(*)  
      EQUIVALENCE     (IOPTI, IOPTS(1)), (IOPTX, IOPTS(2))  
*
      dimension nio(9), iarg(9)
*     ------------------------------------------------------------------    
*   
*  ** Open the file to editing  
*   
      CALL KUPROC ('Give Data File-Name (e.g. DFNAME) ',CFNAM, LFNAM)   
      CFNAM  = CFNAM(1:LFNAM)//'.FILEXT'    
      CALL DBOPEN (LUDADX, CFNAM, 'UNKNOWN', ISTAT) 
      IF (ISTAT.NE.0)     GO TO 999 
*   
* *** Decode the character option   
*   
      CALL UOPTC (CHOPT, 'IX', IOPTS)   
      IF (IOPTX.NE.0) THEN  
        CALL DBAIRD (LUDADX, PATHN, KEYO, ' ')  
      ELSE  
        CALL DBAIRD (LUDADX, PATHN, KEYX, 'L')  
      ENDIF 
      CALL DBCLOS (LUDADX)  
      IF (IQUEST(1).NE.0) GO TO 999 
*   
*  ** Edits the file containing the data    
*   
      CALL KUEDIT (CFNAM, IST)  
      IF (IST.NE.0)       GO TO 999 
*   
*  ** Read the data part    
*   
      IF (LFRSDX.NE.0) CALL MZDROP (IDIVDB, LFRSDX, 'L')    
      NDATA  = NDMXDB
      nio(1) = 1
      CALL DBBOOK (IDIVDB, LFRSDX, LFRSDX, 2, 'USER', 0,0, NDATA, nio,
     &     -1)
      IF (IQUEST(1).NE.0) GO TO 999 
      CALL DBOPEN (LUDADX, CFNAM, 'OLD', ISTAT) 
      IF (ISTAT.NE.0)     GO TO 50  
*   
*  ** Now read the file 
*   
      NDAT   = 0    
      NREC   = 0    
   10 READ (LUDADX, 1000, ERR=20, END=20) KLINE 
      NREC   = NREC + 1 
      LENG   = LENOCC (KLINE)   
      CALL DBLINC (KLINE, LENG, IQ(KOFUDB+LFRSDX+1), NDAT)  
      IF (NDAT.GT.NDATA-20) THEN    
        PRINT 1000, ' Out of buffer space'  
        GO TO 20    
      ENDIF 
      GO TO 10  
*   
   20 NDP    = NDAT - NDATA 
      CALL DBCLOS (LUDADX)  
      IF (NDP.LT.0) CALL MZPUSH (IDIVDB, LFRSDX, 0, NDP, 'I')
      iarg(1) = nrec
      IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBAIWR : '',I8,'' '//    
     +   'records read from the file'')', iarg, 1)  
*   
      IQUEST(1) = 0 
      IF (IOPTX.NE.0) THEN  
        CALL DBREPL (PATHN, LKVWDX(1), LDVWDX(1), IDIVDB, LFRSDX,   
     +               NWKYDK, KEYO, KEYX, 0, 'RT')   
      ELSE  
        CALL DBENTR (PATHN, LKVWDX(1), LDVWDX(1), IDIVDB, LFRSDX,   
     +               NWKYDK, KEYX, 0, 'RT') 
      ENDIF 
*   
   50 IER    = IQUEST(1)    
      CALL MZDROP (IDIVDB, LFRSDX, ' ') 
      IQUEST(1) = IER   
*   
 1000 FORMAT (A80)  
*                                                             END DBAIWR    
  999 END   
      SUBROUTINE DBAUXI 
*     ================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBAUXI                                                  *    
*                                                                      *    
*   Action Routines for menu /DBL3/AUXILIARY                           *    
*                                                                      *    
*   Allowed Actions :                                                  *    
*                                                                      *    
*     DBASCI, DBDISP, DBEALI, DBEDIT, DBEHLP, DBENAM, DBKEPT, DBPEEK,  *    
*     DBPLNT, DBPRGD, DBPTIM, DBPURG, DBRALI, DBRENK, DBRHLP, DBRNAM,  *    
*     DBRTFZ, DBSHOW, DBUTIM, DBVIEW, DBWRITE                          *    
*                                                                      *    
*   Called by KUIP routine                                             *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (NOBMDP=50, NPLMDP=500, NPMXDP=10)    
      PARAMETER       (NMAXDP=2*NOBMDP) 
      COMMON /DPLOTS/ IBINDP(8), INDXDP(2,NOBMDP), KOBJDP(NMAXDP)   
     +              , NKSMDP(NPMXDP), NKSTDP(NPMXDP), NDSMDP(NPMXDP)    
     +              , NDSTDP(NPMXDP), IBEGDP(NPMXDP), NDEMDP(NPMXDP)    
     +              , IOTYDP(NMAXDP), NSKYDP(NPMXDP), NKEYDP(22,NPMXDP) 
     +              , KKEYDP(22,NPMXDP), VMAXDP, VMINDP 
      COMMON /DPLOCH/ CHRPDP, CTTLDP, DYENDP, DYSTDP    
      CHARACTER       CHRPDP*119, CTTLDP*73, DYENDP*9, DYSTDP*9 
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      PARAMETER       (NOBJM=100)   
      DIMENSION       KEYS(MXDMDK), NKEYX(NPMXDP), NOBJS(NPMXDP)    
      DIMENSION       KEYXS(NOBJM), KOBJS(NOBJM)    
      CHARACTER       CPATL*32, CHOPT*32, PATHN*80, CHPRO*32, CTEMP*5   
      CHARACTER       YESNO*4, PATH*80, CFNAM*80, PATHS(NPMXDP)*80  
      CHARACTER       CRZPA*80, CTITL*80, CTAG(NOBJM)*8, CHOP*32    
      CHARACTER       ALIAS*8, CHTAG*8, PATHX*16, CFMT*120  
      DATA            PATHN /' '/, ALIAS /' '/, CTITL /' '/ 
      DATA            NWDS /0/, NPATH /1/, IDN /0/, KYI /0/, KYEL /0/   
      DATA            LUNFZ /0/, IDATM /0/  
*
      dimension iarg(9)
*     ------------------------------------------------------------------    
*   
      CALL KUPATL (CPATL, NPAR) 
*   
      IF (CPATL.EQ.'DBASCI') THEN   
*   
*  **   DBASCI  
*   
        CALL KUGETC (PATHN, NCH)    
        CALL KUGETC (CFNAM, NCH)    
        CALL DBEDAS (CFNAM, NCH, PATHN) 
*   
      ELSE IF (CPATL.EQ.'DBDISP') THEN  
*   
*  **   DBDISP  
*   
        CALL KUGETC (PATHN, NCH)    
        CALL KUGETC (CFNAM, NCF)    
        CALL DBOPEN (LUKYDX, CFNAM, 'UNKNOWN', ISTAT)   
        IF (ISTAT.NE.0) THEN
          iarg(1) = istat
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : error '',I12,'' in ope'//    
     +         'ning file '//CFNAM(1:NCF)//''')', iarg, 1) 
          GO TO 999 
        ENDIF   
        CALL KUGETC (CHOPT, NCH)    
        CALL UOPTC (CHOPT, 'H', IOPHDD) 
        CHOP   = 'K'//CHOPT 
        CALL DBDISP (LUKYDX, PATHN, CHOP)   
        CALL DBCLOS (LUKYDX)    
        CALL KUEDIT (CFNAM, IST)    
*   
      ELSE IF (CPATL.EQ.'DBEALI') THEN  
*   
*  **   DBEALI  
*   
        CALL KUGETC (PATHN, NCT)    
        CALL KUGETC (ALIAS, NCH)    
        CALL KUGETI (IFLAG) 
        CALL DBEALI (PATHN, ALIAS, IFLAG)   
        IF (IQUEST(1).EQ.0) THEN    
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Alias name of '//    
     +         PATHN(1:NCT)//' is '//ALIAS//''')', IARGDB, 0)   
        ELSE    
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Error in entering alia'//    
     +         's name for '//PATHN(1:NCT)//''')', IARGDB, 0)   
        ENDIF   
*   
      ELSE IF (CPATL.EQ.'DBEDIT') THEN  
*   
*  **   DBEDIT  
*   
        CALL KUGETC (PATHN, NCH)    
        CALL KUGETC (CFNAM, NCF)    
        CALL KUPROC ('Create Directory ? (Y/N)', YESNO, NCH)    
        IF (YESNO(1:1).EQ.'Y') CALL DBCRDR (PATHN)  
        CALL KUPROC ('Keys Insert/Update ? (Y/N)', YESNO, NCH)  
        IF (YESNO(1:1).EQ.'Y') THEN 
          CALL KUPROC ('Horizontal or Vertical Mode ? (H/V)',   
     +                  YESNO, NCH) 
          CALL UOPTC (YESNO, 'H', IOPHDD)   
          CALL DBEDKY (CFNAM, NCF, PATHN, 'S')  
        ENDIF   
*   
      ELSE IF (CPATL.EQ.'DBEHLP') THEN  
*   
*  **   DBEHLP  
*   
        CALL KUGETC (PATHN, NCT)    
        CALL KUGETC (CFNAM, NCH)    
        CALL KUEDIT (CFNAM, IST)    
        IF (IST.EQ.0) THEN  
          CALL DBOPEN (LUKYDX, CFNAM, 'UNKNOWN', ISTAT) 
          IF (ISTAT.EQ.0) THEN  
            CALL DBEHLP (PATHN, LUKYDX) 
            CALL DBCLOS (LUKYDX)    
            IF (IQUEST(1).EQ.0) THEN    
              CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Help info. for '//   
     +             PATHN(1:NCT)//' is stored'')', IARGDB, 0)    
            ELSE
              iarg(1) = iquest(1)
              CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : error '',I6,'' in '//    
     +             'storing Help info. for '//PATHN(1:NCT)//''')',  
     +             iarg, 1)    
            ENDIF   
          ELSE
            iarg(1) = istat
            CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : error '',I12,'' in o'//    
     +           'pening file '//CFNAM(1:NCH)//''')', iarg, 1) 
          ENDIF 
        ELSE
          iarg(1) = ist
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : error '',I12,'' in ed'// 
     +         'iting file '//CFNAM(1:NCH)//''')', iarg, 1)  
        ENDIF   
*   
      ELSE IF (CPATL.EQ.'DBENAM') THEN  
*   
*  **   DBENAM  
*   
        CALL KUGETC (PATHN, NCT)    
        CALL KUGETI (NWDS)  
        IF (NWDS.GT.NOBJM) THEN 
          IARGDB(1) = NWDS  
          IARGDB(2) = NOBJM 
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Too many data elements'//    
     +         ' '',I12,'' maximum '',I5,'' is allowed'')', IARGDB, 2)  
          GO TO 999 
        ENDIF   
        IF (NWDS.GT.0) THEN 
          DO 5 I = 1, NWDS  
            WRITE (CHPRO, 1001) I   
            CALL DBPROC (CHPRO(1:10), CHTAG, NCH)   
            CTAG(I) = CHTAG 
    5     CONTINUE  
          CALL DBENAM (PATHN, NWDS, CTAG)   
          IF (IQUEST(1).EQ.0) THEN  
            CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Tags of data for '//   
     +           PATHN(1:NCT)//' is stored'')', IARGDB, 0)  
          ELSE
            iarg(1) = iquest(1)
            CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : error '',I6,'' in st'//    
     +           'oring Tags of data for '//PATHN(1:NCT)//''')',    
     +           iarg, 1)  
          ENDIF 
        ENDIF   
*   
      ELSE IF (CPATL.EQ.'DBKEPT') THEN  
*   
*  **   DBKEPT  
*   
        CALL KUGETI (NPATH) 
        CALL KUGETC (CHOPT, NCH)    
        IF (NPATH.GT.0) THEN    
          DO 10 IP = 1, NPATH   
            WRITE (CHPRO, 1002) IP  
            CALL KUPROC (CHPRO(1:15), PATHS(IP), NCH)   
   10     CONTINUE  
          CALL DBKEPT (PATHS, NPATH, CHOPT) 
          IARGDB(1) = NPATH 
          IARGDB(2) = IQUEST(1) 
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : All but '',I6,'' direc'//    
     +         'tory trees deleted - return code '',I6)', IARGDB, 2)    
        ENDIF   
*   
      ELSE IF (CPATL.EQ.'DBPEEK') THEN  
*   
*  **   DBPEEK  
*   
        CALL KUGETC (PATHN, NCH)    
        CALL KUGETC (CFNAM, NCF)    
        CALL DBOPEN (LUKYDX, CFNAM, 'UNKNOWN', ISTAT)   
        IF (ISTAT.NE.0) THEN
          iarg(1) = istat
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : error '',I12,'' in ope'//    
     +         'ning file '//CFNAM(1:NCF)//''')', iarg, 1) 
          GO TO 999 
        ENDIF   
        CALL KUGETC (CHOPT, NCH)    
        CALL UOPTC (CHOPT, 'H', IOPHDD) 
        CALL DBPEEK (CFNAM, NCF, PATHN) 
*   
      ELSE IF (CPATL.EQ.'DBPLNT') THEN  
*   
*  **   DBPLNT  
*   
        CALL KUGETI (NPATH) 
        IF (NPATH.LT.1) THEN    
          NPATH = 1 
        ELSE IF (NPATH.GT.NPMXDP) THEN  
          NPATH = NPMXDP    
        ENDIF   
        CALL KUGETC (CHOPT, NCH)    
        CALL KUGETI (IDN)   
        CALL KUGETC (CTITL, NCT)    
        CALL KUGETC (CRZPA, NCR)    
        CALL KUGETI (NPRIM) 
        CALL HCDIR  (PATH, 'R') 
        CALL HCDIR  (CRZPA, ' ')    
        IF (IQUEST(1).NE.0) THEN    
          CALL DBPRNT (L3PRDX, '('' RZ-path '//CRZPA(1:NCR)//' for '//  
     +         'N-tuple is illegal'')', IARGDB, 0)  
          GO TO 999 
        ENDIF   
        CALL HCDIR (CRZPA, 'R') 
        CALL DBOPTS (CHOPT) 
        IF (IQUEST(1).NE.0)               GO TO 999 
        CALL VZERO_i (KEYS, MXDMDK)   
        CALL DBRVNT (NPATH, PATHS, KEYS, NVAR, NKST, NDST, NKEYX, KEYXS,    
     1               NOBJS, KOBJS, CTAG, NOBJM) 
        IF (IQUEST(1).NE.0)               GO TO 999 
        IF (NVAR.LT.1) THEN 
          CALL DBPRNT (L3PRDX, '('' Too few  variables for N-tuple'')', 
     +         IARGDB, 0)   
          GO TO 999 
        ENDIF   
*  **    Book the N-tuple   
        CALL HCDIR  (PATH, ' ') 
        CALL HBOOKN (IDN, CTITL(1:NCT), NVAR, CRZPA, NPRIM, CTAG)   
        CALL DBPLNT (IDN, PATHS, NPATH, NOBJS, KOBJS, NKEYX, KEYXS, 
     +               KEYS, CHOPT)   
        iarg(1) = iquest(1)
        IF (IQUEST(1).NE.0) CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : erro'//    
     +  'r '',I12,'' in routine DBPLNT'')', iarg, 1)   
        CALL HCDIR  (PATH, ' ') 
*   
      ELSE IF (CPATL.EQ.'DBPRGD') THEN  
*   
*  **   DBPRGD  
*   
        CALL KUGETC (PATHN, NCH)    
        CALL KUGETI (IKEEP) 
        CALL DBPRGD (PATHN, IKEEP, ' ') 
        IARGDB(1) = IKEEP   
        IARGDB(2) = IQUEST(1)   
        CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : all but'',I6,'' partitio'//    
     +       'ns deleted from '//PATHN(1:60)//' return code '',I6)',    
     +       IARGDB, 2) 
*   
      ELSE IF (CPATL.EQ.'DBPTIM') THEN  
*   
*  **   DBPTIM  
*   
        CALL KUGETI (IDATE) 
        CALL KUGETI (ITIME) 
        CALL DBPKTS (IDATE, ITIME, IARGDB(1))   
        IARGDB(2) = IDATE   
        IARGDB(3) = ITIME   
        CALL DBPRNT (L3PRDX, '(/,2X,I10,'' is the packed integer for '//    
     +       'date and time : '',2I10,/)', IARGDB, 3)   
*   
      ELSE IF (CPATL.EQ.'DBPURG') THEN  
*   
*  **   DBPURG  
*   
        CALL KUGETC (PATHN, NCH)    
        CALL KUGETI (KYDAT) 
        CALL KUGETI (KYTIM) 
        CALL KUGETC (CHOPT, NCH)    
        CALL DBPURG (PATHN, KYDAT, KYTIM, CHOPT)    
        NCH    = LENOCC (PATHN) 
        IF (NCH.GT.40) NCH = 40
        iarg(1) = iquest(1)
        CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : DBPURG deletes in Path '// 
     +       PATHN(1:NCH)//' return code '',I6)', iarg, 1) 
*   
      ELSE IF (CPATL.EQ.'DBRALI') THEN  
*   
*  **   DBRALI  
*   
        CALL KUGETC (ALIAS, NCH)    
        CALL DBRALI (ALIAS, PATHN)  
        CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Path name for alias '//    
     +       ALIAS//' is '//PATHN//''')', IARGDB, 0)    
*   
      ELSE IF (CPATL.EQ.'DBRENK') THEN  
*   
*  **   DBRENK  
*   
        CALL KUGETC (PATHN, NCH)    
        CALL KUGETI (KYI)   
        CALL KUGETI (KYEL)  
        CALL DBSBLC (PATHN, PATH, NCHAR)    
        CALL RZCDIR (PATH, ' ') 
        IF (IQUEST(1).EQ.0) THEN    
          NKEYDK = IQUEST(7)    
          NWKYDK = IQUEST(8)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          KST    = NWKYDK + 1   
          CALL DBKEYT   
          IF (NKEYDK.NE.0)  THEN    
            IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)    
            IOPTP  = JBIT (IOPTP, JPRTDB)   
          ELSE  
            IOPTP  = 0  
          ENDIF 
          IF (IOPTP.NE.0) THEN  
            CALL RZCDIR (PATH, 'R') 
            NCHAR  = LENOCC (PATH)  
            NKEYS  = NKEYDK 
            DO 45 JK = 1, NKEYS 
              IK     = NKEYS + 1 - JK   
              KPNT   = IUHUNT (IK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB), 
     +                         NKEYS*KST, KST)  
              IF (KPNT.GT.0) THEN   
                IPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB   
              ELSE  
                IPNT   = KOFSDB + LCDRDB + IKDRDB + (NKEYDK - 1) * KST  
              ENDIF 
              IF (IQ(IPNT+MOBJDB).GT.KYI) GO TO 45  
              CALL DBPATH (PATHX, IK)   
              CALL RZCDIR (PATHX, ' ')  
              IF (IQUEST(1).NE.0) THEN  
                PATHN  = PATH(1:NCHAR)//'/'//PATHX  
                CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Illegal Path name '    
     +               //PATHN//''')', IARGDB, 0) 
                GO TO 999   
              ENDIF 
              NKEYDK = IQUEST(7)    
              LCDRDB = IQUEST(11)   
              IKDRDB = IQUEST(13)   
              KK     = IUHUNT (KYI, IQ(KOFSDB+LCDRDB+IKDRDB+MSERDB),    
     +                         NKEYDK*KST, KST) 
              IF (KK.GT.0) THEN 
                KK     = (KK - MSERDB) / KST + 1    
                GO TO 50    
              ELSE
                iarg(1) = kyi
                CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Object '',I12'//   
     +               ','' not found in '//PATH//''')', iarg, 1)  
                GO TO 999   
              ENDIF 
   45       CONTINUE    
            iarg(1) = kyi
            CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Object '',I12'//   
     +           ','' not found in '//PATH//''')', iarg, 1)  
            GO TO 999   
          ELSE  
            KK     = IUHUNT (KYI, IQ(KOFSDB+LCDRDB+IKDRDB+MSERDB),  
     +                       NKEYDK*KST, KST)   
            IF (KK.GT.0) THEN   
              KK     = (KK - MSERDB) / KST + 1  
            ELSE
              iarg(1) = kyi
              CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Object '',I12'// 
     +             ','' not found in '//PATH//''')', iarg, 1)    
              GO TO 999 
            ENDIF   
          ENDIF 
   50     CALL DBKEYR (KK, NWKYDK, KEYS)    
          CALL UCOPY_i  (KEYS, KEYXS, NWKYDK) 
          IF (KYEL.GT.2.AND.KYEL.LE.NWKYDK.AND.KYEL.NE.MFLGDB.AND.  
     +        KYEL.NE.MITMDB)                     THEN  
            IF (KYEL.EQ.MBVRDB.OR.KYEL.EQ.MEVRDB) THEN  
              IF (KYEL.EQ.MBVRDB) THEN  
                CTEMP  = 'Begin'    
              ELSE  
                CTEMP  = 'End'  
              ENDIF 
              WRITE (CHPRO, 1003) 'YYMMDD', CTEMP   
              CALL KUPROI (CHPRO, IDATE)    
              WRITE (CHPRO, 1003) 'HHMMSS', CTEMP   
              CALL KUPROI (CHPRO, ITIME)    
              CALL DBPKTS (IDATE, ITIME, KEYXS(KYEL))   
            ELSE    
              WRITE (CHPRO, 1004) KYEL  
              IF (IOTYDK(KYEL).LE.2) THEN   
                CALL KUPROI (CHPRO, KEYXS(KYEL))    
              ELSE  
                CALL KUPROC (CHPRO, CTEMP, NCH) 
                CALL UCTOH  (CTEMP, KEYXS(KYEL), 4, 4)  
              ENDIF 
            ENDIF   
            CALL DBRENK (PATH, KEYS, KEYXS) 
            IARGDB(1) = KYEL    
            IARGDB(2) = KYI 
            IARGDB(3) = IQUEST(1)   
            CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Key '',I4,'' changed'//    
     +           ' for Object '',I12,'' in '//PATH(1:40)//' return co'//    
     +           'de '',I6)', IARGDB, 3)    
          ELSE  
            IARGDB(1) = KYEL    
            IARGDB(2) = NWKYDK  
            CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Key '',I4,'' illegal'//    
     +           ' for DBRENK - NWKYDK '',I8)', IARGDB, 2)  
          ENDIF 
        ELSE    
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Illegal Path name '//    
     +         PATH//''')', IARGDB, 0)  
        ENDIF   
*   
      ELSE IF (CPATL.EQ.'DBRHLP') THEN  
*   
*  **   DBRHLP  
*   
        CALL KUGETC (PATHN, NCH)    
        CALL KUGETC (CFNAM, NCH)    
        CALL DBOPEN (LUKYDX, CFNAM, 'UNKNOWN', ISTAT)   
        IF (ISTAT.EQ.0) THEN    
          CALL DBRHLP (PATHN, LUKYDX)   
          IERR = IQUEST(1)
          iarg(1) = ierr
          IF (IERR.NE.0) CALL DBPRNT (LUKYDX, '(/,'' DBAUXI : Error'//  
     +    ' '',I12,'' in getting help info. for '',/,'' '//PATHN(1:72)  
     +    //''')', iarg, 1) 
          CALL DBCLOS (LUKYDX)  
          CALL KUEDIT (CFNAM, IST)  
        ELSE
          iarg(1) = istat
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : error '',I12,'' in ope'//    
     +         'ning file '//CFNAM(1:NCH)//''')', iarg, 1) 
        ENDIF   
*   
      ELSE IF (CPATL.EQ.'DBRNAM') THEN  
*   
*  **   DBRNAM  
*   
        CALL KUGETC (PATHN, NCH)    
        NWMAX  = NOBJM  
        CALL DBRNAM (PATHN, NWMAX, CTAG)    
        CFMT(1:1)     = '(' 
        CFMT(120:120) = ')' 
        DO 60 I1 = 1, NWMAX, 5  
          I2     = I1 + 4   
          IF (I2.GT.NWMAX) I2 = NWMAX   
          CFMT(2:119) = ' ' 
          DO 55 I = I1, I2  
            IARGDB(I-I1+1) = I  
            K1             = (I - I1) * 23 + 2  
            K2             = K1 + 22    
            CFMT(K1:K2)    = ''' Tag '',I2,''         '','  
            CFMT(K1+13:K1+20) = CTAG(I) 
   55     CONTINUE  
          NARG   = I2 - I1 + 1  
          CALL DBPRNT (L3PRDX, CFMT, IARGDB, NARG)  
   60   CONTINUE    
*   
      ELSE IF (CPATL.EQ.'DBRTFZ') THEN  
*   
*  **   DBRTFZ  
*   
        CALL KUGETC (PATHN, NCH)    
        CALL KUGETI (LUNFZ) 
        CALL KUGETI (K1MIN) 
        CALL KUGETI (K1MAX) 
        CALL KUGETC (CHOPT, NCH)    
        CALL DBRTFZ (PATHN, LUNFZ, K1MIN, K1MAX, CHOPT) 
        NCH    = LENOCC (PATHN) 
        IF (NCH.GT.36) NCH = 36 
        IARGDB(1) = K1MIN   
        IARGDB(2) = K1MAX   
        IARGDB(3) = LUNFZ   
        IARGDB(4) = IQUEST(1)   
        CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Transfers '',I8,'' to'//   
     +       ' '',I8,'' objects from '//PATHN(1:NCH)//' to unit '',I4'//    
     +       ','' return code '',I6)', IARGDB, 4)   
*   
      ELSE IF (CPATL.EQ.'DBSHOW') THEN  
*   
*  **   DBSHOW  
*   
        CALL KUGETC (PATHN, NCH)    
        CALL KUGETC (CHOPT, NCH)    
        CALL DBPRIN (PATHN, CHOPT)  
*   
      ELSE IF (CPATL.EQ.'DBUTIM') THEN  
*   
*  **   DBUTIM  
*   
        CALL KUGETI (IDATM) 
        CALL DBUPTS (IARGDB(2), IARGDB(3), IDATM)   
        IARGDB(1) = IDATM   
        CALL DBPRNT (L3PRDX, '(/,2X,I10,'' is the packed integer for '//    
     +       'date and time : '',2I10,/)', IARGDB, 3)   
*   
      ELSE IF (CPATL.EQ.'DBVIEW') THEN  
*   
*  **   DBVIEW  
*   
        CALL KUGETC (PATHN, NCH)    
        CALL KUGETC (CFNAM, NCF)    
        CALL DBVIEW (CFNAM, PATHN)  
*   
      ELSE IF (CPATL.EQ.'DBWRITE') THEN 
*   
*  **   DBWRITE 
*   
        CALL KUGETC (PATHN, NCH)    
        CALL KUGETC (CFNAM, NCF)    
        CALL KUPROC ('Create Directory ? (Y/N)', YESNO, NCH)    
        IF (YESNO(1:1).EQ.'Y') CALL DBCRDR (PATHN)  
        CALL KUPROC ('Keys Insert/Update ? (Y/N)', YESNO, NCH)  
        IF (YESNO(1:1).EQ.'Y') THEN 
          CALL KUPROC ('Horizontal or Vertical Mode ? (H/V)',   
     +                  YESNO, NCH) 
          CALL UOPTC (YESNO, 'H', IOPHDD)   
          CALL DBEDKY (CFNAM, NCF, PATHN, 'A')  
        ENDIF   
*   
      ENDIF 
*   
 1001 FORMAT ('Tag(',I2,')')    
 1002 FORMAT (I2,'th Path name')    
 1003 FORMAT (A,' of ',A,' Range')  
 1004 FORMAT ('Key(',I2,') ?')  
*                                                             END DBAUXI    
  999 END   
      SUBROUTINE DBCLOS (LUN)   
*     =======================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBCLOS (LUN)                                            *    
*                                                                      *    
*   Closes unit LUN                                                    *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUN      Logical unit number                                     *    
*                                                                      *    
*   Called by DBACPL, DBACTI, DBAIWR, DBAUXI, DBEDAS, DBEDKY, DBPEEK,  *    
*             DBPRES, DBRDDA, DBRDIO                                   *    
*                                                                      *    
************************************************************************    
*   
*     ------------------------------------------------------------------    
*   
      CLOSE (LUN)   
*                                                             END DBCLOS    
  999 END   
      SUBROUTINE DBCONC (IOT, N, ICON, NSK) 
*     ===================================== 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBCONC (IOT, N, ICON*, NSK*)                            *    
*                                                                      *    
*   Routine to calculate the number of concatenated keys               *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IOT      I/O Type of the keys                                    *    
*     N        Length of the key-vector                                *    
*     ICON     Number of concatenated keys to present key              *    
*     NSK      Total number of concatenated keys                       *    
*                                                                      *    
*   Called by DBDISP, DBEDAS, DBJOIN, DBVWPR                           *    
*                                                                      *    
************************************************************************    
*   
      COMMON /DCONCT/ ISYSDC(100), IUSEDC(100)  
*   
      DIMENSION       ICON(9), IOT(9)   
*   
*     ------------------------------------------------------------------    
*   
      CALL VZERO_i (ICON(1), N)   
      NSK  = 0  
      I    = 0  
      ISYS = 0  
      IUSE = 0  
    5 CONTINUE  
      I    = I + 1  
      J    = 0  
      IF (I.GT.N) GO TO 999 
      IF (IOT(I).EQ.5) THEN 
        ISYS = ISYS + 1 
        IUSE = IUSE + 1 
        IUSEDC(ISYS) = IUSE 
        ISYSDC(IUSE) = ISYS 
   10   K    = I + J + 1    
        IF (K.LE.N.AND.IOT(K).EQ.6) THEN    
          ISYS = ISYS + 1   
          IUSEDC(ISYS) = IUSE   
          J    = J + 1  
          GO TO 10  
        ENDIF   
        ICON(I) = J 
        NSK  = NSK + J  
      ELSE  
        ISYS = ISYS + 1 
        IUSE = IUSE + 1 
        IUSEDC(ISYS) = IUSE 
        ISYSDC(IUSE) = ISYS 
      ENDIF 
      GO TO 5   
*                                                             END DBCONC    
  999 END   
      SUBROUTINE DBCRDR (PATHN) 
*     ========================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBCRDR (PATHN)                                          *    
*                                                                      *    
*   Routine to create DB Directory interactively                       *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*                                                                      *    
*   Called by DBACTI, DBAUXI                                           *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       PATHN*(*), CHKTY*100, KEYNM*8, KEYTP*1, YESNO*1   
*   
*     ------------------------------------------------------------------    
*   
*  **   Insert the System-Keys  
*   
      CHKTY  = CHFTDK   
      DO 10 I = 1, NSYSDK   
   10 CTAGDK(I) = CHTGDK(I) 
*   
* *** Check if it is a partitioned directory    
*   
      CALL KUPROC ('Is it a partitioned Directory ? (Y/N) ', YESNO, LYN)    
      IF (YESNO.EQ.'Y') THEN    
        CALL KUPROI ('Maximum number of objects in a partition ', MXKP) 
        IF (MXKP.LT.1.OR.MXKP.GT.MXKYDK) MXKP = MXKPDK  
      ELSE  
        MXKP   = 0  
      ENDIF 
*   
*  ** Get the Users Keys (Name and Type)    
*   
      NKEYS  = NSYSDK   
   15 CONTINUE  
      CALL KUPROC ('Key-Name ? (No more : |)', KEYNM, LKNM) 
      IF (KEYNM(1:1).EQ.'|') GO TO 30   
      NKEYS  = NKEYS + 1    
      CTAGDK(NKEYS) = KEYNM 
   20 CONTINUE  
      CALL KUPROC ('Key-Type ? (I,H,B or A)', KEYTP, LKTP)  
      IF (KEYTP.NE.'I'.AND.KEYTP.NE.'H'.AND.KEYTP.NE.'B'.AND.   
     +    KEYTP.NE.'A')      GO TO 20   
      CHKTY(NKEYS:NKEYS) = KEYTP    
      GO TO 15  
*   
*  ** Create the Directory  
*   
   30 CONTINUE  
      IF (MXKP.LE.0) THEN   
        CALL DBMDIR (PATHN, NKEYS, CHKTY, CTAGDK)   
      ELSE  
        CALL DBMDIP (PATHN, NKEYS, CHKTY, CTAGDK, MXKP) 
      ENDIF 
*                                                             END DBCRDR    
  999 END   
      SUBROUTINE DBCTOB (CVAL, ZVAL)    
*     ==============================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBCTOB (CVAL, ZVAL*)                                    *    
*                                                                      *    
*   Converts character string into hexadecimal bit string              *    
*                                                                      *    
*   This routine is taken from R.Brun                                  *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     CVAL     Character string (input)                                *    
*     ZVAL(*)  Hexadecimal bit string (output)                         *    
*                                                                      *    
*   Called by DBDCKH, DBDCKV, DBRDDA                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =100 : Error in decoding                               *    
*                                                                      *    
************************************************************************    
*   
      COMMON /QUEST/  IQUEST(100)   
      PARAMETER       (MXD=15)  
      CHARACTER       CVAL*(*)  
      CHARACTER*(MXD) CTEMP, BLANK  
      REAL*4          ZVAL  
*   
*     ------------------------------------------------------------------    
*   
      IQUEST(1) = 0 
      L  = LENOCC(CVAL) 
      IF (L.EQ.0) GO TO 999 
      IF (L.GT.MXD) THEN    
        IQUEST(1) = 100 
        GO TO 999   
      ENDIF 
      BLANK = ' '   
      IF (L.EQ.MXD) THEN    
        CTEMP = CVAL    
      ELSE  
        CTEMP = BLANK(1:MXD-L)//CVAL    
      ENDIF 
      READ (CTEMP, '(Z15)', ERR=100) ZVAL   
      GO TO 999 
  100 IQUEST(1) = 100   
*                                                             END DBCTOB    
  999 END   
      SUBROUTINE DBCTOI (CVAL, IVAL)    
*     ==============================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBCTOI (CVAL, IVAL*)                                    *    
*                                                                      *    
*   Converts character string into integer value                       *    
*                                                                      *    
*   This routine is taken from R.Brun                                  *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     CVAL     Character string (input)                                *    
*     IVAL(*)  Integer value (output)                                  *    
*                                                                      *    
*   Called by DBCTOR, DBDCKH, DBDCKV, DBRDDA                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =100 : Error in decoding                               *    
*                                                                      *    
************************************************************************    
*   
      COMMON /QUEST/  IQUEST(100)   
      PARAMETER       (MXD=15)  
      CHARACTER       CVAL*(*)  
      CHARACTER*(MXD) CTEMP, BLANK  
      INTEGER         IVAL  
*   
*     ------------------------------------------------------------------    
*   
      IQUEST(1) = 0 
      L  = LENOCC(CVAL) 
      IF (L.EQ.0) GO TO 999 
      IF (L.GT.MXD) THEN    
        IQUEST(1) = 100 
        GO TO 999   
      ENDIF 
      BLANK = ' '   
      IF (L.EQ.MXD) THEN    
        CTEMP = CVAL    
      ELSE  
        CTEMP = BLANK(1:MXD-L)//CVAL    
      ENDIF 
      READ (CTEMP, '(I15)', ERR=100) IVAL   
      GO TO 999 
  100 IQUEST(1) = 100   
*                                                             END DBCTOI    
  999 END   
      SUBROUTINE DBCTOR (CVAL, RVAL)    
*     ==============================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBCTOR (CVAL, RVAL*)                                    *    
*                                                                      *    
*   Converts character string into real value                          *    
*                                                                      *    
*   This routine is taken from R.Brun                                  *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     CVAL     Character string (input)                                *    
*     RVAL(*)  Real value (output)                                     *    
*                                                                      *    
*   Called by DBDCKV, DBRDDA                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =100 : Error in decoding                               *    
*                                                                      *    
************************************************************************    
*   
      COMMON /QUEST/  IQUEST(100)   
      PARAMETER       (MXD=15)  
      CHARACTER       CVAL*(*)  
      CHARACTER*(MXD) CTEMP, BLANK  
      REAL            RVAL  
*   
*     ------------------------------------------------------------------    
*   
      IQUEST(1) = 0 
      L  = LENOCC(CVAL) 
      IF (L.EQ.0)       GO TO 999   
      IF (L.GT.MXD)     GO TO 900   
      BLANK = ' '   
      IF (L.EQ.MXD) THEN    
        CTEMP = CVAL    
      ELSE  
        CTEMP = BLANK(1:MXD-L)//CVAL    
      ENDIF 
*   
      CALL CLTOU (CTEMP)    
*   
      I1  = INDEX (CTEMP, '.')  
      II1 = 0   
      IF (I1.LT.L) II1 = INDEX (CTEMP(I1+1:MXD), '.')   
      I2  = INDEX (CTEMP, 'E')  
      II2 = 0   
      IF (I2.LT.L) II2 = INDEX (CTEMP(I2+1:MXD), 'E')   
*   
      IF (II1+II2.NE.0) GO TO 900   
*   
      IF (I1+I2.EQ.0) THEN  
        CALL DBCTOI (CTEMP,IVAL)    
        RVAL = IVAL 
      ELSE IF (I1.EQ.L.AND.I2.EQ.0) THEN    
        CALL DBCTOI (CTEMP(:I1-1), IVAL)    
        RVAL = IVAL 
      ELSE  
        READ (CTEMP, '(G15.9)', END=999, ERR=900) RVAL  
      ENDIF 
      GO TO 999 
*   
  900 IQUEST(1) = 100   
*                                                             END DBCTOR    
  999 END   
      SUBROUTINE DBDCKH (CHPRT, KY, IKEY)   
*     ===================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBDCKH (CHPRT, KY*, IKEY*)                              *    
*                                                                      *    
*   Fills a vector KY of elements NWKYDK according to its type IOTYDD  *    
*   from the character string CHPRT in Horizontal Mode                 *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     CHPRT    Character string containing the keys to be decoded      *    
*     KY       Vector to be filled with the decoded elements           *    
*     IKEY     Serial number of the key to be filled                   *    
*                                                                      *    
*   Other variables :                                                  *    
*                                                                      *    
*     IOTYDD   Type of the vector elements                             *    
*          1 - Binary                                                  *    
*          2   Integer                                                 *    
*          3   Floating                                                *    
*          4   Double Precision (not yet implemented)                  *    
*          5   Hollerith                                               *    
*          6   Hollerith concatenetad to previous hollerith            *    
*          7   Packed integer - time packed upto seconds               *    
*          8   Packed integer - time packed upto minutes               *    
*          9   Data which should not be displayed                      *    
*     ICONDK   Number of keys concatenated to the present one          *    
*     NWKYDK   Number of elements in the array KY (and IOTYDD)         *    
*                                                                      *    
*   Called by  DBEDAS, DBEDKY                                          *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       CHPRT*(*) 
      DIMENSION       KY(9) 
      real*4 rky(9)
      integer kky(9), iii
      equivalence (kky,rky)
*   
*     ------------------------------------------------------------------    
*   
      READ (CHPRT(2:9), '(I8)') IKEY    
      CALL VZERO_i (KY(1), NWKYDK)    
      ISTR = 12 
      DO 10 I = 1, NWKYDK   
        KK    = IOTYDD(I)   
        GO TO (1,2,10,10,5,10,7,8,10), KK   
    1   CONTINUE    
*   
*  **   Binary  
*   
        IEND = ISTR + NUMCDD(I) - 3 
        CALL DBCTOB (CHPRT(ISTR:IEND), rKY(I))   
        do iii=1, 9
          ky(i)=kky(i)
        enddo
        ISTR = IEND + 3 
        GO TO 10    
    2   CONTINUE    
*   
*  **   Integer 
*   
        IEND = ISTR + NUMCDD(I) - 3 
        CALL DBCTOI (CHPRT(ISTR:IEND), KY(I))   
        ISTR = IEND + 3 
        GO TO 10    
    5   CONTINUE    
*   
*  **   Hollerith   
*   
        IEND = ISTR + NUMCDD(I) - 3 
        IREP = ICONDK(I) + 1    
        IF (IREP.EQ.1) THEN 
          DO 51 J = ISTR, IEND  
            IF (CHPRT(J:J).EQ.' ') THEN 
              GO TO 51  
            ELSE IF (CHPRT(J:J).EQ.'''') THEN   
              IST = J + 1   
              GO TO 52  
            ELSE    
              IST = J   
              GO TO 52  
            ENDIF   
   51     CONTINUE  
   52     CONTINUE  
          ISTR = IST    
        ENDIF   
        CALL UCTOH (CHPRT(ISTR:IEND), KY(I), 4, 4*IREP) 
        ISTR = IEND + 3 
        GO TO 10    
    7   CONTINUE    
*   
*  **   Packed Integer (upto seconds)   
*   
        IEND = ISTR + NUMCDD(I) - 3 
        I1 = ISTR   
        I2 = I1 + 5 
        READ  (CHPRT(I1:I2), '(I6)') IDATE  
        I1 = I2 + 2 
        I2 = I1 + 5 
        READ  (CHPRT(I1:I2), '(I6)') ITIME  
        ISTR = IEND + 3 
        CALL DBPKTS (IDATE, ITIME, KY(I))   
        GO TO 10    
    8   CONTINUE    
*   
*  **   Packed Integer (upto minutes)   
*   
        IEND = ISTR + NUMCDD(I) - 3 
        I1 = ISTR   
        I2 = I1 + 5 
        READ  (CHPRT(I1:I2), '(I6)') IDATE  
        I1 = I2 + 2 
        I2 = I1 + 5 
        READ  (CHPRT(I1:I2), '(I6)') ITIME  
        ISTR = IEND + 3 
        CALL DBPKTM (IDATE, ITIME, KY(I))   
        GO TO 10    
*   
   10 CONTINUE  
      IQUEST(1) = 0 
      GO TO 999 
*                                                             END DBDCKH    
  999 END   
      SUBROUTINE DBDCKV (LUN, IC, KY)   
*     ===============================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBDCKV (LUN, IC, KY*)                                   *    
*                                                                      *    
*   Decodes values of a key vector (KY) stored in Vertical mode        *    
*   (in NL lines on a file on unit LUN)                                *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUN      Logical Unit number containing the file to be decoded   *    
*     IC       Number of keys concatenated to the present one          *    
*     KY       Vector containing the decoded elements                  *    
*                                                                      *    
*   Called by  DBEDAS, DBEDKY                                          *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       LINE*80, CHFOR*1, CHVAL*80    
      DIMENSION       KY(9), IC(9)  
      real rky
      integer kky
      equivalence (rky, kky)
*   
*     ------------------------------------------------------------------    
*   
      J = 0 
    5 READ (LUN, '(A80)', END=999) LINE 
*   
      NCH = LENOCC (LINE)   
      IF (NCH.LE.0)    GO TO 30 
      CHVAL = ' '   
      I = 13    
      CHFOR = LINE(I:I) 
      DO 6 K = I+1, NCH 
        IF (LINE(K:K).NE.' ') THEN  
          CHVAL = LINE(K:NCH)   
          GO TO 20  
        ENDIF   
    6 CONTINUE  
*   
   20 J = J + 1 
      IF (CHFOR.EQ.'I') THEN    
        CALL DBCTOI (CHVAL, KY(J))  
      ELSE IF (CHFOR.EQ.'F') THEN   
        CALL DBCTOR (CHVAL, rKY)  
        ky(j)=kky
      ELSE IF (CHFOR.EQ.'B') THEN   
        CALL DBCTOB (CHVAL, rKY)  
        ky(j) = kky
      ELSE IF (CHFOR.EQ.'H') THEN   
        NREP = IC(J)    
        LCDAT = 4*(NREP+1)  
        CALL UCTOH (CHVAL, KY(J), 4, LCDAT) 
        J = J + NREP    
      ELSE IF (CHFOR.EQ.'S') THEN   
        NC = LENOCC (CHVAL) 
        DO 21 K = 1, NC 
          IF (CHVAL(K:K).EQ.' ') THEN   
            KK = K  
            GO TO 22    
          ENDIF 
   21   CONTINUE    
        KY(J) = 0   
        GO TO 25    
   22   CONTINUE    
        CALL DBCTOI (CHVAL(1:KK-1), IDATE)  
        CALL DBCTOI (CHVAL(KK:NC),  ITIME)  
        CALL DBPKTS (IDATE, ITIME, KY(J))   
      ELSE IF (CHFOR.EQ.'M') THEN   
        NC = LENOCC (CHVAL) 
        DO 23 K = 1, NC 
          IF (CHVAL(K:K).EQ.' ') THEN   
            KK = K  
            GO TO 24    
          ENDIF 
   23   CONTINUE    
        KY(J) = 0   
        GO TO 25    
   24   CONTINUE    
        CALL DBCTOI (CHVAL(1:KK-1), IDATE)  
        CALL DBCTOI (CHVAL(KK:NC),  ITIME)  
        CALL DBPKTM (IDATE, ITIME, KY(J))   
      ENDIF 
   25 IF (J.LT.NWKYDK) GO TO 5  
   30 CONTINUE  
*                                                             END DBDCKV    
  999 END   
      SUBROUTINE DBDHEA (IOKEY, NK, CHEAD)  
*     ====================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBDHEA (IOKEY, NK, *CHEAD)                              *    
*                                                                      *    
*   Writes the Header of the Display in Horizontal Mode into the       *    
*   Character Variable CHEAD                                           *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IOKEY    Type of the Key                                         *    
*          1 - Binary                                                  *    
*          2   Integer                                                 *    
*          3   Floating                                                *    
*          4   Double Precision (not yet implemented)                  *    
*          5   Hollerith                                               *    
*          6   Hollerith concatenetad to previous hollerith            *    
*          7   Packed integer - time packed upto seconds               *    
*          8   Packed integer - time packed upto minutes               *    
*          9   Data which should not be displayed                      *    
*     NK       Number of Keys                                          *    
*     CHEAD    Character variable containing the header                *    
*                                                                      *    
*   Called by DBDISD, DBDISH                                           *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      DIMENSION       IOKEY(NK) 
      CHARACTER       CHEAD*(*) 
*   
*     ------------------------------------------------------------------    
*   
      IPOS = 11 
      DO 5 I = 1,NK 
        IF (IOKEY(I).NE.9) THEN 
          NSP = MAX0 ((NUMCDD(I)-8)/2,1)    
          IW = IPOS + NSP   
          CHEAD(IW:IW+7) = CTAGDK(I)    
          IPOS = IPOS + NUMCDD(I)   
        ENDIF   
    5 CONTINUE  
*                                                             END DBDHEA    
      END   
      SUBROUTINE DBDISD (LUN, PATHN, KEYX, CHOPT)   
*     ===========================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBDISD (LUN, PATHN, KEYX, CHOPT)                        *    
*                                                                      *    
*   Display the data attached to the directory PATHN and KEY           *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUN      Unit number of file for display                         *    
*     PATHN    Character string describing the pathname                *    
*     KEYX     Key-vector                                              *    
*     CHOPT    Character option                                        *    
*          E   Only example for display to be shown                    *    
*                                                                      *    
*   Called by DBRDIO                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =101 : Illegal path name                               *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      DIMENSION       KEYX(9)   
      CHARACTER       PATHN*(*), CHOPT*(*), CHEAD*300   
      CHARACTER       PATHY*80, PATHX*16    
      CHARACTER       CB*1, CC*1, CI*1, CF*1, DC*4, BLANK*10    
      INTEGER         DB, DI    
      DATA            CB /'B'/, CC /'H'/, CI /'I'/, CF /'F'/    
      DATA            BLANK /' '/   
      DATA            DB /101/, DC /'DATA'/, DI /77/, DF /777.777/  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
* *** Set the current directory 
*   
      CALL UOPTC (CHOPT, 'E', IOPTE)    
      PATHY  = PATHN    
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0)                        GO TO 991  
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      ISTP   = NWKYDK + 1   
      IF (NKEYDK.GT.0) THEN 
        IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB) 
      ELSE  
        IOPTP  = 0  
      ENDIF 
      CALL DBKYTG   
*   
*  ** Display keys  
*   
      NCHR   = LEN (PATHN)  
      NCH    = INDEX (PATHN, ' ') - 1   
      IF (NCH.EQ.0) NCH = NCHR  
      WRITE (LUN, 1001) PATHN(1:NCH)    
      IF ((IOPTE.NE.0) .OR. (IOPHDD.EQ.0)) THEN 
        WRITE (LUN, 1002) CTAGDK(1) 
      ELSE  
        CHEAD = ' ' 
        CALL DBDHEA (IOTYDD(1), NWKYDK, CHEAD)  
        WRITE (LUN, 1003) CHEAD(1:MXDPDD)   
      ENDIF 
*   
      IF (IOPTE.NE.0) THEN  
        CALL DBUPTS (IDV1, ITV1, KEYX(MBVRDB))  
        CALL DBUPTS (IDV2, ITV2, KEYX(MEVRDB))  
        WRITE (LUN, 1004) IDV1, ITV1, IDV2, ITV2    
*   
*  **   Write steering lines as format indication   
*   
        WRITE (LUN, 1005) CB, DB, CC, DC, CI, DI, CF, DF    
      ELSE  
*   
*  **   Read in the data    
*   
        JBIAS  = 2  
        IF (LFRSDX.NE.0) THEN   
          CALL MZDROP (IDIVDB, LFRSDX, 'L') 
          LFRSDX = 0    
        ENDIF   
        IF (NKEYDK.EQ.0) THEN   
          CALL UCOPY_i (KEYX, KEYVDK, NWKYDK) 
          GO TO 20  
        ENDIF   
        IF (IOPTP.EQ.0) THEN    
          IPNT   = KOFSDB + LCDRDB + IKDRDB 
          KPNT   = IUHUNT (KEYX(MSERDB), IQ(IPNT+MSERDB), ISTP*NKEYDK,  
     +                     ISTP)    
          IF (KPNT.GT.0) THEN   
            KEYVDK(MSERDB) = (KPNT - MSERDB) / ISTP + 1 
          ELSE  
            KEYVDK(MSERDB) = NKEYDK 
          ENDIF 
        ELSE    
          NKEYS  = NKEYDK   
          IPNT   = KOFSDB + LCDRDB + IKDRDB 
          DO 10 JK = 1, NKEYS   
            IK     = NKEYS + 1 - JK 
            KPNT   = IUHUNT (IK, IQ(IPNT+MPSRDB), NKEYS*ISTP, ISTP) 
            IF (KPNT.GT.0) THEN 
              KPNT   = IPNT + KPNT - MPSRDB 
            ELSE    
              KPNT   = IPNT + (IK - 1) * ISTP   
            ENDIF   
            IF (IQ(KPNT+MOBJDB).GT.KEYX(MSERDB)) GO TO 10   
            CALL DBPATH (PATHX, IK) 
            PATHY  = PATHN(1:NCH)//'/'//PATHX   
            CALL RZCDIR (PATHY, ' ')    
            IF (IQUEST(1).NE.0)                  GO TO 991  
            LCDRDB = IQUEST(11) 
            IKDRDB = IQUEST(13) 
            NKEYDK = IQUEST(7)  
            IPNT   = KOFSDB + LCDRDB + IKDRDB   
            KPNT   = IUHUNT (KEYX(MSERDB), IQ(IPNT+MSERDB), ISTP*NKEYDK,    
     +                       ISTP)  
            IF (KPNT.GT.0) THEN 
              KEYVDK(MSERDB) = (KPNT - MSERDB) / ISTP + 1   
            ELSE    
              KEYVDK(MSERDB) = NKEYDK   
            ENDIF   
            GO TO 15    
   10     CONTINUE  
        ENDIF   
   15   ITIME  = 1  
        IOLD1  = IOKYDA(MSERDB) 
        IOLDK  = IOPKDA 
        IOKYDA(MSERDB) = 1  
        IOPKDA = 0  
        CALL DBKXIN (ITIME, IDIVDB, LFRSDX, LFRSDX, JBIAS, NWKYDK,  
     +               KEYVDK, IPREC) 
        IOKYDA(MSERDB) = IOLD1  
        IOPKDA = IOLDK  
        IF (IOPTP.NE.0) THEN    
          IER    = IQUEST(1)    
          CALL RZCDIR (PATHN, ' ')  
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          NKEYDK = IQUEST(7)    
          IQUEST(1) = IER   
        ENDIF   
*   
   20   IF (IOPHDD.EQ.0) THEN   
          WRITE (LUN, 1006) KEYX(MSERDB)    
        ELSE    
          CALL DBDKYH (LUN, NWKYDK, KEYVDK, IOTYDD, ICONDK, IKEY)   
        ENDIF   
*   
*  **   Display data if exists, if it does not, display dummy data  
*   
        IF ((IQUEST(1).EQ.0) .AND. (IQ(KOFUDB+LFRSDX-1).GT.0)) THEN 
          CALL DBWRDP (LUN, LFRSDX) 
        ELSE    
          WRITE (LUN, 1005) CB, DB, CC, DC, CI, DI, CF, DF  
        ENDIF   
        IF (LFRSDX.NE.0) THEN   
          IER    = IQUEST(1)    
          CALL MZDROP (IDIVDB, LFRSDX, ' ') 
          IQUEST(1) = IER   
        ENDIF   
        IF (IQUEST(1).NE.0)                      GO TO 999  
      ENDIF 
*   
      IQUEST(1) = 0 
      WRITE (LUN, 1007) 
      GO TO 999 
*   
* *** Error messages    
*   
  991 IQUEST(1) = 101   
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDISD : Illegal '// 
     +   'Path Name '//PATHY//''')', IARGDB, 0) 
      GO TO 999 
*   
 1001 FORMAT ('     Data in Directory and Key-Vector'/A)    
 1002 FORMAT (/3X,A8,3X)    
 1003 FORMAT (/A)   
 1004 FORMAT (10X,'Object inserted with validity ',2I8,' to ',2I8)  
 1005 FORMAT (1X,A,4X,'1',4X,Z10,10X, 'This line is only an example !'  
     +      /,1X,A,4X,'2',4X,A4 ,16X, 'This line is only an example !'  
     +      /,1X,A,4X,'3',4X,I10,10X, 'This line is only an example !'  
     +      /,1X,A,4X,'4',4X,E12.4,8X,'This line is only an example !') 
 1006 FORMAT (I10)  
 1007 FORMAT (4X,'We have reached the End of File Position - ', 
     +        'do not delete this line !!') 
*                                                             END DBDISD    
  999 END   
      SUBROUTINE DBDISH (LUN, PATHN, MINKY, MAXKY, IFLG, CHOPT) 
*     ========================================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBDISH (LUN, PATHN, MINKY, MAXKY, IFLG, CHOPT)          *    
*                                                                      *    
*   Displays the keys in horizontal mode                               *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUN      Unit number of file for display                         *    
*     PATHN    Character string describing the pathname                *    
*     MINKY    Minimum object number to be displayed (for IFLG=0)      *    
*     MAXKY    Maximum object number to be displayed (for IFLG=0)      *    
*     IFLG     Flag to decide if objects (=0) or only template (=1)    *    
*              to be shown                                             *    
*     CHOPT    Character with any of the follwing characters           *    
*          K   Display all the keys (Default)                          *    
*          U   Display only user keys and validities                   *    
*                                                                      *    
*   Called by DBDISP                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       PATHN*(*), CHOPT*(*), CHEAD*300   
      DIMENSION       IDPFL(100)    
*   
*     ------------------------------------------------------------------    
*   
      NCHR   = LEN (PATHN)  
      NCH    = INDEX (PATHN, ' ') - 1   
      IF (NCH.EQ.0) NCH = NCHR  
      WRITE (LUN, 1001) PATHN(1:NCH)    
      IF (IFLG.NE.0) GO TO 20   
*   
* *** Range of the keys to be displayed 
*   
    5 CONTINUE  
      IF (CHOPT.EQ.'U') THEN    
        CALL DBDPRG (IDPFL, NWKYDK, 'EDIT') 
      ELSE  
        CALL DBDPRG (IDPFL, NWKYDK, 'TERM') 
      ENDIF 
      CALL DBRGCK (IDPFL, NWKYDK, NDISP, IOTYDD)    
      IF (NDISP.GT.MXDPDD) THEN 
        CALL DBPRNT (LPRTDB, '(''   DBDISH : Not enough space to disp'//    
     +       'lay.'',/,''   Enlarge display range by DBSETD or use V-'//    
     +       'mode.'')', IARGDB, 0) 
        IF (CHOPT.EQ.'U') THEN  
          WRITE (LUN, 1002) 
          GO TO 999 
        ENDIF   
        GO TO 5 
      ENDIF 
*   
*  ** Display header with a template    
*   
      CHEAD  = ' '  
      CALL DBDHEA (IOTYDD(1), NWKYDK, CHEAD)    
      CALL DBTEMP (IOTYDD(1), NWKYDK, CHEAD)    
      WRITE (LUN, 1003) CHEAD(1:MXDPDD) 
*   
*  ** Display keys  
*   
      IOLD1  = IOKYDA(MSERDB)   
      IOLDK  = IOPKDA   
      IOPKDA = 1    
      IOKYDA(MSERDB) = 1    
      ITIME  = 1    
      JBIAS  = 2    
      DO 10 IKEY = MINKY, MAXKY 
        KEYVDK(MSERDB) = IKEY   
        CALL DBKXIN (ITIME, IDISDB, LAUXDL(7), LAUXDL(7), JBIAS, NWKEY, 
     +               KEYVDK, IPREC) 
        IF (IQUEST(1).EQ.0) THEN    
          CALL DBDKYH (LUN, NWKYDK, KEYVDK, IOTYDD, ICONDK, IKEY)   
        ENDIF   
   10 CONTINUE  
*   
      IQUEST(1) = 0 
      IOKYDA(MSERDB) = IOLD1    
      IOPKDA = IOLDK    
      WRITE (LUN, 1004) 
      GO TO 999 
*   
* *** Display the template  
*   
   20 CONTINUE  
      CALL DBDPRG (IDPFL, NWKYDK, ' ')  
      CALL DBRGCK (IDPFL, NWKYDK, NDISP, IOTYDD)    
      IF (NDISP.GT.MXDPDD) THEN 
        CALL DBPRNT (LPRTDB, '(''   DBDISH : Not enough space to disp'//    
     +       'lay.'',/,''   Enlarge display range by DBSETD or use V-'//    
     +       'mode.'')', IARGDB, 0) 
        WRITE (LUN, 1002)   
        GO TO 999   
      ENDIF 
*   
*  ** Display header    
*   
        CHEAD = ' ' 
        CALL DBDHEA (IOTYDD(1), NWKYDK, CHEAD)  
        WRITE (LUN, 1003) CHEAD(1:MXDPDD)   
*   
*  ** Display template  
*   
      CHEAD  = 'N'  
      CHEAD(9:9) = '1'  
      CALL DBTEMP (IOTYDD(1), NWKYDK, CHEAD)    
      WRITE (LUN, 1003) CHEAD(1:MXDPDD) 
      WRITE (LUN, 1005) 
      IQUEST(1) = 0 
      WRITE (LUN, 1004) 
*   
 1001 FORMAT ('   Keys in Directory to be displayed/updated: '/A)   
 1002 FORMAT ('   DBDISH : Not enough space to display.'    
     +       /'   Enlarge display range by DBSETD or use V-mode.')  
 1003 FORMAT (/A)   
 1004 FORMAT ('    We have reached the End of File Position')   
 1005 FORMAT ('    The Directory does not contain any object  ' 
     +       /'    Insert the value of the keys for the first object'   
     +       /'    between the vertical bars on the template')  
*                                                             END DBDISH    
  999 END   
      SUBROUTINE DBDISP (LUN, PATHN, CHOPT) 
*     ===================================== 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBDISP (LUN, PATHN, *CHOPT*)                            *    
*                                                                      *    
*   Displays objects attached to the directory PATHN                   *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUN      Unit number of file for display                         *    
*     PATHN    Character string describing the pathname                *    
*     CHOPT    Character with any of the follwing characters           *    
*          K   Display all the keys (Default)                          *    
*          U   Display only user keys and validities                   *    
*     (*)  I   Display template to type in new keys (Return value)     *    
*                                                                      *    
*   Called by DBAUXI, DBEDKY, DBPEEK                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =101 : Illegal path name                               *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       PATHN*(*), CHOPT*(*), PATHX*16, CFORM*67  
      DATA            MAXLN /1000/  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
* *** Set the current directory 
*   
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0)     GO TO 991 
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKYTG   
      CALL DBCONC (IOTYDK(1), NWKYDK, ICONDK(1), NSKPDK)    
      CALL UCOPY_i  (IOTYDK(1), IOTYDD(1), NWKYDK)    
*   
* *** Check the number of keys  
*   
      IF (NKEYDK.EQ.0) THEN 
        IFLG   = 1  
      ELSE  
        IFLG   = 0  
        MINKY  = 1  
        IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)    
        IOPTP  = JBIT (IOPTP, JPRTDB)   
        IF (IOPTP.EQ.0) THEN    
          MAXKY  = NKEYDK   
        ELSE    
          KST    = NWKYDK + 1   
          KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB), 
     +                     NKEYDK*KST, KST) 
          IF (KPNT.GT.0) THEN   
            IPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB   
          ELSE  
            IPNT   = KOFSDB + LCDRDB + IKDRDB + (NKEYDK - 1) * KST  
          ENDIF 
          KOBJ   = IQ(IPNT+MOBJDB)  
          CALL DBPATH (PATHX, NKEYDK)   
          CALL RZCDIR (PATHX, ' ')  
          IF (IQUEST(1).NE.0) GO TO 991 
          NKEYS  = IQUEST(7)    
          MAXKY  = KOBJ + NKEYS 
          IF (MAXKY.LE.0) IFLG = 1  
          CALL RZCDIR (PATHN, ' ')  
          IF (IQUEST(1).NE.0) GO TO 991 
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
        ENDIF   
        IF (IOPHDD.NE.0) THEN   
          LENOB  = MAXKY    
        ELSE    
          LENOB  = MAXKY * NWKYDK   
        ENDIF   
        IF (LENOB.GT.MAXLN) THEN    
          WRITE (CFORM, 1000) MAXKY 
          CALL KUPROI (CFORM, MINKY)    
          IF (IOPHDD.NE.0) THEN 
            MAXK   = MINKY + MAXLN  
          ELSE  
            MAXK   = MINKY + MAXLN/NWKYDK   
          ENDIF 
          MAXKY = MIN0 (MAXKY, MAXK)    
        ENDIF   
      ENDIF 
*   
* *** Now display the keys  
*   
      IF (IOPHDD.NE.0) THEN 
        CALL DBDISH (LUN, PATHN, MINKY, MAXKY, IFLG, CHOPT) 
      ELSE  
        CALL DBDISV (LUN, PATHN, MINKY, MAXKY, IFLG, CHOPT) 
      ENDIF 
      IQUEST(1) = 0 
      IF (IFLG.EQ.1) CHOPT = 'I'    
      GO TO 999 
*   
* *** Error messages    
*   
  991 IQUEST(1) = 101   
      IF (IDEBDB.GT.0) THEN 
        CFORM  = PATHN  
        CALL DBPRNT (LPRTDB, '(/,'' DBDISP : Illegal Path Name '//CFORM 
     +       //''')', IARGDB, 0)    
      ENDIF 
      GO TO 999 
*   
 1000 FORMAT ('Directory too Long --',I10,' Objects - First Object to'  
     +,' Display ?')    
*                                                             END DBDISP    
  999 END   
      SUBROUTINE DBDISV (LUN, PATHN, MINKY, MAXKY, IFLG, CHOPT) 
*     ========================================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBDISV (LUN, PATHN, MINKY, MAXKY, IFLG, CHOPT)          *    
*                                                                      *    
*   Displays the keys in vertical mode                                 *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUN      Unit number of file for display                         *    
*     PATHN    Character string describing the pathname                *    
*     MINKY    Minimum object number to be displayed (for IFLG=0)      *    
*     MAXKY    Maximum object number to be displayed (for IFLG=0)      *    
*     IFLG     Flag to decide if objects (=0) or only template (=1)    *    
*              to be shown                                             *    
*     CHOPT    Character with any of the follwing characters           *    
*          K   Display all the keys (Default)                          *    
*          U   Display only user keys and validities                   *    
*                                                                      *    
*   Called by DBDISP                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       DEFST(7)*20, CHPRT*40, CFORS(7)*1, CFOR*1 
      CHARACTER       PATHN*(*), CHOPT*(*)  
*   
      DATA         DEFST /'                    ','                    ' 
     +                   ,'800000          0   ','991231     235959   ',    
     +                    '     1              ','                    ',    
     +                    '                    '/   
      DATA            CHPRT /'  Object Number :               ==>    D'/    
      DATA            CFORS  /'U', 'U', 'S', 'S', 'I', 'U', 'U'/    
*   
*     ------------------------------------------------------------------    
*   
      NCHR   = LEN (PATHN)  
      NCH    = INDEX (PATHN, ' ') - 1   
      IF (NCH.EQ.0) NCH = NCHR  
      WRITE (LUN, 1001) PATHN(1:NCH)    
      IF (IFLG.NE.0)     GO TO 20   
*   
*  ** Display keys  
*   
      IOTYDD(MBVRDB) = 7    
      IOTYDD(MEVRDB) = 7    
      IOTYDD(MITMDB) = 8    
      IF (CHOPT.EQ.'U') THEN    
        IOTYDD(MSERDB) = 9  
        IOTYDD(MUPNDB) = 9  
        IOTYDD(MFLGDB) = 9  
      ENDIF 
*   
      CHPRT(40:40) = 'D'    
      IOLD1  = IOKYDA(MSERDB)   
      IOLDK  = IOPKDA   
      IOPKDA = 1    
      IOKYDA(MSERDB) = 1    
      ITIME  = 1    
      JBIAS  = 2    
      DO 10 IKEY = MINKY, MAXKY 
        KEYVDK(MSERDB) = IKEY   
        CALL DBKXIN (ITIME, IDISDB, LAUXDL(7), LAUXDL(7), JBIAS, NWKEY, 
     +               KEYVDK, IPREC) 
        IF (IQUEST(1).EQ.0) THEN    
          WRITE (CHPRT(21:30), 1002) IKEY   
          WRITE (LUN, 1003) CHPRT   
          CALL DBDKYV (LUN, NWKYDK, CTAGDK, KEYVDK, IOTYDD, ICONDK) 
        ENDIF   
   10 CONTINUE  
*   
      IQUEST(1) = 0 
      IOKYDA(MSERDB) = IOLD1    
      IOPKDA = IOLDK    
      WRITE (LUN, 1004) 
      GO TO 999 
*   
* *** No keys prepare the template  
*   
   20 IKEY = 1  
      CHPRT(40:40) = 'N'    
      WRITE (CHPRT(21:30), 1002) IKEY   
      WRITE (LUN, 1003) CHPRT   
      DO 25 IPR = 1, 7  
        WRITE (LUN, 1005) CTAGDK(IPR), CFORS(IPR), DEFST(IPR)   
   25 CONTINUE  
      IPR  = 7  
   30 CONTINUE  
      IPR  = IPR + 1    
      IF (IPR.GT.NWKYDK) GO TO 35   
      CFOR = 'I'    
      IF (IOTYDK(IPR).EQ.1) CFOR = 'B'  
      IF (IOTYDK(IPR).EQ.5) CFOR = 'H'  
      WRITE (LUN, 1005) CTAGDK(IPR), CFOR   
      IF (CFOR.EQ.'H') THEN 
        NREP = ICONDK(IPR)  
        IPR  = IPR + NREP   
      ENDIF 
      GO TO 30  
   35 WRITE (LUN, 1006) 
      IQUEST(1) = 0 
*   
 1001 FORMAT ('   Keys in Directory to be displayed/updated: '/A)   
 1002 FORMAT (I10)  
 1003 FORMAT (A)    
 1004 FORMAT ('    We have reached the End of File Position')   
 1005 FORMAT ('  ',A8,'  ',A1,'                ',A) 
 1006 FORMAT ('   The Directory does not contain any object - ' 
     +       /'  The above line contains the default values for the'    
     +       /'  system keys and a format specification for the others')    
*                                                             END DBDISV    
  999 END   
      SUBROUTINE DBDKYH (LUN, NW, KY, KT, ICON, IKEY)   
*     ===============================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBDKYH (LUN, NW, KY, KT, ICON, IKEY)                    *    
*                                                                      *    
*   Displays a vector KY of elements NW according to its type KT       *    
*   in Horizontal Mode                                                 *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUN      Unit number of the file on which to display             *    
*     NW       Number of elements in the array KY (and KT)             *    
*     KY       Vector to be printed                                    *    
*     KT       Type of the vector elements                             *    
*          1 - Binary                                                  *    
*          2   Integer                                                 *    
*          3   Floating                                                *    
*          4   Double Precision (not yet implemented)                  *    
*          5   Hollerith                                               *    
*          6   Hollerith concatenetad to previous hollerith            *    
*          7   Packed integer - time packed upto seconds               *    
*          8   Packed integer - time packed upto minutes               *    
*          9   Data which should not be displayed                      *    
*     ICON     Number of keys concatenated to the present one          *    
*     IKEY     Serial number of the key to be displayed                *    
*                                                                      *    
*   Called by DBDISD, DBDISH, DBPRES                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =103 : Illegal data type                               *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       CHPRT*300, CFORM*5    
      DIMENSION       KY(9), KT(9), ICON(9), iarg(9)
*   
*     ------------------------------------------------------------------    
*   
      CHPRT = ' '   
      IF (IKEY.GT.0) THEN   
         WRITE (CHPRT(2:9), 1001) IKEY  
      ENDIF 
      I1    = 11    
      DO 10 I = 1, NW   
        KK    = KT(I)   
        IF (KK.LT.1.OR.KK.EQ.4.OR.KK.GT.9) GO TO 901    
        GO TO (1,2,10,10,5,10,7,8,10), KK   
    1   CONTINUE    
*   
*  **   Binary  
*   
        I1 = I1 + 1 
        I2 = I1 + NUMCDD(I) - 3 
        CFORM(1:2) = '(Z'   
        CFORM(5:5) = ')'    
        WRITE (CFORM(3:4), 1002) NUMCDD(I)-2    
        WRITE (CHPRT(I1:I2), CFORM) KY(I)   
        I1 = I2 + 2 
        GO TO 10    
    2   CONTINUE    
*   
*  **   Integer 
*   
        I1 = I1 + 1 
        I2 = I1 + NUMCDD(I) - 3 
        CFORM(1:2) = '(I'   
        CFORM(5:5) = ')'    
        WRITE (CFORM(3:4), 1002) NUMCDD(I)-2    
        WRITE (CHPRT(I1:I2), CFORM) KY(I)   
        I1 = I2 + 2 
        GO TO 10    
    5   CONTINUE    
*   
*  **   Hollerith   
*   
        IREP = ICON(I) + 1  
        I1 = I1 + 1 
        DO 6 J = 1, IREP    
          I2 = I1 + 3   
          IF (IREP.EQ.1) THEN   
             I1 = I1 + 2    
             I2 = I2 + 2    
          ENDIF 
          WRITE (CHPRT(I1:I2), 1003) KY(I+J-1)  
          I1 = I2 + 1   
    6   CONTINUE    
        I1 = I1 + 1 
        GO TO 10    
    7   CONTINUE    
*   
*  **   Packed Integer (upto seconds)   
*   
        CALL DBUPTS (IDATE, ITIME, KY(I))   
        I1 = I1 + 1 
        I2 = I1 + 5 
        WRITE (CHPRT(I1:I2), 1004) IDATE    
        I1 = I2 + 2 
        I2 = I1 + 5 
        WRITE (CHPRT(I1:I2), 1004) ITIME    
        I1 = I2 + 2 
        GO TO 10    
    8   CONTINUE    
*   
*  **   Packed Integer (upto minutes)   
*   
        CALL DBUPTM (IDATE, ITIME, KY(I))   
        I1 = I1 + 1 
        I2 = I1 + 5 
        WRITE (CHPRT(I1:I2), 1004) IDATE    
        I1 = I2 + 2 
        I2 = I1 + 5 
        WRITE (CHPRT(I1:I2), 1004) ITIME    
        I1 = I2 + 2 
        GO TO 10    
*   
   10 CONTINUE  
      WRITE (LUN, 2001) CHPRT(1:MXDPDD) 
      IQUEST(1) = 0 
      GO TO 999 
*   
* *** Error codes   
*   
  901 IQUEST(1) = 103   
      iarg(1) = kk
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDKYH : Illegal '// 
     +   'data type to be printed = '',I10,/)', iarg, 1)  
*   
 1001 FORMAT (I8)   
 1002 FORMAT (I2)   
 1003 FORMAT (A4)   
 1004 FORMAT (I6)   
 2001 FORMAT (A)    
*                                                             END DBDKYH    
  999 END   
      SUBROUTINE DBDKYV (LUN, NW, CT, KY, KT, ICON) 
*     ============================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBDKYV (LUN, NW, CT, KY, KT, ICON)                      *    
*                                                                      *    
*   Displays a vector KY of elements NW according to its type KT       *    
*   in Vertical Mode (Concatenated keys are printed in 1 line)         *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUN      Unit number of the file on which to display             *    
*     NW       Number of elements in the array KY (and KT)             *    
*     CT       Character-Name of the Key to be printed                 *    
*     KY       Vector to be printed                                    *    
*     KT       Type of the vector elements                             *    
*          1 - Binary                                                  *    
*          2   Integer                                                 *    
*          3   Floating                                                *    
*          4   Double Precision (not yet implemented)                  *    
*          5   Hollerith                                               *    
*          6   Hollerith concatenetad to previous hollerith            *    
*          7   Packed integer - time packed upto seconds               *    
*          8   Packed integer - time packed upto minutes               *    
*          9   Data which should not be displayed                      *    
*     ICON     Number of keys concatenated to the present one          *    
*                                                                      *    
*   Called by DBDISV, DBPEEK, DBPRES                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =103 : Illegal data type                               *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      CHARACTER       CHPRT*80, CT(*)*8 
      DIMENSION       KY(9), KT(9), ICON(9), iarg(9)
*   
*     ------------------------------------------------------------------    
*   
      CHPRT = ' '   
      I = 1 
   15 CONTINUE  
        CHPRT = ' ' 
        I1 = 20 
        CHPRT(3:10) = CT(I) 
        KK    = KT(I)   
        IF (KK.EQ.6) KK = 5 
        IF (KK.LT.1.OR.KK.EQ.4.OR.KK.GT.9) GO TO 901    
        GO TO (1,2,3,4,5,5,7,8,9), KK   
    1   CONTINUE    
*   
*  **   Binary  
*   
        CHPRT(13:13) = 'B'  
        I1 = I1 + 2 
        I2 = I1 + 9 
        WRITE (CHPRT(I1:I2), 1001) KY(I)    
        I = I + 1   
        GO TO 10    
    2   CONTINUE    
*   
*  **   Integer 
*   
        CHPRT(13:13) = 'I'  
        I1 = I1 + 2 
        I2 = I1 + 9 
        WRITE (CHPRT(I1:I2), 1002) KY(I)    
        I = I + 1   
        GO TO 10    
    3   CONTINUE    
*   
*  **   Floating    
*   
        CHPRT(13:13) = 'F'  
        I1 = I1 + 1 
        I2 = I1 + 11    
        WRITE (CHPRT(I1:I2), 1003) KY(I)    
        I = I + 1   
        GO TO 10    
    4   CONTINUE    
        GO TO 901   
    5   CONTINUE    
*   
*  **   Hollerith   
*   
         CHPRT(13:13) = 'H' 
         I1 = I1 + 5    
         I2 = I1 + 3    
         WRITE (CHPRT(I1:I2), 1005) KY(I)   
         I = I + 1  
*          Is Key  concatenated with the next one ? 
         NCONC = ICON(I-1)  
         IF (NCONC.EQ.0)                   GO TO 10 
         DO 51 J = 1, NCONC 
            I1 = I2 + 1 
            I2 = I1 + 3 
            WRITE (CHPRT(I1:I2), 1005) KY(I)    
            I = I + 1   
   51    CONTINUE   
         GO TO 10   
    7   CONTINUE    
*   
*  **   Packed Integer - Time packed upto seconds   
*   
        CHPRT(13:13) = 'S'  
        CALL DBUPTS (IDATE, ITIME, KY(I))   
        I1 = I1 + 2 
        I2 = I1 + 9 
        WRITE (CHPRT(I1:I2), 1002) IDATE    
        I1 = I2 + 2 
        I2 = I1 + 9 
        WRITE (CHPRT(I1:I2), 1002) ITIME    
        I = I + 1   
        GO TO 10    
    8   CONTINUE    
*   
*  **   Packed Integer - Time packed upto minutes   
*   
        CHPRT(13:13) = 'M'  
        CALL DBUPTM (IDATE, ITIME, KY(I))   
        I1 = I1 + 2 
        I2 = I1 + 9 
        WRITE (CHPRT(I1:I2), 1002) IDATE    
        I1 = I2 + 2 
        I2 = I1 + 9 
        WRITE (CHPRT(I1:I2), 1002) ITIME    
        I = I + 1   
        GO TO 10    
    9   CONTINUE    
*   
*  **   Key_value should not be visible 
*   
        CHPRT = ' ' 
        CHPRT(13:13) = 'U'  
        I = I + 1   
        GO TO 10    
*   
   10 CONTINUE  
      WRITE (LUN, 2001) CHPRT   
      IF (I.LE.NW)                         GO TO 15 
      IQUEST(1) = 0 
      GO TO 999 
*   
* *** Error codes   
*   
  901 IQUEST(1) = 103   
      iarg(1) = kk
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDKYV : Illegal '// 
     +   'data type to be printed = '',I10,/)', iarg, 1)  
*   
 1001 FORMAT (Z10)  
 1002 FORMAT (I10)  
 1003 FORMAT (E12.4)    
 1005 FORMAT (A4)   
 2001 FORMAT (A)    
*                                                             END DBDKYV    
  999 END   
      SUBROUTINE DBDPRG (KDISP, NK, CHOPT)  
*     ====================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBDPRG (*KDISP, NK, CHOPT)                              *    
*                                                                      *    
*   Sets flag to keys to be displayed (requested by the user)          *    
*      in Horizontal Mode                                              *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     KDISP    Key Flag = 0 for No Display, = 1 for Key to be displayed*    
*     NK       Number of Keys                                          *    
*     CHOPT    Character string specifying following options           *    
*        TERM  Range of keys requested from terminal                   *    
*                                                                      *    
*   Called by DBDISH                                                   *    
*                                                                      *    
************************************************************************    
*   
      COMMON /DCONCT/ ISYSDC(100), IUSEDC(100)  
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       CRANG*80, CUSE*2, CHOPT*(*)   
      DIMENSION       KDISP (NK)    
*   
*     ------------------------------------------------------------------    
*   
      CALL VZERO_i (KDISP, NK)    
*   
      IF (CHOPT.EQ.'TERM') THEN 
        CALL KUPROC ('Range of Keys to display: K1-K2,K3-K4,..',    
     +              CRANG, LCRNG)   
      ELSE IF (CHOPT.EQ.'EDIT') THEN    
        WRITE (CUSE, '(I2)') IUSEDC(NK) 
        CRANG = '3-5,8-'//CUSE  
        LCRNG = 8   
      ELSE  
        WRITE (CUSE, '(I2)') IUSEDC(NK) 
        CRANG = '3-5,8-'//CUSE  
        LCRNG = 8   
      ENDIF 
      IF ((CRANG.EQ.' ') .OR. (LCRNG.EQ.0)) GO TO 20    
      NUMB = 0  
      NUMB1 = 0 
      NUMB2 = 0 
      I = 0 
    5 CONTINUE  
      I = I + 1 
      IF ((I.LE.LCRNG) .AND. (CRANG(I:I).EQ.','.OR.CRANG.EQ.' ')    
     +  .OR. (I.GT.LCRNG)) THEN 
        IF (NUMB.NE.0) THEN 
          IF (NUMB1.EQ.0) THEN  
            NUMB1 = NUMB    
          ELSE  
            NUMB2 = NUMB    
          ENDIF 
          IF (NUMB2.LT.NUMB1) NUMB2 = NUMB1 
          NUMB2 = MIN0 (NUMB2, NK)  
          NUMBF = ISYSDC(NUMB1) 
          NUMBL = ISYSDC(NUMB2) 
          NUMBL = NUMBL + ICONDK(NUMBL) 
          DO 10 J = NUMBF, NUMBL    
   10     KDISP(J) = 1  
          NUMB = 0  
          NUMB1 = 0 
          NUMB2 = 0 
        ENDIF   
      ELSE IF (CRANG(I:I).EQ.'-') THEN  
        NUMB1 = NUMB    
        NUMB = 0    
      ELSE  
        READ (CRANG(I:I), '(I1)') IMANT 
        IF (IMANT.GE.0.AND.IMANT.LE.9) THEN 
          NUMB = NUMB*10 + IMANT    
        ENDIF   
      ENDIF 
      IF (I.LE.LCRNG)                       GO TO 5 
      GO TO 999 
   20 CONTINUE  
      DO 30 I = 1, NK   
   30 KDISP(I) = 1  
      GO TO 999 
*                                                             END DBDPRG    
  999 END   
      SUBROUTINE DBEDAS (CFNAM, NCF, PATHN) 
*     ===================================== 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBEDAS (CFNAM, NCF, PATHN)                              *    
*                                                                      *    
*   Routine to insert objects from a pre-edited ascii file             *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     CFNAM    Character string describing the name of the file used   *    
*              for the editing                                         *    
*     NCF      Number of characters in the string CFNAM                *    
*     PATHN    Character string describing the pathname                *    
*                                                                      *    
*   Called by DBAUXI                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =101 : Illegal path name                               *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      CHARACTER       CFNAM*(*), PATHN*(*), STRFL*300   
      CHARACTER       CHOPT*4, YESNO*1  
      DIMENSION       KEYS(MXDMDK), KEYO(MXDMDK)    
*   
*     ------------------------------------------------------------------    
*   
* *** Set the current directory 
*   
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0)        GO TO 991  
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKYTG   
      IF (IQUEST(1).NE.0)        GO TO 999  
      CALL DBCONC (IOTYDK(1), NWKYDK, ICONDK(1), NSKPDK)    
*   
      CALL KUPROC ('Data is to be inserted ? (Y/N) ', YESNO, LYN)   
      IF (YESNO.EQ.'Y') THEN    
        CHOPT  = 'IAD'  
      ELSE  
        CHOPT  = 'IAW'  
      ENDIF 
      CALL DBOPEN (LUKYDX, CFNAM, 'OLD', ISTAT) 
      IF (ISTAT.NE.0)            GO TO 999  
      CALL KUPROC ('Horizontal or Vertical Mode ? (H/V) ', YESNO, LYN)  
      IF (YESNO.EQ.'H') THEN    
        CHOPT(4:4) = 'H'    
        READ (LUKYDX, 1001, ERR=20, END=20) 
        CALL VZERO_i (KEYO, NWKYDK)   
*   
   10   CONTINUE    
        READ (LUKYDX, CFMTDD, ERR=20, END=20) STRFL(1:MXDPDD)   
        IF (STRFL(1:20).EQ.' ') THEN    
          GO TO 20  
        ELSE IF (STRFL(1:1).EQ.'D') THEN    
*   
*  **     The object is to be inserted  
*   
          CALL VZERO_i (KEYS, NWKYDK) 
          CALL DBDCKH (STRFL, KEYS(1), IKEY)    
          KEYS(MSERDB) = IKEY   
          CALL DBUPKY (KEYS, KEYO, PATHN, CHOPT)    
          IF (IQUEST(1).NE.0)    GO TO 20   
        ENDIF   
        GO TO 10    
      ELSE  
        CHOPT(4:4) = 'V'    
        CALL VZERO_i (KEYS, NWKYDK)   
        READ (LUKYDX, 1002, ERR=20, END=20) 
   15   CONTINUE    
        READ (LUKYDX, '(A80)', ERR=20, END=20) STRFL(1:80)  
        IF (STRFL(40:40).NE.'D') GO TO 20   
        READ (STRFL(21:30), 1004, ERR=20) KEYS(MSERDB)  
        CALL DBDCKV (LUKYDX, ICONDK(1), KEYS(1))    
        CALL DBUPKY (KEYS, KEYO, PATHN,  CHOPT) 
        IF (IQUEST(1).NE.0)      GO TO 20   
        GO TO 15    
      ENDIF 
*   
   20 CALL DBCLOS (LUKYDX)  
      GO TO 999 
*   
* *** Error messages    
*   
  991 IQUEST(1) = 101   
      IF (IDEBDB.GT.0) THEN 
        STRFL  = PATHN  
        CALL DBPRNT (LPRTDB, '(/,'' DBEDAS : Illegal Path Name '//  
     +       STRFL(1:80)//''')', IARGDB, 0) 
      ENDIF 
      GO TO 999 
*   
 1001 FORMAT (///)  
 1002 FORMAT (/)    
 1003 FORMAT (A)    
 1004 FORMAT (I10)  
*                                                             END DBEDAS    
 999  END   
      SUBROUTINE DBEDKY (CFNAM, NCF, PATHN, CHOPT)  
*     ============================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBEDKY (CFNAM, NCF, PATHN)                              *    
*                                                                      *    
*   Edits keys and data in an interactive session                      *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     CFNAM    Character string describing the name of the file used   *    
*              for editing                                             *    
*     NCF      Number of characters in the string CFNAM                *    
*     PATHN    Character string describing the pathname                *    
*     CHOPT    Character with any of the follwing characters           *    
*          A   ASCII type data                                         *    
*          S   Standard ZEBRA data bank (default)                      *    
*                                                                      *    
*   Called by DBAUXI                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      CHARACTER       CFNAM*(*), PATHN*(*), CHOP1*1, CHOP2*1, CHOP0*4   
      CHARACTER       CHSLA*100, STRFL*300, CHOPT*(*), CFMT*20  
      DIMENSION       KEYS(MXDMDK), KEYO(MXDMDK), IOPTS(2)  
      EQUIVALENCE     (IOPTS(1), IOPA), (IOPTS(2), IOPS)    
*   
*     ------------------------------------------------------------------    
*   
* *** Open the file for editing 
*   
      CALL DBOPEN (LUKYDX, CFNAM, 'UNKNOWN', ISTAT) 
      CHOP1   = 'U' 
      IF (ISTAT.NE.0)       GO TO 999   
      IF (IOPHDD.NE.0) THEN 
        IMAX   = MXDPDD 
        IMRK   = 1  
        I1     = 2  
        I2     = 9  
        CFMT   = CFMTDD 
      ELSE  
        IMAX   = 80 
        IMRK   = 40 
        I1     = 23 
        I2     = 30 
        CFMT   = '(A80)'    
      ENDIF 
      CALL DBDISP (LUKYDX, PATHN, CHOP1)    
      IERR   = IQUEST(1)    
      CALL DBCLOS (LUKYDX)  
      CALL UOPTC (CHOPT, 'AS', IOPTS(1))
      IF (IERR.NE.0)        GO TO 999   
      CALL KUEDIT (CFNAM, IST)  
*   
* *** Read back the edited file 
*   
      CALL DBOPEN (LUKYDX, CFNAM, 'OLD', ISTAT) 
      IF (ISTAT.NE.0)       GO TO 999   
      CHOP2  = ' '  
      CALL VZERO_i (KEYO, MXDMDK) 
      CHSLA  = ' '  
      IF (IOPHDD.NE.0) THEN 
        READ (LUKYDX, 1001, ERR=20, END=20) 
      ELSE  
        READ (LUKYDX, 1002, ERR=20, END=20) 
        NINCR  = NWKYDK - NSKPDK - 1    
        CHSLA(1:1) = '('    
        CHSLA(NINCR+2:NINCR+2) = ')'    
        DO 5 I = 1, NINCR   
    5   CHSLA(I+1:I+1) = '/'    
      ENDIF 
*   
   10 CONTINUE  
      READ (LUKYDX, CFMT, ERR=20, END=20) STRFL(1:IMAX) 
      IF ((IOPHDD.NE.0) .AND. (STRFL(1:20).EQ.' ')) THEN    
        GO TO 20    
      ELSE IF ((IOPHDD.EQ.0) .AND. (STRFL(IMRK:IMRK).EQ.'D')) THEN  
        READ (LUKYDX, CHSLA(1:NINCR+2), ERR=20, END=20) 
        GO TO 10    
      ELSE IF (STRFL(IMRK:IMRK).EQ.'N') THEN    
*   
*  **   The object is to be inserted    
*   
        CALL VZERO_i (KEYS, NWKYDK)   
        IF (IOPHDD.NE.0) THEN   
          CALL DBDCKH (STRFL, KEYS(1), IKEY)    
          KEYS(MSERDB) = IKEY   
          CHOP0   = 'V' 
        ELSE    
          READ (STRFL(21:30), 1004, ERR=20) KEYS(MSERDB)    
          CALL DBDCKV (LUKYDX, ICONDK(1), KEYS(1))  
          CHOP0   = 'H' 
        ENDIF   
        IF (CHOP1.EQ.'I') THEN  
          CHOP0  = CHOP0(1:1)//'EI' 
        ELSE IF (CHOP2.EQ.'X') THEN 
          CHOP0  = CHOP0(1:1)//CHOP2    
        ELSE    
          CHOP0  = CHOP0(1:1)//'I'  
        ENDIF   
        IF (IOPA.EQ.0) THEN 
          CALL DBUPKY (KEYS, KEYO, PATHN, CHOP0)    
        ELSE    
          CALL DBAIWR (KEYS, KEYO, PATHN, CHOP0)    
        ENDIF   
        IF (IQUEST(1).NE.0) GO TO 20    
        GO TO 10    
      ELSE IF (STRFL(IMRK:IMRK).EQ.'R') THEN    
*   
*  **   An existing object is modified  
*   
        READ (STRFL(I1:I2), 1005, ERR=20) KEYO(MSERDB)  
        IOLD1  = IOKYDA(MSERDB) 
        IOLDK  = IOPKDA 
        ITIME  = 1  
        JBIAS  = 2  
        IOPKDA = 1  
        IOKYDA(MSERDB) = 1  
        CALL DBKXIN (ITIME, IDISDB, LAUXDL(7), LAUXDL(7), JBIAS, NWKEY, 
     +               KEYO, IPREC)   
        IOPKDA = IOLDK  
        IOKYDA(MSERDB) = IOLD1  
        CHOP2  = 'X'    
        IF (IOPHDD.EQ.0) READ (LUKYDX, CHSLA(1:NINCR+2), ERR=20, END=20)    
        GO TO 10    
      ELSE IF (IOPHDD.NE.0) THEN    
        GO TO 10    
      ENDIF 
*   
   20 CALL DBCLOS (LUKYDX)  
*   
 1001 FORMAT (///)  
 1002 FORMAT (/)    
 1003 FORMAT (A)    
 1004 FORMAT (I10)  
 1005 FORMAT (I8)   
*                                                             END DBEDKY    
  999 END   
      SUBROUTINE DBFTIO (IODV, CHIDH)   
*     ===============================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBFTIO (IODV, CHIDH*)                                   *    
*                                                                      *    
*   Routine to fetch the I/O characteristic of a bank from             *    
*   the IODV words into the character string CHIDH                     *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IODV     I/O word of the bank                                    *    
*     CHIDH    I/O characteristics of the bank                         *    
*                                                                      *    
*   Called by user                                                     *    
*                                                                      *    
************************************************************************    
*   
      COMMON /ZBCD/  IQNUM2(11),IQLETT(26),IQNUM(10),   IQPLUS,IQMINS   
     +,              IQSTAR,IQSLAS,IQOPEN,IQCLOS,IQDOLL,IQEQU, IQBLAN   
     +,              IQCOMA,IQDOT, IQNUMB,IQAPO, IQEXCL,IQCOLO,IQQUOT   
     +,              IQUNDE,IQCLSQ,IQAND, IQAT,  IQQUES,IQOPSQ,IQGREA   
     +,              IQLESS,IQREVE,IQCIRC,IQSEMI,IQPERC,  IQLOWL(26)    
     +,              IQCROP,IQVERT,IQCRCL,IQNOT, IQGRAV,  IQILEG    
     +,              NQHOL0,NQHOLL(95)  
      COMMON /ZUNIT/ IQREAD,IQPRNT,IQPR2,IQLOG,IQPNCH,IQTTIN,IQTYPE 
      COMMON /ZUNITZ/IQDLUN,IQFLUN,IQHLUN,  NQUSED  
      COMMON /QUEST/ IQUEST(100)    
      COMMON /MZIOC/ NWFOAV,NWFOTT,NWFODN,NWFORE,IFOCON(3)  
     +,              MFOSAV(2),  JFOEND,JFOREP,JFOCUR,MFO(200)  
C-------------------------  CDE  -----------------------------------    
    
      CHARACTER       CHIDH*(*) 
      DIMENSION       IODV(20), MTR(500), INV(7)    
      DATA  INV       / 2, 9, 6, 4, 8, 24, 19 / 
*   
      CALL MZIOCR (IODV)    
*   
      JT = 1    
   21 IF (JFOCUR.EQ.JFOREP)  THEN   
        MTR(JT)   = IQSLAS  
        MTR(JT+1) = 0   
        JT = JT + 2 
      ENDIF 
*   
      JF = MFO(JFOCUR+1)    
      JC = MFO(JFOCUR+2)    
*   
      IF    (JC)             24, 25, 26 
   24 MTR(JT) = IQMINS  
      JT = JT + 1   
      GO TO 28  
*   
   25 MTR(JT) = IQSTAR  
      JT = JT + 1   
      GO TO 28  
*   
   26 CALL USET (JC,MTR(JT),1,6)    
      JT = JT + 6   
*   
   28 JF = INV(JF)  
      MTR(JT)   = IQLETT(JF)    
      MTR(JT+1) = 0 
      JT = JT + 2   
    
      JFOCUR = JFOCUR + 2   
      IF (JFOCUR.LT.JFOEND)  GO TO 21   
*   
      JT = JT - 2   
      CALL ULEFT (MTR,1,JT) 
      NT = IULAST (IQBLAN,MTR,JT)   
*   
      DO 33 JT=1,NT 
      IF (MTR(JT).NE.0)      GO TO 33   
      MTR(JT) = IQBLAN  
   33 CONTINUE  
      CALL UH1TOC (MTR, CHIDH, NT)  
*                                                             END DBFTIO    
   99 END   
      SUBROUTINE DBJOIN (PATHN, IDATM, NI, NOBI, CHTI, IOTI, ICONI, 
     +                           KEYI, NO, NOBO, CHTO, IOTO, ICONO) 
*     ============================================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR.DBJOIN (PATHN, IDATM, NI, NOBI, CHTI, IOTI, ICONI,       *    
*                            KEYI, NO*, NOBO*, CHTO*, IOTO*, ICONO)    *    
*                                                                      *    
*   Routine to Join a Table of Name PATHN                              *    
*   The values of the Keys to be presented can be found at             *    
*                 IQ(LJOIDX+1,..,NO,NO+1,...,NO*NOBO)                  *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Pathname of the Table                                   *    
*     IDATM    Packed Date and Time (or Run #) at which the table is   *    
*              valid                                                   *    
*     NI       Number of Coloumns to join                              *    
*     NOBI     Number of Rows (Data) to join                           *    
*     CHTI     Name of Keys to which to join                           *    
*     IOTI     Type of Keys to which to join                           *    
*     ICONI    Number of concatenated keys to join                     *    
*     KEYI     Value of Keys to which to join                          *    
*     NO       Number of Keys to be Presented                          *    
*     NOBO     Number of Objects to be presented                       *    
*     CHTO     Name of Keys used for Presentation                      *    
*     IOTO     Type of Keys used for Presentation                      *    
*     ICONO    Number of concatenated keys to present                  *    
*                                                                      *    
*   Called by DBVIEW                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =101 : Illegal path name                               *    
*               =102 : No key or data for the path name                *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DVIEWS/ IFKYDV(100), JFKYDV(100), IOTYDV(100), KEYSDV(100)    
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      DIMENSION       IOTI(NI), IOTO(9), KEYI(NI, NOBI) 
      DIMENSION       ICONI(9), ICONO(9), IFLAG(100)    
      CHARACTER       PATHN*(*), CHTI(NI)*8, CHTO(*)*8, CHTG(100)*8 
      CHARACTER       CHOPT*40, KYNAM*8, KYVAL*20, BLANK*20, PATHY*80   
      CHARACTER       KY10*10, CHPRO*50 
      DATA            BLANK /' '/

      dimension nio(9), iarg(9)
*   
*     ------------------------------------------------------------------    
*   
* *** Set the current directory 
*   
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0)   GO TO 991   
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      IF (NWKYDK.LE.NSYSDK) GO TO 992   
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKYTG   
      IF (IQUEST(1).NE.0)   GO TO 999   
*   
*  ** Fill concatenation flag (if non-zero: number of concatenated keys 
*   
      CALL DBCONC (IOTYDK(1), NWKYDK, ICONDK(1), NSKPDK)    
*   
*  ** Get the Coloumn Names in the Table to Join    
*   
      CALL VZERO_i (IFKYDV, NWKYDK)   
      CALL VZERO_i (IFLAG, NWKYDK)    
      I = 1 
    1 CONTINUE  
      I = I + 1 
      IF (I.GT.NI)          GO TO 7 
    2 CONTINUE  
      I1 = I-1  
      CHPRO = 'Give name for '//CHTI(I) 
      CALL KUPROC (CHPRO(1:23), CHTG(I1), LCHT) 
      IOTYDV(I1) = IOTI(I)  
      DO 3 J = NSYSDK+1, NWKYDK 
        IF (CHTG(I1).EQ.CTAGDK(J)) THEN 
          JST = J   
          IFKYDV(I1) = J    
          IC = 2*I1 
          WRITE (CHOPT(IC-1:IC), 1001) J    
          GO TO 5   
        ENDIF   
    3 CONTINUE  
      GO TO 2   
    5 CONTINUE  
      IF (ICONI(I).EQ.0)    GO TO 1 
      NREP = ICONI(I)   
      DO 6 J = 1, NREP  
        I = I + 1   
        K = JST + J 
        I1 = I - 1  
        IC = IC + 2 
        IFKYDV(I1) = K  
        IFLAG(K) = 1    
        WRITE (CHOPT(IC-1:IC), 1001) K  
        IOTYDV(I1) = IOTYDK(K)  
        CHTG(I1) = CTAGDK(K)    
    6 CONTINUE  
      GO TO 1   
    7 CONTINUE  
*   
*  ** Get additional Key-Names and Key-Values to Search 
*   
      CALL VZERO_i (KEYSDV, NWKYDK)   
      IK = NI-1 
   10 CONTINUE  
      CALL KUPROC ('Key-Name to Search (if no more - |) ?', KYNAM, LKEY)    
      IF (KYNAM.EQ.'|')     GO TO 20    
      I = NSYSDK+1  
   11 IF (I.GT.NWKYDK)      GO TO 13    
      IF (KYNAM.EQ.CTAGDK(I).AND.IFLAG(I).EQ.0) THEN    
        IFLAG(I) = 1    
        IKEY = I    
        IK = IK + 1 
        IC = 2*IK   
        IFKYDV(IK) = I  
        WRITE (CHOPT(IC-1:IC), 1001) I  
        CHTG(IK)   = CTAGDK(I)  
        IOTYDV(IK) = IOTYDK(I)  
        ICONI(IK)  = ICONDK(I)  
        NREP = 0    
        IF (ICONI(IK).GT.0) THEN    
          NREP = ICONI(IK)  
          DO 12 J = 1, NREP 
            I = I + 1   
            IC = IC + 2 
            IFKYDV(IK+J) = I    
            WRITE (CHOPT(IC-1:IC), 1001) I  
            CHTG(IK+J)   = CTAGDK(I)    
            IOTYDV(IK+J) = IOTYDK(I)    
            ICONI(IK+J)  = ICONDK(I)    
            IFLAG(I)     = 1    
   12     CONTINUE  
        ENDIF   
        GO TO 15    
      ENDIF 
      I = I + 1 
      GO TO 11  
   13 CONTINUE  
      GO TO 10  
   15 CONTINUE  
      CALL KUPROC ('Key-Value ?', KYVAL, LKEY)  
      IF (IOTYDK(IKEY).EQ.5) THEN   
*  *        Hollerith   
        LCDAT = (NREP+1)*4  
        CALL UCTOH (KYVAL(1:LCDAT), KEYSDV(IKEY), 4, LCDAT) 
        IK = IK + NREP  
      ELSE IF (IOTYDK(IKEY).EQ.2) THEN  
*  *        Integer 
        LEN  = MIN (10,LKEY)    
        KY10 = BLANK(1:10-LEN)//KYVAL(1:LEN)    
        READ (KY10(1:10), 1002) KEYSDV(IKEY)    
      ELSE IF (IOTYDK(IKEY).EQ.1) THEN  
*  *        Bit-string  
        LEN  = MIN (8,LKEY) 
        KY10 = BLANK(1:8-LEN)//KYVAL(1:LEN) 
        READ (KY10(1:8), 1003) KEYSDV(IKEY) 
      ENDIF 
      GO TO 10  
   20 CONTINUE  
*  *        Variable data-length and Search Options in CHOPT    
      CHOPT(IC+1:IC+2) = 'VS'   
*   
*  ** Loop on Input Objects 
*   
      LKJNDX(1) = 0 
      LKJNDX(2) = 0 
      DO 23 I = 1, NOBI 
*    *      Key-Vector for DBUSE    
        DO 22 J = 2, NI 
          INDX = IFKYDV(J-1)    
*    *  The following equality can be later replaced by other relation: 
          KEYSDV(INDX) = KEYI(J,I)  
   22   CONTINUE    
*   
        IF (I.EQ.1) THEN    
          CALL DBUSE (PATHN, LKJNDX(1), LDJNDX(1), IDATM, KEYSDV(1),    
     +                CHOPT(1:IC+2))    
        ELSE    
          CALL DBUSE (PATHN, LKJNDX(2), LDJNDX(2), IDATM, KEYSDV(1),    
     +                CHOPT(1:IC+2))    
          IF (LKJNDX(1).EQ.0) LKJNDX(1) = LKJNDX(2) 
        ENDIF   
   23 CONTINUE  
*   
*  ** Get the Key-Names to Present  
*   
      CALL VZERO_i (JFKYDV, NWKYDK)   
      CALL VZERO_i (IFLAG, NWKYDK)    
      IP = 1    
      ICONO(I) = 0  
      CHTO(1)  = CTAGDK(MSERDB) 
      IOTO(1)  = IOTYDK(MSERDB) 
      JFKYDV(1) = MSERDB    
   25 CALL KUPROC ('Key-Name to Present (if no more: |) ?', KYNAM, LKEY)    
      IF (KYNAM.EQ.'|')     GO TO 30    
      I = NSYSDK+1  
   26 IF (I.GT.NWKYDK)      GO TO 28    
      IF (KYNAM.EQ.CTAGDK(I).AND.IFLAG(I).EQ.0) THEN    
        IFLAG(I) = 1    
        IP = IP + 1 
        CHTO(IP)   = CTAGDK(I)  
        IOTO(IP)   = IOTYDK(I)  
        ICONO(IP)  = ICONDK(I)  
        JFKYDV(IP) = I  
        IF (ICONO(IP).LE.0) THEN    
          GO TO 25  
        ELSE    
          NREP = ICONO(IP)  
          DO 27 J = 1,NREP  
            IP = IP + 1 
            I = I + 1   
            IFLAG(I) = 1    
            CHTO(IP)  = CTAGDK(I)   
            IOTO(IP)  = IOTYDK(I)   
            ICONO(IP) = ICONDK(I)   
            JFKYDV(IP) = I  
   27     CONTINUE  
        ENDIF   
        GO TO 25    
      ENDIF 
      I = I + 1 
      GO TO 26  
   28 CONTINUE  
      GO TO 25  
   30 CONTINUE  
*   
*  ** Lift Bank for Output  
*   
      NO = IP   
      IF (NO.LE.0)          GO TO 999   
      NOBO =  NZBANK (IDIVDB, LKJNDX(1))    
      IF (NOBO.LE.0)        GO TO 999   
      NDAT = NO *  NOBO
      nio(1) = 2
      CALL DBBOOK (IDIVDB, LJOIDX, LJOIDX, 2, 'JOIN', 0, 0, NDAT, nio,
     &     0) 
      IF (IQUEST(1).NE.0)   GO TO 999   
*   
*  ** Fill-Up 'JOIN' Bank and free LKJNDX   
*   
      IPOIN = LJOIDX    
      NKOBJ = NZBANK (IDIVDB, LKJNDX(1))    
      IF (NKOBJ.GT.0) THEN  
        LFRSDX = LKJNDX(1)  
        DO 40 K = 1, NKOBJ  
          IF (LFRSDX.GT.0) THEN 
            DO 35 J = 1, NO 
              IPOIN = IPOIN + 1 
              IQ(KOFUDB+IPOIN) = IQ(KOFUDB+LFRSDX+JFKYDV(J))    
   35       CONTINUE    
          ENDIF 
          LFRSDX = LQ(KOFUDB+LFRSDX)    
   40   CONTINUE    
      ENDIF 
      CALL MZDROP (IDIVDB, LKJNDX(1), 'L')  
      GO TO 999 
*   
* *** Error messages    
*   
  991 IQUEST(1) = 101   
      IF (IDEBDB.GT.0) THEN 
        PATHY  = PATHN  
        CALL DBPRNT (LPRTDB, '(/,'' DBJOIN : Illegal Path Name '//PATHY 
     +       //''')', IARGDB, 0)    
      ENDIF 
      GO TO 999 
*   
  992 IQUEST(1) = 102   
      IF (IDEBDB.GT.0) THEN 
        PATHY  = PATHN
        iarg(1) = nsysdk
        CALL DBPRNT (LPRTDB, '(/,'' DBJOIN : Less than '',I5,'' key '// 
     +       'for Path Name '//PATHY//''')', iarg, 1) 
      ENDIF 
      GO TO 999 
*   
 1001 FORMAT (I2)   
 1002 FORMAT (I10)  
 1003 FORMAT (Z8)   
*                                                             END DBJOIN    
  999 END   
      SUBROUTINE DBLOOK (LAD, X, Y, PATH)   
*     ===================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBLOOK (LAD, X, Y, PATH*)                               *    
*                                                                      *    
*   Returns the path name picked up by the cursor at x, y              *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LAD      Address of the bank containing information about the    *    
*              tree structure starting from the top level              *    
*     X        X coordinate of the cursor position                     *    
*     Y        Y coordinate of the cursor position                     *    
*     PATH(*)  Complete path name as picked up by the user             *    
*                                                                      *    
*   Called by DBACPL                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      CHARACTER       PATHX*17, PATHY*80, PATHZ*80, PATH*(*)    
*   
*     ------------------------------------------------------------------    
*   
      PATH   = ' '  
      IF (LAD.LE.0) GO TO 999    
      NLEV   = IQ(KOFUDB+LAD+MNLVDB) 
      IF (NLEV.LE.0)   GO TO 999    
*   
* *** Find the level number from the x coordinate   
*   
      IPNL   = IQ(KOFUDB+LAD+MPNLDB) 
      HFRAM  =  Q(KOFUDB+LAD+MHFMDB) 
      KLEV   = 0    
      DO 10 ILEV = 1, NLEV  
        XDIST  = X - Q(KOFUDB+LAD+IPNL+MXOFDB)   
        DELX   = Q(KOFUDB+LAD+IPNL+MXWDDB)   
        IF (XDIST.GE.0.AND.XDIST.LE.DELX) THEN  
          KLEV   = ILEV 
        ENDIF   
        IPNL   = IQ(KOFUDB+LAD+IPNL+MPNLDB)  
   10 CONTINUE  
      IF (KLEV.LE.0)   GO TO 999    
*   
* *** Find the node number from the y coordinate    
*   
      IPNL   = IQ(KOFUDB+LAD+MPNLDB) 
      NODE   = 0    
      IF (KLEV.GT.1) THEN   
        DO 15 ILEV = 2, KLEV    
          IPNL   = IQ(KOFUDB+LAD+IPNL+MPNLDB)    
   15   CONTINUE    
      ENDIF 
      NODES  = IQ(KOFUDB+LAD+IPNL+MNODDB)    
      IPNN   = IQ(KOFUDB+LAD+IPNL+MPNNDB)    
      DO 20 INOD = 1, NODES 
        YDIST  = Y- Q(KOFUDB+LAD+IPNN+MYFNDB)    
        IF (YDIST.GE.0.AND.YDIST.LE.HFRAM) THEN 
          NODE   = INOD 
        ENDIF   
        IPNN   = IQ(KOFUDB+LAD+IPNN+MPNLDB)  
   20 CONTINUE  
      IF (NODE.LE.0)   GO TO 999    
*   
* *** Correct node is identified; now compute the Path  
*   
      IUPN   = NODE 
      NCHRT  = 0    
      PATHY  = ' '  
      DO 40 ILEV = 1, KLEV  
        JLEV   = KLEV + 1 - ILEV    
        IPNL   = IQ(KOFUDB+LAD+MPNLDB)   
        IF (JLEV.GT.1) THEN 
          DO 25 IL = 2, JLEV    
            IPNL   = IQ(KOFUDB+LAD+IPNL+MPNLDB)  
   25     CONTINUE  
        ENDIF   
        IPNN   = IQ(KOFUDB+LAD+IPNL+MPNNDB)  
        IF (IUPN.GT.1) THEN 
          DO 30 INOD = 2, IUPN  
            IPNN   = IQ(KOFUDB+LAD+IPNN+MPNLDB)  
   30     CONTINUE  
        ENDIF   
        NCHR   = IQ(KOFUDB+LAD+IPNN+MNCHDB)  
        IUPN   = IQ(KOFUDB+LAD+IPNN+MNFNDB)  
        CALL UHTOC (IQ(KOFUDB+LAD+IPNN+MNAMDB), 4, PATHZ, NCHR)  
        PATHX  = '/'//PATHZ(1:NCHR) 
        NCHR   =NCHR+1  
        IF (NCHRT.GT.0) THEN    
          PATHZ  = PATHX(1:NCHR)//PATHY(1:NCHRT)    
        ELSE    
          PATHZ  = PATHX    
        ENDIF   
        PATHY  = PATHZ  
        NCHRT  = NCHRT + NCHR   
   40 CONTINUE  
      PATH  = '/'//PATHY    
*                                                             END DBLOOK    
  999 END   
      SUBROUTINE DBOPEN (LUN, CHNAM, STATE, ISTAT)  
*     ============================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBOPEN (LUN, CHNAM, STATE, ISTAT*)                      *    
*                                                                      *    
*   Opens a sequential formatted file through a FOTRAN OPEN statement  *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUN      Logical unit number                                     *    
*     CHNAM    Character string specifying the file name               *    
*     STATE    Status of the file                                      *    
*     ISTAT(*) Error code for opening the file (0 if no error)         *    
*                                                                      *    
*   Called by DBACPL, DBAIWR, DBAUXI, DBEDAS, DBEDKY, DBPEEK, DBPRES,  *    
*             DBRDIO                                                   *    
*                                                                      *    
************************************************************************    
*   
      CHARACTER      CHNAM*(*), STATE*(*)   
*   
*     ------------------------------------------------------------------    
*   
* *** Open the file 
*   
      IF (STATE.EQ.'OLD') THEN  
C&IF LINUX
C&        OPEN (UNIT=LUN, FILE=CHNAM, ACCESS='SEQUENTIAL', STATUS=STATE,  
C&     +        FORM='FORMATTED', IOSTAT=ISTAT, ERR=20) 
C&ELSE
        OPEN (UNIT=LUN, FILE=CHNAM, ACCESS='SEQUENTIAL', STATUS=STATE,  
     +        FORM='FORMATTED', READONLY, IOSTAT=ISTAT, ERR=20) 
C&ENDIF
      ELSE  
        OPEN (UNIT=LUN, FILE=CHNAM, ACCESS='SEQUENTIAL', STATUS=STATE,  
     +        FORM='FORMATTED', IOSTAT=ISTAT, ERR=20)   
      ENDIF 
      ISTAT  = 0    
   20 CONTINUE  
*                                                             END DBOPEN    
  999 END   
      SUBROUTINE DBPEEK (CFNAM, NCF, PATHN) 
*     ===================================== 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPEEK (CFNAM, NCF, PATHN)                              *    
*                                                                      *    
*   Displays keys and data in an interactive session                   *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     CFNAM    Character string describing the name of the file used   *    
*     NCF      Number of characters in the string CFNAM                *    
*     PATHN    Character string describing the pathname                *    
*                                                                      *    
*   Called by DBACPL, DBAUXI                                           *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      CHARACTER       CFNAM*(*), PATHN*(*), CHOP1*1, CHSLA*100, STRFL*40    
      CHARACTER       DFNAM*20  
      DIMENSION       KEYX(MXDMDK)  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*
      dimension ierr(9)
*     ------------------------------------------------------------------    
*   
* *** Display the keys  
*   
      IF (IOPHDD.NE.0) THEN 
        IMRK   = 1  
        I1     = 2  
        I2     = 9  
        CHOP1  = 'K'    
      ELSE  
        IMRK   = 40 
        I1     = 23 
        I2     = 30 
        CHOP1  = 'U'    
      ENDIF 
      CALL DBDISP (LUKYDX, PATHN, CHOP1)    
      IERR(1)   = IQUEST(1)    
      CALL DBCLOS (LUKYDX)  
      IF (IERR(1).NE.0) THEN   
        CHSLA  = PATHN  
        NCH    = LENOCC (CHSLA) 
        CALL DBPRNT (LPRTDB, '(/,'' DBPEEK : Error '',I6,'' from DBDI'//    
     +       'SP for '//CHSLA(1:NCH)//''')', IERR, 1)   
        GO TO 999   
      ENDIF 
*   
* *** Open the file for editing 
* *** If Data are to be displayed - replace 'D' by an asterix   
*   
      CALL KUEDIT (CFNAM, IST)  
      IF (IST.NE.0) THEN    
        CHSLA  = CFNAM  
        NCH    = LENOCC (CHSLA) 
        IF (IST.NE.1) then
          ierr(1) = ist
          CALL DBPRNT (LPRTDB, '(/,'' DBPEEK : Error '',I12,'' in edi'//
     &         'ting file '//CHSLA(1:NCH)//''')', ierr, 1)   
        endif
        GO TO 999   
      ENDIF 
      DFNAM  = 'DFNAME.FILEXT'  
*   
* *** Read back the edited file -- look for the '*' 
*   
      CALL DBOPEN (LUKYDX, CFNAM, 'OLD', ISTAT) 
      IF (ISTAT.NE.0) THEN  
        CHSLA  = CFNAM  
        NCH    = LENOCC (CHSLA)
        ierr(1) = istat
        CALL DBPRNT (LPRTDB, '(/,'' DBPEEK : Error '',I12,'' in open'// 
     +       'ing file '//CHSLA(1:NCH)//''')', ierr, 1)    
        GO TO 999   
      ENDIF 
      CALL UCOPY_i (IOTYDK, IOTYDD, NWKYDK)   
      IOTYDD(MBVRDB) = 7    
      IOTYDD(MEVRDB) = 7    
      IOTYDD(MITMDB) = 8    
      CHSLA  = ' '  
      IF (IOPHDD.NE.0) THEN 
        READ (LUKYDX, 1001, ERR=20, END=20) 
      ELSE  
        READ (LUKYDX, 1002, ERR=20, END=20) 
        NINCR  = NWKYDK - NSKPDK - 1    
        CHSLA(1:1) = '('    
        CHSLA(NINCR+2:NINCR+2) = ')'    
        DO 5 I = 1, NINCR   
    5   CHSLA(I+1:I+1) = '/'    
      ENDIF 
*   
   10 CONTINUE  
      READ (LUKYDX, 1003, ERR=20, END=20) STRFL 
      IF ((IOPHDD.NE.0) .AND. (STRFL(1:20).EQ.' ')) THEN    
        GO TO 20    
      ELSE IF ((IOPHDD.EQ.0) .AND. (STRFL(IMRK:IMRK).EQ.'D')) THEN  
        READ (LUKYDX, CHSLA(1:NINCR+2), ERR=20, END=20) 
        GO TO 10    
      ELSE IF (STRFL(IMRK:IMRK).EQ.'*') THEN    
*   
*  **   Fetch the data according to the key vector  
*   
        READ (STRFL(I1:I2), 1004, ERR=20) KEYX(MSERDB)  
        IOLD   = IOKYDA(MSERDB) 
        IOKYDA(MSERDB) = 1  
        JBIAS  = 2  
        ITIME  = 1  
        CALL DBKXIN (ITIME, IDIVDB, LFRSDX, LFRSDX, JBIAS, NWKEY, KEYX, 
     +               IPREC) 
        IOKYDA(MSERDB) = IOLD   
        IF (IQUEST(1).EQ.0.AND.IQ(KOFUDB+LFRSDX-1).GT.0) THEN   
*   
*   *     Display the data  
*   
          CALL DBOPEN (LUDADX, DFNAM, 'UNKNOWN', IST1)  
          IF (IST1.NE.0) THEN   
            CHSLA  = DFNAM  
            NCH    = LENOCC (CHSLA)
            ierr(1) = ist1
            CALL DBPRNT (LPRTDB, '(/,'' DBPEEK : Error '',I12,'' in '// 
     +           'opening file '//CHSLA(1:NCH)//''')', ierr, 1) 
            GO TO 20    
          ENDIF 
          IF (JBIT(KEYX(MFLGDB), JASFDB).EQ.0) THEN 
            CALL DBDKYV (LUDADX, NWKYDK, CTAGDK, KEYX, IOTYDD, ICONDK)  
            CALL DBWRDP (LUDADX, LFRSDX)    
          ELSE  
            CALL DBAIRD (LUDADX, PATHN, KEYX, 'E')  
          ENDIF 
          CALL DBCLOS (LUDADX)  
          CALL KUEDIT (DFNAM, IST2) 
        ELSE    
          IF (IQUEST(1).NE.0) THEN  
            IARGDB(1) = IQUEST(1)   
            IARGDB(2) = KEYX(MSERDB)    
            CALL DBPRNT (LPRTDB, '(/,'' DBPEEK : Error '',I12,'' in '// 
     +           'reading data for '',I12)', IARGDB, 2) 
          ELSE
            ierr(1) = KEYX(MSERDB)
            CALL DBPRNT (LPRTDB, '(/,'' DBPEEK : Empty data structure'//    
     +           ' for '',I12)', ierr, 1)   
          ENDIF 
        ENDIF   
*   
        IF (LFRSDX.NE.0) CALL MZDROP (IDIVDB, LFRSDX, 'L')  
        IF (IOPHDD.EQ.0) THEN   
          READ (LUKYDX, CHSLA(1:NINCR+2), ERR=20, END=20)   
        ENDIF   
        GO TO 10    
      ELSE IF (IOPHDD.NE.0) THEN    
        GO TO 10    
      ENDIF 
*   
   20 CALL DBCLOS (LUKYDX)  
*   
 1001 FORMAT (///)  
 1002 FORMAT (/)    
 1003 FORMAT (A40)  
 1004 FORMAT (I8)   
*                                                             END DBPEEK    
  999 END   
      SUBROUTINE DBPRES (PATHI, PATHO, IOTI, IOTO, CHTI, CHTO, KEYI,    
     +                       KEYO, ICONI, ICONO, NI, NO, NOB, CFNAM)    
*     ==============================================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPRES (PATHI, PATHO, IOTI, IOTO, CHTI, CHTO, KEYI,     *    
*                      KEYO, ICONI, ICONO, NI, NO, NOB, CFNAM)         *    
*                                                                      *    
*   Routine to Present the "View"                                      *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHI    Pathname of the First Table                             *    
*     PATHO    Pathname of the Last  Table                             *    
*     IOTI     Type of Keys used for Search                            *    
*     IOTO     Type of Keys used for Presentation                      *    
*     CHTI     Name of Keys used for Search                            *    
*     CHTO     Name of Keys used for Presentation                      *    
*     KEYI     Value of Keys used for Search                           *    
*     KEYO     Value of Keys to be presented                           *    
*     ICONI    Number of keys concatenated to this key                 *    
*     ICONO    Number of keys concatenated to this key                 *    
*     NI       Number of Keys used for Search                          *    
*     NO       Number of Keys to be Presented                          *    
*     NOB      Number of Objects to be presented                       *    
*     CFNAM    File Name used for presentation                         *    
*                                                                      *    
*   Called by DBVIEW                                                   *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      DIMENSION       IDPFL(100)    
      DIMENSION       IOTI(NI), IOTO(NO), KEYI(NI), KEYO(NO,NOB)    
      DIMENSION       ICONI(NI), ICONO(NO)  
      CHARACTER       PATHI*(*), PATHO*(*), CFNAM*(*)   
      CHARACTER       CHTI(NI)*8, CHTO(NO)*8, CHEAD*300 
*   
*     ------------------------------------------------------------------    
*   
* *** Open file for Presentation    
*   
      LUN = LUKYDX  
      CALL DBOPEN (LUN, CFNAM, 'UNKNOWN', ISTAT)    
      IF (ISTAT.NE.0) RETURN    
*   
* *** Header Line   
*   
      WRITE (LUN, 1001) PATHO   
      IF (IOPHDD.NE.0) THEN 
*   
*  **   Check if display is wide enough 
*   
        NW = NO - 1 
        IF (NW.GT.0) THEN   
          DO 1 I = 1, NW    
    1     IDPFL(I) = 1  
          CALL DBRGCV (IDPFL, NW, NDISP, IOTO(2))   
          IF (NDISP.GT.MXDPDD) THEN 
            CALL DBPRNT (LPRTDB, '(/,'' DBPRES : Not enough space to '//    
     +           'display.'',/,'' Enlarge display range by DBSETD or '//    
     +           'use V-mode.'')', IARGDB, 0)   
            WRITE (LUN, 1007)   
            GO TO 999   
          ENDIF 
*   
*  **     Display header    
*   
          CHEAD = ' '   
          CHEAD(4:9) = 'Serial' 
          CALL DBVHEA (IOTO(2), CHTO(2), NW, CHEAD) 
          WRITE (LUN, '(A/)') CHEAD(1:MXDPDD)   
*   
*  **     Display the Objects if there is any   
*   
          WRITE (LUN, 1003) 
          IF (NOB.GT.0) THEN    
            DO 5 I = 1, NOB 
              CALL DBDKYH (LUN, NW, KEYO(2,I), IOTO(2), ICONO(2),   
     +                              KEYO(1,I))  
    5       CONTINUE    
          ENDIF 
        ENDIF   
      ELSE  
        WRITE (LUN, '(/)')  
*   
*  **   Display the Objects if there is any 
*   
        IF (NOB.GT.0) THEN  
          DO 10 I = 1, NOB  
            WRITE (LUN, 1005) KEYO(1,I) 
            CALL DBDKYV (LUN, NO-1, CHTO(2), KEYO(2,I), IOTO(2),    
     +                   ICONO(2))  
   10     CONTINUE  
        ENDIF   
      ENDIF 
*   
* *** Closing Phrase    
*   
      WRITE (LUN, 1004) PATHI   
      IF (IOPHDD.NE.0) THEN 
*   
*   *   Check if display is wide enough 
*   
        IF (NI.GT.0) THEN   
          NW = NI   
          DO 11 I = 1, NW   
   11     IDPFL(I) = 1  
          CALL DBRGCV (IDPFL, NW, NDISP, IOTI(1))   
          IF (NDISP.GT.MXDPDD) THEN 
            CALL DBPRNT (LPRTDB, '(/,'' DBPRES : Not enough space to '//    
     +           'display.'',/,'' Enlarge display range by DBSETD or '//    
     +           'use V-mode.'')', IARGDB, 0)   
            WRITE (LUN, 1007)   
            GO TO 999   
          ENDIF 
*   
*  **     Display header    
*   
          CHEAD = ' '   
          CHEAD(4:9) = 'Serial' 
          CALL DBVHEA (IOTI(1), CHTI(1), NW, CHEAD) 
          WRITE (LUN, '(A/)') CHEAD(1:MXDPDD)   
*   
          WRITE (LUN, 1003) 
          CALL DBDKYH (LUN, NW, KEYI(1), IOTI(1), ICONI(1), -1) 
        ENDIF   
      ELSE  
        WRITE (LUN, '(/)')  
        IF (NI.GT.0) THEN   
          CALL DBDKYV (LUN, NI, CHTI, KEYI(1), IOTI(1), ICONI(1))   
        ENDIF   
      ENDIF 
*   
      CALL DBCLOS (LUN) 
      CALL KUEDIT (CFNAM, IST)  
*   
 1001 FORMAT (/2X,' Objects in Directory ',A/)  
 1002 FORMAT (/20(3X,A8,3X)/)   
 1003 FORMAT (/)    
 1004 FORMAT (////2X,' Satisfy the Search in Directory ',A//)   
 1005 FORMAT (/2X,' ---- Object-Serial : ',I10,' ----'/)    
 1007 FORMAT (/,' DBPRES : Not enough space to display.' /  
     +          ' Enlarge display range by DBSETD or use V-mode.')  
*                                                             END DBPRES    
 999  END   
      SUBROUTINE DBPROC (CPRO, CPAR, NCH)   
*     ===================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBPROC (CPRO, CPAR*, NCH*)                              *    
*                                                                      *    
*   Reads a character variable from the screen                         *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     CPRO     Prompt to be printed on the screen                      *    
*     CPAR(*)  Character variable as supplied by user                  *    
*     NCH(*)   Length of the variable CPAR                             *    
*                                                                      *    
*   Called by DBAUXI                                                   *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (LUNI=5, LUNO=6)  
      CHARACTER       CPRO*(*), CPAR*(*), CHVAL*80  
*   
*     ------------------------------------------------------------------    
*   
*  ** Set default and write the prompt  
*   
      CPAR   = ' '  
      NCH    = 0    
      WRITE (LUNO, 1001) CPRO   
*   
*  ** Now read in the line  
*   
      READ (LUNI, 1002, ERR=999, END=999) CHVAL 
      CPAR   = CHVAL    
      NCH    = LENOCC (CPAR)    
      IF (NCH.GT.0) CALL CLTOU (CPAR(:NCH)) 
*   
 1001 FORMAT (' ',A,': ',$) 
 1002 FORMAT (A80)  
*                                                             END DBPROC    
  999 END   
      SUBROUTINE DBRDDA (DATA)  
*     ========================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBRDDA (DATA*)                                          *    
*                                                                      *    
*   Routine to Decode the Data from the Display file                   *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     DATA     Data Items                                              *    
*                                                                      *    
*   Called by DBUPKY                                                   *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      CHARACTER       IOC*1, STRFIL*80, CHVAL*80    
      DIMENSION       DATA (9)  
*
      integer istr
      real fstr
      equivalence (istr, fstr)
*     ------------------------------------------------------------------    
*   
*  ** Decode the Data part of the edited file   
*   
      REWIND (LUDADX)   
      READ (LUDADX, 1001, ERR=10, END=10)   
*   
      I = 1 
    2 CONTINUE  
      READ (LUDADX, 1002, ERR=10, END=10) STRFIL    
      CHVAL = ' '   
      NCH = LENOCC (STRFIL) 
      NCH = MIN0 (NCH, 80)  
      IF (NCH.EQ.0) GO TO 10    
      DO 3 J = 1, NCH   
        IF (STRFIL(J:J).NE.' ') THEN    
          IOC = STRFIL(J:J) 
          JST = J + 6   
          GO TO 4   
        ENDIF   
    3 CONTINUE  
    4 CONTINUE  
      LCDAT = 4 
      LWRDH = 1 
      DO 5 J = JST, NCH 
        IF (STRFIL(J:J).NE.' ') THEN    
          CHVAL = STRFIL(J:NCH) 
          LCDAT = NCH-J+1   
          LWRDH = (LCDAT-1)/4 + 1   
          GO TO 6   
        ENDIF   
    5 CONTINUE  
    6 CONTINUE  
      IF (IOC.EQ.'B') THEN  
        CALL DBCTOB (CHVAL, DATA(I))    
        I = I + 1   
      ELSE IF (IOC.EQ.'I') THEN 
        CALL DBCTOI (CHVAL, ISTR)
        data(i) = fstr
        I = I + 1   
      ELSE IF (IOC.EQ.'F') THEN 
        CALL DBCTOR (CHVAL, DATA(I))    
        I = I + 1   
      ELSE IF (IOC.EQ.'H') THEN
        CALL UCTOH (CHVAL, istr, 4, LCDAT)
        data(i) = fstr
        I = I + LWRDH   
      ELSE  
        DATA(I) = 0.    
        I = I + 1   
      ENDIF 
      GO TO 2   
   10 CONTINUE  
*   
      CALL DBCLOS (LUDADX)  
*   
 1001 FORMAT (////) 
 1002 FORMAT (A80)  
*                                                             END DBRDDA    
      END   
      SUBROUTINE DBRDIO (PATHN, KEYX, NDAT, CHIDH, LENCH, CHOPT)    
*     ==========================================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBRDIO (PATHN, KEYX, NDAT*, CHIDH*, LENCH*, CHOPT)      *    
*                                                                      *    
*   Reads the I/O-Descriptor of the Data-Bank from the display-file    *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Character string describing the pathname                *    
*     KEYX     Key-vector                                              *    
*     NDAT     Number of Data in the Data-bank associated to the key   *    
*     CHIDH    IO Characteristics of the Data-bank                     *    
*     LENCH    Length of CHIDH                                         *    
*     CHOPT    Character string with any of the following characters   *    
*          E   Display only example (template)                         *    
*                                                                      *    
*   Called by DBUPKY                                                   *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      CHARACTER       CFNAM*32, PATHN*(*), STRFIL*40    
      CHARACTER       IOO*1, ION*1, IOC*2, CHIDH*(*), CHOPT*(*) 
      DIMENSION       KEYX(*) 
*   
*     ------------------------------------------------------------------    
*   
      NDAT  = 0 
*   
*  ** Open the file to editing  
*   
      CALL KUPROC ('Give Data File-Name (e.g. DFNAME) ',CFNAM, LFNAM)   
      CFNAM  = CFNAM(1:LFNAM)//'.FILEXT'    
      CALL DBOPEN (LUDADX, CFNAM, 'UNKNOWN', ISTAT) 
      IF (ISTAT.NE.0)     GO TO 999 
*   
*  ** Prepares the Data file for PATHN and KEYX vector  
*   
      CALL DBDISD (LUDADX, PATHN, KEYX, CHOPT)  
      CALL DBCLOS (LUDADX)  
      IF (IQUEST(1).NE.0) GO TO 999 
*   
*  ** Edits the file containing the Data    
*   
      CALL KUEDIT (CFNAM, IST)  
*   
*  ** Decode the Key part of the edited file    
*   
      LENCH = 0 
      CALL DBOPEN (LUDADX, CFNAM, 'OLD', ISTAT) 
      IF (ISTAT.NE.0) RETURN    
      READ (LUDADX, 1001, ERR=20, END=20)   
*   
*  ** Build-up I/O descriptor   
*   
      IT    = -1    
      IOO   = ' '   
   10 CONTINUE  
      READ (LUDADX, 1002, ERR=20, END=20) STRFIL    
      NCH   = LENOCC (STRFIL)   
      NCH   = MIN0 (NCH, 80)    
      ION   = ' '   
      DO 15 J = 1, NCH  
        IF (STRFIL(J:J).NE.' ') THEN    
          ION = STRFIL(J:J) 
          JST = J + 6   
          GO TO 16  
        ENDIF   
   15 CONTINUE  
   16 CONTINUE  
      LWRDH = 1 
      DO 17 J = JST, NCH    
        IF (STRFIL(J:J).NE.' ') THEN    
          LCDAT = NCH-J+1   
          LWRDH = (LCDAT-1)/4 + 1   
          GO TO 18  
        ENDIF   
   17 CONTINUE  
   18 CONTINUE  
      IF (IOO.NE.ION) THEN  
        IF (IT.EQ.-1) THEN  
          IT = 0    
          IS = 1    
          IF (ION.EQ.'H') IS = LWRDH    
        ELSE    
          WRITE (IOC, 1003) IS  
          NDAT = NDAT + IS  
          IF (IT.EQ.0) THEN 
            CHIDH = IOC//IOO    
          ELSE  
            CHIDH = CHIDH(1:IT)//IOC//IOO   
          ENDIF 
          IF (ION.EQ.' ') GO TO 20  
          IS = 1    
          IF (ION.EQ.'H') IS = LWRDH    
          CHIDH(IT+4:IT+4) = ' '    
          IT = IT + 4   
        ENDIF   
        IOO = ION   
      ELSE  
        INCR = 1    
        IF (ION.EQ.'H') INCR = LWRDH    
        IS = IS + INCR  
      ENDIF 
      GO TO 10  
   20 CONTINUE  
      LENCH = IT + 3    
      IF (NDAT.EQ.0) CALL DBCLOS (LUDADX)   
*   
 1001 FORMAT (////) 
 1002 FORMAT (A40)  
 1003 FORMAT (I2)   
*                                                             END DBRDIO    
  999 END   
      SUBROUTINE DBRGCK (KDISP, NK, NTOT, IOKEY)    
*     ==========================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBRGCK (KDISP, NK, *NTOT, *IOKEY*)                      *    
*                                                                      *    
*   Checks if the display Range is enough to display data              *    
*      in Horizontal Mode (except for DBVIEW action)                   *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     KDISP    Key Flag = 0 for No Display, = 1 for Key to be displayed*    
*     NK       Number of Keys                                          *    
*     NTOT     Place occupied by displaying the keys                   *    
*     IOKEY    Type of the Key                                         *    
*          1 - Binary                                                  *    
*          2   Integer                                                 *    
*          3   Floating                                                *    
*          4   Double Precision (not yet implemented)                  *    
*          5   Hollerith                                               *    
*          6   Hollerith concatenetad to previous hollerith            *    
*          7   Packed integer - time packed upto seconds               *    
*          8   Packed integer - time packed upto minutes               *    
*          9   Data which should not be displayed                      *    
*                                                                      *    
*   Called by DBDISH                                                   *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      DIMENSION       KDISP (NK), NUMBS(7), IOKEY(NK)   
      DATA            NUMBS /12, 12, 15, 15, 12, 12, 15/    
      DATA            NUMBI, NUMIN, NUMHO /12, 12, 6/   
*   
*     ------------------------------------------------------------------    
*   
      NTOT = 10 
*   
*  ** System Keys   
*   
      IOKEY(MBVRDB) = 7 
      IOKEY(MEVRDB) = 7 
      IOKEY(MITMDB) = 8 
      DO 5 I = 1, NSYSDK    
        IF (KDISP(I).NE.0) THEN 
          NUMCDD(I) = NUMBS(I)  
          NTOT = NTOT + NUMCDD(I)   
        ELSE    
          IOKEY(I) = 9  
          NUMCDD(I) = 0 
        ENDIF   
    5 CONTINUE  
*   
*  ** User Keys 
*   
      DO 10 I = NSYSDK+1, NK    
        IF (KDISP(I).NE.0) THEN 
          IF (IOKEY(I).EQ.6) THEN   
            IOKEY(I) = 9    
            NUMCDD(I) = 0   
          ELSE IF (IOKEY(I).EQ.1) THEN  
            NUMCDD(I) = NUMBI   
            NTOT = NTOT + NUMBI 
          ELSE IF (IOKEY(I).EQ.2) THEN  
            NUMCDD(I) = NUMIN   
            NTOT = NTOT + NUMIN 
          ELSE IF (IOKEY(I).EQ.5) THEN  
            NUMCDD(I) = NUMHO + 4*ICONDK(I) 
            NUMCDD(I) = MAX0 (10, NUMCDD(I))    
            NTOT = NTOT + NUMCDD(I) 
          ENDIF 
        ELSE    
          IOKEY(I) = 9  
          NUMCDD(I) = 0 
        ENDIF   
   10 CONTINUE  
*                                                             END DBRGCK    
      END   
      SUBROUTINE DBRGCV (KDISP, NK, NTOT, IOKEY)    
*     ==========================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBRGCV (KDISP, NK, *NTOT, *IOKEY*)                      *    
*                                                                      *    
*   Checks if the display Range is enough to display data              *    
*      in Horizontal Mode (for DBVIEW action)                          *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     KDISP    Key Flag = 0 for No Display, = 1 for Key to be displayed*    
*     NK       Number of Keys                                          *    
*     NTOT     Place occupied by displaying the keys                   *    
*     IOKEY    Type of the Key                                         *    
*          1 - Binary                                                  *    
*          2   Integer                                                 *    
*          3   Floating                                                *    
*          4   Double Precision (not yet implemented)                  *    
*          5   Hollerith                                               *    
*          6   Hollerith concatenetad to previous hollerith            *    
*          7   Packed integer - time packed upto seconds               *    
*          8   Packed integer - time packed upto minutes               *    
*          9   Data which should not be displayed                      *    
*                                                                      *    
*   Called by DBPRES                                                   *    
*                                                                      *    
************************************************************************    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      DIMENSION       KDISP (NK), NUMBS(7), IOKEY(NK)   
      DATA            NUMBS /12, 12, 15, 15, 12, 12, 15/    
      DATA            NUMBI, NUMIN, NUMHO /12, 12, 6/   
*   
*     ------------------------------------------------------------------    
*   
      NTOT = 10 
*   
*  ** Input Keys (cannot be system keys)    
*   
      DO 10 I = 1,NK    
        IF (KDISP(I).NE.0) THEN 
          IF (IOKEY(I).EQ.6) THEN   
            IOKEY(I) = 9    
            NUMCDD(I) = 0   
          ELSE IF (IOKEY(I).EQ.1) THEN  
            NUMCDD(I) = NUMBI   
            NTOT = NTOT + NUMBI 
          ELSE IF (IOKEY(I).EQ.2) THEN  
            NUMCDD(I) = NUMIN   
            NTOT = NTOT + NUMIN 
          ELSE IF (IOKEY(I).EQ.5) THEN  
            NUMCDD(I) = NUMHO + 4*ICONDK(I) 
            NUMCDD(I) = MAX0 (10, NUMCDD(I))    
            NTOT = NTOT + NUMCDD(I) 
          ENDIF 
        ELSE    
          IOKEY(I) = 9  
          NUMCDD(I) = 0 
        ENDIF   
   10 CONTINUE  
*                                                             END DBRGCV    
      END   
      SUBROUTINE DBRVNT (NPATH, PATHS, KEYS, NVAR, NKST, NDST, NKEYX,   
     1                              KEYXS, NOBJS, KOBJS, CTAG, NOBJM)   
*     ===============================================================   
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBRVNT (NPATH, PATHS*, KEYS*, NVAR*, NKST*, NDST*,      *    
*                      NKEYX*, KEYXS*, NOBJS*, KOBJS*, CTAG*, NOBJM)   *    
*                                                                      *    
*   Reads variables for DBACPL from command line or external file      *    
*                                                                      *    
*   Argements :                                                        *    
*                                                                      *    
*     NPATH    Number of pathnames for the directories                 *    
*     PATHS    Names of the directory paths                            *    
*     KEYS     Vector of keys for character option                     *    
*     NVAR     Total number of variables                               *    
*     NKST     Number of key  elements selected                        *    
*     NDST     Number of data elements selected                        *    
*     NKEYX    Number of key  elements for each paths                  *    
*     KEYXS    Key  element indices                                    *    
*     NOBJS    Number of data elements for each paths                  *    
*     KOBJS    Data element indices                                    *    
*     CTAG     Tag for each of the elements                            *    
*     NOBJM    Maximum number of variables                             *    
*                                                                      *    
*   Called by DBAUXI                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =167 : Error in reading from the file                  *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      DIMENSION       KEYS(9), NKEYX(9), KEYXS(9), KOBJS(9), NOBJS(9)   
      CHARACTER       CFNAM*80, CHPRO*32, PATHN*80, CTEMP*5 
      CHARACTER*(*)   PATHS(*), CTAG(*) 
*
      dimension iarg(9)
*     ------------------------------------------------------------------    
*   
      CALL KUGETI (LUNI)    
      CALL KUGETC (CFNAM, NCF)  
      NVAR   = 0    
      NKST   = 0    
      NDST   = 0    
*   
      IF (LUNI.GT.0.AND.CFNAM.NE.' ') THEN  
*   
* ***   Read the information from an external file  
*   
        CALL DBOPEN (LUNI, CFNAM, 'OLD', ISTAT) 
        IF (ISTAT.NE.0) THEN
          iarg(1) = istat
          CALL DBPRNT (L3PRDX, '(/,'' DBRVNT : Error '',I12,'' in ope'//    
     +         'ning file '//CFNAM(1:NCF)//''')', iarg, 1) 
          IQUEST(1) = 167   
          GO TO 999 
        ENDIF   
*   
*  **   Read in the path names first    
*   
        DO 5 I = 1, NPATH   
          READ (LUNI, *, ERR=30, END=30) PATHS(I)   
          PATHN = PATHS(I)  
          CALL RZCDIR (PATHN, ' ')  
          IF (IQUEST(1).NE.0) THEN  
            NCH   = LENOCC (PATHN)  
            CALL DBPRNT (L3PRDX, '('' DB-path '//PATHN(1:NCH)//' is '// 
     +           'illegal'')', IARGDB, 0)   
            IQUEST(1) = 167 
            GO TO 30    
          ENDIF 
    5   CONTINUE    
*   
*  **   Now read the key values 
*   
        DO 10 I = 1, 29 
          IF (IOKYDA(I).NE.0) THEN  
            IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB.OR.I.EQ.MITMDB) THEN 
              READ (LUNI, *, ERR=30, END=30) IDATE, ITIME   
              IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB) THEN  
                CALL DBPKTS (IDATE, ITIME, KEYS(I)) 
              ELSE  
                CALL DBPKTM (IDATE, ITIME, KEYS(I)) 
              ENDIF 
            ELSE    
              READ (LUNI, *, ERR=30, END=30) KEYS(I)    
            ENDIF   
          ENDIF 
   10   CONTINUE    
*   
*  **   Now read the items to be stored 
*   
        DO 25 I = 1, NPATH  
          PATHN  = PATHS(I) 
          CALL RZCDIR (PATHN, ' ')  
          NKEYDK = IQUEST(7)    
          NWKYDK = IQUEST(8)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          CALL DBKYTG   
          READ (LUNI, *, ERR=30, END=30) NKEYX(I)   
          IF (NKEYX(I).LT.1) THEN   
            NKEYX(I) = 0    
          ELSE IF (NKEYX(I).GT.NWKYDK) THEN 
            NKEYX(I) = NWKYDK   
          ENDIF 
          IF (NVAR+NKEYX(I).GT.NOBJM) THEN  
            CALL DBPRNT (L3PRDX, '('' Too many variables for N-tuple'')'    
     +,          IARGDB, 0) 
            IQUEST(1) = 167 
            GO TO 30    
          ENDIF 
          DO 15 J = 1, NKEYX(I) 
            READ (LUNI, *, ERR=30, END=30) KEYXS(NKST+J)    
            IF (KEYXS(NKST+J).LT.1.OR.KEYXS(NKST+J).GT.NWKYDK) THEN
              iarg(1) = KEYXS(NKST+J) 
              CALL DBPRNT (L3PRDX, '('' Invalid Key index'',I12)',  
     +             iarg, 1)    
              IQUEST(1) = 167   
              GO TO 30  
            ENDIF   
            CTAG(NVAR+J) = CTAGDK(KEYXS(NKST+J))    
   15     CONTINUE  
          NVAR   = NVAR + NKEYX(I)  
          NKST   = NKST + NKEYX(I)  
          READ (LUNI, *, ERR=30, END=30) NOBJS(I)   
          IF (NOBJS(I).LT.1) NOBJS(I) = 0   
          IF (NVAR+NOBJS(I).GT.NOBJM) THEN  
            CALL DBPRNT (L3PRDX, '('' Too many variables for N-tuple'')'    
     +,          IARGDB, 0) 
            IQUEST(1) = 167 
            GO TO 30    
          ENDIF 
          DO 20 J = 1, NOBJS(I) 
            READ (LUNI, *, ERR=30, END=30) KOBJS(NDST+J), CTAG(NVAR+J)  
            IF (KOBJS(NDST+J).LT.1) KOBJS(NDST+J) = 1   
   20     CONTINUE  
          NVAR   = NVAR + NOBJS(I)  
          NDST   = NDST + NOBJS(I)  
   25   CONTINUE    
        IQUEST(1) = 0   
        GO TO 40    
*   
   30   iarg(1) = istat
        CALL DBPRNT (L3PRDX, '(/,'' DBRVNT : Error in reading file '//  
     +       CFNAM(1:NCF)//''')', iarg, 0) 
        IQUEST(1) = 167 
   40   CALL DBCLOS (LUNI)  
*   
      ELSE  
*   
* ***   Read the information from the command line  
*   
        DO 45 I = 1, NPATH  
          WRITE (CHPRO, 1001) I 
          CALL KUPROC (CHPRO, PATHS(I), NCH)    
          PATHN  = PATHS(I) 
          CALL RZCDIR (PATHN, ' ')  
          IF (IQUEST(1).NE.0) THEN  
            CALL DBPRNT (L3PRDX, '('' DB-path '//PATHN(1:NCH)//' is '// 
     +           'illegal'')', IARGDB, 0)   
            IQUEST(1) = 167 
            GO TO 999   
          ENDIF 
   45   CONTINUE    
*   
*  **   Now read the key values 
*   
        DO 50 I = 1, 29 
          IF (IOKYDA(I).NE.0) THEN  
            IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB) THEN    
              IF (I.EQ.MBVRDB) THEN 
                CTEMP  = 'Begin'    
              ELSE  
                CTEMP  = 'End'  
              ENDIF 
              WRITE (CHPRO, 1002) 'YYMMDD', CTEMP   
              CALL KUPROI (CHPRO, IDATE)    
              WRITE (CHPRO, 1002) 'HHMMSS', CTEMP   
              CALL KUPROI (CHPRO, ITIME)    
              CALL DBPKTS (IDATE, ITIME, KEYS(I))   
            ELSE IF (I.EQ.MITMDB) THEN  
              WRITE (CHPRO, 1003) 'YYMMDD'  
              CALL KUPROI (CHPRO, IDATE)    
              WRITE (CHPRO, 1003) 'HHMM'    
              CALL KUPROI (CHPRO, ITIME)    
              CALL DBPKTM (IDATE, ITIME, KEYS(I))   
            ELSE    
              WRITE (CHPRO, 1004) I 
              CALL KUPROI (CHPRO, KEYS(I))  
            ENDIF   
          ENDIF 
   50   CONTINUE    
*   
*  **   Now read the items to be stored 
*   
        DO 70 I = 1, NPATH  
          PATHN  = PATHS(I) 
          CALL RZCDIR (PATHN, ' ')  
          NKEYDK = IQUEST(7)    
          NWKYDK = IQUEST(8)    
          LCDRDB = IQUEST(11)   
          IKDRDB = IQUEST(13)   
          CALL DBKYTG   
          WRITE (CHPRO, 1005) I 
          CALL KUPROI (CHPRO, NKEYX(I)) 
          IF (NKEYX(I).LT.1) THEN   
            NKEYX(I) = 0    
          ELSE IF (NKEYX(I).GT.NWKYDK) THEN 
            NKEYX(I) = NWKYDK   
          ENDIF 
          IF (NVAR+NKEYX(I).GT.NOBJM) THEN  
            CALL DBPRNT (L3PRDX, '('' Too many variables for N-tuple'')'    
     +,          IARGDB, 0) 
            IQUEST(1) = 167 
            GO TO 999   
          ENDIF 
          DO 60 J = 1, NKEYX(I) 
            WRITE (CHPRO, 1006) J, I    
   55       CALL KUPROI (CHPRO, KEYXS(NKST+J))  
            IF (KEYXS(NKST+J).LT.1.OR.KEYXS(NKST+J).GT.NWKYDK) GO TO 55 
            CTAG(NVAR+J) = CTAGDK(KEYXS(NKST+J))    
   60     CONTINUE  
          NVAR   = NVAR + NKEYX(I)  
          NKST   = NKST + NKEYX(I)  
          WRITE (CHPRO, 1007) I 
          CALL KUPROI (CHPRO, NOBJS(I)) 
          IF (NOBJS(I).LT.1) NOBJS(I) = 0   
          IF (NVAR+NOBJS(I).GT.NOBJM) THEN  
            CALL DBPRNT (L3PRDX, '('' Too many variables for N-tuple'')'    
     +,          IARGDB, 0) 
            IQUEST(1) = 167 
            GO TO 999   
          ENDIF 
          DO 65 J = 1, NOBJS(I) 
            WRITE (CHPRO, 1008) J, I    
            CALL KUPROI (CHPRO, KOBJS(NDST+J))  
            IF (KOBJS(NDST+J).LT.1) KOBJS(NDST+J) = 1   
            WRITE (CHPRO, 1009) KOBJS(NDST+J)   
            CALL DBPROC (CHPRO, CTAG(NVAR+J), NCH)  
   65     CONTINUE  
          NVAR   = NVAR + NOBJS(I)  
          NDST   = NDST + NOBJS(I)  
   70   CONTINUE    
        IQUEST(1) = 0   
*   
      ENDIF 
*   
 1001 FORMAT (I2,'th Path name')    
 1002 FORMAT (A,' of ',A,' Range')  
 1003 FORMAT (A,' of cut in insertion time')    
 1004 FORMAT ('Key(',I2,') ?')  
 1005 FORMAT ('No. of keys to store for path ',I2)  
 1006 FORMAT (I2,'th Key element for path ',I2) 
 1007 FORMAT ('No. of data to store for path ',I2)  
 1008 FORMAT (I2,'th data element for path ',I2)    
 1009 FORMAT ('Tag for',I3,'th data element')   
*                                                             END DBRVNT    
  999 END   
      SUBROUTINE DBRVPL (INDX, NOBJ, KOBJ1, KOBJ2, KEYS)    
*     ==================================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBRVPL (INDX, NOBJ, KOBJ1*, KOBJ2*, KEYS*)              *    
*                                                                      *    
*   Reads variables for DBACPL from command line or external file      *    
*                                                                      *    
*   Argements :                                                        *    
*                                                                      *    
*     INDX     Type of input (1 for DBPLOB; 2 for DBPLOV; 0 otherwise) *    
*     NOBJ     Number of objects                                       *    
*     KOBJ1    Array for object indices for DBPLOB                     *    
*     KOBJ2    Array for pair of object indices for DBPLOV             *    
*     KEYS     Key indices                                             *    
*                                                                      *    
*   Called by DBACPL                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =167 : Error in reading from the file                  *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      DIMENSION       KEYS(9), KOBJ2(2,9), KOBJ1(9) 
      CHARACTER       CFNAM*80, CHPRO*32, CTEMP*5   
*
      dimension iarg(9)
*     ------------------------------------------------------------------    
*   
      CALL KUGETI (LUNI)    
      CALL KUGETC (CFNAM, NCF)  
*   
      IF (LUNI.GT.0.AND.CFNAM.NE.' ') THEN  
*   
* ***   Read the information from an external file  
*   
        CALL DBOPEN (LUNI, CFNAM, 'OLD', ISTAT) 
        IF (ISTAT.NE.0) THEN
          iarg(1) = istat
          CALL DBPRNT (L3PRDX, '(/,'' DBRVPL : Error '',I12,'' in ope'//    
     +         'ning file '//CFNAM(1:NCF)//''')', iarg, 1) 
          IQUEST(1) = 167   
          GO TO 999 
        ENDIF   
*   
*  **   Read the object indices first   
*   
        IF (INDX.EQ.1) THEN 
          DO 10 I = 1, NOBJ 
            READ (LUNI, *, ERR=25, END=25) KOBJ1(I) 
   10     CONTINUE  
        ELSE IF (INDX.EQ.2) THEN    
          DO 15 I = 1, NOBJ 
            READ (LUNI, *, ERR=25, END=25) KOBJ2(1,I), KOBJ2(2,I)   
   15     CONTINUE  
        ENDIF   
*   
*  **   Now read the key values 
*   
        DO 20 I = 1, 29 
          IF (IOKYDA(I).NE.0) THEN  
            IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB.OR.I.EQ.MITMDB) THEN 
              READ (LUNI, *, ERR=25, END=25) IDATE, ITIME   
              IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB) THEN  
                CALL DBPKTS (IDATE, ITIME, KEYS(I)) 
              ELSE  
                CALL DBPKTM (IDATE, ITIME, KEYS(I)) 
              ENDIF 
            ELSE    
              READ (LUNI, *, ERR=25, END=25) KEYS(I)    
            ENDIF   
          ENDIF 
   20   CONTINUE    
        IQUEST(1) = 0   
        GO TO 30    
*   
 25     iarg(1) = istat
        CALL DBPRNT (L3PRDX, '(/,'' DBRVPL : Error in reading file '//  
     +       CFNAM(1:NCF)//''')', iarg, 0) 
        IQUEST(1) = 167 
   30   CALL DBCLOS (LUNI)  
*   
      ELSE  
*   
* ***   Read the information from the command line  
*   
        IF (INDX.EQ.1) THEN 
          DO 35 I = 1, NOBJ 
            WRITE (CHPRO, 1001) I   
            CALL KUPROI (CHPRO, KOBJ1(I))   
   35     CONTINUE  
        ELSE IF (INDX.EQ.2) THEN    
          DO 40 I = 1, NOBJ 
            WRITE (CHPRO, 1002) 'First ',I  
            CALL KUPROI (CHPRO, KOBJ2(1,I)) 
            WRITE (CHPRO, 1002) 'Second',I  
            CALL KUPROI (CHPRO, KOBJ2(2,I)) 
   40     CONTINUE  
        ENDIF   
*   
*  **   Now read the key values 
*   
        DO 45 I = 1, 29 
          IF (IOKYDA(I).NE.0) THEN  
            IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB) THEN    
              IF (I.EQ.MBVRDB) THEN 
                CTEMP  = 'Begin'    
              ELSE  
                CTEMP  = 'End'  
              ENDIF 
              WRITE (CHPRO, 1003) 'YYMMDD', CTEMP   
              CALL KUPROI (CHPRO, IDATE)    
              WRITE (CHPRO, 1003) 'HHMMSS', CTEMP   
              CALL KUPROI (CHPRO, ITIME)    
              CALL DBPKTS (IDATE, ITIME, KEYS(I))   
            ELSE IF (I.EQ.MITMDB) THEN  
              WRITE (CHPRO, 1004) 'YYMMDD'  
              CALL KUPROI (CHPRO, IDATE)    
              WRITE (CHPRO, 1004) 'HHMM'    
              CALL KUPROI (CHPRO, ITIME)    
              CALL DBPKTM (IDATE, ITIME, KEYS(I))   
            ELSE    
              WRITE (CHPRO, 1005) I 
              CALL KUPROI (CHPRO, KEYS(I))  
            ENDIF   
          ENDIF 
   45   CONTINUE    
        IQUEST(1) = 0   
      ENDIF 
*   
 1001 FORMAT ('Index for Object',I2,' ?')   
 1002 FORMAT (A,' index for Object',I2,' ?')    
 1003 FORMAT (A,' of ',A,' Range')  
 1004 FORMAT (A,' of cut in insertion time')    
 1005 FORMAT ('Key(',I2,') ?')  
*                                                             END DBRVPL    
  999 END   
      SUBROUTINE DBTEMP (IOKEY, NK, CHEAD)  
*     ====================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBTEMP (IOKEY, NK, *CHEAD)                              *    
*                                                                      *    
*   Writes a Template of the Display in Horizontal Mode into           *    
*   the Character Variable CHEAD                                       *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IOKEY    Type of the Key                                         *    
*          1 - Binary                                                  *    
*          2   Integer                                                 *    
*          3   Floating                                                *    
*          4   Double Precision (not yet implemented)                  *    
*          5   Hollerith                                               *    
*          6   Hollerith concatenetad to previous hollerith            *    
*          7   Packed integer - time packed upto seconds               *    
*          8   Packed integer - time packed upto minutes               *    
*          9   Data which should not be displayed                      *    
*     NK       Number of Keys                                          *    
*     CHEAD    Character variable containing the header                *    
*                                                                      *    
*   Called by DBDISH                                                   *    
*                                                                      *    
************************************************************************    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      DIMENSION       IOKEY(9)  
      CHARACTER       CHEAD*(*) 
*   
*     ------------------------------------------------------------------    
*   
      IPOS = 11 
      DO 5 I = 1,NK 
        IF (IOKEY(I).NE.9) THEN 
          IW1 = IPOS    
          IW2 = IPOS + NUMCDD(I) - 1    
          CHEAD(IW1:IW1) = '|'  
          CHEAD(IW2:IW2) = '|'  
          IPOS = IPOS + NUMCDD(I)   
        ENDIF   
    5 CONTINUE  
*                                                             END DBTEMP    
      END   
      SUBROUTINE DBUPKY (KEYX, KEYO, PATHN, CHOPT)  
*     ============================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBUPKY (KEYX, KEYO, PATHN, CHOPT)                       *    
*                                                                      *    
*   Insert/Update Keys in CWD                                          *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     KEYX     Key-Vector containing the new Key values                *    
*     KEYO     Key-Vector containing the new Key values                *    
*     PATHN    Pathname of the directory                               *    
*     CHOPT    Character options                                       *    
*         A    Insert objects from Ascii file                          *    
*         E    Object is new - Data-template shown                     *    
*         I    Insert new Key                                          *    
*         W    Insert objects from Ascii file without data             *    
*         X    Replace (update) old key                                *    
*                                                                      *    
*   Called by DBEDAS, DBEDKY                                           *    
*                                                                      *    
************************************************************************    
*   
      PARAMETER       (MXKYDA=100)  
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA    
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA    
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA    
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA    
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      DIMENSION       IOPTS(5), KEYX(9), KEYO(9), IOWDS(16) 
      CHARACTER       YESNO*1, CHIDH*120    
      CHARACTER       PATHN*(*), CHOPT*(*), CHOP*1  
      EQUIVALENCE     (IOPTA, IOPTS(1)), (IOPTE, IOPTS(2)), 
     +                (IOPTI, IOPTS(3)), (IOPTW, IOPTS(4)), 
     +                (IOPTX, IOPTS(5)) 
*
      dimension nio(9)
*     ------------------------------------------------------------------    
*   
* *** Decode the character option   
*   
      CALL UOPTC (CHOPT, 'AEIWX', IOPTS)    
      IF (IOPTA.NE.0.AND.IOPTW.NE.0) THEN   
        NDAT = 0
        nio(1) = 2
        CALL DBBOOK (IDIVDB, LASTDX, LASTDX, 2, 'USER', 0, 0, NDAT, 
     +               nio, 0)  
        IF (IQUEST(1).NE.0)   GO TO 999 
        GO TO 10    
      ENDIF 
*   
*  ** Insert Data ? 
*   
      CALL KUPROC ('Data Insert/Update ? (Y/N)', YESNO, LYN)    
      IF (YESNO.EQ.'Y') THEN    
        IF (IOPTE.NE.0) THEN    
          CHOP = 'E'    
        ELSE    
          IF (IOPHDD.EQ.0) THEN 
            CHOP = 'V'  
          ELSE  
            CHOP = 'H'  
          ENDIF 
        ENDIF   
        CALL DBRDIO (PATHN, KEYX, NDAT, CHIDH, LCHID, CHOP) 
        IF (IQUEST(1).NE.0)   GO TO 999 
        IF (NDAT.GT.0) THEN 
          CALL MZIOCH (IOWDS, 16, CHIDH(1:LCHID))   
          CALL DBBOOK (IDIVDB, LASTDX, LASTDX, 2, 'USER', 0, 0, NDAT,   
     +                 IOWDS, 0)    
          IF (IQUEST(1).NE.0) GO TO 999 
          CALL DBRDDA (Q(KOFUDB+LASTDX+1))  
        ELSE    
          NDAT = 0
          nio(1) = 2
          CALL DBBOOK (IDIVDB, LASTDX, LASTDX, 2, 'USER', 0, 0, NDAT,   
     +                 nio, 0)    
          IF (IQUEST(1).NE.0) GO TO 999 
        ENDIF   
      ELSE  
        NDAT = 0
        nio(1) = 2
        CALL DBBOOK (IDIVDB, LASTDX, LASTDX, 2, 'USER', 0, 0, NDAT, 
     +               nio, 0)  
        IF (IQUEST(1).NE.0)   GO TO 999 
      ENDIF 
*   
   10 CONTINUE  
      IF (IOPTX.NE.0) CALL DBREPL (PATHN, LKVWDX(1), LDVWDX(1), 
     +                IDIVDB, LASTDX, NWKYDK, KEYO, KEYX, 0, ' ')   
      IF (IOPTI.NE.0) CALL DBENTR (PATHN, LKVWDX(1), LDVWDX(1), 
     +                IDIVDB, LASTDX, NWKYDK, KEYX, 0, ' ') 
      CALL MZDROP (IDIVDB, LASTDX, ' ') 
      IQUEST(1) = 0 
*                                                             END DBUPKY    
  999 END   
      SUBROUTINE DBVHEA (IOKEY, CHTG, NK, CHEAD)    
*     ==========================================    
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBVHEA (IOKEY, CHTG, NK, *CHEAD)                        *    
*                                                                      *    
*   Writes the Header of the Display in Horizontal Mode into the       *    
*   Character Variable CHEAD                                           *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     IOKEY    Type of the Key                                         *    
*          1 - Binary                                                  *    
*          2   Integer                                                 *    
*          3   Floating                                                *    
*          4   Double Precision (not yet implemented)                  *    
*          5   Hollerith                                               *    
*          6   Hollerith concatenetad to previous hollerith            *    
*          7   Packed integer - time packed upto seconds               *    
*          8   Packed integer - time packed upto minutes               *    
*          9   Data which should not be displayed                      *    
*     CHTG     Vector containing the names of the keys                 *    
*     NK       Number of Keys                                          *    
*     CHEAD    Character variable containing the header                *    
*                                                                      *    
*   Called by DBPRES                                                   *    
*                                                                      *    
************************************************************************    
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      DIMENSION       IOKEY(NK) 
      CHARACTER       CHEAD*(*), CHTG(*)*8  
*   
*     ------------------------------------------------------------------    
*   
      IPOS = 11 
      DO 5 I = 1,NK 
        IF (IOKEY(I).NE.9) THEN 
          NSP = MAX0 ((NUMCDD(I)-8)/2,1)    
          IW = IPOS + NSP   
          CHEAD(IW:IW+7) = CHTG(I)  
          IPOS = IPOS + NUMCDD(I)   
        ENDIF   
    5 CONTINUE  
*                                                             END DBVHEA    
      END   
      SUBROUTINE DBVIEW (CFNAM, PATHI)  
*     ================================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBVIEW (CFNAM, PATHI)                                   *    
*                                                                      *    
*   Routine to Create and Present "View" a la ORACLE                   *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     CFNAM    File-Name for Presentation                              *    
*     PATHI    Pathname of the Table                                   *    
*                                                                      *    
*   Called by DBAUXI                                                   *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)  
      COMMON /DDCFMT/ CFMTDD    
      CHARACTER       CFMTDD*20 
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      DIMENSION       KEYI(100), IOTI(100), IOTO(100), IOTJ(100)    
      DIMENSION       ICONI(100), ICONO(100), ICONJ(100)    
      CHARACTER*80    PATHJ, PATHO  
      CHARACTER       CHTI(100)*8, CHTO(100)*8, CHTJ(100)*8, CHMOD*1    
      CHARACTER       PATHI*(*), CFNAM*(*)  
*   
*     ------------------------------------------------------------------    
*   
* *** Define the Mode to Present (Horizontal or Vertical)   
*   
      CALL KUPROC ('Which Mode ? (H/V) ', CHMOD, LCMOD) 
      IF (CHMOD.NE.'H') THEN    
        CHMOD = 'V' 
        IOPHDD = 0  
      ELSE  
        IOPHDD = 1  
      ENDIF 
*   
* *** Get the date and time (or Run# or last version)   
*   
      IDATE = 0 
      CALL KUPROI ('Date in YYMMDD - if 0, next item is Run #', IDATE)  
      IF (IDATE.NE.0) THEN  
        ITIME = 0   
        CALL KUPROI ('Time in HHMMSS ', ITIME)  
        CALL DBPKTS (IDATE, ITIME, IDATM)   
      ELSE  
        NRUN = 0    
        CALL KUPROI ('Run Number - if 0, Date = 991231 is set', NRUN)   
        IF (NRUN.EQ.0) THEN 
          IDATM = 773874975 
        ELSE    
          IDATM = NRUN  
        ENDIF   
      ENDIF 
*   
* *** Create the first view 
*   
      CALL DBVWPR (PATHI, IDATM, NI, CHTI(1), IOTI(1), ICONI(1),    
     +             KEYI(1), NO, CHTO(1), IOTO(1), ICONO(1), NOBO)   
      IF (IQUEST(1).NE.0) GO TO 999 
*   
* *** Present the View or Join New Tables before Presenting 
*   
      PATHO = PATHI 
   10 CONTINUE  
      CALL KUPROC ('Present view (|) or join Table (Pathname :) ',  
     +             PATHJ, LPJ)  
      IF (PATHJ.EQ.'|') THEN    
        IF (NO*NOBO.GT.0) THEN  
          CALL DBPRES (PATHI, PATHO, IOTI(1), IOTO(1), CHTI(1), 
     +                 CHTO(1), KEYI(1), IQ(KOFUDB+LVIWDX+1), ICONI(1), 
     +                 ICONO(1), NI, NO, NOBO, CFNAM)   
          CALL MZDROP (IDIVDB, LVIWDX, ' ') 
        ENDIF   
      ELSE  
        IF (NO*NOBO.GT.0) THEN  
          CALL DBJOIN (PATHJ, IDATM, NO, NOBO, CHTO(1), IOTO(1),    
     +                 ICONO(1), IQ(KOFUDB+LVIWDX+1), NJ, NOBJ, CHTJ(1),    
     +                 IOTJ(1), ICONJ(1))   
          IER    = IQUEST(1)    
          CALL MZDROP (IDIVDB, LVIWDX, ' ') 
          IF (IER.NE.0)   GO TO 999 
          LVIWDX = LJOIDX   
          NO = NJ   
          NOBO = NOBJ   
          DO 15  I = 1, NJ  
            IOTO(I)  = IOTJ(I)  
            CHTO(I)  = CHTJ(I)  
            ICONO(I) = ICONJ(I) 
   15     CONTINUE  
          PATHO = PATHJ 
          GO TO 10  
        ENDIF   
      ENDIF 
*                                                             END DBVIEW    
  999 END   
      SUBROUTINE DBVWPR (PATHN, IDATM, NI, CHTI, IOTI, ICONI, KEYI, 
     +                                 NO, CHTO, IOTO, ICONO, NOBO) 
*     ============================================================= 
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBVWPR (PATHN, IDATM, NI*, CHTI*, IOTI*, ICONI, KEYI,   *    
*                                    NO*, CHTO*, IOTO*,ICONO*, NOBO*)  *    
*                                                                      *    
*   Routine to Prepare a View from a Table for Presentation or to      *    
*              Join to a another Table                                 *    
*   The values of the Keys to be presented/joined can be found at      *    
*                 IQ(LVIWDX+1,..,NO,NO+1,...,NO*NOBO)                  *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     PATHN    Pathname of the Table                                   *    
*     IDATM    Packed Date and Time (or Run #) at which the Table is   *    
*              valid                                                   *    
*     NI       Number of Keys to search                                *    
*     CHTI     Name of Keys to search                                  *    
*     IOTI     Type of Keys to search                                  *    
*     ICONI    Number of concatenated keys in search                   *    
*     KEYI     Value of the Keys to search                             *    
*     NOBO     Number of Objects to be presented                       *    
*     NO       Number of Keys to be Presented                          *    
*     CHTO     Name of Keys to be presented                            *    
*     IOTO     Type of Keys to be presented                            *    
*     ICONO    Number of concatenated to be presented                  *    
*     NOBO     Number of Objects to be presented                       *    
*                                                                      *    
*   Called by DBVIEW                                                   *    
*                                                                      *    
*   Error Condition :                                                  *    
*                                                                      *    
*     IQUEST(1) =  0 : No error                                        *    
*               =101 : Illegal path name                               *    
*               =102 : No key or data for the path name                *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10) 
*   
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7) 
      PARAMETER       (MXKPDK=1000) 
*   
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)    
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)    
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK    
      DIMENSION       RKY1DK(MXKYDK)    
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))    
*   
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK    
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8  
*   
      COMMON /DVIEWS/ IFKYDV(100), JFKYDV(100), IOTYDV(100), KEYSDV(100)    
*   
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89) 
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,   
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,   
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),   
     +                LASTDX    
*   
      DIMENSION       IOTI(9), IOTO(9), KEYI(9), ICONI(9), ICONO(9) 
      DIMENSION       IFLAG(100)    
      CHARACTER       PATHN*(*), CHTI(*)*8, CHTO(*)*8   
      CHARACTER       CHOPT*40, KYNAM*8, KYVAL*100, BLANK*20, KY10*10   
      DATA            BLANK /' '/

      dimension nio(9), iarg(9)
*   
*     ------------------------------------------------------------------    
*   
*   ** Set the current directory    
*   
      CALL RZCDIR (PATHN, ' ')  
      IF (IQUEST(1).NE.0)   GO TO 991   
      NKEYDK = IQUEST(7)    
      NWKYDK = IQUEST(8)    
      IF (NWKYDK.LE.NSYSDK) GO TO 992   
      LCDRDB = IQUEST(11)   
      IKDRDB = IQUEST(13)   
      CALL DBKYTG   
      IF (IQUEST(1).NE.0)   GO TO 999   
*   
*  ** Fill concatenation flag (if non-zero: number of concatenated keys 
*   
      CALL DBCONC (IOTYDK(1), NWKYDK, ICONDK(1), NSKPDK)    
*   
*  ** Get Key-Names and Key-Values to Search    
*   
      CALL VZERO_i (KEYSDV, NWKYDK)   
      CALL VZERO_i (IFLAG, NWKYDK)    
      IK = 0    
   10 CONTINUE  
      CALL KUPROC ('Key-Name to Search (if no more - |) ?', KYNAM, LKEY)    
      IF (KYNAM.EQ.'|')     GO TO 20    
      I = NSYSDK+1  
   11 IF (I.GT.NWKYDK)      GO TO 13    
        IF (KYNAM.EQ.CTAGDK(I).AND.IFLAG(I).EQ.0) THEN  
          IFLAG(I) = 1  
          IKEY = I  
          IK = IK + 1   
          IC = 2*IK 
          IFKYDV(IK) = I    
          WRITE (CHOPT(IC-1:IC), 1001) I    
          CHTI(IK)  = CTAGDK(I) 
          IOTI(IK)  = IOTYDK(I) 
          ICONI(IK) = ICONDK(I) 
          NREP = 0  
          IF (ICONI(IK).GT.0) THEN  
            NREP = ICONI(IK)    
            DO 12 J = 1, NREP   
              I = I + 1 
              IC = IC + 2   
              IFKYDV(IK+J) = I  
              WRITE (CHOPT(IC-1:IC), 1001) I    
              CHTI(IK+J)  = CTAGDK(I)   
              IOTI(IK+J)  = IOTYDK(I)   
              ICONI(IK+J) = ICONDK(I)   
              IFLAG(I)    = 1   
   12       CONTINUE    
          ENDIF 
          GO TO 15  
        ENDIF   
        I = I + 1   
        GO TO 11    
   13 CONTINUE  
      GO TO 10  
   15 CONTINUE  
*    *      Key-Vector for DBUSE    
      CALL KUPROC ('Key-Value ?', KYVAL, LKEY)  
      IF (IOTYDK(IKEY).EQ.5) THEN   
*  *        Hollerith   
        LCDAT = (NREP+1)*4  
        CALL UCTOH (KYVAL(1:LCDAT), KEYSDV(IKEY), 4, LCDAT) 
        KEYI(IK) = KEYSDV(IKEY) 
        IF (NREP.GT.0) THEN 
          DO 16 J = 1, NREP 
            IK = IK + 1 
            KEYI(IK) = KEYSDV(IKEY+J)   
   16     CONTINUE  
        ENDIF   
      ELSE IF (IOTYDK(IKEY).EQ.2) THEN  
*  *        Integer 
        LEN  = MIN (10,LKEY)    
        KY10 = BLANK(1:10-LEN)//KYVAL(1:LEN)    
        READ (KY10(1:10), 1002) KEYSDV(IKEY)    
        KEYI(IK) = KEYSDV(IKEY) 
      ELSE IF (IOTYDK(IKEY).EQ.1) THEN  
*  *        Bit-string  
        LEN  = MIN (8,LKEY) 
        KY10 = BLANK(1:8-LEN)//KYVAL(1:LEN) 
        READ (KY10(1:8), 1003) KEYSDV(IKEY) 
        KEYI(IK) = KEYSDV(IKEY) 
      ENDIF 
      GO TO 10  
   20 CONTINUE  
      NI = IK   
*   
*   * Variable data-length and Search Options in CHOPT  
*   
      CHOPT(IC+1:IC+2) = 'VS'   
*   
*  ** Find the Objects Satisfying the Search    
*   
      CALL DBUSE (PATHN, LKVWDX(1), LDVWDX(1), IDATM, KEYSDV(1),    
     +            CHOPT(1:IC+2))    
*   
*  ** Get the Key-Names to Present  
*   
      CALL VZERO_i (JFKYDV, NWKYDK)   
      CALL VZERO_i (IFLAG, NWKYDK)    
      IP = 1    
      ICONO(I) = 0  
      CHTO(1)  = CTAGDK(1)  
      IOTO(1)  = IOTYDK(1)  
      JFKYDV(1) = 1 
   25 CALL KUPROC ('Key-Name to Present (if no more: |) ?', KYNAM, LKEY)    
      IF (KYNAM.EQ.'|')     GO TO 30    
      I = NSYSDK+1  
   26 IF (I.GT.NWKYDK)      GO TO 28    
        IF (KYNAM.EQ.CTAGDK(I).AND.IFLAG(I).EQ.0) THEN  
          IFLAG(I) = 1  
          IP = IP + 1   
          CHTO(IP)  = CTAGDK(I) 
          IOTO(IP)  = IOTYDK(I) 
          ICONO(IP) = ICONDK(I) 
          JFKYDV(IP) = I    
          IF (ICONO(IP).LE.0) THEN  
            GO TO 25    
          ELSE  
            NREP = ICONO(IP)    
            DO 27 J = 1,NREP    
              IP = IP + 1   
              I = I + 1 
              IFLAG(I) = 1  
              CHTO(IP)  = CTAGDK(I) 
              IOTO(IP)  = IOTYDK(I) 
              ICONO(IP) = ICONDK(I) 
              JFKYDV(IP) = I    
   27       CONTINUE    
          ENDIF 
          GO TO 25  
        ENDIF   
        I = I + 1   
        GO TO 26    
   28 CONTINUE  
      GO TO 25  
   30 CONTINUE  
*   
*  ** Lift Bank for Output  
*   
      NO = IP   
      IF (NO.LE.0)          GO TO 999   
      NOBO = NZBANK (IDIVDB, LKVWDX(1)) 
      IF (NOBO.LE.0)        GO TO 999   
      NDAT = NO *  NOBO
      nio(1) = 2
      CALL DBBOOK (IDIVDB, LVIWDX, LVIWDX, 2, 'VIEW', 0, 0, NDAT, nio,
     &     0) 
      IF (IQUEST(1).NE.0)   GO TO 999   
*   
*  ** Fill-Up 'VIEW' Bank and free LKVWDX   
*   
      IPOIN = LVIWDX    
      NKOBJ = NZBANK (IDIVDB, LKVWDX(1))    
      IF (NKOBJ.GT.0) THEN  
        LFRSDX = LKVWDX(1)  
        DO 40 K = 1, NKOBJ  
          IF (LFRSDX.GT.0) THEN 
            DO 35 J = 1, NO 
              IPOIN = IPOIN + 1 
              IQ(KOFUDB+IPOIN) = IQ(KOFUDB+LFRSDX+JFKYDV(J))    
   35       CONTINUE    
          ENDIF 
          LFRSDX = LQ(KOFUDB+LFRSDX)    
   40   CONTINUE    
      ENDIF 
      CALL MZDROP (IDIVDB, LKVWDX(1), ' ')  
      GO TO 999 
*   
* *** Error messages    
*   
  991 IQUEST(1) = 101   
      IF (IDEBDB.GT.0) THEN 
        KYVAL  = PATHN  
        NCH    = LENOCC (KYVAL) 
        CALL DBPRNT (LPRTDB, '(/,'' DBVWPR : Illegal Path Name '//  
     +       KYVAL(1:NCH)//''')', IARGDB, 0)    
      ENDIF 
      GO TO 999 
*   
  992 IQUEST(1) = 102   
      IF (IDEBDB.GT.0) THEN 
        KYVAL  = PATHN  
        NCH    = LENOCC (KYVAL)
        iarg(1) = nsysdk
        CALL DBPRNT (LPRTDB, '(/,'' DBVWPR : Less than '',I5,'' key '// 
     +       'for Path Name '//KYVAL(1:NCH)//''')', iarg, 1)  
      ENDIF 
      GO TO 999 
*   
 1001 FORMAT (I2)   
 1002 FORMAT (I10)  
 1003 FORMAT (Z8)   
*                                                             END DBVWPR    
  999 END   
      SUBROUTINE DBWRDP (LUN, LAD)  
*     ============================  
*   
************************************************************************    
*                                                                      *    
*        SUBR. DBWRDP (LUN, LAD)                                       *    
*                                                                      *    
*   Prepares the display the data on unit LUN and at address LAD       *    
*                                                                      *    
*   Arguments :                                                        *    
*                                                                      *    
*     LUN      Unit number of file for display                         *    
*     LAD      Address of the data in DBSTOR                           *    
*                                                                      *    
*   Called by DBDISD, DBPEEK                                           *    
*                                                                      *    
*   Original Code : J. Zoll                                            *    
*                                                                      *    
************************************************************************    
*   
      COMMON /GCBANK/ FENCDB(22), LQ(9) 
      DIMENSION       IQ(2), Q(2)   
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))    
*   
      COMMON /QUEST/  IQUEST(100)   
*   
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)  
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80) 
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)  
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)    
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20) 
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)    
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)  
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)  
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)   
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)  
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)   
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)  
      PARAMETER       (MDCALI=4, MDCNAM=6)  
      PARAMETER       (NARGDB=20)   
      PARAMETER       (LUFMDB=999)  
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,    
     +                 MFLGDB=6, MITMDB=7)  
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)    
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)    
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)    
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)    
      PARAMETER       (MYFNDB=6)    
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB    
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)    
     +              , IARGDB(NARGDB)    
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB    
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB    
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7) 
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB    
      PARAMETER       (NDMXDB=25000)    
*   
      COMMON /MZIOC/ NWFOAV,NWFOTT,NWFODN,NWFORE,IFOCON(3)  
     +,              MFOSAV(2),  JFOEND,JFOREP,JFOCUR,MFO(200)  
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)  
*   
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)  
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)    
*   
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) ) 
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  ) 
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(    
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1))) 
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )   
*   
*     ------------------------------------------------------------------    
*   
*  ** No data to display    
*   
      NDAT = IQ(KOFUDB+LAD-1)   
      IF (NDAT.LE.0)        GO TO 999   
*   
*  ** Crack I/O Words into the character description    
*   
      LIO = LAD - IQ(KOFUDB+LAD-3) - JBYT(IQ(KOFUDB+LAD),19,4) - 1  
      CALL MZIOCR (LQ(KOFUDB+LIO))  
*   
*  ** This part (upto the RETURN) is by courtesy of J. Zoll 
*   
      NDONE = 0 
      JFOCUR = 0    
   10 ITYPE = MFO(JFOCUR+1) 
      IF (ITYPE.EQ.7)       GO TO 31    
      NWSEC = MFO(JFOCUR+2) 
      NDO   = NWSEC 
      IT    = ITYPE 
      IF (NDO.GT.0)         GO TO 41    
*   
      IF (NDO.LT.0)  THEN   
*   
*  *    Rest of the bank    
*   
        NDO = NDAT  
      ELSE  
*   
*  *    Dynamic sector  
*   
        NDONE = NDONE + 1   
        NDO   = IQ(KOFUDB+LAD+NDONE)    
      ENDIF 
      GO TO 34  
*   
*  ** Self-describing sector    
*   
   31 NDONE = NDONE + 1 
      IWORD = IQ(KOFUDB+LAD+NDONE)  
      IT    = MOD (IWORD,16)    
      NDO   = IWORD/16  
*   
   34 IF (IT.GE.8)          GO TO 999   
      IF (NDO.LT.0)         GO TO 999   
      IF (NDO.EQ.0)         GO TO 999   
*   
   41 JS = NDONE + 1    
      JE = MIN (NDONE+NDO, NDAT)    
      DO 47 J = JS, JE  
        IF (IT.EQ.1) THEN   
          WRITE (LUN, 1001) J, Q(KOFUDB+LAD+J)  
        ELSE IF (IT.EQ.2) THEN  
          WRITE (LUN, 1002) J,IQ(KOFUDB+LAD+J)  
        ELSE IF (IT.EQ.3) THEN  
          WRITE (LUN, 1003) J, Q(KOFUDB+LAD+J)  
        ELSE IF (IT.EQ.5) THEN  
          WRITE (LUN, 1004) J,IQ(KOFUDB+LAD+J)  
        ENDIF   
   47 CONTINUE  
      NDONE = JE    
      IF (NDONE.GE.NDAT)    GO TO 999   
*   
      JFOCUR = JFOCUR + 2   
      IF (JFOCUR.LT.JFOEND) GO TO 10    
      JFOCUR = JFOREP   
      GO TO 10  
*   
 1001 FORMAT (1X,'B',I5,4X,Z10) 
 1002 FORMAT (1X,'I',I5,4X,I10) 
 1003 FORMAT (1X,'F',I5,4X,E12.4)   
 1004 FORMAT (1X,'H',I5,4X,A4)  
*                                                             END DBWRDP    
  999 END   
