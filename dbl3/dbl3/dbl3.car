+TITLE.
C DBL3  V  3.10     911215 11.30    Database Utility Program
+PATCH, DBL3HEAD, IF=$DOC.
+DECK, DBL3HEAD.
 
Current version number : 3.10  (see below)
 
Coordinator  for this PAM : R.Mount
Deputy                    : S.Banerjee, E.Nagy
Attached Processor        : M.Guanziroli
 
This is a 'Utility' Pam file for the storage and retrieval of data
in the L3 Data Base system.
 
 
List of Patches :
---------------
 
  DBL3HEAD     Pam header and short history of successive versions
  DBL3DOC      General documentation
  *DBLIB       Steering patch for creating DB library
  *DBINT       Steering patch for creating interactive DBMAIN
  DBCDES       Commons used in the package
  DBEXAMn      Example how to create Database (n=1,3,5,7)
  DBEXAMn      Example how to use DBL3 (n=2,4,6,8)
  DBEXAMn      Example for testing DBL3 (n=9, A)
  DBMAIN       Main program for interactive usage and example of Logon
               macros
  DBL3         Routines related to User interface to database package
  DATABASE     Routines related to the database package (System related)
  DBONLINE     Routines related to the online  server
  DBOFFLIN     Routines related to the offline server
  DBPLOT       Routines related to the plotting fcailities of database
               package
  DBP3         Routines related to the Host/A.P. environment
  DBXINT       Routines related to interactive database accesses
  DBINSTAL     Examples of installation decks
 
 
PATCHY Options :
--------------
 
  APOLLO, CRAY, HPUX,
  IBM, IBMRT, MIP,
  UNIX, VAX        - To select machine dependent codes
  $P3CHILD         - To select the child task dependent code
  $HIGZ            - To select the plotting facilities in the inreactive
                     version.
  $DOC             - To flag the (non-executable) documentation Patches
  $DEBUG           - To switch on the debug print outs
  $SERVER          - To activate the codes for servers
  $INIMODE         - To switch on the initialisation mode in DBEXAM2
  $PARTDIR         - To test partitioned directories in DBEXAM9
 
 
Extra material required :
 
  CERN libraries KERNLIB and PACKLIB (including ZEBRA 3.61)
       INL3 Pam file, GRAFLIB for the interactive package
 
 
+DECK, DBSTORY.
 
Pam history in inverse chronological order:
-------------------------------------------
 
Version 3.10  (December 1991)
------------
 
   Introduction of parameter statements for key names. New entry
point DBDONT added specifically for use of lumlist stored on DB.
 
Version 3.09  (November 1991)
------------
 
   Correction of character tables for new machines. Possibility of
enforced updating (no check on Key 1 value) on selective directories
supplied through routine DBILDF.
 
Version 3.08  (April 1991)
------------
 
   Extended functionality in DBUSE/DBFREE for character option M.
Bugs fixed in DBFREE. Patch name ACCESORY has been renamed to DBEXTRA.
Possibility of updating on selective directories supplied through
routine DBILDU. Improvement of handlings of data access in P3 mode.
 
Version 3.07  (July 1990)
------------
 
   Bug fixes and cleanup of code.
 
Version 3.06  (June 1990)
------------
 
   Implementation of the code in a parallel processing environment.
The  modifications needed to run DBL3 in a Host/Attached Processors
environment are of 2 types : (1) trivial: replacing WRITE with DBPRNT
(and internal write with UTWRIT for emulators); (2) substantial: storing
objects into the database RZ file is done by the host at request from
the child Requests from  the child tasks are centralized  through a
common routine DBCHLD, which is responsible for the dialogue with the
host. Its partner routine in the host library (server) is named DBHOST.
Data retrieval  (DBUSE,...) does  not need any  special code, since the
AP version of RZ already handles correctly RZIN calls. It also runs on
CRAY (new Patchy flag CRAY). New example DBEXAMB added, an example to
convert ASCII file to a database object (used in converting L3 field
map).
 
Version 3.05  (March 1990)
------------
 
   Facilities to retrieve data on the basis of serial number (DBGETS);
to extract certain part of the data base in the form of a journal file
(DBRTFZ); to delete all but the specified directory trees in the data
base (DBKEPT); to increment packed date/time by a given amount (DBINCT).
Provision for server mode option on Apollo. Bug correction in DBSEKY
(data retrieval through DBUSE) and added functionality in DBFZUP.
 
Version 3.04  (September 1989)
------------
 
   Facilities to store and retrieve help information for a given
directory (DBEHLP, DBRHLP); to give alias name for directory (DBEALI,
DBRALI); to store and use tags for data elements for a directory
(DBENAM, DBRNAM, DBGNAM). Facility to fetch a set of data base objects
within a time slice (DBGET). Calling sequence of the routine DBENFZ
(used internally by DBL3) has been changed. Facilities of transforming a
non-partitioned directory to a partitioned one is introduced (DBNTOP);
of deleting all but the last few partitions in a partitioned directory
(DBPRGD). Calling sequence of DBDELT is changed. New routine DBRKY1 to
return the serial numbers of all the objects stored. Now the S option
in DBINIT isv taken care inside the code by locking and freeing all
appropriate directories for the write operations. User should remove
all LOCK and FREE calls in their code (for such operations).
 
Version 3.03  (July 1989)
------------
 
   Introduction of Parameters in bit settings and introduction of
statement functions for bit/byte handlings. Backward incompatible
changes in the structure of the journal file and calling sequences of
DBFZOP, DBFZUP. Extension of the plotting and interactive facilities.
Introduction of the facility of deleting a directory (DBDELT). New
code for Servers on VAX and on IBM. Capability of introducing ASCII
files to data base and retrieving them (DBABRD, DBABWR). Routines
DBINIT and DBEFOR have backward incompatible codes. DBINIT for making
a new data base should have character option 'Z' along with NREC>0.
New routine DBRENK to rename keys (useful in the context of server).
 
Version 3.02  (February 1989)
------------
 
   Optional creation of journal files while creating or updating data
base (through routine DBFZOP). Updating of databases from the journal
file through a new routine DBFZUP. Creation and use of Dictionary
information (no change in the user code is required). Facilities to
plot validity time of data objects, variation of some data elements with
any key element, correlation of data elements (routine DBPLTI, DBPLOB,
DBPLOV). Modified interactive menu and use of plotting facilities
interactively. Global selection on insertion time (DBEFOR), utilities
to find the last inserted objects (DBLAST, DBLKEY), date of last change
in data base (DBLMOD), creation of DBTB bank with information of data
objects used (DBTBCR). All examples revisited in light of testing all
the modifications.
 
Version 3.01  (September 1988)
------------
 
   New routines DBENTB and DBPURK for storing and deleting objects. New
option 'S' in DBPURG. Some old bugs fixed. New example Patches DBEXAM9
and DBEXAMA. New routine DBCRSD to create standard L3 directory(ies).
 
Version 3.00  (April 1988)
------------
 
   The use of DBL3 is now independent of the ZEBRA store. Also a
facility is added (test on IQUEST(2)) in DBUSE for permitting the
user to be informed if data has been refreshed in the current pass.
 
Version 2.10  (February 1988)
------------
 
    Bugs have been fixed in routines DBUSE, DBKEYS, DBKXIN and DBKOUT.
 
    A new concept of partitioned database is introduced in view of the
directories accumulating a large number of data objects. A directory
could be defined to be of partitioned nature at the time of creation
only, by using the routine DBMDIP instead of DBMDIR or through the
character option 'P' in routines DBENTR or DBOUT or DBVOUT.
 
    An interactive version of the Data Base routines has been added in
the Patch DBXINT. These routines are based on the KUIP package (Version
1.00).
 
Version 2.00  (October 1987)
------------
 
    This version is based on a modified RZ-package (Version 3.54) which
allows the use of an increased number of keys (upto 100).
 
    A new option 'S' is added to the routine DBUSE enabling retrieval of
all objects in a directory satisfying prescribed conditions on a limited
number of key-elements. This new feature allows to use DBL3 as a
relational Data Base management system.
 
    This version provides two new routines DBENTR and DBREPL which can
enter data on to the disk and to the memory (like DBUSE in Node/Key
structure) at the same time. The routine DBREPL replaces a set of old
user keys by a new set where the keys are used to form a table (as in
relational data base).
 
    The routines DBKVIN and DBKXIN are no longer supported as user entry
points. They are now internal to DB package. The arguments of these
routines and also of DBKIN have been changed from previous versions.
 
Version 1.10  (April 1987)
------------
 
    This version provides two new routines DBUSE and DBFREE for
retrieving data and for freeing (not dropping) a data object not
used at this moment. This permits the user to optimise between the
frequency of data retrieval and the available space in memory.
 
Version 1.00  (February 1987)
------------
 
   This is the first version installed on APOLLO and on VM using
the ZEBRA Version 3.53 allowing for 9 keys in RZ.
 
Version 0.99  (9 December 1986)
------------
 
   This version is based on an early version of ZEBRA (Version 3.41)
allowing only 5 keys in an RZ directory. This version is installed
also on VM and used for BGO calibration. Y. Karyotakis has written
a version of it on VM allowing an interactive query on the database.
 
+PATCH, DBL3DOC, IF=$DOC.
+DECK, DBL3DOC.  General information
 
 
 The basic concepts for the L3 database were defined by Francis Bruyant,
Richard Mount and other members of the collaboration; in particular,
Y.Karyotakis from the BGO Group, B.Adeva, E.Gonzales from the Muon
Chamber Group, M.Fukushima, T.Hebecker, R.Dolin from the Trigger Group
were involved in defining the specific requirements for various
applications. The software presented here has mainly been written by
S.Banerjee and E.Nagy. The work of L.Barone and N.Colino in the
implementation of the server and the work of Z.L.Ren and A.Syed in
developing the plotting facilities have been greatly appreciated.
 
 
 
  General documentation
  ---------------------
 
 
    A Software Utility Package for the L3 Data Bases :
    ------------------------------------------------
 
                     S.Banerjee, F.Bruyant, R.Mount, E.Nagy
 
1. Introduction.
 
  High Energy Physics experiments, nowadays, require the use of powerful
data base systems. The data consist usually of a part which is largely
time independent, for instance the parameters which describe the
experimental setup, and of another part whose contents may vary with
time, with different frequencies, and have therefore to be recorded
repeatedly, with proper time validity ranges.
 
  The latter may represent quite a large amount of data. As an example,
for the L3 Detector, one expects to have to store several gigabytes of
data per year of operation.
 
  At program execution time, fast access to the data base contents is
essential, and an efficient system which limits the rate of transactions
between the directly addressable storage medium, where the data base
resides, and the computer memory available to the user, has to be
implemented.
 
  In a multi-user, multi-computer environment, keeping up to date a
centralized data base and optimizing the data flow is not a trivial
matter. This can only be achieved through dedicated 'service' machines
under control of a data base 'server'.
 
  Last, but not least, the system has to be robust and safe, and
equipped with facilities which minimize the inconveniences of a
possible program crash or of a computer hang-up.
 
  The Software utility package DBL3, presented here, is an attempt to
solve the above requirements. It has greatly benefitted from feasibility
studies made by dedicated working groups within the L3 collaboration[1].
 
  The data base server, successfully put in operation for the LEP Pilot
run, will be described elsewhere [2]. In short, the data bases are
owned by a server program which is active all the time; any user who
wants to update a data base, by addition or deletion of data, has to
communicate a request to the server, which takes the appropriate action,
avoiding clashes between different processes possibly trying to write on
the same data base file. The communication between the server and the
user program is taken care of by the DBL3 package.
 
  DBL3 is based on the ZEBRA system [3] and relies heavily on one of its
constituents, the Random Access I/O package RZ, and also on the well
known MZ (memory management), DZ (debug and dump) and FZ (sequential
I/O files) packages, with which the user is assumed to have some
familiarity.
 
  Section 2 gives an overview of RZ. Section 3 reviews the main concepts
and the basic functionality of DBL3. Section 4 gives more information on
the user interface, and Section 5 describes, for completness, other
facilities available in the package.
 
  The present report refers to the version 3.04 of the package. The code
is available from CERN, on request to the authors, as an exportable CETA
Pam file. More details of the user callable routines can be found in the
inline documentation at the beginning of each routine. Simple examples
of application programs are also given inside the Pam file.
 
 
2. An overview of the RZ package.
 
  The choice of RZ was natural, as all L3 Software components make use
of Zebra. RZ seemed to have all basic features which one thought to be
needed for the L3 data base system, including transportability from
computer to computer. Furthermore, RZ was free of charge and frequent
contacts with its authors, residing at CERN, could give us the
opportunity to suggest adequate developments and to benefit from a fast
feedback.
 
  Once a random access file has been opened, RZ permits the creation of
a tree of directories, each one addressable through its pathname, and
the storage and retrieval of data at any level of the tree. Pathnames
are built-up by concatenating the names of the directory nodes along the
given paths through the tree, following the conventions of the UNIX
hierarchical file structure. Several files can be opened and handled by
RZ at the same time; the top level directory names being not recorded in
the files, they can be assigned by the user at initialization time, thus
permitting concurrent access to directories with identical internal
pathnames from different files.
 
  Several 'data objects' can be associated to any node; they are
addressed by the pathname of the corresponding directory and by a vector
of keys, which make possible their identification. The keys are stored
by the system in a way which permits a fast retrieval of the data
objects.
 
  The dimension of the key vector and the definition of the keys (names
and types), are user defined, at the time of creating a directory.
Therefore, before storing any data, the user has, if not yet done, to
create a directory and, at the same time, to give the specifications of
the key vector, which become an intrinsic property of the directory.
Once this is done, the user is no longer free to change either the
sequence of node names along the path to the directory or the number
of keys and their definition. Note that the keys can only be of type
integer, hollerith or bit string.
 
  The data objects are Zebra data structures, or single banks in the
simplest case. Successive versions of the same data objects can coexist
with different cycle numbers, but, as explained in the following
section, this facility is not used by DBL3. Empty data objects are
accepted, the key values playing the role of the data to be stored;
then, the key vectors can be used as relational tables, and for the
purpose, their maximum dimension permitted by RZ has been enlarged to
100. It should be noted, however, that the usage of directories with
both a large number of keys and a large number of data objects is not
recommended in RZ, as it degrades the timing performance of the system
(steps have been taken in DBL3 to cure this weakness).
 
 
3. DBL3 concepts and basic functionality.
 
  Built upon RZ, the DBL3 package provides facilities and utilities
which have been developed in the context of L3, but can nevertheless be
considered of general interest. It increases the functionality of RZ
where it was thought to be useful, in particular for a better control of
the time validity of the data objects (L3 standard keys), for a more
economical storage on the random access devices (data compression) and
for an improvement of the overall performance (optimization of disk-
memory transfers, partitioned directories).
 
 3.1 Data base representation in memory.
 
  The DBL3 package uses as Zebra dynamic store a labelled common block.
This can be any of the stores used by the application program. DBL3
operates inside two divisions in that store ; a DBL3 system division, of
no concern for the user, and the division where, at user's request, the
data objects are dumped from the random access medium and kept in memory
as long as required by the user.
 
  In the latter division, data objects from a given data base file are
stored as Zebra banks, or Zebra data structures, within a main data
structure which reproduces, partially and only for the directories in
use, the Node/Key structure of the data base files. As many main
structures can be simultaneously handled in memory as there are data
base files declared by the user; however, they are expected to all share
the same division. The skeleton of NODE and KEY banks grows up,
following the successive user requests, and stays permanently available
in memory. The data banks, appended to the corresponding KEY
banks, can be either refreshed when the time dependence of their
contents requires it, or dropped when they are no longer needed by the
user. They can also be marked as temporarily unwanted, so that the
system can drop them in case of shortage of memory, at the cost of
reaccessing them from the random access device if and when required
again.
 
 3.2 L3 standard keys and user keys.
 
  In order to minimize the disk-memory transfers and to permit a tight
control of the whole system, a few general standard keys have been
defined. The DBL3 package assumes that all key vectors consist of at
least 7 keys. The keys 1, 2 and 6 are totally internal to the system.
The keys 3 and 4 carry the user assigned range of validity for the data
objects (upto seconds). Key 5, set by the user, is the 'source
identifier' reserved to identify, one way or another, the program which
creates the corresponding data object. Key 7 is filled in by the system
and carries the insertion time of the data object in the data base (upto
minutes). Access to keys 3, 4 and 7 permits control of time dependence
in a more flexible way than the RZ cycle numbers, which is why the
latter are never used by the DBL3 package.
 
  Additional keys, the so-called user keys, can be declared by the user
(within the overall limit of 100 keys). Their role will become more
transparent when reviewing the functionality of the storage and
retrieval of data objects, in Sections 4.3 and 4.4.
 
 3.3 Data compression.
 
  By default, whenever possible, that is when all elements of a data
object are of the same type (integer or real), DBL3 proceeds
automatically to packing, with the default storage precision or the one
specified by the user. The default algorithm for packing searches for
the optimum bit-length the majority of the data can be packed with, the
rest being represented by two data words, the value and the location in
the data array, so as to minimize the total number of words. Another
packing algorithm, activated at user's request, stores only the data
elements whose absolute values are greater than a predefined number.
Packing and unpacking are automatic and not seen by the user, who always
deals with unpacked data in memory. Furthermore, the user is in any case
given the possibility to inhibit the packing.
 
  In order to store data as compactly as possible, a default updating
procedure is built in the program. Provided the user has not explicitly
turned off this process, the DBL3 software looks for a neighbouring
object such that the difference with the object to be inserted can be
described and packed in the least number of words. Like packing,
updating is completely automatic and not seen by the user.
 
 3.4 Real time optimization.
 
  The RZ package is not optimized for handling directories with too many
data objects; the memory resident part of the data describing the keys
becomes very large and storage and retrieval become more expensive, both
in CPU time and real time, when the number of data objects exceeds a few
thousands. The concept of partitioned directory has been introduced to
attenuate these effects. Subdirectories are automatically created when
needed, with keys which permit to keep track of their contents and to
quickly access the right partition. Partitioning is invisible to the
user, who just has to give its characteristics when creating the
directory. Subsequent storage and retrieval of data objects in a
partitioned directory follow the same rules as for a normal directory,
as far as the calling sequences of the user interface subroutines are
concerned. It should be noted however that direct calls to RZ routines
for handling such directories would be extremely hazardous and should
be avoided.
 
  To further optimize real time usage in storing data, DBL3 also
provides a facility to store several objects, belonging to the same
directory, in one pass. In real time, the gain is about proportional to
the number of objects one stores at once.
 
 3.5 Dictionary.
 
  The DBL3 package supports a dictionary in a special directory called
DICTIONARY. In the dictionary the user can enter, for any of the
directories, simple alias names for the pathnames as well as mnemonics
for the data object elements (both limited to 8 characters). The
DICTIONARY directory, which does not make use of the standard L3 keys,
is automatically generated, at the top level, when the data base is
created. To start with, it has only one data object, with key 1 set to
-1. The data object contains the number of directories in the data base,
followed by 25 words for each directory, 3 integers and 22 hollerith.
The integers contain the unique numeric identifier assigned to the
directory, the number of characters in the pathname and the date of the
last modification. The 2 first hollerith are reserved to store an alias
name for the pathname (up to 8 characters) and the rest to store the
pathname itself (top directory name excluded).
 
 3.6 ASCII data objects and HELP directory.
 
  A facility has been introduced which permits to store in a data base
the contents of ASCII files with a record length less or equal to 80
characters. Several applications in the L3 software make use of
it. One of them is, in the context of the Production Control, for
storing in the Job Log data base a summary of the job performance.
Another is related to the storage of help information in a special HELP
directory generated at the top level when a data base file is created.
HELP directories do not make use of the standard keys. One key is used
to specify the node to which the help information is relevant.
 
 3.7 Journaling.
 
  For restoring the integrity of a data base after a crash, as well as
for establishing communication with the data base server, a journaling
facility has been implemented. It consists of recording on an FZ
sequential file all kinds of updates which affect the data base, namely
the addition or deletion of directory trees, the addition or deletion of
data objects, the alteration of key values, the deletion of some
partitions in a partitioned directory, the definition of aliases and
mnemonics in the DICTIONARY directory or the insertion of items in the
HELP directory. The information is recorded in different types of FZ
records, consisting of at least an FZ header, with or without a data
part, depending on the kind of action, recorded as first word in the FZ
header. In case of several data base files, each corresponding top
directory is associated with an RZ file number. The same FZ file can
however serve several top directories, if the user has decided so. It is
possible to update a database on a selective number of directories from
a journal file.
 
 
 
4. DBL3 User interface.
 
  In most of the DBL3 calling sequences, various character options can
be preset by the user and transmitted as a character string, the
argument 'CHOPT'. These will be referred to as 'options' in the
following paragraphs.
 
 4.1 Initialization phase and use of non standard directories.
 
  The user is supposed to have initialized the ZEBRA memory management
system through the standard MZ package routines. The data base files, on
random access devices, have also to be opened through FORTRAN OPEN (+ a
call to VMCMS, on IBM/VM). Then, for each data base file, a call to
DBINIT initializes the DBL3/RZ control for the corresponding file. When
using several data base files, the user should be careful always to give
the complete pathnames for all subsequent references to the directories.
 
  For an optimum usage of the RZ system, the user is advised to have a
reasonably large allocation for the system division. For the time being,
a safe way to proceed is to lift a large bank in the system division and
to drop it prior to the first call to DBINIT.
 
  A unique numeric identifier is associated to every given top directory
(every file). The DBL3 package defines by default an identifier
increasing monotonically as the user makes the successive calls to
DBINIT. The choice of the identifier can however be imposed by the user,
by presetting IQUEST(1), a Zebra short term communication variable, to
the desired value, before calling DBINIT. The numeric identifier
assigned to each directory packed with that of the top directory, is
stored in the corresponding NODE bank. This permits to record in a
simple way which data objects have been used in a given program
execution.
 
  To activate the journaling mode, the user should first open the FZ
file through a FORTRAN OPEN statement followed by a call to FZFILE, then
define the appropriate unique FZ file number associated to the given top
directory, through a call to DBFZOP (the file number being set by
default to 0 at initialization time through DBINIT).
 
  When running in a server mode, the only differences with the stand
alone mode concern the OPEN statement for the RZ file (read only and
shared instead of read/write) and the call to DBINIT, where the option
'P' (public) has to be specified.
 
  The DICTIONARY directory, initially generated under control of DBINIT,
is dumped into memory at every call to DBINIT. It can be expanded at
user's request to store mnemonics (upto 8 characters) for the elements
of the data objects. These are mainly used in DBL3 interactive
applications. For each directory, the mnemonics are stored in a data
object of the DICTIONARY directory, with key 1 set equal to the numeric
identifier of the corresponding directory. The routines which can be
used for entering or retrieving the information are DBENAM and DBRNAM
respectively. The alias names, in the DICTIONARY directory, can be
stored and retrieved through the routines DBEALI and DBRALI.
 
  The HELP directory, also generated automatically under control of
DBINIT, at the time of creating the data base, is initially empty. The
user should enter the help information as an ASCII file through the
routine DBEHLP. The content of the file is encoded as a computer
independent single data object with the key 1 set equal to the numeric
identifier of the relevant directory. The help information can be
subsequently retrieved, decoded and displayed through the routine
DBRHLP.
 
 
 4.2 Creation of standard directories.
 
  Before storing any data, the user has to create a directory with all
specifications of the key vector. The routine DBCRSD permits to create
L3 standard directories, with any number of additional user keys. The
option 'P' (partitioned) can be used to create a partitioned directory.
Any creation of a directory is accompanied by an automatic update of the
dictionary. In case the directories at the intermediate nodes do not
exist yet, DBCRSD will create them and, by default, assigns to them 9
keys, all of type integer. To rescue from a situation where a directory,
originally expected to receive a limited number of data objects and
hence created as a normal directory, happens to have too many objects
to be handled efficiently, the user can call DBNTOP to transform the
directory into a partitioned directory.
 
 4.3 Storage of data.
 
  The user can store data from memory to disk with either of the two
routines DBENTR or DBREPL, the data in memory being simple Zebra banks
or Zebra data structures. In the latter case, the option 'R' (full RZ
option) has to be used. The pathname of the directory as well as the key
vector have to be supplied when storing the data (the system keys 1, 2,
6 and 7 do not however need to be filled in). If the directory does not
exist yet for the data object, the above routines will create it only
when the option 'N' (new) has been required. Note that, with the option
N, it is only possible to create a new directory with a maximum of 9
keys, all of integer type. If the user wants to store the data object in
a partitioned directory the option 'P' (partitioned) has also to be
specified, unless the directory already exists.
 
  As mentioned earlier, the relatively large maximum number of keys
allows the user to construct data tables which can be scanned by the
program much faster than any equivalent data residing in the data
objects. In this context, the use of DBREPL plays an important role, to
the extent where, unlike DBENTR, it permits to replace an old set of key
values by a new one. Both routines DBENTR and DBREPL can also be used,
with the option 'C' (copy), to keep at the same time a copy of the data
base object in memory in the NODE/KEY data structure.
 
  To store several objects belonging to the same directory in one pass,
the user can call DBENTB. The addresses of the several data structures,
or single banks, have to be prepared in a vector of addresses passed on
as an argument.
 
  In relation to the automatic compression of data mentioned earlier, a
number of options is available : 'U' (unpacked) to inhibit the packing,
'Z' (zero suppression) to store only the non-zero elements, a zero
element being defined according to the precision word given as argument
in IPREC, 'R' (RZ) to store with full RZ options and therefore with no
data compression, 'S' (stand alone) to inhibit the automatic updating
procedure and 'F' (forced update) to force the updating with respect to
a data object previously stored with identical user key values.
 
  The contents of an ASCII file can be encoded into machine independent
format and stored in a data base through the routine DBABWR. The
functionality and the calling sequence of the routine are quite similar
to those of DBENTR. However, the logical unit number from which the
routine is expected to read the file, has to be passed as an argument.
The user is assumed to have opened the file with a FORTRAN
OPEN, before calling DBABWR.
 
  The update of a data base from a journal file can be done by first
initializing the relevant file (with a FORTRAN OPEN and a call to
FZFILE), then by simply calling the routine DBFZUP. The user can make
a journal file from the data enetered in the data base using the routine
DBRTFZ. This file is useful to transmit updates to the data base. One
can select only a few directories of the data base for the update
purpose. The user has to create a file with a list of directory names
to be updated; open this file through a FORTRAN open and call the
routine DBILDU to load the names.
 
 4.4 Retrieval of data
 
  The user can retrieve Zebra data structures from any directory on a
disk file into memory through the routine DBUSE. The data objects are
selected according to the given directory pathname and to the contents
of the key vector, namely the validity interval (keys 3 and 4) and, when
relevant, the prescribed values for a number of user keys (from 8 to 29,
through the options '8' to '29'). If not yet done, the routine creates
in memory a tree structure of NODE banks, according to the pathname
elements. At the lowest node, DBUSE inserts the information relevant to
the keys in KEY banks (one or several, created as a linear chain at the
next-of-same-type link of the corresponding NODE banks) and the
information relevant to the data itself, in DATA banks supported by the
first link of the corresponding KEY banks. As a general rule, when DBUSE
finds that more than one data object satisfy the validity criteria, the
default action is to return the latest inserted one. Special actions can
however be taken, with the options '5' and '7', through the values of
the system keys 5 and 7, to force the retrieval of a data object with
given source identifier or with given insertion time. Independently, the
user can set a global selection on insertion time, through the routine
DBEFOR, for instance to ignore modifications to the data base past a
certain date and be able to reproduce the conditions of a previous
program execution.
 
  DBUSE can retrieve several data objects at once, with the option 'M'
(multiple), which permits to prescribe several values per key, for upto
5 user keys. The key numbers (from 8 to 29) have to be specified as
options and the required values, for each key, have to be given in an
extension to the input key vector.
 
  DBUSE also supports, with the option 'S' (selection), the retrieval of
all valid objects, at the given directory, satisfying user conditions on
any of the user keys (8 to 29). As for the 'M' option, the selected
KEY banks are linked as a linear chain of banks and the address of the
first one is returned to the user. The options 'M' and 'S' are mutually
exclusive.
 
  With the option 'K' (key), DBUSE also permits retrieval of the keys
only, without loading the data objects.
 
  In case DBUSE finds that the required data objects already exist in
memory, it does not bother to transfer them again from disk. Also, by
default, unless the option 'V' (variable size) is specified, DBUSE
assumes that the refreshing of the data objects in memory can be done in
situ and overwrites the contents of the same data banks, hence avoiding
unnecessary memory management operations.
 
  For an optimum use of the memory, and in order to minimize the disk
accesses, the user should call the routine DBFREE, in conjunction with
DBUSE. DBFREE sets a flag in the specified KEY bank to signal that the
corresponding data object is no longer needed, until a subsequent call
to DBUSE requires it again. The data object bank is not dropped
immediately, but only if and when any other call to DBUSE need more
space than currently available in memory. If the 'frozen' data object
has not been dropped when it is required again, the flag is cleared and
no further disk transfer will take place.
 
  To read data objects where ASCII information has been encoded, the
user can call DBABRD, similar to DBUSE, except that the logical unit
number of the file reserved to write the ASCII information has to be
passed as an argument.
 
 4.5 Alternative for data storage and retrieval.
 
  DBL3 has a few other user entry points. Some of them have been
conserved only for backward compatibility with previously released
versions of the package, and should preferably not be used. Others have
been designed with some specific use in mind and it is recommended not
to use them without understanding fully the implications of their
specificity and their limitations.
 
  The creation of standard directories can be achieved by calling
directly  either DBMDIR, for normal directories, or DBMDIP, for
partitioned directories. Both routines are internally called by the
recommended routine DBCRSD.
 
  The routine DBOUT can be used in a stand-alone program to store data
from a single Zebra bank. The routine DBVOUT can be used to store data
from a FORTRAN array. For historical reasons, the definition of the key
vector transmitted as argument is slightly different from that in the
standard routine DBENTR; the validity period and the source identifier
have to be supplied explicitly by the user, so only the keys 6 and
following have to appear in the key vector. The user should not use the
routines DBOUT or DBVOUT when the number of keys exceeds 9.
 
  The routines DBIN and DBVIN can be used to retrieve data with given
time of validity or with given source identifier. No other selection on
user keys is supported and the data must belong to a single Zebra bank.
DBIN returns the bank address, whereas DBVIN fills up a user vector with
the contents of the bank. Another routine, DBKIN, permits to fetch an
object from disk to memory on the basis of its serial number, specified
in key 1.
 
  The routine DBSRTM allows retrieval of a data object inserted within
a certain time interval.
 
  The routine DBGET can be used to retrieve data for a range of start of
validity time. This range should be passed over through the values of
the keys 3 and 4.
 
  The routine DBGETS can be used to retrieve data with selection on a
range of serial number (stored as Key 1). This range should be passed
over through the values of the keys 1 and 2.
 
 4.6 Error handling.
 
  The DBL3 package uses the Zebra common block /QUEST/ IQUEST(100) for
communication with the user in transmiting error messages. On return
from any DBL3 routine, the user is supposed to check the value of
IQUEST(1). If this is zero, there is NO error. Otherwise, the setting of
a non-zero value has some specific meaning; the value can be set from
the user callable routine or from somewhere deeper in the DBL3 package.
An explicit message is printed out when the debug log level has been
set to 1 or a higher value, through a call to DBLOGL (the debug level
is set by default to 0 in DBINIT).
 
 4.7 Termination.
 
  The user should always close the data base files at the end of the
job, through a call to DBEND. This routine closes all the RZ files
opened during the session. A single file can be closed through the
routine DBENDF. The user should not make reference to any DBL3 routines
(other than DBINIT !) after the call to DBEND.
 
 
 
5. Other DBL3 facilities.
 
  In this section a few other user callable subroutines of general
interest are mentioned, as well as some additional facilities which
extend the functionality of the DBL3 package and make it more user
friendly.
 
 5.1 Print and trace-back.
 
  The user can print the contents of a directory with the routine
DBPRIN, only the keys with the option 'K' (keys), or both the data and
the keys with the option 'D' (data).
 
  The user can print the summary of data base usage through the routine
DBTBPR. The summary consists of the numbers of calls to DBUSE and actual
disk accesses, for each set of user key values.
 
  Information on the data objects used in a given program execution can
be obtained through the routine DBTBCR.
 
 5.2 Time related routines.
 
   Two sets of routines are available to pack/unpack the date and time
to/from one single word :
      DBPKTM/DBUPTM, upto minutes, and
      DBPKTS/DBUPTS, upto seconds.
  The maximum of the start validity and the minimum of the end validity
of all data base objects used in a given program execution can be
obtained through the routine DBVLDT.
 
  The insertion time of the last inserted object in a given directory
can be enquired through the routine DBLKEY, and the time when a
directory has been last modified, through the routine DBLMOD.
 
 5.3 Purging operations.
 
  With the automatic updating mode, deleting data objects from a given
directory is rather critical, because of the possibility of deleting a
master object and leaving alive its updated version(s). Therefore, any
direct call to RZ deletion routines should be avoided. The operation can
be taken care of by the routines DBPURK and DBPURG. The latter provides
a wide range of actions through a number of character options, while
DBPURK can be used to purge data objects with selection on user keys
like DBUSE.
 
  The user can delete a complete tree of directory starting from a given
node, using the routine DBDELT. In the situation where a normal
directory has been 'a posteriori' partitioned, through the use of
DBNTOP, the user should call DBDELT to delete the original directory.
 
  With the routine DBPRGD, it is possible to delete all but the last few
partitions, as specified by the user, from a partitioned directory.
 
  The user can delete all but a few directory trees from the data base
using the routine DBKEPT.
 
 
 5.4 Plotting facilities.
 
  A few routines are available for plotting various quantities, such as
the validity of data objects in a given directory (DBPLTI), the
evolution of some data elements as a function of the value of a given
key (DBPLOB) and the correlation between two data elements inside a
given directory (DBPLOV).
 
  Another routine, DBPLNT, permits to prepare an N-tuple by reading data
from one or several directories.
 
 5.5 Interactive facilities.
 
  Most of the DBL3 operations mentioned in this report, and some other
specific ones, can be controlled interactively. The interactive version
of DBL3 is based on the KUIP package [4] and therefore can be used on
any usual computer.
 
  Note that there are two modes for displaying data :
        - Vertical (V-mode), available on all terminals without
          restriction,
        - Horizontal (H-mode), which can be used only if the screen is
          large enough to display the keys.
 
  The following commands (listed in alphabetic order) are provided :
 
DBASCI  - loads objects from a pre-edited ASCII file
DBCRDR  - creates a new directory
DBDELT  - deletes a directory or a complete tree
DBDISP  - displays the keys of objects in a given directory
DBEALI  - enters an alias name for a directory
DBEDIT  - inserts or replaces data objects, creating the directory if
          needed
DBEFOR  - defines a maximum insertion time for all subsequent data
          retrievals
DBEHLP  - enters help information for a given directory
DBENAM  - enters mnemonics for the data elements of a given directory
DBENFL  - closes one data base file
DBEND   - closes all data base files
DBFZOP  - opens a journal file for a given RZ file
DBFZUP  - updates a data base from a journal file
DBHELP  - displays the directory tree for the user to pick a given
          directory, and displays the corresponding Help information
DBILDU  - initializes the list of directories to be updated from the
          journal file for a given top directory
DBINIT  - initializes a data base file
DBLOGL  - sets the log level of a data base file
DBNTOP  - transforms a normal directory into a partitioned directory
DBOPEN  - opens a FORTRAN direct access file
DBPEEK  - displays user keys and data in a given directory
DBPLNT  - prepares an N-tuple from data and keys from one or more
          directories
DBPLOB  - displays data element(s) as a function of a given key
DBPLOT  - displays the time evolution of a given data element (specified
          by its name) in a given directory(specified by its alias name)
DBPLOV  - displays the correlation of two data elements in a given
          directory
DBPLTI  - plots the validity period of data objects in a given directory
DBPRGD  - deletes the first few partitions inside a partitioned
          directory
DBPTIM  - packs the date and time in a single word, up to seconds
DBPURG  - purges data objects in a directory
DBRALI  - displays the full pathname of a directory with given alias
          name
DBREAD  - displays the directory tree for the user to pick a given
          directory, and displays the user keys and data in that
          directory
DBRENK  - renames one key element of an object in the given directory
DBRHLP  - displays the help information for a given directory
DBRNAM  - displays the mnemonics of the data elements for a given
          directory
DBSETD  - sets the horizontal display width
DBSHOW  - displays the data objects in a given directory
DBTREE  - displays the directory tree
DBUTIM  - unpacks the date and time (inverse of DBPTIM)
DBVIEW  - displays objects preselected according to validity time and
          conditions on user keys, possibly across different directories
          (similar to joining tables in ORACLE)
DBWRITE - inserts ASCII data objects, also creating the directory if
          needed
 
  In addition to these commands the user can also execute all standard
MZ-, FZ-, DZ- and RZ-commands.
 
  The KUIP commands can be kept in the form of macros, and aliases can
also be defined and used to execute them.
A special macro called DBLOGN.KUMAC can be executed to initialize a data
base file (DBINIT), to set the appropriate display range and, on VAX, to
choose the host editor.
 
  A command can be executed in any one of the following ways :
 - Command mode, by typing the command together with the parameters
 - Menu mode, by typing /STYLE AN (or AL), then the menu numbers (or
   letters)    up to the desired command is reached
 - Help usage, by typing HELP in the command line and following the
   instructions
 - Macro execution, by typing EXEC followed by the macro name (a macro
   can be edited without exiting from the interactive session by typing
   /MACRO/EDIT )
 
  At the end of an interactive session, the command QUIT will
automatically close all data base files, by invoking DBEND.
 
 
 
 
 
 
[1]  L3 Offline Software Group   L3 Report No 315
     A.Gurtu                     L3 Report No 370
     B.Adeva, E.Gonzales         L3 Report No 496
     L.Barone        A data base interface for BGO calibration, L3 Note,
                                                                June 86
[2]  (in preparation)
 
[3]  R.Brun, J.Zoll       ZEBRA user guide, CERN Program Library, Q 100
 
[4]  R.Brun, P.Zanarini   KUIP user guide, CERN Program Library, I 202
 
 
 
  Technical appendices
  --------------------
 
A. Pam structure :
   -------------
 
   The organization of the Patches inside the Pam file is based on the
classification of routines according to whether they can be called by
the user or not.
 
   The Patch DBL3 contains routines which can be called by the user.
There are routines
             to initialize a data base file (DBINIT);
             to terminate all the data base operations (DBEND);
             to create standard DBL3 directory (DBCRSD);
             to store data in the mass storage (DBENTR, DBREPL, DBABWR);
             to retrieve data from the data base (DBUSE, DBABRD);
             to print keys and data (DBPRIN);
             to purge data on the disk (DBPURG);
             to delete a complete directory tree (DBDELT);
             to liberate space in the memory (DBFREE);
             to pack/unpack date and time upto minute/second
                (DBPKTM,DBUPTM/DBPKTS,DPUPTS);
             to print the statistics of data base usage (DBTBPR);
             to set the debug level of the DBL3 package (DBLOGL).
 
   The Patch DATABASE contains a series of additional routines which
are only for internal use to the DBL3 package. The user is advised not
to use these routines, as the calling sequence, functionality, etc. of
these routines may change in future editions.
 
   The Patch DBPLOT contains routines for presenting quantities stored
in the data base to the user through the HPLOT package [3].
 
   The Patch DBXINT contains all the routines needed for the interactive
version of the DBL3 package. The interactive commands defined in the
INL3 Pam file for the menu DBL3 are interpreted by the KUIP package [4]
and the execution of the various actions is steered through the routines
DBACPL, DBACTI and DBAUXI.
 
   The Pam file also contains several examples of how to use the Package
(in Patches DBEXAM1 through DBEXAMB).
 
 
 
B.  Error codes :
    -----------
 
   The following table summarizes the meanings of the error codes
returned in IQUEST(1).
 
 
 +-----+------------------------------------------------+--------------+
 |Error|             Meaning                            | Routine Name |
 |Code |                                                |              |
 +-----+------------------------------------------------+--------------+
 |  -1 |Invalid top directory name                      |   DBINIT     |
 |     |                                                |              |
 |  -2 |The file is already open with correct LUNRZ and |   DBINIT     |
 |     |TOPNM                                           |              |
 |     |                                                |              |
 |  -3 |The file is already open with wrong LUNRZ or    |   DBINIT     |
 |     |TOPNM                                           |              |
 |     |                                                |              |
 |  -4 |Already a file is opened with the same unique   |   DBINIT     |
 |     |identifier as requested through IQUEST(1) for   |              |
 |     |this top name                                   |              |
 |     |                                                |              |
 |  -5 |Invalid process name in Online context          |   DBINIT     |
 |     |                                                |              |
 |  -6 |Error in IC_BOOK for booking the CACHE          |   DBINIT     |
 |     |                                                |              |
 |  -7 |Error in CC_SETUP for reserving the CLUSCOM     |   DBINIT     |
 |     |                                                |              |
 |  -8 |Error in opening journal file on Apollo in the  |   DBINIT     |
 |     |server mode                                     |              |
 +-----+------------------------------------------------+--------------+
 |   1 |Illegal character option                        |DBABRD/DBUSE  |
 |     |                                                |              |
 |   2 |Illegal path name                               |DBABRD/DBGET/ |
 |     |                                                |DBGETS/DBUSE  |
 |     |                                                |              |
 |   3 |Data base structure in memory clobbered         |   DBUSE      |
 |     |                                                |              |
 |   4 |Illegal key option                              |DBABRD/DBUSE  |
 |     |                                                |              |
 |   5 |Error in DBCHLD in P3 communication             |DBGET/DBUSE   |
 +-----+------------------------------------------------+--------------+
 |  11 |Pathname not found in the RZ directory          |   DBNODE     |
 |     |                                                |              |
 |  12 |Illegal pathname                                |   DBNODE     |
 |     |                                                |              |
 |  13 |Not enough structural link to support a new Node|   DBNODE     |
 |     |                                                |              |
 |  14 |No space available to create bank NODB          |   DBNODE     |
 |     |                                                |              |
 |  15 |Cannot define IO descriptor for Key bank        |   DBNODE     |
 |     |                                                |              |
 |  16 |Cannot find appropriate top directory           |   DBNODE     |
 +-----+------------------------------------------------+--------------+
 |  21 |Too many keys with option M                     |   DBKEYS     |
 |     |                                                |              |
 |  22 |Illegal key option                              |   DBKEYS     |
 |     |                                                |              |
 |  23 |Key bank cannot be created; no space in memory  | DBKEYS/DBKYSE|
 |     |                                                |              |
 |  24 |No Key bank created satisfying key options for  |   DBKEYS     |
 |     |option S                                        |              |
 |     |                                                |              |
 |  25 |Illegal Path Name                               |   DBKEYS     |
 +-----+------------------------------------------------+--------------+
 |  31 |Illegal path name or path name in node bank     |DBIN/DBKIN/   |
 |     |is wrong                                        |DBKVIN/DBSRTM/|
 |     |                                                |DBVIN/DBCHCK/ |
 |     |                                                |DBKXIN        |
 |     |                                                |              |
 |  32 |No keys/data in this directory                  |DBGET/DBGETS/ |
 |     |                                                |DBIN/DBKIN/   |
 |     |                                                |DBKVIN/DBSRTM/|
 |     |                                                |DBVIN/DBCHCK  |
 |     |                                                |              |
 |  33 |No valid data for the given range of insertion  |DBSRTM/DBKXIN |
 |     |time or for the given set of keys and program   |              |
 |     |version number                                  |              |
 |     |                                                |              |
 |  34 |RZIN fails to read the data                     |   DBRZIN     |
 |     |                                                |              |
 |  35 |Wrong reference to data objects in update mode  |   DBKXIN     |
 |     |                                                |              |
 |  36 |Data bank address zero on return from DBKXIN    |DBKVIN/DBUSE/ |
 |     |                                                |DBVIN/DBCHCK  |
 |     |                                                |              |
 |  37 |Insufficient space in USER store array          |DBKVIN/DBUSE/ |
 |     |                                                |DBVIN/DBCHCK  |
 +-----+------------------------------------------------+--------------+
 |  41 |CHFOR for DB system keys declared wrongly by    |DBMDIP/DBMDIR |
 |     |user                                            |              |
 |     |                                                |              |
 |  42 |CHTAG for DB system keys declared wrongly by    |DBMDIP/DBMDIR |
 |     |user                                            |              |
 |     |                                                |              |
 |  43 |Too many key elements                           |DBCRSD/DBMDIP/|
 |     |                                                |DBMDIR        |
 |     |                                                |              |
 |  44 |Cannot find the top directory name              |DBMDIP/DBMDIR |
 |     |(wrong initialization)                          |              |
 |     |                                                |              |
 |  45 |Illegal Path name                               |DBMDIP/DBMDIR |
 |     |                                                |              |
 |  46 |Top directory name in the Path name does not    |DBMDIP/DBMDIR |
 |     |match with the Top directory name               |              |
 |     |                                                |              |
 |  47 |The Directory already exists                    |   DBMDIR     |
 |     |                                                |              |
 |  48 |Error in directory search sequence              |DBMDIP/DBMDIR |
 |     |                                                |              |
 |  49 |FZOUT fails to write on the sequential file     |   DBSDIR     |
 +-----+------------------------------------------------+--------------+
 |  51 |Illegal character option                        |   DBFREE     |
 |     |                                                |              |
 |  52 |No access to the Key banks                      |   DBFREE     |
 |     |                                                |              |
 |  53 |Pathname not found in the RZ directory          |   DBFREE     |
 |     |                                                |              |
 |  54 |Pathname not matched to that found in bank NODB |   DBFREE     |
 |     |                                                |              |
 |  55 |Too many keys with option M                     |   DBFREE     |
 |     |                                                |              |
 |  56 |Illegal Key option                              |   DBFREE     |
 |     |                                                |              |
 |  57 |Illegal pathname                                |   DBFREE     |
 |     |                                                |              |
 |  58 |Database structure in memory clobbered          |   DBFREE     |
 |     |                                                |              |
 |  59 |Some of the expected key banks not found        |   DBFREE     |
 +-----+------------------------------------------------+--------------+
 |  61 |Too many keys                                   |DBABWR/DBENTB/|
 |     |                                                |DBENTR/DBREPL |
 |     |                                                |              |
 |  62 |Too many keys with option N                     |DBENTR/DBOUT/ |
 |     |                                                |DBREPL/DBVOUT |
 |     |                                                |              |
 |  63 |Data base structure in memory clobbered         |DBENTR/DBREPL |
 |     |                                                |              |
 |  64 |Error in MZCOPY while copying Data bank         |DBENTR/DBREPL |
 |     |                                                |              |
 |  65 |Illegal number of data objects                  |   DBENTB     |
 |     |                                                |              |
 |  66 |Illegal logical unit number                     |DBABWR/DBEHLP/|
 |     |                                                |DBRHLP        |
 |     |                                                |              |
 |  67 |File too long; no space in buffer               |DBABWR/DBEHLP |
 |     |                                                |              |
 |  68 |Input directory is partitioned                  |   DBNTOP     |
 |     |                                                |              |
 |  69 |Input directory is not partitioned              |   DBPRGD     |
 |     |                                                |              |
 |  70 |Error in deleting a partition through RZDELT    |   DBPRGD     |
 +-----+------------------------------------------------+--------------+
 |  71 |Illegal path name                               |DBENTB/DBNTOP/|
 |     |                                                |DBPRGD/DBRTFZ/|
 |     |                                                |DBKOUT        |
 |     |                                                |              |
 |  72 |Number of keys does not match with that         |DBENTB/DBKOUT |
 |     |specified in the directory                      |              |
 |     |                                                |              |
 |  73 |RZOUT fails to write on disk                    |DBENTB/DBNTOP/|
 |     |                                                |DBPRGD/DBKOUT |
 |     |                                                |              |
 |  74 |Error in RZRENK in updating key values for      |DBENTB/DBNTOP/|
 |     |partitioned data set                            |DBPRGD/DBKOUT |
 |     |                                                |              |
 |  75 |Cannot find the top directory name in pathname  |DBENTB/DBNTOP/|
 |     |                                                |DBPRGD/DBKOUT |
 |     |                                                |              |
 |  76 |Cannot form the IO descriptor for the FZ header |DBENTB/DBFZUP/|
 |     |                                                |DBNTOP/DBFZWR/|
 |     |                                                |DBKOUT        |
 |     |                                                |              |
 |  77 |FZOUT fails to write on the sequential journal  |DBENTB/DBNTOP/|
 |     |file                                            |DBPRGD/DBENFZ/|
 |     |                                                |DBKOUT        |
 |     |                                                |              |
 |  78 |Illegal number of keys on data base/journal file|DBENTB/DBFZUP/|
 |     |                                                |DBKOUT        |
 +-----+------------------------------------------------+--------------+
 |  81 |Precision is not correctly given                |   DBUCMP     |
 |     |                                                |              |
 |  82 |Illegal Data Type                               |   DBUCMZ     |
 |     |                                                |              |
 |  83 |Data update but uncompreseed                    |   DBUNCP     |
 |     |                                                |              |
 |  84 |The update structure has different number of    |   DBUNCP     |
 |     |data words                                      |              |
 |     |                                                |              |
 |  85 |No data in the structure                        |   DBUNCP     |
 |     |                                                |              |
 |  86 |The update structure has different data type    |   DBUNCP     |
 +-----+------------------------------------------------+--------------+
 |  91 |Illegal Character Option                        |   DBOPTS     |
 |     |                                                |              |
 |  92 |Nonstandard IO descriptor                       |   DBFRUS     |
 |     |                                                |              |
 |  98 |Invalid path name in Node bank                  |   DBTBPR     |
 |     |                                                |              |
 |  99 |No space in memory for creating the bank        |DBBOOK/DBRZIN |
 +-----+------------------------------------------------+--------------+
 | 100 |Error in decoding                               |DBCTOB/DBCTOI/|
 |     |                                                |DBCTOR        |
 |     |                                                |              |
 | 101 |Illegal path name                               |DBKTYP/DBPRIN/|
 |     |                                                |DBRKY1/DBAIRD/|
 |     |                                                |DBDISD/DBDISP/|
 |     |                                                |DBEDAS/DBJOIN/|
 |     |                                                |DBVWPR        |
 |     |                                                |              |
 | 102 |No key or data for the path name                |DBPRIN/DBJOIN/|
 |     |                                                |DBVWPR        |
 |     |                                                |              |
 | 103 |Illegal data type                               |DBPRKY/DBDKYH/|
 |     |                                                |DBDKYV        |
 |     |                                                |              |
 | 104 |Read error in getting the RZ date and time      |   DBPRDT     |
 +-----+------------------------------------------------+--------------+
 | 111 |Illegal path name                               |DBPURG/DBPURK |
 |     |                                                |              |
 | 112 |No key or data for the path name                |DBPURG/DBPURK |
 |     |                                                |              |
 | 113 |Illegal character option                        |   DBPURK     |
 |     |                                                |              |
 | 114 |Valid data object(s) in the Node/Key structure  |   DBPURK     |
 |     |                                                |              |
 | 115 |Cannot form the IO descriptor for the FZ header |   DBSPUR     |
 |     |                                                |              |
 | 116 |FZOUT fails to write on the sequential file     |   DBSPUR     |
 +-----+------------------------------------------------+--------------+
 | 121 |Store area in DBGETA is insufficient            |   DBGETA     |
 |     |                                                |              |
 | 122 |NADMX is too small for the data structure       |   DBGETA     |
 |     |                                                |              |
 | 123 |Illegal data type                               |   DBTSAD     |
 +-----+------------------------------------------------+--------------+
 | 131 |Illegal pathname (in key bank for DBLAST)       |DBLAST/DBLKEY/|
 |     |                                                |DBLMOD        |
 |     |                                                |              |
 | 132 |Illegal number of keys in the directory         |DBLAST/DBLKEY |
 +-----+------------------------------------------------+--------------+
 | 140 |Illegal top directory name                      |   DBFZOP     |
 |     |                                                |              |
 | 141 |Read error on the FZ file (journal file)        |DBFZUP/DBENFZ |
 |     |                                                |              |
 | 142 |Top directory name illegal in the FZ file       |   DBFZUP     |
 |     |                                                |              |
 | 143 |Illegal path name in the FZ file                |DBFZUP/DBENFZ |
 |     |                                                |              |
 | 144 |Error in RZ for saving the data object          |   DBENFZ     |
 |     |                                                |              |
 | 145 |Error in RZ for renaming the keys               |   DBENFZ     |
 +-----+------------------------------------------------+--------------+
 | 150 |Error in loading the top directory              |   DBUDIC     |
 |     |                                                |              |
 | 151 |Cannot find the top directory                   |   DBCDIC     |
 |     |                                                |              |
 | 152 |Illegal path name                               |   DBCDIC     |
 |     |                                                |              |
 | 153 |Illegal top directory name                      |   DBCDIC     |
 |     |                                                |              |
 | 154 |Dictionary directory cannot be loaded           |   DBCDIC     |
 |     |                                                |              |
 | 155 |Error in RZ while reading the dictionary        |DBCDIC/DBUDIC |
 |     |                                                |              |
 | 156 |Pathname already exists in the dictionary       |   DBCDIC     |
 |     |                                                |              |
 | 157 |Error in RZ in writing the dictionary object    |DBCDIC/DBUDIC |
 |     |                                                |              |
 | 158 |Error in RZ in purging the dictionary directory |DBCDIC/DBUDIC |
 |     |                                                |              |
 | 159 |Error in creating the DICTIONARY/HELP directory |   DBUDIC     |
 +-----+------------------------------------------------+--------------+
 | 161 |Illegal path name                               |DBFPAT/DBPLNT/|
 |     |                                                |DBPLOB/DBPLOV/|
 |     |                                                |DBPLTI        |
 |     |                                                |              |
 | 162 |No keys or data in the directory                |DBPLNT/DBPLOB/|
 |     |                                                |DBPLOV/DBPLTI |
 |     |                                                |              |
 | 163 |Illegal number of objects in the request        |DBPLNT/DBPLOB/|
 |     |                                                |DBPLOV        |
 |     |                                                |              |
 | 164 |Illegal number of path names                    |   DBPLNT     |
 |     |                                                |              |
 | 165 |Illegal object element indices                  |   DBPLNT     |
 |     |                                                |              |
 | 166 |Illegal key element indices                     |   DBPLNT     |
 +-----+------------------------------------------------+--------------+
 | 171 |Illegal Path name                               |   DBDELT     |
 |     |                                                |              |
 | 172 |Cannot find the top directory for the path name |   DBDELT     |
 |     |                                                |              |
 | 173 |Error in RZ for reading the dictionary object   |   DBDELT     |
 |     |                                                |              |
 | 174 |Error in FZOUT for saving the journal file      |   DBDELT     |
 |     |                                                |              |
 | 175 |Error in RZ in writing the dictionary object    |   DBDELT     |
 |     |                                                |              |
 | 176 |Error in RZ in purging the dictionary directory |   DBDELT     |
 |     |                                                |              |
 | 177 |Error in RZ in deleting the tree                |   DBDELT     |
 +-----+------------------------------------------------+--------------+
 | 181 |Error in sending spool file to the server       |DBEND/DBENDF/ |
 |     |                                                |DBSAVE        |
 |     |                                                |              |
 | 182 |Illegal path name                               |DBEALI/DBEHLP/|
 |     |                                                |DBENAM/DBRHLP/|
 |     |                                                |DBRNAM/DBGNAM |
 |     |                                                |              |
 | 183 |Illegal number of data words                    |   DBENAM     |
 |     |                                                |              |
 | 184 |Illegal flag (IFLAG)                            |   DBSNAM     |
 |     |                                                |              |
 | 185 |Illegal top directory name                      |DBEALI/DBSNAM |
 |     |                                                |              |
 | 186 |FZIN error for reading the data structure       |   DBSNAM     |
 |     |                                                |              |
 | 187 |FZOUT fails to write on the sequential file     |DBEALI/DBSNAM |
 |     |                                                |              |
 | 188 |Error in RZ for writing to the R.A. file        |DBEALI/DBSNAM |
 +-----+------------------------------------------------+--------------+
 | 191 |Illegal path name                               |   DBRENK     |
 |     |                                                |              |
 | 192 |Specified key elements do not match with any of |   DBRENK     |
 |     |the existing set of keys                        |              |
 |     |                                                |              |
 | 193 |Cannot find the top directory name in pathname  |   DBRENK     |
 |     |                                                |              |
 | 194 |Cannot form the IO descriptor for the FZ header |   DBRENK     |
 |     |                                                |              |
 | 195 |FZOUT fails to write on the sequential journal  |   DBRENK     |
 |     |file                                            |              |
 |     |                                                |              |
 | 196 |Error in RZRENK in updating key values          |   DBRENK     |
 |     |partitioned data set                            |              |
 +-----+------------------------------------------------+--------------+
 | 201 |DICTIONARY directory not found                  |DBEALI/DBRNAM/|
 |     |                                                |DBGNAM        |
 |     |                                                |              |
 | 202 |No description of data elements for the given   |DBRNAM/DBGNAM |
 |     |path name exists in the data base               |              |
 |     |                                                |              |
 | 203 |No HELP directory inside the data base          |   DBRHLP     |
 |     |                                                |              |
 | 204 |No help information for this path stored yet    |   DBRHLP     |
 |     |                                                |              |
 | 205 |Illegal alias name for a directory              |   DBRALI     |
 +-----+------------------------------------------------+--------------+
 | 211 |Illegal number of paths                         |   DBKEPT     |
 |     |                                                |              |
 | 212 |Illegal path name                               |   DBKEPT     |
 |     |                                                |              |
 | 213 |Conflicting top directory names                 |   DBKEPT     |
 +-----+------------------------------------------------+--------------+
 | 221 |Error in CC_WRITELOCK for locking CLUSCOM (VAX);|   DBWLOK     |
 |     |                                                |              |
 | 222 |Error in CC_RELEASE for releasing CLUSCOM (VAX) |   DBCWSV     |
 |     |                                                |              |
 | 223 |Error in IC_SIGNAL for signalling the VAX Server|   DBCWSV     |
 |     |                                                |              |
 | 225 |Error in sending spool file to the server (IBM  |   DBSTSV     |
 |     |or APOLLO)                                      |              |
 +-----+------------------------------------------------+--------------+
 | 231 |Illgeal Top directory name                      |   DBILDU     |
 |     |                                                |              |
 | 232 |Illegal logical unit number                     |DBILDF/DBILDU |
 +-----+------------------------------------------------+--------------+
 
Note :
 
If IQUEST(1) = 0 on return in subroutine DBUSE, IQUEST(2) carries
information whether data part has been actually read from the disk.
 
      IQUEST(2) =  0 : No disk i/o has been performed
                =  1 : Data have been refreshed from the disk
 
 
C.  Format for FZ output :
    --------------------
 
   DBL3 can create a journal file and can also update a data base from
the corresponding journal file. The journal file format is defined as an
FZ record consisting of a header and the data part. The format is
general enough and can also be used for the communication betwen the
server and a process which wants to update the data base.
 
   The data part of the FZ record is relevant only for data to be
entered. It is exactly the same data structure as input to DBENTR. For
efficiency reason, DBL3 for its own journal file stores the data
structure as input to the RZOUT call. This difference can be easily
recognised from the value of KEY(1), which is zero for outside source
and nonzero for DBL3's own journal file.
 
   The header part has very similar structure for the eight actions
foreseen so far, e.g., entering data, creating new directories, deleting
data objects, deleting a directory tree, renaming the keys, entering
names of data elements or help information for a directory, entering
alias name to a directory, deleting a few partitions in a partitioned
directory. However, they differ in details and the eight different types
of FZ headers are listed below.
 
   Header for entering data :
 
 +----------+----------+------+----------------------------------------+
 |Word Count| Mnemonic | Type |         Content                        |
 +----------+----------+------+----------------------------------------+
 |        1 |   IACT   |   I  | Action code (=1)                       |
 |        2 |  NWKEY   |   I  | Number of key elements                 |
 |        3 |  NWDOP   |   I  | Number of words used to store CHOPT    |
 |        4 |   NDOP   |   I  | Number of words used to to store the   |
 |          |          |      | path name                              |
 |        5 |  IPREC   |   I  | Precision chosen for packing           |
 |          |          |      | (see DBENTR)                           |
 |        6 |  KEY(1)  |   I  | Key element 1                          |
 |       .. |   ...    |  ..  |   ........                             |
 |  NWKEY+5 |KEY(NWKEY)|  ..  | Key element NWKEY                      |
 |  NWKEY+6 |  CHOPT   |   H  | Character option                       |
 |       .. |     ..   |   H  |                                        |
 |  NWKEY+6 |  PATHN   |   H  | Path name                              |
 |   +NWDOP |          |      |                                        |
 |       .. |     ..   |   H  |                                        |
 +----------+----------+------+----------------------------------------+
 
   Header for creating directories :
 
 +----------+----------+------+----------------------------------------+
 |Word Count| Mnemonic | Type |         Content                        |
 +----------+----------+------+----------------------------------------+
 |        1 |   IACT   |   I  | Action code (=2)                       |
 |        2 |  NWKEY   |   I  | Number of key elements                 |
 |        3 |  NWDOP   |   I  | Number of words used to store CHOPT    |
 |        4 |   NDOP   |   I  | Number of words used to to store the   |
 |          |          |      | path name                              |
 |        5 |   MXKP   |   I  | Maximum number of objects inside one   |
 |          |          |      | partition (see DBMDIP)                 |
 |        6 |  INSTM   |   I  | Insertion time packed up to minutes    |
 |          |          |      | (see DBPKTM)                           |
 |        7 |  NRECD   |   I  | Unused at this moment                  |
 |        8 |  CHOPT   |   H  | Character option ('P' for partitioned  |
 |       .. |   ...    |  ..  | directory)                             |
 |   NDOP+8 |  CHFOR   |   H  | Description of key element type. This  |
 |       .. |     ..   |  ..  | information is stored in NCFO = (NWKEY |
 |       .. |     ..   |  ..  | +3)/4 words                            |
 |   NDOP+8 |  CHTAG   |   H  | Tags for each key element. This info.  |
 |    +NCFO |     ..   |  ..  | is stored in NTAG = 2*NWKEY words.     |
 |NDOP+NCFO |  PATHN   |   H  | Path name                              |
 |  +NTAG+8 |          |      |                                        |
 |       .. |     ..   |   H  |                                        |
 +----------+----------+------+----------------------------------------+
 
   Header for deleting objects :
 
 +----------+----------+------+----------------------------------------+
 |Word Count| Mnemonic | Type |         Content                        |
 +----------+----------+------+----------------------------------------+
 |        1 |   IACT   |   I  | Action code (=3)                       |
 |        2 |  NWKEY   |   I  | Number of key elements                 |
 |        3 |  NWDOP   |   I  | Number of words used to store CHOPT    |
 |        4 |   NDOP   |   I  | Number of words used to to store the   |
 |          |          |      | path name                              |
 |        5 |  ITIME   |   I  | Argument ITIME in DBPURK or -1 for     |
 |          |          |      | DBPURG                                 |
 |        6 |  INSTM   |   I  | Deletion time packed up to minutes     |
 |          |          |      | (see DBPKTM)                           |
 |        7 |  KEY(1)  |   I  | Key element 1 for DBPURK or KYDAT for  |
 |          |          |      | DBPURG                                 |
 |        8 |  KEY(2)  |   I  | Key element 2 for DBPURK or KYTIM for  |
 |          |          |      | DBPURG                                 |
 |       .. |   ...    |  ..  |                                        |
 |  NWKEY+7 |  CHOPT   |   H  | Character option                       |
 |       .. |   ...    |  ..  |                                        |
 |  NWKEY+7 |  PATHN   |   H  | Path name                              |
 |   +NWDOP |          |      |                                        |
 |       .. |     ..   |   H  |                                        |
 +----------+----------+------+----------------------------------------+
 
   Header for deleting directories :
 
 +----------+----------+------+----------------------------------------+
 |Word Count| Mnemonic | Type |         Content                        |
 +----------+----------+------+----------------------------------------+
 |        1 |   IACT   |   I  | Action code (=4)                       |
 |        2 |    ---   |   I  | Unused (set to 0)                      |
 |        3 |  NWDOP   |   I  | Number of words used to store CHOPT    |
 |        4 |   NDOP   |   I  | Number of words used to to store the   |
 |          |          |      | path name                              |
 |        5 |    ---   |   I  | Unused (set to 0)                      |
 |        6 |  INSTM   |   I  | Deletion time packed up to minutes     |
 |          |          |      | (see DBPKTM)                           |
 |        7 |  CHOPT   |   H  | Character option                       |
 |  NWDOP+7 |  PATHN   |   H  | Path name                              |
 |       .. |     ..   |   H  |                                        |
 +----------+----------+------+----------------------------------------+
 
   Header for renaming keys :
 
 +----------+----------+------+----------------------------------------+
 |Word Count| Mnemonic | Type |         Content                        |
 +----------+----------+------+----------------------------------------+
 |        1 |   IACT   |   I  | Action code (=5)                       |
 |        2 |  NWKEY   |   I  | Number of key elements                 |
 |        3 |  NWDOP   |   I  | Number of words for CHOPT (= 0)        |
 |        4 |   NDOP   |   I  | Number of words used to to store the   |
 |          |          |      | path name                              |
 |        5 |  Unused  |   I  | Set to zero                            |
 |        6 |  KYO(1)  |   I  | Old key element 1                      |
 |       .. |   ...    |  ..  |   ........                             |
 |  NWKEY+5 |KYO(NWKEY)|  ..  | Old key element NWKEY                  |
 |  NWKEY+6 |  KYN(1)  |   I  | New key element 1                      |
 |       .. |     ..   |  ..  |   ........                             |
 |2*NWKEY+5 |KYO(NWKEY)|  ..  | New key element NWKEY                  |
 |2*NWKEY+6 |  PATHN   |   H  | Path name                              |
 |       .. |     ..   |   H  |                                        |
 +----------+----------+------+----------------------------------------+
 
   Header for entering names or help information :
 
 +----------+----------+------+----------------------------------------+
 |Word Count| Mnemonic | Type |         Content                        |
 +----------+----------+------+----------------------------------------+
 |        1 |   IACT   |   I  | Action code (=6)                       |
 |        2 |  NWKEY   |   I  | Number of key elements                 |
 |        3 |  NWDOP   |   I  | Number of words used to store CHOPT(=0)|
 |        4 |   NDOP   |   I  | Number of words used to to store the   |
 |          |          |      | path name (DICTIONARY or HELP)         |
 |        5 |  IFLAG   |   I  | Flag (1 for help information; 2 for    |
 |          |          |      | names of the data elements)            |
 |        6 |  PATHN   |   H  | Path name (DICTIONARY or HELP)         |
 |       .. |     ..   |   H  |                                        |
 +----------+----------+------+----------------------------------------+
 
   Header for entering the alias name :
 
 +----------+----------+------+----------------------------------------+
 |Word Count| Mnemonic | Type |         Content                        |
 +----------+----------+------+----------------------------------------+
 |        1 |   IACT   |   I  | Action code (=7)                       |
 |        2 |    ---   |   I  | Unused (set to 0)                      |
 |        3 |  NWDOP   |   I  | Number of words used to store CHOPT(=0)|
 |        4 |   NDOP   |   I  | Number of words used to to store the   |
 |          |          |      | path name of the dictitionary          |
 |        5 |  IFLAG   |   I  | Flag (0 means temporary; 1 permanent)  |
 |        6 |   NWDP   |   I  | Number of words used to store the      |
 |          |          |      | path name                              |
 |        7 |  PATHD   |   H  | Path name of the dictionary            |
 |       .. |     ..   |   H  |                                        |
 |   NDOP+7 |  ALIAS   |   H  | Alias name                             |
 |       .. |     ..   |   H  |                                        |
 |   NDOP+9 |  PATHN   |   H  | Path name of the directory             |
 |       .. |     ..   |   H  |                                        |
 +----------+----------+------+----------------------------------------+
 
   Header for deleting a few partitions in a partitioned directory :
 
 +----------+----------+------+----------------------------------------+
 |Word Count| Mnemonic | Type |         Content                        |
 +----------+----------+------+----------------------------------------+
 |        1 |   IACT   |   I  | Action code (=8)                       |
 |        2 |    ---   |   I  | Unused (set to 0)                      |
 |        3 |  NWDOP   |   I  | Number of words used to store CHOPT    |
 |        4 |   NDOP   |   I  | Number of words used to to store the   |
 |          |          |      | path name                              |
 |        5 |  INSTM   |   I  | Deletion time packed up to minutes     |
 |          |          |      | (see DBPKTM)                           |
 |        6 |  NKEEP   |   I  | Number of partitions to be kept        |
 |        7 |  CHOPT   |   H  | Character option                       |
 |  NWDOP+7 |  PATHN   |   H  | Path name of the directory             |
 |       .. |     ..   |   H  |                                        |
 +----------+----------+------+----------------------------------------+
 
 
D.  Bank Description :
    ----------------
 
            (3)   +-------\
        +---------|  FZDB  >   List of directories to be updated
        |         +-------/
        |
  +--------\      +--------\
  |  UPDB   >-----|  UPDB   >  Support for all top directories opened
  +--------/      +--------/
    |   |
    |   |   (2)   +--------\
    |   +---------|  DICT   >  Dictionary information
    |             +--------/
    |
    |       (1)   +--------\
    +-------------|  NODB   >  Node bank for the top directory
                  +--------/
                   |..|..||
                      |
                      |
                  +--------\
                  |  NODB   >
                  +--------/
                   |....|||
                        |      Node bank of subdirectory for which data
                  +--------\   +--------\   +--------\   is retrieved
                  |  NODB   >--|  KYDB   >--|  KYDB   >
                  +--------/   +--------/   +--------/   Key banks
                                   | (1)        | (1)
                               +--------+   +--------+
                               |  DATA  |   |  DATA  |
                               +--------+   +--------+
 
 
 
========================================================================
|Bank:  UPDB                                            Top level bank |
|NL_/NS_ =  2/2                                          IO_ = '8I -H' |
|NW_     =  12                                                         |
+----------------------------------------------------------------------+
|LINKS:                                                                |
|link   type   bank                                        offset      |
|----   ----   ----                                        ------      |
| -3     Ref   FZDB                                        KLFZDB ( 3) |
| -2     Str   DICT                                        KLDICT ( 2) |
| -1     Str   NODB                                                    |
|  0     nxt   UPDB of the next data base file                         |
+----------------------------------------------------------------------+
|DATA WORDS:                                                           |
|word  type  contents                                      offset      |
|----  ----  --------                                      ------      |
|   1    I   Logical unit number of RZ file                MUPLUN ( 1) |
|   2    I   Flag if database to be updated (0 if not)     MUPFLG ( 2) |
|   3    I   Logical unit number of standard journal file  MUPJFL ( 3) |
|   4    I   Logical unit number of special backup file    MUPBAK ( 4) |
|   5    I   Identifier of the top directrory              MUPDIC ( 5) |
|   6    I   Number of characters in the top directory     MUPNCH ( 6) |
|            name                                                      |
|   7    I   Shared/server flag (IOPS*10 + IOPP)           MUPSRV ( 7) |
|            (IOPS = 1 if S option in DBINIT;                          |
|             IOPP = 1 if P option in DBINIT)                          |
|   8    I   Maximum insertion time for subsequent         MUPKY7 ( 8) |
|            object retrieval                                          |
|9-12    H   Name of the top directory                     MUPNAM ( 9) |
+----------------------------------------------------------------------+
 
 
========================================================================
|Bank:  DICT                                           Dictionary bank |
|NL_/NS_ =  0/0                                     IO_ = '1I /3I 22H' |
|NW_     =  1 + 25*n                                                   |
+----------------------------------------------------------------------+
|DATA WORDS:                                                           |
|word  type  contents                                      offset      |
|----  ----  --------                                      ------      |
|   1    I   Number of nodes in the dictionary             MDCNTM ( 1) |
|      For each node (Node number n)                                   |
|IOFF+      (= (n-1)*NWITDB + 1)  (NWITDB = 25)                        |
|   1    I   Unique identifier of the node                 MDCITM ( 1) |
|   2    I   Number of characters for describing the path  MDCNCH ( 2) |
|            to the node                                               |
|   3    I   Last update to the node (not avaialable yet)  MDCLUP ( 3) |
| 4-5    H   Alias name                                    MDCALI ( 4) |
|6-25    H   Name of the path to the node (excluding the   MDCNAM ( 6) |
|            top directory part)                                       |
+----------------------------------------------------------------------+
 
 
========================================================================
|Bank:  NODB                                                 Node bank |
|NL_/NS_ =  NS_/(number of down nodes)               IO_ = '4I 16B -H' |
|NW_     =  20 + words needed for path name                            |
+----------------------------------------------------------------------+
|LINKS:                                                                |
|link   type   bank                                        offset      |
|----   ----   ----                                        ------      |
| -n     Str   NODB (next level node)                                  |
|  0     nxt   KYDB of the first key bank to the node      KLDYDB ( 0) |
+----------------------------------------------------------------------+
|DATA WORDS:                                                           |
|word  type  contents                                      offset      |
|----  ----  --------                                      ------      |
|   1    I   Number of key elements for this node          MNDNWK ( 1) |
|   2    I   Total number of data words in the Key bank    MNDNWD ( 2) |
|   3    I   Number of characters describing the path to   MNDNCH ( 3) |
|            the node                                                  |
|   4    I   Unique identifier of this node                MNDDIC ( 4) |
|5-20    B   IO descriptor of the Key bank                 MNDIOF ( 5) |
|21-..   H   Name of the path to the node                  MNDNAM (21) |
+----------------------------------------------------------------------+
 
 
========================================================================
|Bank:  KYDB                                                  Key bank |
|NL_/NS_ =  3/1                                          IO_ = Dynamic |
|NW_     =  NWKEY + NWFXM(=6)                                          |
+----------------------------------------------------------------------+
|LINKS:                                                                |
|link   type   bank                                        offset      |
|----   ----   ----                                        ------      |
| -2     Ref   UPDB (Top level bank)                       KLUPDB ( 3) |
| -2     Ref   NODB (parent node bank)                     KLNODB ( 2) |
| -1     Str   Data bank                                   KLDADB ( 1) |
|  0     nxt   KYDB of the next key bank                               |
+----------------------------------------------------------------------+
|DATA WORDS:                                                           |
|word  type  contents                                      offset      |
|----  ----  --------                                      ------      |
|   1    I   Serial number of the object                               |
|   2    I   Refernce to the master object (for update)                |
|   3    I   Start validity time (upto seconds)                        |
|   4    I   End   validity time (upto seconds)                        |
|   5    I   Source identifier                                         |
|   6    I   Flag for storing the object (internal to DBL3)            |
|             Bit JRZUDB (=1) : Full RZ option                         |
|                 JIGNDB (=2) : Ignore the object                      |
|                 JPRTDB (=3) : Directory is partitioned               |
|                 JASFDB (=4) : Specially encoded ASCII                |
|   7    I   Insertion time (upto minutes)                             |
|8-NWKEY     User keys                                                 |
|NWKEY+1 I   Logical end validity time (upto seconds)                  |
|NWKYDB+                                                               |
|  -4    I   Number of physical reads to disk for this key MKYRID (-4) |
|  -3    I   Number of calls to DBUSE in the same event    MKYCEV (-3) |
|  -2    I   Number of calls to DBUSE in the entire run    MKYCRU (-2) |
|  -1    I   Precision used for storing the object         MKYPRE (-1) |
|   0    I   Free flag (set by DBFREE call)                MKYFRI ( 0) |
+----------------------------------------------------------------------+
 
 
========================================================================
|Bank:  FZDB                         List of directories to be updated |
|NL_/NS_ =  0/0                                    IO_ = '4H / 1I 20H' |
|NW_     =  4 + 21*n                                                   |
+----------------------------------------------------------------------+
|LINKS:                                                                |
|link   type   bank                                        offset      |
|----   ----   ----                                        ------      |
|  0     nxt   FZDB of the next data base file                         |
+----------------------------------------------------------------------+
|DATA WORDS:                                                           |
|word  type  contents                                      offset      |
|----  ----  --------                                      ------      |
| 1-4    H   Top directory name                            MFZTOP ( 1) |
|      For each directory (number n)                                   |
|IOFF+      (= (n-1)*(MXLWDB+1) + MFZDIR)  (MXLWDB = 20; MFZDIR = 5)   |
|  1     I   Number of characters in the path                          |
|2-21    H   Complete pathname of the directory or the root            |
+----------------------------------------------------------------------+
 
 
========================================================================
|Bank:  FDDB             List of directories to be forced for updating |
|NL_/NS_ =  0/0                                       IO_ = '/ 1I 20H' |
|NW_     =  21*n                                                       |
+----------------------------------------------------------------------+
|DATA WORDS:                                                           |
|word  type  contents                                      offset      |
|----  ----  --------                                      ------      |
|      For each directory (number n)                                   |
|IOFF+      (= (n-1)*(MXLWDB+1) + 1)  (MXLWDB = 20)                    |
|  1     I   Number of characters in the path                          |
|2-21    H   Complete pathname of the directory                        |
+----------------------------------------------------------------------+
 
+PATCH, *DBLIB.
+DECK, *DBLIB.
+USE, $DEBUG.
+USE, DBCDES.
+USE, DBL3.
+USE, DATABASE.
+USE, UNIX, IF=HPUX,IBMRT,MIP.
+USE, $SERVER,  IF=$P3CHILD.
+USE, DBONLINE, IF=$SERVER, IF=VAX, IF=-$P3CHILD.
+USE, DBOFFLIN, IF=$SERVER, IF=APOLLO,HPUX,IBM,IBMRT, IF=-$P3CHILD.
+USE, DBP3.
+USE, DBPLOT.
+USE, DBXINT, IF=-$P3CHILD.
+PATCH, *DBINT.
+DECK, *DBINT.
+USE, $DBL3.
+USE, $PAW.
+USE, $DEBUG.
+USE, $HIGZ.
+USE, $CDF.
+USE, UNIX, IF=HPUX,IBMRT,MIP.
+USE, UTCDES.                                (from Pam UTL3)
+USE, DBCDES.                                (from this Pam)
+USE, DBMAIN, T=EXE.                         (from this Pam)
+USE, INCDES.                                (from Pam INL3)
+USE, INZEBRA, INDBL3, INPAW.                (from Pam INL3)
+USE, INZECDF, INDBCDF, INPACDF.             (from Pam INL3)
+PATCH, DBCDES.
+DECK, DBCDES.
+KEEP, L3CORES.
      PARAMETER       (L3CORQ=200000, L3CORH=200000, L3CORK=70000)
*
+KEEP, DAOPTI.
      COMMON /DAOPTI/ CALFDA(62), CSTRDA
      CHARACTER       CALFDA*1, CSTRDA*132
      COMMON /DAOPT1/ MPAKDA(2)
      INTEGER         MPAKDA
*
+KEEP, DAOPTS.
      PARAMETER       (MXKYDA=100)
      COMMON /DAOPTS/ IOPADA, IOPBDA, IOPCDA, IOPDDA, IOPEDA, IOPFDA
     +              , IOPGDA, IOPHDA, IOPIDA, IOPJDA, IOPKDA, IOPLDA
     +              , IOPMDA, IOPNDA, IOPODA, IOPPDA, IOPQDA, IOPRDA
     +              , IOPSDA, IOPTDA, IOPUDA, IOPVDA, IOPWDA, IOPXDA
     +              , IOPYDA, IOPZDA, IOKYDA(MXKYDA)
*
+KEEP, DBLUFM, IF=IBMRT, HPUX.
      PARAMETER       (LUFMDB=87)
+KEEP, DBLUFM, IF=-IBMRT, IF=-HPUX.
      PARAMETER       (LUFMDB=999)
+KEEP, DBSRVR.
      COMMON /DBSRVR/ CACHDB, FILEDB, DIREDB
      CHARACTER       CACHDB*11, FILEDB*28, DIREDB*12
*
+KEEP, DBSRVRN.
      COMMON /DB_SRVR/DBFZUP_PATHN, DBFZUP_PATHN_L, DBFZUP_IACT
      CHARACTER*80    DBFZUP_PATHN
      INTEGER*4       DBFZUP_PATHN_L
      INTEGER*4       DBFZUP_IACT
*
+KEEP, DBUSER.
      COMMON /DBUSER/ IDEBDB, IDISDB, IDIVDB, IHKYDB, IKDRDB, IONODB
     +              , KOFSDB, KOFUDB, LBADDB, LBAFDB, LBDADB, LBFXDB
     +              , LBFYDB, LBKYDB, LBNODB, LFIXDB, LREFDB(7)
     +              , LSAVDB, LTOPDB, LPRTDB, NTOPDB
      PARAMETER       (NDMXDB=25000)
*
+KEEP, DBSTOR.
      COMMON /GCBANK/ FENCDB(22), LQ(9)
      DIMENSION       IQ(2), Q(2)
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))
*
      COMMON /QUEST/  IQUEST(100)
*
      PARAMETER       (IKTYDB=33, KNSDDB=23, KLSDDB=26, NWNODB=16)
      PARAMETER       (NWITDB=25, NPUSDB=50, MAXLDB=80)
      PARAMETER       (JRZUDB=1, JIGNDB=2, JPRTDB=3, JASFDB=4)
      PARAMETER       (KLKYDB=0, KLDADB=1, KLNODB=2, KLUPDB=3, KLDICT=2)
      PARAMETER       (KLFZDB=3, MFZTOP=1, MFZDIR=5, MXLWDB=20)
      PARAMETER       (MUPLUN=1, MUPFLG=2, MUPJFL=3, MUPBAK=4, MUPDIC=5)
      PARAMETER       (MUPNCH=6, MUPSRV=7, MUPKY7=8, MUPNAM=9)
      PARAMETER       (MNDNWK=1, MNDNWD=2, MNDNCH=3, MNDDIC=4)
      PARAMETER       (MNDIOF=5, MNDNAM=NWNODB+5, NLKYDB=3, NSKYDB=1)
      PARAMETER       (MKYRID=-4, MKYCEV=-3, MKYCRU=-2, MKYPRE=-1)
      PARAMETER       (MKYFRI=0, NLUPDB=3, NSUPDB=2, NDUPDB=MUPNAM+3)
      PARAMETER       (MDCNTM=1, MDCITM=1, MDCNCH=2, MDCLUP=3)
      PARAMETER       (MDCALI=4, MDCNAM=6)
      PARAMETER       (NARGDB=20)
+CDE, DBLUFM.
      PARAMETER       (MSERDB=1, MUPNDB=2, MBVRDB=3, MEVRDB=4, MPVSDB=5,
     +                 MFLGDB=6, MITMDB=7)
      PARAMETER       (MPSRDB=1, MXKPDB=2, MOBJDB=5)
      PARAMETER       (MHFMDB=3, MLEVDB=3, MNAMDB=7, MNCHDB=5, MNDWDB=4)
      PARAMETER       (MNFNDB=3, MNLVDB=2, MNNUDB=2, MNODDB=4, MPNNDB=2)
      PARAMETER       (MPNLDB=1, MPPLDB=8, MXOFDB=5, MXWDDB=6, MYFLDB=7)
      PARAMETER       (MYFNDB=6)
      COMMON /DBSTOR/ LCDRDB, LJNKDB, IBIGDB, INSRDB, IODIDB, IOFDDB
     +              , IOFZDB, IOVRDB, KY4MDB, KY7MDB, IOKYDB(NWNODB)
     +              , IARGDB(NARGDB)
+CDE, DBUSER.
+KEEP, DCONCT.
      COMMON /DCONCT/ ISYSDC(100), IUSEDC(100)
*
+KEEP, DDISPL.
      COMMON /DDISPL/ IOPHDD, IOTYDD(100), MXDPDD, NUMCDD(100)
      COMMON /DDCFMT/ CFMTDD
      CHARACTER       CFMTDD*20
*
+KEEP, DFZLUN.
      PARAMETER       (MACTDF=1, MNKYDF=2, MOPTDF=3, MPATDF=4, MPREDF=5)
      PARAMETER       (MXKPDF=5, MTIMDF=5, MFLGDF=5, MDELDF=5)
      PARAMETER       (MINSDF=6, MWDPDF=6, MKEPDF=6, MRECDF=7)
      PARAMETER       (NHEADF=300, NWFMDF=16)
      COMMON /DFZLUN/ IHEADF(NHEADF), IOFMDF(NWFMDF), LUFZDF, NUFZDF
     +              , NWHEDF
*
+KEEP, DINITL.
      COMMON /DINITL/ TOPLDI, TOPNDI
      CHARACTER       TOPNDI*16, TOPLDI*16
*
+KEEP, DKKEYS.
      PARAMETER       (MXDMDK=90, MXKYDK=10000, NINEDK=9, NSYSDK=7)
      PARAMETER       (MXKPDK=1000)
*
      COMMON /DKKEYS/ ICONDK(MXDMDK), INDKDK(MXKYDK), IOTYDK(MXDMDK)
     +              , IPURDK(MXKYDK), KEY1DK(MXKYDK), KEYNDK(MXDMDK)
     +              , KEYVDK(MXDMDK), KEY7DK, NKEYDK, NSKPDK, NWKYDK
      DIMENSION       RKY1DK(MXKYDK)
      EQUIVALENCE     (KEY1DK(1), RKY1DK(1))
*
      COMMON /DKTAGS/ CHTGDK(NINEDK), CTAGDK(MXDMDK), CHFTDK
      CHARACTER       CHFTDK*9, CHTGDK*8, CTAGDK*8
*
+KEEP, DLINKS.
      COMMON /DLINKS/ LSTRDL(5), LAUXDL(10), LREFDL(10)
*
+KEEP, DMULOP.
      PARAMETER       (NMLMDM=10)
      COMMON /DMULOP/ INDXDM(NMLMDM), KEYVDM(NMLMDM), KTYPDM(NMLMDM)
     +              , LFKYDM(NMLMDM), NOCCDM(NMLMDM)
*
+KEEP, DPLOTS.
      PARAMETER       (NOBMDP=50, NPLMDP=500, NPMXDP=10)
      PARAMETER       (NMAXDP=2*NOBMDP)
      COMMON /DPLOTS/ IBINDP(8), INDXDP(2,NOBMDP), KOBJDP(NMAXDP)
     +              , NKSMDP(NPMXDP), NKSTDP(NPMXDP), NDSMDP(NPMXDP)
     +              , NDSTDP(NPMXDP), IBEGDP(NPMXDP), NDEMDP(NPMXDP)
     +              , IOTYDP(NMAXDP), NSKYDP(NPMXDP), NKEYDP(22,NPMXDP)
     +              , KKEYDP(22,NPMXDP), VMAXDP, VMINDP
      COMMON /DPLOCH/ CHRPDP, CTTLDP, DYENDP, DYSTDP
      CHARACTER       CHRPDP*119, CTTLDP*73, DYENDP*9, DYSTDP*9
*
+KEEP, DRCCOM.
      PARAMETER       (NMAXDR=20000)
      COMMON /DRCCOM/ IFRSDR, IWORDR(4), QVECDR(NMAXDR), ILSTDR(128)
      DIMENSION       IQVCDR(NMAXDR)
      EQUIVALENCE     (QVECDR, IQVCDR)
CDEC$ PSECT /DRCCOM/ ALIGN=9
*
+KEEP, DSAVBK.
      PARAMETER       (NSVMDS=50, NSAVDS=20, MXDMDS=100)
      COMMON /DSAVBK/ NOBJDS, LOBJDS(NSVMDS), KEYSDS(MXDMDS,NSVMDS)
*
+KEEP, DTKXIN.
      COMMON /DTKXIN/ ICURDT, IDNRDT, IKYLDT, IMINDT, INRSDT, IPRVDT
     +              , IUSEDT, KEY6DT, KY6NDT, MNKYDT, NTIMDT
*
+KEEP, DTMPAK.
      PARAMETER       (MXSEC=61, MXMIN=61, MXHOU=25, MXDAY=32, MXMON=13)
      INTEGER         IDAYY(20), IDAYM(12,2)
      SAVE            IDAYY, IDAYM
      DATA            IDAYY / 366,  731, 1096, 1461, 1827, 2192, 2557,
     1                       2922, 3288, 3653, 4018, 4383, 4749, 5114,
     2                       5479, 5844, 6210, 6575, 6940, 7305/
      DATA            IDAYM / 0,  31,  59,  90, 120, 151, 181, 212, 243,
     1                      273, 304, 334,   0,  31,  60,  91, 121, 152,
     2                      182, 213, 244, 274, 305, 335/
*
+KEEP, DVIEWS.
      COMMON /DVIEWS/ IFKYDV(100), JFKYDV(100), IOTYDV(100), KEYSDV(100)
*
+KEEP, DXLINK.
      PARAMETER       (MAXJDX=20, MAXVDX= 20, LUKYDX=88, LUDADX=89)
      COMMON /DXLINK/ ISTODX, L3PRDX, LURZDX, LFRSDX, LJOIDX,
     +                LKJNDX(MAXJDX), LDJNDX(MAXJDX), LVIWDX,
     +                LKVWDX(MAXVDX), LDVWDX(MAXVDX),
     +                LASTDX
*
+KEEP, DZPACK.
      COMMON /DZPACK/ PRECDZ, PACKDZ
      LOGICAL         PACKDZ
*
+KEEP, P3DBL3.
      COMMON /P3DBL3/ IDDBP3, NWDBP3, IWDBP3(32), LIDBP3, LODBP3, IQDBP3
     +              , IXDBP3, IPASP3, NDIRP3, NBKDP3, NBKYP3, INDXP3
     +              , LNK1P3, LNK2P3, LNK3P3, LNK4P3, LNK5P3, LNK6P3
     +              , LNK7P3, LNK8P3, LNK9P3
*
      COMMON /P3DBC3/ RNDBP3  , MSDBP3
      CHARACTER       RNDBP3*8, MSDBP3*80
*
+KEEP, L3BITS, IF=APOLLO.
      IBITS (I,N,L)      = RSHFT (LSHFT(I,32-N-L), 32-L)
*
      JBIT (IZW,IZP)     = AND (RSHFT(IZW,IZP-1), 1)
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)
*
      MSBIT0 (IZW,IZP)   = AND (IZW, NOT(LSHFT(1,IZP-1)) )
      MSBIT1 (IZW,IZP)   = OR  (IZW,     LSHFT(1,IZP-1)  )
      MSBYT (MZ,IZW,IZP,NZB) = OR ( AND (IZW, NOT(
     +                   LSHFT (RSHFT(NOT(INT4(0)),32-NZB), IZP-1)))
     +                     , RSHFT (LSHFT(MZ,32-NZB), 33-IZP-NZB) )
+KEEP, L3BITX, IF=APOLLO.
+SEQ, L3BITS.
      MSBIT (MZ,IZW,IZP) = OR (AND (IZW, NOT(LSHFT(1,IZP-1)) )
     +                             , LSHFT(AND(MZ,1),IZP-1) )
*
      MCBYT (MZ,IZQ,IZW,IZP,NZB) = OR ( AND (IZW, NOT(
     +                   LSHFT (RSHFT(NOT(INT4(0)),32-NZB), IZP-1)))
     +        , RSHFT (LSHFT(RSHFT(MZ,IZQ-1),32-NZB), 33-IZP-NZB) )
*
      JBYTET (MZ,IZW,IZP,NZB) = AND (MZ,
     +                        RSHFT (LSHFT(IZW,33-IZP-NZB), 32-NZB) )
      JBYTOR (MZ,IZW,IZP,NZB) = OR  (MZ,
     +                        RSHFT (LSHFT(IZW,33-IZP-NZB), 32-NZB) )
      MBYTET (MZ,IZW,IZP,NZB) = AND (IZW, NOT(RSHFT (
     +                          LSHFT(NOT(MZ),32-NZB), 33-IZP-NZB)) )
      MBYTOR (MZ,IZW,IZP,NZB) = OR (IZW, RSHFT (
     +                               LSHFT(MZ,32-NZB), 33-IZP-NZB) )
+KEEP, L3BITS, IF=CRAY.
      JBIT (IZW,IZP)     = SHIFTR(IZW,IZP-1) .AND. MASK(127)
      JBYT (IZW,IZP,NZB) = SHIFTR(IZW,IZP-1) .AND. MASK(128-NZB)
*
      MSBIT0 (IZW,IZP)       =  IZW .AND. SHIFT(MASK(65),IZP)
      MSBIT1 (IZW,IZP)       =  IZW .OR.  SHIFT(MASK(1), IZP)
      MSBYT (MZ,IZW,IZP,NZB) = (IZW .AND. SHIFT(MASK(64-NZB),IZP-1))
     +                       .OR. SHIFT(MZ.AND.MASK(128-NZB),IZP-1)
+KEEP, L3BITX, IF=CRAY.
+SEQ, L3BITS.
      MSBIT (MZ,IZW,IZP)     = (IZW .AND. SHIFT(MASK(65),IZP))
     +                     .OR. SHIFT(MZ.AND.MASK(127),IZP-1)
*
      MCBYT (MZ,IZQ,IZW,IZP,NZB)=(IZW.AND.SHIFT(MASK(64-NZB),IZP-1))
     +         .OR. SHIFT(SHIFTR(MZ,IZQ-1).AND.MASK(128-NZB),IZP-1)
*
      JBYTET (MZ,IZW,IZP,NZB) = MZ .AND. SHIFTR(IZW,IZP-1)
     +                             .AND. MASK(128-NZB)
      JBYTOR (MZ,IZW,IZP,NZB) = MZ .OR. (SHIFTR(IZW,IZP-1)
     +                             .AND. MASK(128-NZB) )
      MBYTET (MZ,IZW,IZP,NZB) = IZW .AND.
     +                             SHIFT (MZ.OR. MASK(64-NZB), IZP-1)
      MBYTOR (MZ,IZW,IZP,NZB) = IZW .OR.
     +                             SHIFT (MZ.AND.MASK(128-NZB),IZP-1)
+KEEP, L3BITS, IF=HPUX.
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)
+KEEP, L3BITS, IF=IBM, IBMRT, VAX.
      IBITS (I,N,L)      = ISHFT(ISHFT(I,32-L-N),L-32)
*
      JBIT (IZW,IZP)     = IBITS (IZW,IZP-1,1)
      JBYT (IZW,IZP,NZB) = IBITS (IZW,IZP-1,NZB)
*
      MSBIT0 (IZW,IZP)   = IAND (IZW, NOT(ISHFT(1,IZP-1)) )
      MSBIT1 (IZW,IZP)   = IOR  (IZW,     ISHFT(1,IZP-1)  )
      MSBYT (MZ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1)))
     +                     , ISHFT (ISHFT(MZ, 32-NZB), -33+IZP+NZB) )
+KEEP, L3BITX, IF=IBM, IBMRT, VAX.
+SEQ, L3BITS.
      MSBIT (MZ,IZW,IZP) = IOR (IAND (IZW, NOT(ISHFT(1,IZP-1)) )
     +                              , ISHFT(IAND(MZ,1),IZP-1))
*
      MCBYT (MZ,IZQ,IZW,IZP,NZB) = IOR ( IAND (IZW, NOT(
     +                   ISHFT (ISHFT(NOT(0),-32+NZB), IZP-1)))
     +        , ISHFT (ISHFT(ISHFT(MZ,-IZQ+1),32-NZB), -33+IZP+NZB) )
*
      JBYTET (MZ,IZW,IZP,NZB) = IAND (MZ, IBITS(IZW,IZP-1,NZB))
      JBYTOR (MZ,IZW,IZP,NZB) = IOR  (MZ, IBITS(IZW,IZP-1,NZB))
      MBYTET (MZ,IZW,IZP,NZB) = IAND (IZW, NOT(ISHFT (
     +                          ISHFT(NOT(MZ),32-NZB),-33+IZP+NZB)) )
      MBYTOR (MZ,IZW,IZP,NZB) = IOR (IZW, ISHFT (
     +                               ISHFT(MZ,32-NZB),-33+IZP+NZB) )
+DECK, DBCDEDOC, IF=$DOC.
+KEEP, DAOPTI%.
/DAOPTI/           (For carrying information to decode options)
    CALFDA       Alphanumeric characters interpreted in character option
    CSTRDA       Character string decoded as integers for Text files
    MPAKDA       Byte packing parameters used for PAKBYT/UPKBYT
+KEEP, DAOPTS%.
/DAOPTS/           (For carrying decoded information of CHOPT)
  IOPaDA..IOPzDA Flag for each character in character option.
                 Decoded by DBOPTS and set to 1 if option requested.
    IOKYDA       Flag for each key element as set by CHOPT.
                 Decoded and has similar meaning as IOPxDA.
+KEEP, DBSRVR%.
/DBSRVR/           (For carrying information of Cache etc of VAX server)
    CACHDB       Name of the cache used by the server and the client
    FILEDB       Complete filename of the MAPCOM file
    DIREDB       Directory name of the MAPCOM files
/DBSRVRN/          (For giving some information back to the VAX server)
 DBFZUP_PATHN    The directory name last updated
 DBFZUP_PATHN_L  Length of the directory name
 DBFZUP_IACT     Action code used for that directory
+KEEP, DBSTOR%.
/GCBANK/          (For definition of the Q/IQ/LQ vectors)
 LQ,IQ,Q         Dynamic memory used inside the program
 FENCDB          Fence words used
/QUEST/           (For communication with user; error code etc.)
 IQUEST          Error code and other information
/DBUSER/          (Most commonly used ZEBRA pointers and other indices)
    IDEBDB       Debug level (default set at 0 in DBINIT)
    IDISDB       Division index of DBL3 system division
    IDIVDB       Division index of DBL3 user   division
    IHKYDB       Hollerith bank name of Key banks
    IKDRDB       Internal pointer to the first key in current directory
    IONODB       IO descriptor of the node bank
    KOFSDB       Offset of the store containing ZEBRA system division 
    KOFUDB       Offset of the store containing DBL3 divisions relative
                 to /GCBANK/
    LBADDB  -|
    LBAFDB   |
    LBDADB   |
    LBFXDB   |
    LBFYDB   |   Relocatable ZBERA addresses
    LBKYDB   |     Key bank
    LBNODB   |     Current node bank
    LFIXDB   |
    LREFDB   |
    LSAVDB   |
    LTOPDB  -|     First Top level bank (saved for all operations)
    LPRTDB       Logical unit number of the standard output file
    NTOPDB       Number of top level directories
    NDMXDB       Maximum number of data words to store a text file 
                  (Offsets and mnemonics)
    IKTYDB       Key descriptor in the directory bank
    KNSDDB       Number of subdirectories
    KLSDDB       Pointer to the first subdirectory
    NWNODB       Number of fixed words in the node bank (containing IO
                 descriptor of the Key banks)
    NWITDB       Number of words/directory in the Dictionary bank
    NPUSDB       Number of directories to be added in one go in the
                 Dictionary bank (per push)
    MAXLDB       Maximum number of characters in the path name
    JRZUDB       Bit in flag to tell if no packing/updating is done
    JIGNDB                   to tell the current object is to be ignored
    JPRTDB                   to tell the cuurent directory is partitiond
    JASFDB                   to tell the current object is a text file
    KLKYDB       Offset of the Key bank w.r.t. the node bank
    KLDADB       Offset of the Data bank w.r.t. the key bank
    KLNODB       Reference link offset of the node bank from key bank
    KLUPDB                 link offset of the top  bank from key bank
    KLDICT       Offset of the dictionary bank w.r.t. the top bank
    KLFZDB              of the FZDB bank (conatining list of directories
                        to be updated from Journal file) w.r.t. top bank
    MFZTOP       Offset of top directory name in FZDB bank
    MFZDIR              of directory name     in FZDB bank
    MXLWDB       Maximum number of words in the directory name in FZDB
    MUPLUN       Offset in UPDB of logical unit number of RZ file
    MUPFLG                      of flag if D.B. to be updated
    MUPJFL                      of logical unit number of journal file
    MUPBAK                      of logical unit number of backup file
    MUPDIC                      of identifier of the top directory
    MUPNCH                      of number of characters in top name
    MUPSRV                      of the shared/server flag
    MUPKY7                      of maximum Key7 value for retrieval
    MUPNAM                      of name of the top directory
    MNDNWK       Offset in NODB of the number of key elements 
    MNDNWD                      of total number of words in Key bank
    MNDNCH                      of number of characters in the name
    MNDDIC                      of unique identifier of the node
    MNDIOF                      of IO descriptor of the key bank
    MNDNAM                      of name of the path to the node
    NLKYDB       Number of links in the KYDB bank
    NSKYDB       Number of structural links in the KYDB bank
    MKYRID       Offset in KYDB of number of physical reads from disk
    MKYCEV       (from end)     of number of calls to DBUSE in 1 event
    MKYCRU                      of number of calls to DBUSE in 1 run
    MKYPRE                      of precision used to store the object
    MKYFRI                      of FREE flag
    NLUPDB       Number of links in the UPDB bank
    NSUPDB       Number of structural links in the UPDB bank
    NDUPDB       Number of data words in the UPDB bank
    MDCNTM       Offset in DICT of the number of nodes in the dictionary
    MDCITM                      of unique identifier of the node
    MDCNCH                      of number of characters in the path name
    MDCLUP                      of last update to the node
    MDCALI                      of the alias name
    MDCNAM                      of the path name to the node
    NARGDB       Maximum dimension of IARGDB used for printing
    LUFMDB       Logical unit number for the server file (in P mode)
    MSERDB       Offset in key vector of serial number of the object
    MUPNDB                            of reference to the master object
    MBVRDB                            of beginning validity range
    MEVRDB                            of end validity range
    MPVSDB                            of source identifier (Prog Vsn)
    MFLGDB                            of flag
    MITMDB                            of insertion time
    MPSRDB                            of partition number
    MXKPDB                            of maximum number per partition
    MOBJDB                            of lowest serial number (-1) in
                                      current partition
    MHFMDB       Offset in   | of height of the frame
    MLEVDB       the bank    |    level number
    MNAMDB       created in  |    node name
    MNCHDB       DBFPAT of   |    number of characters in node name
    MNDWDB       directory   |    number of down nodes
    MNFNDB       information |    upward node number
    MNLVDB       used for    |    number of levels
    MNNUDB       display etc.|    node number
    MNODDB                        number of nodes in the level
    MPNNDB                        pointer to the first node
    MPNLDB                        pointer to next level/node
    MPPLDB                        pointer to previous level
    MXOFDB                        X-offset of the level
    MXWDDB                        X-width  of the level
    MYFLDB                        Y-offset of the level
    MYFNDB                        Y-offset of the node
/DBSTOR/          (Additional flags and pointers)
    LCDRDB  -|   ZEBRA pointers in the | Current directory
    LJNKDB  -|   ZEBRA system divsion  |
    IBIGDB       Maximum end validity range value
    INSRDB       Initialization flag in server mode
    IODIDB       IO descriptor of the Dictionary bank
    IOFDDB                     of the FDDB bank
    IOFZDB                     of the FZDB bank
    IOVRDB       Overwrite flag in DBFZUP
    KY4MDB       Logical end validity of the current object
    KY7MDB       Maximum allowed Key 7 for data retrieval
    IOKYDB       IO descriptor of the Key bank
    IARGDB       Buffer for prinout
+PATCH, DBEXAM1.
+DECK, DBEXAM1.
+KEEP, DSTOR1.
      COMMON /GCBANK/ FENCDS(22), LQ(9)
      DIMENSION       IQ(2), Q(2)
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))
*
      COMMON /QUEST/  IQUEST(100)
*
+KEEP, DUSER1.
      COMMON /DUSER1/ IDIVDU, ISTODU, LPRTDU, LDUVDU(16), LKUVDU(16)
     +              , LUSEDU
*
+DECK, DEXAM1.
      PROGRAM DEXAM1
*     ==============
*
************************************************************************
*                                                                      *
*        PROG. DEXAM1                                                  *
*                                                                      *
*   Program to create a fictitious database to test DBOUT, DBENTR      *
*                                                                      *
*   The Data Base structure is an extraction from the Muon Chamber     *
*   database as proposed by B.Adeva and E.Gonzalez in L3 Report No.496 *
*                                                                      *
************************************************************************
*
      PARAMETER       (NLAST=150000, NDIV1=5000)
      COMMON /GCBANK/ FENCDS(22), LQ(NLAST)
*
+CDE, DUSER1.
      CHARACTER       CFNM1*80, CFNM2*80
*
*     ------------------------------------------------------------------
*
      CALL MZEBRA(-1)
*
* *** Open the 1 and only 1 Store used in the reconstruction
*
      CALL MZSTOR (ISTODU, '/GCBANK/', ' ', FENCDS(1), LQ(1), LQ(1)
     +           , LQ(1), LQ(NDIV1), LQ(NLAST))
*
* *** Open the RZ-file with an Open Statement (or JCL, etc)
*
      LUNRZ  = 1
      LUNFZ  = 2
      LPRTDU = 6
      NREC   = 1000
      LREC   = 1024
      NBYTE  = 4*LREC
      NBYTF  = 80
+SELF, IF=IBM.
      CFNM1  = 'DBMUON.DATA.A4'
      CFNM2  = 'DBMUFZ.DATA.A'
+SELF, IF=-IBM.
      CFNM1  = 'DBMUON.DAT'
      CFNM2  = 'DBMUFZ.DAT'
+SELF.
      CALL DBROPN (LUNRZ, 'ZO',  CFNM1, NBYTE, IOERR)
      IF (IOERR.NE.0)        GO TO 999
      CALL DBSOPN (LUNFZ, 'AZO', CFNM2, NBYTF, IOERR)
      IF (IOERR.NE.0)        GO TO 999
*
* *** Log-Level
*
+SELF, IF=-$DEBUG.
      CALL MZLOGL (ISTODU, 0)
+SELF, IF=$DEBUG.
      CALL MZLOGL (ISTODU, 1)
+SELF.
*
* *** Define user division and link area like:
*
      CALL MZDIV  (ISTODU, IDIVDU, 'DB-USERS', 50000, 100000, 'L')
      CALL MZLINK (ISTODU, '/DUSER1/', LDUVDU(1), LUSEDU, LDUVDU(1))
*
* *** Initialize DB-Package
*
      CALL TIMEST (999999.)
      CALL DBINIT (IDIVDU, LUNRZ, 'DBL3', LTOP, NREC, 'UZ')
+SELF, IF=-$DEBUG.
      CALL DBLOGL (LUNRZ,  0)
+SELF, IF=$DEBUG.
      CALL DBLOGL (LUNRZ,  2)
+SELF.
      CALL DBFZOP (LUNFZ, 'DBL3', ' ')
*
* *** Create the Muon Data Base
*
      CALL DBCRMD
      IDATX = 800101
      DO 10 I = 1, 3
        CALL DBPKTS (IDATX, 0, ISTRV)
        CALL DBCRMU (ISTRV)
        IDATX = IDATX + 10000
   10 CONTINUE
*
* *** Close Data Base
*
      CALL FZENDO (LUNFZ, 'T')
      CALL DBEND
*                                                             END DEXAM1
  999 END
+DECK, DBCRMD.
      SUBROUTINE DBCRMD
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBCRMD                                                  *
*                                                                      *
*   Creates the directory structure of the immitation data base        *
*                                                                      *
*   Called by DEXAM1                                                   *
*                                                                      *
************************************************************************
*
+CDE, DUSER1.
      CHARACTER       CHTAG(2)*8
      DATA            CHTAG /'Key_8   ', 'Key_9   '/
*
*     ------------------------------------------------------------------
*
      CALL TIMEX (TIMINT)
      CALL DBUVTX (IDAY, ITIM1)
*
      CALL DBCRSD ('//DBL3/MUCH/MCALB/UVDS', 1, 'I', CHTAG, 0, ' ')
      CALL DBCRSD ('//DBL3/MUCH/MCALB/ALIG/HRAS', 2, 'II', CHTAG,
     +             0, ' ')
      CALL DBCRSD ('//DBL3/MUCH/MCALB/ALIG/BEAC', 1, 'I', CHTAG, 0, ' ')
      CALL DBCRSD ('//DBL3/MUCH/MPARS/BWIR', 0, 'I', CHTAG, 0, ' ')
      CALL DBCRSD ('//DBL3/MUCH/MPARS/MGEOM/XBRI', 2, 'II', CHTAG,
     +             0, ' ')
      CALL DBCRSD ('//DBL3/MUCH/MPARS/MGEOM/YPCH/YAPL', 1, 'I', CHTAG,
     +             0, ' ')
      CALL DBCRSD ('//DBL3/MUCH/MPARS/MGEOM/YPCH/YBRI', 1, 'I', CHTAG,
     +             0, ' ')
*
      CALL TIMEX (TIMNOW)
      TIME  = TIMNOW - TIMINT
      CALL DBUVTX (IDAY, ITIM2)
      ITIME = ITIM2 - ITIM1
      WRITE (LPRTDU, 1001) IDAY, ITIM1, ITIM2, ITIME
      WRITE (LPRTDU, 1002) TIMINT, TIMNOW, TIME
*
 1001 FORMAT (/,' DBCRMD : IDAY/ITIM1/ITIM2/ITIME ', 4I12)
 1002 FORMAT (/,' DBCRMD : TIMINT/TIMNOW/TIME ',4G12.4)
*                                                             END DBCRMD
      END
+DECK, DBCRMU.
      SUBROUTINE DBCRMU (ITIM1)
*     =========================
*
************************************************************************
*                                                                      *
*        SUBR. DBCRMU (ITIM1)                                          *
*                                                                      *
*   Creates the imitation of the Muon Chamber Data Base                *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     ITIM1    Start time of validity                                  *
*                                                                      *
*   Called by DEXAM1                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR1.
+CDE, DUSER1.
      DIMENSION       KEYX(4), KEYS(9)
      DATA            IPROG /1/, KEYX /4*0/
      DATA            XRANG / 1000.0/, XCENT / 500.0/
*
*     ------------------------------------------------------------------
*
      CALL TIMEX (TIMINT)
      CALL DBUVTX (IDAY, ITIM1)
      CALL DBPKTS (991231, 235959, INFIN)
*
* *** --------  UVDS  ----------------------
*
      NKEYS = 8
      NKEY8 = 16
      CALL VZERO (KEYS, NKEYS)
      KEYS(3) = ITIM1
      KEYS(4) = INFIN
      KEYS(5) = IPROG
      DO 10 K = 1, NKEY8
        NDAT  = 48
        CALL MZBOOK (IDIVDU, LUSEDU, LUSEDU, 2, 'UVDS', 0, 0, NDAT, 3,0)
        KEYS(8) = K
        DO 5 I = 1, NDAT
          Q(LUSEDU+I) = XRANG*RNDM(Q) - XCENT
    5   CONTINUE
        CALL DBENTR ('//DBL3/MUCH/MCALB/UVDS', LKUVDU(K), LDUVDU(K),
     +              IDIVDU, LUSEDU, NKEYS, KEYS, 3, 'C')
+SELF, IF=-$DEBUG.
        IF (LUSEDU.NE.0 .AND. K.EQ.NKEY8)
+SELF, IF=$DEBUG.
        IF (LUSEDU.NE.0)
+SELF.
     +    CALL DZSHOW ('UVDS    ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
        CALL MZDROP (IDIVDU, LUSEDU, ' ')
   10 CONTINUE
+SELF, IF=$DEBUG.
      K     = 1
+SELF, IF=-$DEBUG.
      K     = NKEY8
+SELF.
      CALL DZSHOW ('LKUVDU ', IDIVDU, LKUVDU(K), 'BLV', 0, 0, 0, 0)
      CALL MZDROP (IDIVDU, LKUVDU(1), 'L')
*
* *** --------  HRAS  ----------------------
*
      NKEX  = 4
      NKEY8 = 16
      NKEY9 = 5
      DO 25 L = 1, NKEY9
        DO 20 K = 1, NKEY8
          NDAT  = 21
          CALL MZBOOK (IDIVDU, LUSEDU, LUSEDU, 2, 'HRAS', 0,0, NDAT,3,0)
          KEYX(3) = K
          KEYX(4) = L
          DO 15 I = 1, NDAT
            Q(LUSEDU+I) = XRANG*RNDM(Q) - XCENT
   15     CONTINUE
          CALL DBOUT ('//DBL3/MUCH/MCALB/ALIG/HRAS', ITIM1, INFIN,
     +                LUSEDU, IPROG, NKEX, KEYX, 0, ' ')
+SELF, IF=-$DEBUG.
          IF (LUSEDU.NE.0 .AND. K.EQ.NKEY8)
+SELF, IF=$DEBUG.
          IF (LUSEDU.NE.0)
+SELF.
     +      CALL DZSHOW ('HRAS    ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
          CALL MZDROP (IDIVDU, LUSEDU, ' ')
   20   CONTINUE
   25 CONTINUE
*
* *** --------  BEAC  ----------------------
*
      NKEX  = 3
      NKEY8 = 16
      DO 35 K = 1, NKEY8
        NDAT  = 67
        CALL MZBOOK (IDIVDU, LUSEDU, LUSEDU, 2, 'BEAC', 0, 0, NDAT, 3,0)
        KEYX(3) = K
        DO 30 I = 1, NDAT
          Q(LUSEDU+I) = XRANG*RNDM(Q) - XCENT
   30   CONTINUE
        CALL DBOUT ('//DBL3/MUCH/MCALB/ALIG/BEAC', ITIM1, INFIN,
     +              LUSEDU, IPROG, NKEX, KEYX, 0, ' ')
+SELF, IF=-$DEBUG.
        IF (LUSEDU.NE.0 .AND. K.EQ.NKEY8)
+SELF, IF=$DEBUG.
        IF (LUSEDU.NE.0)
+SELF.
     +    CALL DZSHOW ('BEAC    ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
        CALL MZDROP (IDIVDU, LUSEDU, ' ')
   35 CONTINUE
*
* *** --------  BWIR  ----------------------
*
      NKEX  = 2
      NDAT  = 100
      CALL MZBOOK (IDIVDU, LUSEDU, LUSEDU, 2, 'BWIR', 0, 0, NDAT, 2, 0)
      DO 40 I = 1, NDAT
        J     = 4*(I-1)
        IQ(LUSEDU+J+1) = 12
        IQ(LUSEDU+J+2) = 5
        IQ(LUSEDU+J+3) = -1
        IQ(LUSEDU+J+4) = 1000*RNDM(Q)
   40 CONTINUE
      CALL DBOUT ('//DBL3/MUCH/MPARS/BWIR', ITIM1, INFIN,
     +            LUSEDU, IPROG, NKEX, KEYX, 0, ' ')
      CALL DZSHOW ('BWIR    ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
      CALL MZDROP (IDIVDU, LUSEDU, ' ')
*
* *** --------  XBRI  ----------------------
*
      NKEX  = 4
      NKEY8 = 17
      NKEY9 = 5
      DO 55 L = 1, NKEY9
        DO 50 K = 1, NKEY8
          NDAT  = 30
          CALL MZBOOK (IDIVDU, LUSEDU, LUSEDU, 2, 'XBRI', 0,0, NDAT,3,0)
          KEYX(3) = K
          KEYX(4) = L
          DO 45 I = 1, NDAT
            Q(LUSEDU+I) = XRANG*RNDM(Q) - XCENT
   45     CONTINUE
          CALL DBOUT ('//DBL3/MUCH/MPARS/MGEOM/XBRI', ITIM1, INFIN,
     +                LUSEDU, IPROG, NKEX, KEYX, 0, ' ')
+SELF, IF=-$DEBUG.
          IF (LUSEDU.NE.0 .AND. K.EQ.NKEY8)
+SELF, IF=$DEBUG.
          IF (LUSEDU.NE.0)
+SELF.
     +      CALL DZSHOW ('XBRI    ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
          CALL MZDROP (IDIVDU, LUSEDU, ' ')
   50  CONTINUE
   55 CONTINUE
*
* *** --------  YAPL  ----------------------
*
      NKEX  = 3
      NKEY8 = 17
      DO 65 K = 1, NKEY8
        NDAT  = 67
        CALL MZBOOK (IDIVDU, LUSEDU, LUSEDU, 2, 'YAPL', 0, 0, NDAT, 3,0)
        KEYX(3) = K
        DO 60 I = 1, NDAT
          Q(LUSEDU+I) = XRANG*RNDM(Q) - XCENT
   60   CONTINUE
        CALL DBOUT ('//DBL3/MUCH/MPARS/MGEOM/YPCH/YAPL', ITIM1, INFIN,
     +              LUSEDU, IPROG, NKEX, KEYX, 0, ' ')
+SELF, IF=-$DEBUG.
        IF (LUSEDU.NE.0 .AND. K.EQ.NKEY8)
+SELF, IF=$DEBUG.
        IF (LUSEDU.NE.0)
+SELF.
     +    CALL DZSHOW ('YAPL    ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
        CALL MZDROP (IDIVDU, LUSEDU, ' ')
   65 CONTINUE
*
* *** --------  YBRI  ----------------------
*
      NKEX  = 3
      NKEY8 = 17
      DO 75 K = 1, NKEY8
        NDAT  = 43
        CALL MZBOOK (IDIVDU, LUSEDU, LUSEDU, 2, 'YBRI', 0, 0, NDAT, 3,0)
        KEYX(3) = K
        DO 70 I = 1, NDAT
          Q(LUSEDU+I) = XRANG*RNDM(Q) - XCENT
   70   CONTINUE
        CALL DBOUT ('//DBL3/MUCH/MPARS/MGEOM/YPCH/YBRI', ITIM1, INFIN,
     +              LUSEDU, IPROG, NKEX, KEYX, 0, ' ')
+SELF, IF=-$DEBUG.
        IF (LUSEDU.NE.0 .AND. K.EQ.NKEY8)
+SELF, IF=$DEBUG.
        IF (LUSEDU.NE.0)
+SELF.
     +    CALL DZSHOW ('YBRI    ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
        CALL MZDROP (IDIVDU, LUSEDU, ' ')
   75 CONTINUE
*
      CALL TIMEX (TIMNOW)
      TIME  = TIMNOW - TIMINT
      CALL DBUVTX (IDAY, ITIM2)
      ITIME = ITIM2 - ITIM1
      WRITE (LPRTDU, 1001) IDAY, ITIM1, ITIM2, ITIME
      WRITE (LPRTDU, 1002) TIMINT, TIMNOW, TIME
*
 1001 FORMAT (/,' DBCRMU : IDAY/ITIM1/ITIM2/ITIME ', 4I12)
 1002 FORMAT (/,' DBCRMU : TIMINT/TIMNOW/TIME ',4G12.4)
*                                                             END DBCRMU
      END
+PATCH, DBEXAM2.
+DECK, DBEXAM2.
+KEEP, DSTOR2.
      COMMON /GCBANK/ FENCDS(22), LQ(9)
      DIMENSION       IQ(2), Q(2)
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))
*
      COMMON /QUEST/  IQUEST(100)
*
+KEEP, DUSER2.
      COMMON /DUSER2/ IDIVDU, ISTODU, LPRTDU, LKUVDU(16), LDUVDU(16)
     +              , LKBWDU, LDBWDU, LKHRDU(16,5), LDHRDU(16,5)
     +              , LKYBDU(17), LDYBDU(17)
*
+KEEP, DVSER2.
      COMMON /DVSER2/ LKUVDV(16), LDUVDV(16), LKBWDV, LDBWDV
     +              , LKHRDV(16,5), LDHRDV(16,5), LKYBDV(17), LDYBDV(17)
*
+DECK, DEXAM2.
      PROGRAM DEXAM2
*     ==============
*
************************************************************************
*                                                                      *
*        PROG. DEXAM2                                                  *
*                                                                      *
*   Program to debug DBUSE on a fictitious Data Base. It can also      *
*   debug the routines DBPRIN, DBPURG and DBTBPR.                      *
*                                                                      *
*   The Data Base structure is an extraction from the Muon Chamber     *
*   database as proposed by B.Adeva and E.Gonzalez in L3 Report No.496 *
*                                                                      *
************************************************************************
*
      PARAMETER       (NLAST=150000, NDIV1=5000)
      COMMON /GCBANK/ FENCDS(22), LQ(NLAST)
+CDE, DUSER2.
+CDE, DVSER2.
      CHARACTER       CHOPT*8, CFNM1*80, CFNM2*80, CFNM3*80
*
*     ------------------------------------------------------------------
*
      CALL MZEBRA (-1)
*
* *** Open the 1 and only 1 Store used in the reconstruction
*
      CALL MZSTOR (ISTODU, '/GCBANK/', ' ', FENCDS(1), LQ(1), LQ(1)
     +           , LQ(1), LQ(NDIV1), LQ(NLAST))
*
* *** Open the RZ-file with an Open Statement (or JCL, etc)
*
      LUNRZ  = 1
      LUNFZ  = 2
      LU2RZ  = 3
      LPRTDU = 6
      NREC   = 1000
      LREC   = 1024
      NBYTE  = 4*LREC
      NBYTF  = 80
+SELF, IF=IBM.
      CFNM1  = 'DBMUON.DATA.A4'
      CFNM2  = 'DBMUFZ.DATA.A'
      CFNM3  = 'DBMUOM.DATA.A4'
+SELF, IF=-IBM.
      CFNM1  = 'DBMUON.DAT'
      CFNM2  = 'DBMUFZ.DAT'
      CFNM3  = 'DBMUOM.DAT'
+SELF.
      CALL DBROPN (LUNRZ, '  ',  CFNM1, NBYTE, IOERR)
      IF (IOERR.NE.0)        GO TO 999
      CALL DBROPN (LU2RZ, 'ZO',  CFNM3, NBYTE, IOERR)
      IF (IOERR.NE.0)        GO TO 999
      CALL DBSOPN (LUNFZ, 'AI',  CFNM2, NBYTF, IOERR)
      IF (IOERR.NE.0)        GO TO 999
*
* *** Log-Level
*
+SELF, IF=-$DEBUG.
      CALL MZLOGL (ISTODU, 0)
+SELF, IF=$DEBUG.
      CALL MZLOGL (ISTODU, 1)
+SELF.
*
* *** Define user division and link area like:
*
      CALL MZDIV  (ISTODU, IDIVDU, 'DB-USERS', 20000, 30000, 'L')
      CALL MZLINK (ISTODU, '/DUSER2/', LKUVDU(1), LDYBDU(17), LKUVDU(1))
      CALL MZLINK (ISTODU, '/DVSER2/', LKUVDV(1), LDYBDV(17), LKUVDV(1))
*
* *** Initialize DB-Package
*
      CALL TIMEST (999999.)
      CALL DBINIT (IDIVDU, LU2RZ, 'DBL3', LTOP, NREC, 'UZ')
      CALL DBINIT (IDIVDU, LUNRZ, 'DVL3', LTOP, 0, ' ')
+SELF, IF=-$DEBUG.
      CALL DBLOGL (LUNRZ,  0)
      CALL DBLOGL (LU2RZ,  0)
+SELF, IF=$DEBUG.
      CALL DBLOGL (LUNRZ,  2)
      CALL DBLOGL (LU2RZ,  2)
      CALL DZSTOR ('DBSTORE', ISTODU)
      CALL DZAREA ('DB-LINKS', ISTODU, ' ', 0, ' ')
+SELF.
*
* *** Retrieve the data base from the journal file
*
      CALL TIMEX (TIMINT)
      CALL DBUVTX (IDAY, ITIM1)
      CALL DBFZUP (LUNFZ, ' ')
      CALL FZENDI (LUNFZ, 'T')
*
      CALL TIMEX (TIMNOW)
      TIME  = TIMNOW - TIMINT
      CALL DBUVTX (IDAY, ITIM2)
      ITIME = ITIM2 - ITIM1
      WRITE (LPRTDU, 1001) IDAY, ITIM1, ITIM2, ITIME
      WRITE (LPRTDU, 1002) TIMINT, TIMNOW, TIME
+SELF, IF=$INIMODE.
*
* *** Initialize the Muon Data Base structure
*
      CALL DBINMU
+SELF.
*
* *** Read the Muon Data Base
*
      IDATX = 800601
      DO 10 I = 1, 3
        CALL DBPKTS (IDATX, 120000, ITIME)
        CALL DBONMU (ITIME)
        IDATX = IDATX + 10000
   10 CONTINUE
*
* *** Test subroutine DBPRIN
*
+SELF, IF=-$DEBUG.
      CHOPT  = 'K'
+SELF, IF=$DEBUG.
      CHOPT  = 'D'
+SELF.
      CALL DBPRIN ('//DBL3/MUCH/MCALB/UVDS', CHOPT)
      CALL DBPRIN ('//DVL3/MUCH/MCALB/UVDS', CHOPT)
*
* *** Test subroutine DBPURG
*
      CALL DBPURG ('//DBL3/MUCH/MCALB/UVDS', 8, 10, 'K')
      CALL DBPRIN ('//DBL3/MUCH/MCALB/UVDS', CHOPT)
*
* *** Print out the summary of usage
*
      CALL DBTBPR
*
* *** Test subroutine DBDELT
*
      CALL RZSTAT ('//DBL3', 20, ' ')
      CALL DBDELT ('//DBL3/MUCH/MPARS/MGEOM', ' ')
      CALL RZSTAT ('//DBL3', 20, ' ')
*
* *** Close DataBase
*
      CALL DBEND
*
 1001 FORMAT (/,' DEXAM2 : IDAY/ITIM1/ITIM2/ITIME ', 4I12)
 1002 FORMAT (/,' DEXAM2 : TIMINT/TIMNOW/TIME ',4G12.4)
*                                                             END DEXAM2
  999 END
+DECK, DBINMU, IF=$INIMODE.
      SUBROUTINE DBINMU
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBINMU                                                  *
*                                                                      *
*   Initializes DBUSE on the imitation of the Muon Data Base           *
*                                                                      *
*   Called by DEXAM2                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR2.
+CDE, DUSER2.
+CDE, DVSER2.
      DIMENSION       KEYS(1000)
*
*     ------------------------------------------------------------------
*
      CALL TIMEX (TIMINT)
      CALL DBUVTX (IDAY, ITIM1)
      CALL VZERO (KEYS, 9)
      ITIME = 0
*
* *** -------------- UVDS ---------------------
*
      KEYS(8) = 16
      DO 5 I = 1, KEYS(8)
        KEYS(8+I) = I
    5 CONTINUE
      CALL DBUSE ('//DBL3/MUCH/MCALB/UVDS', LKUVDU(1), LDUVDU(1),
     +            ITIME, KEYS, 'M8')
      CALL DBUSE ('//DVL3/MUCH/MCALB/UVDS', LKUVDV(1), LDUVDV(1),
     +            ITIME, KEYS, 'M8')
+SELF, IF=$DEBUG.
      IF (LKUVDU(1).NE.0)
     +  CALL DZSHOW ('UVDS    ', IDIVDU, LKUVDU(1), 'L', 0, 0, 0, 0)
      IF (LKUVDV(1).NE.0)
     +  CALL DZSHOW ('UVDS    ', IDIVDU, LKUVDV(1), 'L', 0, 0, 0, 0)
+SELF.
*
* *** -------------- HRAS ---------------------
*
      KEYS(8) = 16
      KEYS(9) = 5
      DO 10 I = 1, KEYS(8)
        KEYS(9+I) = I
   10 CONTINUE
      IS    = 9 + KEYS(8)
      DO 20 I = 1, KEYS(9)
        KEYS(IS+I) = I
   20 CONTINUE
      CALL DBUSE ('//DBL3/MUCH/MCALB/ALIG/HRAS', LKHRDU(1,1),
     +            LDHRDU(1,1), ITIME, KEYS, 'M89')
      CALL DBUSE ('//DVL3/MUCH/MCALB/ALIG/HRAS', LKHRDV(1,1),
     +            LDHRDV(1,1), ITIME, KEYS, 'M89')
+SELF, IF=$DEBUG.
      IF (LKHRDU(1,1).NE.0)
     +  CALL DZSHOW ('HRAS    ', IDIVDU, LKHRDU(1,1), 'L', 0, 0, 0, 0)
      IF (LKHRDV(1,1).NE.0)
     +  CALL DZSHOW ('HRAS    ', IDIVDU, LKHRDV(1,1), 'L', 0, 0, 0, 0)
+SELF.
*
* *** -------------- BWIR ---------------------
*
      CALL DBUSE ('//DBL3/MUCH/MPARS/BWIR', LKBWDU, LDBWDU, ITIME, KEYS,
     +            ' ')
      CALL DBUSE ('//DVL3/MUCH/MPARS/BWIR', LKBWDV, LDBWDV, ITIME, KEYS,
     +            ' ')
+SELF, IF=$DEBUG.
      IF (LKBWDU.NE.0)
     +  CALL DZSHOW ('BWIR    ', IDIVDU, LKBWDU, 'B', 0, 0, 0, 0)
      IF (LKBWDV.NE.0)
     +  CALL DZSHOW ('BWIR    ', IDIVDU, LKBWDV, 'B', 0, 0, 0, 0)
+SELF.
*
* *** -------------- YBRI ---------------------
*
      KEYS(5) = 1
      KEYS(8) = 17
      DO 30 I = 1, KEYS(8)
        KEYS(8+I) = I
   30 CONTINUE
      CALL DBUSE ('//DBL3/MUCH/MPARS/MGEOM/YPCH/YBRI', LKYBDU(1),
     +            LDYBDU(1), ITIME, KEYS, 'M58')
      CALL DBUSE ('//DVL3/MUCH/MPARS/MGEOM/YPCH/YBRI', LKYBDV(1),
     +            LDYBDV(1), ITIME, KEYS, 'M58')
+SELF, IF=$DEBUG.
      IF (LKYBDU(1).NE.0)
     +  CALL DZSHOW ('YBRI    ', IDIVDU, LKYBDU(1), 'L', 0, 0, 0, 0)
      IF (LKYBDV(1).NE.0)
     +  CALL DZSHOW ('YBRI    ', IDIVDU, LKYBDV(1), 'L', 0, 0, 0, 0)
+SELF.
*
      CALL TIMEX (TIMNOW)
      TIME  = TIMNOW - TIMINT
      CALL DBUVTX (IDAY, ITIM2)
      ITIME = ITIM2 - ITIM1
      WRITE (LPRTDU, 1001) IDAY, ITIM1, ITIM2, ITIME
      WRITE (LPRTDU, 1002) TIMINT, TIMNOW, TIME
*
 1001 FORMAT (/,' DBINMU : IDAY/ITIM1/ITIM2/ITIME ', 4I12)
 1002 FORMAT (/,' DBINMU : TIMINT/TIMNOW/TIME ',4G12.4)
*                                                             END DBINMU
      END
+DECK, DBONMU.
      SUBROUTINE DBONMU (ITIME)
*     =========================
*
************************************************************************
*                                                                      *
*        SUBR. DBONMU (ITIME)                                          *
*                                                                      *
*   Tests DBUSE on the imitation of the Muon Data Base                 *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     ITIME    Validity time                                           *
*                                                                      *
*   Called by DEXAM2                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR2.
+CDE, DUSER2.
+CDE, DVSER2.
      DIMENSION       KEYS(1000)
      CHARACTER       CHOPT*4
*
*     ------------------------------------------------------------------
*
      CALL TIMEX (TIMINT)
      CALL DBUVTX (IDAY, ITIM1)
      CALL VZERO (KEYS, 9)
*
* *** -------------- UVDS ---------------------
*
      KEYS(8) = 16
      DO 5 I = 1, KEYS(8)
        KEYS(8+I) = I
    5 CONTINUE
+SELF, IF=$INIMODE.
      CHOPT = 'AM8'
+SELF, IF=-$INIMODE.
      CHOPT = 'M8'
+SELF.
      CALL DBUSE ('//DBL3/MUCH/MCALB/UVDS', LKUVDU(1), LDUVDU(1),
     +            ITIME, KEYS, CHOPT)
      CALL DBUSE ('//DVL3/MUCH/MCALB/UVDS', LKUVDV(1), LDUVDV(1),
     +            ITIME, KEYS, CHOPT)
      DO 10 I = 1, KEYS(8)
+SELF, IF=-$DEBUG.
        IF (LDUVDU(I).NE.0.AND.I.EQ.KEYS(8))
+SELF, IF=$DEBUG.
        IF (LDUVDU(I).NE.0)
+SELF.
     +    CALL DZSHOW ('UVDS    ', IDIVDU, LDUVDU(I), 'V', 0, 0, 0, 0)
+SELF, IF=-$DEBUG.
        IF (LDUVDV(I).NE.0.AND.I.EQ.KEYS(8))
+SELF, IF=$DEBUG.
        IF (LDUVDV(I).NE.0)
+SELF.
     +    CALL DZSHOW ('UVDS    ', IDIVDU, LDUVDV(I), 'V', 0, 0, 0, 0)
   10 CONTINUE
      CALL DBFREE ('//DBL3/MUCH/MCALB/UVDS', LKUVDU, KEYS, CHOPT)
      CALL DBFREE ('//DVL3/MUCH/MCALB/UVDS', LKUVDV, KEYS, CHOPT)
*
* *** -------------- HRAS ---------------------
*
      KEYS(8) = 16
      KEYS(9) = 5
      DO 15 I = 1, KEYS(8)
        KEYS(9+I) = I
   15 CONTINUE
      IS    = 9 + KEYS(8)
      DO 20 I = 1, KEYS(9)
        KEYS(IS+I) = I
   20 CONTINUE
+SELF, IF=$INIMODE.
      CHOPT = 'AM89'
+SELF, IF=-$INIMODE.
      CHOPT = 'M89'
+SELF.
      CALL DBUSE ('//DBL3/MUCH/MCALB/ALIG/HRAS', LKHRDU(1,1),
     +            LDHRDU(1,1), ITIME, KEYS, CHOPT)
      CALL DBUSE ('//DVL3/MUCH/MCALB/ALIG/HRAS', LKHRDV(1,1),
     +            LDHRDV(1,1), ITIME, KEYS, CHOPT)
      DO 30 J = 1, KEYS(9)
        DO 25 I = 1, KEYS(8)
+SELF, IF=-$DEBUG.
          IF (LDHRDU(I,J).NE.0.AND.I.EQ.KEYS(8))
+SELF, IF=$DEBUG.
          IF (LDHRDU(I,J).NE.0)
+SELF.
     +      CALL DZSHOW ('HRAS    ', IDIVDU, LDHRDU(I,J), 'V', 0,0, 0,0)
+SELF, IF=-$DEBUG.
          IF (LDHRDV(I,J).NE.0.AND.I.EQ.KEYS(8))
+SELF, IF=$DEBUG.
          IF (LDHRDV(I,J).NE.0)
+SELF.
     +      CALL DZSHOW ('HRAS    ', IDIVDU, LDHRDV(I,J), 'V', 0,0, 0,0)
   25   CONTINUE
   30 CONTINUE
      CALL DBFREE ('//DBL3/MUCH/MCALB/ALIG/HRAS', LKHRDU, KEYS, CHOPT)
      CALL DBFREE ('//DVL3/MUCH/MCALB/ALIG/HRAS', LKHRDV, KEYS, CHOPT)
*
* *** -------------- BWIR ---------------------
*
+SELF, IF=$INIMODE.
      CHOPT = 'AV'
+SELF, IF=-$INIMODE.
      CHOPT = 'V'
+SELF.
      CALL DBUSE ('//DBL3/MUCH/MPARS/BWIR', LKBWDU, LDBWDU, ITIME, KEYS,
     +            CHOPT)
      CALL DBUSE ('//DVL3/MUCH/MPARS/BWIR', LKBWDV, LDBWDV, ITIME, KEYS,
     +            CHOPT)
      IF (LDBWDU.NE.0)
     +  CALL DZSHOW ('BWIR    ', IDIVDU, LDBWDU, 'V', 0, 0, 0, 0)
      IF (LDBWDV.NE.0)
     +  CALL DZSHOW ('BWIR    ', IDIVDU, LDBWDV, 'V', 0, 0, 0, 0)
      CALL DBFREE ('//DBL3/MUCH/MPARS/BWIR', LKBWDU, KEYS, CHOPT)
      CALL DBFREE ('//DVL3/MUCH/MPARS/BWIR', LKBWDV, KEYS, CHOPT)
*
* *** -------------- YBRI ---------------------
*
      KEYS(5) = 1
      KEYS(8) = 17
      DO 35 I = 1, KEYS(8)
        KEYS(8+I) = I
   35 CONTINUE
+SELF, IF=$INIMODE.
      CHOPT = 'AM58'
+SELF, IF=-$INIMODE.
      CHOPT = 'M58'
+SELF.
      CALL DBUSE ('//DBL3/MUCH/MPARS/MGEOM/YPCH/YBRI', LKYBDU(1),
     +            LDYBDU(1), ITIME, KEYS, CHOPT)
      CALL DBUSE ('//DVL3/MUCH/MPARS/MGEOM/YPCH/YBRI', LKYBDV(1),
     +            LDYBDV(1), ITIME, KEYS, CHOPT)
      DO 40 I = 1, KEYS(8)
+SELF, IF=-$DEBUG.
        IF (LDYBDU(I).NE.0.AND.I.EQ.KEYS(8))
+SELF, IF=$DEBUG.
        IF (LDYBDU(I).NE.0)
+SELF.
     +    CALL DZSHOW ('YBRI    ', IDIVDU, LDYBDU(I), 'V', 0, 0, 0, 0)
+SELF, IF=-$DEBUG.
        IF (LDYBDV(I).NE.0.AND.I.EQ.KEYS(8))
+SELF, IF=$DEBUG.
        IF (LDYBDV(I).NE.0)
+SELF.
     +    CALL DZSHOW ('YBRI    ', IDIVDU, LDYBDV(I), 'V', 0, 0, 0, 0)
   40 CONTINUE
      CALL DBFREE ('//DBL3/MUCH/MPARS/MGEOM/YPCH/YBRI', LKYBDU, KEYS,
     +             CHOPT)
      CALL DBFREE ('//DVL3/MUCH/MPARS/MGEOM/YPCH/YBRI', LKYBDV, KEYS,
     +             CHOPT)
+SELF, IF=$DEBUG.
*
      CALL DZSNAP ('MEMORY MAP OF MUON DATABASE', IDIVDU, 'LM')
+SELF.
*
      CALL TIMEX (TIMNOW)
      TIME  = TIMNOW - TIMINT
      CALL DBUVTX (IDAY, ITIM2)
      ITIME = ITIM2 - ITIM1
      WRITE (LPRTDU, 1001) IDAY, ITIM1, ITIM2, ITIME
      WRITE (LPRTDU, 1002) TIMINT, TIMNOW, TIME
*
 1001 FORMAT (/,' DBONMU : IDAY/ITIM1/ITIM2/ITIME ', 4I12)
 1002 FORMAT (/,' DBONMU : TIMINT/TIMNOW/TIME ',4G12.4)
*                                                             END DBONMU
      END
+PATCH, DBEXAM3.
+DECK, DBEXAM3.
+KEEP, DSTOR3.
      COMMON /GCBANK/ FENCDS(22), LQ(9)
      DIMENSION       IQ(2), Q(2)
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))
*
      COMMON /QUEST/  IQUEST(100)
*
+KEEP, DUSER3.
      COMMON /DUSER3/ IDIVDU, ISTODU, LPRTDU, LKTRDU(5), LDTRDU(5)
     +              , LUSEDU
*
+DECK, DEXAM3.
      PROGRAM DEXAM3
*     ==============
*
************************************************************************
*                                                                      *
*        PROG. DEXAM3                                                  *
*                                                                      *
*   Program to create a fictitious Data Base to test the Package       *
*           including DBENTR, DBMDIR and NKEYS > 9                     *
*                                                                      *
*   The Data Base structure is completely arbitary                     *
*                                                                      *
************************************************************************
*
      PARAMETER       (NLAST=150000, NDIV1=5000)
      COMMON /GCBANK/ FENCDS(22), LQ(NLAST)
*
+CDE, DUSER3.
      CHARACTER       CFNM1*80
*     ------------------------------------------------------------------
*
* *** Open the RZ-file with an Open Statement (or JCL, etc)
*
      LUNRZ  = 1
      LPRTDU = 6
      NREC   = 1000
      LREC   = 1024
      NBYTE  = 4*LREC
+SELF, IF=IBM.
      CFNM1  = 'DBFAKE.DATA.A4'
+SELF, IF=-IBM.
      CFNM1  = 'DBFAKE.DAT'
+SELF.
      CALL DBROPN (LUNRZ, 'ZO',  CFNM1, NBYTE, IOERR)
      IF (IOERR.NE.0)        GO TO 999
      CALL MZEBRA (-1)
*
* *** Open the 1 and only 1 Store used in the reconstruction
*
      CALL MZSTOR (ISTODU, '/GCBANK/', ' ', FENCDS(1), LQ(1), LQ(1)
     +           , LQ(1), LQ(NDIV1), LQ(NLAST))
*
* *** Log-Level
*
+SELF, IF=-$DEBUG.
      CALL MZLOGL (ISTODU, 0)
+SELF, IF=$DEBUG.
      CALL MZLOGL (ISTODU, 1)
+SELF.
*
* *** Define user division and link area like:
*
      CALL MZDIV  (ISTODU, IDIVDU, 'DB-USERS', 50000, 100000, 'L')
      CALL MZLINK (ISTODU, '/DUSER3/', LKTRDU(1), LUSEDU, LKTRDU(1))
*
* *** Initialize DB-Package
*
      CALL TIMEST (999999.)
      CALL DBINIT (IDIVDU, LUNRZ, 'DBL3', LTOP, NREC, 'UZ')
+SELF, IF=-$DEBUG.
      CALL DBLOGL (LUNRZ,  0)
+SELF, IF=$DEBUG.
      CALL DBLOGL (LUNRZ,  2)
+SELF.
*
* *** Create the Fake Data Base
*
      CALL DBCRFD
      IDATX = 800101
      DO 10 I = 1, 3
        CALL DBPKTS (IDATX, 0, ISTRV)
        CALL DBCRFK (ISTRV)
        IDATX = IDATX + 10000
   10 CONTINUE
*
* *** Close Data Base
*
      CALL DBEND
*                                                             END DEXAM3
  999 END
+DECK, DBCRFD.
      SUBROUTINE DBCRFD
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBCRFD                                                  *
*                                                                      *
*   Creates a the directory structure of a fictitious data base        *
*                                                                      *
*   Called by DEXAM3                                                   *
*                                                                      *
************************************************************************
*
      CHARACTER       CRATF*50, CRATT(50)*8
      DATA            NKEX  / 50/
      DATA CRATF/'IIIIIIIIIIHHHHHHHHHHHHHHHHHHHHBBBBBBBBBBBBBBBBBBBB'/
      DATA CRATT/'SERIAL_#','POINTER ','STR_VALI','END_VALI','PRG_VERS',
     +           'FLAGS   ','INS_TIME','UINTEG01','UINTEG02','UINTEG03',
     +           'UHOLL_01','UHOLL_02','UHOLL_03','UHOLL_04','UHOLL_05',
     +           'UHOLL_06','UHOLL_07','UHOLL_08','UHOLL_09','UHOLL_10',
     +           'UHOLL_11','UHOLL_12','UHOLL_13','UHOLL_44','UHOLL_15',
     +           'UHOLL_16','UHOLL_17','UHOLL_18','UHOLL_19','UHOLL_20',
     +           'UBINR_01','UBINR_02','UBINR_03','UBINR_04','UBINR_05',
     +           'UBINR_06','UBINR_07','UBINR_08','UBINR_09','UBINR_10',
     +           'UBINR_11','UBINR_12','UBINR_13','UBINR_44','UBINR_15',
     +           'UBINR_16','UBINR_17','UBINR_18','UBINR_19','UBINR_20'/
*
*     ------------------------------------------------------------------
*
      CALL DBMDIR ('//DBL3/FAKE/CRATES', NKEX, CRATF, CRATT)
*                                                             END DBCRFD
      END
+DECK, DBCRFK.
      SUBROUTINE DBCRFK (ITIM1)
*     =========================
*
************************************************************************
*                                                                      *
*        SUBR. DBCRFK (ITIM1)                                          *
*                                                                      *
*   Creates a complete fictitious Data Base to accommodate 50 keys     *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     ITIM1    Start time of validity                                  *
*                                                                      *
*   Called by DEXAM3                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR3.
+CDE, DUSER3.
      DIMENSION       KEYX(50), K(500,2), P(500,5)
      INTEGER         BITS(20)
      CHARACTER       CHOPT*8, CRATE(20)*4
      DATA            IPROG /1/, XRANG / 1000.0/, XCENT / 500.0/
      DATA            CRATE /'CR01','CR02','CR03','CR04','CR05',
     +                       'CR06','CR07','CR08','CR09','CR10',
     +                       'CR11','CR12','CR13','CR14','CR15',
     +                       'CR16','CR17','CR18','CR19','CR20'/
+SELF, IF=APOLLO.
      DATA            BITS /16#0001, 16#0008, 16#0040, 16#0200, 16#1000,
     +                      16#0001, 16#0009, 16#0041, 16#0201, 16#1001,
     +                      16#0001, 16#0009, 16#0049, 16#0209, 16#1009,
     +                      16#0001, 16#0009, 16#0049, 16#0249, 16#1049/
+SELF, IF=CRAY.
      DATA            BITS /X'0001', X'0008', X'0040', X'0200', X'1000',
     +                      X'0001', X'0009', X'0041', X'0201', X'1001',
     +                      X'0001', X'0009', X'0049', X'0209', X'1009',
     +                      X'0001', X'0009', X'0049', X'0249', X'1049'/
+SELF, IF=IBM.
      DATA            BITS /Z0001, Z0008, Z0040, Z0200, Z1000,
     +                      Z0001, Z0009, Z0041, Z0201, Z1001,
     +                      Z0001, Z0009, Z0049, Z0209, Z1009,
     +                      Z0001, Z0009, Z0049, Z0249, Z1049/
+SELF, IF=HPUX,IBMRT,MIP,VAX.
      DATA            BITS /'0001'X, '0008'X, '0040'X, '0200'X, '1000'X,
     +                      '0001'X, '0009'X, '0041'X, '0201'X, '1001'X,
     +                      '0001'X, '0009'X, '0049'X, '0209'X, '1009'X,
     +                      '0001'X, '0009'X, '0049'X, '0249'X, '1049'X/
+SELF.
*
*     ------------------------------------------------------------------
*
      CALL TIMEX (TIMINT)
      CALL DBUVTX (IDAY, ITIM1)
      NKEX  = 50
*
* *** Prepare the keys for the structure
*
      CALL DBPKTS (991231, 235000, INFIN)
      CALL VZERO (KEYX, NKEX)
      KEYX(3) = ITIM1
      KEYX(4) = INFIN
      KEYX(5) = IPROG
      DO 10 I = 8, 10
        KEYX(I) = 50000*RNDM(I)
   10 CONTINUE
      DO 20 I = 11, 30
        CALL UCTOH (CRATE(I-10), KEYX(I), 4, 4)
   20 CONTINUE
      CALL UCOPY (BITS(1), KEYX(31), 20)
*
* *** Create Data to store with DBOUT 'R' Option  - most general I/O
* ***     (Example is taken from the Generators)
*
      N      = 25
      NDAT   = 2 + 5 + 7*N
      CALL MZFORM ('CRAT', '1I 3F 1I -S', IOCRA)
      CALL MZBOOK (IDIVDU, LUSEDU, LUSEDU, 2, 'CRAT', 0,0,NDAT, IOCRA,0)
*
      IE     = 10001
      DO 35 I = 1, N
        DO 25 J = 1, 2
          K(I,J) = (J-1)*25 + I
   25   CONTINUE
        DO 30 J = 1, 5
          P(I,J) = (J-1)*250. + I*0.1
   30   CONTINUE
   35 CONTINUE
      L      = LUSEDU
      IQ(L+1) = IE
      Q(L+2)  = 0.
      Q(L+3)  = 0.
      Q(L+4)  = 0.
      IQ(L+5) = N
      L      = L + 5
      IQ(L+1) = 16*N*2 + 2
      L      = L + 1
      DO 40 I = 1, N
        IQ(L+1) = K(I,1)
        IQ(L+2) = K(I,2)
        L      = L + 2
   40 CONTINUE
      IQ(L+1) = 16*N*5 + 3
      L      = L + 1
      DO 50 I = 1, N
        DO 45 J = 1, 5
          Q(L+J) = P(I,J)
   45   CONTINUE
        L      = L + 5
   50 CONTINUE
*
      CHOPT = 'RC'
      CALL DBENTR ('//DBL3/FAKE/CRATES', LKTRDU(1), LDTRDU(1),
     +             IDIVDU, LUSEDU, NKEX, KEYX, 0, CHOPT)
      IF (LUSEDU.NE.0)  THEN
        CALL DZSHOW ('CRAT    ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
        CALL MZDROP (IDIVDU, LUSEDU, ' ')
      ENDIF
      CALL UOPTC (CHOPT, 'C', IOPTC)
      IF (IOPTC.NE.0)  THEN
        CALL DZSHOW ('LKTRDU  ', IDIVDU, LKTRDU(1), 'LVB', 0, 0, 0, 0)
        CALL MZDROP (IDIVDU, LKTRDU(1), 'L')
      ENDIF
*
      CALL TIMEX (TIMNOW)
      TIME  = TIMNOW - TIMINT
      CALL DBUVTX (IDAY, ITIM2)
      ITIME = ITIM2 - ITIM1
      WRITE (LPRTDU, 1001) IDAY, ITIM1, ITIM2, ITIME
      WRITE (LPRTDU, 1002) TIMINT, TIMNOW, TIME
*
 1001 FORMAT (/,' DBCRFK : IDAY/ITIM1/ITIM2/ITIME ', 4I12)
 1002 FORMAT (/,' DBCRFK : TIMINT/TIMNOW/TIME ',4G12.4)
*                                                             END DBCRFK
      END
+PATCH, DBEXAM4.
+DECK, DBEXAM4.
+KEEP, DSTOR4.
      COMMON /GCBANK/ FENCDS(22), LQ(9)
      DIMENSION       IQ(2), Q(2)
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))
*
      COMMON /QUEST/  IQUEST(100)
*
+KEEP, DUSER4.
      COMMON /DUSER4/ IDIVDU, ISTODU, LPRTDU, LKTRDU(5), LDTRDU(5)
*
+DECK, DEXAM4.
      PROGRAM DEXAM4
*     ==============
*
************************************************************************
*                                                                      *
*        PROG. DEXAM4                                                  *
*                                                                      *
*   Program to debug DBUSE on a fictitious Data Base                   *
*                                                                      *
*   Program is used to test option 'S' in DBUSE for NKEYS > 9          *
*                                                                      *
************************************************************************
*
      PARAMETER       (NLAST=150000, NDIV1=5000)
      COMMON /GCBANK/ FENCDS(22), LQ(NLAST)
*
+CDE, DUSER4.
*     ------------------------------------------------------------------
*
* *** Open the RZ-file with an Open Statement (or JCL, etc)
*
      LUNRZ  = 1
      LPRTDU = 6
      LREC   = 1024
      NBYTE  = 4*LREC
+SELF, IF=IBM.
      CALL DBROPN (LUNRZ, ' ', 'DBFAKE.DATA.A4', NBYTE, IOERR)
+SELF, IF=-IBM.
      CALL DBROPN (LUNRZ, ' ', 'DBFAKE.DAT', NBYTE, IOERR)
+SELF.
      IF (IOERR.NE.0)        GO TO 999
      CALL MZEBRA (-1)
*
* *** Open the 1 and only 1 Store used in the reconstruction
*
      CALL MZSTOR (ISTODU, '/GCBANK/', ' ', FENCDS(1), LQ(1), LQ(1)
     +           , LQ(1), LQ(NDIV1), LQ(NLAST))
*
* *** Log-Level
*
+SELF, IF=-$DEBUG.
      CALL MZLOGL (ISTODU, 0)
+SELF, IF=$DEBUG.
      CALL MZLOGL (ISTODU, 1)
+SELF.
*
* *** Define user division and link area like:
*
      CALL MZDIV  (ISTODU, IDIVDU, 'DB-USERS', 20000, 30000, 'L')
      CALL MZLINK (ISTODU, '/DUSER4/', LKTRDU(1), LDTRDU(5), LKTRDU(1))
*
* *** Initialize DB-Package
*
      CALL TIMEST (999999.)
      CALL DBINIT (IDIVDU, LUNRZ, 'DBL3', LTOP, 0, ' ')
+SELF, IF=-$DEBUG.
      CALL DBLOGL (LUNRZ, 0)
+SELF, IF=$DEBUG.
      CALL DBLOGL (LUNRZ, 2)
+SELF.
*
* *** Read the Data Base
*
      CALL DBONFK
*
* *** Close DataBase
*
      CALL DBEND
*                                                             END DEXAM4
  999 END
+DECK, DBONFK.
      SUBROUTINE DBONFK
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBONFK                                                  *
*                                                                      *
*   Tests DBUSE with option 'S' and for 50 keys                        *
*                                                                      *
*   Called by DEXAM4                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR4.
+CDE, DUSER4.
      DIMENSION       KEYS(1000)
      CHARACTER       CHOPT*8
*
*
*     ------------------------------------------------------------------
*
      CALL TIMEX (TIMINT)
      CALL DBUVTX (IDAY, ITIM1)
      CALL VZERO (KEYS, 50)
      CALL UCTOH ('CR05', KEYS(15), 4, 4)
      CALL DBPKTS (830101, 90000, ITIME)
      CHOPT = 'SK15'
*
* *** -------------- CRATES ---------------------
*
      CALL DBUSE ('//DBL3/FAKE/CRATES', LKTRDU(1), LDTRDU(1),
     +            ITIME, KEYS, CHOPT)
*
* *** Print linear structure
*
      CALL DZSHOW ('LKTRDU  ', IDIVDU, LKTRDU(1), 'LVB', 0, 0, 0, 0)
*
* *** Test subroutine DBPRIN
*
      CALL DBPRIN ('//DBL3/FAKE/CRATES', 'K')
+SELF, IF=$DEBUG.
      CALL DBPRIN ('//DBL3/FAKE/CRATES', 'D')
+SELF.
      CALL DBFREE ('//DBL3/FAKE/CRATES', LKTRDU(1), KEYS, CHOPT)
*
      CALL TIMEX (TIMNOW)
      TIME  = TIMNOW - TIMINT
      CALL DBUVTX (IDAY, ITIM2)
      ITIME = ITIM2 - ITIM1
      WRITE (LPRTDU, 1001) IDAY, ITIM1, ITIM2, ITIME
      WRITE (LPRTDU, 1002) TIMINT, TIMNOW, TIME
*
 1001 FORMAT (/,' DBONFK : IDAY/ITIM1/ITIM2/ITIME ', 4I12)
 1002 FORMAT (/,' DBONFK : TIMINT/TIMNOW/TIME ',4G12.4)
*                                                             END DBONFK
      END
+PATCH, DBEXAM5.
+DECK, DBEXAM5.
+KEEP, DSTOR5.
      COMMON /GCBANK/ FENCDS(22), LQ(9)
      DIMENSION       IQ(2), Q(2)
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))
*
      COMMON /QUEST/  IQUEST(100)
*
+KEEP, DUSER5.
      COMMON /DUSER5/ ISTODU, IDIVDU, LPRTDU, LDTRDU(5), LKTRDU(5)
     +              , LUSEDU
*
+DECK, DEXAM5.
      PROGRAM DEXAM5
*     ==============
*
************************************************************************
*                                                                      *
*        PROG. DEXAM5                                                  *
*                                                                      *
*   Program to create a fictitious Data Base to test the Package       *
*           including DBENTR, DBMDIR, DBUSE (opt.'S') and nkeys > 9    *
*                                                                      *
*   Creates an immitation of the Trigger Data Base                     *
*                                                                      *
************************************************************************
*
      PARAMETER       (NLAST=150000, NDIV1=5000)
      COMMON /GCBANK/ FENCDS(22), LQ(NLAST)
*
+CDE, DUSER5.
*     ------------------------------------------------------------------
*
* *** Open the RZ-file with an Open Statement (or JCL, etc)
*
      LUNRZ  = 1
      LPRTDU = 6
      NREC   = 1000
      LREC   = 1024
      NBYTE  = 4*LREC
+SELF, IF=IBM.
      CALL DBROPN (LUNRZ, 'ZO', 'DBTRIG.DATA.A4', NBYTE, IOERR)
+SELF, IF=-IBM.
      CALL DBROPN (LUNRZ, 'ZO', 'DBTRIG.DAT', NBYTE, IOERR)
+SELF.
      IF (IOERR.NE.0)        GO TO 999
      CALL MZEBRA (-1)
*
* *** Open the 1 and only 1 Store used in the reconstruction
*
      CALL MZSTOR (ISTODU, '/GCBANK/', ' ', FENCDS(1), LQ(1), LQ(1)
     +           , LQ(1), LQ(NDIV1), LQ(NLAST))
*
* *** Log-Level
*
+SELF, IF=-$DEBUG.
      CALL MZLOGL (ISTODU, 0)
+SELF, IF=$DEBUG.
      CALL MZLOGL (ISTODU, 1)
+SELF.
*
* *** Define user division and link area like:
*
      CALL MZDIV  (ISTODU, IDIVDU, 'DB-USERS', 50000, 100000, 'L')
      CALL MZLINK (ISTODU, '/DUSER5/', LDTRDU(1), LUSEDU, LDTRDU(1))
*
* *** Initialize DB-Package
*
      CALL TIMEST (999999.)
      CALL DBINIT (IDIVDU, LUNRZ, 'DBL3', LTOP, NREC, 'UZ')
+SELF, IF=-$DEBUG.
      CALL DBLOGL (LUNRZ, 0)
+SELF, IF=$DEBUG.
      CALL DBLOGL (LUNRZ, 2)
+SELF.
*
* *** Create the Trigger Data Base
*
      CALL TIMEX (TIMINT)
      CALL DBUVTX (IDAY, ITIM1)
      CALL DBL1ET
*
      CALL TIMEX (TIMNOW)
      TIME  = TIMNOW - TIMINT
      CALL DBUVTX (IDAY, ITIM2)
      ITIME = ITIM2 - ITIM1
      WRITE (LPRTDU, 1001) IDAY, ITIM1, ITIM2, ITIME
      WRITE (LPRTDU, 1002) TIMINT, TIMNOW, TIME
*
* *** Close Data Base
*
      CALL DBEND
*
 1001 FORMAT (/,' DEXAM5 : IDAY/ITIM1/ITIM2/ITIME ', 4I12)
 1002 FORMAT (/,' DEXAM5 : TIMINT/TIMNOW/TIME ',4G12.4)
*                                                             END DEXAM5
  999 END
+DECK, DBBRCA.
      SUBROUTINE DBBRCA (ITIME)
*     =========================
*
************************************************************************
*                                                                      *
*        SUBR. DBBRCA (ITIME)                                          *
*                                                                      *
*   Creates an example of the Branch-Camac vs. Rack-Crate table        *
*   as suggested by T. Hebecker                                        *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     ITIME    Start of time validity                                  *
*                                                                      *
*   Called by DBL1ET                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR5.
+CDE, DUSER5.
      PARAMETER       (NKEX = 11)
      DIMENSION       KEYX(NKEX)
      CHARACTER       CHOPT*8, COMNT*40
      DATA            IPROG/1/, INFIN/773964216/, IFRST/0/
*
*     ------------------------------------------------------------------
*
* *** --------  BRANCH-CAMAC  ----------------------
*
      IFRST = IFRST + 1
      NDAT  = 10
      CHOPT = 'RC'
      CALL MZBOOK (IDIVDU, LUSEDU, LUSEDU, 2, 'BRCA', 0, 0, NDAT, 5, 0)
*
*  ** Comment
*
      COMNT = 'BRANCH-CAMAC VS. RACK-CRATE '
      CALL UCTOH (COMNT, IQ(LUSEDU+1), 4, 40)
*
      CALL VZERO (KEYX, NKEX)
      KEYX(3) = ITIME
      KEYX(4) = INFIN
      KEYX(5) = IPROG
*
*  ** Loop on branch and camac
*
      DO 30 ICR = 1, 20
        DO 25 IBR = 1, 3
          KEYX(8)  = IBR
          KEYX(9)  = ICR
          KEYX(10) = (ICR-1)/4 + 1
          KEYX(11) = MOD (ICR, 4)
          IF (KEYX(11).EQ.0) KEYX(11) = 4
*
          CALL DBENTR ('//DBL3/TRIG/HARDCONF/BRACAM', LKTRDU(3),
     +                 LDTRDU(3), IDIVDU, LUSEDU, NKEX, KEYX, 0, CHOPT)
*
+SELF, IF=$DEBUG.
          IF (LUSEDU.NE.0)  THEN
            CALL DZSHOW ('BRACAM  ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
          ENDIF
+SELF.
          CALL UOPTC (CHOPT, 'C', IOPTC)
          IF (IOPTC.NE.0)  THEN
+SELF, IF=$DEBUG.
            IF ((ICR.EQ.1.OR.ICR.EQ.20).AND.(IBR.EQ.1))  THEN
+SELF, IF=-$DEBUG.
            IF ((ICR.EQ.1).AND.(IBR.EQ.1))  THEN
+SELF.
              CALL DZSHOW ('LKBRACAM', IDIVDU, LKTRDU(3), 'BLV',0,0,0,0)
            ENDIF
            CALL MZDROP (IDIVDU, LKTRDU(3), 'L')
          ENDIF
   25   CONTINUE
   30 CONTINUE
      CALL MZDROP (IDIVDU, LUSEDU, ' ')
*                                                             END DBBRCA
      END
+DECK, DBCBCN.
      SUBROUTINE DBCBCN (ITYP, NICKN, ITIME)
*     =======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBCBCN (ITYP, NICKN, ITIME)                             *
*                                                                      *
*   Creates a table of front pannel cable connections                  *
*   as suggested by T. Hebecker                                        *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     ITYP     Topological module number                               *
*     NICKN    Nickname - unique name for each connection              *
*     ITIME    Start of time validity                                  *
*                                                                      *
*   Called by DBL1ET                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR5.
+CDE, DUSER5.
      PARAMETER       (NKEX = 15)
      DIMENSION       KEYX(NKEX), IOWDS(40)
      CHARACTER       CHOPT*8, COMNT*40
      DATA            IPROG/1/, INFIN/773964216/, IFRST/0/
*
*     ------------------------------------------------------------------
*
* *** --------  CABLE CONNECTIONS  ----------------------
*
      IFRST = IFRST + 1
      NDAT  = 11
      CHOPT = 'RC'
      CALL MZIOCH (IOWDS, 40, '10H -F')
      CALL MZBOOK (IDIVDU, LUSEDU, LUSEDU, 2, 'MDPR', 0,0, NDAT,IOWDS,0)
*
*  ** Comment
*
      COMNT = 'CABLE CONNECTIONS FOR THAT MODULE '
      CALL UCTOH (COMNT, IQ(LUSEDU+1), 4, 40)
*
*  ** Cable length
*
      Q(LUSEDU+11) = 10.0*RNDM (Q)
*
      CALL VZERO (KEYX, NKEX)
      KEYX(3) = ITIME
      KEYX(4) = INFIN
      KEYX(5) = IPROG
*
*  ** Generate Cable connections
*  ** Only the same types are concerned
*  ** # of output cable = # of input cable = ITYP
*  ** Position of the first cable = ITYP
*
      NTOPO = 100*ITYP + 3*ITYP - 2
      NTOPI = NTOPO + 1
      KEYX(8)  = NTOPO
      KEYX(9)  = ITYP
      KEYX(10) = ITYP*2 - 1
      KEYX(11) = NTOPI
      KEYX(12) = KEYX(9)
      KEYX(13) = KEYX(10)
*
*  ** Nickname and polarity
*
      KEYX(14) = NICKN
      CALL UCTOH ('P   ', KEYX(15), 4, 4)
*
      CALL DBENTR ('//DBL3/TRIG/HARDCONF/CABCON', LKTRDU(4), LDTRDU(4),
     +             IDIVDU, LUSEDU, NKEX, KEYX, 0, CHOPT)
*
      IF (LUSEDU.NE.0)  THEN
+SELF, IF=$DEBUG.
        CALL DZSHOW ('CABCON  ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
+SELF.
        CALL MZDROP (IDIVDU, LUSEDU, ' ')
      ENDIF
*
      CALL UOPTC (CHOPT, 'C', IOPTC)
      IF (IOPTC.NE.0)  THEN
+SELF, IF=$DEBUG.
        IF (IFRST.LE.20)  THEN
+SELF, IF=-$DEBUG.
        IF (IFRST.LE.5)  THEN
+SELF.
          CALL DZSHOW ('LKCABCON', IDIVDU, LKTRDU(4), 'BLV',0,0,0,0)
        ENDIF
        CALL MZDROP (IDIVDU, LKTRDU(4), 'L')
      ENDIF
*                                                             END DBCBCN
      END
+DECK, DBCDL1.
      SUBROUTINE DBCDL1
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBCDL1                                                  *
*                                                                      *
*   Creates the directory structure of example Level 1 energy trigger  *
*   Data base                                                          *
*                                                                      *
*   Called by DBL1ET                                                   *
*                                                                      *
************************************************************************
*
      PARAMETER       (NKTPS=3, NKBRA=4, NKMAT=10, NKMOD=7, NKCAB=8)
      CHARACTER       CFTPS*3, CFBRA*4, CFMAT*10, CFMOD*7, CFCAB*8
      CHARACTER*8     CTTPS(3), CTBRA(4), CTMAT(10), CTMOD(7), CTCAB(8)
      DATA            CFTPS /'IHA'/, CFBRA /'IIII'/, CFMOD /'HAHIIII'/
      DATA            CFMAT /'IIIIIIIIII'/, CFCAB /'IIIIIIIH'/
      DATA            CTTPS /'TOPOLOGY', 'SERIAL_1', 'SERIAL_2'/
      DATA            CTBRA /'BRANCH  ', 'CAMAC   ', 'RACK    ',
     +                       'CRATE   '/
      DATA            CTMAT /'TOPOL.NU', 'TYPE    ', 'BRANCH  ',
     +                       'CAMAC   ', 'STATION ', 'TIMING  ',
     +                       'SWITCHES', 'IN/OUT_C', 'RES.OUT1',
     +                       'RES.OUT2'/
      DATA            CTMOD /'SERIAL_1', 'SERIAL_2', 'STATUS  ',
     +                       'MODU_TYP', 'NOBITS  ', 'RES.OUT1',
     +                       'RES.OUT2'/
      DATA            CTCAB /'#OUT_MOD', 'OUT_1ST ', 'OUT_LAST',
     +                       '#INP_MOD', 'INP_1ST ', 'INP_LAST',
     +                       'NICKNAME', 'POLARITY'/
*
*     ------------------------------------------------------------------
*
      CALL DBCRSD ('//DBL3/TRIG/TOPSER', NKTPS, CFTPS, CTTPS, 0, ' ')
      CALL DBCRSD ('//DBL3/TRIG/HARDCONF/BRACAM', NKBRA, CFBRA, CTBRA,
     +             0, ' ')
      CALL DBCRSD ('//DBL3/TRIG/HARDCONF/MODATT', NKMAT, CFMAT, CTMAT,
     +             0, ' ')
      CALL DBCRSD ('//DBL3/TRIG/MODPRP', NKMOD, CFMOD, CTMOD, 0, ' ')
      CALL DBCRSD ('//DBL3/TRIG/HARDCONF/CABCON', NKCAB, CFCAB, CTCAB,
     +             0, ' ')
*                                                             END DBCDL1
      END
+DECK, DBL1ET.
      SUBROUTINE DBL1ET
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBL1ET                                                  *
*                                                                      *
*   Creates an example of the Level 1 Energy Trigger as suggested by   *
*   T. Hebecker                                                        *
*                                                                      *
*   Called by DEXAM5                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR5.
+CDE, DUSER5.
      DIMENSION       KEYX(50), KEYO(50)
      CHARACTER       CHOPT*8, COMNT*40
      CHARACTER       MODU1*4, MODU2*4, MODU5(5)*1, SERNO*8, SEROL*8
      DATA            IPROG /1/, INFIN /773964216/
      DATA            MODU1 /'XMOD'/, MODU5 /'A','B','C','D','E'/
*
*     ------------------------------------------------------------------
*
* *** --------  TOPSER  ----------------------
*
      NKEX  = 10
      CALL DBCDL1
*
*  ** 10 data words reserved for comments (40 characters)
*
      NDAT  = 10
*
*  ** Set-up TOPSER at time IT1  and date ID1
*
      ID1   = 870731
      IT1   = 103000
      CALL DBPKTS (ID1, IT1, IDT1)
*
*  ** Set up Branch-Camac vs. Rack-crate table
*
      CALL DBBRCA (IDT1)
*
      DO 30 I = 1, 50
        CALL VZERO (KEYX, NKEX)
        KEYX(3) = IDT1
        KEYX(4) = INFIN
        KEYX(5) = IPROG
*
*  *    Topological Module
*
        ITYP  = I/3 + 1
        KEYX(8) = 100*ITYP + I
*
*  *    Set up Module Attributes (i.e. prescribed properties)
*
        CALL DBMATT (KEYX(8), IDT1)
*
*  *    Serial Number of Module
*
        J     = (I-1)/10 + 1
        MODU1(1:1) = MODU5(J)
        CALL UCTOH (MODU1, KEYX(9), 4, 4)
        IMODU = 10*I
        WRITE (MODU2, 1001) IMODU
        CALL UCTOH (MODU2, KEYX(10), 4, 4)
*
*  **   Store Module Properties
*
        SERNO = MODU1//MODU2
        SEROL = SERNO
        CALL DBMODP (SEROL, SERNO, ITYP, IDT1)
        CHOPT = 'RC'
        CALL MZBOOK (IDIVDU, LUSEDU, LUSEDU, 2, 'TPSR', 0, 0, NDAT, 5,0)
*
*  *    Comment
*
        COMNT = 'TOPSER AT 870731 103000'
        CALL UCTOH (COMNT, IQ(LUSEDU+1), 4, 40)
        CALL DBENTR ('//DBL3/TRIG/TOPSER', LKTRDU(1), LDTRDU(1),
     +               IDIVDU, LUSEDU, NKEX, KEYX, 0, CHOPT)
        IF (LUSEDU.NE.0)  THEN
+SELF, IF=$DEBUG.
          CALL DZSHOW ('TOPSER  ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
+SELF.
          CALL MZDROP (IDIVDU, LUSEDU, ' ')
        ENDIF
        CALL UOPTC (CHOPT, 'C', IOPTC)
        IF (IOPTC.NE.0)  THEN
+SELF, IF=$DEBUG.
          IF (I.EQ.1.OR.I.EQ.50) THEN
+SELF, IF=-$DEBUG.
          IF (I.EQ.1) THEN
+SELF.
            CALL DZSHOW ('LKTOPSER', IDIVDU, LKTRDU(1), 'BLV', 0,0, 0,0)
          ENDIF
          CALL MZDROP (IDIVDU, LKTRDU(1), 'L')
        ENDIF
   30 CONTINUE
*
*  ** Change first 20 TOPSER at time IT2  and date ID2
*
      ID2   = 880731
      IT2   = 163000
      CALL DBPKTS (ID2, IT2, IDT2)
*
      DO 40 I = 1, 20
        CALL VZERO (KEYX, NKEX)
        KEYX(3) = IDT2
        KEYX(4) = INFIN
        KEYX(5) = IPROG
*
*  *    Topological Module
*
        ITYP  = I/3 + 1
        KEYX(8) = 100*ITYP + I
*
*  *    Serial Number of Module
*
        J     = (I-1)/10 + 1
        MODU1(1:1) = 'X'
        CALL UCTOH (MODU1, KEYX(9), 4, 4)
        IMODU = 10*I
        WRITE (MODU2, 1001) IMODU
        CALL UCTOH (MODU2, KEYX(10), 4, 4)
*
*  **   Store Module Properties
*
        SERNO = MODU1//MODU2
        MODU1(1:1) = MODU5(J)
        SEROL  = MODU1//MODU2
        CALL DBMODP (SEROL, SERNO, ITYP, IDT2)
        CALL UCOPY (KEYX, KEYO, NKEX)
        CALL UCTOH (SEROL, KEYO(9), 4, 8)
        CHOPT = 'RC'
        CALL MZBOOK (IDIVDU, LUSEDU, LUSEDU, 2, 'TPSR', 0, 0, NDAT, 5,0)
*
*  *    Comment
*
        COMNT = 'TOPSER AT 880731 163000'
        CALL UCTOH (COMNT, IQ(LUSEDU+1), 4, 40)
        CALL DBREPL ('//DBL3/TRIG/TOPSER', LKTRDU(1), LDTRDU(1),
     +               IDIVDU, LUSEDU, NKEX, KEYO, KEYX, 0, CHOPT)
        IF (LUSEDU.NE.0)  THEN
+SELF, IF=$DEBUG.
          CALL DZSHOW ('TOPSER  ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
+SELF.
          CALL MZDROP (IDIVDU, LUSEDU, ' ')
        ENDIF
        CALL UOPTC (CHOPT, 'C', IOPTC)
        IF (IOPTC.NE.0)  THEN
+SELF, IF=$DEBUG.
          IF (I.EQ.1.OR.I.EQ.20) THEN
+SELF, IF=-$DEBUG.
          IF (I.EQ.1) THEN
+SELF.
            CALL DZSHOW ('LKTOPSER', IDIVDU, LKTRDU(1), 'BLV', 0,0, 0,0)
          ENDIF
          CALL MZDROP (IDIVDU, LKTRDU(1), 'L')
        ENDIF
   40 CONTINUE
*
*  ** Change last 20 TOPSER at time IT3  and date ID3
*
      ID3   = 900131
      IT3   = 221500
      CALL DBPKTS (ID3, IT3, IDT3)
*
      DO 50 I = 31, 50
        CALL VZERO (KEYX,NKEX)
        KEYX(3) = IDT3
        KEYX(4) = INFIN
        KEYX(5) = IPROG
*
*  *    Topological Module
*
        ITYP  = I/3 + 1
        KEYX(8) = 100*ITYP + I
*
*  *    Serial Number of Module
*
        J     = (I-1)/10 + 1
        MODU1(1:1) = 'Y'
        CALL UCTOH (MODU1, KEYX(9), 4, 4)
        IMODU = 10*I
        WRITE (MODU2, 1001) IMODU
        CALL UCTOH (MODU2, KEYX(10), 4, 4)
*
*  **   Store Module Properties
*
        SERNO = MODU1//MODU2
        MODU1(1:1) = MODU5(J)
        SEROL  = MODU1//MODU2
        CALL DBMODP (SEROL, SERNO, ITYP, IDT3)
        CALL UCOPY (KEYX, KEYO, NKEX)
        CALL UCTOH (SEROL, KEYO(9), 4, 8)
        CHOPT = 'R'
        CALL MZBOOK (IDIVDU, LUSEDU, LUSEDU, 2, 'TPSR', 0, 0, NDAT, 5,0)
*
*  *    Comment
*
        COMNT = 'TOPSER AT 900131 221500'
        CALL UCTOH (COMNT, IQ(LUSEDU+1), 4, 40)
        CALL DBREPL ('//DBL3/TRIG/TOPSER', LKTRDU(1), LDTRDU(1),
     +               IDIVDU, LUSEDU, NKEX, KEYO, KEYX, 0, CHOPT)
        IF (LUSEDU.NE.0)  THEN
+SELF, IF=$DEBUG.
          CALL DZSHOW ('TOPSER  ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
+SELF.
          CALL MZDROP (IDIVDU, LUSEDU, ' ')
        ENDIF
        CALL UOPTC (CHOPT, 'C', IOPTC)
        IF (IOPTC.NE.0)  THEN
+SELF, IF=$DEBUG.
          IF (I.EQ.31.OR.I.EQ.50) THEN
+SELF, IF=-$DEBUG.
          IF (I.EQ.31) THEN
+SELF.
            CALL DZSHOW ('LKTOPSER', IDIVDU, LKTRDU(1), 'BLV', 0,0, 0,0)
          ENDIF
          CALL MZDROP (IDIVDU, LKTRDU(1), 'L')
        ENDIF
   50 CONTINUE
*
*  ** The propeerties of the last two modules are changed at ID4 and IT4
*
      ID4   = 920101
      IT4   = 103000
      CALL DBPKTS (ID4, IT4, IDT4)
      CALL DBMODP ('YMOD 490', 'YMOD 490', ITYP, IDT4)
      CALL DBMODP ('YMOD 500', 'YMOD 500', ITYP, IDT4)
*
*  ** Set up Cable Connections
*
      NICKN = 0
      DO 60 ITYP = 1, 17
        NICKN = NICKN + 1
        CALL DBCBCN (ITYP, NICKN, IDT1)
   60 CONTINUE
*
 1001 FORMAT (I4)
*                                                             END DBL1ET
      END
+DECK, DBMATT.
      SUBROUTINE DBMATT (NTOP, ITIME)
*     ===============================
*
************************************************************************
*                                                                      *
*        SUBR. DBMATT (NTOP, ITIME)                                    *
*                                                                      *
*   Creates table of Module - attributes (prescribed module properties)*
*   as suggested by T. Hebecker                                        *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     NTOP     Topological Module number                               *
*     ITIME    Start of time validity                                  *
*                                                                      *
*   Called by DBL1ET                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR5.
+CDE, DUSER5.
      PARAMETER       (NKEX = 17)
      DIMENSION       KEYX(NKEX)
      CHARACTER       CHOPT*8, COMNT*40
      DATA            IPROG/1/, INFIN/773964216/, IFRST/0/
*
*     ------------------------------------------------------------------
*
* *** --------  MODULE ATTRIBUTES  ----------------------
*
      IFRST = IFRST + 1
      NDAT  = 10
      CHOPT = 'RC'
      CALL MZBOOK (IDIVDU, LUSEDU, LUSEDU, 2, 'MATT', 0, 0, NDAT, 5, 0)
*
*  ** Comment
*
      COMNT = 'PRESCRIBED PROPERTIES OF THAT MODULE '
      CALL UCTOH (COMNT, IQ(LUSEDU+1), 4, 40)
*
      CALL VZERO (KEYX, NKEX)
      KEYX(3) = ITIME
      KEYX(4) = INFIN
      KEYX(5) = IPROG
*
      KEYX(8) = NTOP
      ITYP  = NTOP/100
      KEYX(9) = ITYP
*
*  ** Generate Branch, Camac and Station number
*
      KEYX(10) = MOD (NTOP, 3)
      IF (KEYX(10).EQ.0) KEYX(10) = 3
      KEYX(11) = NTOP/100 + 1
      KEYX(12) = 21.0*RNDM(Q) - 1.0
*
*  ** Generate Relative Timing and Switches
*
      KEYX(13) = 0
      KEYX(14) = 0
      IF (ITYP.EQ.5) KEYX(14) = 11
*
*  ** Generate In/Out Cables and Resistors
*
      NCIN  = ITYP
      NCOUT = ITYP
      KEYX(15) = 1000*NCIN + NCOUT
      KEYX(16) = KEYX(15)
      KEYX(17) = ITYP*1000
*
      CALL DBENTR ('//DBL3/TRIG/HARDCONF/MODATT', LKTRDU(5), LDTRDU(5),
     +             IDIVDU, LUSEDU, NKEX, KEYX, 0, CHOPT)
      IF (LUSEDU.NE.0)  THEN
+SELF, IF=$DEBUG.
        CALL DZSHOW ('MODATT  ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
+SELF.
        CALL MZDROP (IDIVDU, LUSEDU, ' ')
      ENDIF
*
      CALL UOPTC (CHOPT, 'C', IOPTC)
      IF (IOPTC.NE.0)  THEN
+SELF, IF=$DEBUG.
        IF (IFRST.LE.20)  THEN
+SELF, IF=-$DEBUG.
        IF (IFRST.LE.5)  THEN
+SELF.
          CALL DZSHOW ('LKMODATT', IDIVDU, LKTRDU(5), 'BLV', 0, 0, 0, 0)
        ENDIF
        CALL MZDROP (IDIVDU, LKTRDU(5), 'L')
      ENDIF
*                                                             END DBMATT
      END
+DECK, DBMODP.
      SUBROUTINE DBMODP (SEROL, SERNO, ITYP, ITIME)
*     =============================================
*
************************************************************************
*                                                                      *
*        SUBR. DBMODP (SEROL, SERNO, ITYP, ITIME)                      *
*                                                                      *
*   Creates an example of the Properties of the Modules                *
*   as suggested by T. Hebecker                                        *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     SEROL    Serial number of the old module                         *
*     SERNO    Serial number of the Module                             *
*     ITYP     Type of the module                                      *
*     ITIME    Start of time validity                                  *
*                                                                      *
*   Called by DBL1ET                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR5.
+CDE, DUSER5.
      PARAMETER       (NKEX = 14)
      DIMENSION       IOWDS(40), KEYX(NKEX), KEYO(NKEX)
      CHARACTER       CHOPT*8, COMNT*40
      CHARACTER       SERNO*8, STATU*4, SEROL*8
      LOGICAL         FERA
      DATA            IPROG/1/, INFIN/773964216/, IFRST/0/
*
*     ------------------------------------------------------------------
*
* *** --------  MODPRP  ----------------------
*
      IFRST = IFRST + 1
      CALL VZERO (KEYX, NKEX)
      KEYX(3) = ITIME
      KEYX(4) = INFIN
      KEYX(5) = IPROG
*
*  *  Serial Number of Module
*
      CALL UCTOH (SERNO, KEYX(8), 4, 8)
*
*  *  Status
*
      STATU = 'Y   '
      CALL UCTOH (STATU, KEYX(10), 4, 4)
*
*  *  Integer keys
*
      FERA  = ITYP.EQ.5
      NCIN  = ITYP
      NCOUT = ITYP
      KEYX(11) = ITYP
      KEYX(12) = 0
      IF (FERA) KEYX(12) = 11
      KEYX(13) = 1000*NCIN + NCOUT
      KEYX(14) = ITYP*1000
      CALL UCOPY (KEYX, KEYO, NKEX)
      CALL UCTOH (SEROL, KEYO(8), 4, 8)
*
*  *  ADC - Information  (If FERA = 'F   ')
*
      IF (FERA) THEN
        NDAT  = 127
        CALL MZIOCH (IOWDS, 40, '10H 5F 16I 80F -H')
      ELSE
        NDAT  = 15
        CALL MZIOCH (IOWDS, 40, '10H -F')
      ENDIF
*
      CHOPT = 'RC'
      CALL MZBOOK (IDIVDU, LUSEDU, LUSEDU, 2, 'MDPR', 0,0, NDAT,IOWDS,0)
      IF (FERA) THEN
*
*  **   ADC - Data
*
        LWU  = LUSEDU + 15
        DO 30 I = 1, 16
*                        Channel #
          IQ(LWU+I) = I-1
*                        Pedestals
          Q (LWU+16+I) = 35. + 10.*RNDM(Q)
*                        R.M.S.
          Q (LWU+32+I) = RNDM(Q)
*                        Slopes
          Q (LWU+48+I) = 1. + 0.05*(RNDM(Q)-0.5)
*                        Intercepts
          Q (LWU+64+I) = 1.5*(RNDM(Q)-0.5)
*                        Chi-squares
          Q (LWU+80+I) = 2.*RNDM(Q)
*                        OK ?
          CALL UCTOH ('Y   ', IQ(LWU+96+I), 4, 4)
   30   CONTINUE
      ENDIF
*
*  ** Comment
*
      COMNT = 'MODULE PROPERTIES           '
      CALL UCTOH (COMNT, IQ(LUSEDU+1), 4, 40)
*
*  ** Floating data
*
      Q(LUSEDU+11) = 99. * RNDM(Q)
      Q(LUSEDU+12) = 99. * RNDM(Q)
      Q(LUSEDU+13) = 0.
      Q(LUSEDU+14) = 0.
      Q(LUSEDU+15) = 0.
*
      IF (SEROL.EQ.SERNO)  THEN
        CALL DBENTR ('//DBL3/TRIG/MODPRP', LKTRDU(2), LDTRDU(2),
     +               IDIVDU, LUSEDU, NKEX, KEYX, 0, CHOPT)
      ELSE
        CALL DBREPL ('//DBL3/TRIG/MODPRP', LKTRDU(2), LDTRDU(2),
     +               IDIVDU, LUSEDU, NKEX, KEYO, KEYX, 0, CHOPT)
      ENDIF
      IF (LUSEDU.NE.0)  THEN
+SELF, IF=$DEBUG.
        CALL DZSHOW ('MODPRP  ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
+SELF, IF=-$DEBUG.
        IF (MOD(IFRST,50).EQ.1)
     +    CALL DZSHOW ('MODPRP  ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
+SELF.
        CALL MZDROP (IDIVDU, LUSEDU, ' ')
      ENDIF
*
      CALL UOPTC (CHOPT, 'C', IOPTC)
      IF (IOPTC.NE.0)  THEN
+SELF, IF=$DEBUG.
        CALL DZSHOW ('LKMODPRP', IDIVDU, LKTRDU(2), 'BLV', 0, 0, 0, 0)
+SELF.
        CALL MZDROP (IDIVDU, LKTRDU(2), 'L')
      ENDIF
*                                                             END DBMODP
      END
+PATCH, DBEXAM6.
+DECK, DBEXAM6.
+KEEP, DSTOR6.
      COMMON /GCBANK/ FENCDS(22), LQ(9)
      DIMENSION       IQ(2), Q(2)
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))
*
      COMMON /QUEST/  IQUEST(100)
*
+KEEP, DUSER6.
      COMMON /DUSER6/ IDIVDU, ISTODU, LPRTDU, LDTRDU(12), LKTRDU(12)
*
+DECK, DEXAM6.
      PROGRAM DEXAM6
*     ==============
*
************************************************************************
*                                                                      *
*        PROG. DEXAM6                                                  *
*                                                                      *
*   Program to use a fictitious Trigger Data Base for energy level     *
*   trigger as suggested by T. Hebecker                                *
*                                                                      *
*   This is an example how one can use DBL3 to imitate a relational    *
*   Data base system                                                   *
*                                                                      *
************************************************************************
*
      PARAMETER       (NLAST=150000, NDIV1=5000)
      COMMON /GCBANK/ FENCDS(22), LQ(NLAST)
*
+CDE, DUSER6.
*     ------------------------------------------------------------------
*
* *** Open the RZ-file with an Open Statement (or JCL, etc)
*
      LUNRZ  = 1
      LPRTDU = 6
      LREC   = 1024
      NBYTE  = 4*LREC
+SELF, IF=IBM.
      CALL DBROPN (LUNRZ, ' ', 'DBTRIG.DATA.A4', NBYTE, IOERR)
+SELF, IF=-IBM.
      CALL DBROPN (LUNRZ, ' ', 'DBTRIG.DAT', NBYTE, IOERR)
+SELF.
      IF (IOERR.NE.0)        GO TO 999
      CALL MZEBRA (-1)
*
* *** Open the 1 and only 1 Store used in the reconstruction
*
      CALL MZSTOR (ISTODU, '/GCBANK/', ' ', FENCDS(1), LQ(1), LQ(1)
     +           , LQ(1), LQ(NDIV1), LQ(NLAST))
*
* *** Log-Level
*
+SELF, IF=-$DEBUG.
      CALL MZLOGL (ISTODU, 0)
+SELF, IF=$DEBUG.
      CALL MZLOGL (ISTODU, 1)
+SELF.
*
* *** Define user division and link area like:
*
      CALL MZDIV  (ISTODU, IDIVDU, 'DB-USERS', 50000, 100000, 'L')
      CALL MZLINK (ISTODU, '/DUSER6/', LDTRDU(1), LKTRDU(12), LDTRDU(1))
*
* *** Initialize DB-Package
*
      CALL TIMEST (999999.)
      CALL DBINIT (IDIVDU, LUNRZ, 'DBL3', LTOP, 0, ' ')
+SELF, IF=-$DEBUG.
      CALL DBLOGL (LUNRZ, 0)
+SELF, IF=$DEBUG.
      CALL DBLOGL (LUNRZ, 2)
+SELF.
*
* *** Read the Trigger Data Base - Query it for a given time IDT1
*
      CALL TIMEX (TIMINT)
      CALL DBUVTX (IDAY, ITIM1)
      ID1    = 890101
      IT1    = 220000
      CALL DBPKTS (ID1, IT1, IDT1)
      CALL DBRL1E (IDT1)
*
      CALL TIMEX (TIMNOW)
      TIME  = TIMNOW - TIMINT
      CALL DBUVTX (IDAY, ITIM2)
      ITIME = ITIM2 - ITIM1
      WRITE (LPRTDU, 1001) IDAY, ITIM1, ITIM2, ITIME
      WRITE (LPRTDU, 1002) TIMINT, TIMNOW, TIME
*
* *** Close DataBase
*
      CALL DBEND
*
 1001 FORMAT (/,' DEXAM6 : IDAY/ITIM1/ITIM2/ITIME ', 4I12)
 1002 FORMAT (/,' DEXAM6 : TIMINT/TIMNOW/TIME ',4G12.4)
*                                                             END DEXAM6
  999 END
+DECK, DBRL1E.
      SUBROUTINE DBRL1E (ITIME)
*     =========================
*
************************************************************************
*                                                                      *
*        SUBR. DBRL1E (ITIME)                                          *
*                                                                      *
*   Query of the Trigger Data Base for a given time                    *
*   as suggested by T. Hebecker                                        *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     ITIME    Time for which the query refers                         *
*                                                                      *
*   Called by DEXAM6                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR6.
+CDE, DUSER6.
      DIMENSION       KEY1(100), KEY2(100), KEY3(100), KEY4(100)
      DIMENSION       KEY5(100), KEY6(100), KEY7(100), KEY8(100)
      CHARACTER       COMNT*40, SERNB*8, STATU*4, OK*4, POLAR*4
      CHARACTER       CHOP1*20, CHOP2*20, CHOP3*20, CHOP4*20
      CHARACTER       CHOP5*20, CHOP6*20, CHOP7*20, CHOP8*20
      LOGICAL         FERA
      INTEGER         RESOU1, RESOU2
*
*     ------------------------------------------------------------------
*
* *** Unpack date and time
*
      CALL DBUPTS (ID1, IT1, ITIME)
*
* *** Find all modules (Topological number) in Rack # IRCK
* *** and perform further querries to these modules
*
      DO 100 IRCK = 1, 5
        WRITE (LPRTDU, 1001) IRCK
*
*  **   Camac number
*
        CALL VZERO (KEY5, 50)
        KEY5(10) = IRCK
        CHOP5 = 'SK10'
        CALL DBUSE ('//DBL3/TRIG/HARDCONF/BRACAM', LKTRDU(5), LDTRDU(5),
     +              ITIME, KEY5, CHOP5)
*
        IF (LKTRDU(5).EQ.0) THEN
          WRITE (LPRTDU, 1002)
          GO TO 100
        ENDIF
*
        NK5   = NZBANK (IDIVDU, LKTRDU(5))
        LKTRDU(9) = LKTRDU(5)
        DO 90 IK5 = 1, NK5
          IF (LKTRDU(9).EQ.0)             GO TO 95
          IBRA  = IQ(LKTRDU(9)+8)
          ICAM  = IQ(LKTRDU(9)+9)
          WRITE (LPRTDU, 1003) ICAM, IBRA
*
*  **     Module number
*
          CALL VZERO (KEY6, 50)
          KEY6(10) = IBRA
          KEY6(11) = ICAM
          CHOP6 = 'KS1011'
          CALL DBUSE ('//DBL3/TRIG/HARDCONF/MODATT', LKTRDU(6),
     +                LDTRDU(6), ITIME, KEY6, CHOP6)
*
          IF (LKTRDU(6).EQ.0)  THEN
            WRITE (LPRTDU, 1004)
            GO TO 90
          ENDIF
*
          NK6   = NZBANK (IDIVDU, LKTRDU(6))
          LKTRDU(10) = LKTRDU(6)
          DO 80 IK6 = 1, NK6
            IF (LKTRDU(10).EQ.0)          GO TO 85
            IMOD  = IQ(LKTRDU(10)+8)
            WRITE (LPRTDU, 1005) IMOD
*
*  **       Find the cable connections of that module
*  *        Output cables
*
            CALL VZERO (KEY7, 50)
            CHOP7 = 'SK8'
            KEY7(8) = IMOD
            CALL DBUSE ('//DBL3/TRIG/HARDCONF/CABCON', LKTRDU(7),
     +                  LDTRDU(7), ITIME, KEY7, CHOP7)
*
*  *         Print input cables (start-end, #, nicknumber and polarity)
*
            NK7  = NZBANK (IDIVDU, LKTRDU(7))
            IF (NK7.LE.0)  THEN
              WRITE (LPRTDU, 1006)
              GO TO 20
            ENDIF
            LKTRDU(11) = LKTRDU(7)
            DO 10 IK7 = 1, NK7
              IF (LKTRDU(11).EQ.0)        GO TO 20
              L11   = LKTRDU(11)
              CALL UHTOC (IQ(L11+15), 4, POLAR, 4)
              WRITE (LPRTDU, 1007) IQ(L11+9), IQ(L11+10), IQ(L11+11),
     +                             IQ(L11+12), IQ(L11+13), IQ(L11+14),
     +                             POLAR
   10       LKTRDU(11) = LQ(LKTRDU(11))
*
   20       CALL DBFREE ('//DBL3/TRIG/HARDCONF/CABCON', LKTRDU(7), KEY7,
     +                   CHOP7)
*
*  *        Input cables
*
            CALL VZERO (KEY7, 50)
            CHOP7 = 'SK11'
            KEY7(11) = IMOD
            CALL DBUSE ('//DBL3/TRIG/HARDCONF/CABCON', LKTRDU(7),
     +                  LDTRDU(7), ITIME, KEY7, CHOP7)
*
*  *         Print output cables (start-end, #, nicknumber and polarity)
*
            NK7  = NZBANK (IDIVDU, LKTRDU(7))
            IF (NK7.LE.0)  THEN
              WRITE (LPRTDU, 1008)
              GO TO 40
            ENDIF
            LKTRDU(11) = LKTRDU(7)
            DO 30 IK7 = 1, NK7
              IF (LKTRDU(11).EQ.0)        GO TO 40
              L11   = LKTRDU(11)
              CALL UHTOC (IQ(L11+15), 4, POLAR, 4)
              WRITE (LPRTDU, 1009) IQ(L11+12), IQ(L11+13), IQ(L11+8),
     +                             IQ(L11+9), IQ(L11+10), IQ(L11+14),
     +                             POLAR
   30       LKTRDU(11) = LQ(LKTRDU(11))
*
   40       CALL DBFREE ('//DBL3/TRIG/HARDCONF/CABCON', LKTRDU(7), KEY7,
     +                   CHOP7)
*
*  **       Find the serial number of that module
*
            CALL VZERO (KEY1, 50)
            CHOP1 = '8'
            KEY1(8) = IMOD
            CALL DBUSE ('//DBL3/TRIG/TOPSER', LKTRDU(1), LDTRDU(1),
     +                  ITIME, KEY1, CHOP1)
*
*  **       Print serial # with the comment
*
            CALL UHTOC (IQ(LKTRDU(1)+9), 4, SERNB, 8)
            CALL UHTOC (IQ(LDTRDU(1)+1), 4, COMNT, 40)
            WRITE (LPRTDU, 1010) SERNB, KEY1(8), ID1, IT1, COMNT
*
            CALL DBFREE ('//DBL3/TRIG/TOPSER', LKTRDU(1), KEY1, CHOP1)
*
*  **       Print the properties of that particular module
*
            CALL VZERO (KEY2, 50)
            CALL UCTOH (SERNB, KEY2(8), 4, 8)
            CHOP2 = '89'
            CALL DBUSE ('//DBL3/TRIG/MODPRP', LKTRDU(2), LDTRDU(2),
     +                  ITIME, KEY2, CHOP2)
*
            CALL UHTOC (IQ(LKTRDU(2)+10), 4, STATU, 4)
            ITYP   = IQ(LKTRDU(2)+11)
            FERA   = ITYP.EQ.5
            NOBITS = IQ(LKTRDU(2)+12)
            RESOU1 = IQ(LKTRDU(2)+13)
            RESOU2 = IQ(LKTRDU(2)+14)
            CALL UHTOC (IQ(LDTRDU(2)+1), 4, COMNT, 40)
*
            WRITE (LPRTDU, 1011) SERNB, STATU, ITYP, NOBITS, RESOU1,
     +                           RESOU2, COMNT
            IF (FERA) THEN
              WRITE (LPRTDU,1012)
              LDT    = LDTRDU(2) + 15
              DO 50 I = 1, 16
                CALL UHTOC (IQ(LDT+96+I), 4, OK, 4)
                WRITE (LPRTDU, 1013) IQ(LDT+I), Q(LDT+16+I), Q(LDT+32+I)
     +                             , Q(LDT+48+I), Q(LDT+64+I)
     +                             , Q(LDT+80+I), OK
   50         CONTINUE
            ENDIF
*
            CALL DBFREE ('//DBL3/TRIG/MODPRP', LKTRDU(2), KEY2, CHOP2)
*
*  **       Find all serial # which can satisfy the properties of module
*  **       First find the requested module properties
*
            CALL VZERO (KEY3, 50)
            CHOP3  = 'K8'
            KEY3(8) = IMOD
*
            CALL DBUSE ('//DBL3/TRIG/HARDCONF/MODATT', LKTRDU(3),
     +                  LDTRDU(3), ITIME, KEY3, CHOP3)
            ITYPE  = IQ(LKTRDU(3)+9)
            RESOU1 = IQ(LKTRDU(3)+16)
            RESOU2 = IQ(LKTRDU(3)+17)
*
            CALL DBFREE ('//DBL3/TRIG/HARDCONF/MODATT', LKTRDU(3), KEY3,
     +                   CHOP3)
*
*  **       Next find all the serial numbers
*
            CHOP4  = 'VKS10111314'
            STATU  = 'Y   '
            CALL VZERO (KEY4, 50)
            CALL UCTOH (STATU, KEY4(10), 4, 4)
            KEY4(11) = ITYPE
            KEY4(13) = RESOU1
            KEY4(14) = RESOU2
*
            CALL DBUSE ('//DBL3/TRIG/MODPRP', LKTRDU(4), LDTRDU(4),
     +                  ITIME, KEY4, CHOP4)
            WRITE (LPRTDU, 1014) IMOD
            LKT    = LKTRDU(4)
            NS4    = NZBANK (IDIVDU, LKT)
            IF (NS4.GT.0)  THEN
   60         CALL UHTOC (IQ(LKT+8), 4, SERNB, 8)
              WRITE (LPRTDU, 1015) SERNB
              LKT    = LQ(LKT)
              IF (LKT.NE.0)               GO TO 60
            ENDIF
*
            CALL DBFREE ('//DBL3/TRIG/MODPRP', LKTRDU(4), KEY4, CHOP4)
+SELF, IF=$DEBUG.
            CALL DZSHOW ('LKTRDU4 ', IDIVDU, LKTRDU(4), 'LVB', 0,0, 0,0)
+SELF.
*
   80     LKTRDU(10) = LQ(LKTRDU(10))
   85     CALL DBFREE ('//DBL3/TRIG/HARDCONF/MODATT', LKTRDU(6), KEY6,
     +                 CHOP6)
*
   90   LKTRDU(9) = LQ(LKTRDU(9))
   95   CALL  DBFREE ('//DBL3/TRIG/HARDCONF/BRACAM', LKTRDU(5), KEY5,
     +                CHOP5)
*
  100 CONTINUE
*
 1001 FORMAT (/5X,' ========== Rack Number : ',I5,' =========='//)
 1002 FORMAT (/10X,' +++ There is no Camac in this Rack !!! ')
 1003 FORMAT (/10X,' +++ Camac Number : ',I5,' Branch Number : ',I5
     +,' +++')
 1004 FORMAT (/15X,' --- There is NO Module in this Camac !!! ')
 1005 FORMAT (/15X,' --- Module Number : ',I5,' ---')
 1006 FORMAT (/10X,' ... There is NO output cable from this Module !!!')
 1007 FORMAT (/10X,' ... Cables from plugs :',I4,' -',I4,
     +        '   to module :',I8,' and plugs :',I4,' -',I4,I10,2X,A4)
 1008 FORMAT (/10X,' ... There is NO  input cable   to this Module !!!')
 1009 FORMAT (/10X,' ... Cables   to plugs :',I4,' -',I4,
     +        ' from module :',I8,' and plugs :',I4,' -',I4,I10,2X,A4)
 1010 FORMAT (/2X,'Module number : ',A8,' for topological no. :',I6
     +,' and validity : ',2I7,2X,A40)
 1011 FORMAT (/2X,'Properties of Module : ',A8,' Status  Modul type'
     +,'   Nobits  Res.Out1  Res.Out2     Comment'/36X,A4,4X,I4,3X,3I10
     +,5X,A40)
 1012 FORMAT (/20X,'  ADC - Properties  ',2X
     +,'Channel Pedest   R.M.S.    Slope  Intercept   Chi2  OK?'/)
 1013 FORMAT (45X,I2,5F9.3,2X,A4)
 1014 FORMAT (/20X,' --- All serial numbers for Module : ',I10,' ---'/)
 1015 FORMAT (25X,A8)
*                                                             END DBRL1E
  999 END
+PATCH, DBEXAM7.
+DECK, DBEXAM7.
+KEEP, DSTOR7.
      COMMON /DSTOR7/ FENCDS(22), LQ(9)
      DIMENSION       IQ(2), Q(2)
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))
*
      COMMON /QUEST/  IQUEST(100)
*
+KEEP, DUSER7.
      COMMON /DUSER7/ ISTODU, IDIVDU, LPRTDU, LDUVDU, LKUVDU, LUSEDU
*
+DECK, DEXAM7.
      PROGRAM DEXAM7
*     ==============
*
************************************************************************
*                                                                      *
*        PROG. DEXAM7                                                  *
*                                                                      *
*   Program to create a fictitious database to test the partitioned    *
*   directory (DBENTR with option P at the time of creating the user   *
*   directory)                                                         *
*                                                                      *
*   This program uses a different store from /GCBANK/ and hence both   *
*   the user division and the ZEBRA system division refer to the new   *
*   store /DSTOR7/ and tests the new feature of version 3.00 of DBL3   *
*                                                                      *
************************************************************************
*
      PARAMETER       (NLAST=150000, NDIV1=5000)
      COMMON /DSTOR7/ FENCDS(22), LQ(NLAST)
      COMMON /QUEST/  IQUEST(100)
*
+CDE, DUSER7.
*     ------------------------------------------------------------------
*
* *** Open the RZ-file with an Open Statement (or JCL, etc)
*
      LUNRZ  = 1
      LPRTDU = 6
      NREC   = 1000
      LREC   = 1024
      NBYTE  = 4*LREC
+SELF, IF=IBM.
      CALL DBROPN (LUNRZ, 'ZO', 'DBUVDS.DATA.A4', NBYTE, IOERR)
+SELF, IF=-IBM.
      CALL DBROPN (LUNRZ, 'ZO', 'DBUVDS.DAT', NBYTE, IOERR)
+SELF.
      IF (IOERR.NE.0)        GO TO 999
      CALL MZEBRA(-1)
*
* *** Open the 1 and only 1 Store used in the reconstruction
*
      CALL MZSTOR (ISTODU, '/DSTOR7/', ' ', FENCDS(1), LQ(1), LQ(1)
     +           , LQ(1), LQ(NDIV1), LQ(NLAST))
*
* *** Log-Level
*
+SELF, IF=-$DEBUG.
      CALL MZLOGL (ISTODU, 0)
+SELF, IF=$DEBUG.
      CALL MZLOGL (ISTODU, 1)
+SELF.
*
* *** Define user division and link area like:
*
      CALL MZDIV  (ISTODU, IDIVDU, 'DB-USERS', 50000, 100000, 'L')
      CALL MZLINK (ISTODU, '/DUSER7/', LDUVDU, LUSEDU, LDUVDU)
*
* *** Expand the system-division to its maximum
*
      LARGE  = NLAST/2
      IDIVS  = IDIVDU - 1
      CALL MZNEED (IDIVS, LARGE, 'G')
      ND     = LARGE + IQUEST(11) - 20
      IF (ND.GT.0) THEN
        CALL MZBOOK (IDIVS, L, 0, 2, 'DUMY', 0, 0, ND, 2, -1)
        CALL MZDROP (IDIVS, L, ' ')
      ENDIF
*
* *** Initialize DB-Package
*
      CALL TIMEST (999999.)
      CALL DBINIT (IDIVDU, LUNRZ, 'DBL3', LTOP, NREC, 'UZ')
+SELF, IF=-$DEBUG.
      CALL DBLOGL (LUNRZ,  0)
+SELF, IF=$DEBUG.
      CALL DBLOGL (LUNRZ,  2)
+SELF.
*
* *** Create the Data Base with partitioned directory
*
      CALL DBCRSD ('//DBL3/MUCH/MCALB/UVDS', 1, 'I', 'KEY_8   ',
     +             200, 'P')
      IYEAR = 80
      MONTH =  1
      IDAY  =  1
      CALL TIMEX (TIMINT)
      CALL DBUVTX (IDAY, ITIM1)
      DO 10 I = 1, 500
        IDATX = IYEAR*10000 + MONTH*100 + IDAY
        CALL DBPKTS (IDATX, 0, ISTRV)
        CALL DBCRUV (ISTRV)
        IDAY  = IDAY  + 10
        IF (IDAY.GT.25)  THEN
          MONTH = MONTH + 1
          IDAY  = 1
          IF (MONTH.GT.12) THEN
            IYEAR = IYEAR + 1
            MONTH = 1
          ENDIF
        ENDIF
   10 CONTINUE
*
      CALL TIMEX (TIMNOW)
      TIME  = TIMNOW - TIMINT
      CALL DBUVTX (IDAY, ITIM2)
      ITIME = ITIM2 - ITIM1
      WRITE (LPRTDU, 1001) IDAY, ITIM1, ITIM2, ITIME
      WRITE (LPRTDU, 1002) TIMINT, TIMNOW, TIME
*
* *** Close Data Base
*
      CALL DBEND
*
 1001 FORMAT (/,' DEXAM7 : IDAY/ITIM1/ITIM2/ITIME ', 4I12)
 1002 FORMAT (/,' DEXAM7 : TIMINT/TIMNOW/TIME ',4G12.4)
*                                                             END DEXAM7
  999 END
+DECK, DBCRUV.
      SUBROUTINE DBCRUV (ITIM1)
*     =========================
*
************************************************************************
*                                                                      *
*        SUBR. DBCRUV (ITIM1)                                          *
*                                                                      *
*   Creates the UVDS part of the Muon Chamber Data Base                *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     ITIM1    Start time of validity                                  *
*                                                                      *
*   Called by DEXAM7                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR7.
+CDE, DUSER7.
      DIMENSION       KEYX(4), KEYS(9)
      DATA            IPROG /1/, KEYX /4*0/, NENT /0/
      DATA            XRANG / 1000.0/, XCENT / 500.0/
*
*     ------------------------------------------------------------------
*
      NENT  = NENT + 1
      CALL DBPKTS (991231, 235959, INFIN)
*
* *** --------  UVDS  ----------------------
*
      NKEYS = 8
      NKEY8 = 16
      CALL VZERO (KEYS, NKEYS)
      KEYS(3) = ITIM1
      KEYS(4) = INFIN
      KEYS(5) = IPROG
      DO 10 K = 1, NKEY8
        NDAT  = 48
        CALL MZBOOK (IDIVDU, LUSEDU, LUSEDU, 2, 'UVDS', 0, 0, NDAT, 3,0)
        KEYS(8) = K
        DO 5 I = 1, NDAT
          Q(LUSEDU+I) = XRANG*RNDM(Q) - XCENT
    5   CONTINUE
        CALL DBENTR ('//DBL3/MUCH/MCALB/UVDS', LKUVDU, LDUVDU,
     +              IDIVDU, LUSEDU, NKEYS, KEYS, 3, ' ')
+SELF, IF=-$DEBUG.
        IF (NENT.LE.50 .AND. LUSEDU.NE.0 .AND. K.EQ.NKEY8)
+SELF, IF=$DEBUG.
        IF (NENT.LE.50 .AND. LUSEDU.NE.0)
+SELF.
     +    CALL DZSHOW ('UVDS    ', IDIVDU, LUSEDU, 'B', 0, 0, 0, 0)
        CALL MZDROP (IDIVDU, LUSEDU, ' ')
   10 CONTINUE
*                                                             END DBCRUV
      END
+PATCH, DBEXAM8.
+DECK, DBEXAM8.
+KEEP, DSTOR8.
      COMMON /DSTOR8/ FENCDS(22), LQ(9)
      DIMENSION       IQ(2), Q(2)
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))
*
      COMMON /QUEST/  IQUEST(100)
*
+KEEP, DUSER8.
      COMMON /DUSER8/ IDIVDU, IST1DU, IST2DU, LPRTDU, LDUVDU(16)
     +              , LKUVDU(16)
*
+DECK, DEXAM8.
      PROGRAM DEXAM8
*     ==============
*
************************************************************************
*                                                                      *
*        PROG. DEXAM8                                                  *
*                                                                      *
*   Program to debug DBUSE on a fictitious Data Base for partitioned   *
*   directories                                                        *
*                                                                      *
*   This program uses /DSTOR1/ as store 1 (ZEBRA store 0) where the    *
*   ZEBRA system division is created and /DSTOR8/ as store 2 (ZEBRA    *
*   store 1) where the DB-divisions (both system and user) are         *
*   created. This tests the complete generality of DBL3 (independence  *
*   from store allocation). The user can make use of this example to   *
*   initialize the store(s) and DBL3 for his own application program.  *
*                                                                      *
************************************************************************
*
      PARAMETER       (NLAS1=100000, NLAS2=150000, NDIV1=5000)
      COMMON /DSTOR1/ IFENC1(4), LQ1(NLAS1)
      COMMON /DSTOR8/ IFENC2(22), LQ2(NLAS2)
      COMMON /QUEST/  IQUEST(100)
+CDE, DUSER8.
      CHARACTER       CHOPT*8
+SELF.
*
*     ------------------------------------------------------------------
*
* *** Open the RZ-file with an Open Statement (or JCL, etc)
*
      LUNRZ  = 1
      LPRTDU = 6
      LREC   = 1024
      NBYTE  = 4*LREC
+SELF, IF=IBM.
      CALL DBROPN (LUNRZ, ' ', 'DBUVDS.DATA.A4', NBYTE, IOERR)
+SELF, IF=-IBM.
      CALL DBROPN (LUNRZ, ' ', 'DBUVDS.DAT', NBYTE, IOERR)
+SELF.
      IF (IOERR.NE.0)        GO TO 999
+SELF.
      CALL MZEBRA (-1)
*
* *** Open two Stores one for system and one for user division
*
      CALL MZSTOR (IST1DU, '/DSTOR1/', ' ', IFENC1(1), LQ1(1), LQ1(1)
     +           , LQ1(1), LQ1(NDIV1), LQ1(NLAS1))
      CALL MZSTOR (IST2DU, '/DSTOR8/', ' ', IFENC2(1), LQ2(1), LQ2(1)
     +           , LQ2(1), LQ2(NDIV1), LQ2(NLAS2))
*
* *** Log-Level
*
+SELF, IF=-$DEBUG.
      CALL MZLOGL (IST1DU, 0)
      CALL MZLOGL (IST2DU, 0)
+SELF, IF=$DEBUG.
      CALL MZLOGL (IST1DU, 1)
      CALL MZLOGL (IST2DU, 1)
+SELF.
*
* *** Define user division and link area like:
*
      CALL MZDIV  (IST2DU, IDIVDU, 'DB-USERS', 20000, 30000, 'L')
      CALL MZLINK (IST2DU, '/DUSER8/', LDUVDU(1), LKUVDU(16), LDUVDU(1))
*
* *** Expand the system-division to its maximum
*
      LARGE  = NLAS1/2
      IDIVS  = 20
      CALL MZNEED (IDIVS, LARGE, 'G')
      ND     = LARGE + IQUEST(11) - 20
      IF (ND.GT.0) THEN
        CALL MZBOOK (IDIVS, L, 0, 2, 'DUMY', 0, 0, ND, 2, -1)
        CALL MZDROP (IDIVS, L, ' ')
      ENDIF
*
* *** Initialize DB-Package
*
      CALL TIMEST (999999.)
      CALL DBINIT (IDIVDU, LUNRZ, 'DBL3', LTOP, 0, ' ')
+SELF, IF=-$DEBUG.
      CALL DBLOGL (LUNRZ,  0)
+SELF, IF=$DEBUG.
      CALL DBLOGL (LUNRZ,  2)
      CALL DZSTOR ('DSTOR8', IST2DU)
      CALL DZAREA ('DB-LINKS', IST2DU, ' ', 0, ' ')
+SELF.
*
* *** Read the Partitioned Data Base
*
      IYEAR = 80
      MONTH =  1
      IDAY  =  3
      CALL TIMEX (TIMINT)
      CALL DBUVTX (IDAY, ITIM1)
      DO 10 I = 1, 100
        IDATX = IYEAR*10000 + MONTH*100 + IDAY
        CALL DBPKTS (IDATX, 0, ITIME)
        CALL DBONUV (ITIME)
        IDAY  = IDAY  + 10
        IF (IDAY.GT.25)  THEN
          MONTH = MONTH + 1
          IDAY  = 3
          IF (MONTH.GT.12) THEN
            IYEAR = IYEAR + 1
            MONTH = 1
          ENDIF
        ENDIF
   10 CONTINUE
*
      CALL TIMEX (TIMNOW)
      TIME  = TIMNOW - TIMINT
      CALL DBUVTX (IDAY, ITIM2)
      ITIME = ITIM2 - ITIM1
      WRITE (LPRTDU, 1001) IDAY, ITIM1, ITIM2, ITIME
      WRITE (LPRTDU, 1002) TIMINT, TIMNOW, TIME
+SELF, IF=$DEBUG.
*
* *** Test subroutine DBPRIN
*
      CHOPT  = 'K'
      CALL DBPRIN ('//DBL3/MUCH/MCALB/UVDS', CHOPT)
+SELF, IF=$HIGZ.
*
* *** Plot some data objects and validity period
*
      CALL DBPTES
+SELF.
*
* *** Close DataBase
*
      CALL DBEND
*
 1001 FORMAT (/,' DEXAM8 : IDAY/ITIM1/ITIM2/ITIME ', 4I12)
 1002 FORMAT (/,' DEXAM8 : TIMINT/TIMNOW/TIME ',4G12.4)
*                                                             END DEXAM8
  999 END
+DECK, DBONUV.
      SUBROUTINE DBONUV (ITIME)
*     =========================
*
************************************************************************
*                                                                      *
*        SUBR. DBONUV (ITIME)                                          *
*                                                                      *
*   Tests DBUSE on the imitation of the Muon Data Base                 *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     ITIME    Validity time                                           *
*                                                                      *
*   Called by DEXAM8                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR8.
+CDE, DUSER8.
      DIMENSION       KEYS(1000)
      CHARACTER       CHOPT*4
      DATA            NENT /0/
*
*     ------------------------------------------------------------------
*
      CALL VZERO (KEYS, 9)
      NENT  = NENT + 1
*
* *** -------------- UVDS ---------------------
*
      KEYS(8) = 16
      DO 5 I = 1, KEYS(8)
        KEYS(8+I) = I
    5 CONTINUE
      CHOPT = 'M8'
      CALL DBUSE ('//DBL3/MUCH/MCALB/UVDS', LKUVDU(1), LDUVDU(1),
     +            ITIME, KEYS, CHOPT)
      DO 10 I = 1, KEYS(8)
+SELF, IF=-$DEBUG.
        IF (NENT.LE.50.AND.LDUVDU(I).NE.0.AND.I.EQ.KEYS(8))
+SELF, IF=$DEBUG.
        IF (NENT.LE.50.AND.LDUVDU(I).NE.0)
+SELF.
     +    CALL DZSHOW ('UVDS    ', IDIVDU, LDUVDU(I), 'V', 0, 0, 0, 0)
   10 CONTINUE
      CALL DBFREE ('//DBL3/MUCH/MCALB/UVDS', LKUVDU, KEYS, CHOPT)
*                                                             END DBONUV
      END
+DECK, DBPTES, IF=$HIGZ.
      SUBROUTINE DBPTES
*
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBPTES                                                  *
*                                                                      *
*   Tests the routine DBPLTI and DBPLOB on the fictitious data base    *
*                                                                      *
*   Called by DEXAM8                                                   *
*                                                                      *
************************************************************************
*
      PARAMETER       (NPAWC=20000)
      COMMON /PAWC/   HMEMOR(NPAWC)
      DIMENSION       KEYS(100), KOBJ(10)
+SELF, IF=IBM.
      CHARACTER       FILE*80
+SELF.
*
*     ------------------------------------------------------------------
*
* *** Initialize HPLOT
*
      LUMET = 2
+SELF, IF=APOLLO,CRAY,MIP.
      OPEN (UNIT=LUMET, FILE='dexam8.meta', STATUS='UNKNOWN')
+SELF, IF=IBM.
      WRITE (FILE, 1001) LUMET, 'DEXAM8'
      CALL VMCMS (FILE, IOERR)
+SELF, IF=VAX.
      OPEN (UNIT=LUMET, FILE='DEXAM8.META', STATUS='NEW')
+SELF.
      CALL HLIMIT (-NPAWC)
   10 WRITE (6, 1000)
      READ  (*, *, END=10) IWK
      CALL HPLINT (IWK)
      IF (IWK.LE.0) THEN
        CALL HPLCAP (-LUMET)
      ELSE
        CALL IGSA (1)
      ENDIF
*
      CALL VZERO (KEYS, 100)
      KEYS (8) = 1
      CALL DBPLTI ('//DBL3/MUCH/MCALB/UVDS', KEYS, '8')
      CALL IGSA (1)
      KOBJ (1) = 1
      KOBJ (2) = 3
      CALL DBPLOB ('//DBL3/MUCH/MCALB/UVDS', KEYS, 2, KOBJ, 3, 1, '8')
      CALL IGSA (1)
*
      CALL HPLEND
*
+SELF, IF=-VAX.
 1000 FORMAT (' Give Workstation type (7878/10002/0) : ')
+SELF, IF=VAX.
 1000 FORMAT ('$Give Workstation type (7878/10002/0) : ')
+SELF, IF=IBM.
 1001 FORMAT ('FILEDEF ',I2,' DISK ',A,' METAFILE A ( PERM ')
+SELF.
*                                                             END DBPTES
      END
+PATCH, DBEXAM9.
+DECK, DBEXAM9.
+KEEP, DSTOR9.
      COMMON /DSTOR9/ FENCDS(22), LQ(9)
      DIMENSION       IQ(2), Q(2)
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))
*
      COMMON /QUEST/  IQUEST(100)
*
+KEEP, DUSER9.
      PARAMETER       (NKEYDU=8, NKY8DU=16, NOBJDU=320)
      COMMON /DUSER9/ ISTODU, IDIVDU, LPRTDU, KEYSDU(NKEYDU,NOBJDU)
     +              , LDUVDU, LKUVDU, LUSEDU(NOBJDU)
*
+DECK, DEXAM9.
      PROGRAM DEXAM9
*     ==============
*
************************************************************************
*                                                                      *
*        PROG. DEXAM9                                                  *
*                                                                      *
*   Program to create a fictitious database to test the batch option   *
*   DBENTB and compare its performance against standard DBENTR         *
*                                                                      *
*   This program uses a different store from /GCBANK/ and hence both   *
*   the user division and the ZEBRA system division refer to the new   *
*   store /DSTOR9/ and tests the new feature of version 3.00 of DBL3   *
*                                                                      *
************************************************************************
*
      PARAMETER       (NLAST=150000, NDIV1=5000)
      COMMON /DSTOR9/ FENCDS(22), LQ(NLAST)
      DIMENSION       IQ(2), Q(2)
      EQUIVALENCE     (IQ(1),Q(1),LQ(9))
*
      COMMON /QUEST/  IQUEST(100)
*
+CDE, DUSER9.
      PARAMETER       (NKEX=NKEYDU-7)
      CHARACTER       CHTAG(NKEX)*8, CHFOR*(NKEX), CHD*1
      DATA            CHTAG /'KEY_8   '/, CHFOR /'I'/
*
*     ------------------------------------------------------------------
*
* *** Open the RZ-file with an Open Statement (or JCL, etc)
*
      LUNRZ  = 1
      LPRTDU = 6
      NREC   = 1000
      LREC   = 1024
      NBYTE  = 4*LREC
+SELF, IF=IBM.
      CALL DBROPN (LUNRZ, 'ZO', 'DBTEST.DATA.A4', NBYTE, IOERR)
+SELF, IF=-IBM.
      CALL DBROPN (LUNRZ, 'ZO', 'DBTEST.DAT', NBYTE, IOERR)
+SELF.
      IF (IOERR.NE.0)        GO TO 999
      CALL MZEBRA(-1)
*
* *** Open the 1 and only 1 Store used in the reconstruction
*
      CALL MZSTOR (ISTODU, '/DSTOR9/', ' ', FENCDS(1), LQ(1), LQ(1)
     +           , LQ(1), LQ(NDIV1), LQ(NLAST))
*
* *** Log-Level
*
      CALL MZLOGL (ISTODU, 0)
*
* *** Define user division and link area like:
*
      CALL MZDIV  (ISTODU, IDIVDU, 'DB-USERS', 50000, 100000, 'L')
      CALL MZLINK (ISTODU, '/DUSER9/', LDUVDU, LUSEDU(NOBJDU), LDUVDU)
*
* *** Expand the system-division to its maximum
*
      LARGE  = NLAST/2
      IDIVS  = IDIVDU - 1
      CALL MZNEED (IDIVS, LARGE, 'G')
      ND     = LARGE + IQUEST(11) - 20
      IF (ND.GT.0) THEN
        CALL MZBOOK (IDIVS, L, 0, 2, 'DUMY', 0, 0, ND, 2, -1)
        CALL MZDROP (IDIVS, L, ' ')
      ENDIF
*
* *** Initialize DB-Package
*
      CALL TIMEST (999999.)
      CALL DBINIT (IDIVDU, LUNRZ, 'DBL3', LTOP, NREC, 'UZ')
+SELF, IF=-$DEBUG.
      CALL DBLOGL (LUNRZ,  0)
+SELF, IF=$DEBUG.
      CALL DBLOGL (LUNRZ,  2)
+SELF.
*
* *** Generate the list of objects to be inserted
*
      IDEND  = 901231
      IDBGN  = 880617
      ITIME  = 0
      CALL DBPKTS (IDEND, ITIME, INFIN)
      CALL DBPKTS (IDBGN, ITIME, IDTIM)
      IPVSN  = 1
      XRANG  = 500.
      XCENT  = 1000.
      NDAT   = 48
      DO 10 I = 1, NOBJDU
        KEY8   = MOD (I, NKY8DU)
        IF (KEY8.EQ.0) THEN
          KEY8   = NKY8DU
          IDBGN  = IDBGN + 1
          CALL DBPKTS (IDBGN, ITIME, IDTIM)
        ENDIF
        KEYSDU(3,I) = IDTIM
        KEYSDU(4,I) = INFIN
        KEYSDU(5,I) = IPVSN
        KEYSDU(8,I) = KEY8
        CALL MZBOOK (IDIVDU, LUSEDU(I), LUSEDU(I), 2, 'UVDS', 0, 0, NDAT
     +             , 3, 0)
        DO 5 J = 1, NDAT
          Q(LUSEDU(I)+J) = XRANG*RNDM(Q) - XCENT
    5   CONTINUE
   10 CONTINUE
*
* *** Create the two directories
*
+SELF, IF=$PARTDIR.
      CHD    = 'P'
+SELF, IF=-$PARTDIR.
      CHD    = ' '
+SELF.
      CALL DBCRSD ('//DBL3/DBMU/MCALB/UVD1', NKEX, CHFOR, CHTAG,20, CHD)
      CALL DBCRSD ('//DBL3/DBMU/MCALB/UVD2', NKEX, CHFOR, CHTAG,20, CHD)
      CALL DBCRSD ('//DBL3/DBMU/MCALB/UVD3', NKEX, CHFOR, CHTAG,20, CHD)
      CALL DBCRSD ('//DBL3/DBMU/MCALB/UVD4', NKEX, CHFOR, CHTAG,20, CHD)
*
* *** Now use 4 methods for saving the datasets
*
      CALL DBUVD1
+SELF, IF=$DEBUG.
      CALL DZSNAP ('UVD1', IDIVDU, 'LMT')
      CALL DZSNAP ('UVD1', IDIVDU-1, 'LMT')
+SELF.
      CALL DBUVD2
+SELF, IF=$DEBUG.
      CALL DZSNAP ('UVD2', IDIVDU, 'LMT')
      CALL DZSNAP ('UVD2', IDIVDU-1, 'LMT')
+SELF.
      CALL DBUVD3
+SELF, IF=$DEBUG.
      CALL DZSNAP ('UVD3', IDIVDU, 'LMT')
      CALL DZSNAP ('UVD3', IDIVDU-1, 'LMT')
+SELF.
      CALL DBUVD4
+SELF, IF=$DEBUG.
      CALL DZSNAP ('UVD4', IDIVDU, 'LMT')
      CALL DZSNAP ('UVD4', IDIVDU-1, 'LMT')
+SELF.
*
* *** Test the data objects stored
*
      CALL DBUVDT
+SELF, IF=$DEBUG.
*
* *** Debug print out
*
      DO 20 K = 1, NOBJDU
        IF (MOD(K,NKY8DU).EQ.1)
     +    CALL DZSHOW ('UVDS    ', IDIVDU, LUSEDU(K), 'B', 0, 0, 0, 0)
   20 CONTINUE
+SELF.
*
* *** Close Data Base
*
      CALL DBEND
*                                                             END DEXAM9
  999 END
+DECK, DBUVD1.
      SUBROUTINE DBUVD1
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBUVD1                                                  *
*                                                                      *
*   Stores objects in the UVD1 subdirectory using DBENTR               *
*                                                                      *
*   Called by DEXAM9                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR9.
+CDE, DUSER9.
*     ------------------------------------------------------------------
*
* *** Get Real time at the beginning of the loop
*
      CALL TIMEX (TIMINT)
      CALL DBUVTX (IDAY, ITIM1)
*
* *** Now save the objects
*
      DO 10 K = 1, NOBJDU
        CALL DBENTR ('//DBL3/DBMU/MCALB/UVD1', LKUVDU, LDUVDU,
     +              IDIVDU, LUSEDU(K), NKEYDU, KEYSDU(1,K), 3, 'R')
   10 CONTINUE
*
* *** Get Real time at the end of the loop
*
      CALL TIMEX (TIMNOW)
      TIME  = TIMNOW - TIMINT
      CALL DBUVTX (IDAY, ITIM2)
      ITIME = ITIM2 - ITIM1
      WRITE (LPRTDU, 1001) IDAY, ITIM1, ITIM2, ITIME
      WRITE (LPRTDU, 1002) TIMINT, TIMNOW, TIME
*
 1001 FORMAT (/,' DBUVD1 : IDAY/ITIM1/ITIM2/ITIME ', 4I12)
 1002 FORMAT (/,' DBUVD1 : TIMINT/TIMNOW/TIME ',4G12.4)
*                                                             END DBUVD1
      END
+DECK, DBUVD2.
      SUBROUTINE DBUVD2
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBUVD2                                                  *
*                                                                      *
*   Stores objects in the UVD2 subdirectory using DBENTB               *
*                                                                      *
*   Called by DEXAM9                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR9.
+CDE, DUSER9.
*     ------------------------------------------------------------------
*
* *** Get Real time at the beginning of the loop
*
      CALL TIMEX (TIMINT)
      CALL DBUVTX (IDAY, ITIM1)
*
* *** Now save the objects
*
      CALL DBENTB ('//DBL3/DBMU/MCALB/UVD2', IDIVDU, LUSEDU, KEYSDU,
     +             NKEYDU, NOBJDU, 3, 'R')
*
* *** Get Real time at the end of the loop
*
      CALL TIMEX (TIMNOW)
      TIME  = TIMNOW - TIMINT
      CALL DBUVTX (IDAY, ITIM2)
      ITIME = ITIM2 - ITIM1
      WRITE (LPRTDU, 1001) IDAY, ITIM1, ITIM2, ITIME
      WRITE (LPRTDU, 1002) TIMINT, TIMNOW, TIME
*
 1001 FORMAT (/,' DBUVD2 : IDAY/ITIM1/ITIM2/ITIME ', 4I12)
 1002 FORMAT (/,' DBUVD2 : TIMINT/TIMNOW/TIME ',4G12.4)
*                                                             END DBUVD2
      END
+DECK, DBUVD3.
      SUBROUTINE DBUVD3
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBUVD3                                                  *
*                                                                      *
*   Stores objects in the UVD3 subdirectory using DBENTR (with update) *
*                                                                      *
*   Called by DEXAM9                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR9.
+CDE, DUSER9.
*     ------------------------------------------------------------------
*
* *** Get Real time at the beginning of the loop
*
      CALL TIMEX (TIMINT)
      CALL DBUVTX (IDAY, ITIM1)
*
* *** Now save the objects
*
      DO 10 K = 1, NOBJDU
        CALL DBENTR ('//DBL3/DBMU/MCALB/UVD3', LKUVDU, LDUVDU,
     +              IDIVDU, LUSEDU(K), NKEYDU, KEYSDU(1,K), 3, ' ')
   10 CONTINUE
*
* *** Get Real time at the end of the loop
*
      CALL TIMEX (TIMNOW)
      TIME  = TIMNOW - TIMINT
      CALL DBUVTX (IDAY, ITIM2)
      ITIME = ITIM2 - ITIM1
      WRITE (LPRTDU, 1001) IDAY, ITIM1, ITIM2, ITIME
      WRITE (LPRTDU, 1002) TIMINT, TIMNOW, TIME
*
 1001 FORMAT (/,' DBUVD3 : IDAY/ITIM1/ITIM2/ITIME ', 4I12)
 1002 FORMAT (/,' DBUVD3 : TIMINT/TIMNOW/TIME ',4G12.4)
*                                                             END DBUVD3
      END
+DECK, DBUVD4.
      SUBROUTINE DBUVD4
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBUVD4                                                  *
*                                                                      *
*   Stores objects in the UVD4 subdirectory using DBENTB (with update) *
*                                                                      *
*   Called by DEXAM9                                                   *
*                                                                      *
************************************************************************
*
+CDE, DSTOR9.
+CDE, DUSER9.
*     ------------------------------------------------------------------
*
* *** Get Real time at the beginning of the loop
*
      CALL TIMEX (TIMINT)
      CALL DBUVTX (IDAY, ITIM1)
*
* *** Now save the objects
*
      CALL DBENTB ('//DBL3/DBMU/MCALB/UVD4', IDIVDU, LUSEDU, KEYSDU,
     +             NKEYDU, NOBJDU, 3, ' ')
*
* *** Get Real time at the end of the loop
*
      CALL TIMEX (TIMNOW)
      TIME  = TIMNOW - TIMINT
      CALL DBUVTX (IDAY, ITIM2)
      ITIME = ITIM2 - ITIM1
      WRITE (LPRTDU, 1001) IDAY, ITIM1, ITIM2, ITIME
      WRITE (LPRTDU, 1002) TIMINT, TIMNOW, TIME
*
 1001 FORMAT (/,' DBUVD4 : IDAY/ITIM1/ITIM2/ITIME ', 4I12)
 1002 FORMAT (/,' DBUVD4 : TIMINT/TIMNOW/TIME ',4G12.4)
*                                                             END DBUVD4
      END
+DECK, DBUVDT.
      SUBROUTINE DBUVDT
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBUVDT                                                  *
*                                                                      *
*   Tests the objects stored in the directories                        *
*                                                                      *
*   Called by DEXAM9                                                   *
*                                                                      *
************************************************************************
*
+CDE, DKKEYS.
+CDE, DSTOR9.
+CDE, DUSER9.
      CHARACTER       PATHN*30
*
*     ------------------------------------------------------------------
*
* *** Get Real time at the beginning of the loop
*
      CALL TIMEX (TIMINT)
      CALL DBUVTX (IDAY, ITIM1)
*
* *** Now test the first directory
*
      PATHN = '//DBL3/DBMU/MCALB/UVD1'
      WRITE (LPRTDU, 1003) PATHN
      NERR   = 0
      DO 20 IOBJ = 1, NOBJDU
        IERR   = 0
        KEY1S  = IOBJ
        NDAT   = IQ(LUSEDU(IOBJ)-1)
        CALL DBKIN (PATHN, KEY1S, IDIVDU, LDUVDU, LKUVDU, 2, IPREC)
        NDATD  = IQ(LDUVDU-1)
        DO 10 K = 1, NKEYDU
          IF (K.NE.1 .AND. K.NE.2 .AND. K.NE.6 .AND. K.NE.7 .AND.
     +        KEYVDK(K).NE.KEYSDU(K,IOBJ)) IERR = IERR + 1
   10   CONTINUE
        IF (NDAT.NE.NDATD) THEN
          IERR   = IERR + 1
        ELSE
          DO 15 I = 1, NDAT
            DIFF   = (Q(LUSEDU(IOBJ)+I) - Q(LDUVDU+I)) / AMAX1
     +               (ABS(Q(LDUVDU+I)), ABS(Q(LUSEDU(IOBJ)+I)), 1.0E-12)
            IF (ABS(DIFF).GT.0.01) IERR = IERR + 1
   15     CONTINUE
        ENDIF
        IF (IERR.GT.0) THEN
          NERR   = NERR + 1
+SELF, IF=$DEBUG.
          WRITE (LPRTDU, 1004) (KEYSDU(K,IOBJ), K = 1, NKEYDU)
          WRITE (LPRTDU, 1005) (KEYVDK(K), K = 1, NKEYDU)
          WRITE (LPRTDU, 1006) NDAT, (Q(LUSEDU(IOBJ)+I), I = 1, NDAT)
          WRITE (LPRTDU, 1007) NDATD, (Q(LDUVDU+I), I = 1, NDATD)
+SELF.
        ENDIF
        IF (LDUVDU.GT.0) CALL MZDROP (ISTODU, LDUVDU, 'L')
   20 CONTINUE
      WRITE (LPRTDU, 1008) NERR, NOBJDU
*
* *** Now test the second directory
*
      PATHN = '//DBL3/DBMU/MCALB/UVD2'
      WRITE (LPRTDU, 1003) PATHN
      NERR   = 0
      DO 40 IOBJ = 1, NOBJDU
        IERR   = 0
        KEY1S  = IOBJ
        NDAT   = IQ(LUSEDU(IOBJ)-1)
        CALL DBKIN (PATHN, KEY1S, IDIVDU, LDUVDU, LKUVDU, 2, IPREC)
        NDATD  = IQ(LDUVDU-1)
        DO 30 K = 1, NKEYDU
          IF (K.NE.1 .AND. K.NE.2 .AND. K.NE.6 .AND. K.NE.7 .AND.
     +        KEYVDK(K).NE.KEYSDU(K,IOBJ)) IERR = IERR + 1
   30   CONTINUE
        IF (NDAT.NE.NDATD) THEN
          IERR   = IERR + 1
        ELSE
          DO 35 I = 1, NDAT
            DIFF   = (Q(LUSEDU(IOBJ)+I) - Q(LDUVDU+I)) / AMAX1
     +               (ABS(Q(LDUVDU+I)), ABS(Q(LUSEDU(IOBJ)+I)), 1.0E-12)
            IF (ABS(DIFF).GT.0.01) IERR = IERR + 1
   35     CONTINUE
        ENDIF
        IF (IERR.GT.0) THEN
          NERR   = NERR + 1
+SELF, IF=$DEBUG.
          WRITE (LPRTDU, 1004) (KEYSDU(K,IOBJ), K = 1, NKEYDU)
          WRITE (LPRTDU, 1005) (KEYVDK(K), K = 1, NKEYDU)
          WRITE (LPRTDU, 1006) NDAT, (Q(LUSEDU(IOBJ)+I), I = 1, NDAT)
          WRITE (LPRTDU, 1007) NDATD, (Q(LDUVDU+I), I = 1, NDATD)
+SELF.
        ENDIF
        IF (LDUVDU.GT.0) CALL MZDROP (ISTODU, LDUVDU, 'L')
   40 CONTINUE
      WRITE (LPRTDU, 1008) NERR, NOBJDU
*
* *** Now test the third directory
*
      PATHN = '//DBL3/DBMU/MCALB/UVD3'
      WRITE (LPRTDU, 1003) PATHN
      NERR   = 0
      DO 60 IOBJ = 1, NOBJDU
        IERR   = 0
        KEY1S  = IOBJ
        NDAT   = IQ(LUSEDU(IOBJ)-1)
        CALL DBKIN (PATHN, KEY1S, IDIVDU, LDUVDU, LKUVDU, 2, IPREC)
        NDATD  = IQ(LDUVDU-1)
        DO 50 K = 1, NKEYDU
          IF (K.NE.1 .AND. K.NE.2 .AND. K.NE.6 .AND. K.NE.7 .AND.
     +        KEYVDK(K).NE.KEYSDU(K,IOBJ)) IERR = IERR + 1
   50   CONTINUE
        IF (NDAT.NE.NDATD) THEN
          IERR   = IERR + 1
        ELSE
          DO 55 I = 1, NDAT
            DIFF   = (Q(LUSEDU(IOBJ)+I) - Q(LDUVDU+I)) / AMAX1
     +               (ABS(Q(LDUVDU+I)), ABS(Q(LUSEDU(IOBJ)+I)), 1.0E-12)
            IF (ABS(DIFF).GT.0.01) IERR = IERR + 1
   55     CONTINUE
        ENDIF
        IF (IERR.GT.0) THEN
          NERR   = NERR + 1
+SELF, IF=$DEBUG.
          WRITE (LPRTDU, 1004) (KEYSDU(K,IOBJ), K = 1, NKEYDU)
          WRITE (LPRTDU, 1005) (KEYVDK(K), K = 1, NKEYDU)
          WRITE (LPRTDU, 1006) NDAT, (Q(LUSEDU(IOBJ)+I), I = 1, NDAT)
          WRITE (LPRTDU, 1007) NDATD, (Q(LDUVDU+I), I = 1, NDATD)
+SELF.
        ENDIF
        IF (LDUVDU.GT.0) CALL MZDROP (ISTODU, LDUVDU, 'L')
   60 CONTINUE
      WRITE (LPRTDU, 1008) NERR, NOBJDU
*
* *** Now test the fourth directory
*
      PATHN = '//DBL3/DBMU/MCALB/UVD4'
      WRITE (LPRTDU, 1003) PATHN
      NERR   = 0
      DO 80 IOBJ = 1, NOBJDU
        IERR   = 0
        KEY1S  = IOBJ
        NDAT   = IQ(LUSEDU(IOBJ)-1)
        CALL DBKIN (PATHN, KEY1S, IDIVDU, LDUVDU, LKUVDU, 2, IPREC)
        NDATD  = IQ(LDUVDU-1)
        DO 70 K = 1, NKEYDU
          IF (K.NE.1 .AND. K.NE.2 .AND. K.NE.6 .AND. K.NE.7 .AND.
     +        KEYVDK(K).NE.KEYSDU(K,IOBJ)) IERR = IERR + 1
   70   CONTINUE
        IF (NDAT.NE.NDATD) THEN
          IERR   = IERR + 1
        ELSE
          DO 75 I = 1, NDAT
            DIFF   = (Q(LUSEDU(IOBJ)+I) - Q(LDUVDU+I)) / AMAX1
     +               (ABS(Q(LDUVDU+I)), ABS(Q(LUSEDU(IOBJ)+I)), 1.0E-12)
            IF (ABS(DIFF).GT.0.01) IERR = IERR + 1
   75     CONTINUE
        ENDIF
        IF (IERR.GT.0) THEN
          NERR   = NERR + 1
+SELF, IF=$DEBUG.
          WRITE (LPRTDU, 1004) (KEYSDU(K,IOBJ), K = 1, NKEYDU)
          WRITE (LPRTDU, 1005) (KEYVDK(K), K = 1, NKEYDU)
          WRITE (LPRTDU, 1006) NDAT, (Q(LUSEDU(IOBJ)+I), I = 1, NDAT)
          WRITE (LPRTDU, 1007) NDATD, (Q(LDUVDU+I), I = 1, NDATD)
+SELF.
        ENDIF
        IF (LDUVDU.GT.0) CALL MZDROP (ISTODU, LDUVDU, 'L')
   80 CONTINUE
      WRITE (LPRTDU, 1008) NERR, NOBJDU
*
* *** Get Real time at the end of the loop
*
      CALL TIMEX (TIMNOW)
      TIME  = TIMNOW - TIMINT
      CALL DBUVTX (IDAY, ITIM2)
      ITIME = ITIM2 - ITIM1
      WRITE (LPRTDU, 1001) IDAY, ITIM1, ITIM2, ITIME
      WRITE (LPRTDU, 1002) TIMINT, TIMNOW, TIME
*
 1001 FORMAT (/,' DBUVDT : IDAY/ITIM1/ITIM2/ITIME ', 4I12)
 1002 FORMAT (/,' DBUVDT : TIMINT/TIMNOW/TIME ',4G12.4)
 1003 FORMAT (//,' DBUVDT : Test object stored in directory ',A)
+SELF, IF=$DEBUG.
 1004 FORMAT (' Input  Keys',10I12)
 1005 FORMAT (' Output Keys',10I12)
 1006 FORMAT (' Input  Data',I12,9G12.4/(12X,10G12.4))
 1007 FORMAT (' Output Data',I12,9G12.4/(12X,10G12.4))
+SELF.
 1008 FORMAT (/,' DBUVDT : Number of errors ',I6,' in ',I6,' objects')
*                                                             END DBUVDT
      END
+PATCH, DBEXAMA.
+DECK, DEXAMA.
      PROGRAM DEXAMA
*     ==============
*
************************************************************************
*                                                                      *
*        PROG. DEXAMA                                                  *
*                                                                      *
*   Program to debug DBPURG and DBPRIN on a fictitious Data Base       *
*                                                                      *
************************************************************************
*
      PARAMETER       (NLAST=150000, NDIV1=5000)
      COMMON /GCBANK/ FENCDS(22), LQ(NLAST)
      CHARACTER       CHOPT*8
      DIMENSION       KEY(100)
+SELF, IF=IBM.
      CHARACTER       CHLUN*3, CTEMP*20
+SELF.
*
*     ------------------------------------------------------------------
*
* *** Open the RZ-file with an Open Statement (or JCL, etc)
*
      LUNRZ  = 1
      NREC   = 1000
      LREC   = 1024
      NBYTE  = 4*LREC
+SELF, IF=IBM.
      CALL DBROPN (LUNRZ, 'O', 'DBMUON.DATA.A4', NBYTE, IOERR)
+SELF, IF=-IBM.
      CALL DBROPN (LUNRZ, 'O', 'DBMUON.DAT', NBYTE, IOERR)
+SELF.
      IF (IOERR.NE.0)        GO TO 999
      CALL MZEBRA (-1)
*
* *** Open the 1 and only 1 Store used in the reconstruction
*
      CALL MZSTOR (ISTODU, '/GCBANK/', ' ', FENCDS(1), LQ(1), LQ(1)
     +           , LQ(1), LQ(NDIV1), LQ(NLAST))
*
* *** Log-Level
*
+SELF, IF=-$DEBUG.
      CALL MZLOGL (ISTODU, 0)
+SELF, IF=$DEBUG.
      CALL MZLOGL (ISTODU, 1)
+SELF.
*
* *** Define user division and link area like:
*
      CALL MZDIV  (ISTODU, IDIVDU, 'DB-USERS', 20000, 30000, 'L')
*
* *** Initialize DB-Package
*
      CALL DBINIT (IDIVDU, LUNRZ, 'DBL3', LTOP, 0, 'UZ')
+SELF, IF=-$DEBUG.
      CALL DBLOGL (LUNRZ,  0)
+SELF, IF=$DEBUG.
      CALL DBLOGL (LUNRZ,  2)
+SELF.
*
* *** Test subroutine DBPRIN
*
      PRINT 1001
      READ  (*, 1002) CHOPT
      CALL DBPRIN ('//DBL3/MUCH/MCALB/UVDS', 'K')
*
* *** Test subroutine DBPURG
*
      KEY(8) = 10
      CALL DBPKTS (801222, 0, ITIME)
      CALL DBPURK ('//DBL3/MUCH/MCALB/UVDS', ITIME, KEY, '8')
      CALL DBPRIN ('//DBL3/MUCH/MCALB/UVDS', 'K')
      CALL DBPURG ('//DBL3/MUCH/MCALB/UVDS', 8, 10, CHOPT)
      CALL DBPRIN ('//DBL3/MUCH/MCALB/UVDS', 'K')
*
* *** Close DataBase
*
      CALL DBEND
*
 1001 FORMAT ('$Give the character option in purging : ')
 1002 FORMAT (A)
*                                                             END DEXAMA
  999 END
+PATCH, DBEXAMB.
+DECK, DEXAMB.
      PROGRAM DEXAMB
*
************************************************************************
*
*        PROG. DEXAMB
*
*   Provides facility to enter information into data base from an input
*   file. It operates with 2 FFKEY data cards 'IOPA' to specify the
*   input and output (data base) files and 'DIRE' to specify the name
*   of the directory and when needed the specification of user keys.
*
*   External routines : DBBANK, DB routines, UTOPEN, UTLOOK
*   External libraries : NPACKLIB, KERNLIB
*
************************************************************************
*
      PARAMETER       (NLAST=150000, NDIV1=5000)
      COMMON /GCBANK/ NZEBRA, GVERSN, ZVERSN, IXSTOR, IXDIV, IXCONS
     +              , FENDQ(16), LMAIN, LR1, WS(NLAST)
      DIMENSION       IQ(2), Q(2), LQ(8000)
      EQUIVALENCE     (Q(1),IQ(1),LQ(9)), (LQ(1),LMAIN,LBKS)
*
      COMMON /QUEST/  IQUEST(100)
*
+CDE, L3UNIT.
      PARAMETER       (NBUFF=50, NBDIR=20)
      DIMENSION       LBUFF(NBUFF), LBDIR(NBDIR)
      CHARACTER       CHINP*4, CHDBL*4, CHOPT*4, TOPN*16, CHDIR*80
      CHARACTER       CHNAM*80, CHFOR*100, CTAG(100)*8, CHVL*4
      INTEGER         KEYS(100)
*
*     ------------------------------------------------------------------
*
* *** Initialize ZEBRA
*
      CALL MZEBRA (-1)
      CALL MZSTOR (IXSTOR, '/GCBANK/', ' ', FENDQ(1), LQ(1), LQ(1)
     +           , LQ(1), LQ(NDIV1), LQ(NLAST))
      CALL MZDIV  (IXSTOR, IXCONS, 'Constant', 10000, NLAST-5000, 'L')
      IXDIV  = IXSTOR + 2
*
* *** Initialize /L3UNIT/ and FFREAD
*
      L3PRNT = 6
      CALL FFINIT (0)
      LUNIN  = 0
      LUNDB  = 0
      CALL VBLANK (LBUFF, NBUFF)
      CALL VBLANK (LBDIR, NBDIR)
      CALL FFKEY  ('IOPA', LBUFF, NBUFF, 'MIXED')
      CALL FFKEY  ('DIRE', LBDIR, NBDIR, 'MIXED')
      CALL FFGO
*
* *** Find the name of the directory and hence Top dir name
*
      CALL UHTOC (LBDIR(1), 4, CHNAM, 80)
      IF (CHNAM(1:2).NE.'//') THEN
        WRITE (L3PRNT, *) ' DEXAMB : No valid directory name given'
        GO TO 999
      ENDIF
      LNB     = INDEX (CHNAM, ' ')
      IF (LNB.GT.1) THEN
        CHDIR  = CHNAM(1:LNB-1)
      ELSE
        CHDIR  = CHNAM
      ENDIF
      NCHAR  = LENOCC (CHDIR)
      NCHRT  = INDEX  (CHDIR(3:NCHAR), '/') - 1
      IF (NCHRT.LE.0) NCHRT = NCHAR - 2
      TOPN   = CHDIR(3:NCHRT+2)
*
* *** Open the i/p and o/p files
*
      CALL UTLOOK ('INPU', LBUFF, NBUFF, I)
      IF (I.GT.0) THEN
        I      = I + 1
        LUNIN  = IABS (LBUFF(I))
        IF (LBUFF(I).LT.0) THEN
          I      =  I + 1
          CALL UHTOC (LBUFF(I), 4, CHINP, 4)
          I      =  I + 1
          LRINP  = LBUFF(I)
        ELSE
          CHINP  = 'AI  '
          LRINP  = 80
        ENDIF
        CALL UTOPEN ('INPU', LUNIN,  CHINP, LBUFF(I+1), LRINP, 0)
      ENDIF
*
      CALL UTLOOK ('DBL3', LBUFF, NBUFF, I)
      IF (I.GT.0) THEN
        I      = I + 1
        LUNDB  = IABS (LBUFF(I))
        IF (LBUFF(I).LT.0) THEN
          I      =  I + 1
          CALL UHTOC (LBUFF(I), 4, CHDBL, 4)
          I      =  I + 1
          LRCDB  = LBUFF(I)
          I      =  I + 1
          LXTDB  = LBUFF(I)
          I      =  I + 1
          CALL UHTOC (LBUFF(I), 4, CHOPT, 4)
        ELSE
          CHDBL  = 'RO  '
          LRCDB  = 4096
          LXTDB  = 4096
          CHOPT  = 'U   '
        ENDIF
        CALL UTOPEN ('DBL3', LUNDB,  CHDBL, LBUFF(I+1), LRCDB, LXTDB)
      ENDIF
*
      IF (LUNIN.EQ.0.OR.LUNDB.EQ.0) THEN
        WRITE (L3PRNT, *) ' DEXAMB : Error in opening the files'
        GO TO 999
      ENDIF
*
* *** Initialize the Database
*
      CALL DBINIT (IXCONS, LUNDB, TOPN, LR1, LXTDB, CHOPT)
      CALL DBLOGL (LUNDB, 1)
      CALL UOPTC  (CHOPT, 'Z', II)
*
* *** See if directory creation is necessary
*
      IF (II.GT.0) THEN
        ICREA   = 1
      ELSE
        CALL RZCDIR (CHDIR, ' ')
        IF (IQUEST(1).EQ.0) THEN
          ICREA  = 0
          NWKEY  = IQUEST(8)
        ELSE
          ICREA  = 1
        ENDIF
      ENDIF
*
* *** Find the number of user keys and create directory
*
      IF (ICREA.GT.0) THEN
        NUKYS   = 0
        CHFOR   = ' '
        CTAG(1) = ' '
        CALL UTLOOK ('KEYS', LBDIR, NBDIR, I)
   10   IF (I.GT.0 .AND. I.LE.NBDIR-3) THEN
          I      = I + 1
          CALL UHTOC (LBDIR(I), 4, CTAG(NUKYS+1), 8)
          IF (CTAG(NUKYS+1).NE.'        ') THEN
            I      = I + 2
            CALL UHTOC (LBDIR(I), 4, CHVL, 4)
            IF (CHVL(1:1).NE.'I'.AND.CHVL(1:1).NE.'B'.AND.
     +          CHVL(1:1).NE.'H'.AND.CHVL(1:1).NE.'A') CHVL(1:1) = 'I'
            IF (NUKYS.GT.0) THEN
              CHFOR  = CHFOR(1:NUKYS)//CHVL(1:1)
            ELSE
              CHFOR  = CHVL(1:1)
            ENDIF
            NUKYS  = NUKYS + 1
            GO TO 10
          ENDIF
        ENDIF
        CALL DBCRSD (CHDIR, NUKYS, CHFOR, CTAG, 0, ' ')
        NWKEY  = NUKYS + 7
        IF (IQUEST(1).NE.0) THEN
          WRITE (L3PRNT, *) ' DEXAMB : Error ', IQUEST(1),
     +                      ' in creating directory'
          GO TO 50
        ENDIF
      ENDIF
*
* *** Now call user routine to prepare the data base object
*
      CALL VZERO  (KEYS, NWKEY)
      CALL DBBANK (LUNIN, LBKS, KEYS)
*
* *** Enter it in Data base
*
      CALL DBENTR (CHDIR, LBK, LBD, IXDIV, LBKS, NWKEY, KEYS, 0, 'R')
      WRITE (L3PRNT, *) ' DEXAMB : Data entered in ',CHDIR(1:NCHAR)
      WRITE (L3PRNT, *) '          Error code      ',IQUEST(1)
*
* *** Close data base and exit
*
   50 CALL DBEND
      CALL MZEND
*                                                             END DEXAMB
  999 END
+DECK, DBBANK.
      SUBROUTINE DBBANK (LUNI, LBKS, KEYS)
*
************************************************************************
*
*        SUBR. DBBANK (LUNI, LBKS, KEYS)
*
*   Creates user bank to be entered into data base
*   (Version prepared to transfer the field map to data base)
*
*   Arguments :
*
*     LUNI     Logical unit number of input file
*     LBKS     Address of the data bank created
*     KEYS     Corresponding Key vector
*
*   Called by DEXAMB
*
************************************************************************
*
+CDE, GCBANK.
+CDE, L3UNIT.
      DIMENSION       LBKS(9), KEYS(9)
*                                              start User part of DBBANK
      REAL            BZM(5000), BRM(5000)
*
*     ------------------------------------------------------------------
*
* *** Read BZ map-limits
*
      READ (LUNI, 2001) ZMINZ,ZMAXZ,RMINZ,RMAXZ,NZZ,NRZ,DZZ,DRZ
      NMAX = NZZ * NRZ
      WRITE (L3PRNT, *) ' DBBANK : NMAX, NZ, NR = ', NMAX, NZZ, NRZ
*
*  ** Read the main-component map
*
      READ (LUNI, 2002)   (BZM(I),I=1,NMAX)
*
*  ** Read BR map-limits
*
      READ (LUNI, 2001) ZMINR,ZMAXR,RMINR,RMAXR,NZR,NRR,DZR,DRR
      NMAX = NZR * NRR
      WRITE (L3PRNT, *) ' DBBANK : NMAX, NZ, NR = ', NMAX, NZR, NRR
*
*  ** Read the minor-component map
*
      READ (LUNI, 2002) (BRM(I),I=1,NMAX)
*
* *** Create the FMAP bank
*
      ND   = 2*NMAX + 4
      CALL MZFORM ('FMAP', '2I -F', IOFM)
      CALL MZBOOK (IXDIV, LBKS(1), 0, 2, 'FMAP', 0, 0, ND, IOFM, -1)
      IQ(LBKS(1)+1) = NZZ
      IQ(LBKS(1)+2) = NRZ
       Q(LBKS(1)+3) = DZZ
       Q(LBKS(1)+4) = DRZ
      CALL UCOPY (BZM, Q(LBKS(1)+5), NMAX)
      CALL UCOPY (BRM, Q(LBKS(1)+NMAX+5), NMAX)
*
* *** Prepare the key vector
*
      CALL DBPKTS (991231, 235959, KEYS(4))
      KEYS(5) = 1
*
 2001 FORMAT (4E15.5/2I15,2E15.5)
 2002 FORMAT (4E15.5)
*                                                             END DBBANK
  999 END
+PATCH, DBMAIN.
+DECK, DBMAIN.
      PROGRAM DBMAIN
*     ==============
*
************************************************************************
*                                                                      *
*        PROG. DBMAIN                                                  *
*                                                                      *
*   Main Program of the Interactive DBL3 based on the KUIP Package     *
*                                                                      *
************************************************************************
*
+CDE, L3CORES.
      COMMON /PAWC/   PAW(L3CORH)
      PARAMETER       (L3WKST=1, NARGL3=100)
      COMMON /L3FLAG/ IFTML3, IGYFL3, IHFIL3, IHISL3, INTXL3, IPRTL3
     +              , IPR2L3, IWKTL3, IXERL3, MOP3L3, ARGSL3(NARGL3)
      INTEGER         IARGL3(NARGL3)
      INTEGER         IFTML3, IGYFL3, IHFIL3, IHISL3, INTXL3, IPRTL3
     +              , IPR2L3, IWKTL3, IXERL3, MOP3L3
      REAL            ARGSL3
      EQUIVALENCE     (IARGL3(1), ARGSL3(1))
+CDE, DXLINK.
      EXTERNAL        DBTERM
      DATA            LUNER /19/, LUNMF /10/
*
*     ------------------------------------------------------------------
*
* *** Initialize ZEBRA
*
      CALL MZEBRA (-1)
*
*  ** Initialize DB-Store, User-Division, User-Links
*
      CALL DBXINI
*
*  ** Initialize PAW and KUIP
*
      CALL HLIMIT (-L3CORH)
      CALL KUINIT (L3CORK)
      INTXL3 = 1
      NWORD  = 0
      CALL IGINIT (NWORD)
+SELF, IF=VAX.
      CALL KUOPEN (LUNMF, 'SYS$LOGIN:DBASE.METAFILE', 'UNKNOWN', ISTAT)
      CALL KUOPEN (LUNER, 'SYS$LOGIN:GKSERROR.LOG', 'UNKNOWN', ISTAT)
+SELF, IF=-VAX.
      CALL KUOPEN (LUNMF, 'dbase.metafile', 'UNKNOWN', ISTAT)
      CALL KUOPEN (LUNER, 'gkserror.log', 'UNKNOWN', ISTAT)
+SELF.
      CALL HERMES (LUNER)
      CALL IGWKTY (IWKTL3)
      CALL HPLINT (IWKTL3)
      CALL IGSA   (L3WKST)
      CALL INPAW
*
*  ** Define the Exit Routine
*
      CALL KUEXIT (DBTERM)
      CALL TIMEST (99999.)
*
*  *  Create the Interactive Command structure
*
      CALL HERMES (L3PRDX)
      CALL VECDEF
      CALL INDBIN
      CALL INZEIN
      CALL INPAIN
*
*  *  Set prompt
*
      CALL KUEXEC ('SET/PROMPT ''DB >''')
*
*  *  Execute LOGON Macro
*
      CALL KUEXEC ('EXEC DBLOGN')
*
      CALL KUSPY ('NEVER')
*
      CALL KUWHAT
*
      CALL DBEND
      STOP
*                                                             END DBMAIN
      END
+DECK, DBTERM.
      SUBROUTINE DBTERM
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBTERM                                                  *
*                                                                      *
*   Exit routine for Interactive DB version                            *
*                                                                      *
*   Called by DBMAIN                                                   *
*                                                                      *
************************************************************************
*
      CALL DBEND
      CALL HPLEND
*                                                             END DBTERM
      END
+DECK, DBLOGN, T=DATA.
MACRO DBLOGN
READ MXDIS
DBSETD [MXDIS]
RETURN
+DECK, ZABEND.
      SUBROUTINE ZABEND
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. ZABEND                                                  *
*                                                                      *
*   Called by ZEBRA system                                             *
*                                                                      *
************************************************************************
*
*
      CALL DBEND
      CALL FZENDO (0, 'T')
*
      CALL ZPOSTM ('TCWM.')
*
      CALL MZEND
      STOP
*                                                             END ZABEND
      END
+PATCH, DBL3.
+DECK, DBABRD.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBABRD (PATHN, LBK, LUN, ITIME, KEYS, CHOPT)
*     ======================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBABRD (PATHN, *LBK*, LUN, ITIME, KEYS, CHOPT)          *
*                                                                      *
*   Prepares the database data structure in memory for any required    *
*   Pathname (for ASCII objects) and set of Keys, unless already done. *
*   Returns (optionally) the addresses in memory for the corresponding *
*   Key banks after checking their validity for the given time and     *
*   keys. Also writes the ASCII format on a given file specified.      *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     LBK(*)   Address(es) of Keys bank(s) KYDB   (INPUT or OUTPUT)    *
*              For option 'S' it is the support address of the linear  *
*              structure                                               *
*              For option 'M' with selection on user keys 8 and 9,     *
*              LBK(k) is the address corresponding to the ith Key-8    *
*              and the jth Key-9 value, where k = KEYS(8) * (j-1) + i  *
*     LUN      Logical unit number of the file with ASCII data         *
*              (0 if no output conversion is required)                 *
*     ITIME    Event data acquisition time (or 0, if Data not wanted)  *
*     KEYS     Vector of keys. Only the elements declared in CHOPT are *
*              assumed to contain useful information.                  *
*              When option 'M' is declared KEYS(n) (when user Key n    *
*              is selected should contain the number of data objects   *
*              to be retrieved according to the KEYS(n) values and     *
*              the values of the key elements for Key-n to be matched  *
*              should be stored in successive KEYS(i) elements, with   *
*              i starting from NWKEY+1 (NWKEY is the number of key     *
*              elements for this directory)                            *
*     CHOPT    Character string with any of the following characters   *
*          A   trust LBK address(es) if non-zero                       *
*          K   read only the keys (no data is required)                *
*          M   expect multiple Key banks to be returned (only up to    *
*              a maximum of 5 user keys)                               *
*          S   expect multiple Key banks satisfying selection on a     *
*              number of keys (Options S and M are mutually exclusive) *
*          V   declare the Data as being different in size to what is  *
*              already resident in memory                              *
*          3   selects objects with start validity time < KEYS(3)      *
*              (with option S)                                         *
*          4   selects objects with end validity time > KEYS(4)        *
*              (with option S)                                         *
*          5   specific Program version number required                *
*          7   select objects with insertion time < KEYS(7)            *
*          n   consider user key n (where 7 < n < 29 )                 *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =  1 : Illegal character option                        *
*               =  2 : Illegal path name                               *
*               =  4 : Illegal key option                              *
*                                                                      *
*     If IQUEST(1) =0, IQUEST(2) carries information whether data      *
*     part had been actually read from the disk or not                 *
*     IQUEST(2) =  0 : No disk i/o has been performed                  *
*               =  1 : Data have been refreshed from the disk          *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, P3DBL3, IF=$P3CHILD.
      DIMENSION       KEYS(9), LBK(9)
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, KLINE*80
*
*     ------------------------------------------------------------------
*
* *** Initialize options
*
      LREFDB(1) = LBK(1)
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)     GO TO 999
      IF (IOPMDA.NE.0 .AND. IOPSDA.NE.0) THEN
        IQUEST(1) = 1
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBABRD : Illegal'//
     +  ' Character option - S/M options are mutually exclusive'')',
     +  IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Create (or complete) database skeleton in memory
*                       (banks NODB and KYDB)
*
      IF (ITIME.EQ.0 .OR. IOPADA.EQ.0. OR.
     +   (IOPADA.NE.0. AND. LREFDB(1).EQ.0) )  THEN
*
        CALL DBNODE (PATH, LBNODB)
        IF (IQUEST(1).NE.0)   GO TO 999
*
        CALL DBKEYS (LBNODB, KEYS, LBK, ITIME)
        IF (IQUEST(1).NE.0)   GO TO 999
        LREFDB(1) = LBK(1)
*
*  *    That's it, when only initialisation required
*
        IQUEST(2) = 0
        IF (ITIME.EQ.0)       GO TO 999
*
      ELSE
*
        CALL RZCDIR (PATH, ' ')
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1) = 2
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBABRD : Illeg'//
     +    'al path name '//PATH(1:80)//''')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
        NKEYDK = IQUEST(7)
        NWKYDK = IQUEST(8)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
*
        IF (IOPSDA.NE.0)  THEN
          LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)
          CALL DBKEYS (LBNODB, KEYS, LBK, ITIME)
          IF (IQUEST(1).NE.0) GO TO 999
          LREFDB(1) = LBK(1)
        ENDIF
      ENDIF
*
* *** Get number of Data banks needed
*
      NKYMX  = 1
      IF (IOPMDA.NE.0)  THEN
        IF (NWKYDK.GT.NSYSDK)  THEN
          DO 60 I = NSYSDK+1, NWKYDK
            IF (IOKYDA(I).NE.0) THEN
              IF (KEYS(I).LE.0)  THEN
*
*  **           Illegal key option
*
                IQUEST(1)  = 4
                IQUEST(11) = I
                IQUEST(12) = KEYS(I)
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) THEN
                  IARGDB(1) = IQUEST(12)
                  IARGDB(2) = IQUEST(11)
                  CALL DBPRNT (LPRTDB, '(/,'' DBABRD : Illegal key op'//
     +                 'tion '',I3,'' for key '',I3,'' with option M'')'
     +,                IARGDB, 2)
                ENDIF
+SELF.
                GO TO 999
              ENDIF
*
              NKYMX  = NKYMX * KEYS(I)
            ENDIF
   60     CONTINUE
        ENDIF
      ENDIF
*
* *** Number of Key banks in S mode
*
      IF (IOPSDA.NE.0)  THEN
        LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)
        LBKYDB = LREFDB(1)
        NKYMX  = NZBANK (IDIVDB, LBKYDB)
      ENDIF
*
* *** Create (or update) Data bank(s)
*
      IQUEST(2) = 0
      I = 0
  100 I = I + 1
      IF (IOPSDA.EQ.0)  THEN
        LBKYDB = LBK(I)
      ENDIF
      LBDADB = LQ(KOFUDB+LBKYDB-KLDADB)
      CALL DBCHCK (LBKYDB, ITIME, KEYS, LBDADB)
      IF (IQUEST(1).NE.0)     GO TO 999
      IF (LUN.GT.0) THEN
        IF (LBDADB.GT.0) THEN
          NDATA  = IQ(KOFUDB+LBDADB-1)
          IF (NDATA.GT.0) THEN
+SELF, IF=-$P3CHILD.
*
*   *       Display data if exists, if it does not, display dummy data
*
            NTOT   = 0
            CALL UCOPY (IQ(KOFUDB+LBKYDB+1), KEYVDK(1), NWKYDK)
+SELF, IF=$DEBUG, IF=-$P3CHILD.
            NREC   = 0
+SELF, IF=-$P3CHILD.
  120       IF (NTOT.LT.NDATA) THEN
              CALL DBLIND (IQ(KOFUDB+LBDADB+1), NTOT, KLINE, LENG)
              IF (LENG.GT.0) THEN
                WRITE (LUN, 1000) KLINE(1:LENG)
              ELSE
                WRITE (LUN, *)
              ENDIF
+SELF, IF=$DEBUG, IF=-$P3CHILD.
              NREC   = NREC + 1
+SELF, IF=-$P3CHILD.
              GO TO 120
            ENDIF
+SELF, IF=$DEBUG, IF=-$P3CHILD.
            IF (IDEBDB.GT.1) THEN
              IARGDB(1) = NREC
              IARGDB(2) = I
              CALL DBPRNT (LPRTDB, '(/,'' DBABRD : '',I10,'' records '//
     +             'written for set '',I4)', IARGDB, 2)
            ENDIF
+SELF, IF=$P3CHILD.
            RNDBP3 = 'DBABRD'
            NWDBP3 = 2
            IWDBP3(1) = LUN
            IWDBP3(2) = NDATA
            CALL DBCHLD
            IF (IQDBP3.EQ.0)
     +        CALL APFZUT (LODBP3, IDIVDB, LBDADB, 1, 'S', 0, 0, 0)
+SELF.
          ENDIF
        ENDIF
      ENDIF
      IF (IOPSDA.EQ.0)  THEN
        IF (I.LT.NKYMX)       GO TO 100
      ELSE
        LBKYDB = LQ(KOFUDB+LBKYDB)
        IF (LBKYDB.NE.0)      GO TO 100
      ENDIF
+SELF, IF=-$P3CHILD.
*
 1000 FORMAT (A)
+SELF.
*                                                             END DBABRD
  999 END
+DECK, DBABWR.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBABWR (PATHN, LBK, LUN, NWKEY, KEY, KEYO, CHOPT)
*     ============================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBABWR (PATHN, *LBK*, LUN, NWKEY, KEY, KEYO, CHOPT)     *
*                                                                      *
*   Stores ASCII data from a disk file to the data base and also enters*
*   in the memory ala DBUSE in NODE/KEY structure                      *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     LBK(*)   Address of Keys bank KYDB   (INPUT or OUTPUT)           *
*     LUN      Logical unit number of the file where ASCII data reside *
*     NWKEY    Number of keys associated with the data bank            *
*     KEY      Vector of keys                                          *
*     KEYO     Old vector of keys (for option X only)                  *
*     CHOPT    Character string with any of the following characters   *
*          A   trust LBK address if non-zero                           *
*          B   Save in the special backup file; not in standard Journal*
*          C   create Node/Key data structure ala DBUSE                *
*          X   Replaces an old set of keys                             *
*          7   Insertion time as supplied by user to be honoured       *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 61 : Too many keys                                   *
*               = 66 : Illegal logical unit number                     *
*               = 67 : File too long; no space in buffer               *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DZPACK.
+CDE, P3DBL3, IF=$P3CHILD.
      DIMENSION       KEY(9), KEYO(9), LBK(9)
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, KLINE*80
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Decode the character option
*
      LREFDB(1) = LBK(1)
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)     GO TO 999
      PACKDZ = .FALSE.
*
      IOPKDA = 0
      IOPRDA = 1
      IOPSDA = 0
      IOPTDA = 1
      IOPUDA = 0
      IOPZDA = 0
*
* *** Check the number of keys
*
      IF (NWKEY.GT.MXDMDK)  THEN
        IQUEST(1) = 61
        IQUEST(11)= NWKEY
        IQUEST(12)= MXDMDK
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBABWR : Too man'//
     +  'y keys '',I6,'' maximum permitted '',I6)', IQUEST(11), 2)
+SELF.
        GO TO 999
      ENDIF
*
      IF (LUN.LE.0) THEN
        IQUEST(1) = 66
        IQUEST(11)= LUN
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBABWR : Illegal'//
     +  ' unit number '',I10,'' for ASCII file'')', IQUEST(11), 1)
+SELF.
        GO TO 999
      ENDIF
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
      IF (NWKEY.GE.NSYSDK)  THEN
        NTKEY  = NWKEY
      ELSE
        NTKEY  = NINEDK
      ENDIF
*
* *** Prepare the output with old keys if option X is selected
*
      IF (IOPXDA.NE.0) THEN
        CALL VZERO (KEYVDK, MXDMDK)
        KEYVDK(MBVRDB) = KEY(MBVRDB)
        KEYVDK(MEVRDB) = KEY(MEVRDB)
        KEYVDK(MPVSDB) = KEYO(MPVSDB)
        IOKYDA(MPVSDB) = 1
        KEYVDK(MFLGDB) = MSBIT1 (KEYVDK(MFLGDB), JIGNDB)
        IF (IOKYDA(MITMDB).NE.0) KEYVDK(MITMDB) = KEY(MITMDB)
        IF (NWKEY.GT.NSYSDK) THEN
          DO 10 NK = NSYSDK+1, NWKEY
            IOKYDA(NK) = 1
            KEYVDK(NK) = KEYO(NK)
   10     CONTINUE
        ENDIF
*
        IF (LSTRDL(3).NE.0) CALL MZDROP (IDISDB, LSTRDL(3), 'L')
        JBIAS  = 2
        CALL DBBOOK (IDISDB, LSTRDL(3), LSTRDL(3), JBIAS, 'SAME', 0, 0,
     +               0, 2, 0)
        IF (IQUEST(1).NE.0)   GO TO 999
*
        CALL DBKOUT (PATH, IDISDB, LSTRDL(3), NTKEY, KEYVDK, 0)
        IF (IQUEST(1).NE.0)   GO TO 999
        IF (LSTRDL(3).NE.0) THEN
          CALL MZDROP (IDISDB, LSTRDL(3), 'L')
          LSTRDL(3) = 0
        ENDIF
      ENDIF
*
* *** Prepare the Key vector array
*
      CALL VZERO (KEYVDK, MXDMDK)
      KEYVDK(MBVRDB) = KEY(MBVRDB)
      KEYVDK(MEVRDB) = KEY(MEVRDB)
      KEYVDK(MPVSDB) = KEY(MPVSDB)
      IOKYDA(MPVSDB) = 1
      IF (IOKYDA(MITMDB).NE.0) KEYVDK(MITMDB) = KEY(MITMDB)
      IF (NWKEY.GT.NSYSDK) THEN
        DO 20 NK = NSYSDK+1, NWKEY
          IOKYDA(NK) = 1
          KEYVDK(NK) = KEY(NK)
   20   CONTINUE
      ENDIF
*
*  ** Read the data part
*
      IF (LSTRDL(3).NE.0) CALL MZDROP (IDIVDB, LSTRDL(3), 'L')
      NDATA  = NDMXDB
      JBIAS  = 2
+SELF, IF=-$P3CHILD.
      CALL DBBOOK (IDIVDB, LSTRDL(3), LSTRDL(3), JBIAS, 'USER', 0, 0,
     +             NDATA, 1, -1)
      IF (IQUEST(1).NE.0)     GO TO 999
*
*  ** Now read the file
*
      NDAT   = 0
      NREC   = 0
   25 READ (LUN, 1000, ERR=30, END=30) KLINE
      NREC   = NREC + 1
      LENG   = LENOCC (KLINE)
      CALL DBLINC (KLINE, LENG, IQ(KOFUDB+LSTRDL(3)+1), NDAT)
      IF (NDAT.GT.NDATA-20) THEN
        IQUEST(1) = 67
        IQUEST(11)= NREC
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBABWR : Buffer '//
     +  'full after '',I8,'' records'')', IQUEST(11), 1)
+SELF, IF=-$P3CHILD.
        GO TO 990
      ENDIF
      GO TO 25
*
   30 NDP    = NDAT - NDATA
      IF (NDP.LT.0) CALL MZPUSH (IDIVDB, LSTRDL(3), 0, NDP, 'I')
+SELF, IF=$P3CHILD.
      RNDBP3 = 'DBABWR'
      NWDBP3 = 1
      IWDBP3(1) = LUN
      CALL DBCHLD
      IF (IQDBP3.NE.0)        GO TO 999
      NDAT   = IWDBP3(2)
      CALL APFZIN (LIDBP3, IDIVDB, LSTRDL(3), JBIAS, 'E', 0, IWDBP3)
+SELF.
*
* *** Write out the data
*
      CALL DBKOUT (PATH, IDIVDB, LSTRDL(3), NTKEY, KEYVDK, 0)
      IF (IQUEST(1).NE.0)     GO TO 990
*
* *** Create data bank in memory ala DBUSE
*
      IF (IOPCDA.NE.0)  THEN
*
*  **   Create database skeleton in memory (banks NODB and KYDB)
*
        IF (IOPADA.EQ.0. OR. (IOPADA.NE.0. AND. LREFDB(1).EQ.0) )  THEN
*
          CALL DBNODE (PATH, LBNODB)
          IF (IQUEST(1).NE.0) GO TO 990
*
*  *      Switch off M and/or S option of DBUSE
*
          IOPMDA = 0
          IOPSDA = 0
*
          CALL DBKEYS (LBNODB, KEYVDK, LBK, KEYVDK(MBVRDB))
          IF (IQUEST(1).NE.0) GO TO 990
          LREFDB(1) = LBK(1)
          CALL UCOPY (KEYVDK(1), IQ(KOFUDB+LREFDB(1)+1), NWKYDK)
          NDK    = IQ(KOFUDB+LREFDB(1)-1)
          IQ(KOFUDB+LREFDB(1)+NDK+MKYFRI) = 0
          IQ(KOFUDB+LREFDB(1)+NWKYDK+1)   = KEYVDK(MEVRDB)
*
        ELSE
*
          CALL UCOPY (KEYVDK(1), IQ(KOFUDB+LREFDB(1)+1), NWKYDK)
          NDK    = IQ(KOFUDB+LREFDB(1)-1)
          IQ(KOFUDB+LREFDB(1)+NDK+MKYFRI) = 0
          IQ(KOFUDB+LREFDB(1)+NWKYDK+1)   = KEYVDK(MEVRDB)
        ENDIF
*
*  **   Now copy the data banks appended at LSUP to the key bank
*
        CALL ZSHUNT (IDIVDB, LSTRDL(3), LREFDB(1), -1, 0)
        LSTRDL(3) = 0
        IQUEST(1) = 0
      ENDIF
*
  990 IF (LSTRDL(3).NE.0) THEN
        IERR   = IQUEST(1)
        CALL MZDROP (IDIVDB, LSTRDL(3), 'L')
        LSTRDL(3) = 0
        IQUEST(1) = IERR
      ENDIF
+SELF, IF=-$P3CHILD.
*
 1000 FORMAT (A80)
+SELF.
*                                                             END DBABWR
  999 END
+DECK, DBCRSD.
      SUBROUTINE DBCRSD (PATH, NKEX, CHFOR, CHTAG, MXKP, CHOPT)
*     =========================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBCRSD (PATH, NKEX, CHFOR, CHTAG, MXKP, CHOPT)          *
*                                                                      *
*   Creates a L3 directory with standard keys plus NKEX extra keys     *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATH     Character string describing the pathname                *
*     NKEX     Number of user keys                                     *
*     CHFOR    Character string specifying the user key type           *
*     CHTAG    String of 8-character tags for the user key elements    *
*     MXKP     Maximum number of objects in a partitioned directory    *
*     CHOPT    Character string with any of the following characters   *
*          P   Create partitioned subdirectories for the pathname      *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 43 : Illegal number of user keys                     *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
      CHARACTER*(*)   PATH, CHTAG(*), CHFOR, CHOPT
      CHARACTER       CFOR*100
*
*     ------------------------------------------------------------------
*
* *** Decode the character option
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0) GO TO 999
      KEY7DK = 0
*
* *** Check the number of user keys
*
      IF (NKEX.LT.0.OR.NKEX.GT.MXDMDK-NSYSDK) THEN
        IQUEST(1) = 43
        IQUEST(11)= NKEX
        IQUEST(12)= MXDMDK - NSYSDK
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          CFOR   = PATH
          CALL DBPRNT (LPRTDB, '(/,'' DBCRSD : Illegal number of user'//
     +         ' keys '',2I12,'' for '',/,''        '//CFOR//''')',
     +         IQUEST(11), 2)
        ENDIF
+SELF.
        GO TO 999
      ENDIF
*
* *** Prepare the Tag and Type of the keys
*
      CFOR   = CHFTDK(1:NSYSDK)
      DO 10 I = 1, NSYSDK
   10 CTAGDK(I) = CHTGDK(I)
      IF (NKEX.GT.0) THEN
        DO 20 K = 1, NKEX
          CTAGDK(NSYSDK+K) = CHTAG(K)
          CFOR(NSYSDK+K:NSYSDK+K) = CHFOR(K:K)
   20   CONTINUE
      ENDIF
      NWKEY  = NSYSDK + NKEX
*
* *** Now create the directory
*
      IF (IOPPDA.EQ.0) THEN
        CALL DBMDIR (PATH, NWKEY, CFOR, CTAGDK)
      ELSE
        IF (MXKP.LE.0) THEN
          MXKPU  = MXKPDK
        ELSE
          MXKPU  = MXKP
        ENDIF
        CALL DBMDIP (PATH, NWKEY, CFOR, CTAGDK, MXKPU)
      ENDIF
*                                                             END DBCRSD
  999 END
+DECK, DBDELT.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBDELT (PATHN, CHOPT)
*     ================================
*
************************************************************************
*                                                                      *
*        SUBR. DBDELT (PATHN, CHOPT)                                   *
*                                                                      *
*   Deletes the directory from the current level downwards as given    *
*   in the path name                                                   *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Path name to be deleted                                 *
*     CHOPT    Character string with any of the following characters   *
*          B   Save in the special backup file; not in standard Journal*
*                                                                      *
*   Called by user,   DBFZUP, DBKEPT, DBACTI                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =171 : Illegal Path name                               *
*               =172 : Cannot find the top directory for the path name *
*               =173 : Error in RZ for reading the dictionary object   *
*               =174 : Error in FZOUT for saving the journal file      *
*               =175 : Error in RZ in writing the dictionary object    *
*               =176 : Error in RZ in purging the dictionary directory *
*               =177 : Error in RZ in deleting the tree                *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, P3DBL3, IF=$P3CHILD.
      PARAMETER       (NLEVM=20)
      DIMENSION       NCHD(NLEVM), ISDI(NLEVM)
      DIMENSION       NKEY(NLEVM), IOPT(NLEVM), NSDI(NLEVM)
      DIMENSION       IHDIR(4)
      CHARACTER       PATH*80, PATHX*16, PATHY*80, PATHF*80, PATHZ*16
      CHARACTER       PATHD*80, PATHN*(*), CHOPT*(*), PATHL*80
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Load the current directory
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)           GO TO 999
      KEY7   = KEY7DK
      KEY7DK = 0
      PATHL  = ' '
      CALL DBSBLC (PATHN, PATH, NCHR)
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 171
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDELT : Illegal'//
     +  ' path name '//PATH(1:NCHR)//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL RZCDIR (PATH, 'R')
      NCHR   = INDEX (PATH, ' ') - 1
      IF (NCHR.LE.0) NCHR = MAXLDB
      NCHRT  = INDEX (PATH(3:NCHR), '/') - 1
      IF (NCHRT.LE.0) NCHRT = NCHR - 2
      PATHZ  = PATH(3:NCHRT+2)
      PATHF  = PATH(3:NCHRT+2)//'/DICTIONARY'
      IF (PATH.EQ.PATHF)            GO TO 999
      PATHF  = PATH(3:NCHRT+2)//'/HELP'
      IF (PATH.EQ.PATHF)            GO TO 999
*
* *** Find the appropriate top directory name
*
      JBIAS  = -KLDICT
      LBNODB = LTOPDB
   10 IF (LBNODB.GT.0) THEN
        NCHRT  = IQ(KOFUDB+LBNODB+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LBNODB+MUPNAM), 4, TOPNDI, NCHRT)
        IF (PATHZ.EQ.TOPNDI(1:NCHRT)) THEN
          IF (IOPBDA.EQ.0) THEN
            LUFZDF = IQ(KOFUDB+LBNODB+MUPJFL)
          ELSE
            LUFZDF = IQ(KOFUDB+LBNODB+MUPBAK)
          ENDIF
          IOUT   = IQ(KOFUDB+LBNODB+MUPFLG)
          IOPS   = MOD (IQ(KOFUDB+LBNODB+MUPSRV)/10, 10)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          IOPP   = MOD (IQ(KOFUDB+LBNODB+MUPSRV), 10)
+SELF.
        ELSE
          LBNODB = LQ(KOFUDB+LBNODB)
          GO TO 10
        ENDIF
      ELSE
        IQUEST(1) = 172
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDELT : Illegal'//
     +  ' top directory for '//PATH(1:NCHR)//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      IF (IOUT.EQ.0) IOPS = 0
*
* *** Find the dictionary record
*
      PATHD  = '//'//PATHZ(1:NCHRT)//'/DICTIONARY'
      CALL RZCDIR (PATHD, ' ')
      IF (IQUEST(1).NE.0) THEN
        LFIXDB    = 0
        IQUEST(1) = 173
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDELT : '//
     +  'RZCDIR error for path name '//PATHD//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      ISTP   = NWKYDK + 1
      IF (NKEYDK.GT.0) THEN
        IPNT   = KOFSDB + LCDRDB + IKDRDB
        IMIN   = IUHUNT (-1, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)
        IF (IMIN.GT.0) THEN
          IMIN   = (IMIN - MSERDB) / ISTP + 1
          CALL DBKEYT
          CALL DBKEYR (IMIN, NWKYDK, KEYVDK)
          IF (LQ(KOFUDB+LBNODB+JBIAS).LE.0) THEN
            CALL DBRZIN (IDIVDB, LBNODB, JBIAS, IMIN, ICYCL, PATHD)
            IF (IQUEST(1).NE.0)     GO TO 999
          ENDIF
          LFIXDB = LQ(KOFUDB+LBNODB+JBIAS)
        ELSE
          LFIXDB = 0
        ENDIF
      ELSE
        LFIXDB = 0
      ENDIF
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
      IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
        CALL DBWLOK
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
        CALL DBSTSV (PATHZ, 0)
+SELF, IF=$P3CHILD, IF=$SERVER.
        LUFZDF = LODBP3
        IQUEST(1) = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        IF (IQUEST(1).NE.0)         GO TO 999
      ENDIF
+SELF.
*
* *** Prepare the journal file if needed
*
      IF (LUFZDF.GT.0) THEN
        IF (IOPBDA.EQ.0) THEN
          NWDOP  = 0
        ELSE
          NWDOP  = 1
        ENDIF
        NDOP   = (NCHR + 3) / 4
        IHEADF(MACTDF) = 4
        IHEADF(MNKYDF) = 0
        IHEADF(MOPTDF) = NWDOP
        IHEADF(MPATDF) = NDOP
        IHEADF(MPREDF) = 0
        IF (KEY7.LE.0) THEN
          CALL DATIME (IDATE, ITIME)
          CALL DBPKTM (IDATE, ITIME, KEY7)
        ENDIF
        IHEADF(MINSDF) = KEY7
        IF (NWDOP.EQ.1) CALL UCTOH ('B   ', IHEADF(MINSDF+1), 4, 4)
        CALL UCTOH (PATH, IHEADF(MINSDF+NWDOP+1), 4, 4*NDOP)
        CALL MZIOCH (IOFMDF, NWFMDF, '6I -H')
        NWDH   = NWDOP + NDOP + MINSDF
*
*  **   Now write on the sequential output
*
+SELF, IF=$P3CHILD.
        RNDBP3 = 'DBDELT  '
        NWDBP3 = 2
        CALL UCTOH ('JOURNAL ', IWDBP3, 4, 8)
        CALL DBCHLD
        IQUEST(1) = IQDBP3
        IF (IQUEST(1).NE.0)         GO TO 999
+SELF.
        CALL FZOUT (LUFZDF, IDIVDB, 0, 1, 'Z', IOFMDF, NWDH, IHEADF)
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1) = 174
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDELT : FZOUT'//
     +    ' error for path name '//PATH(1:NCHR)//''')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
      ENDIF
*
      IQUEST(1) = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
* *** Server environment, Public mode
*
      IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
        CALL DBCWSV
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        GO TO 999
      ENDIF
+SELF, IF=-$P3CHILD.
*
* *** Find the level below which all directories are deleted
*
   15 NLEV   = 1
      NCHD(NLEV) = NCHR
      NCHL   = 0
      DO 20 I = 1, NCHR
        NCH    = NCHR - I + 1
        IF (PATH(NCH:NCH).EQ.'/') THEN
          NCHL   = NCH
          GO TO 25
        ENDIF
   20 CONTINUE
   25 IF (NCHL.LE.2)                GO TO 999
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 171
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDELT : Illegal'//
     +  ' path name '//PATH(1:NCHR)//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      IF (KEY7.GT.0) THEN
        CALL DBPKTM (IQUEST(16), IQUEST(17), KEY7N)
        IF (KEY7.LT.KEY7N)          GO TO 999
      ENDIF
*
* *** Update the dictionary information if it exists
*
      IF (LFIXDB.GT.0) THEN
        NITEM  = IQ(KOFUDB+LFIXDB+MDCNTM)
        IF (NKEYDK.GT.0) THEN
          IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
        ELSE
          IOPTP  = 0
        ENDIF
*
*  **   Now scan down to find all the subdirectories
*
   30   IF (NLEV.GT.1) THEN
          PATH   = PATH(1:NCHD(NLEV-1))//'/'//PATHX
          NCHD(NLEV) = NCHD(NLEV-1) + NCHAR + 1
          CALL RZCDIR (PATH, ' ')
          NKEYDK = IQUEST(7)
          NWKYDK = IQUEST(8)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          IF (NKEYDK.GT.0) THEN
            IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
          ELSE
            IOPTP  = 0
          ENDIF
        ENDIF
        NKEY(NLEV) = NKEYDK
        IOPT(NLEV) = IOPTP
        ISDI(NLEV) = 0
        NSDI(NLEV) = IQ(KOFSDB+LCDRDB+KNSDDB)
*
   35   ISDI(NLEV) = ISDI(NLEV) + 1
        IF (ISDI(NLEV).LE.NSDI(NLEV)) THEN
*
*  **     If a new subdirectory go down one level
*
          LS    = IQ(KOFSDB+LCDRDB+KLSDDB)
          IPNT  = LS + 7 * (ISDI(NLEV) - 1)
          CALL ZITOH (IQ(KOFSDB+LCDRDB+IPNT), IHDIR, 4)
          CALL UHTOC (IHDIR, 4, PATHX, 16)
          NCHAR = INDEX (PATHX, ' ') - 1
          IF (NCHAR.LE.0.OR.NCHAR.GT.16) NCHAR = 16
          IF (IOPTP.NE.0) THEN
            DO 45 IK = 1, NKEYDK
              KK     = IK
              IDIG   = 0
   40         IF (KK.GT.0) THEN
                KK     = KK / 10
                IDIG   = IDIG + 1
                GO TO 40
              ENDIF
              IF (NCHAR.EQ.IDIG) THEN
                WRITE (PATHY, '(I8)') IK
                I1     = 8 - IDIG + 1
                PATHZ  = PATHY(I1:8)
                IF (PATHZ.EQ.PATHX) GO TO 35
              ENDIF
   45       CONTINUE
          ENDIF
          NLEV   = NLEV +1
          GO TO 30
*
        ELSE
*
*  **     Check if the name is to be deleted
*
          PATHY  = PATH(NCHRT+3:NCHD(NLEV))
          NCHRU  = NCHD(NLEV) - NCHRT - 2
          IF (NITEM.GT.0) THEN
            DO 50 I = 1, NITEM
              IPNT   = KOFUDB + LFIXDB + (I - 1) * NWITDB + 1
              NCHF   = IQ(IPNT+MDCNCH)
              IF (NCHRU.EQ.NCHF) THEN
                CALL UHTOC (IQ(IPNT+MDCNAM), 4, PATHF, NCHF)
                PATHF  = PATHF(1:NCHF)
                IF (PATHY.EQ.PATHF) THEN
                  IQ(IPNT+MDCITM) = -1
                  GO TO 55
                ENDIF
              ENDIF
   50       CONTINUE
          ENDIF
*
   55     NLEV   = NLEV - 1
          IF (NLEV.GE.1) THEN
            LUP    = LQ(KOFSDB+LCDRDB+1)
            CALL MZDROP (0, LCDRDB, ' ')
            LCDRDB = LUP
            NKEYDK = NKEY(NLEV)
            IOPTP  = IOPT(NLEV)
            GO TO 35
          ENDIF
        ENDIF
*
* *** Lock the directory if necessary
*
   60 IF (IOPS.NE.0) THEN
        CALL RZCDIR (PATHD, ' ')
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        CALL RZLOCK ('DBDELT')
        PATHL  = PATHD
      ENDIF
*
*  **   All subdirectories looked at; now store dictionary
*
        CALL RZCDIR (PATHD, ' ')
        CALL RZOUT (IDIVDB, LFIXDB, KEYVDK, ICYCLE, 'S')
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1) = 175
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDELT : RZOUT'//
     +    ' error for path name '//PATHD//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
          GO TO 998
        ENDIF
        CALL RZPURG (0)
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1) = 176
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDELT : RZPUR'//
     +    'G error for path name '//PATHD//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
          GO TO 998
        ENDIF
      ENDIF
*
* *** Free the directory if locked
*
      IF (PATHL.NE.' ') THEN
        CALL RZCDIR (PATHL, ' ')
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        CALL RZFREE ('DBDELT')
        PATHL  = ' '
      ENDIF
*
  100 IQUEST(1) = 0
      PATHZ  = PATH(NCHL+1:NCHR)
      PATH   = PATH(1:NCHL-1)
*
*  ** Lock the directory if necessary
*
      IF (IOPS.NE.0) THEN
        CALL RZCDIR (PATH, ' ')
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        CALL RZLOCK ('DBDELT')
        PATHL  = PATH
      ELSE
        CALL RZCDIR (PATH, ' ')
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
      ENDIF
      CALL RZDELT (PATHZ)
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 177
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDELT : RZDELT '//
     +  'error for path name '//PATH(1:NCHR)//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
      ENDIF
*
* *** Free the directory if locked
*
  998 IF (PATHL.NE.' ') THEN
        IERR   = IQUEST(1)
        CALL RZCDIR (PATHL, ' ')
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        CALL RZFREE ('DBDELT')
        IQUEST(1) = IERR
      ENDIF
+SELF.
*                                                             END DBDELT
  999 END
+DECK, DBDONT.
      SUBROUTINE DBDONT (PATHN, IUDIV, LSUP, NWKEY, KEY, CHOPT)
*     =========================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBDONT (PATHN, IUDIV, LSUP, NWKEY, KEY, CHOPT)          *
*                                                                      *
*   Stores data from memory to disk. If data exist with the same user  *
*   keys, the old object is physically replaced. This mode is not      *
*   recommended for all calibration data.                              *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     IUDIV    Division index of the user data bank                    *
*     LSUP     Address of bank in memory where data reside             *
*     NWKEY    Number of keys associated with the data bank            *
*     KEY      Vector of keys                                          *
*     CHOPT    Character string with any of the following characters   *
*          B   Save in the special backup file; not in standard Journal*
*          7   Insertion time as supplied by user to be honoured       *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 61 : Too many keys                                   *
*               = 71 : Illegal path name                               *
*               = 73 : RZ error during writing to disk                 *
*               = 75 : Cannot find the Top directory name in pathname  *
*               = 76 : Cannot form the IO descriptor for the FZ header *
*               = 77 : FZOUT fails to write on to the sequential file  *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, P3DBL3, IF=$P3CHILD.
      PARAMETER       (NLEVM=20)
      DIMENSION       KEY(9), LSUP(9)
      DIMENSION       KEYV(MXDMDK), KEYO(MXDMDK), KEYN(MXDMDK)
      CHARACTER       CHOPT*(*), PATHN*(*)
      CHARACTER       PATH*80, PATHY*80, PATHX*16, PATHL*80, TOPN*16
      CHARACTER       CFORM(6)*1, CHFOR*100, CHCUR(NLEVM)*1
      INTEGER         NLCUR(NLEVM)
      DATA            CFORM /'B', 'I', 'F', 'D', 'H', 'A'/
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Decode the character option (no compression of data)
*
      LREFDB(1) = LSUP(1)
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)            GO TO 999
      IOPRDA = 1
*
* *** Check the number of keys
*
      IF (NWKEY.GT.MXDMDK)  THEN
        IQUEST(1) = 61
        IQUEST(11)= NWKEY
        IQUEST(12)= MXDMDK
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDONT : Too man'//
     +  'y keys '',I6,'' maximum permitted '',I6)', IQUEST(11), 2)
+SELF.
        GO TO 999
      ENDIF
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Set the current directory path name
*
      PATHX  = ' '
      PATHY  = PATH
      PATHL  = ' '
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0)            GO TO 991
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      KST    = NWKYDK + 1
      CALL RZCDIR (PATHY, 'R')
      CALL DBKYTG
      IF (NKEYDK.NE.0)  THEN
        IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)
        IOPTP  = JBIT (IOPTP, JPRTDB)
      ELSE
        IOPTP  = 0
      ENDIF
*
      IF (NWKYDK.NE.NWKEY) THEN
        IQUEST(1) = 61
        IQUEST(11)= NWKEY
        IQUEST(12)= NWKYDK
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDONT : Illegal'//
     +  ' number of keys '',I10,'' & as in directory'',I6)', IQUEST(11),
     +  2)
+SELF.
        GO TO 999
      ENDIF
*
* *** Extract the Top level directory name
*
      CALL DBTOPN (PATHY, TOPN, NCH)
      IF (NCH.EQ.0) THEN
        IQUEST(1) = 75
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDONT : No top '//
     +  'directory for '//PATHY//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** See if transcript file is needed
*
      LTOP   = LTOPDB
      IOPS   = 0
      IOUT   = 0
+SELF, IF=-$SERVER, CRAY.
      IOPP   = 0
+SELF.
   10 IF (LTOP.NE.0) THEN
        NCH    = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCH)
        TOPNDI = TOPNDI(1:NCH)
        IF (TOPN.EQ.TOPNDI) THEN
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)
          IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10)
          IF (IOPBDA.EQ.0) THEN
            LUFZDF = IQ(KOFUDB+LTOP+MUPJFL)
          ELSE
            LUFZDF = IQ(KOFUDB+LTOP+MUPBAK)
          ENDIF
        ELSE
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 10
        ENDIF
      ELSE
        LUFZDF = 0
        IOPP   = 0
      ENDIF
      IF (IOUT.EQ.0) IOPS = 0
*
* *** Prepare the Key vector array
*
      CALL VZERO (KEYVDK, MXDMDK)
      KEYVDK(MBVRDB) = KEY(MBVRDB)
      KEYVDK(MEVRDB) = KEY(MEVRDB)
      KEYVDK(MPVSDB) = KEY(MPVSDB)
      IF (IOKYDA(MITMDB).NE.0) THEN
        KEYVDK(MITMDB) = KEY(MITMDB)
      ELSE
        CALL DATIME (IDATE, ITIME)
        CALL DBPKTM (IDATE, ITIME, IDATM)
        KEYVDK(MITMDB) = IDATM
      ENDIF
      IF (NWKEY.GT.NSYSDK) THEN
        DO 15 NK = NSYSDK+1, NWKEY
          IOKYDA(NK) = 1
          KEYVDK(NK) = KEY(NK)
   15   CONTINUE
      ENDIF
*
* *** Encode the character option, IO descriptor for the header
*
      IF (IOPP.NE.0.OR.LUFZDF.GT.0) THEN
        NDOP   = LENOCC (CHOPT)
        NDOP   = (NDOP + 3) / 4
*
        NLEV   = 1
        NCUR   = 5
        IFORO  = 2
        CHCUR(NLEV) = CFORM(IFORO)
        DO 20 I = 1, NWKYDK
          IFORM  = IOTYDK(I)
          IF (IFORM.EQ.6) IFORM = 5
          IF (IFORM.EQ.IFORO) THEN
            NCUR   = NCUR + 1
          ELSE
            NLCUR(NLEV) = NCUR
            IF (NLEV.GE.NLEVM) THEN
              IQUEST(1) = 76
+SELF, IF=$DEBUG.
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDONT : '//
     +        'Cannot get IO descriptor '//PATHY//''')', IARGDB, 0)
+SELF.
              GO TO 999
            ENDIF
            NLEV   = NLEV + 1
            CHCUR(NLEV) = CFORM(IFORM)
            NCUR   = 1
            IFORO  = IFORM
          ENDIF
   20   CONTINUE
        NLCUR(NLEV) = NCUR
*
+SELF, IF=-IBM, -$P3CHILD.
        WRITE (CHFOR, 2001) (NLCUR(I), CHCUR(I), I = 1, NLEV)
+SELF, IF=IBM, IF=$P3CHILD.
        CHFOR  = ' '
        II     = 1
        DO 25 I = 1, NLEV
          CALL UTWRIT (CHFOR(II:II+1), '(I2)', NLCUR(I))
          II     = II + 2
          CHFOR(II:II) = CHCUR(I)
          II     = II + 2
   25   CONTINUE
+SELF.
        II     = 4 *NLEV
        CHFOR = CHFOR(1:II)//' -H'
        CALL MZIOCH (IOFMDF, NWFMDF, CHFOR(1:II+3))
*
*  **   Complete the header
*
        NWDP   = (NCHAR + 3) / 4
        NWDH   = NWDP + NDOP + NWKYDK + 5
        IHEADF(MACTDF) = 9
        IHEADF(MNKYDF) = NWKYDK
        IHEADF(MOPTDF) = NDOP
        IHEADF(MPATDF) = NWDP
        IHEADF(MPREDF) = 0
        IF (NDOP.GT.0)
     +    CALL UCTOH (CHOPT, IHEADF(MPREDF+NWKYDK+1), 4, 4*NDOP)
        CALL UCTOH (PATHY, IHEADF(MPREDF+NWKYDK+NDOP+1), 4, 4*NWDP)
        CALL UCOPY (KEYVDK, IHEADF(MPREDF+1), NWKYDK)
      ENDIF
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
      IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
        LUFZDF = LUFMDB
        CALL DBWLOK
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
        CALL DBSTSV (TOPN, 0)
+SELF, IF=$P3CHILD.
        LUFZDF = LODBP3
        RNDBP3 = 'DBDONT '
        NWDBP3 = 2
        CALL UCTOH ('JOURNAL ', IWDBP3, 4, 8)
        CALL DBCHLD
        IQUEST(1) = IQDBP3
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        IF (IQUEST(1).NE.0)          GO TO 999
      ENDIF
+SELF.
*
*  ** Write the sequential output if needed
*
      IF (LUFZDF.GT.0) THEN
        CALL FZOUT (LUFZDF, IUDIV, LREFDB(1), 1, 'L', IOFMDF, NWDH,
     +              IHEADF)
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1)  = 77
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDONT : Error'//
     +    ' in FZOUT while writing Data for '//PATHY//''')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
      ENDIF
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
      IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
*
        CALL DBCWSV
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        GO TO 999
      ENDIF
+SELF, IF=-$P3CHILD.
*
* *** Lock the directory if necessary
*
      IF (IOPP.EQ.0.AND.IOPS.NE.0) THEN
        CALL RZLOCK ('DBDONT')
        PATHL  = PATHY
      ENDIF
*
* *** Look if object already exists with similar user keys
*
      IF (IOPTP.EQ.0) THEN
        CALL DBHUNT (KEYV)
*
      ELSE
*
        NKEYS  = NKEYDK
        DO 30 JK = 1, NKEYS
          ICURDT = NKEYS + 1 - JK
          CALL DBPATH (PATHX, ICURDT)
          IF (JK.NE.1) THEN
            CALL RZCDIR (PATHY, ' ')
            IF (IQUEST(1).NE.0)      GO TO 991
          ENDIF
*
          CALL RZCDIR (PATHX, ' ')
          IF (IQUEST(1).NE.0)        GO TO 991
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          CALL DBHUNT (KEYV)
          IF (KEYV(1).GT.0)          GO TO 35
*
   30   CONTINUE
*
      ENDIF
*
* *** Either update an old record
*
   35 IF (KEYV(1).GT.0) THEN
        CALL RZOUT (IUDIV, LREFDB(1), KEYV, ICYCLE, 'L')
        IER    = IQUEST(1)
        CALL RZPURG (0)
        IF (IER.NE.0) IQUEST(1) = IER
*
* *** Or enter a new one
*
      ELSE
*
*  **   Take necessary action for partitioned and nonpartiitined dataset
*
        IF (IOPTP.EQ.0) THEN
          KOBJ   = 0
        ELSE
          CALL RZCDIR (PATHY, ' ')
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          KPNT   = IUHUNT (NKEYS, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                     NKEYS*KST, KST)
          IF (KPNT.NE.0) THEN
            NK     = (KPNT - MPSRDB) / KST + 1
          ELSE
            NK     = NKEYS
          ENDIF
          CALL DBKEYR (NK, NWKYDK, KEYO)
          KOBJ   = KEYO(MOBJDB)
          MXKP   = KEYO(MXKPDB)
          CALL DBPATH (PATHX, NKEYS)
          CALL RZCDIR (PATHX, ' ')
          IF (IQUEST(1).NE.0)        GO TO 991
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
*
*  **     Make a different subdirectory if there are too many keys
*
          IF (NKEYDK.GE.MXKP) THEN
            NWKEY  = NWKYDK
            CHFOR = ' '
            DO 40 I = 1, NWKEY
              IF (I.EQ.1) THEN
                CHFOR  = CFORM(IOTYDK(I))
              ELSE
                CHFOR  = CHFOR(1:I-1)//CFORM(IOTYDK(I))
              ENDIF
   40       CONTINUE
            KEY7DK = KEYVDK(MITMDB)
            CALL DBMDIP (PATHY, NWKEY, CHFOR, CTAGDK, MXKP)
            IF (IQUEST(1).NE.0)      GO TO 999
            CALL RZCDIR (PATHY, ' ')
            NKEYDK = IQUEST(7)
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
            KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                       NKEYDK*KST, KST)
            IF (KPNT.NE.0) THEN
              NK     = (KPNT - MPSRDB) / KST + 1
            ELSE
              NK     = NKEYDK
            ENDIF
            CALL DBKEYR (NK, NWKYDK, KEYO)
            KOBJ   = KEYO(MOBJDB)
            CALL DBPATH (PATHX, NKEYDK)
            CALL RZCDIR (PATHX, ' ')
            IF (IQUEST(1).NE.0)      GO TO 991
            NKEYDK = IQUEST(7)
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
          ENDIF
          CALL UCOPY (KEYO, KEYN, NWKYDK)
*
        ENDIF
*
*  **   Check the number of keys
*
        LOBJ   = KOBJ
        DO 45 IK = 1, NKEYDK
          IP     = KOFSDB + LCDRDB + IKDRDB + (IK-1)*KST + MSERDB
          IF (IQ(IP).GT.LOBJ) LOBJ = IQ(IP)
   45   CONTINUE
        KEYVDK(MSERDB) = LOBJ + 1
        KEYVDK(MFLGDB) = MSBIT1 (KEYVDK(MFLGDB), JRZUDB)
        CALL RZOUT (IUDIV, LREFDB(1), KEYVDK, ICYCLE, 'L')
        IER    = IQUEST(1)
        KEYN(MBVRDB) = MIN0 (KEYN(MBVRDB), KEYVDK(MBVRDB))
        KEYN(MEVRDB) = MAX0 (KEYN(MEVRDB), KEYVDK(MEVRDB))
        CALL RZRENK (KEYO, KEYN)
        IF (IER.NE.0) IQUEST(1) = IER
      ENDIF
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 73
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDONT : Error i'//
     +     'n RZ while writing Data for '//PATHY//PATHX(1:8)//''')',I,0)
+SELF, IF=-$P3CHILD.
      ENDIF
      GO TO 998
+SELF.
*
* *** Error messages
*
  991 IQUEST(1) = 71
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDONT : Illegal '//
     +   'Path Name '//PATHY//PATHX(1:8)//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
*
  998 IER   = IQUEST(1)
      IF (PATHL.NE.' ') THEN
        CALL RZCDIR (PATHL, ' ')
        CALL RZFREE ('DBDONT')
      ENDIF
      IQUEST(1) = IER
+SELF, IF=-IBM, -$P3CHILD.
*
 2001 FORMAT (20(I2,A1,1X))
+SELF.
*                                                             END DBDONT
  999 END
+DECK, DBEALI.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBEALI (PATH, ALIAS, IFLAG)
*     ======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBEALI (PATH, ALIAS, IFLAG)                             *
*                                                                      *
*   Enter the alias name of a given directory either only for this     *
*   session or permanently in the data base.                           *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATH     Character string specifying the directory path name     *
*     ALIAS    Character string specifying the alias name              *
*     IFLAG    Flag (0 if to be entered only for this session;         *
*                    1 if to be entered for this session and D.B.)     *
*                                                                      *
*   Called by user,   DBFZUP, DBAUXI                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =182 : Illegal path name                               *
*               =185 : Illegal top directory name                      *
*               =187 : FZOUT fails to write on the sequential file     *
*               =188 : Error in RZ for writing to the R.A. file        *
*               =201 : Dictionary directory not found                  *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, P3DBL3, IF=$P3CHILD.
      CHARACTER       PATH*(*), ALIAS*(*), CALI*8, PATHN*80, TOPN*16
      CHARACTER       PATHD*32, PATHL*80
*
*     ------------------------------------------------------------------
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATH, PATHN, NCHAR)
      CALI   = ALIAS
      PATHL  = ' '
*
* *** Check if the path name already exists in the help
*
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 182
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : Illegal'//
     +  ' pathname '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL RZCDIR (PATHN, 'R')
      NCHAR = LENOCC(PATHN)
*
* *** Find the unique directory identifier from the pathname
*
      CALL DBGPID (PATHN, NCHAR, TOPN, IDN)
      IF (IDN.LE.0) THEN
        IQUEST(1) = 182
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : Illegal'//
     +  ' pathname '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Modify in memory
*
      LTOP   = LTOPDB
   10 IF (LTOP.GT.0) THEN
        NCHT   = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHT)
        TOPNDI = TOPNDI(1:NCHT)
        IF (TOPN.EQ.TOPNDI) THEN
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10)
+SELF.
          LUFZDF = IQ(KOFUDB+LTOP+MUPJFL)
        ELSE
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 10
        ENDIF
      ELSE
        IQUEST(1) = 185
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : Illegal'//
     +  ' top directory name '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      LFIXDB = LQ(KOFUDB+LTOP-KLDICT)
      IF (LFIXDB.EQ.0) THEN
        IQUEST(1) = 201
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : DICTION'//
     +  'ARY not found for '//TOPN//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      IF (IOUT.EQ.0) IOPS = 0
*
      IPNT   = KOFUDB + LFIXDB + (IDN - 1) * NWITDB + 1
      CALL UCTOH (CALI, IQ(IPNT+MDCALI), 4, 8)
      IF (IFLAG.EQ.0)  THEN
        LFIXDB = 0
        GO TO 999
      ENDIF
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
      IF (IOPP.NE.0) THEN
        LFIXDB = 0
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
        CALL DBWLOK
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
        CALL DBSTSV (TOPN, 0)
+SELF, IF=$P3CHILD.
        LUFZDF = LODBP3
        IQUEST(1) = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        IF (IQUEST(1).NE.0) GO TO 999
      ENDIF
+SELF.
*
* *** Get the name of the correct DICTIONARY directory
*
      NCTOP  = LENOCC (TOPN)
      PATHD  = '//'//TOPN(1:NCTOP)//'/DICTIONARY'
      NCHRD  = NCTOP + 13
*
      IF (LUFZDF.GT.0) THEN
*
*  **   Prepare the header containing all the information
*
        NCHD   = (NCHRD + 3) / 4
        NCHP   = (NCHAR + 3) / 4
        CALL MZIOCH (IOFMDF, NWFMDF, '6I -H')
        IHEADF(MACTDF) = 7
        IHEADF(MNKYDF) = 0
        IHEADF(MOPTDF) = 0
        IHEADF(MPATDF) = NCHD
        IHEADF(MFLGDF) = IFLAG
        IHEADF(MWDPDF) = NCHP
        NPNT1  = NCHD  + MWDPDF + 1
        NPNT2  = NPNT1 + 2
        CALL UCTOH (PATHD, IHEADF(MWDPDF+1), 4, 4*NCHD)
        CALL UCTOH (CALI , IHEADF(NPNT1),    4, 8)
        CALL UCTOH (PATHN, IHEADF(NPNT2),    4, 4*NCHP)
        NWDH   = NPNT2 + NCHP - 1
*
*  **   Now write on the sequential output
*
+SELF, IF=$P3CHILD.
        RNDBP3 = 'DBEALI '
        NWDBP3 = 2
        CALL UCTOH ('JOURNAL ',IWDBP3, 4, 8)
        CALL DBCHLD
        IQUEST(1) = IQDBP3
        IF (IQUEST(1).NE.0) GO TO 999
+SELF.
        CALL FZOUT (LUFZDF, IDIVDB, 0, 1, 'Z', IOFMDF, NWDH, IHEADF)
        IF (IQUEST(1).NE.0) THEN
          LFIXDB = 0
          IQUEST(1) = 187
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : FZOUT'//
     +    ' error for path name '//PATHN//''')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
      ENDIF
*
      IQUEST(1) = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
* *** Server environment, Public mode
*
      IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
        IOPBDA = 0
        CALL DBCWSV
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        GO TO 999
      ENDIF
+SELF, IF=-$P3CHILD.
*
* *** Now save this information in the data base
*
      CALL RZCDIR (PATHD, ' ')
      IF (IQUEST(1).NE.0) THEN
        LFIXDB = 0
        IQUEST(1) = 201
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : DICTION'//
     +  'ARY not found for '//TOPN//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      ISTP   = NWKYDK + 1
*
* *** Lock the directory if necessary
*
      IF (IOPS.NE.0) THEN
        CALL RZCDIR (PATHD, ' ')
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        CALL RZLOCK ('DBEALI')
        PATHL  = PATHD
      ENDIF
*
      IF (NKEYDK.GT.0) THEN
        IPNT   = KOFSDB + LCDRDB + IKDRDB
        IMIN   = IUHUNT (-1, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)
        IF (IMIN.GT.0) THEN
          IMIN   = (IMIN - MSERDB) / ISTP + 1
          CALL DBKEYT
          CALL DBKEYR (IMIN, NWKYDK, KEYNDK)
          ISTEP  = 1
          CALL RZOUT (IDIVDB, LFIXDB, KEYNDK, ICYCLE, 'S')
          LFIXDB = 0
          IF (IQUEST(1).NE.0) THEN
            IQUEST(1) = 188
            IQUEST(11)= ISTEP
+SELF, IF=$DEBUG, IF=-$P3CHILD.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : RZ '//
     +      'error in step '',I3,'' for path name '//PATHD//''')',
     +      IQUEST(11), 1)
+SELF, IF=-$P3CHILD.
            GO TO 998
          ENDIF
          ISTEP  = 2
          CALL RZPURG (0)
          IF (IQUEST(1).NE.0) THEN
            IQUEST(1) = 188
            IQUEST(11)= ISTEP
+SELF, IF=$DEBUG, IF=-$P3CHILD.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : RZ '//
     +      'error in step '',I3,'' for path name '//PATHD//''')',
     +      IQUEST(11), 1)
+SELF, IF=-$P3CHILD.
            GO TO 998
          ENDIF
        ENDIF
      ELSE
        IMIN   = 0
      ENDIF
      LFIXDB = 0
      IF (IMIN.EQ.0) THEN
        IQUEST(1) = 201
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEALI : DICTION'//
     +  'ARY not found for '//TOPN//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
      ELSE
        IQUEST(1) = 0
      ENDIF
*
* *** Free the locked directory
*
  998 IF (PATHL.NE.' ') THEN
        IERR   = IQUEST(1)
        CALL RZCDIR (PATHL, ' ')
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        CALL RZFREE ('DBEALI')
        IQUEST(1) = IERR
      ENDIF
+SELF.
*                                                             END DBEALI
  999 END
+DECK, DBEFOR.
      SUBROUTINE DBEFOR (TOPN, IDATE, ITIME)
*     ======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBEFOR (TOPN, IDATE, ITIME)                             *
*                                                                      *
*   Set the maximum insertion time for retrieval of all subsequent     *
*   data objects for a given top directory                             *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     TOPN     Name of the top directory ('*' means all)               *
*     IDATE    Date : 6 Decimal integer : YYMMDD                       *
*     ITIME    Time : 4 Decimal integer : HHMM                         *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DINITL.
      CHARACTER       TOPN*(*), TOP*16
*
*     ------------------------------------------------------------------
*
      CALL DBPKTM (IDATE, ITIME, KY7M)
      CALL DBSBLC (TOPN, TOPNDI, NCHR)
*
* *** Insert the KY7M value for the appropriate
*
      LFIXDB = LTOPDB
   10 IF (LFIXDB.GT.0) THEN
        NCH    = IQ(KOFUDB+LFIXDB+MUPNCH)
        IF (NCH.EQ.NCHR) THEN
          CALL UHTOC (IQ(KOFUDB+LFIXDB+MUPNAM), 4, TOP, NCH)
          IF (TOPNDI.EQ.'*'.OR.TOP(1:NCH).EQ.TOPNDI) THEN
            IQ(KOFUDB+LFIXDB+MUPKY7) = KY7M
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) THEN
              IARGDB(1) = IDATE
              IARGDB(2) = ITIME
              CALL DBPRNT (LPRTDB, '(/,'' DBEFOR : All subsequent ret'//
     +             'rievals of data objects for '//TOP(1:NCH)//' will'//
     +             ' test on insertion time before '',2I7)', IARGDB, 2)
            ENDIF
+SELF.
          ENDIF
          LFIXDB = LQ(KOFUDB+LFIXDB)
          GO TO 10
        ENDIF
      ENDIF
*                                                             END DBEFOR
      END
+DECK, DBEHLP.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBEHLP (PATH, LUN)
*     =============================
*
************************************************************************
*                                                                      *
*        SUBR. DBEHLP (PATH, LUN)                                      *
*                                                                      *
*   Encode the help information from an ASCII disk file specified by   *
*   the logical unit number LUN with subroutine DBLINC and enter it    *
*   into the data base.                                                *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATH     Path name of the help subdirectory                      *
*     LUN      Logical unit number of the file where ASCII help        *
*              information reside                                      *
*                                                                      *
*   Called by user,   DBAUXI                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 66 : Illegal logical unit number                     *
*               = 67 : File too long; no space in buffer               *
*               =182 : Illegal path name                               *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, P3DBL3, IF=$P3CHILD.
      CHARACTER       PATH*(*), KLINE*80, PATHN*80, TOPN*16
*
*     ------------------------------------------------------------------
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATH, PATHN, NCHAR)
*
      IF (LUN.LE.0) THEN
        IQUEST(1) = 66
        IQUEST(11)= LUN
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEHLP : Illegal'//
     +  ' unit number '',I10,'' for ASCII file'')', IQUEST(11), 1)
+SELF.
        GO TO 999
      ENDIF
*
* *** Check if the path name already exists in the help
*
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 182
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEHLP : Illegal'//
     +  ' pathname '//PATHN(1:NCHAR)//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL RZCDIR (PATHN, 'R')
      NCHAR = LENOCC(PATHN)
*
* *** Find the unique directory identifier from the pathname
*
      CALL DBGPID (PATHN, NCHAR, TOPN, IDN)
      IF (IDN.LE.0) THEN
        IQUEST(1) = 182
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEHLP : Illegal'//
     +  ' pathname '//PATHN(1:NCHAR)//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Read the data part
*
      IF (LSTRDL(1).NE.0) CALL MZDROP (IDIVDB, LSTRDL(1), 'L')
      NDATA  = NDMXDB
      JBIAS  = 2
+SELF, IF=-$P3CHILD.
      CALL DBBOOK (IDIVDB, LSTRDL(1), LSTRDL(1), JBIAS, 'USER', 0, 0,
     +             NDATA, 1, -1)
      IF (IQUEST(1).NE.0)     GO TO 999
*
* *** Now read the file
*
      NDAT   = 0
      NREC   = 0
   25 READ (LUN, 1000, ERR=30, END=30) KLINE
      NREC   = NREC + 1
      LENG   = LENOCC (KLINE)
      CALL DBLINC (KLINE, LENG, IQ(KOFUDB+LSTRDL(1)+1), NDAT)
      IF (NDAT.GT.NDATA-20) THEN
        IQUEST(1) = 67
        IQUEST(11)= NREC
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBEHLP : Buffer '//
     +  'full after '',I8,'' records'')', IQUEST(11), 1)
+SELF, IF=-$P3CHILD.
        GO TO 990
      ENDIF
      GO TO 25
*
   30 NDP    = NDAT - NDATA
      IF (NDP.LT.0) CALL MZPUSH (IDIVDB, LSTRDL(1), 0, NDP, 'I')
+SELF, IF=$P3CHILD.
      RNDBP3 = 'DBEHLP'
      NWDBP3 = 1
      IWDBP3(1) = LUN
      CALL DBCHLD
      IQUEST(1) = IQDBP3
      IF (IQUEST(1).NE.0)     GO TO 999
      NDAT  = IWDBP3(2)
      CALL APFZIN (LIDBP3, IDIVDB, LSTRDL(1), JBIAS, 'E', 0, IWDBP3)
+SELF.
*
* *** Now save the bank into the database and drop the bank
*
      CALL DBSNAM (1, IDN, LSTRDL(1), TOPN, 0)
*
  990 IF (LSTRDL(1).NE.0) THEN
        IERR   = IQUEST(1)
        CALL MZDROP (IDIVDB, LSTRDL(1), 'L')
        LSTRDL(1) = 0
        IQUEST(1) = IERR
      ENDIF
+SELF, IF=-$P3CHILD.
*
 1000 FORMAT (A80)
+SELF.
*                                                             END DBEHLP
  999 END
+DECK, DBENAM.
      SUBROUTINE DBENAM (PATH, NW, CHTAG)
*     ===================================
*
************************************************************************
*                                                                      *
*        SUBR. DBENAM (PATH, NW, CHTAG)                                *
*                                                                      *
*   Enters the name of the data elements of a given directory inside   *
*   the data base. The stored information goes in the DICTIONARY       *
*   directory with KEY(1) set to the unique identifier of this         *
*   directory.                                                         *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATH     Character string describing the path name               *
*     NW       Number of data elements                                 *
*     CHTAG    Name of each data element (assumed to be 8 character)   *
*                                                                      *
*   Called by user,   DBAUXI                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =182 : Illegal path name                               *
*               =183 : Illegal number of data words                    *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
      CHARACTER*(*)   CHTAG(*)
      CHARACTER       CTAG*8, TOPN*16, PATH*(*), PATHN*80
*
*     ------------------------------------------------------------------
*
      IF (NW.LE.0) THEN
        IQUEST(1) = 183
        IQUEST(11)= NW
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENAM : Illegal'//
     +  ' number of data words '',I12)', IQUEST(11), 1)
+SELF.
        GO TO 999
      ENDIF
*
* *** See if the path name is correct
*
      CALL DBSBLC (PATH, PATHN, NCHAR)
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 182
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENAM : Illegal'//
     +  ' path name '//PATHN(1:NCHAR)//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL RZCDIR (PATHN, 'R')
      NCHAR = LENOCC (PATHN)
      CALL DBGPID (PATHN, NCHAR, TOPN, IDN)
      IF (IDN.LE.0) THEN
        IQUEST(1) = 182
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENAM : Illegal'//
     +  ' path name '//PATHN(1:NCHAR)//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Book the bank and fill it up with appropriate information
*
      NUM   = 2 * NW
      IF (LSTRDL(1).NE.0) THEN
        CALL MZDROP (IDISDB, LSTRDL(1), 'L')
        LSTRDL(1) = 0
      ENDIF
      CALL DBBOOK (IDISDB, LSTRDL(1), LSTRDL(1), 2, 'DNAM', 0, 0, NUM,
     +             5, -1)
      IF (IQUEST(1).NE.0)  GO TO 999
      IPNT = KOFUDB + LSTRDL(1)
      DO 10 I = 1, NW
        CTAG   = CHTAG(I)
        CALL UCTOH (CTAG, IQ(IPNT+1), 4, 8)
        IPNT = IPNT + 2
   10 CONTINUE
*
* *** Now store the information inside data base
*
      CALL DBSNAM (2, IDN, LSTRDL(1), TOPN, 0)
      IERR = IQUEST(1)
      CALL MZDROP (IDISDB, LSTRDL(1), 'L')
      LSTRDL(1) = 0
      IQUEST(1) = IERR
*                                                             END DBENAM
  999 END
+DECK, DBEND.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBEND
*     ================
*
************************************************************************
*                                                                      *
*        SUBR. DBEND                                                   *
*                                                                      *
*   Terminates the Data Base utility package                           *
*                                                                      *
*   Called by user,   DBMAIN, DBTERM, DBACTI                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DINITL.
      CHARACTER       TOP*16, TOPN*16, PATH*20
*
*     ------------------------------------------------------------------
*
+SELF, IF=-$SERVER, $P3CHILD, CRAY.
      IER    = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
      CALL DBSTSV (' ', -1)
      IER    = IQUEST(1)
      INSRDB = 0
+SELF.
*
* *** Call RZEND for all the files opened
*
      LFIXDB = LTOPDB
   10 IF (LFIXDB.EQ.0)  GO TO 20
      NCH    = IQ(KOFUDB+LFIXDB+MUPNCH)
      CALL UHTOC (IQ(KOFUDB+LFIXDB+MUPNAM), 4, TOP, NCH)
      TOPN   = TOP(1:NCH)
      PATH   = '//'//TOPN
      CALL RZCDIR (PATH, ' ')
      CALL RZEND (TOPN)
      LFIXDB = LQ(KOFUDB+LFIXDB)
      GO TO 10
*
   20 IF (LTOPDB.GT.0) THEN
        CALL MZDROP (IDIVDB, LTOPDB, 'L')
        LTOPDB = 0
      ENDIF
      IQUEST(1) = IER
*                                                              END DBEND
  999 END
+DECK, DBENDF.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBENDF (TOPN)
*     ========================
*
************************************************************************
*                                                                      *
*        SUBR. DBENDF (TOPN)                                           *
*                                                                      *
*   Closes one data base file given by the top directory name          *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     TOPN     Name of the top directory                               *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DINITL.
      CHARACTER       TOP*16, TOPN*(*), PATH*20
*
*     ------------------------------------------------------------------
*
      CALL DBSBLC (TOPN, TOPNDI, NCHR)
+SELF, IF=-$SERVER, $P3CHILD, CRAY.
      IER    = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
      CALL DBSTSV (' ', 0)
      IER    = IQUEST(1)
+SELF.
*
* *** Make appropriate RZEND call
*
      LFIXDB = LTOPDB
   10 IF (LFIXDB.EQ.0)  GO TO 20
      NCH    = IQ(KOFUDB+LFIXDB+MUPNCH)
      IF (NCH.EQ.NCHR) THEN
        CALL UHTOC (IQ(KOFUDB+LFIXDB+MUPNAM), 4, TOP, NCH)
        IF (TOP(1:NCH).EQ.TOPNDI(1:NCH)) THEN
           PATH   = '//'//TOPNDI
           CALL RZCDIR (PATH, ' ')
          CALL RZEND (TOPNDI)
          IF (LTOPDB.EQ.LFIXDB) LTOPDB = LQ(KOFUDB+LFIXDB)
          CALL MZDROP (IDIVDB, LFIXDB, ' ')
          GO TO 20
        ENDIF
      ENDIF
      LFIXDB = LQ(KOFUDB+LFIXDB)
      GO TO 10
*
   20 IQUEST(1) = IER
*                                                             END DBENDF
      END
+DECK, DBENTB.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBENTB (PATHN, IUDIV, LSUP, KEY, NWDIM, NTKEY, IPREC,
     +                   CHOPT)
*     ================================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBENTB (PATHN, IUDIV, LSUP, *KEY*, NWDIM, NTKEY, IPREC, *
*                      CHOPT)                                          *
*                                                                      *
*   Stores data from memory to disk for a number of objects in a go.   *
*   It is useful in a Batch operation to save real time spent          *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     IUDIV    Division index where the data reside                    *
*     LSUP     Vector containing the addresses of the banks where      *
*              data reside                                             *
*     KEY      Two dimensional array with the first dimension NWDIM,   *
*              specifying the key elements for each object and the     *
*              secod dimension NTKEY, specifying the number of objects *
*              (Keys 3,4,5 and 8 onwards to be filled in by user on    *
*              input; the DB system keys will be filled in here at the *
*              time of output)                                         *
*     NWDIM    First dimension of the array KEY                        *
*     NTKEY    Number of objects to be inserted                        *
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *
*              IPREC significant digits right to the decimal points; if*
*              IPREC < 0, data are stored with IPREC insignificant     *
*              digits left to the decimal point.)                      *
*     CHOPT    Character string with any of the following characters   *
*          B   Save in the special backup file; not in standard Journal*
*          F   Updates with a fully matched data object (in user keys) *
*          R   Store with full RZ option (No compression to be made)   *
*          S   Create stand alone (master) data                        *
*          T   Special text type of data (to be used with R)           *
*          U   Store data uncompressed                                 *
*          Z   Store only nonzero elements. An element is considered to*
*              be zero if its absolute is less than IPREC              *
*          7   Insertion time as supplied by user to be honoured       *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 61 : Too many keys                                   *
*               = 65 : Illegal number of objects                       *
*               = 71 : Illegal path name                               *
*               = 72 : Number of keys does not match with that         *
*                      specified in the directory                      *
*               = 73 : RZOUT fails to write on disk                    *
*               = 74 : Error in RZRENK in updating key values for      *
*                      partitioned data set                            *
*               = 75 : Cannot find the Top directory name in pathname  *
*               = 76 : Cannot form the IO descriptor for the FZ header *
*               = 77 : FZOUT fails to write on to the sequential file  *
*               = 78 : Illegal number of keys in data base             *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DZPACK.
+CDE, P3DBL3, IF=$P3CHILD.
      PARAMETER       (NLEVM=20)
      INTEGER         NLCUR(NLEVM)
      DIMENSION       KEY(NWDIM,2), LSUP(9), KEYO(MXDMDK), KEYN(MXDMDK)
      CHARACTER       PATHY*80, PATHX*16, CHFOR*100, CFORM(6)*1
      CHARACTER       CHCUR(NLEVM)*1, TOPN*16, CHOP*1
      CHARACTER       PATHN*(*), CHOPT*(*), CHOP0*80, PATHL*80
      DATA            CFORM /'B', 'I', 'F', 'D', 'H', 'A'/
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Decode the character option
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)          GO TO 999
      PACKDZ = .FALSE.
      PATHL  = ' '
*
      IF (IOPUDA.NE.0.AND.IOPZDA.NE.0)  THEN
        IOPZDA = 0
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Warning'//
     +  ' - Z option is incompatible with U option - U option will be'//
     +  ' executed'')', IARGDB, 0)
+SELF.
*
      ELSE IF (IOPZDA.NE.0) THEN
        PACKDZ = .TRUE.
        CALL UCOPY (IPREC, PRECDZ, 1)
      ENDIF
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATHY, NCHAR)
*
* *** Set the current directory path name
*
      PATHX  = ' '
      CALL RZCDIR (PATHY, ' ')
      IF (IQUEST(1).NE.0)          GO TO 991
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      KST    = NWKYDK + 1
      CALL RZCDIR (PATHY, 'R')
      CALL DBKYTG
      IF (NKEYDK.NE.0)  THEN
        IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)
        IOPTP  = JBIT (IOPTP, JPRTDB)
      ELSE
        IOPTP  = 0
      ENDIF
*
* *** Check the number of keys
*
      IF (NWDIM.LT.NWKYDK)  THEN
        IQUEST(1) = 61
        IQUEST(11)= NWKYDK
        IQUEST(12)= NWDIM
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Too man'//
     +  'y keys '',I6,'' maximum permitted '',I6)', IQUEST(11), 2)
+SELF.
        GO TO 999
      ENDIF
      IF (NTKEY.LE.0) THEN
        IQUEST(1) = 65
        IQUEST(11)= NTKEY
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Too few'//
     +  ' objects '',I12)', IQUEST(11), 1)
+SELF.
        GO TO 999
      ENDIF
      IF (NWKYDK.LT.NSYSDK.OR.NWKYDK.GT.MXDMDK) THEN
        IQUEST(1) = 78
        IQUEST(11)= NWKYDK
        IQUEST(12)= NSYSDK
        IQUEST(13)= MXDMDK
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Illegal'//
     +  ' number of keys '',I10,'' permitted range '',2I6)', IQUEST(11),
     +  3)
+SELF.
        GO TO 999
      ENDIF
*
* *** Extract the Top level directory name
*
      I1     = 0
      I11    = 0
      DO 10 I0 = 1, MAXLDB
        IF (PATHY(I0:I0).EQ.'/'.OR.PATHY(I0:I0).EQ.' ') THEN
          IF (I1.GT.0) THEN
            TOPN   = PATHY(I11:I0-1)
            GO TO 15
          ENDIF
          IF (PATHY(I0:I0).EQ.' ') GO TO 15
        ELSE
          IF (I1.EQ.0) I11 = I0
          I1     = I1 +1
        ENDIF
   10 CONTINUE
   15 IF (I1.EQ.0) THEN
        IQUEST(1) = 75
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : No top '//
     +  'directory for '//PATHY//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Find the appropriate FZ file number
*
      LTOP   = LTOPDB
+SELF, IF=-$SERVER, CRAY.
      IOPP   = 0
+SELF.
      IOUT   = 0
   20 IF (LTOP.NE.0) THEN
        NCH    = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCH)
        TOPNDI = TOPNDI(1:NCH)
        IF (TOPN.EQ.TOPNDI) THEN
          IF (IOPBDA.EQ.0) THEN
            LUFZDF = IQ(KOFUDB+LTOP+MUPJFL)
          ELSE
            LUFZDF = IQ(KOFUDB+LTOP+MUPBAK)
          ENDIF
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10)
+SELF.
        ELSE
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 20
        ENDIF
      ELSE
        LUFZDF = 0
        IOPS   = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        IOPP   = 0
+SELF.
      ENDIF
      IF (IOUT.EQ.0) IOPS = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
      IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
        LUFZDF = LUFMDB
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
        CALL DBSTSV (TOPN, 0)
        IF (IQUEST(1).NE.0)        GO TO 999
+SELF, IF=$P3CHILD.
        LUFZDF = LODBP3
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
      ENDIF
+SELF.
*
* *** Get the IO descriptor for the header
*
      IF (LUFZDF.GT.0) THEN
        NDOPC  = LENOCC (CHOPT)
        IF (INDEX (CHOPT, '7') .EQ. 0) THEN
          CHOP0  = '7'//CHOPT
          NDOPC  = NDOPC + 1
        ELSE
          CHOP0  = CHOPT
        ENDIF
        NDOP   = (NDOPC + 3) / 4
        NLEV   = 1
        NCUR   = 5
        IFORO  = 2
        CHCUR(NLEV) = CFORM(IFORO)
        IF (PACKDZ.AND.IOPUDA.EQ.0) THEN
          NLCUR(NLEV) = 4
          IFORO  = 3
          NCUR   = 1
          NLEV   = NLEV + 1
          CHCUR(NLEV) = CFORM(IFORO)
          CALL UCOPY (PRECDZ, IHEADF(MPREDF), 1)
        ELSE
          IHEADF(MPREDF) = IPREC
        ENDIF
        DO 25 I = 1, NWKYDK
          IFORM  = IOTYDK(I)
          IF (IFORM.EQ.6) IFORM = 5
          IF (IFORM.EQ.IFORO) THEN
            NCUR   = NCUR + 1
          ELSE
            NLCUR(NLEV) = NCUR
            IF (NLEV.GE.NLEVM) THEN
              IQUEST(1) = 76
+SELF, IF=$DEBUG.
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : '//
     +        'Cannot get IO descriptor '//PATHY//''')', IARGDB, 0)
+SELF.
              GO TO 999
            ENDIF
            NLEV   = NLEV + 1
            CHCUR(NLEV) = CFORM(IFORM)
            NCUR   = 1
            IFORO  = IFORM
          ENDIF
   25   CONTINUE
        NLCUR(NLEV) = NCUR
*
+SELF, IF=-IBM, -$P3CHILD.
        WRITE (CHFOR, 2001) (NLCUR(I), CHCUR(I), I = 1, NLEV)
+SELF, IF=IBM, IF=$P3CHILD.
        CHFOR  = ' '
        II     = 1
        DO 26 I = 1, NLEV
          CALL UTWRIT (CHFOR(II:II+1), '(I2)', NLCUR(I))
          II     = II + 2
          CHFOR(II:II) = CHCUR(I)
          II     = II + 2
   26   CONTINUE
+SELF.
        II     = 4 *NLEV
        CHFOR = CHFOR(1:II)//' -H'
        CALL MZIOCH (IOFMDF, NWFMDF, CHFOR(1:II+3))
*
*  **   Partially fill up the header
*
        NCHR   = INDEX (PATHY, ' ') - 1
        IF (NCHR.LT.1.OR.NCHR.GT.MAXLDB) NCHR = MAXLDB
        NWDP   = (NCHR + 3) / 4
        NWDH   = NWDP + NDOP + NWKYDK + 5
        IHEADF(MACTDF) = 1
        IHEADF(MNKYDF) = NWKYDK
        IHEADF(MOPTDF) = NDOP
        IHEADF(MPREDF) = NWDP
        IF (NDOP.GT.0)
     +    CALL UCTOH (CHOP0, IHEADF(NWKYDK+MPREDF+1), 4, 4*NDOP)
        CALL UCTOH (PATHY, IHEADF(NWKYDK+NDOP+MPREDF+1), 4, 4*NWDP)
      ENDIF
*
* *** Take necessary action for partitioned and nonpartiitined datasets
*
      IF (IOPTP.EQ.0) THEN
        KOBJ   = 0
      ELSE
        KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                   NKEYDK*KST, KST)
        IF (KPNT.NE.0) THEN
          NK     = (KPNT - MPSRDB) / KST + 1
        ELSE
          NK     = NKEYDK
        ENDIF
        CALL DBKEYR (NK, NWKYDK, KEYO)
        KOBJ   = KEYO(MOBJDB)
        MXKP   = KEYO(MXKPDB)
        NWKYS  = NWKYDK
        CHFOR = ' '
        DO 30 I = 1, NWKYS
          IF (I.EQ.1) THEN
            CHFOR  = CFORM(IOTYDK(I))
          ELSE
            CHFOR  = CHFOR(1:I-1)//CFORM(IOTYDK(I))
          ENDIF
   30   CONTINUE
*
        CALL DBPATH (PATHX, NKEYDK)
        CALL RZCDIR (PATHX, ' ')
        IF (IQUEST(1).NE.0)        GO TO 991
        NKEYDK = IQUEST(7)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
*
*  **   Make a different subdirectory if there are too many keys
*
        IF (NKEYDK.GE.MXKP) THEN
          IF (IOKYDA(MITMDB).EQ.0.OR.KEY(MITMDB,1).LE.0) THEN
            KEY7DK = 0
          ELSE
            KEY7DK = KEY(MITMDB,1)
          ENDIF
          CALL DBMDIP (PATHY, NWKYS, CHFOR, CTAGDK, MXKP)
          IF (IQUEST(1).NE.0)      GO TO 999
          CALL RZCDIR (PATHY, ' ')
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                     NKEYDK*KST, KST)
          IF (KPNT.NE.0) THEN
            NK     = (KPNT - MPSRDB) / KST + 1
          ELSE
            NK     = NKEYDK
          ENDIF
          CALL DBKEYR (NK, NWKYDK, KEYO)
          KOBJ   = KEYO(MOBJDB)
          CALL DBPATH (PATHX, NKEYDK)
          CALL RZCDIR (PATHX, ' ')
          IF (IQUEST(1).NE.0)      GO TO 991
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
        ENDIF
        CALL UCOPY (KEYO, KEYN, NWKYDK)
*
      ENDIF
*
* *** Get the Serial number of the last object inserted
*
      LOBJ   = KOBJ
      IF (NKEYDK.GT.0) THEN
        ISTP   = NWKYDK + 1
        DO 35 IK = 1, NKEYDK
          IP     = KOFSDB + LCDRDB + IKDRDB + (IK-1)*ISTP + MSERDB
          IF (IQ(IP).GT.LOBJ) LOBJ = IQ(IP)
   35   CONTINUE
      ENDIF
      NINS   = NKEYDK
*
* *** Lock the directory if necessary
*
      IF (IOPP.EQ.0.AND.IOPS.NE.0) THEN
        CALL RZCDIR (PATHY, ' ')
        NKEYDK = IQUEST(7)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        CALL RZLOCK ('DBENTB')
        PATHL  = PATHY
        IF (IOPTP.NE.0) THEN
          CALL RZCDIR (PATHX, ' ')
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
        ENDIF
      ENDIF
*
* *** Loop over all the objects
*
      DO 40 IOBJ = 1, NTKEY
        LOBJ   = LOBJ + 1
        NINS   = NINS + 1
*
        IDB    = IDBTYP (LSUP(IOBJ))
        IF (IDB.EQ.2.OR.IDB.EQ.3) THEN
          IOPTR  = 0
        ELSE
          IOPTR  = 1
        ENDIF
*
        IF (IOPRDA.NE.0 .OR. IOPTR.NE.0 .OR. IOPTDA.NE.0)  THEN
          IF (IOPTDA.NE.0) THEN
            CHOP   = 'S'
          ELSE IF (IOPRDA.NE.0) THEN
            CHOP   = 'L'
          ELSE
            CHOP   = ' '
          ENDIF
        ELSE
          CHOP   = 'S'
        ENDIF
*
*  **   Fill up Key vectors 1,2,6,7
*
        KEY(MSERDB,IOBJ) = LOBJ
        KEY(MUPNDB,IOBJ) = 0
        KEY(MFLGDB,IOBJ) = MSBIT0 (KEY(MFLGDB,IOBJ), JRZUDB)
        KEY(MFLGDB,IOBJ) = MSBIT0 (KEY(MFLGDB,IOBJ), JPRTDB)
        KEY(MFLGDB,IOBJ) = MSBIT0 (KEY(MFLGDB,IOBJ), JASFDB)
        IF (IOKYDA(MITMDB).EQ.0.OR.KEY(MITMDB,IOBJ).LE.0) THEN
          CALL DATIME (IDATE, ITIME)
          CALL DBPKTM (IDATE, ITIME, IDATM)
          KEY(MITMDB,IOBJ) = IDATM
        ENDIF
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
*
        IF (IOPP.NE.0) THEN
          CALL DBWLOK
          IF (IQUEST(1).NE.0)      GO TO 999
        ENDIF
+SELF.
*
*  **   Write the sequential output if needed
*
        IF (LUFZDF.GT.0) THEN
          CALL UCOPY (KEY(1,IOBJ), IHEADF(MPREDF+1), NWKYDK)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          IF (IOPP.NE.0) IHEADF(MPREDF+MSERDB) = 0
+SELF, IF=$P3CHILD.
          RNDBP3 = 'DBENTB '
          NWDBP3 = 2
          CALL UCTOH ('JOURNAL ', IWDBP3, 4, 8)
          CALL DBCHLD
          IQUEST(1) = IQDBP3
          IF (IQUEST(1).NE.0)      GO TO 997
+SELF.
          CALL FZOUT (LUFZDF, IUDIV, LSUP(IOBJ), 1, CHOP, IOFMDF,
     +                NWDH, IHEADF)
          IF (IQUEST(1).NE.0) THEN
            IQUEST(1)  = 77
            IQUEST(11) = IOBJ
            IQUEST(12) = NTKEY
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Err'//
     +      'or in FZOUT while writing Data for '',2I12)', IQUEST(11),2)
+SELF.
            GO TO 997
          ENDIF
        ENDIF
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
        IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
          CALL DBCWSV
          IF (IQUEST(1).NE.0)      GO TO 999
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          GO TO 40
        ENDIF
+SELF, IF=-$P3CHILD.
*
        IF (IOPRDA.NE.0 .OR. IOPTR.NE.0 .OR. IOPTDA.NE.0)  THEN
*
*  **     RZ mode output
*
          KEY(MFLGDB,IOBJ) = MSBIT1 (KEY(MFLGDB,IOBJ), JRZUDB)
          IF (IOPTDA.NE.0)
     +      KEY(MFLGDB,IOBJ) = MSBIT1 (KEY(MFLGDB,IOBJ), JASFDB)
*
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')
+SELF, IF=-$P3CHILD.
          CALL RZOUT (IUDIV, LSUP(IOBJ), KEY(1,IOBJ), ICYCLE, CHOP)
*
        ELSE
*
*  **     Copy data to DB internal store
*
*  **     0 Data word : do not pack
*
          IF (IQ(KOFUDB+LSUP(IOBJ)-1).EQ.0) IOPUDA = 1
          CALL DBFRUS (LSUP(IOBJ), LSTRDL(1), IPREC)
          IF (IQUEST(1).NE.0)      GO TO 997
*
*  **     Compress the data if requested
*
          IF (IOPUDA.NE.0)  THEN
            LREFDL(1) = LSTRDL(1)
          ELSE
            NOLD   = NKEYDK
            NKEYDK = NINS - 1
            CALL DBCOMP (LSTRDL(1), LREFDL(1), KEY(1,IOBJ))
            NKEYDK = NOLD
          ENDIF
          IF (IQUEST(1).NE.0)      GO TO 997
*
*  **     Drop the uncompressed data
*
          IF (LREFDL(1).NE.LSTRDL(1)) CALL MZDROP (IDISDB,LSTRDL(1),'L')
*
*  **     Write on to disk
*
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')
+SELF, IF=-$P3CHILD.
          CALL RZOUT (IDISDB, LREFDL(1), KEY(1,IOBJ), ICYCLE, 'S')
          IER    = IQUEST(1)
          CALL MZDROP (IDISDB, LREFDL(1), 'L')
          IQUEST(1) = IER
          IF (IER.EQ.77)           GO TO 997
*
        ENDIF
*
        IF (IOPTP.NE.0) THEN
          KEYN(MBVRDB) = MIN0 (KEYN(MBVRDB), KEY(MBVRDB,IOBJ))
          KEYN(MEVRDB) = MAX0 (KEYN(MEVRDB), KEY(MEVRDB,IOBJ))
        ENDIF
        IF (IQUEST(1).NE.0)        GO TO 993
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.1) THEN
          CALL UCOPY (KEY(1,IOBJ), KEYNDK, NWKYDK)
          IARGDB(1) = IDATE
          IARGDB(2) = ITIME
          CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Data was inserted into'//
     +         '   '//PATHY//''',/,10X,''on the '',I8,'' at '',I6,'' '//
     +         'with Key-Vector '')', IARGDB, 2)
          CALL DBKEYT
          CALL DBPRKY (NWKYDK, KEYNDK, IOTYDK)
        ENDIF
+SELF, IF=-$P3CHILD.
        IF (IOPTP.NE.0) THEN
          IF (NINS.GE.MXKP.AND.IOBJ.LT.NTKEY) THEN
            CALL RZCDIR (PATHY, ' ')
            IF (IQUEST(1).NE.0)    GO TO 991
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
            NKEYDK = IQUEST(7)
*
*  **       Rename Keys 3 and 4 of the latest subdirectory
*
            CALL RZRENK (KEYO, KEYN)
            IF (IQUEST(1).NE.0) THEN
              IQUEST(1) = 74
+SELF, IF=$DEBUG, IF=-$P3CHILD.
              IF (IDEBDB.GT.0) THEN
                CALL UCOPY  (KEYO, IARGDB(1),        NSYSDK)
                CALL UCOPY  (KEYN, IARGDB(NSYSDK+1), NSYSDK)
                CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Error in RZREN'//
     +               'K while writing data for '//PATHY//''',/(10X,'//
     +               '7I12))', IARGDB, 2*NSYSDK)
              ENDIF
+SELF, IF=-$P3CHILD.
              GO TO 998
            ENDIF
*
*  **       Make a different subdirectory if there are too many keys
*
            IF (IOKYDA(MITMDB).EQ.0.OR.KEY(MITMDB,IOBJ+1).LE.0) THEN
              KEY7DK = 0
            ELSE
              KEY7DK = KEY(MITMDB,IOBJ+1)
            ENDIF
            CALL DBMDIP (PATHY, NWKYS, CHFOR, CTAGDK, MXKP)
            IF (IQUEST(1).NE.0)    GO TO 998
            CALL RZCDIR (PATHY, ' ')
            NKEYDK = IQUEST(7)
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
            KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                       NKEYDK*KST, KST)
            IF (KPNT.NE.0) THEN
              NK     = (KPNT - MPSRDB) / KST + 1
            ELSE
              NK     = NKEYDK
            ENDIF
            CALL DBKEYR (NK, NWKYDK, KEYO)
            CALL DBPATH (PATHX, NKEYDK)
            CALL RZCDIR (PATHX, ' ')
            IF (IQUEST(1).NE.0)    GO TO 991
            NKEYDK = IQUEST(7)
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
            NINS   = 0
            CALL UCOPY (KEYO, KEYN, NWKYDK)
          ENDIF
        ENDIF
+SELF.
   40 CONTINUE
      GO TO 997
*
* *** Error messages
*
  991 IQUEST(1) = 71
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Illegal '//
     +   'Path Name '//PATHY//PATHX(1:8)//''')', IARGDB, 0)
+SELF.
      GO TO 998
+SELF, IF=-$P3CHILD.
*
  993 IQUEST(1) = 73
+SELF, IF=$DEBUG, IF=-$P3CHILD.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Error in '//
     +   'RZOUT while writing Data for '//PATHY//PATHX(1:8)//''')',
     +   IARGDB, 0)
+SELF.
*
  997 IER   = IQUEST(1)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
      IF (IOPP.NE.0) THEN
        IQUEST(1) = IER
        GO TO 999
      ENDIF
+SELF, IF=-$P3CHILD.
      IF (IOPTP.NE.0)  THEN
        IF (NINS.GT.0)  THEN
          CALL RZCDIR (PATHY, ' ')
          IF (IQUEST(1).NE.0) THEN
            IF (IER.EQ.0) THEN
              GO TO 991
            ELSE
              IQUEST(1) = IER
            ENDIF
          ELSE
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
            NKEYDK = IQUEST(7)
            IQUEST(1) = IER
*
*  **       Rename Keys 3 and 4 of the latest subdirectory
*
            IF (IER.EQ.0) THEN
              CALL RZRENK (KEYO, KEYN)
              IF (IQUEST(1).NE.0) THEN
                IQUEST(1) = 74
+SELF, IF=$DEBUG, IF=-$P3CHILD.
                IF (IDEBDB.GT.0) THEN
                  CALL UCOPY  (KEYO, IARGDB(1),        NSYSDK)
                  CALL UCOPY  (KEYN, IARGDB(NSYSDK+1), NSYSDK)
                  CALL DBPRNT (LPRTDB, '(/,'' DBENTB : Error in RZREN'//
     +                 'K while writing data for '//PATHY//''',/(10X,'//
     +                 '7I12))', IARGDB, 2*NSYSDK)
                ENDIF
+SELF, IF=-$P3CHILD.
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
*
*  ** Free the locked directory if any
*
+SELF.
  998 CONTINUE
+SELF, IF=-$P3CHILD.
      IF (PATHL.NE.' ') THEN
        CALL RZCDIR (PATHL, ' ')
        NKEYDK = IQUEST(7)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        CALL RZFREE ('DBENTB')
      ENDIF
+SELF, IF=-IBM, -$P3CHILD.
*
 2001 FORMAT (20(I2,A1,1X))
+SELF.
*                                                             END DBENTB
  999 END
+DECK, DBENTR.
      SUBROUTINE DBENTR (PATHN, LBK, LBD, IUDIV, LSUP, NWKEY, KEY, IPREC
     +                 , CHOPT)
*     ==================================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBENTR (PATHN, *LBK*, LBD*, IUDIV, LSUP, NWKEY, KEY,    *
*                      IPREC, CHOPT)                                   *
*                                                                      *
*   Stores data from memory to disk and also enters in the memory ala  *
*   DBUSE in NODE/KEY structure                                        *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     LBK(*)   Address of Keys bank KYDB   (INPUT or OUTPUT)           *
*     LBD(*)   Address of Data bank                                    *
*     IUDIV    Division index of the user data bank                    *
*     LSUP     Address of bank in memory where data reside             *
*     NWKEY    Number of keys associated with the data bank            *
*     KEY      Vector of keys                                          *
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *
*              IPREC significant digits right to the decimal points; if*
*              IPREC < 0, data are stored with IPREC insignificant     *
*              digits left to the decimal point.)                      *
*     CHOPT    Character string with any of the following characters   *
*          A   Trust LBK address if non-zero                           *
*          B   Save in the special backup file; not in standard Journal*
*          C   Create Node/Key data structure ala DBUSE                *
*          F   Updates with a fully matched data object (in user keys) *
*          K   Store data only inside the keys (not yet installed)     *
*          N   Create new (sub)directory(ies)                          *
*          P   Create partitioned subdirectories for the pathname      *
*          R   Store with full RZ option (No compression to be made)   *
*          S   Create stand alone (master) data                        *
*          T   Special text type of data (to be used with R)           *
*          U   Store data uncompressed                                 *
*          Z   Store only nonzero elements. An element is considered to*
*              be zero if its absolute value is less than IPREC (real) *
*          7   Insertion time as supplied by user to be honoured       *
*                                                                      *
*   Called by user,   DBAIWR, DBUPKY                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 61 : Too many keys                                   *
*               = 62 : Too many keys with option N                     *
*               = 63 : Data base structure in memory clobbered         *
*               = 64 : Error in MZCOPY while copying Data bank         *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DZPACK.
      DIMENSION       KEY(9), LBD(9), LBK(9), LSUP(9)
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, FPATH*80, CHOP*2
*
*     ------------------------------------------------------------------
*
* *** Decode the character option
*
      LREFDB(1) = LBK(1)
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)          GO TO 999
      PACKDZ = .FALSE.
*
      IF (IOPUDA.NE.0.AND.IOPZDA.NE.0)  THEN
        IOPZDA = 0
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBENTR : Warning'//
     +  ' - Z option is incompatible with U option - U option will be'//
     +  ' executed'')', IARGDB, 0)
+SELF.
*
      ELSE IF (IOPZDA.NE.0)  THEN
        PACKDZ = .TRUE.
        CALL UCOPY (IPREC, PRECDZ, 1)
      ENDIF
*
      IF (IOPRDA.NE.0.AND.IOPNDA.NE.0)  THEN
        IOPNDA = 0
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBENTR : Warning'//
     +  ' - R option is incompatible with N option - R option will be'//
     +  ' executed'')', IARGDB, 0)
+SELF.
      ENDIF
*
* *** Check the number of keys
*
      IF (NWKEY.GT.MXDMDK)  THEN
        IQUEST(1) = 61
        IQUEST(11)= NWKEY
        IQUEST(12)= MXDMDK
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTR : Too man'//
     +  'y keys '',I6,'' maximum permitted '',I6)', IQUEST(11), 2)
+SELF.
        GO TO 999
      ENDIF
*
      IF (IOPNDA.NE.0.AND.NWKEY.GT.NINEDK)  THEN
        IQUEST(1) = 62
        IQUEST(11)= NWKEY
        IQUEST(12)= NINEDK
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTR : Too man'//
     +  'y keys '',I6,'' with option N - a maximum of '',I6,'' permit'//
     +  'ted'')', IQUEST(11), 2)
+SELF.
        GO TO 999
      ENDIF
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Create new subdirectories if needed
*
      IF (NWKEY.GE.NSYSDK)  THEN
        NTKEY  = NWKEY
      ELSE
        NTKEY  = NINEDK
      ENDIF
      IF (IOPNDA.NE.0)  THEN
        IF (IOPPDA.EQ.0)  THEN
          CALL DBMDIR (PATH, NTKEY, CHFTDK, CHTGDK)
        ELSE
          KEY7DK = 0
          CALL DBMDIP (PATH, NTKEY, CHFTDK, CHTGDK, MXKPDK)
        ENDIF
        IF (IQUEST(1).NE.0)        GO TO 999
      ENDIF
*
* *** Prepare the Key vector array
*
      CALL VZERO (KEYVDK, MXDMDK)
      KEYVDK(MBVRDB) = KEY(MBVRDB)
      KEYVDK(MEVRDB) = KEY(MEVRDB)
      KEYVDK(MPVSDB) = KEY(MPVSDB)
      IOKYDA(MPVSDB) = 1
      IF (IOKYDA(MITMDB).NE.0) KEYVDK(MITMDB) = KEY(MITMDB)
      IF (NWKEY.GT.NSYSDK) THEN
        DO 20 NK = NSYSDK+1, NWKEY
          IOKYDA(NK) = 1
          KEYVDK(NK) = KEY(NK)
   20   CONTINUE
      ENDIF
*
* *** Write out the data
*
      CALL DBKOUT (PATH, IUDIV, LSUP(1), NTKEY, KEYVDK, IPREC)
      IF (IQUEST(1).NE.0)          GO TO 999
*
* *** Create data bank in memory ala DBUSE
*
      IF (IOPCDA.NE.0)  THEN
*
*  **   Create database skeleton in memory (banks NODB and KYDB)
*
        IF (IOPADA.EQ.0. OR. (IOPADA.NE.0. AND. LREFDB(1).EQ.0) )  THEN
*
          CALL DBNODE (PATH, LBNODB)
          IF (IQUEST(1).NE.0)      GO TO 999
*
*  *      Switch off M and/or S option of DBUSE
*
          ITMPM  = IOPMDA
          ITMPS  = IOPSDA
          IOPMDA = 0
          IOPSDA = 0
*
          CALL DBKEYS (LBNODB, KEYVDK, LBK, KEYVDK(MBVRDB))
          IF (IQUEST(1).NE.0)      GO TO 999
          LREFDB(1) = LBK(1)
          IOPMDA = ITMPM
          IOPSDA = ITMPS
          CALL UCOPY (KEYVDK(1), IQ(KOFUDB+LREFDB(1)+1), NWKYDK)
          NDK    = IQ(KOFUDB+LREFDB(1)-1)
          IQ(KOFUDB+LREFDB(1)+NDK+MKYFRI) = 0
          IQ(KOFUDB+LREFDB(1)+NWKYDK+1)   = KEYVDK(MEVRDB)
*
        ELSE
+SELF, IF=$DEBUG.
*
          IF (IDEBDB.GT.0) THEN
            LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)
            NF     = IQ(KOFUDB+LBNODB+MNDNCH)
            CALL UHTOC (IQ(KOFUDB+LBNODB+MNDNAM), 4, FPATH, NF)
            FPATH  = FPATH(1:NF)
            N = INDEX (PATH, ' ')
            IF (N.EQ.0)  N = LEN (PATH) + 1
*
   50       N = N -1
            IF (PATH(N:N).NE.FPATH(NF:NF))  THEN
              IQUEST(1) = 63
              IQUEST(11)= N
              CALL DBPRNT (LPRTDB, '(/,'' DBENTR : Database structure'//
     +             ' in memory clobbered'')', IARGDB, 0)
              GO TO 999
            ELSE IF (N.NE.1)  THEN
              NF = NF -1
              GO TO 50
            ENDIF
          ENDIF
+SELF.
*
          CALL UCOPY (KEYVDK(1), IQ(KOFUDB+LREFDB(1)+1), NWKYDK)
          NDK    = IQ(KOFUDB+LREFDB(1)-1)
          IQ(KOFUDB+LREFDB(1)+NDK+MKYFRI) = 0
          IQ(KOFUDB+LREFDB(1)+NWKYDK+1)   = KEYVDK(MEVRDB)
        ENDIF
*
*  **   Now copy the data banks appended at LSUP to the key bank
*
        IF (IOPRDA.EQ.0)  THEN
          CHOP   = 'NP'
        ELSE
          CHOP   = 'LP'
        ENDIF
*
        IF (IOPKDA.EQ.0 .AND. LSUP(1).NE.0) THEN
          CALL MZCOPY (IUDIV, LSUP(1), IDIVDB, LREFDB(1), -KLDADB, CHOP)
        ENDIF
*
        IF (IQUEST(1).EQ.0)  THEN
          LBD(1) = LQ(KOFUDB+LREFDB(1)-KLDADB)
        ELSE
          IQUEST(11)= IQUEST(1)
          IQUEST(1) = 64
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENTR : Error'//
     +    ' '',I6,'' while copying the Data bank in the Node/Key stru'//
     +    'cture'')', IQUEST(11), 1)
+SELF.
        ENDIF
*
      ENDIF
*                                                             END DBENTR
  999 END
+DECK, DBFREE.
      SUBROUTINE DBFREE (PATHN, LBK, KEYS, CHOPT)
*     ===========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBFREE (PATHN, LBK, KEYS, CHOPT)                        *
*                                                                      *
*   Declares the given data bank(s) as candidates to be dropped in     *
*   case space is needed in the database division. Optionally it       *
*   deletes the Data bank(s) (with option D) or the Keys as well as    *
*   the Data bank(s) (with option K).                                  *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     LBK(*)   Address(es) of Keys bank(s) KYDB                        *
*     KEYS     Vector of keys                                          *
*     CHOPT    Character string with any of the following characters   *
*          A   trust LBK address(es) if non-zero                       *
*          D   drop the Data bank(s) supported at link 1 of Key bank(s)*
*          K   drop the Key bank(s) as well as Data bank(s)            *
*          M   expect multiple Key banks                               *
*          S   Key/data was retrieved using 'S' option in DBUSE        *
*          V   declare the Data as being of variable size              *
*          3   start valdity time to be < KEYS(3) (with option S)      *
*          4   end   valdity time to be > KEYS(4) (with option S)      *
*          5   specific Program version number required                *
*          7   insertion time to be < KEYS(7)                          *
*          n   consider user key n (7 < n < 29)                        *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 51 : Illegal character option                        *
*               = 52 : No access to the Key banks                      *
*               = 53 : Pathname not found in the RZ directory          *
*               = 54 : Pathname not matched to that found in bank NODB *
*               = 55 : Too many keys with option M                     *
*               = 56 : Illegal Key option                              *
*               = 57 : Illegal pathname                                *
*               = 58 : Database structure in memory clobbered          *
*               = 59 : Some of the expected key banks not found        *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DMULOP.
      CHARACTER       FPATH*80, FTEMP*80, FTMP1*80, CNODE(20)*16, CHL*16
      CHARACTER       PATH*80, PATHN*(*), CHOPT*(*)
      DIMENSION       LBK(9), KEYS(9)
*
*     ------------------------------------------------------------------
*
* *** Decode all the options
*
      LREFDB(1) = LBK(1)
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)                              GO TO 999
      IF (IOPMDA.NE.0 .AND. IOPSDA.NE.0)  THEN
        IQUEST(1) = 51
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFREE : Illegal'//
     +  ' character option -- Options S/M are mutually exclusive'')',
     +  IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Check if Key bank address is usable
*
      IF (PATH(1:1).NE.'*'.AND.PATH(1:1).NE.' ') THEN
        IPUSE = 1
      ELSE
        IPUSE = 0
      ENDIF
      IF (LREFDB(1).NE.0.AND.IOPADA.NE.0) THEN
        IKUSE = 1
      ELSE
        IKUSE = 0
      ENDIF
*
* *** Check if the options are consistent
*
      IF (IPUSE+IKUSE.EQ.0)  THEN
        IQUEST(1) = 52
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFREE : Illegal'//
     +  ' entry -- No access to Key bank '')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
      IF (IKUSE.NE.0)                                  GO TO 10
      IF (IPUSE.NE.0)  THEN
        CALL RZCDIR (PATH, ' ')
        IF (IQUEST(1).NE.0)  THEN
          IQUEST(1) = 53
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFREE : Pathn'//
     +    'ame '//PATH(1:NCHAR)//' not found in RZ directory'')',
     +    IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
        NWKYDK = IQUEST(8)
        CALL RZCDIR (FPATH, 'R')
*
      ELSE
        LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)
        NWKYDK = IQ(KOFUDB+LBNODB+MNDNWK)
      ENDIF
*
      IF (IPUSE.NE.0.AND.IKUSE.NE.0)  THEN
        LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)
        NCHAR  = IQ(KOFUDB+LBNODB+MNDNCH)
        IF (NCHAR.GT.MAXLDB) NCHAR  = MAXLDB
        CALL UHTOC (IQ(KOFUDB+LBNODB+MNDNAM), 4, FTMP1, NCHAR)
        FTEMP  = FTMP1(1:NCHAR)
        IF (FTEMP.NE.FPATH)  THEN
          IQUEST(1) = 54
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFREE : Pathn'//
     +    'ame '//FPATH//' not matched to '',/,18X,'' '//FTEMP//' fou'//
     +    'nd in bank NODB'')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
      ENDIF
*
   10 IQUEST(1) = 0
*
* *** Get number of key banks needed
*
      NMUL   = 0
      NKYMX  = 1
      ISTKY  = NWKYDK
      IF (IOPMDA.NE.0)  THEN
        IF (NWKYDK.GT.NSYSDK)  THEN
          DO 15 I = NSYSDK+1, NWKYDK
            IF (IOKYDA(I).NE.0) THEN
              IF (NMUL.GE.NMLMDM)  THEN
*
*  **           Too many keys with option M
*
                IQUEST(1)  = 55
                IQUEST(11) = NMLMDM + 1
                IQUEST(12) = I
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFREE :'//
     +          ' Too many keys '',I3,'' with M option - Last Key'','//
     +          'I3)', IQUEST(11), 2)
+SELF.
                GO TO 999
              ENDIF
*
              IF (KEYS(I).LE.0)  THEN
*
*  **           Illegal key option
*
                IQUEST(1)  = 56
                IQUEST(11) = I
                IQUEST(12) = KEYS(I)
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) THEN
                  IARGDB(1) = IQUEST(12)
                  IARGDB(2) = IQUEST(11)
                  CALL DBPRNT (LPRTDB, '(/,'' DBFREE : Illegal key op'//
     +                 'tion '',I3,'' for key '',I3,'' with option M'')'
     +,                IARGDB, 2)
                ENDIF
+SELF.
                GO TO 999
              ENDIF
*
*  **         Build up the array of keys used for option M
*
              NMUL   = NMUL + 1
              NOCCDM(NMUL) = KEYS(I)
              LFKYDM(NMUL) = ISTKY
              KTYPDM(NMUL) = I
              ISTKY  = ISTKY + KEYS(I)
              NKYMX  = NKYMX * KEYS(I)
            ENDIF
   15     CONTINUE
        ENDIF
      ENDIF
*
* *** Get the L-address of the first Key bank
*
      IF (IKUSE.NE.0)  THEN
        LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)
        LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)
        ND     = IQ(KOFUDB+LBNODB+MNDNWD)
      ELSE
*
*  **   Get it from the pathname
*  **   First find the list of Nodes
*
        NODES  = 0
        MAXL   = MAXLDB
        I0     = 0
   20   I1     = I0 + 1
        IF (I1.GT.MAXL)                                GO TO 45
        DO 25 I0 = I1, MAXL
          IF (FPATH(I0:I0).EQ.' ')                     GO TO 35
          IF (FPATH(I0:I0).EQ.'/')                     GO TO 30
   25   CONTINUE
        I0     = MAXL + 1
   30   I2     = I0 - 1
        GO TO 40
   35   I2     = I0 - 1
        I0     = MAXL + 1
   40   IF (I2.LT.I1)                                  GO TO 20
        NODES  = NODES + 1
        CNODE(NODES) = FPATH(I1:I2)
        GO TO 20
*
*  **   Number of Nodes found should be nonzero
*
   45   CONTINUE
        IF (NODES.EQ.0)  THEN
          IQUEST(1) = 57
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFREE : Illeg'//
     +    'al pathname '//FPATH//''')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
*
*  **   Go through the Nodes to reach the bottom level
*
        IN     = 0
   50   IN     = IN + 1
*
*  *    Construct the pathname from the Node names
*
        NCHAR  = 2
        FPATH  = '//'
        MAXL   = 16
        DO 60 I = 1, IN
          CHL    = CNODE(I)
          DO 55 J = 1, MAXL
            IF (CHL(J:J).EQ.' ') THEN
               NMAX   = J - 1
             ELSE
               IF (J.NE.MAXL)                          GO TO 55
               NMAX   = J
             ENDIF
*
            IF (NCHAR+NMAX .GT. MAXLDB) NMAX = MAXLDB - NCHAR
            IF (I.EQ.1)  THEN
              FPATH  = '//'//CHL(1:NMAX)
              NCHAR  = NMAX + 2
            ELSE
              FTEMP  = FPATH(1:NCHAR)//'/'//CHL(1:NMAX)
              FPATH  = FTEMP
              NCHAR  = NCHAR + NMAX + 1
            ENDIF
            IF (NCHAR.EQ.MAXLDB)                       GO TO 65
            GO TO 60
   55     CONTINUE
   60   CONTINUE
*
*  *   The first Node should be at the top directory
*
   65   I0     = 0
        IF (IN.EQ.1) THEN
          NMAX   = NTOPDB
          LBFXDB = LTOPDB
        ELSE
          NMAX   = IQ(KOFUDB+LBKYDB-2)
        ENDIF
*
   70   I0     = I0 + 1
*
*  *    No link left for the Node bank
*
        IF (I0.GT.NMAX)  THEN
          IQUEST(1) = 58
          IQUEST(11)= IN
          IQUEST(12)= NODES
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFREE : Node'//
     +    ' '//CNODE(IN)//' at level '',I3,'' out of '',I3,'' not fou'//
     +    'nd'')', IQUEST(11), 2)
+SELF.
          GO TO 999
        ENDIF
*
        IF (IN.EQ.1)  THEN
          IF (I0.GT.1) LBFXDB = LQ(KOFUDB+LBFXDB)
          LBNODB = LQ(KOFUDB+LBFXDB-1)
        ELSE
          LBNODB = LQ(KOFUDB+LBKYDB-I0)
        ENDIF
        IF (LBNODB.EQ.0)                               GO TO 70
*
*  *    Check the full pathname in the Node bank name against
*  *    the current pathname
*
        MCHAR  = IQ(KOFUDB+LBNODB+MNDNCH)
        IF (MCHAR.GT.MAXLDB) MCHAR  = MAXLDB
        CALL UHTOC (IQ(KOFUDB+LBNODB+MNDNAM), 4, FTMP1, MCHAR)
        FTEMP  = FTMP1(1:MCHAR)
        IF (FTEMP.NE.FPATH)                            GO TO 70
*
        LBKYDB = LBNODB
        IF (IN.LT.NODES)                               GO TO 50
        ND     = IQ(KOFUDB+LBNODB+MNDNWD)
        LBKYDB = LQ(KOFUDB+LBKYDB)
      ENDIF
*
* *** Number of Key banks to be serviced with option S
*
      IF (IOPSDA.NE.0)  THEN
        NKYMX  = NZBANK (IDIVDB, LBKYDB)
        NMUL   = 0
      ENDIF
*
* *** Loop over all possible Key Banks
*
      NK     = 0
      IQER1  = 0
   75 NK     = NK + 1
*
*  ** For option 'M', find the corresponding key values
*
      IF (NMUL.GT.0)  THEN
        DO 85 I = 1, NMUL
          NK0    = NK
          IF (I.NE.1)  THEN
            DO 80 J = 1, I-1
              NK0    = (NK0 - INDXDM(J)) / NOCCDM(J) + 1
   80       CONTINUE
          ENDIF
          NK0    = MOD (NK0, NOCCDM(I))
          IF (NK0.EQ.0) NK0 = NOCCDM(I)
          INDXDM(I) = NK0
          KEYVDM(I) = KEYS(LFKYDM(I)+NK0)
   85   CONTINUE
      ENDIF
*
*  ** Check if this Key bank already exists
*
      IF (IOPSDA.EQ.0) LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)
   90 CONTINUE
      IF (LBKYDB.NE.0)  THEN
        IF (IOPSDA.EQ.0)  THEN
          IF (IOKYDA(MPVSDB).NE.0.AND.
     +        KEYS(MPVSDB).NE.IQ(KOFUDB+LBKYDB+MPVSDB))GO TO 115
          IF (IOKYDA(MITMDB).NE.0.AND.
     +        KEYS(MITMDB).LT.IQ(KOFUDB+LBKYDB+MITMDB))GO TO 115
          IF (NWKYDK.GT.NSYSDK)  THEN
            IF (NMUL.EQ.0)  THEN
              DO 95 I = NSYSDK+1, NWKYDK
                IF (IOKYDA(I).NE.0)  THEN
                  IF (KEYS(I).NE.IQ(KOFUDB+LBKYDB+I))  GO TO 115
                ENDIF
   95         CONTINUE
            ELSE
              DO 100 I = 1, NMUL
                NU     = KTYPDM(I)
                IF (KEYVDM(I).NE.IQ(KOFUDB+LBKYDB+NU)) GO TO 115
  100         CONTINUE
            ENDIF
          ENDIF
*
        ELSE
*
          IF (IOKYDA(MBVRDB).NE.0.AND.
     +        KEYS(MBVRDB).LT.IQ(KOFUDB+LBKYDB+MBVRDB))GO TO 115
          IF (IOKYDA(MEVRDB).NE.0.AND.
     +        KEYS(MEVRDB).GT.IQ(KOFUDB+LBKYDB+MEVRDB))GO TO 115
          IF (IOKYDA(MPVSDB).NE.0.AND.
     +        KEYS(MPVSDB).NE.IQ(KOFUDB+LBKYDB+MPVSDB))GO TO 115
          IF (IOKYDA(MITMDB).NE.0.AND.
     +        KEYS(MITMDB).LT.IQ(KOFUDB+LBKYDB+MITMDB))GO TO 115
          IF (NWKYDK.GT.NSYSDK)  THEN
            DO 105 I = NSYSDK+1, NWKYDK
              IF (IOKYDA(I).NE.0)  THEN
                IF (KEYS(I).NE.IQ(KOFUDB+LBKYDB+I))    GO TO 115
              ENDIF
  105       CONTINUE
          ENDIF
        ENDIF
*
*  **   Take proper action according to character option
*
        IF (IOPKDA.NE.0)  THEN
*
*  *      Drop the Key bank
*
          LKEY   = LBKYDB
          LBKYDB = LQ(KOFUDB+LKEY+2)
          CALL MZDROP (IDIVDB, LKEY, ' ')
        ELSE IF (IOPDDA.NE.0) THEN
*
*  *      Drop the data bank
*
          CALL MZDROP (IDIVDB, LBKYDB, 'V')
        ELSE
*
*  *      Set the free bit
*
          IQ(KOFUDB+LBKYDB+ND+MKYFRI) = 1
        ENDIF
        GO TO 120
  115   LBKYDB = LQ(KOFUDB+LBKYDB)
        GO TO 90
*
      ELSE
*
        IF (IOPSDA.EQ.0) THEN
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0.AND.IQER1.EQ.0) CALL DBPRNT (LPRTDB,'(/,'' '//
     +      'DBFREE : Atleast one of the required key bank(s) not fou'//
     +      'nd'')', IARGDB, 0)
+SELF.
          IQER1  = 59
          IF (IOPMDA.NE.0) LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)
        ELSE
          IQUEST(1) = 0
          GO TO 999
        ENDIF
      ENDIF
*
  120 CONTINUE
      IF (IOPSDA.EQ.0)  THEN
        IF (NK.LT.NKYMX)                               GO TO 75
      ELSE
        IF (LBKYDB.NE.0) LBKYDB = LQ(KOFUDB+LBKYDB)
        IF (LBKYDB.NE.0)                               GO TO 75
      ENDIF
      IQUEST(1) = IQER1
*                                                             END DBFREE
  999 END
+DECK, DBFZOP.
      SUBROUTINE DBFZOP (LUNFZ, TOPN, CHOPT)
*     ======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBFZOP (LUNFZ, TOPN, CHOPT)                             *
*                                                                      *
*   Sets the output FZ file number as the sequential backup file for   *
*   a given top directory. One can have up to two backup files, one    *
*   for standard journaling, the other for special backups.            *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUNFZ    Logical unit number of the FZ file                      *
*     TOPN     Top directory name to which the FZ file refers          *
*     CHOPT    Character string with any of the following characters   *
*          B   Specify a special backup file                           *
*                                                                      *
*   Called by user,   DBACTI                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =140 : Illegal top directory name                      *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DFZLUN.
      CHARACTER       TOPN1*16, TOPN2*16, TOPN*(*), CHOPT*(*)
*
*     ------------------------------------------------------------------
*
* *** Decode the character option
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0) GO TO 999
      CALL DBSBLC (TOPN, TOPN2, NCHAR)
*
* *** Check if the topname matches with any of the existing topnames
*
      LTOP   = LTOPDB
   10 IF (LTOP.GT.0) THEN
        NCHR   = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPN1, NCHR)
        TOPN1  = TOPN1(1:NCHR)
        IF (TOPN2.NE.TOPN1) THEN
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 10
        ELSE
          IF (IOPBDA.EQ.0) THEN
            IOFF   = MUPJFL
          ELSE
            IOFF   = MUPBAK
          ENDIF
          LUNOL  = IQ(KOFUDB+LTOP+IOFF)
          IQ(KOFUDB+LTOP+IOFF) = LUNFZ
          IF (LUNOL.LE.0.AND.LUNFZ.GT.0) THEN
            INC    = 1
          ELSE IF (LUNOL.GT.0.AND.LUNFZ.LE.0) THEN
            INC    = - 1
          ELSE
            INC    = 0
          ENDIF
          NUFZDF = NUFZDF + INC
          IQUEST(1) = 0
        ENDIF
      ELSE
        IQUEST(1) = 140
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZOP : Illegal'//
     +  ' top directory name '//TOPN2(1:NCHAR)//''')', IARGDB, 0)
+SELF.
      ENDIF
*                                                             END DBFZOP
  999 END
+DECK, DBFZUP, IF=-$P3CHILD.
      SUBROUTINE DBFZUP (LUNFZ, CHOPT)
*     ================================
*
************************************************************************
*                                                                      *
*        SUBR. DBFZUP (LUNFZ, CHOPT)                                   *
*                                                                      *
*   Updates the data base from transcript file from unit LUNFZ         *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUNFZ    Logical unit number of the FZ file                      *
*     CHOPT    Character string with any of the following characters   *
*          F   Force continuation beyond errors                        *
*          O   Updating journal file is an external source             *
*          S   Updating journal file in a single record mode           *
*                                                                      *
*   Called by user,   DBACTI                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 76 : Cannot form the IO descriptor for the FZ header *
*               =141 : Read error on the FZ file                       *
*               =142 : Top directory name illegal in the transcript    *
*                      file                                            *
*               =143 : Illegal path name in the transcript file        *
*               = 78 : Illegal number of keys in journal file          *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DINITL.
+CDE, DKKEYS.
+SELF, IF=VAX, IF=$SERVER.
+CDE, DBSRVRN.
+SELF.
      PARAMETER       (NLEVM=20)
      DIMENSION       NLCUR(NLEVM), KEYN(MXDMDK)
      CHARACTER       PATHN*80, PATHD*80, TOPN*16, CHOPT*(*)
      CHARACTER       CHFOR*100, CFORM(6)*1, CHOPF*80, CHCUR(NLEVM)*1
      CHARACTER       ALIAS*8, PATHZ*80
      DATA            CFORM / 'B', 'I', 'F', 'D', 'H', 'A' /
*
*     ------------------------------------------------------------------
*
      PATHD  = ' '
      IACTO  = 0
      CALL UOPTC (CHOPT, 'F', IOPTF)
      CALL UOPTC (CHOPT, 'O', IOVRD)
      CALL UOPTC (CHOPT, 'S', ISNGR)
*
* *** Read the header record from the FZ file
*
   10 NWHEDF = NHEADF
      CALL FZIN (LUNFZ, IDISDB, 0, 0, 'S', NWHEDF, IHEADF)
      IF (IQUEST(1).GT.0)                                  GO TO 997
      IF (IQUEST(1).NE.0) THEN
        IQUEST(11) = IQUEST(1)
        IQUEST(1)  = 141
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZUP : FZ erro'//
     +  'r type '',I12)', IQUEST(11), 1)
+SELF.
        IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0)   GO TO 998
        IQUEST(1) = 0
        GO TO 10
      ENDIF
      IACT   = IHEADF(MACTDF)
      NWKEY  = IHEADF(MNKYDF)
      NDOP   = IHEADF(MOPTDF)
      NWDP   = IHEADF(MPATDF)
      IF (IACT.EQ.1) THEN
        NPNT1  = MPREDF + NWKEY + 1
        NPNT2  = NPNT1 + NDOP
      ELSE IF (IACT.EQ.2) THEN
        NPNT1  = MRECDF + 1
        NCFO   = (NWKEY + 3) / 4
        NPNT2  = NPNT1 + NDOP + NCFO + 2 * NWKEY
      ELSE IF (IACT.EQ.3) THEN
        KEY7DK = IHEADF(MINSDF)
        NPNT1  = MINSDF + NWKEY + 1
        NPNT2  = NPNT1 + NDOP
      ELSE IF (IACT.EQ.4) THEN
        KEY7DK = IHEADF(MINSDF)
        NPNT1  = MINSDF + 1
        NPNT2  = NPNT1 + NDOP
      ELSE IF (IACT.EQ.5) THEN
        KEY7DK = 0
        NPNT1  = MPREDF + 2*NWKEY + 1
        NPNT2  = NPNT1
      ELSE IF (IACT.EQ.6) THEN
        KEY7DK = 0
        NPNT1  = MFLGDF + NWKEY + 1
        NPNT2  = NPNT1
      ELSE IF (IACT.EQ.7) THEN
        KEY7DK = 0
        NPNT1  = MWDPDF + 1
        NPNT2  = NPNT1
      ELSE IF (IACT.EQ.8) THEN
        KEY7DK = IHEADF(MDELDF)
        NPNT1  = MKEPDF + 1
        NPNT2  = NPNT1 + NDOP
      ELSE IF (IACT.EQ.9) THEN
        NPNT1  = MPREDF + NWKEY + 1
        NPNT2  = NPNT1 + NDOP
      ELSE
        IF (LUNFZ.EQ.LUFMDB.OR.ISNGR.NE.0)                 GO TO 997
        GO TO 10
      ENDIF
*
      IF (IACT.GT.0.AND.IACT.LE.6.AND.IACT.NE.4) THEN
        IF (NWKEY.LT.NSYSDK.OR.NWKEY.GT.MXDMDK) THEN
          IQUEST(1) = 78
          IQUEST(11)= NWKEY
          IQUEST(12)= NSYSDK
          IQUEST(13)= MXDMDK
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZUP : Illeg'//
     +    'al number of keys '',I10,'' permitted range '',2I6)',
     +    IQUEST(11),  3)
+SELF.
          IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0) GO TO 998
          IQUEST(1) = 0
          GO TO 10
        ENDIF
      ENDIF
*
      IF (NDOP.GT.0) THEN
        NDOP   = MIN0 (NDOP, MAXLDB/4)
        CALL UHTOC (IHEADF(NPNT1), 4, CHOPF, 4*NDOP)
        CHOPF  = CHOPF(1:4*NDOP)
      ELSE
        CHOPF  = ' '
      ENDIF
      CALL DBOPTS (CHOPF)
      IF (IQUEST(1).GT.0) THEN
        IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0)   GO TO 998
        IQUEST(1) = 0
        GO TO 10
      ENDIF
*
      CALL UHTOC (IHEADF(NPNT2), 4, PATHN, 4*NWDP)
      PATHN  = PATHN(1:4*NWDP)
      NCH    = INDEX (PATHN, ' ') - 1
      IF (NCH.LE.0) NCH = MAXLDB
+SELF, IF=VAX, IF=$SERVER.
      DBFZUP_PATHN_L = 4*NWDP
      DBFZUP_PATHN   = PATHN
      DBFZUP_IACT    = IACT
+SELF.
*
* *** Extract the top directory name from the pathname
*
      CALL DBTOPN (PATHN, TOPN, I1)
   20 IF (I1.EQ.0) THEN
        IQUEST(1) = 142
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZUP : Illegal'//
     +  ' top directory name '//PATHN//''')', IARGDB, 0)
+SELF.
        IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0)   GO TO 998
        IQUEST(1) = 0
        GO TO 10
      ENDIF
*
* *** Check if the topname matches with any of the existing topnames
*
      LTOP   = LTOPDB
      LREFDB(1) = 0
+SELF, IF=-$SERVER, CRAY.
      IOPP   = 0
+SELF.
   25 IF (LTOP.GT.0) THEN
        NCHR   = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHR)
        TOPNDI = TOPNDI(1:NCHR)
        IF (TOPN.NE.TOPNDI) THEN
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 25
        ELSE
          LREFDB(1) = LQ(KOFUDB+LTOP-KLFZDB)
          IF (IOPBDA.EQ.0) THEN
            LUFZDF = IQ(KOFUDB+LTOP+MUPJFL)
          ELSE
            LUFZDF = IQ(KOFUDB+LTOP+MUPBAK)
          ENDIF
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10)
+SELF.
        ENDIF
      ELSE
        IQUEST(1) = 142
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZUP : Illegal'//
     +  ' top directory name '//PATHN//''')', IARGDB, 0)
+SELF.
        IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0)   GO TO 998
        IQUEST(1) = 0
        GO TO 10
      ENDIF
      IF (IOUT.EQ.0) IOPS = 0
*
* *** Check if the directory is one in the list
*
      IF (LREFDB(1).NE.0) THEN
        NCUR   = IQ(KOFUDB+LREFDB(1)-5)
        DO 30 I = 1, NCUR
          IPNT   = KOFUDB + LREFDB(1) + MFZDIR + (I - 1) * (MXLWDB + 1)
          NCHZ   = IQ(IPNT)
          CALL UHTOC (IQ(IPNT+1), 4, PATHZ, NCHZ)
          IF ((PATHZ(1:NCHZ).EQ.PATHN(1:NCHZ)).AND.
     +        (PATHN(NCHZ+1:NCHZ+1).EQ.'/'.OR.
     +         PATHN(NCHZ+1:NCHZ+1).EQ.' '))               GO TO 35
   30   CONTINUE
        IQUEST(1) = 0
        IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0)   GO TO 998
        GO TO 10
      ENDIF
*
* *** Decide overriding flag
*
   35 IOVRDB = IOVRD
      IF (LBAFDB.NE.0) THEN
        NCUR   = IQ(KOFUDB+LBAFDB-5)
        DO 40 I = 1, NCUR
          IPNT   = KOFUDB + LBAFDB + (I - 1) * (MXLWDB + 1) + 1
          NCHZ   = IQ(IPNT)
          CALL UHTOC (IQ(IPNT+1), 4, PATHZ, NCHZ)
          IF ((PATHZ(1:NCHZ).EQ.PATHN(1:NCHZ)).AND.(NCHZ.EQ.NCH)) THEN
            IOVRDB = 1
            GO TO 45
          ENDIF
   40   CONTINUE
      ENDIF
*
* *** Check if the current directory is to be changed
*
   45 IF (PATHN.NE.PATHD.OR.IACT.NE.IACTO) THEN
        IF (IACT.NE.2) THEN
          PATHZ  = PATHN
        ELSE
          PATHZ  = '//'//TOPN
        ENDIF
        CALL RZCDIR (PATHZ, ' ')
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1) = 143
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZUP : Illeg'//
     +    'al path name '//PATHZ//''')', IARGDB, 0)
+SELF.
          IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0) GO TO 998
          IQUEST(1) = 0
          GO TO 10
        ENDIF
        IACTO  = IACT
        NKEYDK = IQUEST(7)
        NWKYDK = IQUEST(8)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        PATHD  = PATHN
*
*  **   Get the IO descriptor for the header
*
        IF (LUFZDF.GT.0.AND.IACT.EQ.1) THEN
          CALL DBKEYT
          NLEV   = 1
          NCUR   = 5
          IFORO  = 2
          CHCUR(NLEV) = CFORM(IFORO)
          DO 50 I = 1, NWKYDK
            IFORM  = IOTYDK(I)
            IF (IFORM.EQ.6) IFORM = 5
            IF (IFORM.EQ.IFORO) THEN
              NCUR   = NCUR + 1
            ELSE
              NLCUR(NLEV) = NCUR
              IF (NLEV.GE.NLEVM) THEN
                IQUEST(1) = 76
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZUP :'//
     +          ' Cannot get IO descriptor '//PATHN//''')', IARGDB, 0)
+SELF.
                IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0)
     +                                                     GO TO 998
                IQUEST(1) = 0
                GO TO 10
              ENDIF
              NLEV   = NLEV + 1
              CHCUR(NLEV) = CFORM(IFORM)
              NCUR   = 1
              IFORO  = IFORM
            ENDIF
   50     CONTINUE
          NLCUR(NLEV) = NCUR
*
+SELF, IF=-IBM, -$P3CHILD.
          WRITE (CHFOR, 2001) (NLCUR(I), CHCUR(I), I = 1, NLEV)
+SELF, IF=IBM, IF=$P3CHILD.
          CHFOR  = ' '
          II     = 1
          DO 55 I = 1, NLEV
            CALL UTWRIT (CHFOR(II:II+1), '(I2)', NLCUR(I))
            II     = II + 2
            CHFOR(II:II) = CHCUR(I)
            II     = II + 2
   55     CONTINUE
+SELF.
          II     = 4 *NLEV
          CHFOR = CHFOR(1:II)//' -H'
          CALL MZIOCH (IOFMDF, NWFMDF, CHFOR(1:II+3))
        ENDIF
      ENDIF
*
* *** Take appropriate action as directed by IACT
*
      IF (IACT.EQ.1) THEN
*
*  **   Enter data
*
        CALL DBENFZ (PATHN, LUNFZ, IOPP, TOPN, IOPS)
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          CALL DBUPTM (IARGDB(1), IARGDB(2), IHEADF(MPREDF+MITMDB))
          IARGDB(3) = IQUEST(1)
          CALL DBPRNT (LPRTDB, '('' DBFZUP : enter object in '//
     +         PATHN(1:60)//' time '',2I8,'' return code '',I6)',
     +         IARGDB, 3)
        ENDIF
+SELF.
        IF (IQUEST(1).LT.0)                                GO TO 997
*
      ELSE IF (IACT.EQ.2) THEN
*
*  **   Create a new directory
*
        IOKYDA(MSERDB) = 1
        KEY7DK = IHEADF(MINSDF)
        NPNTF  = NPNT1 + NDOP
        CALL UHTOC (IHEADF(NPNTF), 4, CHFOR, NWKEY)
        CHFOR  = CHFOR(1:NWKEY)
        NPNTF  = NPNTF + NCFO
        DO 60 IK = 1, NWKEY
          CALL UHTOC (IHEADF(NPNTF), 4, CTAGDK(IK), 8)
          NPNTF  = NPNTF + 2
   60   CONTINUE
        IF (IOPPDA.EQ.0) THEN
          CALL DBMDIR (PATHN, NWKEY, CHFOR, CTAGDK)
        ELSE
          MXKP   = IHEADF(MXKPDF)
          CALL DBMDIP (PATHN, NWKEY, CHFOR, CTAGDK, MXKP)
        ENDIF
        IOKYDA(MSERDB) = 0
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          CALL DBUPTM (IARGDB(1), IARGDB(2), IHEADF(MINSDF))
          IARGDB(3) = IQUEST(1)
          CALL DBPRNT (LPRTDB, '('' DBFZUP : enter new directory '//
     +         PATHN(1:60)//' time '',2I8,'' return code '',I6)',
     +         IARGDB, 3)
        ENDIF
+SELF.
*
      ELSE IF (IACT.EQ.3) THEN
*
*  **   Delete data objects
*
        ITIME  = IHEADF(MTIMDF)
        IF (ITIME.GT.0) THEN
          CALL UCOPY (IHEADF(MINSDF+1), KEYVDK, NWKEY)
          CALL DBPURK (PATHN, ITIME, KEYVDK, CHOPF)
        ELSE
          KYDAT  = IHEADF(MINSDF+MSERDB)
          KYTIM  = IHEADF(MINSDF+MUPNDB)
          CALL DBPURG (PATHN, KYDAT, KYTIM, CHOPF)
        ENDIF
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          CALL DBUPTM (IARGDB(1), IARGDB(2), IHEADF(MINSDF))
          IARGDB(3) = IQUEST(1)
          IARGDB(4) = IQUEST(2)
          CALL DBPRNT (LPRTDB, '('' DBFZUP : purge data from '//
     +         PATHN(1:60)//' time '',2I8,'' return code '',I4,I6)',
     +         IARGDB, 4)
        ENDIF
+SELF.
*
      ELSE IF (IACT.EQ.4) THEN
*
*  **   Delete an entire tree
*
        CALL DBDELT (PATHN, CHOPF)
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          CALL DBUPTM (IARGDB(1), IARGDB(2), IHEADF(MINSDF))
          IARGDB(3) = IQUEST(1)
          CALL DBPRNT (LPRTDB, '('' DBFZUP : delete the tree '//
     +         PATHN(1:60)//' time '',2I8,'' return code '',I6)',
     +         IARGDB, 3)
        ENDIF
+SELF.
        IF (IQUEST(1).EQ.171) IQUEST(1) = 0
*
      ELSE IF (IACT.EQ.5) THEN
*
*  **   Rename the keys
*
        CALL UCOPY  (IHEADF(MPREDF+1), KEYVDK, NWKEY)
        CALL UCOPY  (IHEADF(MPREDF+NWKEY+1), KEYN, NWKEY)
        CALL DBRENK (PATHN, KEYVDK, KEYN)
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          CALL DBUPTM (IARGDB(1), IARGDB(2), IHEADF(MPREDF+MITMDB))
          IARGDB(3) = IQUEST(1)
          CALL DBPRNT (LPRTDB, '('' DBFZUP : rename keys in '//
     +         PATHN(1:60)//' time '',2I8,'' return code '',I6)',
     +         IARGDB, 3)
        ENDIF
+SELF.
        IF (IQUEST(1).EQ.192) IQUEST(1) = 0
*
      ELSE IF (IACT.EQ.6) THEN
*
*  **   Enter the name or help information
*
        IFLG   = IHEADF(MFLGDF)
        CALL UCOPY  (IHEADF(MFLGDF+1), KEYVDK, NWKEY)
        CALL DBSNAM (IFLG, KEYVDK, 0, TOPN, LUNFZ)
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          IARGDB(1) = IHEADF(MFLGDF+MSERDB)
          CALL DBUPTM (IARGDB(2), IARGDB(3), IHEADF(MFLGDF+MITMDB))
          IARGDB(4) = IQUEST(1)
          IF (IFLG.EQ.1) THEN
            CALL DBPRNT (LPRTDB, '('' DBFZUP : enter help information'//
     +           ' for path code '',I6,'' time '',2I8,'' return code'//
     +           ' '',I6)', IARGDB, 4)
          ELSE
            CALL DBPRNT (LPRTDB, '('' DBFZUP : enter name information'//
     +           ' for path code '',I6,'' time '',2I8,'' return code'//
     +           ' '',I6)', IARGDB, 4)
          ENDIF
        ENDIF
+SELF.
*
      ELSE IF (IACT.EQ.7) THEN
*
*  **   Rename alias name of a given directory
*
        IFLG   = IHEADF(MFLGDF)
        NWDF   = IHEADF(MWDPDF)
        ALIAS  = ' '
        CALL UHTOC  (IHEADF(MWDPDF+NWDP+1), 4, ALIAS, 8)
        CALL UHTOC  (IHEADF(MWDPDF+NWDP+3), 4, CHOPF, 4*NWDF)
        CHOPF  = CHOPF(1:4*NWDF)
        CALL DBEALI (CHOPF, ALIAS, IFLG)
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          CALL DBPRNT (LPRTDB, '('' DBFZUP : enter alias name for pat'//
     +         'h '//CHOPF(1:60)//' return code '',I6)', IQUEST(1), 1)
        ENDIF
+SELF.
        IQUEST(1) = 0
*
      ELSE IF (IACT.EQ.8) THEN
*
*  **   Delete a few partitions in a partitioned directory
*
        IKEEP  = IHEADF(MKEPDF)
        CALL DBPRGD (PATHN, IKEEP, CHOPF)
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          IARGDB(1) = IKEEP
          IARGDB(2) = IQUEST(1)
          CALL DBPRNT (LPRTDB, '('' DBFZUP : delete all but '',I6,'' '//
     +         'partitions in '//PATHN(1:60)//' return code '',I6)',
     +         IARGDB, 2)
        ENDIF
+SELF.
        IQUEST(1) = 0
*
      ELSE IF (IACT.EQ.9) THEN
*
*  **   Use the forbidden path for updating data base (replace object)
*
        CALL FZIN (LUNFZ, IDISDB, LFIXDB, 2, 'A', 0, 0)
        IF (IQUEST(1).GT.0)                                GO TO 997
        IF (IQUEST(1).NE.0) THEN
          IQUEST(11) = IQUEST(1)
          IQUEST(1)  = 141
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZUP : FZ er'//
     +    'ror type '',I12)', IQUEST(11), 1)
+SELF.
          GO TO 991
        ENDIF
        CALL UCOPY (IHEADF(MPREDF+1), KEYN, NWKEY)
        CALL DBDONT (PATHN, IDISDB, LFIXDB, NWKEY, KEYN, CHOPF)
        IKEEP  = IQUEST(1)
        CALL MZDROP (IDISDB, LFIXDB, 'L')
        LFIXDB = 0
        IQUEST(1) = IKEEP
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          IARGDB(1) = IKEEP
          CALL DBPRNT (LPRTDB, '('' DBFZUP : updated data base in '//
     +         'replace mode for '//PATHN(1:60)//' return code '',I6)',
     +         IARGDB, 1)
        ENDIF
+SELF.
*
      ENDIF
  991 IF (IQUEST(1).GT.0) THEN
        IF (LUNFZ.EQ.LUFMDB.OR.IOPTF.EQ.0.OR.ISNGR.NE.0)   GO TO 998
        IQUEST(1) = 0
        GO TO 10
      ENDIF
      IF (LUNFZ.NE.LUFMDB.AND.ISNGR.EQ.0)                  GO TO 10
*
  997 IQUEST(1) = 0
  998 CONTINUE
+SELF, IF=-IBM, -$P3CHILD.
*
 2001 FORMAT (20(I2,A1,1X))
+SELF.
*                                                             END DBFZUP
      END
+DECK, DBGET.
+SEQ, T=DUMMY, IF= $P3CHILD.
      SUBROUTINE DBGET (PATHN, LBK, KEYS, CHOPT)
*     ==========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBGET (PATHN, LBK*, KEYS, CHOPT)                        *
*                                                                      *
*   Prepares the database data structure in memory for any required    *
*   Pathname and set of Keys, unless already done.  Returns the        *
*   in memory for the corresponding Key bank(s) with a selection on    *
*   a range of start validity time and user keys.                      *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     LBK(*)   Address(es) of Keys bank(s) KYDB. The data bank address *
*              can be obtained as LQ(LBK-1)                            *
*              For option 'S' it is the support address of the linear  *
*              structure                                               *
*     KEYS     Vector of keys. Only the elements declared in CHOPT are *
*              assumed to contain useful information.                  *
*     CHOPT    Character string with any of the following characters   *
*          K   read only the keys (no data is required)                *
*          S   expect multiple Key banks satisfying selection on a     *
*              number of keys                                          *
*          3   selects objects with start validity time > KEYS(3)      *
*          4   selects objects with start validity time < KEYS(4)      *
*          5   specific Program version number required                *
*          6   select objects with insertion time > KEYS(6)            *
*          7   select objects with insertion time < KEYS(7)            *
*          n   consider user key n (where 7 < n < 29 )                 *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =  2 : Illegal path name                               *
+SELF, IF=$P3CHILD.
*               =  5 : Error in DBCHLD in P3 communication             *
+SELF.
*               = 32 : No keys/data in this directory                  *
*                                                                      *
*     If IQUEST(1) =0, IQUEST(2) carries information on number of      *
*     data objects selected by DBGET                                   *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, P3DBL3, IF=$P3CHILD.
      PARAMETER       (NZ=0)
      DIMENSION       KEYS(9), LBK(9)
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, PATHY*80, PATHX*16
+CDE, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Initialize options
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)                                    GO TO 999
      IOPMDA = 0
      LBK(1) = 0
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Create (or complete) database skeleton in memory
*
      CALL DBNODE (PATH, LBNODB)
      IF (IQUEST(1).NE.0)                                    GO TO 999
*
*  ** Start from the end of the existing chain
*
      IF (LQ(KOFUDB+LBNODB-KLKYDB).NE.0) THEN
        LFIXDB = LZLAST (IDIVDB, LQ(KOFUDB+LBNODB-KLKYDB))
        IF (LFIXDB.EQ.0) THEN
          LFIXDB = LBNODB
          JBIAS  =-KLKYDB
        ELSE
          JBIAS  = 0
        ENDIF
      ELSE
        LFIXDB = LBNODB
        JBIAS  =-KLKYDB
      ENDIF
      NDK    = IQ(KOFUDB+LBNODB+MNDNWD)
      CALL UCOPY (IQ(KOFUDB+LBNODB+MNDIOF), IOKYDB, NWNODB)
*
* *** Set the current directory
*
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 2
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGET : Illegal '//
     +  'path name '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      CALL RZCDIR (PATH, 'R')
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKEYT
*
      IF (NKEYDK.LE.0) THEN
        IQUEST(1) = 32
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGET : No keys/'//
     +  'data for  '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
      NCHR   = LENOCC (PATH)
      NCHRT  = INDEX (PATH(3:NCHR), '/') - 1
      IF (NCHRT.LE.0) NCHRT = NCHR - 2
      PATHX  = PATH(3:NCHRT+2)
      LBFXDB = LTOPDB
    5 IF (LBFXDB.NE.0) THEN
        NCHRT  = IQ(KOFUDB+LBFXDB+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LBFXDB+MUPNAM), 4, TOPNDI, NCHRT)
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN
          LBFXDB = LQ(KOFUDB+LBFXDB)
          GO TO 5
        ENDIF
        KY7MDB = IQ(KOFUDB+LBFXDB+MUPKY7)
      ELSE
        KY7MDB = 0
      ENDIF
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
*
* *** Now create the key bank(s) and optionally the data bank
*
      NKB    = 0
+SELF, IF=$P3CHILD.
      IF (IOPSDA.NE.0.AND.IOPKDA.EQ.0) THEN
        IPASP3 = 1
        NDIRP3 = 0
        NBKDP3 = 0
        NBKYP3 = 0
        INDXP3 = 1
      ELSE
        IPASP3 = 0
      ENDIF
      NKBP3  = 0
+SELF.
      IF (IOPTP.EQ.0) THEN
        DO 20 JK = 1, NKEYDK
          IK     = NKEYDK + 1 - JK
          CALL DBKEYR (IK, NWKYDK, KEYVDK)
          IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB))
     +                                                       GO TO 20
          IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB))
     +                                                       GO TO 20
          IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))
     +                                                       GO TO 20
          IF (IOKYDA(MFLGDB).NE.0.AND.KEYVDK(MITMDB).LT.KEYS(MFLGDB))
     +                                                       GO TO 20
          IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))
     +                                                       GO TO 20
          IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)      GO TO 20
          IF (NWKYDK.GT.NSYSDK) THEN
            DO 10 I = NSYSDK+1, NWKYDK
              IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I))   GO TO 20
   10       CONTINUE
          ENDIF
          IF (JBIT(KEYVDK(MFLGDB),JIGNDB).NE.0)              GO TO 20
          CALL DBBOOK (IDIVDB, LBKYDB, LFIXDB, JBIAS, 'KYDB', NLKYDB,
     +                 NSKYDB, NDK, IOKYDB, NZ)
          IF (IQUEST(1).NE.0)                                GO TO 999
          LQ(KOFUDB+LBKYDB-KLNODB) = LBNODB
          LQ(KOFUDB+LBKYDB-KLUPDB) = LBFXDB
          IQ(KOFUDB+LBKYDB+NDK+MKYFRI) = 0
          IQ(KOFUDB+LBKYDB+NDK+MKYCRU) = IQ(KOFUDB+LBKYDB+NDK+MKYCRU) +1
          IQ(KOFUDB+LBKYDB+NDK+MKYCEV) = IQ(KOFUDB+LBKYDB+NDK+MKYCEV) +1
          NKB    = NKB + 1
          IF (NKB.EQ.1) LBK(1) = LBKYDB
          LFIXDB = LBKYDB
          JBIAS  = 0
          IF (IOPKDA.EQ.0) THEN
+SELF, IF=$P3CHILD.
            IF (IPASP3.EQ.1) THEN
              NKBP3  = NKBP3+1
              IF (NKBP3.GT.IQ(KOFUDB+LNK2P3-1))
     +          CALL MZPUSH (IXDBP3, LNK2P3, 100, 100, '....')
              LQ(KOFUDB+LNK2P3-NKBP3) = LBKYDB
              IQ(KOFUDB+LNK2P3+NKBP3) = NBKYP3
            ENDIF
+SELF.
            CALL VZERO (KEYVDK, NWKYDK)
            KEYVDK(MSERDB) = IK
            IOKYDA(MSERDB) = 1
            CALL DBKXIN (ITIME, IDIVDB, LAUXDL(9), LBKYDB, -KLDADB,
     +                   NWKEY, KEYVDK, IPREC)
            IOKYDA(MSERDB) = 0
            LAUXDL(9) = 0
            IQ(KOFUDB+LBKYDB+NDK+MKYPRE) = IPREC
            IQ(KOFUDB+LBKYDB+NDK+MKYRID) = IQ(KOFUDB+LBKYDB+NDK+MKYRID)
     +                                   + 1
          ENDIF
          CALL UCOPY (KEYVDK(1), IQ(KOFUDB+LBKYDB+1), NWKYDK)
          IQ(KOFUDB+LBKYDB+NWKYDK+1) = IQ(KOFUDB+LBKYDB+MBVRDB) + 1
          IF (IQUEST(1).NE.0)                                GO TO 999
          IF (IOPSDA.EQ.0) THEN
            IQUEST(2) = NKB
            GO TO 999
          ENDIF
   20   CONTINUE
*
      ELSE
        KST    = NWKYDK + 1
        NKEYS  = NKEYDK
        DO 40 JKK = 1, NKEYS
          IKK    = NKEYS + 1 - JKK
          KPNT   = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                     NKEYS*KST, KST)
          IF (KPNT.GT.0) THEN
            KPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB
          ELSE
            KPNT   = KOFSDB + LCDRDB + IKDRDB + (IKK - 1) * KST
          ENDIF
          IF (IOKYDA(MFLGDB).NE.0) THEN
            IF (JKK.GT.1.AND.KEY7L.LT.KEYS(MFLGDB))          GO TO 40
            KEY7L  = IQ(KPNT+MITMDB)
          ENDIF
          IF (IOKYDA(MBVRDB).NE.0.AND.IQ(KPNT+MEVRDB).LT.KEYS(MBVRDB))
     +                                                       GO TO 40
          IF (IOKYDA(MEVRDB).NE.0.AND.IQ(KPNT+MBVRDB).GT.KEYS(MEVRDB))
     +                                                       GO TO 40
          IF (IOKYDA(MITMDB).NE.0.AND.IQ(KPNT+MITMDB).GT.KEYS(MITMDB))
     +                                                       GO TO 40
          IF (KY7MDB.GT.0.AND.IQ(KPNT+MITMDB).GT.KY7MDB)     GO TO 40
*
          CALL DBPATH (PATHX, IKK)
          PATHY  = PATH(1:NCHR)//'/'//PATHX
          CALL RZCDIR (PATHY, ' ')
          IF (IQUEST(1).NE.0) THEN
            IQUEST(1) = 2
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGET : Ille'//
     +      'gal path name '//PATHY//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
+SELF, IF=$P3CHILD.
          NKBP3  = 0
+SELF.
          DO 30 JK = 1, NKEYDK
            IK     = NKEYDK + 1 - JK
            CALL DBKEYR (IK, NWKYDK, KEYVDK)
            IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB))
     +                                                       GO TO 30
            IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB))
     +                                                       GO TO 30
            IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))
     +                                                       GO TO 30
            IF (IOKYDA(MFLGDB).NE.0.AND.KEYVDK(MITMDB).LT.KEYS(MFLGDB))
     +                                                       GO TO 30
            IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))
     +                                                       GO TO 30
            IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)    GO TO 30
            IF (NWKYDK.GT.NSYSDK) THEN
              DO 25 I = NSYSDK+1, NWKYDK
                IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I)) GO TO 30
   25         CONTINUE
            ENDIF
            IF (JBIT(KEYVDK(MFLGDB),JIGNDB).NE.0)            GO TO 30
            CALL DBBOOK (IDIVDB, LBKYDB, LFIXDB, JBIAS, 'KYDB', NLKYDB,
     +                   NSKYDB, NDK, IOKYDB, NZ)
            IF (IQUEST(1).NE.0)                              GO TO 999
            LQ(KOFUDB+LBKYDB-KLNODB) = LBNODB
            LQ(KOFUDB+LBKYDB-KLUPDB) = LBFXDB
            IQ(KOFUDB+LBKYDB+NDK+MKYFRI) = 0
            IQ(KOFUDB+LBKYDB+NDK+MKYCRU) = IQ(KOFUDB+LBKYDB+NDK+MKYCRU)
     +                                   + 1
            IQ(KOFUDB+LBKYDB+NDK+MKYCEV) = IQ(KOFUDB+LBKYDB+NDK+MKYCEV)
     +                                   + 1
            NKB    = NKB + 1
            IF (NKB.EQ.1) LBK(1) = LBKYDB
            LFIXDB = LBKYDB
            JBIAS  = 0
            IF (IOPKDA.EQ.0) THEN
+SELF, IF=$P3CHILD.
              IF (IPASP3.EQ.1) THEN
                NKBP3  = NKBP3+1
                IF (NKBP3.GT.IQ(KOFUDB+LNK2P3-1))
     +            CALL MZPUSH (IXDBP3, LNK2P3, 100, 100, '....')
                LQ(KOFUDB+LNK2P3-NKBP3) = LBKYDB
                IQ(KOFUDB+LNK2P3+NKBP3) = NBKYP3
              ENDIF
+SELF.
              CALL VZERO (KEYVDK, NWKYDK)
              KEYVDK(MSERDB) = IK
              IOKYDA(MSERDB) = 1
              CALL DBKXIN (ITIME, IDIVDB, LAUXDL(9), LBKYDB, -KLDADB,
     +                     NWKEY, KEYVDK, IPREC)
              IOKYDA(MSERDB) = 0
              LAUXDL(9) = 0
              IQ(KOFUDB+LBKYDB+NDK+MKYPRE) = IPREC
              IQ(KOFUDB+LBKYDB+NDK+MKYRID) =IQ(KOFUDB+LBKYDB+NDK+MKYRID)
     +                                     + 1
            ENDIF
            CALL UCOPY (KEYVDK(1), IQ(KOFUDB+LBKYDB+1), NWKYDK)
            IQ(KOFUDB+LBKYDB+NWKYDK+1) = IQ(KOFUDB+LBKYDB+MBVRDB) + 1
            IOKYDA(MSERDB) = 0
            IF (IQUEST(1).NE.0)                              GO TO 999
            IF (IOPSDA.EQ.0) THEN
              IQUEST(2) = NKB
              GO TO 999
            ENDIF
   30     CONTINUE
          CALL RZCDIR (PATH, ' ')
          IF (IQUEST(1).NE.0) THEN
            IQUEST(1) = 2
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGET : Ille'//
     +      'gal path name '//PATH//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
   40   CONTINUE
*
      ENDIF
+SELF, IF=$P3CHILD.
*
      IF (IPASP3.NE.1)                                       GO TO 998
*
* *** Request the host to load the data objects from the RZ file
*
      IQ1 = IQUEST(1)
      IF (NBKYP3.EQ.0) THEN
        NKB = 0
        GO TO 998
      ENDIF
*
      RNDBP3 = 'DBRZIN  '
      CALL UCTOH  ('DBGET   ', IWDBP3, 4, 8)
      CALL DBCHLD
      IF (IQDBP3.NE.0) THEN
        IQ1    = 5
+SELF, IF=$P3CHILD, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGET : Error '//
     +  'code'',I6,'' from DBCHLD'')', IQDBP3, 1)
+SELF, IF=$P3CHILD.
        GO TO 998
      ENDIF
*
* *** Relocate the objects
*
      IPASP3 = 2
      LNK6P3 = LQ(KOFUDB+LNK3P3-1)
      LNK7P3 = LQ(KOFUDB+LNK3P3-2)
*
      DO 60 JK = 1, NKBP3
        IP3NEW = IQ(KOFUDB+LNK2P3+JK)
        IF (JK.GT.1) THEN
          IF (IP3NEW.EQ.IP3OLD)                              GO TO 60
          DO 50 IP3 = IP3OLD, IP3NEW-1
            LNK4P3 = LQ(KOFUDB+LNK6P3)
            LNK5P3 = LQ(KOFUDB+LNK7P3)
            CALL MZDROP (IXDBP3,LNK6P3,'BV..')
            CALL MZDROP (IXDBP3,LNK7P3,'BV..')
            LNK6P3 = LNK4P3
            LNK7P3 = LNK5P3
   50     CONTINUE
        ELSE
          LNK4P3 = LNK6P3
          LNK5P3 = LNK7P3
        ENDIF
        IP3OLD = IP3NEW
*
        LBKYDB = LQ(KOFUDB+LNK2P3-JK)
        NWKEY  = IQ(KOFUDB+LBKYDB-1)
        CALL UCOPY (IQ(KOFUDB+LBKYDB+1), KEYVDK, NWKEY)
        CALL DBKXIN (ITIME, IDIVDB, LAUXDL(9), LBKYDB, -KLDADB, NWKEY,
     +               KEYVDK, IPREC)
        IQ(KOFUDB+LBKYDB+NDK+MKYPRE) = IPREC
        LAUXDL(9) = 0
   60 CONTINUE
*
  998 CONTINUE
      IQUEST(1) = IQ1
*
+SELF.
      IQUEST(2) = NKB
  999 CONTINUE
+SELF, IF= $P3CHILD.
      IF (LNK3P3.NE.0) CALL MZDROP (IXDBP3, LNK3P3, '....')
      LNK3P3 = 0
      LNK4P3 = 0
      LNK5P3 = 0
      NBKYP3 = 0
      NDIRP3 = 0
      IPASP3 = 0
+SELF.
*                                                              END DBGET
      END
+DECK, DBGETS.
      SUBROUTINE DBGETS (PATHN, LBK, KEYS, CHOPT)
*     ===========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBGETS (PATHN, LBK*, KEYS, CHOPT)                       *
*                                                                      *
*   Prepares the database data structure in memory for any required    *
*   Pathname and serial number(s), unless already done.  Returns the   *
*   addresses in memory for the corresponding Key bank(s) and loads    *
*   the data part at link 1 of the Key bank(s).                        *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the path name               *
*     LBK(*)   Address(es) of Keys bank(s) KYDB. The data bank address *
*              can be obtained as LQ(LBK-1). For several selected      *
*              objects, the Keys banks appear in a linear structure    *
*     KEYS     Vector of keys. KEYS(1) and (2) should contain the      *
*              two limits on the serial number                         *
*     CHOPT    Character string with any of the following characters   *
*          K   read only the keys (no data is required)                *
*          5   specific Program version number required                *
*          6   select objects with insertion time > KEYS(6)            *
*          7   select objects with insertion time < KEYS(7)            *
*          n   consider user key n (where 7 < n < 29 )                 *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =  2 : Illegal path name                               *
*               = 32 : No keys/data in this directory                  *
*                                                                      *
*     If IQUEST(1) =0, IQUEST(2) carries information on number of      *
*     data objects selected by DBGETS                                  *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DLINKS.
      PARAMETER       (NZ=0)
      DIMENSION       LBK(9), KEYS(9)
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, PATHY*80, PATHX*16
+CDE, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Initialize options
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)                                    GO TO 999
      IOPMDA = 0
      IOPSDA = 0
      LBK(1) = 0
      IF (KEYS(MSERDB).LT.1) THEN
        KYMIN  = 1
      ELSE
        KYMIN  = KEYS(MSERDB)
      ENDIF
      IF (KEYS(MUPNDB).LT.KYMIN) THEN
        KYMAX  = KYMIN + 100000
      ELSE
        KYMAX  = KEYS(MUPNDB)
      ENDIF
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Create (or complete) database skeleton in memory
*
      CALL DBNODE (PATH, LBNODB)
      IF (IQUEST(1).NE.0)                                    GO TO 999
*
*  ** Start from the end of the existing chain
*
      IF (LQ(KOFUDB+LBNODB-KLKYDB).NE.0) THEN
        LFIXDB = LZLAST (IDIVDB, LQ(KOFUDB+LBNODB-KLKYDB))
        IF (LFIXDB.EQ.0) THEN
          LFIXDB = LBNODB
          JBIAS  =-KLKYDB
        ELSE
          JBIAS  = 0
        ENDIF
      ELSE
        LFIXDB = LBNODB
        JBIAS  =-KLKYDB
      ENDIF
      NDK    = IQ(KOFUDB+LBNODB+MNDNWD)
      CALL UCOPY (IQ(KOFUDB+LBNODB+MNDIOF), IOKYDB, NWNODB)
*
* *** Set the current directory
*
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 2
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGETS : Illegal'//
     +  ' path name '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      CALL RZCDIR (PATH, 'R')
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKEYT
*
      IF (NKEYDK.LE.0) THEN
        IQUEST(1) = 32
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGETS : No keys'//
     +  '/data for  '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
      NCHR   = LENOCC (PATH)
      NCHRT  = INDEX (PATH(3:NCHR), '/') - 1
      IF (NCHRT.LE.0) NCHRT = NCHR - 2
      PATHX  = PATH(3:NCHRT+2)
      LBFXDB = LTOPDB
    5 IF (LBFXDB.NE.0) THEN
        NCHRT  = IQ(KOFUDB+LBFXDB+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LBFXDB+MUPNAM), 4, TOPNDI, NCHRT)
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN
          LBFXDB = LQ(KOFUDB+LBFXDB)
          GO TO 5
        ENDIF
        KY7MDB = IQ(KOFUDB+LBFXDB+MUPKY7)
      ELSE
        KY7MDB = 0
      ENDIF
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
*
* *** Now create the key bank(s) and optionally the data bank
*
      NKB    = 0
      IF (IOPTP.EQ.0) THEN
        DO 20 JK = 1, NKEYDK
          IK     = NKEYDK + 1 - JK
          CALL DBKEYR (IK, NWKYDK, KEYVDK)
          IF (KEYVDK(MSERDB).LT.KYMIN.OR.KEYVDK(MSERDB).GT.KYMAX)
     +                                                       GO TO 20
          IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))
     +                                                       GO TO 20
          IF (IOKYDA(MFLGDB).NE.0.AND.KEYVDK(MITMDB).LT.KEYS(MFLGDB))
     +                                                       GO TO 20
          IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))
     +                                                       GO TO 20
          IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)      GO TO 20
          IF (NWKYDK.GT.NSYSDK) THEN
            DO 10 I = NSYSDK+1, NWKYDK
              IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I))   GO TO 20
   10       CONTINUE
          ENDIF
          IF (JBIT(KEYVDK(MFLGDB),JIGNDB).NE.0)              GO TO 20
          CALL DBBOOK (IDIVDB, LBKYDB, LFIXDB, JBIAS, 'KYDB', NLKYDB,
     +                 NSKYDB, NDK, IOKYDB, NZ)
          IF (IQUEST(1).NE.0)                                GO TO 999
          LQ(KOFUDB+LBKYDB-KLNODB) = LBNODB
          LQ(KOFUDB+LBKYDB-KLUPDB) = LBFXDB
          IQ(KOFUDB+LBKYDB+NDK+MKYFRI) = 0
          IQ(KOFUDB+LBKYDB+NDK+MKYCRU) = IQ(KOFUDB+LBKYDB+NDK+MKYCRU) +1
          IQ(KOFUDB+LBKYDB+NDK+MKYCEV) = IQ(KOFUDB+LBKYDB+NDK+MKYCEV) +1
          NKB    = NKB + 1
          IF (NKB.EQ.1) LBK(1) = LBKYDB
          LFIXDB = LBKYDB
          JBIAS  = 0
          IF (IOPKDA.EQ.0) THEN
            CALL VZERO (KEYVDK, NWKYDK)
            KEYVDK(MSERDB) = IK
            IOKYDA(MSERDB) = 1
            CALL DBKXIN (ITIME, IDIVDB, LAUXDL(9), LBKYDB, -KLDADB,
     +                   NWKEY, KEYVDK, IPREC)
            IOKYDA(MSERDB) = 0
            LAUXDL(9) = 0
            IQ(KOFUDB+LBKYDB+NDK+MKYPRE) = IPREC
            IQ(KOFUDB+LBKYDB+NDK+MKYRID) = IQ(KOFUDB+LBKYDB+NDK+MKYRID)
     +                                   + 1
          ENDIF
          CALL UCOPY (KEYVDK(1), IQ(KOFUDB+LBKYDB+1), NWKYDK)
          IQ(KOFUDB+LBKYDB+NWKYDK+1) = IQ(KOFUDB+LBKYDB+MBVRDB) + 1
          IF (IQUEST(1).NE.0)                                GO TO 999
   20   CONTINUE
*
      ELSE
        KST    = NWKYDK + 1
        NKEYS  = NKEYDK
        KEY5L  = -1
        DO 40 JKK = 1, NKEYS
          IKK    = NKEYS + 1 - JKK
          KPNT   = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                     NKEYS*KST, KST)
          IF (KPNT.GT.0) THEN
            KPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB
          ELSE
            KPNT   = KOFSDB + LCDRDB + IKDRDB + (IKK - 1) * KST
          ENDIF
          IF (IOKYDA(MFLGDB).NE.0) THEN
            IF (JKK.GT.1.AND.KEY7L.LT.KEYS(MFLGDB))          GO TO 40
            KEY7L  = IQ(KPNT+MITMDB)
          ENDIF
          IF (IQ(KPNT+MOBJDB).GT.KYMAX)                      GO TO 40
          IF (KEY5L.GE.0.AND.KEY5L.LT.KYMIN)                 GO TO 40
          KEY5L  = IQ(KPNT+MOBJDB)
          IF (IOKYDA(MITMDB).NE.0.AND.IQ(KPNT+MITMDB).GT.KEYS(MITMDB))
     +                                                       GO TO 40
          IF (KY7MDB.GT.0.AND.IQ(KPNT+MITMDB).GT.KY7MDB)     GO TO 40
*
          CALL DBPATH (PATHX, IKK)
          PATHY  = PATH(1:NCHR)//'/'//PATHX
          CALL RZCDIR (PATHY, ' ')
          IF (IQUEST(1).NE.0) THEN
            IQUEST(1) = 2
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGETS : Ill'//
     +      'egal path name '//PATHY//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          DO 30 JK = 1, NKEYDK
            IK     = NKEYDK + 1 - JK
            CALL DBKEYR (IK, NWKYDK, KEYVDK)
            IF (KEYVDK(MSERDB).LT.KYMIN.OR.KEYVDK(MSERDB).GT.KYMAX)
     +                                                       GO TO 30
            IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))
     +                                                       GO TO 30
            IF (IOKYDA(MFLGDB).NE.0.AND.KEYVDK(MITMDB).LT.KEYS(MFLGDB))
     +                                                       GO TO 30
            IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))
     +                                                       GO TO 30
            IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)    GO TO 30
            IF (NWKYDK.GT.NSYSDK) THEN
              DO 25 I = NSYSDK+1, NWKYDK
                IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I)) GO TO 30
   25         CONTINUE
            ENDIF
            IF (JBIT(KEYVDK(MFLGDB),JIGNDB).NE.0)            GO TO 30
            CALL DBBOOK (IDIVDB, LBKYDB, LFIXDB, JBIAS, 'KYDB', NLKYDB,
     +                   NSKYDB, NDK, IOKYDB, NZ)
            IF (IQUEST(1).NE.0)                              GO TO 999
            LQ(KOFUDB+LBKYDB-KLNODB) = LBNODB
            LQ(KOFUDB+LBKYDB-KLUPDB) = LBFXDB
            IQ(KOFUDB+LBKYDB+NDK+MKYFRI) = 0
            IQ(KOFUDB+LBKYDB+NDK+MKYCRU) = IQ(KOFUDB+LBKYDB+NDK+MKYCRU)
     +                                   + 1
            IQ(KOFUDB+LBKYDB+NDK+MKYCEV) = IQ(KOFUDB+LBKYDB+NDK+MKYCEV)
     +                                   + 1
            NKB    = NKB + 1
            IF (NKB.EQ.1) LBK(1) = LBKYDB
            LFIXDB = LBKYDB
            JBIAS  = 0
            IF (IOPKDA.EQ.0) THEN
              CALL VZERO (KEYVDK, NWKYDK)
              KEYVDK(MSERDB) = IK
              IOKYDA(MSERDB) = 1
              CALL DBKXIN (ITIME, IDIVDB, LAUXDL(9), LBKYDB, -KLDADB,
     +                     NWKEY, KEYVDK, IPREC)
              IOKYDA(MSERDB) = 0
              LAUXDL(9) = 0
              IQ(KOFUDB+LBKYDB+NDK+MKYPRE) = IPREC
              IQ(KOFUDB+LBKYDB+NDK+MKYRID) =IQ(KOFUDB+LBKYDB+NDK+MKYRID)
     +                                     + 1
            ENDIF
            CALL UCOPY (KEYVDK(1), IQ(KOFUDB+LBKYDB+1), NWKYDK)
            IQ(KOFUDB+LBKYDB+NWKYDK+1) = IQ(KOFUDB+LBKYDB+MBVRDB) + 1
            IOKYDA(MSERDB) = 0
            IF (IQUEST(1).NE.0)                              GO TO 999
   30     CONTINUE
          CALL RZCDIR (PATH, ' ')
          IF (IQUEST(1).NE.0) THEN
            IQUEST(1) = 2
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGETS : Ill'//
     +      'egal path name '//PATH//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
   40   CONTINUE
*
      ENDIF
      IQUEST(2) = NKB
*                                                             END DBGETS
  999 END
+DECK, DBILDF, IF=-$P3CHILD.
      SUBROUTINE DBILDF (LUNI, CHOPT)
*     ===============================
*
************************************************************************
*                                                                      *
*        SUBR. DBILDF (LUNI, CHOPT)                                    *
*                                                                      *
*   Initializes the List of Directories to be always updated from the  *
*   journal file (ignore the check of the key 1).                      *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUNI     Logical unit number from which the list is read off     *
*     CHOPT    Character string with any of the following characters   *
*          A   Add to the previous information                         *
*          I   Ignore all previous information (also current file)     *
*     Default  Overwrite previous information with the current list    *
*                                                                      *
*   Called by user,   DBACTI                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =232 : Illegal logical unit number                     *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DINITL.
      PARAMETER       (NWDS=50)
      CHARACTER       CHOPT*(*), PATH*80, PATHN*80
*
*     ------------------------------------------------------------------
*
* *** Decode the character option
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)     GO TO 999
*
* *** Find the address of the bank containing the list of directory
*
      LREFDB(1) = LBAFDB
      IF (LREFDB(1).EQ.0) THEN
        JBIAS  = 1
        ND     = NWDS * (MXLWDB + 1)
        CALL DBBOOK (IDIVDB, LBAFDB, LBAFDB, JBIAS, 'FDDB', 0, 0, ND,
     +               IOFDDB, -1)
        IF (IQUEST(1).NE.0)   GO TO 999
        IQ(KOFUDB+LBAFDB-5) = 0
        LREFDB(1) = LBAFDB
      ENDIF
*
* *** Reset the counter if not needed
*
      IF (IOPIDA.NE.0.OR.IOPADA.EQ.0) THEN
        IQ(KOFUDB+LREFDB(1)-5) = 0
        IF (IOPIDA.NE.0)      GO TO 999
      ENDIF
*
* *** Check input file number
*
      IF (LUNI.LE.0) THEN
        IQUEST(1) = 232
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBILDF : Illegal'//
     +  ' logical unit number'',I12)', LUNI, 1)
+SELF.
        GO TO 999
      ENDIF
*
* *** Now read in the file
*
      NWMX   = IQ(KOFUDB+LREFDB(1)-1) / (MXLWDB + 1)
      NCNT   = 0
   10 READ (LUNI, 1000, ERR=20, END=20) PATH
      CALL DBSBLC (PATH, PATHN, NCHR)
      IF (NCHR.LE.0)          GO TO 10
      CALL CLTOU (PATHN)
      NCUR   = IQ(KOFUDB+LREFDB(1)-5) + 1
      NCNT   = NCNT + 1
      IF (NCUR.GT.NWMX) THEN
        CALL ZSHUNT (IDIVDB, LREFDB(1), LREFDB(3), 2, 0)
        ND     = IQ(KOFUDB+LREFDB(3)-1) + NWDS * (MXLWDB + 1)
        JBIAS  = 1
        CALL DBBOOK (IDIVDB, LBAFDB, LBAFDB, JBIAS, 'FDDB', 0, 0, ND,
     +               IOFDDB, -1)
        IF (IQUEST(1).NE.0) THEN
          IERR   = IQUEST(1)
          CALL MZDROP (IDIVDB, LREFDB(3), ' ')
          IQUEST(1) = IERR
          GO TO 999
        ENDIF
        CALL UCOPY (IQ(KOFUDB+LREFDB(3)+1), IQ(KOFUDB+LBAFDB+1),
     +              IQ(KOFUDB+LREFDB(3)-1))
        LREFDB(1) = LBAFDB
        CALL MZDROP (IDIVDB, LREFDB(3), ' ')
        IQUEST(1) = 0
        NWMX   = NWMX + NWDS
      ENDIF
      IQ(KOFUDB+LREFDB(1)-5) = NCUR
      IPNT   = KOFUDB + LREFDB(1) + (NCUR - 1) * (MXLWDB + 1) + 1
      IQ(IPNT) = NCHR
      CALL UCTOH (PATHN, IQ(IPNT+1), 4, 80)
      GO TO 10
*
   20 IQUEST(11)= NCNT
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.3) THEN
        NCUR   = IQ(KOFUDB+LREFDB(1)-5)
        CALL DBPRNT (LPRTDB, '(/,'' DBILDF : '',I8,'' directory names'//
     +       ' stored for forced updating'')', NCUR, 1)
        DO 30 I = 1, NCUR
          IPNT   = KOFUDB + LREFDB(1) + (I - 1) * (MXLWDB + 1) + 1
          CALL UHTOC (IQ(IPNT+1), 4, PATH, 80)
          CALL DBPRNT (LPRTDB, '(10X,''Directory '',I5,'' '//PATH//''')'
     +,        I, 1)
   30   CONTINUE
      ENDIF
+SELF.
*
 1000 FORMAT (A80)
*                                                             END DBILDF
  999 END
+DECK, DBILDU, IF=-$P3CHILD.
      SUBROUTINE DBILDU (LUNI, TOPNM, CHOPT)
*     ======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBILDU (LUNI, TOPNM, CHOPT)                             *
*                                                                      *
*   Initializes the List of Directories to be Updated from the         *
*   journal file.                                                      *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUNI     Logical unit number from which the list is read off     *
*     TOPNM    Name of the Top Directory                               *
*     CHOPT    Character string with any of the following characters   *
*          A   Add to the previous information                         *
*          I   Ignore all previous information (also current file)     *
*     Default  Overwrite previous information with the current list    *
*                                                                      *
*   Called by user,   DBACTI                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =231 : Illegal top directory name                      *
*               =232 : Illegal logical unit number                     *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DINITL.
      PARAMETER       (NWDS=50)
      CHARACTER       CHOPT*(*), TOPNM*(*), TOPN*16, PATH*80, PATHN*80
*
*     ------------------------------------------------------------------
*
* *** Decode the character option and analyse the top directory name
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)     GO TO 999
      CALL DBSBLC (TOPNM, TOPN, NCHT)
      IF (NCHT.LE.0) THEN
        IQUEST(1) = 231
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBILDU : Illegal'//
     +  ' top directory name'')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Find the address of the bank containing the list of directory
*  ** for the given topdirectory
*
      LREFDB(1) = 0
      LREFDB(2) = 0
      LTOP   = LTOPDB
   10 IF (LTOP.GT.0) THEN
        NCHR   = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHR)
        IF (TOPNDI(1:NCHR).NE.TOPN(1:NCHT)) THEN
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 10
        ELSE
          LREFDB(1) = LQ(KOFUDB+LTOP-KLFZDB)
          LREFDB(2) = LTOP
        ENDIF
      ENDIF
*
      IF (LREFDB(1).EQ.0) THEN
        LREFDB(1) = LBADDB
   20   IF (LREFDB(1).GT.0) THEN
          CALL UHTOC (IQ(KOFUDB+LREFDB(1)+MFZTOP), 4, TOPNDI, 16)
          IF (TOPNDI.NE.TOPN) THEN
            LREFDB(1) = LQ(KOFUDB+LREFDB(1))
            GO TO 20
          ENDIF
        ELSE
          JBIAS  = 1
          ND     = NWDS * (MXLWDB + 1) + MFZDIR - 1
          CALL DBBOOK (IDIVDB, LBADDB, LBADDB, JBIAS, 'FZDB', 0, 0, ND,
     +                 IOFZDB, -1)
          IF (IQUEST(1).NE.0) GO TO 999
          IQ(KOFUDB+LBADDB-5) = 0
          LREFDB(1) = LBADDB
          IF (LREFDB(2).GT.0) LQ(KOFUDB+LREFDB(2)-KLFZDB) = LBADDB
          CALL UCTOH (TOPN, IQ(KOFUDB+LBADDB+MFZTOP), 4, 16)
        ENDIF
      ENDIF
*
* *** Reset the counter if not needed
*
      IF (IOPIDA.NE.0.OR.IOPADA.EQ.0) THEN
        IQ(KOFUDB+LREFDB(1)-5) = 0
        IF (IOPIDA.NE.0)      GO TO 999
      ENDIF
*
* *** Check input file number
*
      IF (LUNI.LE.0) THEN
        IQUEST(1) = 232
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBILDU : Illegal'//
     +  ' logical unit number'',I12)', LUNI, 1)
+SELF.
        GO TO 999
      ENDIF
*
* *** Now read in the file
*
      NWMX   = (IQ(KOFUDB+LREFDB(1)-1) - MFZDIR + 1) / (MXLWDB + 1)
      NCNT   = 0
   25 READ (LUNI, 1000, ERR=30, END=30) PATH
      CALL DBSBLC (PATH, PATHN, NCHR)
      IF (NCHR.LE.0)          GO TO 25
      CALL CLTOU (PATHN)
      NCUR   = IQ(KOFUDB+LREFDB(1)-5) + 1
      NCNT   = NCNT + 1
      IF (NCUR.GT.NWMX) THEN
        CALL ZSHUNT (IDIVDB, LREFDB(1), LREFDB(3), 2, 0)
        ND     = IQ(KOFUDB+LREFDB(3)-1) + NWDS * (MXLWDB + 1)
        JBIAS  = 1
        CALL DBBOOK (IDIVDB, LBADDB, LBADDB, JBIAS, 'FZDB', 0, 0, ND,
     +               IOFZDB, -1)
        IF (IQUEST(1).NE.0) THEN
          IERR   = IQUEST(1)
          CALL MZDROP (IDIVDB, LREFDB(3), ' ')
          IF (LREFDB(2).GT.0) LQ(KOFUDB+LREFDB(2)-KLFZDB) = 0
          IQUEST(1) = IERR
          GO TO 999
        ENDIF
        CALL UCOPY (IQ(KOFUDB+LREFDB(3)+1), IQ(KOFUDB+LBADDB+1),
     +              IQ(KOFUDB+LREFDB(3)-1))
        LREFDB(1) = LBADDB
        IF (LREFDB(2).GT.0) LQ(KOFUDB+LREFDB(2)-KLFZDB) = LBADDB
        CALL MZDROP (IDIVDB, LREFDB(3), ' ')
        IQUEST(1) = 0
        NWMX   = NWMX + NWDS
      ENDIF
      IQ(KOFUDB+LREFDB(1)-5) = NCUR
      IPNT   = KOFUDB + LREFDB(1) + MFZDIR + (NCUR - 1) * (MXLWDB + 1)
      IQ(IPNT) = NCHR
      CALL UCTOH (PATHN, IQ(IPNT+1), 4, 80)
      GO TO 25
*
   30 IQUEST(11)= NCNT
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.3) THEN
        NCUR   = IQ(KOFUDB+LREFDB(1)-5)
        CALL UHTOC (IQ(KOFUDB+LREFDB(1)+MFZTOP), 4, TOPNDI, 16)
        CALL DBPRNT (LPRTDB, '(/,'' DBILDU : '',I8,'' directory names'//
     +       ' stored for top directory '//TOPNDI//''')', NCUR, 1)
        DO 40 I = 1, NCUR
          IPNT   = KOFUDB + LREFDB(1) + MFZDIR + (I - 1) * (MXLWDB + 1)
          CALL UHTOC (IQ(IPNT+1), 4, PATH, 80)
          CALL DBPRNT (LPRTDB, '(10X,''Directory '',I5,'' '//PATH//''')'
     +,        I, 1)
   40   CONTINUE
      ENDIF
+SELF.
*
 1000 FORMAT (A80)
*                                                             END DBILDU
  999 END
+DECK, DBIN.
      SUBROUTINE DBIN (PATHN, ITIME, IUDIV, LSUP, IPRVS, NWKEY, KEY,
     +                 IPREC, CHOPT)
*     ==============================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBIN (PATHN, ITIME, IUDIV, LSUP*, IPRVS, NWKEY*, KEY*,  *
*                    IPREC*, CHOPT)                                    *
*                                                                      *
*   Fetches from disk to memory data valid for a given time            *
*                                                                      *
*   Restrictions : No selection on user keys can be made               *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     ITIME    Time for which data are required to be valid            *
*     IUDIV    Division index where bank is expected to be returned    *
*     LSUP(*)  Address of bank in memory where data have been stored   *
*     IPRVS    Version number of program used when data were created   *
*              (if = 0, accept any)                                    *
*     NWKEY(*) Length of the key vector                                *
*     KEY(*)   Key vector elements                                     *
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *
*              IPREC significant digits right to the decimal points; if*
*              IPREC < 0, data are stored with IPREC insignificant     *
*              digits left to the decimal point.)                      *
*     CHOPT    Character string with any of the following characters   *
*          N   If data do not exist for ITIME, take the nearest data   *
*              object in time                                          *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 31 : Illegal path name                               *
*               = 32 : No keys/data in this directory                  *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DINITL.
+CDE, DKKEYS.
      DIMENSION       KEY(9), LSUP(9)
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, PATHX*16
*
*     ------------------------------------------------------------------
*
* *** Decode the character option
* *** Inhibit 'R' option (RZ mode)
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0) GO TO 999
      IOPRDA = 0
      IF (IPRVS.NE.0) IOKYDA(MPVSDB) = 1
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Set the current directory
*
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0)  THEN
        IQUEST(1) = 31
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBIN : Illegal '//
     +  'Path Name '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKEYT
*
* *** Check the number of keys
*
      IF (NKEYDK.EQ.0)  THEN
        IQUEST(1) = 32
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBIN : No key or'//
     +  ' data for Path Name '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
      CALL RZCDIR (PATH, 'R')
      NCHAR  = INDEX (PATH, ' ') - 1
      IF (NCHAR.LT.0) NCHAR = MAXLDB
      NCHRT  = INDEX (PATH(3:NCHAR), '/') - 1
      IF (NCHRT.LE.0) NCHRT = NCHAR - 2
      PATHX  = PATH(3:NCHRT+2)
      LTOP   = LTOPDB
   10 IF (LTOP.NE.0) THEN
        NCHRT  = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHRT)
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 10
        ENDIF
        KY7MDB = IQ(KOFUDB+LTOP+MUPKY7)
      ELSE
        KY7MDB = 0
      ENDIF
*
* *** Set up the key vector to be searched
*
      DO 20 I = 1, NWKYDK
        IF (IOKYDA(I).NE.0) THEN
          KEYVDK(I) = KEY(I)
        ELSE
          KEYVDK(I) = 0
        ENDIF
   20 CONTINUE
      KEYVDK(MPVSDB) = IPRVS
      JBIAS  = 2
*
* *** Read in the data
*
      CALL DBKXIN (ITIME, IUDIV, LSUP(1), LSUP(1), JBIAS, NWKEY, KEYVDK,
     +             IPREC)
      IF (IQUEST(1).NE.0) GO TO 999
      CALL UCOPY (KEYVDK, KEY, NWKEY)
*                                                               END DBIN
  999 END
+DECK, DBINCT.
      SUBROUTINE DBINCT (IDTMI, ISADD, IDTMO)
*     =======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBINCT (IDTMI, ISADD, IDTMO*)                           *
*                                                                      *
*   Converts packed date and time (ala DBPKTS) to a similar packed     *
*   number after adding a fixed time in seconds                        *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDTMI    Packed date-time (ala DBPKTS) on input                  *
*     ISADD    Incremental time to IDTMI in seconds                    *
*     IDTMO    Packed date-time (ala DBPKTS) on output                 *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
************************************************************************
*
+CDE, DTMPAK.
*     ------------------------------------------------------------------
*
* *** Get the real Year/Month/Date Hour/Minute/Second
*
      III    = IDTMI
      ISEC   = MOD (III, MXSEC)
      III    = (III-ISEC)/MXSEC
      IMIN   = MOD (III, MXMIN)
      III    = (III-IMIN)/MXMIN
      IHOU   = MOD (III, MXHOU)
      III    = (III-IHOU)/MXHOU
      IDAY   = MOD (III, MXDAY)
      III    = (III-IDAY)/MXDAY
      IMON   = MOD (III, MXMON)
      IYEA   = (III-IMON)/MXMON
*
* *** Add the second to real seconds in the day
*
      ISECS  = ISEC  + 60*(IMIN + 60*IHOU)
      ISECS  = ISECS + ISADD
      IF (ISECS.GE.0.AND.ISECS.LT.86400) THEN
        ISEC   = MOD (ISECS, 60)
        ISECS  = (ISECS-ISEC)/60
        IMIN   = MOD (ISECS, 60)
        IHOU   = (ISECS-IMIN)/60
      ELSE
        IF (ISECS.LT.0) THEN
          III    = -ISECS
          IDADD  = -(III/86400 + 1)
        ELSE
          IDADD  = ISECS/86400
        ENDIF
        ISECS  = ISECS - IDADD*86400
        ISEC   = MOD (ISECS, 60)
        ISECS  = (ISECS-ISEC)/60
        IMIN   = MOD (ISECS, 60)
        IHOU   = (ISECS-IMIN)/60
        IF (IYEA.LT.1) THEN
          IADD   = 0
          ITYP   = 2
        ELSE IF (IYEA.GT.20) THEN
          IADD   = IDAYY(20)
          ITYP   = 2
        ELSE
          IADD   = IDAYY(IYEA)
          ITYP   = MOD (IYEA, 4)
          IF (ITYP.EQ.0) THEN
            ITYP = 2
          ELSE
            ITYP = 1
          ENDIF
        ENDIF
        IDAYS  = IDAY + IADD + IDAYM(IMON,ITYP) + IDADD
        DO 10 I = 1, 20
          IF (IDAYS.LE.IDAYY(I)) THEN
            IYEA   = I - 1
            IF (IYEA.GT.0) IDAYS  = IDAYS - IDAYY(IYEA)
            GO TO 15
          ENDIF
   10   CONTINUE
        IYEA   = 20
        IDAYS  = 366
   15   IF (MOD(IYEA,4).EQ.0) THEN
          ITYP   = 2
        ELSE
          ITYP   = 1
        ENDIF
        DO 20 I = 2, 12
          IF (IDAYS.LE.IDAYM(I,ITYP)) THEN
            IMON   = I - 1
            GO TO 25
          ENDIF
   20   CONTINUE
        IMON   = 12
   25   IDAY   = IDAYS - IDAYM(IMON,ITYP)
      ENDIF
*
* *** Now reconvert into a packed time
*
      IDTMO  = ISEC
      MAXX   = MXSEC
      IDTMO  = IDTMO + MAXX*IMIN
      MAXX   = MAXX*MXMIN
      IDTMO  = IDTMO + MAXX*IHOU
      MAXX   = MAXX*MXHOU
      IDTMO  = IDTMO + MAXX*IDAY
      MAXX   = MAXX*MXDAY
      IDTMO  = IDTMO + MAXX*IMON
      MAXX   = MAXX*MXMON
      IDTMO  = IDTMO + MAXX*IYEA
*                                                             END DBINCT
      END
+DECK, DBINIT.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBINIT (IDIV, LUNRZ, TOPNM, LTOP, NRECS, CHOPT)
*     ==========================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBINIT (IDIV, LUNRZ, TOPNM, LTOP*, NRECS, CHOPT)        *
*                                                                      *
*   Initializes of the Data Base Package (for each file)               *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDIV     User Division                                           *
*     LUNRZ    RZ file unit                                            *
*     TOPNM    Name of the Top Directory                               *
*     LTOP     Address of the top directory                            *
*     NRECS    Number of records for primary allocation (for RZMAKE)   *
*              If less than or equal to 0 use existing RZ file (RZFILE)*
*     CHOPT    Character Option : Same as in RZFILE / RZMAKE           *
*          Z   Reinitialize the random access file (use RZMAKE)        *
*              (also NRECS > 0 is required)                            *
*                                                                      *
*   Called by user,   DBACTI                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = -1 : Invalid top directory name                      *
*               = -2 : The file is already open with correct LUNRZ and *
*                      TOPNM                                           *
*               = -3 : The file is already open with wrong LUNRZ or    *
*                      TOPNM                                           *
*               = -4 : Already a file is opened with the same unique   *
*                      identifier as requested for this TOPNM          *
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
*               = -5 : Invalid process name in Online context          *
*               = -6 : Error in IC_BOOK for booking the CACHE          *
*               = -7 : Error in CC_SETUP for reserving the CLUSCOM     *
+SELF, IF=APOLLO,HPUX,IBMRT, IF=$SERVER, IF=-$P3CHILD.
*               = -8 : Cannot open journal file in server context      *
+SELF, IF=$P3CHILD.
*               = -9 : Unable to open FZ communication channel         *
*               = -10: Host unable to open RZ file                     *
+SELF.
*                                                                      *
************************************************************************
*
+CDE, ZUNIT.
*
+CDE, DBSTOR.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, P3DBL3, IF=$P3CHILD.
+SELF, IF=VAX, IF=$SERVER.
+CDE, DBSRVR.
+CDE, DRCCOM.
*           Cache stuff
      INTEGER         ICACHE(4)
      BYTE            BCACHE(16)
      EQUIVALENCE     (BCACHE, ICACHE)
      CHARACTER*2     DB_CURRENT_SNAME
      CHARACTER*4     DB_CURRENT_LNAME
      CHARACTER*9     DB_CLUSCOM_NAME
+SELF.
      PARAMETER       (NOPRZ=7)
      CHARACTER       CHOPT*(*), TOPNM*(*)
      CHARACTER       CHOP*8, COPRZ(NOPRZ)*1, TOP*16, TOP1*16, PATH*18
      INTEGER         KEYXT(4), IBUF(2), IOPRZ(NOPRZ), IACRZ(NOPRZ)
      DIMENSION       LTOP(9)
      SAVE            INIT, NTOPM, IUPDB, KEYXT, IBUF, NBUF, NKYXT
      SAVE            IVSTR, IVEND, IDTYP, IPRVS, COPRZ, IACRZ
*
      DATA            KEYXT /0, 0, 0, 0/, IBUF /0, 0/, NKYXT /4/
      DATA            IVSTR /0/, IVEND /999999999/, IDTYP /2/, IPRVS /1/
      DATA            INIT /0/, NBUF /2/
      DATA            COPRZ /'1', 'D', 'L', 'M', 'S', 'U', 'X'/
      DATA            IACRZ /  0,   0,   1,   0,   0,   0,   0/
*
*     ------------------------------------------------------------------
*
C ACP_data_retrieval_start
      LTOP(1)= 0
      NTOP   = IQUEST(1)
      IOPTO  = 0
      CALL UOPTC (CHOPT, 'Z', IOPTZ)
      IF (NRECS.GT.0.AND.IOPTZ.NE.0) THEN
        NREC  = NRECS
        IOPTN = 1
      ELSE
        IOPTN = 0
        NREC  = 0
      ENDIF
      DO 5 I = 1, NOPRZ
        IF (I.EQ.1) THEN
          CHOP   = COPRZ(I)
        ELSE
          CHOP   = CHOP(1:I-1)//COPRZ(I)
        ENDIF
    5 CONTINUE
      CALL UOPTC (CHOPT, CHOP(1:NOPRZ), IOPRZ)
      IF (IOPRZ(1).NE.0.OR.IOPRZ(6).NE.0) IOPTO = 1
*
* *** Remove imbedded blanks from the top directory name
*
      CALL DBSBLC (TOPNM, TOPNDI, MAX)
      IF (MAX.EQ.0) THEN
        IQUEST(1) = -1
+SELF, IF=$DEBUG.
        TOPNDI = TOPNM
        CALL DBPRNT (IQPRNT, '(/,'' DBINIT : Illegal Top Directory '//
     +       'Name '//TOPNDI//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** First pass initialization
*
      IF (INIT.EQ.0) THEN
*
*  **   DB System initialization
*
        NTOPM  = 0
        CALL DBFRST (IDIV)
        INIT   = 1
      ENDIF
*
      IOPP   = 0
      CALL UOPTC (CHOPT, 'S', IOPS)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
* *** Check if it is Server environment
*
      CALL UOPTC (CHOPT, 'O', IOPO)
      CALL UOPTC (CHOPT, 'P', IOPP)
+SELF, IF=$P3CHILD.
      IF (IOPTO.NE.0.OR.IOPTN.NE.0) IOPP = 1
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
      IF (INSRDB.EQ.0) THEN
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,$P3CHILD, IF=$SERVER.
*
* ***   Server environment, Public mode
*
        IF (IOPP.NE.0) THEN
+SELF, IF=$P3CHILD.
*
*  **     Open the FZ Communication Channel
*
          CALL APOPCH (LODBP3, 1, IRET)
          IF (IRET.NE.0) THEN
            IQUEST(1) = -9
            IQUEST(11)= IRET
+SELF, IF=$P3CHILD, IF=$DEBUG.
            CALL DBPRNT (LPRTDB, '(/,'' DBINIT : Cannot open FZ '//
     +           'channel'')', IRET, 0)
+SELF, IF=$P3CHILD.
          ENDIF
          INSRDB = 1
        ENDIF
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
*
*  **     Open the journal file to DBSERVER
*
+SELF, IF=APOLLO,HPUX,IBMRT, IF=$SERVER, IF=-$P3CHILD.
          LUF    = LUFMDB
+SELF, IF=IBM, IF=$SERVER, IF=-$P3CHILD.
          LUF    = 7
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
          CALL DBFZLO (LUF, IFND)
          IF (IFND.EQ.0) THEN
+SELF, IF=APOLLO,HPUX,IBMRT, IF=$SERVER, IF=-$P3CHILD.
            CALL DBFOPN (LUF, IRC)
            IF (IRC.NE.0) THEN
              IQUEST(1) = -8
              IQUEST(11)= IRC
+SELF, IF=APOLLO,HPUX,IBMRT, IF=$SERVER, IF=$DEBUG, IF=-$P3CHILD.
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBINIT : '//
     +        'Error '',I10,'' in DBFOPN'')', IQUEST(11), 1)
+SELF, IF=APOLLO,HPUX,IBMRT, IF=$SERVER, IF=-$P3CHILD.
              GO TO 999
            ENDIF
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
            CALL FZFILE (LUF, 0, 'AOQ')
          ENDIF
          INSRDB = 1
        ENDIF
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
*
* ***   Server environment, Owner mode
*
        IF (IOPO.NE.0) THEN
*
*  **     Open a flat memory for communication via FZ
*
          CALL FZFILE (LUFMDB, 0, 'MNUIQ')
          CALL FZMEMO (LUFMDB, QVECDR, NMAXDR)
          INSRDB = 1
*
* ***   Server environment, Public mode
*
        ELSE IF (IOPP.NE.0) THEN
*
*  **     Open a flat memory for communication via FZ
*
          CALL FZFILE (LUFMDB, 0, 'MNUOQ')
          CALL FZMEMO (LUFMDB, QVECDR, NMAXDR)
*
*  **     Book cache as  a client
*
          CALL DB_CHK_CLIENT (DB_CURRENT_SNAME, DB_CURRENT_LNAME,
     +                        DB_CLUSCOM_NAME, IERR)
          IF (IERR.NE.0) THEN
            IQUEST(1) = -5
+SELF, IF=VAX, IF=$SERVER, IF=$DEBUG, IF=-$P3CHILD.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBINIT : Ill'//
     +      'egal Cluscom name '//DB_CLUSCOM_NAME//''')', IARGDB, 0)
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
            GO TO 999
          ENDIF
*
*  **     Directory name for MAPCOM files is defined through
*  **     db long name. Example 'MUCH$DBMCOM:
*
          DIREDB = DB_CURRENT_LNAME//'$DBMCOM:'
*
*  **     Cache name is the same for the server and its clients
*  **     Example H__DB_CACHE (always 11 characters)
*
          CACHDB = DB_CURRENT_SNAME(1:1)//'__DB_CACHE'
          CALL IC_BOOK (CACHDB, ICACHE, 'C', IERR)
          IF (IERR.NE.0) THEN
            IQUEST(1) = -6
            IQUEST(11)= IERR
+SELF, IF=VAX, IF=$SERVER, IF=$DEBUG, IF=-$P3CHILD.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBINIT : Err'//
     +      'or '',I10,'' in IC_BOOK'')', IQUEST(11), 1)
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
            GO TO 999
          ENDIF
*
*  **     Define the filename from client process name
*  **     Example: HCAL$DBMCOM:H__DBC_UR.DBMCOM
*
          FILEDB(1:12)  = DIREDB
          FILEDB(13:21) = DB_CLUSCOM_NAME
          FILEDB(22:)   = '.DBMCOM'
*         For time being map the whole common to disk
          CALL CC_SETUP ('DRCCOM', FILEDB, IFRSDR, ILSTDR, 'M', IERR)
          IF (IERR.NE.0) THEN
            IQUEST(1) = -7
            IQUEST(11)= IERR
+SELF, IF=VAX, IF=$SERVER, IF=$DEBUG, IF=-$P3CHILD.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBINIT : Err'//
     +      'or '',I10,'' in CC_SETUP'')', IQUEST(11), 1)
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
            GO TO 999
          ENDIF
          INSRDB = 1
        ENDIF
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
      ENDIF
+SELF.
*
* *** Construct the character option
*
      CHOP   = ' '
      II     = 0
      DO 30 I = 1, NOPRZ
        IF (IOPRZ(I).NE.0) THEN
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          IF (IOPP.NE.0) THEN
            IF (IACRZ(I).EQ.0) GO TO 30
          ENDIF
+SELF.
          IF (II.EQ.0) THEN
            CHOP   = COPRZ(I)
          ELSE
            CHOP   = CHOP(1:II)//COPRZ(I)
          ENDIF
          II     = II + 1
        ENDIF
   30 CONTINUE
      IFLG   = 0
      IF (IOPTO.NE.0.OR.IOPTN.NE.0) IFLG = 1
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
      IF (IOPP.NE.0) IOPTN  = 0
+SELF.
      IF (IFLG.NE.0.OR.IOPRZ(5).NE.0) THEN
        KY7M   = 0
      ELSE
        CALL DATIME (IDATE, ITIME)
        CALL DBPKTM (IDATE, ITIME, KY7M)
      ENDIF
*
*  ** Check whether the RZ file has been already initialized
*
      IF (LTOPDB.NE.0) THEN
        LSAVDB = LTOPDB
   40   LUN    = IQ(KOFUDB+LSAVDB+MUPLUN)
        NCH    = IQ(KOFUDB+LSAVDB+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LSAVDB+MUPNAM), 4, TOP1, NCH)
        TOP    = TOP1(1:NCH)
        IF (NTOP.GT.0) THEN
          IF (NTOP.EQ.IQ(KOFUDB+LSAVDB+MUPDIC)) THEN
            IQUEST(1) = -4
            LSAVDB = 0
+SELF, IF=$DEBUG.
            IARGDB(1) = NTOP
            IARGDB(2) = LUN
            CALL DBPRNT (LPRTDB, '(/,'' DBINIT : Requested Identifier'//
     +           ' '',I4,'' for Top Name '//TOPNDI//' clashes with th'//
     +           'at of '//TOP(1:NCH)//' on unit '',I4)', IARGDB, 2)
+SELF.
            GO TO 999
          ENDIF
        ENDIF
        IF (TOP.EQ.TOPNDI.AND.LUN.EQ.LUNRZ) THEN
          IQUEST(1) = -2
          LSAVDB = 0
+SELF, IF=$DEBUG.
          CALL DBPRNT (LPRTDB, '(/,'' DBINIT : Top Directory '//TOPNDI//
     +         ' is already open on unit '',I4)', LUNRZ, 1)
+SELF.
          GO TO 999
        ENDIF
        IF (TOP.EQ.TOPNDI.OR. LUN.EQ.LUNRZ) THEN
          IQUEST(1) = -3
          LSAVDB = 0
+SELF, IF=$DEBUG.
          IARGDB(1) = LUN
          IARGDB(2) = LUNRZ
          CALL DBPRNT (LPRTDB, '(/,'' DBINIT : Top Directory '//TOP//
     +         ' open on unit '',I4,'' is in conflict with'',/,'' Req'//
     +         'uested Top Directory '//TOPNDI//' on unit '',5X,I4)',
     +         IARGDB, 2)
+SELF.
          GO TO 999
        ENDIF
*
        LSUP   = LSAVDB
        LSAVDB = LQ(KOFUDB+LSUP)
        IF (LSAVDB.NE.0)       GO TO 40
*
*  **   Create linear structure of the top-directories
*
        CALL MZBOOK (IDIVDB, LSAVDB, LSUP, 0, 'UPDB', NLUPDB, NSUPDB,
     +               NDUPDB, IUPDB, -1)
      ELSE
        CALL MZBOOK (IDIVDB, LTOPDB, 0, 2, 'UPDB', NLUPDB, NSUPDB,
     +               NDUPDB, IUPDB, -1)
        LSAVDB = LTOPDB
      ENDIF
*
*  ** Fill up the top directory bank with user data
*
      NTOPDB = NTOPDB + 1
      IF (NTOP.LE.0) NTOP = NTOPM + 1
      IF (NTOP.GT.NTOPM) NTOPM = NTOP
      IQ(KOFUDB+LSAVDB+MUPLUN) = LUNRZ
      IQ(KOFUDB+LSAVDB+MUPFLG) = IFLG
      IQ(KOFUDB+LSAVDB+MUPJFL) = 0
      IQ(KOFUDB+LSAVDB+MUPBAK) = 0
      IQ(KOFUDB+LSAVDB+MUPDIC) = NTOP
      IQ(KOFUDB+LSAVDB+MUPNCH) = MAX
      IQ(KOFUDB+LSAVDB+MUPSRV) = IOPS*10 + IOPP
      IQ(KOFUDB+LSAVDB+MUPKY7) = KY7M
      CALL UCTOH (TOPNDI, IQ(KOFUDB+LSAVDB+MUPNAM), 4, MAX)
*
      IQUEST(1) = 0
+SELF, IF=$P3CHILD.
      IF (IOPP.NE.0)  THEN
*
*  **   Request host to open the RZ file
*
        RNDBP3 = 'DBINIT'
        NWDBP3 = 8
        IWDBP3(1) = LUNRZ
        CALL UCTOH  (TOPNDI, IWDBP3(2), 4, 16)
        IWDBP3(6) = NRECS
        MSDBP3 = CHOPT
        CALL UCTOH  (MSDBP3, IWDBP3(7), 4, 8)
        CALL DBCHLD
        IF (IQDBP3.NE.0) THEN
          IF (LTOPDB.EQ.LSAVDB) LTOPDB = 0
          CALL MZDROP (IDIVDB, LSAVDB, ' ')
          IQUEST(1) =-10
          IQUEST(11)= IQDBP3
+SELF, IF=$P3CHILD, IF=$DEBUG.
          CALL DBPRNT (LPRTDB, '(/,'' DBINIT : Host unable to open '//
     +         'directory '//TOPNDI//' on unit '',I4)', LUNRZ, 1)
+SELF, IF=$P3CHILD.
          GO TO 999
        ENDIF
      ENDIF
*
+SELF.
      IF (IOPTN.NE.0)  THEN
*
*  **   Create file on mass storage and create the 1st pass directories
*
        CALL RZMAKE (LUNRZ, TOPNDI, NINEDK, CHFTDK, CHTGDK, NREC, CHOP)
*
      ELSE
*
*  **   Reopen the RZ-file on the mass storage for read and write
*
        CALL RZFILE (LUNRZ, TOPNDI, CHOP)
*
      ENDIF
*
      IF (IQUEST(1).NE.0)  THEN
        IF (LTOPDB.EQ.LSAVDB) LTOPDB = 0
        CALL MZDROP (IDIVDB, LSAVDB, ' ')
        CALL RZEND  (TOPNDI)
        IQUEST(1) = -2
+SELF, IF=$DEBUG.
        CALL DBPRNT (LPRTDB, '(/,'' DBINIT : Top Directory '//TOPNDI//
     +       ' is already open on unit '',I4)', LUNRZ, 1)
+SELF.
      ELSE
*
        IF (IOPTN.NE.0)  THEN
*
*   *     Create the version number
*
          PATH = '//'//TOPNDI
          CALL DBVOUT (PATH, IVSTR, IVEND, NBUF, IBUF, IPRVS, NKYXT
     +               , KEYXT, IDTYP, 0, 'SU')
          IERR = IQUEST(1)
          IF (IERR.NE.0) THEN
            IF (LTOPDB.EQ.LSAVDB) LTOPDB = 0
            CALL MZDROP (IDIVDB, LSAVDB, ' ')
            CALL DBSBLC (TOPNM, TOPNDI, MAX)
            CALL RZEND  (TOPNDI)
            IQUEST(1) = IERR
            GO TO 999
          ENDIF
        ENDIF
*
*   *   Load the dictionary directory
*
        CALL DBUDIC (LSAVDB)
+SELF, IF=VAX, IF=$SERVER.
        IQUEST(1) = 0
+SELF.
        IERR = IQUEST(1)
        IF (IERR.NE.0) THEN
          IF (LTOPDB.EQ.LSAVDB) LTOPDB = 0
          CALL MZDROP (IDIVDB, LSAVDB, ' ')
          CALL DBSBLC (TOPNM, TOPNDI, MAX)
          CALL RZEND  (TOPNDI)
          IQUEST(1) = IERR
          GO TO 60
        ENDIF
*
*   *   Link it to the list of directory names to be updated
*
        LREFDB(1) = LBADDB
        CALL DBSBLC (TOPNM, TOP, MAX)
   50   IF (LREFDB(1).NE.0) THEN
          CALL UHTOC (IQ(KOFUDB+LREFDB(1)+MFZTOP), 4, TOPNDI, 16)
          IF (TOPNDI.EQ.TOP) THEN
            LQ(KOFUDB+LSAVDB-KLFZDB) = LREFDB(1)
          ELSE
            LREFDB(1) = LQ(KOFUDB+LREFDB(1))
            GO TO 50
          ENDIF
        ENDIF
*
      ENDIF
*
      LTOP(1) = LSAVDB
   60 LSAVDB = 0
*                                                             END DBINIT
  999 CONTINUE
C ACP_data_retrieval_end
      END
+DECK, DBKEPT.
      SUBROUTINE DBKEPT (PATHS, NPATH, CHOPT)
*     =======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBKEPT (PATHS, NPATH, CHOPT)                            *
*                                                                      *
*   Deletes all directory trees from the data base except the ones     *
*   specified by the user                                              *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHS    Path names to be kept                                   *
*     NPATH    Number of paths to be kept                              *
*     CHOPT    Character string with any of the following characters   *
*          B   Save in the special backup file; not in standard Journal*
*                                                                      *
*   Called by user,   DBAUXI                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =211 : Illegal number of paths                         *
*               =212 : Illegal path name                               *
*               =213 : Conflicting top directory names                 *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
      PARAMETER       (NLEVM=20)
      DIMENSION       NCHL(NLEVM)
      CHARACTER       PATH*80, PATHX*16, PATHY*80, PATHF*80, PATHZ*16
      CHARACTER       CNODE(NLEVM)*16
      CHARACTER*(*)   PATHS(*), CHOPT
*
*     ------------------------------------------------------------------
*
* *** Find the top directory name
*
      IF (NPATH.LE.0) THEN
        IQUEST(1) = 211
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEPT : Illegal'//
     +  ' number of paths to be kept '',I12)', NPATH, 1)
+SELF.
        GO TO 999
      ENDIF
      PATHX  = ' '
      DO 10 IP = 1, NPATH
        CALL DBSBLC (PATHS(IP), PATH, NCHR)
        IF (NCHR.LT.3.OR.PATH(1:2).NE.'//') THEN
          IQUEST(1) = 212
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEPT : Illeg'//
     +    'al path name '//PATH//''')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
        NCHRT  = INDEX (PATH(3:NCHR), '/') - 1
        IF (NCHRT.LE.0) NCHRT = NCHR - 2
        PATHZ  = PATH(3:NCHRT+2)
        IF (PATHX.EQ.' ') THEN
          PATHX  = PATHZ
        ELSE IF (PATHZ.NE.PATHX) THEN
          IQUEST(1) = 213
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEPT : Confl'//
     +    'icting top-directories '//PATHX//' and '//PATHZ//''')',
     +    IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
   10 CONTINUE
*
* *** Now prepare the bank with all node names
*
      LEVM   = NLEVM
      PATH   = '//'//PATHX
      LSAVDB = 0
      IQUEST(1) = 0
      CALL DBFPAT (PATH, LEVM, LSAVDB)
      IF (IQUEST(1).NE.0)                                   GO TO 100
      IF (LSAVDB.EQ.0) THEN
        IQUEST(1) = 212
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEPT : Illegal'//
     +  ' path name '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NLEV   = IQ(KOFUDB+LSAVDB+MNLVDB)
      IF (NLEV.LE.0)                                        GO TO 100
*
* *** Loop over all the paths to be kept
*
      DO 50 IP = 1, NPATH
        CALL DBSBLC (PATHS(IP), PATH, NCHR)
*
*  **   Find all the nodes in the path name
*
        NODES  = 0
        I0     = 0
   15   I1     = I0 + 1
        IF (I1.LE.NCHR) THEN
          DO 20 I0 = I1, NCHR
            IF (PATH(I0:I0).EQ.' ') THEN
              I2     = I0 - 1
              GO TO 25
            ELSE IF (PATH(I0:I0).EQ.'/') THEN
              I2     = I0 - 1
              GO TO 30
            ENDIF
   20     CONTINUE
          I2     = NCHR
   25     I0     = NCHR + 1
   30     IF (I2.LT.I1)                                     GO TO 15
          NODES  = NODES + 1
          CNODE(NODES) = PATH(I1:I2)
          NCHL (NODES) = I2 - I1 +1
          GO TO 15
        ENDIF
*
*  **   Now look up the complete list and mark the nodes to be kept
*
        IPNL   = IQ(KOFUDB+LSAVDB+MPNLDB)
        NLEV0  = MIN0 (NLEV, NODES)
        IUPN   = 0
        DO 45 ILEV = 1, NLEV0
          NNODE  = IQ(KOFUDB+LSAVDB+IPNL+MNODDB)
          IPNN   = IQ(KOFUDB+LSAVDB+IPNL+MPNNDB)
          DO 35 INOD = 1, NNODE
            IF ((IQ(KOFUDB+LSAVDB+IPNN+MNCHDB).EQ.NCHL(ILEV)) .AND.
     +          (IQ(KOFUDB+LSAVDB+IPNN+MNFNDB).EQ.IUPN)) THEN
              CALL UHTOC (IQ(KOFUDB+LSAVDB+IPNN+MNAMDB), 4, PATHZ,
     +                    NCHL(ILEV))
              IF (PATHZ(1:NCHL(ILEV)).EQ.CNODE(ILEV)) THEN
                IUPN   = INOD
                Q(KOFUDB+LSAVDB+IPNN+MYFNDB) = 1.0
                GO TO 40
              ENDIF
            ENDIF
            IPNN   = IQ(KOFUDB+LSAVDB+IPNN+MPNLDB)
   35     CONTINUE
          GO TO 50
   40     IPNL   = IQ(KOFUDB+LSAVDB+IPNL+MPNLDB)
   45   CONTINUE
*
   50 CONTINUE
*
* *** Now delete the unmarked directories
*
      IPNL   = IQ(KOFUDB+LSAVDB+MPNLDB)
      DO 90 ILEV =1, NLEV
        NNODE  = IQ(KOFUDB+LSAVDB+IPNL+MNODDB)
        IPNN   = IQ(KOFUDB+LSAVDB+IPNL+MPNNDB)
        DO 85 INOD = 1, NNODE
          IF (Q(KOFUDB+LSAVDB+IPNN+MYFNDB).EQ.0.) THEN
            IF (ILEV.EQ.2) THEN
              NCHR   = IQ(KOFUDB+LSAVDB+IPNN+MNCHDB)
              CALL UHTOC (IQ(KOFUDB+LSAVDB+IPNN+MNAMDB), 4, PATHZ, NCHR)
              IF ((NCHR.EQ.10.AND.PATHZ(1:NCHR).EQ.'DICTIONARY').OR.
     +            (NCHR.EQ.4 .AND.PATHZ(1:NCHR).EQ.'HELP')) GO TO 80
            ENDIF
*
*  **       Delete the tree from here; construct the path name first
*
            IUPN   = INOD
            NCHRT  = 0
            PATHY  = ' '
            DO 65 KLEV = 1, ILEV
              JLEV   = ILEV + 1 - KLEV
              IPNLC  = IQ(KOFUDB+LSAVDB+MPNLDB)
              IF (JLEV.GT.1) THEN
                DO 55 IL = 2, JLEV
   55           IPNLC  = IQ(KOFUDB+LSAVDB+IPNLC+MPNLDB)
              ENDIF
              IPNNC  = IQ(KOFUDB+LSAVDB+IPNLC+MPNNDB)
              IF (IUPN.GT.1) THEN
                DO 60 IN = 2, IUPN
   60           IPNNC   = IQ(KOFUDB+LSAVDB+IPNNC+MPNLDB)
              ENDIF
              NCHR   = IQ(KOFUDB+LSAVDB+IPNNC+MNCHDB)
              IUPN   = IQ(KOFUDB+LSAVDB+IPNNC+MNFNDB)
              CALL UHTOC (IQ(KOFUDB+LSAVDB+IPNNC+MNAMDB), 4, PATHZ,NCHR)
              PATHF  = '/'//PATHZ(1:NCHR)
              NCHR   = NCHR + 1
              IF (NCHRT.GT.0) THEN
                PATH  = PATHF(1:NCHR)//PATHY(1:NCHRT)
              ELSE
                PATH   = PATHF
              ENDIF
              PATHY  = PATH
              NCHRT  = NCHRT + NCHR
   65       CONTINUE
            PATH  = '/'//PATHY
*
*  **       Now delete the tree
*
            CALL DBDELT (PATH, CHOPT)
            IF (IQUEST(1).NE.0)                             GO TO 100
*
*  **       Now mark all down nodes from here to be nonexistent
*
            NND    = IQ(KOFUDB+LSAVDB+IPNN+MNDWDB)
            IF (ILEV.LT.NLEV.AND.NND.GT.0) THEN
              IPNLC  = IQ(KOFUDB+LSAVDB+IPNL+MPNLDB)
              KLEV   = ILEV + 1
              NCHL(KLEV) = INOD
   70         IF (KLEV.GT.ILEV) THEN
                NODES  = IQ(KOFUDB+LSAVDB+IPNLC+MNODDB)
                IPNNC  = IQ(KOFUDB+LSAVDB+IPNLC+MPNNDB)
                DO 75 IN = 1, NODES
                  IF ((Q(KOFUDB+LSAVDB+IPNNC+MYFNDB).EQ.0.0) .AND.
     +               (NCHL(KLEV).EQ.IQ(KOFUDB+LSAVDB+IPNNC+MNFNDB)))THEN
                    Q(KOFUDB+LSAVDB+IPNNC+MYFNDB) = 1.0
                    NND    = IQ(KOFUDB+LSAVDB+IPNNC+MNDWDB)
                    IF (KLEV.LT.NLEV.AND.NND.GT.0) THEN
                      KLEV   = KLEV + 1
                      IPNLC  = IQ(KOFUDB+LSAVDB+IPNLC+MPNLDB)
                      NCHL(KLEV) = IN
                      GO TO 70
                    ENDIF
                  ENDIF
                  IPNNC  = IQ(KOFUDB+LSAVDB+IPNNC+MPNLDB)
   75           CONTINUE
                KLEV   = KLEV - 1
                IPNLC  = IQ(KOFUDB+LSAVDB+IPNLC+MPPLDB)
                GO TO 70
              ENDIF
            ENDIF
*
          ENDIF
   80     IPNN   = IQ(KOFUDB+LSAVDB+IPNN+MPNLDB)
   85   CONTINUE
        IPNL   = IQ(KOFUDB+LSAVDB+IPNL+MPNLDB)
   90 CONTINUE
      IQUEST(1) = 0
*
  100 IF (LSAVDB.NE.0) THEN
        IERR   = IQUEST(1)
        CALL MZDROP (IDIVDB, LSAVDB, 'L')
        LSAVDB = 0
        IQUEST(1) = IERR
      ENDIF
*                                                             END DBKEPT
  999 END
+DECK, DBKIN.
      SUBROUTINE DBKIN (PATHN, KEY1S, IUDIV, LBD, LSUP, JBIAS, IPREC)
*     ===============================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBKIN (PATHN, KEY1S, IUDIV, LBD*, LSUP, JBIAS, IPREC*)  *
*                                                                      *
*   Fetches from disk to a ZEBRA bank data valid for a given Key       *
*   serial number (as stored inside the directory)                     *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     KEY1S    Serial number of the data to be fetched                 *
*     IUDIV    Division index where bank is expected                   *
*     LBD(*)   Address of the bank in memory                           *
*     LSUP     Supporting link of the bank (see MZBOOK)                *
*     JBIAS    Link bias for creating the data bank (see MZBOOK)       *
*     IPREC(*) Precision word; (If IPREC > 0, data are stored with     *
*              IPREC significant digits right to the decimal points; if*
*              IPREC < 0, data are stored with IPREC insignificant     *
*              digits left to the decimal point.)                      *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 31 : Illegal path name                               *
*               = 32 : No key or data in the path name                 *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
      DIMENSION       LSUP(9), LBD(9)
      CHARACTER       PATH*80, PATHN*(*)
*
*     ------------------------------------------------------------------
*
* *** Set the character option
*
      CALL DBOPTS (' ')
      IF (IQUEST(1).NE.0) GO TO 999
      IOKYDA(MSERDB) = 1
      ITIME  = 1
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Set the current directory
*
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0)  THEN
        IQUEST(1) = 31
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKIN : Illegal '//
     +  'Path Name '//PATH(1:NCHAR)//''')', IARGDB, 0)
+SELF.
        IOKYDA(MSERDB) = 0
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKEYT
*
      IF (NKEYDK.LE.0)  THEN
        IQUEST(1) = 32
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKIN : No key '//
     +  'or data for Path Name '//PATH(1:NCHAR)//''')', IARGDB, 0)
+SELF.
        IOKYDA(MSERDB) = 0
        GO TO 999
      ENDIF
*
* *** Read in the data
*
      CALL VZERO (KEYVDK, NWKYDK)
      KEYVDK(MSERDB) = KEY1S
      CALL DBKXIN (ITIME, IUDIV, LBD(1), LSUP(1), JBIAS, NWKEY, KEYVDK,
     +             IPREC)
      IOKYDA(MSERDB) = 0
*                                                              END DBKIN
  999 END
+DECK, DBKTYP.
      SUBROUTINE DBKTYP (PATHN, NKEYS, IOTY, CTAG)
*     ============================================
*
************************************************************************
*                                                                      *
*        SUBR. DBKTYP (PATHN, *NKEYS*, IOTY*, CTAG*)                   *
*                                                                      *
*   Gets the key types and their tags for a given directory            *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     NKEYS    On input it carries the maximum dimension of IOTY and   *
*              CTAG; on output it carries number of key elements (if   *
*              no error; -1 if error)                                  *
*     IOTY(*)  Type of each key element                                *
*     CTAG(*)  Tag for each element                                    *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =101 : Illegal path name                               *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
      CHARACTER*(*)   CTAG(*)
      CHARACTER       PATHN*(*), PATH*80
      DIMENSION       IOTY(9)
*
*     ------------------------------------------------------------------
*
* *** Set the current directory
*
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0)  THEN
        IQUEST(1) = 101
        NKEYS  = -1
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          PATH   = PATHN
          CALL DBPRNT (LPRTDB, '(/,'' DBKTYP : Illegal Path Name '//
     +         PATH//''')', IARGDB, 0)
        ENDIF
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKYTG
*
* *** Fill up the user vectors
*
      NKMAX  = MIN0 (NKEYS, NWKYDK)
      DO 10 I = 1, NKMAX
        IOTY(I) = IOTYDK(I)
        CTAG(I) = CTAGDK(I)
   10 CONTINUE
      NKEYS  = NWKYDK
*                                                             END DBKTYP
  999 END
+DECK, DBKVIN.
      SUBROUTINE DBKVIN (PATHN, ITIME, USER, NDAT, IDTYP, IPRVS, NWKEY,
     +                   KEY, IPREC, CHOPT)
*     =================================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBKVIN (PATHN, ITIME, USER*, *NDAT*, IDTYP*, IPRVS,     *
*                      NWKEY*, *KEY*, IPREC*, CHOPT)                   *
*                                                                      *
*   Fetches from disk to a FORTRAN array data valid for a given time   *
*                                                                      *
*   Restrictions : USER should contain variables of the same type      *
*                  (Integer, Real or Holllereith)                      *
*                  One should be very careful in using this routine.   *
*                  The use of character option should be handled with  *
*                  caution.                                            *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     ITIME    Time for which data are required to be valid            *
*     USER(*)  User array where data are stored                        *
*     NDAT(*)  Maximum dimension of USER array (on input)              *
*              Number of data words fetched from disk (on output)      *
*     IDTYP(*) Type of the data (2 - integer; 3 - real; 5 - Hollereith)*
*     IPRVS    Program version number for selecting the data           *
*              (if 0 no selection on program version number to be made)*
*     NWKEY(*) Length of the key vector                                *
*     KEY(*)   Key vector elements (If any User key or key 5 is nonzero*
*              at input, data are retrieved according to that key      *
*              content; on output it contains key elements for the     *
*              data)                                                   *
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *
*              IPREC significant digits right to the decimal points; if*
*              IPREC < 0, data are stored with IPREC insignificant     *
*              digits leftto the decimal point.)                       *
*     CHOPT    Character string with any of the following characters   *
*          N   If data do not exist for ITIME, take the nearest data   *
*              object in time                                          *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 31 : Illegal path name                               *
*               = 32 : No keys/data in this directory                  *
*               = 36 : Data bank address zero on return from DBKXIN    *
*               = 37 : Insufficient space in USER store array          *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DLINKS.
      DIMENSION       KEY(9), USER(2)
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, PATHX*16
*
*     ------------------------------------------------------------------
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0) GO TO 999
      JBIAS  = 2
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Set the current directory
*
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 31
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKVIN : Illegal'//
     +  ' Path Name '//PATH(1:NCHAR)//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKEYT
*
      CALL RZCDIR (PATH, 'R')
      NCHAR  = INDEX (PATH, ' ') - 1
      IF (NCHAR.LT.0) NCHAR = MAXLDB
      NCHRT  = INDEX (PATH(3:NCHAR), '/') - 1
      IF (NCHRT.LE.0) NCHRT = NCHAR - 2
      PATHX  = PATH(3:NCHRT+2)
      LTOP   = LTOPDB
   10 IF (LTOP.NE.0) THEN
        NCHRT  = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHRT)
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 10
        ENDIF
        KY7MDB = IQ(KOFUDB+LTOP+MUPKY7)
      ELSE
        KY7MDB = 0
      ENDIF
*
* *** Check on the number of keys
*
      IF (NKEYDK.EQ.0) THEN
        IQUEST(1) = 32
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKVIN : No key '//
     +  'or data for Path Name '//PATH(1:NCHAR)//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Set up the character option
*
      IOPRDA = 0
      IOPSDA = 0
      DO 15 I = 1, NSYSDK
   15 IOKYDA(I) = 0
      IF (IPRVS.NE.0) THEN
        IOKYDA(MPVSDB) = 1
        KEY(MPVSDB)    = IPRVS
      ELSE IF (KEY(MPVSDB).NE.0) THEN
        IOKYDA(MPVSDB) = 1
      ELSE
        IOKYDA(MPVSDB) = 0
      ENDIF
      IF (NWKYDK.GT.NSYSDK) THEN
        DO 20 IK = NSYSDK+1, NWKYDK
          IF (KEY(IK).NE.0) THEN
            IOKYDA(IK) = 1
          ELSE
            IOKYDA(IK) = 0
          ENDIF
   20   CONTINUE
      ENDIF
*
* *** Read in the data
*
      CALL DBKXIN (ITIME, IDISDB, LAUXDL(7), LAUXDL(7), JBIAS, NWKEY,
     +             KEY, IPREC)
*
      IF (IQUEST(1).NE.0)  THEN
*
*  **   DBKXIN encounters error in retrieving data
*
        NDAT      = 0
*
      ELSE IF (LAUXDL(7).EQ.0)  THEN
*
*  **   DBKXIN has not created the data bank
*
        IQUEST(1) = 36
        NDAT      = 0
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKVIN : Illegal'//
     +  ' Bank address from DBKXIN'')', IARGDB, 0)
+SELF.
*
      ELSE
*
*  **   See if the USER array size is sufficient to store the data
*
        L      = LAUXDL(7)
        ND     = IQ(KOFUDB+L-1)
        IF (ND.GT.NDAT)  THEN
*
*  *      Insufficient space
*
          CALL MZDROP (IDISDB, LAUXDL(7), ' ')
          IQUEST(1) = 37
          IQUEST(11)= ND
          IQUEST(12)= NDAT
          NDAT      = 0
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) THEN
            IARGDB(1) = IQUEST(12)
            IARGDB(2) = IQUEST(11)
            CALL DBPRNT (LPRTDB, '(/,'' DBKVIN : Insufficient space'//
     +           ' '',I10,'' to store data - a minimum of '',I10,'' '//
     +           'storage is needed'')', IARGDB, 2)
          ENDIF
+SELF.
*
        ELSE
*
*  *      Every thing is OK
*
          IQUEST(1) = 0
          IDTYP     = IDBTYP(L)
          CALL UCOPY (Q(KOFUDB+L+1), USER(1), ND)
          NDAT      = ND
          CALL MZDROP (IDISDB, LAUXDL(7), ' ')
*
        ENDIF
      ENDIF
*                                                             END DBKVIN
  999 END
+DECK, DBLAST.
      LOGICAL FUNCTION DBLAST (LBK)
*     =============================
*
************************************************************************
*                                                                      *
*        FUNC. DBLAST (LBK)                                            *
*                                                                      *
*   Checks if the Key bank corresponds to the last inserted object     *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LBK      Address of the key bank                                 *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =131 : Illegal pathname in the Key bank                *
*               =132 : Illegal number of keys in the directory         *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
      CHARACTER       PATHN*80, PATHX*16
      DIMENSION       LBK(9)
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Get the path name from the key bank
*
      LREFDB(1) = LBK(1)
      DBLAST = .FALSE.
      LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)
      NCH    = IQ(KOFUDB+LBNODB+MNDNCH)
      CALL UHTOC (IQ(KOFUDB+LBNODB+MNDNAM), 4, PATHN, NCH)
      PATHN  = PATHN(1:NCH)
*
* *** Set the current directory
*
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 131
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBLAST : Ill'//
     +  'egal path name '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      IF (IQUEST(7).LE.0) THEN
        IQUEST(1) = 132
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBLAST : Illegal'//
     +  ' number of keys for '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      IPNT   = KOFSDB + LCDRDB + IKDRDB
      ISTP   = NWKYDK + 1
      IOPTP  = JBIT (IQ(IPNT+MFLGDB), JPRTDB)
*
* *** Take different action for partitioned and non-partitioned cases
*
      IF (IOPTP.EQ.0) THEN
        KPNT   = IPNT + (NKEYDK-1) * ISTP
        KMAX   = IQ(KPNT+MSERDB)
        DO 10 I = 2, NKEYDK
          KPNT   = KPNT - ISTP
          IF (IQ(KPNT+MSERDB).GT.KMAX) KMAX = IQ(KPNT+MSERDB)
   10   CONTINUE
      ELSE
*
        DO 20 IK = 1, NKEYDK
          JK     = NKEYDK + 1 - IK
          CALL DBPATH (PATHX, JK)
          PATHN  = PATHN(1:NCH)//'/'//PATHX
          CALL RZCDIR (PATHN, ' ')
          IF (IQUEST(1).NE.0) THEN
            IQUEST(1) = 131
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBLAST : Ill'//
     +      'egal path name '//PATHN//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          NKEYS  = IQUEST(7)
          IF (NKEYS.GT.0) THEN
            KPNT   = KOFSDB + IQUEST(11) + IQUEST(13) + (NKEYS-1) * ISTP
            KMAX   = IQ(KPNT+MSERDB)
            DO 15 I = 2, NKEYS
              KPNT   = KPNT - ISTP
              IF (IQ(KPNT+MSERDB).GT.KMAX) KMAX = IQ(KPNT+MSERDB)
   15       CONTINUE
            GO TO 30
          ENDIF
   20   CONTINUE
      ENDIF
*
* *** Now compare last Key 1 with that in the Key bank
*
   30 IF (IQ(KOFUDB+LREFDB(1)+MSERDB).EQ.KMAX) DBLAST = .TRUE.
      IQUEST(1) = 0
*                                                             END DBLAST
  999 END
+DECK, DBLKEY.
      SUBROUTINE DBLKEY (PATHN, KEY1, IDATE, ITIME)
*     =============================================
*
************************************************************************
*                                                                      *
*        SUBR. DBLKEY (PATHN, KEY1*, IDATE*, ITIME*)                   *
*                                                                      *
*   Finds the latest inserted object for a given directory             *
*   (Adapted from P.Bagnaia)                                           *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     KEY1(*)  The highest key(1) of the directory                     *
*     IDATE(*) Date (YYMMDD) of the insertion of the last element      *
*     ITIME(*) Time (HHMM)   "   "      "      "  "    "     "         *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =131 : Illegal pathname                                *
*               =132 : Illegal number of keys in the directory         *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
      CHARACTER       PATHN*(*), PATHY*80, PATHX*16
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATHY, NCHAR)
*
* *** Set the current directory path name
*
      CALL RZCDIR (PATHY, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 131
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBLKEY : Ill'//
     +  'egal path name '//PATHY//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      IF (IQUEST(7).LE.0) THEN
        IQUEST(1) = 132
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBLKEY : Illegal'//
     +  ' number of keys for '//PATHY//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      IPNT   = KOFSDB + LCDRDB + IKDRDB
      ISTP   = NWKYDK + 1
      IOPTP  = JBIT (IQ(IPNT+MFLGDB), JPRTDB)
*
* *** Take different action for partitioned and non-partitioned cases
*
      IF (IOPTP.EQ.0) THEN
        KPNT   = IPNT + (NKEYDK-1) * ISTP
        KMAX   = IQ(KPNT+MSERDB)
        JMAX   = NKEYDK
        DO 10 I = 2, NKEYDK
          KPNT   = KPNT - ISTP
          IF (IQ(KPNT+MSERDB).GT.KMAX) THEN
            KMAX = IQ(KPNT+MSERDB)
            JMAX = I - 1
          ENDIF
   10   CONTINUE
        KEY7   = IQ(IPNT+(JMAX-1)*ISTP+MITMDB)
      ELSE
*
        CALL RZCDIR (PATHY, 'R')
        NCH    = INDEX (PATHY, ' ') - 1
        IF (NCH.LT.1 .OR. NCH.GT.MAXLDB) NCH = MAXLDB
        DO 20 IK = 1, NKEYDK
          JK     = NKEYDK + 1 - IK
          CALL DBPATH (PATHX, JK)
          PATHN  = PATHY(1:NCH)//'/'//PATHX
          CALL RZCDIR (PATHY, ' ')
          IF (IQUEST(1).NE.0) THEN
            IQUEST(1) = 131
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBLKEY : Ill'//
     +      'egal path name '//PATHY//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          NKEYS  = IQUEST(7)
          IF (NKEYS.GT.0) THEN
            IPNT   = KOFSDB + IQUEST(11) + IQUEST(13)
            KPNT   = IPNT + (NKEYS-1) * ISTP
            KMAX   = IQ(KPNT+MSERDB)
            JMAX   = NKEYS
            DO 15 I = 2, NKEYS
              KPNT   = KPNT - ISTP
              IF (IQ(KPNT+MSERDB).GT.KMAX) THEN
                KMAX = IQ(KPNT+MSERDB)
                JMAX = I - 1
              ENDIF
   15       CONTINUE
            KEY7   = IQ(IPNT+(JMAX-1)*ISTP+MITMDB)
            GO TO 30
          ENDIF
   20   CONTINUE
      ENDIF
*
* *** and get the date
*
   30 CALL DBUPTM (IDATE, ITIME, KEY7)
      IQUEST(1) = 0
      KEY1      = KMAX
*                                                             END DBLKEY
  999 END
+DECK, DBLMOD.
      SUBROUTINE DBLMOD (PATHN, IDATE, ITIME)
*     =======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBLMOD (PATHN, IDATE*, ITIME*)                          *
*                                                                      *
*   Finds the date of last modification in a given directory           *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     IDATE(*) Date (YYMMDD) of last modification                      *
*     ITIME(*) Time (HHMM) for the last modification                   *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =131 : Illegal pathname                                *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
      CHARACTER       PATHN*(*), PATHY*80
*
*     ------------------------------------------------------------------
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATHY, NCHAR)
*
* *** Set the current directory path name
*
      CALL RZCDIR (PATHY, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 131
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBLMOD : Illegal'//
     +  ' path name '//PATHY//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      IDATE  = IQUEST(16)
      ITIME  = IQUEST(17)
*                                                             END DBLMOD
  999 END
+DECK, DBLOGL.
      SUBROUTINE DBLOGL (LUNRZ, LOGLV)
*     ================================
*
************************************************************************
*                                                                      *
*        SUBR. DBLOGL (LUNRZ, LOGLV)                                   *
*                                                                      *
*   Set the level of debug information                                 *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUNRZ    RZ file unit                                            *
*     LOGLV    Level of debug output                                   *
*                                                                      *
*   Called by user,   DBACTI                                           *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
*
*     ------------------------------------------------------------------
*
      CALL RZLOGL (LUNRZ, LOGLV)
      IDEBDB = LOGLV
*                                                             END DBLOGL
      END
+DECK, DBMDIP.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBMDIP (PATHN, NWKEY, CHFOR, CHTAG, MXKP)
*     ====================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBMDIP (PATHN, NWKEY, CHFOR, CHTAG, MXKP)               *
*                                                                      *
*   Creates Directories with the conventions of DB package for         *
*   partitioned data sets                                              *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Path name of the directory                              *
*     NWKEY    Number of words associated to the keys at the lowest    *
*              level (If some directory in the pathname at a higher    *
*              level does not exist, it is created with 9 keys)        *
*     CHFOR    Character variable describing each element of the key   *
*              vector at the lowest level (at higher level it is set   *
*              to default, i.e., 'IIIIIIIII')                          *
*              The first 7 characters should be 'I'                    *
*     CHTAG    Character array defined as CHARACTER*8 (NWKEY)          *
*              The first 7 elements should be :  'SERIAL_#'            *
*                                                'POINTER '            *
*                                                'STR_VALI'            *
*                                                'END_VALI'            *
*                                                'PRG_VERS'            *
*                                                'FLAGS   '            *
*                                                'INS_TIME'            *
*     MXKP     Maximum number of objects in each partition             *
*                                                                      *
*   Called by user,   DBCRSD, DBENTB, DBENTR, DBFZUP, DBNTOP, DBOUT,   *
*             DBREPL, DBVOUT, DBENFZ, DBKOUT, DBCRDR                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 41 : CHFOR for DB system keys declared wrongly by    *
*                      user                                            *
*               = 42 : CHTAG for DB system keys declared wrongly by    *
*                      user                                            *
*               = 43 : Too many key elements                           *
*               = 44 : Cannot find the top directory name              *
*                      (wrong initialisation)                          *
*               = 45 : Illegal Path name                               *
*               = 46 : Top directory name in the Path name does not    *
*                      match with the Top directory name               *
*               = 48 : Error in directory search sequence              *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DLINKS.
      CHARACTER       CHFOR*(*), PATHN*(*)
      CHARACTER       PATH*80, PATHX*80, PATHL*80, CHTMP*8
      CHARACTER*(*)   CHTAG(*)
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Check on format and tags of the DB system keys
*
      KEY7   = KEY7DK
      KEY7DK = 0
      PATHL  = ' '
      IF (CHFOR(1:NSYSDK) .NE. CHFTDK(1:NSYSDK)) GO TO 991
      DO 5 I = 1, NSYSDK
        IF (CHTAG(I) .NE. CHTGDK(I))             GO TO 992
    5 CONTINUE
      IF (NWKEY.GT.MXDMDK.OR.NWKEY.LT.NSYSDK)    GO TO 993
      MXK    = MXKP
      IF (MXK.LT.1) MXK = MXKPDK
*
* *** Find the Top Directory name
*
      CALL RZCDIR (PATHX, 'R')
*
      IF (IQUEST(1).EQ.0)  THEN
*
*  **   From Current directory
*
        I0     = 0
        MAXL   = MAXLDB
   10   I1     = I0 + 1
        IF (I1.GT.MAXL)                          GO TO 994
        DO 15 I0 = I1, MAXL
          IF (PATHX(I0:I0).EQ.' ')               GO TO 25
          IF (PATHX(I0:I0).EQ.'/')               GO TO 20
   15   CONTINUE
        I0     = MAXL + 1
   20   I2     = I0 - 1
        GO TO 30
   25   I2     = I0 - 1
        I0     = MAXL + 1
   30   IF (I2.LT.I1)                            GO TO 10
        NCHAR  = I2 - I1 + 1
        TOPNDI = PATHX(I1:I2)
*
      ELSE IF (LTOPDB.NE.0)  THEN
*
*  **   From the name stored at the first DBINIT call
*
        NCHAR  = IQ(KOFUDB+LTOPDB+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOPDB+MUPNAM), 4, PATHX, NCHAR)
        PATHX  = PATHX(1:NCHAR)
        TOPNDI = PATHX
*
      ELSE
*
*  **   Fatal error
*
        GO TO 994
*
      ENDIF
*
* *** Remove imbedded blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCH)
      IF (NCH.EQ.0)                              GO TO 995
*
* *** Get the complete path name
*
      IDONE  = 0
      IF (PATH(1:2).EQ.'//')  THEN
*
*  **   Check if the Top directory name matches
*
        LTOP   = LTOPDB
   45   IF (LTOP.NE.0) THEN
          NCHR   = IQ(KOFUDB+LTOP+MUPNCH)
          CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHR)
          IF (PATH(3:NCHAR+2).NE.TOPNDI(1:NCHR)) THEN
            LTOP   = LQ(KOFUDB+LTOP)
            GO TO 45
          ENDIF
          IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10)
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)
          IF (IOUT.EQ.0) IOPS = 0
          IDONE  = 1
        ELSE
          GO TO 996
        ENDIF
*
      ELSE IF (PATH(1:1).EQ.'/') THEN
        PATH   = '//'//TOPNDI(1:NCHAR)//PATH
        NCH    = NCH + NCHAR + 2
*
+SELF, IF=APOLLO, CRAY, IBM, VAX.
      ELSE IF (PATH(1:1).EQ.'\') THEN
+SELF, IF=HPUX, IBMRT, MIP.
      ELSE IF (PATH(1:1).EQ.'\\') THEN
+SELF.
        IL     = 0
        DO 50 I0 = 1, MAXLDB
          IF (PATHX(I0:I0).EQ.'/') IL = I0
   50   CONTINUE
        IF (IL.LE.1)                             GO TO 995
        PATH   = PATHX(1:IL-1)//'/'//PATH(2:NCH)
        NCH    = IL + NCH - 1
*
      ELSE IF (PATH(1:1).EQ.'~' .OR. PATH(1:1).EQ.'_') THEN
*
        CALL RZNDIR (PATHX, 'R')
        IF (IQUEST(1).NE.0)                      GO TO 994
        IL     = 0
        DO 55 I0 = 1, MAXLDB
          IF (PATHX(I0:I0).NE.' ') IL = I0
   55   CONTINUE
        IF (IL.LE.1)                             GO TO 995
        PATH   = PATHX(1:IL)//'/'//PATH(2:NCH)
        NCH    = IL + NCH
*
      ELSE
*
        IL     = 0
        DO 60 I0 = 1, MAXLDB
          IF (PATHX(I0:I0).NE.' ') IL = I0
   60   CONTINUE
        IF (IL.LE.1)                             GO TO 995
        PATH   = PATHX(1:IL)//'/'//PATH(1:NCH)
        NCH    = IL + NCH + 1
      ENDIF
*
* *** Check if the directory exists as yet
*
      IENCH  = NCHAR + 1
      I      = NCHAR + 2
      IP     = NCHAR + 3
      IF (IP.LE.NCH) THEN
        CALL RZCDIR (PATH, ' ')
        IF (IQUEST(1).EQ.0) THEN
          IF (IDONE.EQ.0) THEN
            NCHRT  = INDEX (PATH(3:NCH), '/') - 1
            IF (NCHRT.LE.0) NCHRT = NCH - 2
            LTOP   = LTOPDB
   62       IF (LTOP.NE.0) THEN
              NCHR   = IQ(KOFUDB+LTOP+MUPNCH)
              CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHR)
              IF (PATH(3:NCHRT+2).NE.TOPNDI(1:NCHR)) THEN
                LTOP   = LQ(KOFUDB+LTOP)
                GO TO 62
              ENDIF
              IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)
              IOUT   = IQ(KOFUDB+LTOP+MUPFLG)
              IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10)
            ELSE
              IOPP   = 0
              IOPS   = 0
              IOUT   = 0
            ENDIF
          ENDIF
          IF (IOUT.EQ.0) IOPS = 0
+SELF, IF=-$P3CHILD.
          IF (IOKYDA(MSERDB).EQ.0.AND.IOPP.EQ.0) GO TO 80
+SELF.
          GO TO 999
        ENDIF
      ENDIF
*
* *** Save the Directory creation information in the FZ file
*
      CALL DBSDIR (PATH, NWKEY, CHFOR, CHTAG, MXK, IOPP, IOPS)
      IF (IOPP.NE.0)                             GO TO 999
      IF (IQUEST(1).NE.0)                        GO TO 999
+SELF, IF=$P3CHILD.
      GO TO 999
+SELF, IF=-$P3CHILD.
*
* *** Create a new (tree of) director(ies) - from the first
* *** non-existing name
* *** Go down to the lowest existing directory in PATH
*
   65 I      = I + 1
      IF (PATH(I:I).EQ.'/')  THEN
        CALL RZCDIR (PATH(1:I-1), ' ')
        IF (IQUEST(1).NE.0)                      GO TO 68
        IENCH  = I -1
      ELSE IF (I.GE.NCH)  THEN
        CALL RZCDIR (PATH(1:I), ' ')
        IF (IQUEST(1).NE.0)                      GO TO 68
        GO TO 80
      ENDIF
      GO TO 65
*
* *** Lock the directory if needed
*
   68 IF (IOPS.NE.0) THEN
        PATHL  = PATH(1:IENCH)
        CALL RZCDIR (PATHL, ' ')
        CALL RZLOCK ('DBMDIP')
      ENDIF
*
* *** Create new directories
*
   70 ISTCH  = IENCH + 2
      IF (ISTCH.GT.NCH)                          GO TO 998
      PATHX  = PATH(ISTCH:ISTCH)
      J      = 0
      ISTCH  = ISTCH + 1
      I      = ISTCH
   75 CONTINUE
      IF (PATH(I:I).EQ.'/')  THEN
        CALL RZCDIR (PATH(1:IENCH), ' ')
*
*  **   Create the intermediate level directory with default values
*
        CALL RZMDIR (PATHX, NINEDK, CHFTDK, CHTGDK)
        IF (IQUEST(1).NE.0)                      GO TO 998
        IF (PATHL.NE.' ') THEN
          CALL RZCDIR (PATHL, ' ')
          CALL RZFREE ('DBMDIP')
          PATHL  = ' '
          CALL RZCDIR (PATH(1:IENCH), ' ')
        ENDIF
        CALL DBCDIC (PATHX)
        IF (IQUEST(1).NE.0)                      GO TO 9981
        IF (IOPS.NE.0) THEN
          PATHL  = PATH(1:IENCH)
          CALL RZCDIR (PATHL, ' ')
          CALL RZLOCK ('DBMDIP')
        ENDIF
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')
+SELF, IF=-$P3CHILD.
        IENCH  = I - 1
        I      = I + 1
        PATHX  = PATH(I:I)
        J      = 0
*
      ELSE
        J      = J + 1
        PATHX  = PATHX(1:J)//PATH(I:I)
      ENDIF
      IF (I.LT.NCH)  THEN
        I      = I + 1
        GO TO 75
      ENDIF
*
      IF (IENCH.GE.0) CALL RZCDIR (PATH(1:IENCH),' ')
      CALL RZMDIR (PATHX, NWKEY, CHFOR, CHTAG)
      IF (IQUEST(1).NE.0)                        GO TO 998
      IF (PATHL.NE.' ') THEN
        CALL RZCDIR (PATHL, ' ')
        CALL RZFREE ('DBMDIP')
        PATHL  = ' '
        IF (IENCH.GE.0) CALL RZCDIR (PATH(1:IENCH), ' ')
      ENDIF
      CALL DBCDIC (PATHX)
      IF (IQUEST(1).NE.0)                        GO TO 9981
      IF (IOPS.NE.0) THEN
        PATHL  = PATH(1:IENCH)
        CALL RZCDIR (PATHL, ' ')
        CALL RZLOCK ('DBMDIP')
      ENDIF
+SELF, IF=$DEBUG, IF=-$P3CHILD.
      IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')
+SELF, IF=-$P3CHILD.
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0)                        GO TO 998
*
* *** Now create Partitioned subdirectory
*
   80 NK    = IQUEST(7)
      CALL VZERO (KEYNDK, NSYSDK)
      IF (NK.GT.0) THEN
*
*  **   Get the keys of the last data inserted
*
        CALL DBPATH (PATHX, NK)
        CALL RZCDIR (PATHX, ' ')
        IF (IQUEST(1).NE.0)                      GO TO 998
        NKEYDK = IQUEST(7)
        NWKYDK = IQUEST(8)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        ISTP   = NWKYDK + 1
        IPNT   = KOFSDB + LCDRDB + IKDRDB
        KEYNDK(MOBJDB) = IQ(IPNT+MSERDB)
        IF (NKEYDK.GT.1) THEN
          DO 85 IK = 2, NKEYDK
            IPNT   = IPNT + ISTP
            IF (KEYNDK(MOBJDB).LT.IQ(IPNT+MSERDB))
     +        KEYNDK(MOBJDB) = IQ(IPNT+MSERDB)
   85     CONTINUE
        ENDIF
      ENDIF
*
*  ** Fill up the remaining keys
*
      KEYNDK(MPSRDB) = NK + 1
      KEYNDK(MXKPDB) = MXK
      KEYNDK(MBVRDB) = 900000000
      KEYNDK(MEVRDB) = 0
      KEYNDK(MFLGDB) = MSBIT1 (KEYNDK(MFLGDB), JPRTDB)
      IF (KEY7.EQ.0) THEN
        CALL DATIME (IDATE, ITIME)
        CALL DBPKTM (IDATE, ITIME, KEYNDK(MITMDB))
      ELSE
        KEYNDK(MITMDB) = KEY7
      ENDIF
      IF (NWKEY.GT.NSYSDK) THEN
        DO 90 IK = NSYSDK+1, NWKEY
          IF (CHFOR(IK:IK).EQ.'A'.OR.CHFOR(IK:IK).EQ.'H') THEN
            CALL UCTOH ('    ', KEYNDK(IK), 4, 4)
          ELSE
            KEYNDK(IK) = 0
          ENDIF
   90   CONTINUE
      ENDIF
*
*  ** Insert a keyname for the new partition
*
      CALL RZCDIR (PATH, ' ')
      IF (IOPS.NE.0) THEN
        IF (PATHL.EQ.' ') THEN
          PATHL  = PATH
          CALL RZLOCK ('DBMDIP')
        ENDIF
      ENDIF
      IF (LSTRDL(3).NE.0) CALL MZDROP (IDISDB, LSTRDL(3), ' ')
      JBIAS  = 2
      CALL DBBOOK (IDISDB, LSTRDL(3), LSTRDL(3), JBIAS, 'SAME', 0, 0, 0,
     +             2, 0)
      IF (IQUEST(1).NE.0)                        GO TO 9981
      CALL RZOUT (IDISDB, LSTRDL(3), KEYNDK, ICYCLE, 'S')
      CALL MZDROP (IDISDB, LSTRDL(3), ' ')
      LSTRDL(3) = 0
      CALL DBPATH (PATHX, KEYNDK(MPSRDB))
      CALL RZMDIR (PATHX, NWKEY, CHFOR, CHTAG)
      IF (IQUEST(1).NE.0) THEN
        CALL RZDELK (KEYNDK, ICYCLE, 'C')
        GO TO 998
      ENDIF
+SELF, IF=$DEBUG, IF=-$P3CHILD.
      IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')
+SELF, IF=-$P3CHILD.
      GO TO 9981
+SELF.
*
* *** Error Messages
*
  991 IQUEST(1) = 41
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) THEN
        CHTMP  = CHFOR(1:NSYSDK)
        CALL DBPRNT (LPRTDB, '(/,'' DBMDIP : The system characters fo'//
     +       'r CHFOR '//CHTMP//' does not conform with the default '//
     +       CHFTDK(1:NSYSDK)//''')', IARGDB, 0)
      ENDIF
+SELF.
      GO TO 999
*
  992 IQUEST(1) = 42
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) THEN
        CALL DBPRNT (LPRTDB, '(/,'' DBMDIP : The system tags for CHTA'//
     +       'G does not conform with defaults '')', IARGDB, 0)
        DO 9921 I = 1, NSYSDK
          CHTMP = CHTAG(I)
          CALL DBPRNT (LPRTDB, '(10X,''Key '',I2,'' Supplied '//CHTMP//
     +         ' Default '//CHTGDK(I)//''')', I, 1)
 9921   CONTINUE
      ENDIF
+SELF.
      GO TO 999
*
  993 IQUEST(1) = 43
      IQUEST(11)= NWKEY
      IQUEST(12)= MXDMDK
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIP : Too many '//
     +   'key elements requested = '',I6,'' maximum permitted '',I5)',
     +   IQUEST(11), 2)
+SELF.
      GO TO 999
*
  994 IQUEST(1) = 44
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIP : Cannot fi'//
     +   'nd the top directory '')', IARGDB, 0)
+SELF.
      GO TO 999
*
  995 IQUEST(1) = 45
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIP : Illegal '//
     +   'path name '//PATHX//''')', IARGDB, 0)
+SELF.
      GO TO 999
*
  996 IQUEST(1) = 46
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIP : Top direc'//
     +   'tory name in path name '//PATHX//''',/,''          does not'//
     +   ' match with '//TOPNDI//''')', IARGDB, 0)
+SELF.
      GO TO 999
+SELF, IF=-$P3CHILD.
*
  998 IQUEST(1) = 48
      IQUEST(11)= ISTCH
      IQUEST(12)= NCH
+SELF, IF=$DEBUG, IF=-$P3CHILD.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIP : Error in '//
     +   'Directory Search - ISTCH = '',I5,'' NCH = '',I5)', IQUEST(11),
     +   2)
+SELF, IF=-$P3CHILD.
*
* *** Unlock the directory if required
*
 9981 IF (PATHL.NE.' ') THEN
        IERR   = IQUEST(1)
        CALL RZCDIR (PATHL, ' ')
        CALL RZFREE ('DBMDIP')
        IQUEST(1) = IERR
      ENDIF
+SELF.
*                                                             END DBMDIP
  999 END
+DECK, DBMDIR.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBMDIR (PATHN, NWKEY, CHFOR, CHTAG)
*     ==============================================
*
************************************************************************
*                                                                      *
*        SUBR. DBMDIR (PATHN, NWKEY, CHFOR, CHTAG)                     *
*                                                                      *
*   Creates Directories with the conventions of DB package             *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Path name of the directory                              *
*     NWKEY    Number of words associated to the keys at the lowest    *
*              level (If some directory in the pathname at a higher    *
*              level does not exist, it is created with 9 keys)        *
*     CHFOR    Character variable describing each element of the key   *
*              vector at the lowest level (at higher level it is set   *
*              to default, i.e., 'IIIIIIIII')                          *
*              The first 7 characters should be 'I'                    *
*     CHTAG    Character array defined as CHARACTER*8 (NWKEY)          *
*              The first 7 elements should be :  'SERIAL_#'            *
*                                                'POINTER '            *
*                                                'STR_VALI'            *
*                                                'END_VALI'            *
*                                                'PRG_VERS'            *
*                                                'FLAGS   '            *
*                                                'INS_TIME'            *
*                                                                      *
*   Called by user,   DBCRSD, DBENTR, DBFZUP, DBOUT,  DBREPL, DBVOUT,  *
*             DBCRDR                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 41 : CHFOR for DB system keys declared wrongly by    *
*                      user                                            *
*               = 42 : CHTAG for DB system keys declared wrongly by    *
*                      user                                            *
*               = 43 : Too many key elements                           *
*               = 44 : Cannot find the top directory name              *
*                      (wrong initialisation)                          *
*               = 45 : Illegal Path name                               *
*               = 46 : Top directory name in the Path name does not    *
*                      match with the Top directory name               *
*               = 47 : The Directory already exists                    *
*               = 48 : Error in directory search sequence              *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DLINKS.
      CHARACTER       CHFOR*(*), PATHN*(*)
      CHARACTER       PATH*80, PATHX*80, PATHL*80, CHTMP*8
      CHARACTER*(*)   CHTAG(*)
*
*     ------------------------------------------------------------------
*
* *** Check on format and tags of the DB system keys
*
      PATHL  = ' '
      IF (CHFOR(1:NSYSDK) .NE. CHFTDK(1:NSYSDK)) GO TO 991
      DO 5 I = 1, NSYSDK
        IF (CHTAG(I) .NE. CHTGDK(I))             GO TO 992
    5 CONTINUE
      IF (NWKEY.GT.MXDMDK.OR.NWKEY.LT.NSYSDK)    GO TO 993
*
* *** Find the Top Directory name
*
      CALL RZCDIR (PATHX, 'R')
*
      IF (IQUEST(1).EQ.0)  THEN
*
*  **   From Current directory
*
        I0     = 0
        MAXL   = MAXLDB
   10   I1     = I0 + 1
        IF (I1.GT.MAXL)                          GO TO 994
        DO 15 I0 = I1, MAXL
          IF (PATHX(I0:I0).EQ.' ')               GO TO 25
          IF (PATHX(I0:I0).EQ.'/')               GO TO 20
   15   CONTINUE
        I0     = MAXL + 1
   20   I2     = I0 - 1
        GO TO 30
   25   I2     = I0 - 1
        I0     = MAXL + 1
   30   IF (I2.LT.I1)                            GO TO 10
        NCHAR  = I2 - I1 + 1
        TOPNDI = PATHX(I1:I2)
*
      ELSE IF (LTOPDB.NE.0)  THEN
*
*  **   From the name stored at the first DBINIT call
*
        NCHAR  = IQ(KOFUDB+LTOPDB+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOPDB+MUPNAM), 4, PATHX, NCHAR)
        PATHX  = PATHX(1:NCHAR)
        TOPNDI = PATHX
*
      ELSE
*
*  **   Fatal error
*
        GO TO 994
*
      ENDIF
*
* *** Remove imbedded blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCH)
      IF (NCH.EQ.0)                              GO TO 995
*
* *** Get the complete path name
*
      IF (PATH(1:2).EQ.'//')  THEN
*
*  **   Check if the Top directory name matches
*
        LTOP   = LTOPDB
   45   IF (LTOP.NE.0) THEN
          NCHR   = IQ(KOFUDB+LTOP+MUPNCH)
          CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHR)
          IF (PATH(3:NCHAR+2).NE.TOPNDI(1:NCHR)) THEN
            LTOP   = LQ(KOFUDB+LTOP)
            GO TO 45
          ENDIF
        ELSE
          GO TO 996
        ENDIF
*
      ELSE IF (PATH(1:1).EQ.'/') THEN
        PATH   = '//'//TOPNDI(1:NCHAR)//PATH
        NCH    = NCH + NCHAR + 2
*
+SELF, IF=APOLLO, CRAY, IBM, VAX.
      ELSE IF (PATH(1:1).EQ.'\') THEN
+SELF, IF=HPUX, IBMRT, MIP.
      ELSE IF (PATH(1:1).EQ.'\\') THEN
+SELF.
        IL     = 0
        DO 50 I0 = 1, MAXLDB
          IF (PATHX(I0:I0).EQ.'/') IL = I0
   50   CONTINUE
        IF (IL.LE.1)                             GO TO 995
        PATH   = PATHX(1:IL-1)//'/'//PATH(2:NCH)
        NCH    = IL + NCH - 1
*
      ELSE IF (PATH(1:1).EQ.'~' .OR. PATH(1:1).EQ.'_') THEN
*
        CALL RZNDIR (PATHX, 'R')
        IF (IQUEST(1).NE.0)                      GO TO 994
        IL     = 0
        DO 55 I0 = 1, MAXLDB
          IF (PATHX(I0:I0).NE.' ') IL = I0
   55   CONTINUE
        IF (IL.LE.1)                             GO TO 995
        PATH   = PATHX(1:IL)//'/'//PATH(2:NCH)
        NCH    = IL + NCH
*
      ELSE
*
        IL     = 0
        DO 60 I0 = 1, MAXLDB
          IF (PATHX(I0:I0).NE.' ') IL = I0
   60   CONTINUE
        IF (IL.LE.1)                             GO TO 995
        PATH   = PATHX(1:IL)//'/'//PATH(1:NCH)
        NCH    = IL + NCH + 1
      ENDIF
*
* *** Check if the directory exists as yet
*
      IENCH  = NCHAR + 1
      I      = NCHAR + 2
      IP     = NCHAR + 3
      IF (IP.LE.NCH) THEN
        CALL RZCDIR (PATH, ' ')
        IF (IQUEST(1).EQ.0) THEN
          IF (IOKYDA(MSERDB).EQ.0)               GO TO 997
          GO TO 999
        ENDIF
      ENDIF
*
* *** Save the Directory creation information in the FZ file
*
      CALL DBSDIR (PATH, NWKEY, CHFOR, CHTAG, 0, IOPP, IOPS)
      IF (IQUEST(1).NE.0)                        GO TO 999
      IF (IOPP.NE.0)                             GO TO 999
+SELF, IF=$P3CHILD.
      GO TO 999
+SELF, IF=-$P3CHILD.
*
* *** Create a new (tree of) director(ies) - from the first
* *** non-existing name
* *** Go down to the lowest existing directory in PATH
*
   65 I      = I + 1
      IF (PATH(I:I).EQ.'/')  THEN
        CALL RZCDIR (PATH(1:I-1), ' ')
        IF (IQUEST(1).NE.0)                      GO TO 68
        IENCH  = I -1
      ELSE IF (I.GE.NCH)  THEN
        CALL RZCDIR (PATH(1:I), ' ')
        IF (IQUEST(1).NE.0)                      GO TO 68
        GO TO 997
      ENDIF
      GO TO 65
*
* *** Lock the directory if needed
*
   68 IF (IOPS.NE.0) THEN
        PATHL  = PATH(1:IENCH)
        CALL RZCDIR (PATHL, ' ')
        CALL RZLOCK ('DBMDIR')
      ENDIF
*
* *** Create new directories
*
   70 ISTCH  = IENCH + 2
      IF (ISTCH.GT.NCH)                          GO TO 998
      PATHX  = PATH(ISTCH:ISTCH)
      J      = 0
      ISTCH  = ISTCH + 1
      I      = ISTCH
   75 CONTINUE
      IF (PATH(I:I).EQ.'/')  THEN
        CALL RZCDIR (PATH(1:IENCH), ' ')
*
*  **   Create the intermediate level directory with default values
*
        CALL RZMDIR (PATHX, NINEDK, CHFTDK, CHTGDK)
        IF (IQUEST(1).NE.0)                      GO TO 998
        IF (PATHL.NE.' ') THEN
          CALL RZCDIR (PATHL, ' ')
          CALL RZFREE ('DBMDIR')
          PATHL  = ' '
          CALL RZCDIR (PATH(1:IENCH), ' ')
        ENDIF
        CALL DBCDIC (PATHX)
        IF (IQUEST(1).NE.0)                      GO TO 9981
        IF (IOPS.NE.0) THEN
          PATHL  = PATH(1:IENCH)
          CALL RZCDIR (PATHL, ' ')
          CALL RZLOCK ('DBMDIR')
        ENDIF
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')
+SELF, IF=-$P3CHILD.
        IENCH  = I - 1
        I      = I + 1
        PATHX  = PATH(I:I)
        J      = 0
*
      ELSE
        J      = J + 1
        PATHX  = PATHX(1:J)//PATH(I:I)
      ENDIF
      IF (I.LT.NCH)  THEN
        I      = I + 1
        GO TO 75
      ENDIF
*
      IF (IENCH.GE.0) CALL RZCDIR (PATH(1:IENCH),' ')
      CALL RZMDIR (PATHX, NWKEY, CHFOR, CHTAG)
      IF (IQUEST(1).NE.0)                        GO TO 998
      IF (PATHL.NE.' ') THEN
        CALL RZCDIR (PATHL, ' ')
        CALL RZFREE ('DBMDIR')
        PATHL  = ' '
        IF (IENCH.GE.0) CALL RZCDIR (PATH(1:IENCH), ' ')
      ENDIF
      CALL DBCDIC (PATHX)
      IF (IQUEST(1).NE.0)                        GO TO 9981
+SELF, IF=$DEBUG, IF=-$P3CHILD.
      IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')
+SELF, IF=-$P3CHILD.
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0)                        GO TO 998
      GO TO 9981
+SELF.
*
* *** Error Messages
*
  991 IQUEST(1) = 41
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) THEN
        CHTMP  = CHFOR(1:NSYSDK)
        CALL DBPRNT (LPRTDB, '(/,'' DBMDIR : The system characters fo'//
     +       'r CHFOR '//CHTMP//' does not conform with the default '//
     +       CHFTDK(1:NSYSDK)//''')', IARGDB, 0)
      ENDIF
+SELF.
      GO TO 999
*
  992 IQUEST(1) = 42
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) THEN
        CALL DBPRNT (LPRTDB, '(/,'' DBMDIR : The system tags for CHTA'//
     +       'G does not conform with defaults '')', IARGDB, 0)
        DO 9921 I = 1, NSYSDK
          CHTMP = CHTAG(I)
          CALL DBPRNT (LPRTDB, '(10X,''Key '',I2,'' Supplied '//CHTMP//
     +         ' Default '//CHTGDK(I)//''')', I, 1)
 9921   CONTINUE
      ENDIF
+SELF.
      GO TO 999
*
  993 IQUEST(1) = 43
      IQUEST(11)= NWKEY
      IQUEST(12)= MXDMDK
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIR : Too many '//
     +   'key elements requested = '',I6,'' maximum permitted '',I5)',
     +   IQUEST(11), 2)
+SELF.
      GO TO 999
*
  994 IQUEST(1) = 44
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIR : Cannot fi'//
     +   'nd the top directory '')', IARGDB, 0)
+SELF.
      GO TO 999
*
  995 IQUEST(1) = 45
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIR : Illegal '//
     +   'path name '//PATHX//''')', IARGDB, 0)
+SELF.
      GO TO 999
*
  996 IQUEST(1) = 46
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIR : Top direc'//
     +   'tory name in path name '//PATHX//''',/,''          does not'//
     +   ' match with '//TOPNDI//''')', IARGDB, 0)
+SELF.
      GO TO 999
*
  997 IQUEST(1) = 47
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIR : Existing '//
     +   'directory is in conflict with Path name '',/,9X,'' '//PATH//
     +   ' '')', IARGDB, 0)
+SELF.
      GO TO 999
+SELF, IF=-$P3CHILD.
*
  998 IQUEST(1) = 48
      IQUEST(11)= ISTCH
      IQUEST(12)= NCH
+SELF, IF=$DEBUG, IF=-$P3CHILD.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBMDIR : Error in '//
     +   'Directory Search - ISTCH = '',I5,'' NCH = '',I5)', IQUEST(11),
     +   2)
+SELF, IF=-$P3CHILD.
*
* *** Unlock the directory if required
*
 9981 IF (PATHL.NE.' ') THEN
        IERR   = IQUEST(1)
        CALL RZCDIR (PATHL, ' ')
        CALL RZFREE ('DBMDIR')
        IQUEST(1) = IERR
      ENDIF
+SELF.
*                                                             END DBMDIR
  999 END
+DECK, DBNTOP.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBNTOP (PATHI, PATHO, MXKP0, NSAV, CHOPT)
*     ====================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBNTOP (PATHI, PATHO, MXKP0, NSAV, CHOPT)               *
*                                                                      *
*   Transforms the contents of a non-partitioned directory to a        *
*   partitioned directory.                                             *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHI    Character string describing the input  pathname         *
*     PATHO    Character string describing the output pathname         *
*     MXKP0    Maximum number of objects in the partitioned directory  *
*     NSAV     Maximum number of objects to be entered in one go       *
*              (default is 20)                                         *
*     CHOPT    Character string with any of the following characters   *
*          B   Save in the special backup file; not in standard Journal*
*          F   Updates with a fully matched data object (in user keys) *
*                                                                      *
*   Called by user,   DBACTI                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 68 : Input directory is partitioned                  *
*               = 71 : Illegal path name                               *
*               = 73 : RZOUT fails to write on disk                    *
*               = 74 : Error in RZRENK in updating key values for      *
*                      partitioned data set                            *
*               = 75 : Cannot find the Top directory name in pathname  *
*               = 76 : Cannot form the IO descriptor for the FZ header *
*               = 77 : FZOUT fails to write on to the sequential file  *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DSAVBK.
+CDE, DZPACK.
+CDE, P3DBL3, IF=$P3CHILD.
      PARAMETER       (NLEVM=20)
      INTEGER         NLCUR(NLEVM)
      DIMENSION       KEYO(MXDMDK), KEYN(MXDMDK)
      CHARACTER       PATHY*80, PATH*80, PATHX*16, CHFOR*100, CFORM(6)*1
      CHARACTER       CHCUR(NLEVM)*1, TOPN*16, CHOPS(NSVMDS)*4, CHOP0*4
      CHARACTER       PATHI*(*), PATHO*(*), CHOPT*(*), CHOP*1, CHFRM*100
      DATA            CFORM /'B', 'I', 'F', 'D', 'H', 'A'/
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Suppress blanks from the path name
*
      CALL DBOPTS (' ')
      CALL UOPTC  (CHOPT, 'B', IOPBDA)
      CALL UOPTC  (CHOPT, 'F', IOPFDA)
      CALL DBSBLC (PATHI, PATH, NCHRI)
      CALL DBSBLC (PATHO, PATHY, NCHAR)
      IF (NSAV.GT.0) THEN
        NSAVM  = MIN0 (NSAV, NSVMDS)
      ELSE
        NSAVM  = NSAVDS
      ENDIF
*
* *** Set the current directory for input path name
*
      PATHX  = ' '
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 71
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Illegal'//
     +  ' Path Name '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      KST    = NWKYDK + 1
      NWKEY  = NWKYDK
      CALL RZCDIR (PATH, 'R')
      CALL DBKYTG
      IF (NKEYDK.NE.0)  THEN
        IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)
        IOPTP  = JBIT (IOPTP, JPRTDB)
      ELSE
        IOPTP  = 0
      ENDIF
      IF (IOPTP.NE.0) THEN
        IQUEST(1) = 68
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Directo'//
     +  'ry '//PATH//' is partitioned '')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Prepare the partitioned directory
*
      NKEYS  = NKEYDK
      CHFOR  = ' '
      DO 10 IK = 1, NWKEY
        IF (IOTYDK(IK).GT.0.AND.IOTYDK(IK).LT.7) THEN
          CHFOR(IK:IK) = CFORM(IOTYDK(IK))
        ELSE
          CHFOR(IK:IK) = CFORM(2)
        ENDIF
   10 CONTINUE
      CALL DBMDIP (PATHY, NWKEY, CHFOR, CTAGDK, MXKP0)
      IF (IQUEST(1).NE.0)          GO TO 999
      IF (NKEYS.LE.0)              GO TO 999
*
* *** Extract the Top level directory name
*
      CALL RZCDIR (PATHY, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 71
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Illegal'//
     +  ' Path Name '//PATHY//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL RZCDIR (PATHY, 'R')
      NCHAR  = LENOCC (PATHY)
      NCHRT  = INDEX  (PATHY(3:NCHAR), '/') - 1
      IF (NCHRT.LE.0) NCHRT = NCHAR - 2
      TOPN   = PATHY(3:NCHRT+2)
      IF (NCHRT.EQ.0) THEN
        IQUEST(1) = 75
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : No top '//
     +  'directory for '//PATHY//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Find the appropriate FZ file number
*
      LTOP   = LTOPDB
+SELF, IF=-$SERVER, CRAY.
      IOPP   = 0
+SELF.
   15 IF (LTOP.NE.0) THEN
        NCH    = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCH)
        TOPNDI = TOPNDI(1:NCH)
        IF (TOPN.EQ.TOPNDI) THEN
          IF (IOPBDA.EQ.0) THEN
            LUFZDF = IQ(KOFUDB+LTOP+MUPJFL)
          ELSE
            LUFZDF = IQ(KOFUDB+LTOP+MUPBAK)
          ENDIF
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10)
+SELF.
        ELSE
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 15
        ENDIF
      ELSE
        LUFZDF = 0
        IOPS   = 0
        IOUT   = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        IOPP   = 0
+SELF.
      ENDIF
      IF (IOUT.EQ.0.OR.IOPP.NE.0) IOPS = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
      IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
        LUFZDF = LUFMDB
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
        CALL DBSTSV (TOPN, 0)
        IF (IQUEST(1).NE.0)        GO TO 999
+SELF, IF=$P3CHILD.
        LUFZDF = LODBP3
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
      ENDIF
+SELF.
*
* *** Partially fill up the header
*
      IF (LUFZDF.GT.0) THEN
        NDOP   = 1
        NCHR   = LENOCC (PATHY)
        NWDP   = (NCHR + 3) / 4
        NWDH   = NWDP + NDOP + NWKYDK + 5
        IHEADF(MACTDF) = 1
        IHEADF(MNKYDF) = NWKYDK
        IHEADF(MOPTDF) = NDOP
        IHEADF(MPATDF) = NWDP
        CALL UCTOH (PATHY, IHEADF(NWKYDK+NDOP+MPREDF+1), 4, 4*NWDP)
      ENDIF
*
* *** Start reading in records from the input file
*
      ISTR   = 0
      ITIME  = 1
      JBIAS  = 2
   20 NOBJDS = 0
      IOPKDA = 0
      PACKDZ = .FALSE.
      CALL RZCDIR (PATH, ' ')
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      DO 25 IK = 1, NSAVM
        ISTR   = ISTR + 1
        IF (ISTR.LE.NKEYS) THEN
          NOBJDS = NOBJDS + 1
          KEYSDS(MSERDB,NOBJDS) = ISTR
          IOKYDA(MSERDB) = 1
          CALL DBKXIN (ITIME, IDISDB, LOBJDS(NOBJDS), LOBJDS(NOBJDS),
     +                 JBIAS, NWKEY, KEYSDS(1,NOBJDS), IPREC)
          IOKYDA(MSERDB) = 0
          IF (IQUEST(1).NE.0)      GO TO 997
          IF (JBIT(KEYSDS(MFLGDB,NOBJDS),JRZUDB).NE.0) THEN
            IF (JBIT(KEYSDS(MFLGDB,NOBJDS),JASFDB).NE.0) THEN
              CHOPS(NOBJDS) = '7RT'
            ELSE
              CHOPS(NOBJDS) = '7R'
            ENDIF
          ELSE
            CALL DBRZIN (IDISDB, LSTRDL(2), 2, ISTR, ICYCL, PATH)
            IF (IQUEST(1).NE.0) THEN
              IER       = IQUEST(1)
              CALL MZDROP (IDISDB, LSTRDL(2), 'L')
              IQUEST(1) = IER
              GO TO 997
            ENDIF
            CALL UCOPY (Q(KOFUDB+LSTRDL(2)+3), IXX, 1)
            IF (IQ(KOFUDB+LSTRDL(2)+1).EQ.0) THEN
              IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN
                CHOPS(NOBJDS) = '7SU'
              ELSE
                CHOPS(NOBJDS) = '7U'
              ENDIF
            ELSE
              PACKDZ = (JBIT(IXX,32).EQ.0)
              IF (PACKDZ) THEN
                IDTY   = IDBTYP (LSTRDL(2))
                IF (IDTY.EQ.3) THEN
                  PRECDZ =  Q(KOFUDB+LSTRDL(2)+2)
                ELSE
                  PRECDZ = IQ(KOFUDB+LSTRDL(2)+2)
                ENDIF
                IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN
                  CHOPS(NOBJDS) = '7ZS'
                ELSE
                  CHOPS(NOBJDS) = '7Z'
                ENDIF
              ELSE
                IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN
                  CHOPS(NOBJDS) = '7S'
                ELSE
                  CHOPS(NOBJDS) = '7'
                ENDIF
              ENDIF
            ENDIF
            CALL MZDROP (IDISDB, LSTRDL(2), 'L')
          ENDIF
        ENDIF
   25 CONTINUE
*
* *** Set the current directory to the output directory
*
      CALL RZCDIR (PATHY, ' ')
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                 NKEYDK*KST, KST)
      IF (KPNT.NE.0) THEN
        NK     = (KPNT - MPSRDB) / KST + 1
      ELSE
        NK     = NKEYDK
      ENDIF
      CALL DBKEYR (NK, NWKYDK, KEYO)
      KOBJ   = KEYO(MOBJDB)
      MXKP   = KEYO(MXKPDB)
      NWKYS  = NWKYDK
      CALL UCOPY (KEYO, KEYN, NWKYDK)
*
      CALL DBPATH (PATHX, NKEYDK)
      CALL RZCDIR (PATHX, ' ')
      IF (IQUEST(1).NE.0)          GO TO 991
      NKEYDK = IQUEST(7)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
*
* *** Get the Serial number of the last object inserted
*
      LOBJ   = KOBJ
      IF (NKEYDK.GT.0) THEN
        DO 30 IK = 1, NKEYDK
          IP     = KOFSDB + LCDRDB + IKDRDB + (IK-1)*KST + MSERDB
          IF (IQ(IP).GT.LOBJ) LOBJ = IQ(IP)
   30   CONTINUE
      ENDIF
      NINS   = NKEYDK
*
* *** Loop over all the objects
*
      DO 50 IOBJ = 1, NOBJDS
        LOBJ   = LOBJ + 1
        NINS   = NINS + 1
        CHOP0  = CHOPS(IOBJ)
*
*  **   Fill up Key vectors 1,2
*
        KEYSDS(1,IOBJ) = LOBJ
        KEYSDS(MUPNDB,IOBJ) = 0
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
*
        IF (IOPP.NE.0) THEN
          CALL DBWLOK
          IF (IQUEST(1).NE.0)      GO TO 999
        ENDIF
+SELF.
*
*  **   Write the sequential output if needed
*
        IF (LUFZDF.GT.0) THEN
          NLEV   = 1
          NCUR   = 5
          IFORO  = 2
          CHCUR(NLEV) = CFORM(IFORO)
          IF (INDEX(CHOP0,'Z').NE.0) THEN
            NLCUR(NLEV) = 4
            IFORO  = 3
            NCUR   = 1
            NLEV   = NLEV + 1
            CHCUR(NLEV) = CFORM(IFORO)
            CALL UCOPY (PRECDZ, IHEADF(MPREDF), 1)
          ELSE
            IHEADF(MPREDF) = IPREC
          ENDIF
          DO 40 I = 1, NWKYDK
            IFORM  = IOTYDK(I)
            IF (IFORM.EQ.6) IFORM = 5
            IF (IFORM.EQ.IFORO) THEN
              NCUR   = NCUR + 1
            ELSE
              NLCUR(NLEV) = NCUR
              IF (NLEV.GE.NLEVM) THEN
                IQUEST(1) = 76
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNTOP :'//
     +          ' Cannot get IO descriptor '//PATHY//''')', IARGDB, 0)
+SELF.
                GO TO 995
              ENDIF
              NLEV   = NLEV + 1
              CHCUR(NLEV) = CFORM(IFORM)
              NCUR   = 1
              IFORO  = IFORM
            ENDIF
   40     CONTINUE
          NLCUR(NLEV) = NCUR
+SELF, IF=-IBM, -$P3CHILD.
          WRITE (CHFRM, 2001) (NLCUR(I), CHCUR(I), I = 1, NLEV)
+SELF, IF=IBM, IF=$P3CHILD.
          CHFRM = ' '
          II    = 1
          DO 41 I = 1, NLEV
            CALL UTWRIT (CHFRM(II:II+1), '(I2)', NLCUR(I))
            II     = II + 2
            CHFRM(II:II) = CHCUR(I)
            II     = II + 2
   41     CONTINUE
+SELF.
          II     = 4 *NLEV
          CHFRM = CHFRM(1:II)//' -H'
          CALL MZIOCH (IOFMDF, NWFMDF, CHFRM(1:II+3))
          CALL UCTOH (CHOP0, IHEADF(NWKYDK+MPREDF+1), 4, 4*NDOP)
          CALL UCOPY (KEYSDS(1,IOBJ), IHEADF(MPREDF+1), NWKYDK)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          IF (IOPP.NE.0) IHEADF(MPREDF+MSERDB) = 0
+SELF, IF=$P3CHILD.
          RNDBP3 = 'DBNTOP '
          NWDBP3 = 2
          CALL UCTOH ('JOURNAL ', IWDBP3, 4, 8)
          CALL DBCHLD
          IQUEST(1) = IQDBP3
          IF (IQUEST(1).NE.0)      GO TO 995
+SELF.
          CALL FZOUT (LUFZDF, IDISDB, LOBJDS(IOBJ), 1, 'L', IOFMDF,
     +                NWDH, IHEADF)
          IF (IQUEST(1).NE.0) THEN
            IQUEST(1)  = 77
            IQUEST(11) = IOBJ
            IQUEST(12) = NOBJDS
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Err'//
     +      'or in FZOUT while writing Data for '',2I12)', IQUEST(11),2)
+SELF.
            GO TO 995
          ENDIF
        ENDIF
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
        IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
          CALL DBCWSV
          IF (IQUEST(1).NE.0)      GO TO 997
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          GO TO 50
        ENDIF
+SELF, IF=-$P3CHILD.
*
*  **   Make a different subdirectory if there are too many keys
*
        IF (NINS.GT.MXKP) THEN
          CALL RZCDIR (PATHY, ' ')
          PATHX  = ' '
          IF (IQUEST(1).NE.0)      GO TO 991
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          NKEYDK = IQUEST(7)
*
*  **     Rename Keys 3 and 4 of the latest subdirectory
*
          IF (IOPS.NE.0) CALL RZLOCK ('DBNTOP')
          CALL RZRENK (KEYO, KEYN)
          IERR   = IQUEST(1)
          IF (IOPS.NE.0) CALL RZFREE ('DBNTOP')
          IF (IERR.NE.0) THEN
            IQUEST(1) = 74
+SELF, IF=$DEBUG, IF=-$P3CHILD.
            IF (IDEBDB.GT.0) THEN
              CALL UCOPY (KEYO, IARGDB(1),        NSYSDK)
              CALL UCOPY (KEYN, IARGDB(NSYSDK+1), NSYSDK)
              CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Error in RZRENK '//
     +             'while writing data for '//PATHY//''',/(10X,7I12))',
     +             IARGDB, 2*NSYSDK)
            ENDIF
+SELF, IF=-$P3CHILD.
            GO TO 997
          ENDIF
*
*  **     Make a different subdirectory if there are too many keys
*
          KEY7DK = KEYSDS(MITMDB,IOBJ)
          CALL DBMDIP (PATHY, NWKYS, CHFOR, CTAGDK, MXKP)
          IF (IQUEST(1).NE.0)      GO TO 997
          CALL RZCDIR (PATHY, ' ')
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                     NKEYDK*KST, KST)
          IF (KPNT.NE.0) THEN
            NK     = (KPNT - MPSRDB) / KST + 1
          ELSE
            NK     = NKEYDK
          ENDIF
          CALL DBKEYR (NK, NWKYDK, KEYO)
          CALL DBPATH (PATHX, NKEYDK)
          CALL RZCDIR (PATHX, ' ')
          IF (IQUEST(1).NE.0)      GO TO 991
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          NINS   = NKEYDK + 1
          CALL UCOPY (KEYO, KEYN, NWKYDK)
        ENDIF
*
        IDB    = IDBTYP (LOBJDS(IOBJ))
        IF (IDB.EQ.2.OR.IDB.EQ.3) THEN
          IOPTR  = 0
        ELSE
          IOPTR  = 1
        ENDIF
*
        IF (IOPS.NE.0) CALL RZLOCK ('DBNTOP')
        IF (JBIT(KEYSDS(MFLGDB,IOBJ),JRZUDB).NE.0. OR. IOPTR.NE.0) THEN
*
*  **     RZ mode output
*
          IF (JBIT(KEYSDS(MFLGDB,IOBJ),JASFDB).NE.0) THEN
            CHOP   = 'S'
          ELSE IF (JBIT(KEYSDS(MFLGDB,IOBJ),JRZUDB).NE.0) THEN
            CHOP   = 'L'
          ELSE
            CHOP   = ' '
          ENDIF
*
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')
+SELF, IF=-$P3CHILD.
          CALL RZOUT (IDISDB, LOBJDS(IOBJ), KEYSDS(1,IOBJ), ICYCLE,CHOP)
*
        ELSE
*
*  **     Copy data to DB internal store
*
*  **     0 Data word : do not pack
*
          IF (IQ(KOFUDB+LOBJDS(IOBJ)-1).EQ.0 .OR. INDEX(CHOP0,'U').NE.0)
     +                                                              THEN
            IOPUDA = 1
          ELSE
            IOPUDA = 0
          ENDIF
          CALL DBFRUS (LOBJDS(IOBJ), LSTRDL(1), IPREC)
          IF (IQUEST(1).NE.0)      GO TO 995
*
*  **     Compress the data if requested
*
          IF (IOPUDA.NE.0)  THEN
            LREFDL(1) = LSTRDL(1)
          ELSE
            IF (INDEX(CHOP0,'S').NE.0) THEN
              IOPSDA = 1
            ELSE
              IOPSDA = 0
            ENDIF
            IF (INDEX(CHOP0,'Z').NE.0) THEN
              PACKDZ = .TRUE.
            ELSE
              PACKDZ = .FALSE.
            ENDIF
            NOLD   = NKEYDK
            NKEYDK = NINS - 1
            CALL DBCOMP (LSTRDL(1), LREFDL(1), KEYSDS(1,IOBJ))
            NKEYDK = NOLD
          ENDIF
          IF (IQUEST(1).NE.0)      GO TO 995
*
*  **     Drop the uncompressed data
*
          IF (LREFDL(1).NE.LSTRDL(1)) CALL MZDROP (IDISDB,LSTRDL(1),'L')
*
*  **     Write on to disk
*
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')
+SELF, IF=-$P3CHILD.
          CALL RZOUT (IDISDB, LREFDL(1), KEYSDS(1,IOBJ), ICYCLE, 'S')
          IER    = IQUEST(1)
          CALL MZDROP (IDISDB, LREFDL(1), 'L')
          IQUEST(1) = IER
        ENDIF
*
        IF (IOPS.NE.0) THEN
          IER    = IQUEST(1)
          CALL RZFREE ('DBNTOP')
          IQUEST(1) = IER
        ENDIF
*
        KEYN(MBVRDB) = MIN0 (KEYN(MBVRDB), KEYSDS(MBVRDB,IOBJ))
        KEYN(MEVRDB) = MAX0 (KEYN(MEVRDB), KEYSDS(MEVRDB,IOBJ))
        IF (IQUEST(1).NE.0)        GO TO 993
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.1) THEN
          CALL UCOPY (KEYSDS(1,IOBJ), KEYNDK, NWKYDK)
          CALL DBUPTM (IARGDB(1), IARGDB(2), KEYNDK(MITMDB))
          CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Data was inserted into'//
     +         '   '//PATHY//''',/,10X,''on the '',I8,'' at '',I6,'' '//
     +         'with Key-Vector '')', IARGDB, 2)
          CALL DBKEYT
          CALL DBPRKY (NWKYDK, KEYNDK, IOTYDK)
        ENDIF
+SELF.
   50 CONTINUE
      IF (ISTR.GE.NKEYS)           GO TO 995
      DO 60 IOBJ = 1, NOBJDS
        IF (LOBJDS(IOBJ).NE.0) CALL MZDROP (IDISDB, LOBJDS(IOBJ), 'L')
   60 CONTINUE
*
*  ** Rename Keys 3 and 4 of the latest subdirectory
*
+SELF, IF=$SERVER, IF=-$P3CHILD.
      IF (IOPP.EQ.0) THEN
+SELF, IF=-$P3CHILD.
        CALL RZCDIR (PATHY, ' ')
        PATHX  = ' '
        IF (IQUEST(1).NE.0)        GO TO 991
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        NKEYDK = IQUEST(7)
        IF (IOPS.NE.0) CALL RZLOCK ('DBNTOP')
        CALL RZRENK (KEYO, KEYN)
        IERR   = IQUEST(1)
        IF (IOPS.NE.0) CALL RZFREE ('DBNTOP')
        IF (IERR.NE.0) THEN
          IQUEST(1) = 74
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.0) THEN
            CALL UCOPY (KEYO, IARGDB(1),        NSYSDK)
            CALL UCOPY (KEYN, IARGDB(NSYSDK+1), NSYSDK)
            CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Error in RZRENK '//
     +           'while writing data for '//PATHY//''',/(10X,7I12))',
     +           IARGDB, 2*NSYSDK)
          ENDIF
+SELF, IF=-$P3CHILD.
          GO TO 997
        ENDIF
+SELF, IF=$SERVER, IF=-$P3CHILD.
      ENDIF
+SELF.
      GO TO 20
*
* *** Error messages
*
  991 IQUEST(1) = 71
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Illegal '//
     +   'Path Name '//PATHY//PATHX(1:8)//''')', IARGDB, 0)
+SELF.
      GO TO 997
+SELF, IF=-$P3CHILD.
*
  993 IQUEST(1) = 73
+SELF, IF=$DEBUG, IF=-$P3CHILD.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Error in '//
     +   'RZOUT while writing Data for '//PATHY//PATHX(1:8)//''')',
     +   IARGDB, 0)
+SELF.
*
  995 IER   = IQUEST(1)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
      IF (IOPP.NE.0) THEN
        IQUEST(1) = IER
        GO TO 997
      ENDIF
+SELF, IF=-$P3CHILD.
      IF (NINS.GT.0)  THEN
        CALL RZCDIR (PATHY, ' ')
        IF (IQUEST(1).NE.0) THEN
          IF (IER.EQ.0) THEN
            GO TO 991
          ELSE
            IQUEST(1) = IER
          ENDIF
        ELSE
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          NKEYDK = IQUEST(7)
          IQUEST(1) = IER
*
*  **     Rename Keys 3 and 4 of the latest subdirectory
*
          IF (IER.EQ.0) THEN
            IF (IOPS.NE.0) CALL RZLOCK ('DBNTOP')
            CALL RZRENK (KEYO, KEYN)
            IERR   = IQUEST(1)
            IF (IOPS.NE.0) CALL RZFREE ('DBNTOP')
            IF (IERR.NE.0) THEN
              IQUEST(1) = 74
+SELF, IF=$DEBUG, IF=-$P3CHILD.
              IF (IDEBDB.GT.0) THEN
                CALL UCOPY (KEYO, IARGDB(1),        NSYSDK)
                CALL UCOPY (KEYN, IARGDB(NSYSDK+1), NSYSDK)
                CALL DBPRNT (LPRTDB, '(/,'' DBNTOP : Error in RZRENK '//
     +               'while writing data for '//PATHY//''',/(10X,7I12))'
     +,              IARGDB, 2*NSYSDK)
              ENDIF
+SELF, IF=-$P3CHILD.
            ENDIF
          ENDIF
        ENDIF
      ENDIF
+SELF.
*
* *** Drop the stored banks
*
  997 IER    = IQUEST(1)
      IF (NOBJDS.GT.0) THEN
        DO 998 IOBJ = 1, NOBJDS
          CALL MZDROP (IDISDB, LOBJDS(IOBJ), 'L')
  998   CONTINUE
        NOBJDS = 0
        IQUEST(1) = IER
      ENDIF
+SELF, IF=-IBM, -$P3CHILD.
*
 2001 FORMAT (20(I2,A1,1X))
+SELF.
*                                                             END DBNTOP
  999 END
+DECK, DBOUT.
      SUBROUTINE DBOUT (PATHN, IVSTR, IVEND, LSUP, IPRVS, NKEXT, KEYXT,
     +                  IPREC, CHOPT)
*     =================================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBOUT (PATHN, IVSTR, IVEND, LSUP, IPRVS, NKEXT, KEYXT,  *
*                     IPREC, CHOPT)                                    *
*                                                                      *
*   Stores data from a ZEBRA bank to disk creating simultaneousely     *
*   the directories if needed                                          *
*   Restrictions : Only directories upto 9 keys can be created and     *
*                  keys should be of type INTEGER                      *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     IVSTR    Start of validity period                                *
*     IVEND    End of validity period                                  *
*     LSUP     Address of bank in memory where data reside             *
*     IPRVS    Version number of program used for creating the data    *
*     NKEXT    Number of extra keys (Beyond key 5)                     *
*     KEYXT    Vector of extra keys                                    *
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *
*              IPREC significant digits right to the decimal points; if*
*              IPREC < 0, data are stored with IPREC insignificant     *
*              digits left to the decimal point.)                      *
*     CHOPT    Character string with any of the following characters   *
*          F   Updates with a fully matched data object (in user keys) *
*          N   Create new (sub)directory(ies)                          *
*          P   Create partitioned subdirectories for the pathname      *
*          R   Store with full RZ option (No compression to be made)   *
*          S   Create stand alone (master) data                        *
*          U   Store data uncompressed                                 *
*          Z   Store only nonzero elements. An element is considered to*
*              be zero if its absolute value is less than IPREC (real) *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 62 : Too many external keys with option N            *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DZPACK.
      DIMENSION       KEYXT(9), LSUP(9)
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80
*
*     ------------------------------------------------------------------
*
* *** Decode the character option
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)   GO TO 999
      PACKDZ = .FALSE.
*
      IF (IOPUDA.NE.0.AND.IOPZDA.NE.0)  THEN
        IOPZDA = 0
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBOUT : Warning '//
     +  '- Z option is incompatible with U option - U option will be '//
     +  'executed'')', IARGDB, 0)
+SELF.
*
      ELSE IF (IOPZDA.NE.0)  THEN
        PACKDZ = .TRUE.
        CALL UCOPY (IPREC, PRECDZ, 1)
      ENDIF
*
      IF (IOPRDA.NE.0.AND.IOPNDA.NE.0)  THEN
        IOPNDA = 0
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBOUT : Warning '//
     +  '- R option is incompatible with N option - R option will be '//
     +  'executed'')', IARGDB, 0)
+SELF.
      ENDIF
*
      IF (IOPNDA.NE.0.AND.NKEXT+5.GT.NINEDK)  THEN
        IQUEST(1) = 62
        IQUEST(11)= NKEXT
        IQUEST(12)= NINEDK - 5
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBOUT : Too many'//
     +  ' external keys '',I6,'' with option N - a maximum of '',I6'//
     +  ','' permitted'')', IQUEST(11), 2)
+SELF.
        GO TO 999
      ENDIF
*
* *** Prepare the Key vector array
*
      CALL VZERO (KEYVDK, MXDMDK)
      IF (NKEXT.GT.2) CALL UCOPY (KEYXT(3), KEYVDK(8), NKEXT-2)
      KEYVDK(MBVRDB) = IVSTR
      KEYVDK(MEVRDB) = IVEND
      KEYVDK(MPVSDB) = IPRVS
      IF (NKEXT.GE.0) THEN
        NTKEY  = NKEXT + 5
      ELSE
        NTKEY  = NINEDK
      ENDIF
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Create new subdirectories if needed
*
      IF (IOPNDA.NE.0)  THEN
        IF (IOPPDA.EQ.0)  THEN
          CALL DBMDIR (PATH, NTKEY, CHFTDK, CHTGDK)
        ELSE
          KEY7DK = 0
          CALL DBMDIP (PATH, NTKEY, CHFTDK, CHTGDK, MXKPDK)
        ENDIF
        IF (IQUEST(1).NE.0) GO TO 999
      ENDIF
*
* *** Write out the data
*
      CALL DBKOUT (PATH, IDIVDB, LSUP(1), NTKEY, KEYVDK, IPREC)
*                                                              END DBOUT
  999 END
+DECK, DBPKTM.
      SUBROUTINE DBPKTM (IDATE, ITIME, IDATM)
*     =======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBPKTM (IDATE, ITIME, IDATM*)                           *
*                                                                      *
*   Packs date and time into one word                                  *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDATE    Date : 6 Decimal integer : YYMMDD                       *
*     ITIME    Time : 4 Decimal integer : HHMM                         *
*     IDATM*   Packed date-time                                        *
*                                                                      *
*   Called by user,   DBDELT, DBEFOR, DBENTB, DBINIT, DBMDIP, DBPRGD,  *
*             DBCDIC, DBENFZ, DBKOUT, DBSDIR, DBSNAM, DBSPUR, DBUDIC,  *
*             DBPLOB, DBACPL, DBAUXI, DBDCKH, DBDCKV                   *
*                                                                      *
************************************************************************
*
+CDE, DTMPAK.
*     ------------------------------------------------------------------
*
      IMIN = MOD(ITIME,100)
      IHOU = ITIME/100
*
      IDAY = MOD(IDATE,100)
      IYEA = IDATE/100
      IMON = MOD(IYEA,100)
      IYEA = IYEA/100
*
      IDATM = IMIN
      MAXX = MXMIN
      IDATM = IDATM + MAXX*IHOU
      MAXX = MAXX*MXHOU
      IDATM = IDATM + MAXX*IDAY
      MAXX = MAXX*MXDAY
      IDATM = IDATM + MAXX*IMON
      MAXX = MAXX*MXMON
      IDATM = IDATM + MAXX*IYEA
*                                                             END DBPKTM
      END
+DECK, DBPKTS.
      SUBROUTINE DBPKTS (IDATE, ITIME, IDATM)
*     =======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBPKTS (IDATE, ITIME, IDATM*)                           *
*                                                                      *
*   Packs date and time into one word                                  *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDATE    Date : 6 Decimal integer : YYMMDD                       *
*              (Only Year > 80 allowed)                                *
*     ITIME    Time : 6 Decimal integer : HHMMSS                       *
*     IDATM*   Packed date-time                                        *
*                                                                      *
*   Called by user,   DBINIT, DBCDIC, DBSNAM, DBUDIC, DBPLNT, DBPLOB,  *
*             DBPLOV, DBPLTI, DBACPL, DBAUXI, DBDCKH, DBDCKV, DBVIEW   *
*                                                                      *
************************************************************************
*
+CDE, DTMPAK.
*     ------------------------------------------------------------------
*
      ISEC = MOD(ITIME,100)
      IHOU = ITIME/100
      IMIN = MOD(IHOU,100)
      IHOU = IHOU/100
*
      IDAY = MOD(IDATE,100)
      IYEA = IDATE/100
      IMON = MOD(IYEA,100)
      IYEA = IYEA/100 - 80
*
      IDATM = ISEC
      MAXX = MXSEC
      IDATM = IDATM + MAXX*IMIN
      MAXX = MAXX*MXMIN
      IDATM = IDATM + MAXX*IHOU
      MAXX = MAXX*MXHOU
      IDATM = IDATM + MAXX*IDAY
      MAXX = MAXX*MXDAY
      IDATM = IDATM + MAXX*IMON
      MAXX = MAXX*MXMON
      IDATM = IDATM + MAXX*IYEA
*                                                             END DBPKTS
      END
+DECK, DBPRGD.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBPRGD (PATHN, IKEEP, CHOPT)
*     =======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBPRGD (PATHN, IKEEP, CHOPT)                            *
*                                                                      *
*   Deletes partitions in a partitioned directory excpet the last      *
*   (first) few ones.                                                  *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     IKEEP    Number of partitions to be preserved                    *
*              (If -ve the last -IKEEP partitions deleted)             *
*     CHOPT    Character string with any of the following characters   *
*          B   Save in the special backup file; not in standard Journal*
*                                                                      *
*   Called by user,   DBFZUP, DBAUXI                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 69 : Input directory is not partitioned              *
*               = 70 : Error in deleting a partition                   *
*               = 71 : Illegal path name                               *
*               = 73 : RZOUT fails to write on disk                    *
*               = 74 : Error in RZRENK in updating key values for      *
*                      partitioned data set                            *
*               = 75 : Cannot find the Top directory name in pathname  *
*               = 77 : FZOUT fails to write on to the sequential file  *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DSAVBK.
+CDE, P3DBL3, IF=$P3CHILD.
      DIMENSION       KEYO(MXDMDK), KEYN(MXDMDK)
      CHARACTER       PATHY*80, PATH*80, PATHX*16, TOPN*16, PATHL*80
      CHARACTER       PATHN*(*), CHOPT*(*)
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Suppress blanks from the path name
*
      PATHL  = ' '
      CALL DBOPTS (' ')
      CALL UOPTC  (CHOPT, 'B', IOPBDA)
      CALL DBSBLC (PATHN, PATH, NCHAR)
      NKEEP  = IKEEP
      KEY7   = KEY7DK
      KEY7DK = 0
      IF (NKEEP.EQ.0) NKEEP = 1
      IF (KEY7.LE.0) THEN
        CALL DATIME (IDATE, ITIME)
        CALL DBPKTM (IDATE, ITIME, KEY7)
      ENDIF
*
* *** Set the current directory for input path name
*
      PATHX  = ' '
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 71
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Illeg'//
     +  'al Path Name '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      KST    = NWKYDK + 1
      CALL RZCDIR (PATH, 'R')
      NCHAR  = LENOCC (PATH)
      CALL DBKEYT
      IF (NKEYDK.NE.0)  THEN
        IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)
        IOPTP  = JBIT (IOPTP, JPRTDB)
      ELSE
        IOPTP  = 0
      ENDIF
      IF (IOPTP.EQ.0) THEN
        IQUEST(1) = 69
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Directo'//
     +  'ry '//PATH//' is not partitioned '')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      IF (NKEYDK.LE.NKEEP.AND.NKEEP.GT.0) THEN
        IQUEST(1) = 0
        GO TO 999
      ENDIF
*
* *** Extract the Top level directory name
*
      NCHRT  = INDEX  (PATH(3:NCHAR), '/') - 1
      IF (NCHRT.LE.0) NCHRT = NCHAR - 2
      TOPN   = PATH(3:NCHRT+2)
      IF (NCHRT.EQ.0) THEN
        IQUEST(1) = 75
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : No top '//
     +  'directory for '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Find the appropriate FZ file number
*
      LTOP   = LTOPDB
   10 IF (LTOP.NE.0) THEN
        NCH    = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCH)
        TOPNDI = TOPNDI(1:NCH)
        IF (TOPN.EQ.TOPNDI) THEN
          IF (IOPBDA.EQ.0) THEN
            LUFZDF = IQ(KOFUDB+LTOP+MUPJFL)
          ELSE
            LUFZDF = IQ(KOFUDB+LTOP+MUPBAK)
          ENDIF
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10)
+SELF.
        ELSE
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 10
        ENDIF
      ELSE
        LUFZDF = 0
        IOPS   = 0
        IOUT   = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        IOPP   = 0
+SELF.
      ENDIF
      IF (IOUT.EQ.0) IOPS = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
      IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
        CALL DBWLOK
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
        CALL DBSTSV (TOPN, 0)
+SELF, IF=$P3CHILD.
        IQUEST(1) = 0
        LUFZDF = LODBP3
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        IF (IQUEST(1).NE.0)                                  GO TO 999
      ENDIF
+SELF.
*
* *** Partially fill up the header
*
      IF (LUFZDF.GT.0) THEN
        IF (IOPBDA.EQ.0) THEN
          NDOP   = 0
        ELSE
          NDOP   = 1
        ENDIF
        NWDP   = (NCHAR + 3) / 4
        NWDH   = NDOP + NWDP + 6
        IHEADF(MACTDF) = 8
        IHEADF(MNKYDF) = 0
        IHEADF(MOPTDF) = NDOP
        IHEADF(MPATDF) = NWDP
        IHEADF(MDELDF) = KEY7
        IHEADF(MKEPDF) = NKEEP
        IF (NDOP.EQ.1) CALL UCTOH ('B   ', IHEADF(MKEPDF+1), 4, 4)
        CALL UCTOH (PATH, IHEADF(MKEPDF+NDOP+1), 4, 4*NWDP)
        CALL MZIOCH (IOFMDF, NWFMDF, '6I -H')
*
*  **   Now write on the sequential file
*
+SELF, IF=$P3CHILD.
        RNDBP3 = 'DBPRGD '
        NWDBP3 = 2
        CALL UCTOH ('JOURNAL ', IWDBP3, 4, 8)
        CALL DBCHLD
        IQUEST(1) = IQDBP3
        IF (IQUEST(1).NE.0)                                  GO TO 999
+SELF.
        CALL FZOUT (LUFZDF, IDISDB, 0, 1, 'Z', IOFMDF, NWDH, IHEADF)
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1)  = 77
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Error'//
     +    ' in FZOUT while writing Data for '//PATH//''')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
        IF (IOPP.NE.0) THEN
          IQUEST(1) = 0
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
          CALL DBCWSV
          IF (IQUEST(1).NE.0)                                GO TO 999
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          GO TO 999
        ENDIF
+SELF.
      ENDIF
+SELF, IF=-$P3CHILD.
*
* *** Check if the directory updated after KEY7
*
      NKEYS  = NKEYDK
      CALL DBPATH (PATHX, NKEYS)
      PATHY  = PATH(1:NCHAR)//'/'//PATHX
      CALL RZCDIR (PATHY, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 71
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Illeg'//
     +  'al Path Name '//PATHY//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      IF (IQ(KOFSDB+LCDRDB+IKDRDB+(NKEYDK-1)*KST+MITMDB).GT.KEY7)
     +                                                       GO TO 999
*
* *** Lock the directory in shared mode
*
      IF (IOPS.NE.0) THEN
        PATHL  = PATH(1:NCHAR)
        CALL RZCDIR (PATHL, ' ')
        CALL RZLOCK ('DBPRGD')
      ENDIF
      IF (NKEEP.LT.0)                                        GO TO 55
*
* *** Now delete all objects in the first few subdirectories
*
      DO 15 JKK = NKEEP+1, NKEYS
        IKK     = JKK - NKEEP
        CALL DBPATH (PATHX, IKK)
        PATHY   = PATH(1:NCHAR)//'/'//PATHX
        CALL RZCDIR (PATHY, ' ')
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1) = 71
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Illeg'//
     +    'al Path Name '//PATHY//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
          GO TO 998
        ENDIF
        NKEYDK = IQUEST(7)
        IF (NKEYDK.GT.0) CALL RZDELK (KDUM, ICDUM, 'K')
   15 CONTINUE
*
* *** Now transfer data from the last parttitions to the first
* *** NKEEP partitions
*
      NOBJDS = 0
      JBIAS  = 2
      DO 50 JKK = 1, NKEEP
        IKK    = NKEYS - NKEEP + JKK
        ISTR   = 0
*
*  **   Set the current directory to the input directory
*
   20   CALL DBPATH (PATHX, IKK)
        PATHY  = PATH(1:NCHAR)//'/'//PATHX
        CALL RZCDIR (PATHY, ' ')
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1) = 71
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Illeg'//
     +    'al Path Name '//PATHY//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
          GO TO 996
        ENDIF
        NKEYDK = IQUEST(7)
        NWKYDK = IQUEST(8)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        DO 25 IK = 1, NSVMDS
          ISTR   = ISTR + 1
          IF (ISTR.LE.NKEYDK) THEN
            NOBJDS = NOBJDS + 1
            KEYSDS(MSERDB,NOBJDS) = ISTR
            ICYCL  = 9999
            CALL DBRZIN (IDISDB, LOBJDS(NOBJDS), JBIAS, ISTR, ICYCL,
     +                   PATHY)
            IF (IQUEST(1).NE.0)                              GO TO 996
            CALL DBKEYR (ISTR, NWKYDK, KEYSDS(1,NOBJDS))
          ENDIF
   25   CONTINUE
        IF (NOBJDS.EQ.0)                                     GO TO 40
*
*  **   Set the current directory to the output directory
*
        CALL DBPATH (PATHX, JKK)
        PATHY  = PATH(1:NCHAR)//'/'//PATHX
        CALL RZCDIR (PATHY, ' ')
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1) = 71
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Illeg'//
     +    'al Path Name '//PATHY//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
          GO TO 996
        ENDIF
        NWKYDK = IQUEST(8)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        DO 30 IK = 1, NOBJDS
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')
+SELF, IF=-$P3CHILD.
          CALL RZOUT (IDISDB, LOBJDS(IK), KEYSDS(1,IK), ICYCLE, 'L')
          IF (IQUEST(1).NE.0) THEN
            IQUEST(1) = 73
+SELF, IF=$DEBUG, IF=-$P3CHILD.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Err'//
     +      'or in RZOUT while writing Data for '//PATHY//''')',
     +      IARGDB, 0)
+SELF, IF=-$P3CHILD.
            GO TO 996
          ENDIF
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.1) THEN
            CALL UCOPY (KEYSDS(1,IK), KEYNDK, NWKYDK)
            CALL DBUPTM (IARGDB(1), IARGDB(2), KEYNDK(MITMDB))
            CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Data was inserted in'//
     +           'to   '//PATHY//''',/,10X,''on the '',I8,'' at '',I6'//
     +           ','' with Key-Vector '')', IARGDB, 2)
            CALL DBPRKY (NWKYDK, KEYNDK, IOTYDK)
          ENDIF
+SELF, IF=-$P3CHILD.
   30   CONTINUE
        DO 35 IK = 1, NOBJDS
          IF (LOBJDS(IK).NE.0) CALL MZDROP (IDISDB, LOBJDS(IK), 'L')
   35   CONTINUE
        NOBJDS = 0
        IF (ISTR.LT.NKEYDK)                                  GO TO 20
*
*  **   Now update the keys of the main directory
*
   40   CALL RZCDIR (PATH, ' ')
        NKEYDK = IQUEST(7)
        NWKYDK = IQUEST(8)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        KPNT   = IUHUNT (JKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                   NKEYDK*KST, KST)
        IF (KPNT.NE.0) THEN
          NK     = (KPNT - MPSRDB) / KST + 1
        ELSE
          NK     = JKK
        ENDIF
        CALL DBKEYR (NK, NWKYDK, KEYO)
        KPNT   = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                   NKEYDK*KST, KST)
        IF (KPNT.NE.0) THEN
          NK     = (KPNT - MPSRDB) / KST + 1
        ELSE
          NK     = IKK
        ENDIF
        CALL DBKEYR (NK, NWKYDK, KEYN)
        KEYN(MPSRDB) = KEYO(MPSRDB)
        CALL RZRENK (KEYO, KEYN)
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1) = 74
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.0) THEN
            CALL UCOPY  (KEYO, IARGDB(1),        NSYSDK)
            CALL UCOPY  (KEYN, IARGDB(NSYSDK+1), NSYSDK)
            CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Error in RZRENK whil'//
     +           'e writing data for '//PATHY//''',/(10X,7I12))',
     +           IARGDB, 2*NSYSDK)
          ENDIF
+SELF, IF=-$P3CHILD.
          GO TO 996
        ENDIF
   50 CONTINUE
*
* *** Now delete the keys and subdirectories beyond NKEEP
*
   55 IF (NKEEP.GT.0) THEN
        NK1    = NKEEP + 1
      ELSE
        NK1    = NKEYS + NKEEP + 1
        IF (NK1.LT.2) NK1  = 2
        NOBJDS = 0
      ENDIF
      DO 60 JKK = NK1, NKEYS
        IKK    = NKEYS + NK1 - JKK
        CALL RZCDIR (PATH, ' ')
        NKEYDK = IQUEST(7)
        NWKYDK = IQUEST(8)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        KPNT   = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                   NKEYDK*KST, KST)
        IF (KPNT.NE.0) THEN
          NK     = (KPNT - MPSRDB) / KST + 1
        ELSE
          NK     = IKK
        ENDIF
        CALL DBKEYR (NK, NWKYDK, KEYN)
        CALL RZDELK (KEYN, ICDUM, 'C')
        CALL DBPATH (PATHX, IKK)
        CALL RZDELT (PATHX)
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1) = 70
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRGD : Error'//
     +    ' in deleting partition '//PATHX(1:8)//' in '//PATH//''')',
     +    IARGDB, 0)
+SELF, IF=-$P3CHILD.
          GO TO 996
        ENDIF
   60 CONTINUE
+SELF.
*
      IQUEST(1) = 0
+SELF, IF=-$P3CHILD.
*
* *** Drop the stored banks
*
  996 IER    = IQUEST(1)
      IF (NOBJDS.GT.0) THEN
        DO 997 IK = 1, NOBJDS
          IF (LOBJDS(IK).NE.0) CALL MZDROP (IDISDB, LOBJDS(IK), 'L')
  997   CONTINUE
        IQUEST(1) = IER
      ENDIF
  998 IF (PATHL.NE.' ') THEN
        IER    = IQUEST(1)
        CALL RZCDIR (PATHL, ' ')
        CALL RZFREE ('DBPRGD')
        IQUEST(1) = IER
      ENDIF
+SELF.
*                                                             END DBPRGD
  999 END
+DECK, DBPRIN.
      SUBROUTINE DBPRIN (PATHN, CHOPT)
*     ================================
*
************************************************************************
*                                                                      *
*        SUBR. DBPRIN (PATHN, CHOPT)                                   *
*                                                                      *
*   Prints all objects attached to the directory PATHN                 *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     CHOPT    Character string with any of the following characters   *
*          I   Print the insertion time as well                        *
*          K   Print only the keys                                     *
*          D   Print all data as well as the keys                      *
*                                                                      *
*   Called by user,   DBAUXI                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =101 : Illegal path name                               *
*               =102 : No key or data for the path name                *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
      CHARACTER       PATH*80, PATHX*16, PATHY*80, PATHN*(*), CHOPT*(*)
      CHARACTER       CFMT*130
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
* *** Decode the character option
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)       GO TO 999
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Set the current directory
*
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0)       GO TO 991
      CALL RZCDIR (PATHY, 'R')
      NCHAR  = INDEX (PATHY, ' ') - 1
      IF (NCHAR.LT.1.OR.NCHAR.GT.MAXLDB) NCHAR = MAXLDB
      NKEYDK = IQUEST(7)
*
* *** Check the number of keys
*
      IF (NKEYDK.EQ.0)          GO TO 992
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKYTG
*
* *** Check if it is partitioned
*
      KEY6   = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)
      IOPTP  = JBIT (KEY6, JPRTDB)
*
*  ** Print keys
*
      IF (IOPKDA.NE.0) IOPDDA = 0
      IF (IOPKDA.NE.0 .OR. IOPDDA.NE.0)  THEN
*
        IF (IOPKDA.NE.0)  THEN
          CALL DBPRNT (LPRTDB, '(/,''  Keys with Insertion Time in Di'//
     +         'rectory '//PATH//''')', IARGDB, 0)
        ELSE IF (IOPDDA.NE.0)  THEN
          CALL DBPRNT (LPRTDB, '(/,''  Keys and Data with Insertion T'//
     +         'ime in Directory '//PATH//''')', IARGDB, 0)
        ENDIF
        CFMT(1:5)     = '(7X,'''
        CFMT(129:130) = ''')'
        DO 10 I1 = 1, NWKYDK, 10
          I2     = I1 + 9
          IF (I2.GT.NWKYDK) I2 = NWKYDK
          CFMT(6:128) = ' '
          IFLD   = 6
          DO 5 I = I1, I2
            CFMT(IFLD:IFLD+7) = CTAGDK(I)
            IFLD   = IFLD + 12
    5     CONTINUE
          CALL DBPRNT (LPRTDB, CFMT, IARGDB, 0)
   10   CONTINUE
        CALL DBPRNT (LPRTDB, '(//)', IARGDB, 0)
*
        IF (IOPTP.EQ.0)  THEN
          CALL DBPRDT
          IF (IQUEST(1).NE.0)   GO TO 999
        ELSE
*
*  **     Loop over subdirectories
*
          NKEYS  = NKEYDK
          DO 20 IK = 1, NKEYS
            CALL DBPATH (PATHX, IK)
            PATH   = PATHY(1:NCHAR)//'/'//PATHX
            CALL RZCDIR (PATH, ' ')
            IF (IQUEST(1).NE.0) GO TO 991
            NKEYDK = IQUEST(7)
            NWKYDK = IQUEST(8)
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
            CALL DBKEYT
            CALL DBPRDT
            IF (IQUEST(1).NE.0) GO TO 999
   20     CONTINUE
        ENDIF
*
      ENDIF
      IQUEST(1) = 0
      GO TO 999
*
* *** Error messages
*
  991 IQUEST(1) = 101
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRIN : Illegal '//
     +   'Path Name '//PATH//''')', IARGDB, 0)
+SELF.
      GO TO 999
*
  992 IQUEST(1) = 102
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRIN : No key or'//
     +   ' data for Path Name '//PATH//''')', IARGDB, 0)
+SELF.
      GO TO 999
*                                                             END DBPRIN
  999 END
+DECK, DBPURG.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBPURG (PATHN, KYDAT, KYTIM, CHOPT)
*     ==============================================
*
************************************************************************
*                                                                      *
*        SUBR. DBPURG (PATHN, KYDAT, KYTIM, CHOPT)                     *
*                                                                      *
*   Purges/Deletes objects in a directory PATHN                        *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     KYDAT    Key element number (for option K in CHOPT) or           *
*              Minimum value of Key 1 to be deleted (for option S)     *
*     KYTIM    Cutoff value for the key (for option K) or              *
*              Maximum value of Key 1 to be deleted (for option S)     *
*     CHOPT    Character string with any of the following characters   *
*          A   Deletes all data objects                                *
*          B   Save in the special backup file; not in standard Journal*
*          K   Deletes all data objects for which KEY(KYDAT) .lt. KYTIM*
*          L   Deletes all but the last (one with highest KEY(1) value)*
*              data objects                                            *
*          P   Deletes all data objects with identical start and end   *
*              validity but those having the highest Program Version   *
*              number (i.e., KEY(5) value)                             *
*          S   Deletes all data objects with Serial number (KEY(1)) in *
*              the range KYDAT-KYTIM (the terminal points included)    *
*                                                                      *
*   Called by user,   DBFZUP, DBAUXI                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =111 : Illegal path name                               *
*               =112 : No key or data for the path name                *
*                                                                      *
*     If IQUEST(1) =0, IQUEST(2) carries information on number of      *
*     data objects deleted in the disk                                 *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DLINKS.
+CDE, DKKEYS.
      CHARACTER       PATHN*(*), CHOPT*(*), PATH*80, PATHX*16, PATHY*80
      CHARACTER       PATHZ*80
      INTEGER         KEYS(NSYSDK)
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
      KEY7   = KEY7DK
      KEY7DK = 0
      NDEL   = 0
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)                         GO TO 999
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Set the current directory
*
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0)                         GO TO 991
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKEYT
      CALL RZCDIR (PATH, 'R')
      NCHAR  = INDEX (PATH, ' ') - 1
      IF (NCHAR.LT.1.OR.NCHAR.GT.MAXLDB) NCHAR = MAXLDB
      IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)
      IOPTP  = JBIT (IOPTP, JPRTDB)
*
* *** Check the number of keys
*
      IF (NKEYDK.EQ.0)                            GO TO 992
*
* *** Save the command in the journal file
*
      CALL VZERO (KEYS, NSYSDK)
      KEYS(MSERDB) = KYDAT
      KEYS(MUPNDB) = KYTIM
      KEY7DK  = KEY7
      CALL DBSPUR (PATH, NWKYDK, -1, KEYS, CHOPT, IOPP, IOPS)
      KEY7DK  = 0
      IF (IQUEST(1).NE.0)                         GO TO 999
      IF (IOPP.NE.0)                              GO TO 999
+SELF, IF=-$P3CHILD.
*
      IF (IOPADA.NE.0)  THEN
*
* ***   Delete all keys
*
        IF (IOPTP.EQ.0)  THEN
          IF (KEY7.LE.0) THEN
            IF (IOPS.NE.0) CALL RZLOCK ('DBPURG')
            CALL RZDELK (KDUM, ICDUM, 'K')
            IF (IOPS.NE.0) CALL RZFREE ('DBPURG')
            NDEL   = NKEYDK
          ELSE
            CALL VZERO (IPURDK, NKEYDK)
            IPNT   = KOFSDB + LCDRDB + IKDRDB
            ISTP   = NWKYDK + 1
            NKEEP  = 0
            DO 10 JK = 1, NKEYDK
              IP     = IPNT + (JK - 1) * ISTP
              KEY1DK(JK) = IQ(IP+MPSRDB)
              IF (IQ(IP+MITMDB).GT.KEY7) THEN
                IPURDK(JK) = 2
                NKEEP  = NKEEP +1
              ENDIF
   10       CONTINUE
            IF (NKEEP.GT.0) THEN
              CALL DBDELK (IOPS)
              NDEL   = IQUEST(2)
            ELSE
              IF (IOPS.NE.0) CALL RZLOCK ('DBPURG')
              CALL RZDELK (KDUM, ICDUM, 'K')
              IF (IOPS.NE.0) CALL RZFREE ('DBPURG')
              NDEL   = NKEYDK
            ENDIF
          ENDIF
        ELSE
          NKEYS  = NKEYDK
          DO 20 IK = 1, NKEYS
            CALL DBPATH (PATHX, IK)
            PATHY  = PATH(1:NCHAR)//'/'//PATHX
            CALL RZCDIR (PATHY, ' ')
            IF (IQUEST(1).NE.0)  THEN
              IQUEST(1) = 111
+SELF, IF=$DEBUG, IF=-$P3CHILD.
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : '//
     +        'Illegal Path Name '//PATHY//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
              GO TO 999
            ENDIF
            NKEYDK = IQUEST(7)
            IF (NKEYDK.GT.0)  THEN
              IF (KEY7.LE.0) THEN
                IF (IOPS.NE.0) CALL RZLOCK ('DBPURG')
                CALL RZDELK (KDUM, ICDUM, 'K')
                IF (IOPS.NE.0) CALL RZFREE ('DBPURG')
                NDEL   = NDEL + NKEYDK
              ELSE
                NWKYDK = IQUEST(8)
                LCDRDB = IQUEST(11)
                IKDRDB = IQUEST(13)
                IPNT   = KOFSDB + LCDRDB + IKDRDB
                ISTP   = NWKYDK + 1
                CALL VZERO (IPURDK, NKEYDK)
                NKEEP  = 0
                DO 15 JK = 1, NKEYDK
                  IP     = IPNT + (JK - 1) * ISTP
                  KEY1DK(JK) = IQ(IP+MPSRDB)
                  IF (IQ(IP+MITMDB).GT.KEY7) THEN
                    IPURDK(JK) = 2
                    NKEEP  = NKEEP +1
                  ENDIF
   15           CONTINUE
                IF (NKEEP.GT.0) THEN
                  CALL DBDELK (IOPS)
                  NDEL   = NDEL + IQUEST(2)
                ELSE
                  IF (IOPS.NE.0) CALL RZLOCK ('DBPURG')
                  CALL RZDELK (KDUM, ICDUM, 'K')
                  IF (IOPS.NE.0) CALL RZFREE ('DBPURG')
                  NDEL   = NDEL + NKEYDK
                ENDIF
              ENDIF
            ENDIF
   20     CONTINUE
        ENDIF
*
      ELSE IF (IOPLDA.NE.0)  THEN
*
* ***   Delete all but last keys (except those another key may depend
*  **   on) Highest number of KEY(1)
*
        IF (IOPTP.EQ.0) THEN
          CALL VZERO (IPURDK, NKEYDK)
          NO1    = 0
          IPNT   = KOFSDB + LCDRDB + IKDRDB
          ISTP   = NWKYDK + 1
          DO 25 IK = 1, NKEYDK
            IP     = IPNT + (IK - 1) * ISTP
            KEY1DK(IK) = IQ(IP+MSERDB)
            IF (KEY7.LE.0) THEN
              IF (KEY1DK(IK).GT.NO1) NO1 = KEY1DK(IK)
            ELSE
              IF (IQ(IP+MITMDB).GT.KEY7) THEN
                IPURDK(IK) = 2
              ELSE
                IF (KEY1DK(IK).GT.NO1) NO1 = KEY1DK(IK)
              ENDIF
            ENDIF
   25     CONTINUE
*
          II     = IUCOMP (NO1, KEY1DK, NKEYDK)
          IF (II.GT.0) IPURDK(II) = 2
          CALL DBDELK (IOPS)
          NDEL   = IQUEST(2)
*
        ELSE
*
          NKEYS  = NKEYDK
          IFLG   = 0
          DO 35 JK1 = 1, NKEYS
            JK     = NKEYS + 1 - JK1
            CALL DBPATH (PATHX, JK)
            PATHY  = PATH(1:NCHAR)//'/'//PATHX
            CALL RZCDIR (PATHY, ' ')
            IF (IQUEST(1).NE.0)  THEN
              IQUEST(1) = 111
+SELF, IF=$DEBUG, IF=-$P3CHILD.
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : '//
     +        'Illegal Path Name '//PATHY//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
              GO TO 999
            ENDIF
            NKEYDK = IQUEST(7)
            IF (NKEYDK.GT.0.AND.IFLG.EQ.0)  THEN
              NWKYDK = IQUEST(8)
              LCDRDB = IQUEST(11)
              IKDRDB = IQUEST(13)
              IPNT   = KOFSDB + LCDRDB + IKDRDB
              ISTP   = NWKYDK + 1
*
              CALL VZERO (IPURDK, NKEYDK)
              NO1    = 0
              DO 30 IK = 1, NKEYDK
                IP     = IPNT + (IK - 1) * ISTP
                KEY1DK(IK) = IQ(IP+MSERDB)
                IF (KEY7.LE.0) THEN
                  IF (KEY1DK(IK).GT.NO1) NO1 = KEY1DK(IK)
                ELSE
                  IF (IQ(IP+MITMDB).GT.KEY7) THEN
                    IPURDK(IK) = 2
                  ELSE
                    IF (KEY1DK(IK).GT.NO1) NO1 = KEY1DK(IK)
                  ENDIF
                ENDIF
   30         CONTINUE
*
              II     = IUCOMP (NO1, KEY1DK, NKEYDK)
              IF (II.GT.0) THEN
                IPURDK(II) = 2
                IFLG   = 1
              ENDIF
              CALL DBDELK (IOPS)
              NDEL   = NDEL + IQUEST(2)
*
            ELSE IF (NKEYDK.GT.0) THEN
*
*  *          Delete all keys in the remaining subdirectories
*
              IF (IOPS.NE.0) CALL RZLOCK ('DBPURG')
              CALL RZDELK (KDUM, ICDUM, 'K')
              IF (IOPS.NE.0) CALL RZFREE ('DBPURG')
              NDEL   = NDEL + NKEYDK
*
            ENDIF
   35     CONTINUE
        ENDIF
*
      ELSE IF (IOPPDA.NE.0)  THEN
*
* ***   Delete all objects with identical start and end validity but
* ***   those having the highest program version #, i.e. the highest
* ***   KEY(5)
*
        IF (IOPTP.EQ.0)  THEN
          CALL VZERO (IPURDK, NKEYDK)
*
*  **     Label by '2' the object of the highest program version #
*
          DO 50 IK = 1, NKEYDK
            IPURDK(IK) = 2
            CALL DBKEYR (IK, NWKYDK, KEYVDK)
            KEY1DK(IK) = KEYVDK(MSERDB)
            IF (KEY7.GT.0) THEN
              IF (KEYVDK(MITMDB).GT.KEY7)         GO TO 50
            ENDIF
            DO 45 JK = 1, NKEYDK
              IF (IK.EQ.JK.OR.IPURDK(JK).EQ.-1)   GO TO 45
              CALL DBKEYR (JK, NWKYDK, KEYNDK)
              DO 40 K = 1, NWKYDK
                IF (IOKYDA(K).NE.0.AND.KEYNDK(K).NE.KEYVDK(K))
     +                                            GO TO 45
   40         CONTINUE
              IF (KEYNDK(MPVSDB).GT.KEYVDK(MPVSDB))  THEN
                IPURDK(IK) = -1
                GO TO 50
              ENDIF
   45       CONTINUE
   50     CONTINUE
          CALL DBDELK (IOPS)
          NDEL   = IQUEST(2)
*
        ELSE
*
          NKEYS  = NKEYDK
          DO 70 JK2 = 1, NKEYS
            JK1    = NKEYS + 1 - JK2
            CALL DBPATH (PATHX, JK1)
            PATHY  = PATH(1:NCHAR)//'/'//PATHX
            CALL RZCDIR (PATHY, ' ')
            IF (IQUEST(1).NE.0)  THEN
              IQUEST(1) = 111
+SELF, IF=$DEBUG, IF=-$P3CHILD.
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : '//
     +        'Illegal Path Name '//PATHY//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
              GO TO 999
            ENDIF
            NKEYDK = IQUEST(7)
            IF (NKEYDK.LE.0)                      GO TO 70
            NWKYDK = IQUEST(8)
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
*
            CALL VZERO (IPURDK, NKEYDK)
*
*  **       Label by '2' the object of the highest program version #
*
            DO 65 IK = 1, NKEYDK
              IPURDK(IK) = 2
              CALL DBKEYR (IK, NWKYDK, KEYVDK)
              KEY1DK(IK) = KEYVDK(MSERDB)
              IF (KEY7.GT.0) THEN
                IF (KEYVDK(MITMDB).GT.KEY7)       GO TO 65
              ENDIF
              DO 60 JK = 1, NKEYDK
                IF (IK.EQ.JK.OR.IPURDK(JK).EQ.-1) GO TO 60
                CALL DBKEYR (JK, NWKYDK, KEYNDK)
                DO 55 K = 1, NWKYDK
                  IF (IOKYDA(K).NE.0.AND.KEYNDK(K).NE.KEYVDK(K))
     +                                            GO TO 60
   55           CONTINUE
                IF (KEYNDK(MPVSDB).GT.KEYVDK(MPVSDB))  THEN
                  IPURDK(IK) = -1
                  GO TO 65
                ENDIF
   60         CONTINUE
   65       CONTINUE
            CALL DBDELK (IOPS)
            NDEL   = NDEL + IQUEST(2)
   70     CONTINUE
*
*  *      Now delete in one subdirectory from results of other
*
          JK2    = NKEYS + 1
   75     IF (JK2.GT.2)  THEN
            JK2    = JK2 - 1
            CALL DBPATH (PATHX, JK2)
            PATHZ  = PATH(1:NCHAR)//'/'//PATHX
            CALL RZCDIR (PATHZ, ' ')
            IF (IQUEST(1).NE.0)  THEN
              IQUEST(1) = 111
+SELF, IF=$DEBUG, IF=-$P3CHILD.
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : '//
     +        'Illegal Path Name '//PATHZ//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
              GO TO 999
            ENDIF
            NKEY2  = IQUEST(7)
            IF (NKEY2.EQ.0)                       GO TO 75
            NWKYDK = IQUEST(8)
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
*
*  *        Get the master object names in the master subdirectory
*
            CALL VZERO (INDKDK, NKEY2)
            DO 90 IK = 1, NKEY2
              INDKDK(IK) = 2
              CALL DBKEYR (IK, NWKYDK, KEYVDK)
              IF (KEY7.GT.0) THEN
                IF (KEYVDK(MITMDB).GT.KEY7)       GO TO 90
              ENDIF
              DO 85 JK = 1, NKEY2
                IF (IK.EQ.JK.OR.INDKDK(JK).EQ.1)  GO TO 85
                CALL DBKEYR (JK, NWKYDK, KEYNDK)
                DO 80 K = 1, NWKYDK
                  IF (IOKYDA(K).NE.0.AND.KEYVDK(K).NE.KEYNDK(K))
     +                                            GO TO 85
   80           CONTINUE
                IF (KEYNDK(MPVSDB).GT.KEYVDK(MPVSDB))  THEN
                  INDKDK(IK) = 1
                  GO TO 90
                ENDIF
   85         CONTINUE
   90       CONTINUE
            II     = IUCOMP (2, INDKDK, NKEY2)
            IF (II.EQ.0)                          GO TO 75
            I1     = 1
*
*  *        Loop over slave subdirectories
*
            DO 115 JK3 = 1, JK2-1
              JK1    = JK2 - JK3
              CALL DBPATH (PATHX, JK1)
              PATHY  = PATH(1:NCHAR)//'/'//PATHX
*
              CALL RZCDIR (PATHY, ' ')
              IF (IQUEST(1).NE.0)  THEN
                IQUEST(1) = 111
+SELF, IF=$DEBUG, IF=-$P3CHILD.
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG :'//
     +          ' Illegal Path Name '//PATHY//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
                GO TO 999
              ENDIF
              LCDRDB = IQUEST(11)
              IKDRDB = IQUEST(13)
              NKEYDK = IQUEST(7)
              IF (NKEYDK.EQ.0)                    GO TO 115
*
              DO 95 IK = 1, NKEYDK
                IPURDK(IK) = 2
   95         CONTINUE
*
  100         IF (I1.LE.NKEY2) THEN
                NN     = NKEY2 - I1 + 1
                II     = IUCOMP (2, INDKDK(I1), NN)
                IF (II.GT.0) THEN
                  II     = II + I1 - 1
                  I1     = II + 1
                  CALL RZCDIR (PATHZ, ' ')
                  IF (IQUEST(1).NE.0)  THEN
                    IQUEST(1) = 111
+SELF, IF=$DEBUG, IF=-$P3CHILD.
                    IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPU'//
     +              'RG : Illegal Path Name '//PATHZ//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
                    GO TO 999
                  ENDIF
                  LCDRDB = IQUEST(11)
                  IKDRDB = IQUEST(13)
                  CALL DBKEYR (II, NWKYDK, KEYVDK)
                  IF (KEY7.GT.0) THEN
                    IF (KEYVDK(MITMDB).GT.KEY7)   GO TO 100
                  ENDIF
*
                  CALL RZCDIR (PATHY, ' ')
                  IF (IQUEST(1).NE.0)  THEN
                    IQUEST(1) = 111
+SELF, IF=$DEBUG, IF=-$P3CHILD.
                    IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPU'//
     +              'RG : Illegal Path Name '//PATHY//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
                    GO TO 999
                  ENDIF
                  LCDRDB = IQUEST(11)
                  IKDRDB = IQUEST(13)
*
*  *              Check all key elements in the slave subdirectory
*
                  DO 110 IK = 1, NKEYDK
                    CALL DBKEYR (IK, NWKYDK, KEYNDK)
                    KEY1DK(IK) = KEYNDK(MSERDB)
                    IF (KEY7.GT.0) THEN
                      IF (KEYNDK(MITMDB).GT.KEY7) GO TO 110
                    ENDIF
                    DO 105 K = 1, NWKYDK
                      IF (IOKYDA(K).NE.0.AND.KEYVDK(K).NE.KEYNDK(K))
     +                                            GO TO 110
  105               CONTINUE
                    IF (KEYNDK(MPVSDB).LT.KEYVDK(MPVSDB)) IPURDK(IK) = 0
  110             CONTINUE
                  GO TO 100
                ENDIF
              ENDIF
              CALL DBDELK (IOPS)
              NDEL   = NDEL + IQUEST(2)
*
  115       CONTINUE
            GO TO 75
          ENDIF
*
        ENDIF
*
      ELSE IF (IOPKDA.NE.0)  THEN
*
*  **   Delete all keys for which KEY(KYDAT).le.KYTIM
*
        IF (IOPTP.EQ.0)  THEN
*
          CALL VZERO (IPURDK, NKEYDK)
*
*  **     Label by '2' the objects for which KEY(KYDAT).le.KYTIM
*
          DO 120 IK = 1, NKEYDK
            CALL DBKEYR (IK, NWKYDK, KEYNDK)
            KEY1DK(IK) = KEYNDK(MSERDB)
            IF (KEY7.LE.0) THEN
              IF (KEYNDK(KYDAT).GE.KYTIM) IPURDK(IK) = 2
            ELSE
              IF (KEYNDK(MITMDB).GT.KEY7) THEN
                IPURDK(IK) = 2
              ELSE
                IF (KEYNDK(KYDAT).GE.KYTIM) IPURDK(IK) = 2
              ENDIF
            ENDIF
  120     CONTINUE
          CALL DBDELK (IOPS)
          NDEL   = IQUEST(2)
*
        ELSE
*
          NKEYS  = NKEYDK
          DO 130 JK1 = 1, NKEYS
            JK     = NKEYS + 1 - JK1
            CALL DBPATH (PATHX, JK)
            PATHY  = PATH(1:NCHAR)//'/'//PATHX
            CALL RZCDIR (PATHY, ' ')
            IF (IQUEST(1).NE.0)  THEN
              IQUEST(1) = 111
+SELF, IF=$DEBUG, IF=-$P3CHILD.
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : '//
     +        'Illegal Path Name '//PATHY//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
              GO TO 999
            ENDIF
            NKEYDK = IQUEST(7)
            IF (NKEYDK.LE.0)                      GO TO 130
            NWKYDK = IQUEST(8)
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
            CALL DBKEYT
*
            CALL VZERO (IPURDK, NKEYDK)
*
*  **       Label by '2' the object for which KEY(KYDAT).le.KYTIM
*
            DO 125 IK = 1, NKEYDK
              CALL DBKEYR (IK, NWKYDK, KEYNDK)
              KEY1DK(IK) = KEYNDK(MSERDB)
              IF (KEY7.LE.0) THEN
                IF (KEYNDK(KYDAT).GE.KYTIM) IPURDK(IK) = 2
              ELSE
                IF (KEYNDK(MITMDB).GT.KEY7) THEN
                  IPURDK(IK) = 2
                ELSE
                  IF (KEYNDK(KYDAT).GE.KYTIM) IPURDK(IK) = 2
                ENDIF
              ENDIF
  125       CONTINUE
            CALL DBDELK (IOPS)
            NDEL   = NDEL + IQUEST(2)
  130     CONTINUE
*
        ENDIF
*
      ELSE IF (IOPSDA.NE.0)  THEN
*
*  **   Delete all keys for with KEY(MSERDB) in the range KYDAT-KYTIM
*
        IF (IOPTP.EQ.0)  THEN
*
          IPNT   = KOFSDB + LCDRDB + IKDRDB
          ISTP   = NWKYDK + 1
*
*  **     Label by '2' objects for which KEY(1) not in range KYDAT-KYTIM
*
          DO 140 IK = 1, NKEYDK
            KEY1DK(IK) = IQ(IPNT+(IK-1)*ISTP+MSERDB)
            IF (KEY7.LE.0) THEN
              IF (KEY1DK(IK).GE.KYDAT.AND.KEY1DK(IK).LE.KYTIM) THEN
                IPURDK(IK) = 0
              ELSE
                IPURDK(IK) = 2
              ENDIF
            ELSE
              IF (IQ(IPNT+(IK-1)*ISTP+MITMDB).GT.KEY7) THEN
                IPURDK(IK) = 2
              ELSE
                IF (KEY1DK(IK).GE.KYDAT.AND.KEY1DK(IK).LE.KYTIM) THEN
                  IPURDK(IK) = 0
                ELSE
                  IPURDK(IK) = 2
                ENDIF
              ENDIF
            ENDIF
  140     CONTINUE
          CALL DBDELK (IOPS)
          NDEL   = IQUEST(2)
*
        ELSE
*
          NKEYS  = NKEYDK
          KST    = NWKYDK + 1
          MAXKY  = -1
          DO 160 JK1 = 1, NKEYS
            JK     = NKEYS + 1 - JK1
            IPNT   = KOFSDB + LCDRDB + IKDRDB
            KPNT   = IUHUNT (JK, IQ(IPNT+MPSRDB), NKEYS*KST, KST)
            IF (KPNT.GT.0) THEN
              KPNT   = KPNT + IPNT - MPSRDB
            ELSE
              KPNT   = IPNT + (JK - 1) * KST
            ENDIF
            MINKY  = IQ(KPNT+MOBJDB) + 1
            IF (KYTIM.LT.MINKY)                   GO TO 155
            IF (MAXKY.GT.0.AND.KYDAT.GT.MAXKY)    GO TO 155
            CALL DBPATH (PATHX, JK)
            PATHY  = PATH(1:NCHAR)//'/'//PATHX
            CALL RZCDIR (PATHY, ' ')
            IF (IQUEST(1).NE.0)  THEN
              IQUEST(1) = 111
+SELF, IF=$DEBUG, IF=-$P3CHILD.
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : '//
     +        'Illegal Path Name '//PATHY//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
              GO TO 999
            ENDIF
            NKEYDK = IQUEST(7)
            IF (NKEYDK.LE.0)                      GO TO 150
            NWKYDK = IQUEST(8)
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
            CALL DBKEYT
            IPNT   = KOFSDB + LCDRDB + IKDRDB
            ISTP   = NWKYDK + 1
*
*  **       Label by '2' objects with KEY(1) not in range KYDAT-KYTIM
*
            DO 145 IK = 1, NKEYDK
              KEY1DK(IK) = IQ(IPNT+(IK-1)*ISTP+MSERDB)
              IF (KEY7.LE.0) THEN
                IF (KEY1DK(IK).GE.KYDAT.AND.KEY1DK(IK).LE.KYTIM) THEN
                  IPURDK(IK) = 0
                ELSE
                  IPURDK(IK) = 2
                ENDIF
              ELSE
                IF (IQ(IPNT+(IK-1)*ISTP+MITMDB).GT.KEY7) THEN
                  IPURDK(IK) = 2
                ELSE
                  IF (KEY1DK(IK).GE.KYDAT.AND.KEY1DK(IK).LE.KYTIM) THEN
                    IPURDK(IK) = 0
                  ELSE
                    IPURDK(IK) = 2
                  ENDIF
                ENDIF
              ENDIF
  145       CONTINUE
            CALL DBDELK (IOPS)
            NDEL   = NDEL + IQUEST(2)
*
  150       CALL RZCDIR (PATH, ' ')
            IF (IQUEST(1).NE.0)  THEN
              IQUEST(1) = 111
+SELF, IF=$DEBUG, IF=-$P3CHILD.
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : '//
     +        'Illegal Path Name '//PATH//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
              GO TO 999
            ENDIF
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
  155       MAXKY  = MINKY - 1
  160     CONTINUE
*
        ENDIF
*
      ENDIF
+SELF.
*
      IQUEST(1) = 0
      IQUEST(2) = NDEL
      GO TO 999
*
* *** Error messages
*
  991 IQUEST(1) = 111
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : Illegal '//
     +   'Path Name '//PATH(1:NCHAR)//''')', IARGDB, 0)
+SELF.
      GO TO 999
*
  992 IQUEST(1) = 112
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURG : No key or'//
     +   ' data for Path Name '//PATH(1:NCHAR)//''')', IARGDB, 0)
+SELF.
      GO TO 999
*                                                             END DBPURG
  999 END
+DECK, DBPURK.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBPURK (PATHN, ITIME, KEYS, CHOPT)
*     =============================================
*
************************************************************************
*                                                                      *
*        SUBR. DBPURK (PATHN, ITIME, KEYS, CHOPT)                      *
*                                                                      *
*   Deletes objects in a directory path name steered by a selection    *
*   on a number of key elements                                        *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     ITIME    Time of validity of the object                          *
*     KEYS     Vector of keys. Only the elements declared in CHOPT are *
*              assumed to contain useful information.                  *
*     CHOPT    Character string with any of the following characters   *
*          B   Save in the special backup file; not in standard Journal*
*          S   expect multiple Key banks satisfying selection on a     *
*              number of keys                                          *
*          3   selects objects with start validity time < KEYS(3)      *
*          4   selects objects with end validity time > KEYS(4)        *
*          5   specific Program version number required                *
*          7   select objects with insertion time < KEYS(7)            *
*          n   consider user key n (where 7 < n < 29 )                 *
*                                                                      *
*   Called by user,   DBFZUP                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =111 : Illegal path name                               *
*               =112 : No key for the path name satisfying the Key     *
*                      assignments                                     *
*               =113 : Illegal character option                        *
*               =114 : Valid data objects in the Node/Key structure    *
*                                                                      *
*     If IQUEST(1) =0, IQUEST(2) carries information on number of      *
*     data objects deleted in the disk                                 *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DINITL.
+CDE, DKKEYS.
      DIMENSION       KEYS(9)
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, PATHX*16, PATHY*80
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Initialize options
*
      KEY7   = KEY7DK
      KEY7DK = 0
      NDEL   = 0
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)                   GO TO 999
      IF (IOPMDA.NE.0) THEN
        IQUEST(1) = 113
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURK : Illegal'//
     +  ' Character option '')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Set the current directory
*
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 111
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURK : Illegal'//
     +  ' Path Name '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL RZCDIR (PATH, 'R')
      NCHAR  = INDEX (PATH, ' ') - 1
      IF (NCHAR.LT.1.OR.NCHAR.GT.MAXLDB) NCHAR = MAXLDB
      IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)
      IOPTP  = JBIT (IOPTP, JPRTDB)
      IF (NKEYDK.LE.0) THEN
        IQUEST(1) = 112
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURK : No vali'//
     +  'd object for Path Name '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
      NCHRT  = INDEX (PATH(3:NCHAR), '/') - 1
      IF (NCHRT.LE.0) NCHRT = NCHAR - 2
      PATHX  = PATH(3:NCHRT+2)
      LTOP   = LTOPDB
    5 IF (LTOP.NE.0) THEN
        NCHRT  = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHRT)
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 5
        ENDIF
        KY7MDB = IQ(KOFUDB+LTOP+MUPKY7)
      ELSE
        KY7MDB = 0
      ENDIF
*
* *** Save the command in the journal file
*
      CALL DBKEYT
      KEY7DK = KEY7
      CALL DBSPUR (PATH, NWKYDK, ITIME, KEYS, CHOPT, IOPP, IOPS)
      KEY7DK = 0
      IF (IQUEST(1).NE.0)                   GO TO 999
      IF (IOPP.NE.0)                        GO TO 999
+SELF, IF=-$P3CHILD.
*
* *** Prepare the Key banks in memory
*
      CALL DBNODE (PATH, LBNODB)
      IF (IQUEST(1).NE.0)                   GO TO 999
      IF (LQ(KOFUDB+LBNODB-KLKYDB).NE.0) THEN
        IQUEST(1) = 114
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURK : Valid '//
     +  'KYDB exists for Path Name '//PATH//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
        GO TO 999
      ENDIF
*
      IF (KEY7.GT.0) THEN
        KEY7O  = KEYS(MITMDB)
        IF (IOKYDA(MITMDB).NE.0) THEN
          KEYS(MITMDB) = MIN0 (KEYS(MITMDB), KEY7)
        ELSE
          KEYS(MITMDB)   = KEY7
          IOKYDA(MITMDB) = 1
        ENDIF
      ENDIF
      CALL DBKEYS (LBNODB, KEYS, LBDADB, ITIME)
      IF (IQUEST(1).NE.0) THEN
        IF (KEY7.GT.0) KEYS(MITMDB) = KEY7O
        GO TO 999
      ENDIF
      IF (LQ(KOFUDB+LBNODB-KLKYDB).LE.0) THEN
        IF (KEY7.GT.0) KEYS(MITMDB) = KEY7O
        IQUEST(1) = 112
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURK : No vali'//
     +  'd object for Path Name '//PATH//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
        GO TO 999
      ENDIF
      LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)
      ITEMP  = IOPKDA
      IOPKDA = 1
   10 IF (IOPSDA.EQ.0 .AND. LBKYDB.GT.0) THEN
        DO 15 I = 1, NWKYDK
          IF (IOKYDA(I).NE.0) THEN
            IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB.OR.I.EQ.MITMDB) THEN
              KEYVDK(I) = KEYS(I)
            ELSE
              KEYVDK(I) = IQ(KOFUDB+LBKYDB+I)
            ENDIF
          ELSE
            KEYVDK(I) = 0
          ENDIF
   15   CONTINUE
        CALL DBKXIN (ITIME, IDIVDB, LBDADB, LBKYDB, -1, NWKYDK, KEYVDK,
     +               IPREC)
        IF (IQUEST(1).NE.0)                 GO TO 100
        CALL UCOPY (KEYVDK(1), IQ(KOFUDB+LBKYDB+1), NWKYDK)
        LBKYDB = LQ(KOFUDB+LBKYDB)
        GO TO 10
      ENDIF
      IOPKDA = ITEMP
*
* *** Now mark the objects which are in the Key banks to be deleted
*
      IF (IOPTP.EQ.0) THEN
*
        IPNT   = KOFSDB + LCDRDB + IKDRDB
        ISTP   = NWKYDK + 1
        DO 20 IK = 1, NKEYDK
          KEY1DK(IK) = IQ(IPNT+(IK-1)*ISTP+MSERDB)
          IPURDK(IK) = 2
   20   CONTINUE
        LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)
   25   IF (LBKYDB.GT.0) THEN
          II     = IUCOMP (IQ(KOFUDB+LBKYDB+MSERDB), KEY1DK, NKEYDK)
          IF (II.GT.0) IPURDK(II) = 0
          LBKYDB = LQ(KOFUDB+LBKYDB)
          GO TO 25
        ENDIF
        CALL DBDELK (IOPS)
        NDEL   = IQUEST(2)
*
      ELSE
*
        NKEYS  = NKEYDK
        KST    = NWKYDK + 1
        MAXKY  = -1
        LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)
        MINK   = IQ(KOFUDB+LBKYDB+MSERDB)
        MAXK   = IQ(KOFUDB+LBKYDB+MSERDB)
   30   LBKYDB = LQ(KOFUDB+LBKYDB)
        IF (LBKYDB.GT.0) THEN
          MINK   = MIN0 (MINK, IQ(KOFUDB+LBKYDB+MSERDB))
          MAXK   = MAX0 (MAXK, IQ(KOFUDB+LBKYDB+MSERDB))
          GO TO 30
        ENDIF
*
        DO 55 JK1 = 1, NKEYS
          JK     = NKEYS + 1 - JK1
          IPNT   = KOFSDB + LCDRDB + IKDRDB
          KPNT   = IUHUNT (JK, IQ(IPNT+MPSRDB), NKEYS*KST, KST)
          IF (KPNT.GT.0) THEN
            KPNT   = KPNT + IPNT - MPSRDB
          ELSE
            KPNT   = IPNT + (JK - 1) * KST
          ENDIF
          MINKY  = IQ(KPNT+MOBJDB) + 1
          IF (MAXK.LT.MINKY)                GO TO 50
          IF (MAXKY.GT.0.AND.MINK.GT.MAXKY) GO TO 50
          CALL DBPATH (PATHX, JK)
          PATHY  = PATH(1:NCHAR)//'/'//PATHX
          CALL RZCDIR (PATHY, ' ')
          IF (IQUEST(1).NE.0)  THEN
            IQUEST(1) = 111
+SELF, IF=$DEBUG, IF=-$P3CHILD.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURK : Ill'//
     +      'egal Path Name '//PATHY//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
            GO TO 100
          ENDIF
          NKEYDK = IQUEST(7)
          IF (NKEYDK.LE.0)                  GO TO 45
          NWKYDK = IQUEST(8)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          IPNT   = KOFSDB + LCDRDB + IKDRDB
          ISTP   = NWKYDK + 1
*
          DO 35 IK = 1, NKEYDK
            KEY1DK(IK) = IQ(IPNT+(IK-1)*ISTP+MSERDB)
            IPURDK(IK) = 2
   35     CONTINUE
          LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)
   40     IF (LBKYDB.GT.0) THEN
            II     = IUCOMP (IQ(KOFUDB+LBKYDB+MSERDB), KEY1DK, NKEYDK)
            IF (II.GT.0) IPURDK(II) = 0
            LBKYDB = LQ(KOFUDB+LBKYDB)
            GO TO 40
          ENDIF
          CALL DBDELK (IOPS)
          NDEL   = NDEL + IQUEST(2)
*
   45     CALL RZCDIR (PATH, ' ')
          IF (IQUEST(1).NE.0)  THEN
            IQUEST(1) = 111
+SELF, IF=$DEBUG, IF=-$P3CHILD.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPURK : Ill'//
     +      'egal Path Name '//PATH//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
            GO TO 100
          ENDIF
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
   50     MAXKY  = MINKY - 1
   55   CONTINUE
*
      ENDIF
*
  100 IER    = IQUEST(1)
      LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)
      IF (LBKYDB.GT.0) CALL MZDROP (IDIVDB, LBKYDB, 'L')
      IQUEST(1) = IER
+SELF, IF=$P3CHILD.
      IQUEST(1) = 0
+SELF.
      IF (KEY7.GT.0) KEYS(MITMDB) = KEY7O
      IF (IQUEST(1).EQ.0) IQUEST(2) = NDEL
*                                                             END DBPURK
  999 END
+DECK, DBRALI.
      SUBROUTINE DBRALI (ALIAS, PATH)
*     ===============================
*
************************************************************************
*                                                                      *
*        SUBR. DBRALI (ALIAS, PATH*)                                   *
*                                                                      *
*   Retrieve the complete path name from the alias name                *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     ALIAS    Character string specifying the alias name              *
*     PATH(*)  Character string specifying the directory path name     *
*                                                                      *
*   Called by user,   DBACPL, DBAUXI                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =205 : Not a valid alias name                          *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
      CHARACTER       PATH*(*), ALIAS*(*), CALI*8, PATHN*80, TOPN*16
*
*     ------------------------------------------------------------------
*
      PATH   = ' '
      IQUEST(1) = 0
*
* *** Loop over all the top directories
*
      LTOP   = LTOPDB
   10 IF (LTOP.NE.0) THEN
        LDIC   = LQ(KOFUDB+LTOP-KLDICT)
        IF (LDIC.NE.0) THEN
          NITEM  = IQ(KOFUDB+LDIC+MDCNTM)
          DO 20 I = 1, NITEM
            IPNT   = KOFUDB + LDIC + (I - 1) * NWITDB + 1
            IF (IQ(IPNT+MDCITM).GT.0) THEN
              CALL UHTOC (IQ(IPNT+MDCALI), 4, CALI, 8)
              IF (ALIAS.EQ.CALI) THEN
                NCHF   = IQ(IPNT+MDCNCH)
                CALL UHTOC (IQ(IPNT+MDCNAM), 4, PATHN, NCHF)
                NCHT   = IQ(KOFUDB+LTOP+MUPNCH)
                CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPN, NCHT)
                PATH   = '//'//TOPN(1:NCHT)//PATHN(1:NCHF)
                GO TO 999
              ENDIF
            ENDIF
   20     CONTINUE
        ENDIF
        LTOP   = LQ(KOFUDB+LTOP)
        GO TO 10
      ELSE
        IQUEST(1) = 205
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          CALI   = ALIAS
          CALL DBPRNT (LPRTDB, '(/,'' DBRALI : Alias name '//CALI//
     +         ' not found'')', IARGDB, 0)
        ENDIF
+SELF.
      ENDIF
*                                                             END DBRALI
  999 END
+DECK, DBRENK.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBRENK (PATHN, KEYO, KEYN)
*     =====================================
*
************************************************************************
*                                                                      *
*        SUBR. DBRENK (PATHN, KEYO, KEYN)                              *
*                                                                      *
*   Changes the key elements of an existing object to new values       *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     KEYO     Array containing the old key elements                   *
*     KEYN     Array containing the new key elements                   *
*                                                                      *
*   Called by user,   DBFZUP                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =191 : Illegal path name                               *
*               =192 : Illegal KEYO values (no matching object)        *
*               =193 : No top directory found                          *
*               =194 : Error in getting the IO descriptor              *
*               =195 : Error in FZOUT in saving the journal file       *
*               =196 : Error in RZRENK in renaming key values          *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, P3DBL3, IF=$P3CHILD.
      PARAMETER       (NLEVM=20)
      INTEGER         NLCUR(NLEVM)
      DIMENSION       KEYO(9), KEYN(9), KEYOP(MXDMDK), KEYNP(MXDMDK)
      CHARACTER       PATHY*80, PATHX*16, CHFOR*100, CFORM(6)*1
      CHARACTER       CHCUR(NLEVM)*1, TOPN*16, PATHN*(*)
      DATA            CFORM /'B', 'I', 'F', 'D', 'H', 'A'/
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATHY, NCHAR)
*
* *** Set the current directory path name
*
      PATHX  = ' '
      CALL RZCDIR (PATHY, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 191
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Illegal'//
     +  ' Path Name '//PATHY(1:NCHAR)//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      KST    = NWKYDK + 1
      CALL RZCDIR (PATHY, 'R')
      NCHAR  = INDEX (PATHY, ' ') - 1
      IF (NCHAR.LT.1.OR.NCHAR.GT.MAXLDB) NCHAR = MAXLDB
      CALL DBKEYT
      IF (NKEYDK.NE.0)  THEN
        IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)
        IOPTP  = JBIT (IOPTP, JPRTDB)
      ELSE
        IQUEST(1) = 192
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Illegal'//
     +  ' key in Path '//PATHY(1:NCHAR)//PATHX(1:8)//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** See if the key matches with one existing
*
      IF (IOPTP.EQ.0) THEN
        KPNT   = IUHUNT (KEYO(MSERDB), IQ(KOFSDB+LCDRDB+IKDRDB+MSERDB),
     +                   NKEYDK*KST, KST)
        IF (KPNT.EQ.0) THEN
          IQUEST(1) = 192
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Illeg'//
     +    'al key in Path '//PATHY(1:NCHAR)//PATHX(1:8)//''')',IARGDB,0)
+SELF.
          GO TO 999
        ELSE
          NK     = (KPNT - MSERDB) / KST + 1
          CALL DBKEYR (NK, NWKYDK, KEYNDK)
          DO 10 IK = 1, NWKYDK
            IF (KEYNDK(IK).NE.KEYO(IK)) THEN
              IQUEST(1) = 192
+SELF, IF=$DEBUG.
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : I'//
     +        'llegal key in Path '//PATHY(1:NCHAR)//PATHX(1:8)//''')',
     +        IARGDB, 0)
+SELF.
              GO TO 999
            ENDIF
   10     CONTINUE
        ENDIF
*
      ELSE
        NKEYS   = NKEYDK
        DO 20 JK = 1, NKEYS
          IK     = NKEYS - JK + 1
          KPNT   = IUHUNT (IK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                     NKEYS*KST, KST)
          IF (KPNT.GT.0) THEN
            KPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB
          ELSE
            KPNT   = KOFSDB + LCDRDB + IKDRDB + (IK - 1) * KST
          ENDIF
          IF (KEYO(MSERDB).LE.IQ(KPNT+MOBJDB)) GO TO 20
          NK     = (KPNT - KOFSDB - LCDRDB -IKDRDB) / KST + 1
          CALL DBKEYR (NK, NWKYDK, KEYOP)
          CALL UCOPY (KEYOP, KEYNP, NWKYDK)
          CALL DBPATH (PATHX, IK)
          CALL RZCDIR (PATHX, ' ')
          IF (IQUEST(1).NE.0) THEN
            IQUEST(1) = 191
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Ill'//
     +      'egal Path Name '//PATHY(1:NCHAR)//PATHX(1:8)//''')', IQ, 0)
+SELF.
            GO TO 999
          ENDIF
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          KPNT   = IUHUNT (KEYO(MSERDB),IQ(KOFSDB+LCDRDB+IKDRDB+MSERDB),
     +                     NKEYDK*KST, KST)
          IF (KPNT.EQ.0) THEN
            IQUEST(1) = 192
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Ill'//
     +      'egal key in Path '//PATHY(1:NCHAR)//PATHX(1:8)//''')',
     +      IARGDB, 0)
+SELF.
            GO TO 999
          ELSE
            NK     = (KPNT - MSERDB) / KST + 1
            CALL DBKEYR (NK, NWKYDK, KEYNDK)
            DO 15 IK = 1, NWKYDK
              IF (KEYNDK(IK).NE.KEYO(IK)) THEN
                IQUEST(1) = 192
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK :'//
     +          ' Illegal key in Path '//PATHY(1:NCHAR)//PATHX(1:8)//
     +          ''')', IARGDB, 0)
+SELF.
                GO TO 999
              ENDIF
   15       CONTINUE
            GO TO 25
          ENDIF
   20   CONTINUE
        IQUEST(1) = 192
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Illegal'//
     +  ' key in Path '//PATHY(1:NCHAR)//PATHX(1:8)//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Extract the Top level directory name
*
   25 I1     = 0
      I11    = 0
      DO 30 I0 = 1, NCHAR
        IF (PATHY(I0:I0).EQ.'/'.OR.PATHY(I0:I0).EQ.' ') THEN
          IF (I1.GT.0) THEN
            TOPN   = PATHY(I11:I0-1)
            GO TO 35
          ENDIF
          IF (PATHY(I0:I0).EQ.' ')             GO TO 35
        ELSE
          IF (I1.EQ.0) I11 = I0
          I1     = I1 +1
        ENDIF
   30 CONTINUE
   35 IF (I1.EQ.0) THEN
        IQUEST(1) = 193
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : No top '//
     +  'directory for '//PATHY//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Find the appropriate FZ file number
*
      LTOP   = LTOPDB
      IOPS   = 0
      IOUT   = 0
   40 IF (LTOP.NE.0) THEN
        NCH    = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCH)
        TOPNDI = TOPNDI(1:NCH)
        IF (TOPN.EQ.TOPNDI) THEN
          LUFZDF = IQ(KOFUDB+LTOP+MUPJFL)
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10)
+SELF.
        ELSE
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 40
        ENDIF
      ELSE
        LUFZDF = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        IOPP   = 0
+SELF.
      ENDIF
      IF (IOUT.EQ.0) IOPS = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
      IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
        LUFZDF = LUFMDB
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
        CALL DBSTSV (TOPN, 0)
        IF (IQUEST(1).NE.0)                    GO TO 999
+SELF, IF=$P3CHILD.
        LUFZDF = LODBP3
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
      ENDIF
+SELF.
*
* *** Get the IO descriptor for the header
*
      IF (LUFZDF.GT.0) THEN
        NLEV   = 1
        NCUR   = 5
        IFORO  = 2
        CHCUR(NLEV) = CFORM(IFORO)
        DO 50 J = 1, 2
          DO 45 I = 1, NWKYDK
            IFORM  = IOTYDK(I)
            IF (IFORM.EQ.6) IFORM = 5
            IF (IFORM.EQ.IFORO) THEN
              NCUR   = NCUR + 1
            ELSE
              NLCUR(NLEV) = NCUR
              IF (NLEV.GE.NLEVM) THEN
                IQUEST(1) = 194
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK :'//
     +          ' Cannot get IO descriptor '//PATHY//''')', IARGDB, 0)
+SELF.
                GO TO 999
              ENDIF
              NLEV   = NLEV + 1
              CHCUR(NLEV) = CFORM(IFORM)
              NCUR   = 1
              IFORO  = IFORM
            ENDIF
   45     CONTINUE
   50   CONTINUE
        NLCUR(NLEV) = NCUR
*
+SELF, IF=-IBM, -$P3CHILD.
        WRITE (CHFOR, 2001) (NLCUR(I), CHCUR(I), I = 1, NLEV)
+SELF, IF=IBM, IF=$P3CHILD.
        CHFOR  = ' '
        II     = 1
        DO 51 I = 1, NLEV
          CALL UTWRIT (CHFOR(II:II+1), '(I2)', NLCUR(I))
          II     = II + 2
          CHFOR(II:II) = CHCUR(I)
          II     = II + 2
   51   CONTINUE
+SELF.
        II     = 4 *NLEV
        CHFOR = CHFOR(1:II)//' -H'
        CALL MZIOCH (IOFMDF, NWFMDF, CHFOR(1:II+3))
*
*  **   Fill up the header
*
        NWDP   = (NCHAR + 3) / 4
        NWDH   = NWDP + 2 * NWKYDK + 5
        IHEADF(MACTDF) = 5
        IHEADF(MNKYDF) = NWKYDK
        IHEADF(MOPTDF) = 0
        IHEADF(MPATDF) = NWDP
        IHEADF(MPREDF) = 0
        CALL UCOPY (KEYO,  IHEADF(MPREDF+1),        NWKYDK)
        CALL UCOPY (KEYN,  IHEADF(MPREDF+NWKYDK+1), NWKYDK)
        CALL UCTOH (PATHY, IHEADF(MPREDF+2*NWKYDK+1), 4, 4*NWDP)
      ENDIF
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
*
      IF (IOPP.NE.0) THEN
        CALL DBWLOK
        IF (IQUEST(1).NE.0)                    GO TO 999
      ENDIF
+SELF.
*
*  ** Write the sequential output if needed
*
      IF (LUFZDF.GT.0) THEN
+SELF, IF=$P3CHILD.
        RNDBP3 = 'DBRENK '
        NWDBP3 = 2
        CALL UCTOH ('JOURNAL ', IWDBP3, 4, 8)
        CALL DBCHLD
        IQUEST(1) = IQDBP3
        IF (IQUEST(1).NE.0)                    GO TO 999
+SELF.
        CALL FZOUT (LUFZDF, IDISDB, 0, 1, 'Z', IOFMDF, NWDH, IHEADF)
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1)  = 195
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Error'//
     +    ' in FZOUT while writing Data for '//PATHY(1:60)//''')',
     +    IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
      ENDIF
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
      IF (IOPP.NE.0)                           GO TO 998
+SELF, IF=-$P3CHILD.
*
* *** Take necessary action for partitioned and nonpartitioned datasets
*
      IF (IOPS.NE.0) CALL RZLOCK ('DBRENK')
      CALL RZRENK (KEYO, KEYN)
      IERR   = IQUEST(1)
      IF (IOPS.NE.0) CALL RZFREE ('DBRENK')
      IF (IERR.NE.0) THEN
        IQUEST(1) = 196
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Error'//
     +  ' in RZRENK while writing data for '//PATHY(1:60)//''')',
     +  IARGDB, 0)
+SELF, IF=-$P3CHILD.
        GO TO 999
      ENDIF
      IF (IOPTP.NE.0) THEN
        KEYNP(MBVRDB) = MIN0 (KEYNP(MBVRDB), KEYN(MBVRDB))
        KEYNP(MEVRDB) = MAX0 (KEYNP(MEVRDB), KEYN(MEVRDB))
        CALL RZCDIR (PATHY, ' ')
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        NKEYDK = IQUEST(7)
*
*  **   Rename Keys 3 and 4 of the latest subdirectory
*
        IF (IOPS.NE.0) CALL RZLOCK ('DBRENK')
        CALL RZRENK (KEYOP, KEYNP)
        IERR   = IQUEST(1)
        IF (IOPS.NE.0) CALL RZFREE ('DBRENK')
        IF (IERR.NE.0) THEN
          IQUEST(1) = 196
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRENK : Error'//
     +    ' in RZRENK while writing data for '//PATHY(1:60)//''')',
     +    IARGDB, 0)
+SELF, IF=-$P3CHILD.
          GO TO 999
        ENDIF
      ENDIF
+SELF.
*
  998 CONTINUE
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
      IF (IOPP.NE.0) THEN
        IOPBDA = 0
        CALL DBCWSV
      ENDIF
+SELF, IF=-IBM, -$P3CHILD.
*
 2001 FORMAT (20(I2,A1,1X))
+SELF.
*                                                             END DBRENK
  999 END
+DECK, DBREPL.
      SUBROUTINE DBREPL (PATHN, LBK, LBD, IUDIV, LSUP, NWKEY, KEYO, KEYN
     +                 , IPREC, CHOPT)
*     ==================================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBREPL (PATHN, *LBK*, LBD*, IUDIV, LSUP, NWKEY, KEYO,   *
*                      KEYN, IPREC, CHOPT)                             *
*                                                                      *
*   Stores data from memory to disk and also enters in the memory ala  *
*   DBUSE in NODE/KEY structure. Also replaces an Old set of keys in   *
*   KEYO by a new set of keys in KEYN                                  *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     LBK(*)   Address of Keys bank KYDB   (INPUT or OUTPUT)           *
*     LBD(*)   Address of Data bank                                    *
*     IUDIV    Division index of the user data bank                    *
*     LSUP     Address of bank in memory where data reside             *
*     NWKEY    Number of keys associated with the data bank            *
*     KEYO     Vector of old keys                                      *
*     KEYN     Vector of new keys                                      *
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *
*              IPREC significant digits right to the decimal points; if*
*              IPREC < 0, data are stored with IPREC insignificant     *
*              digits left to the decimal point.)                      *
*     CHOPT    Character string with any of the following characters   *
*          A   trust LBK address if non-zero                           *
*          B   Save in the special backup file; not in standard Journal*
*          C   create Node/Key data structure ala DBUSE                *
*          F   Updates with a fully matched data object (in user keys) *
*          K   Store data only inside the keys (not yet installed)     *
*          N   Create new (sub)directory(ies)                          *
*          P   Create partitioned subdirectories for the pathname      *
*          R   Store with full RZ option (No compression to be made)   *
*          S   Create stand alone (master) data                        *
*          T   Special text type of data (to be used with R)           *
*          U   Store data uncompressed                                 *
*          Z   Store only nonzero elements. An element is considered to*
*              be zero if its absolute value is less than IPREC (real) *
*          7   Insertion time as supplied by user to be honoured       *
*                                                                      *
*   Called by user,   DBAIWR, DBUPKY                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 61 : Too many keys                                   *
*               = 62 : Too many keys with option N                     *
*               = 63 : Data base structure in memory clobbered         *
*               = 64 : Error in MZCOPY while copying Data bank         *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DZPACK.
      DIMENSION       KEYN(9), KEYO(9), LBD(9), LBK(9), LSUP(9)
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, FPATH*80, CHOP*2
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Decode the character option
*
      LREFDB(1) = LBK(1)
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)     GO TO 999
      PACKDZ = .FALSE.
*
      IF (IOPUDA.NE.0.AND.IOPZDA.NE.0)  THEN
        IOPZDA = 0
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBREPL : Warning'//
     +  ' - Z option is incompatible with U option - U option will be'//
     +  ' executed'')', IARGDB, 0)
+SELF.
*
      ELSE IF (IOPZDA.NE.0)  THEN
        PACKDZ = .TRUE.
        CALL UCOPY (IPREC, PRECDZ, 1)
      ENDIF
*
      IF (IOPRDA.NE.0.AND.IOPNDA.NE.0)  THEN
        IOPNDA = 0
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBREPL : Warning'//
     +  ' - R option is incompatible with N option - R option will be'//
     +  ' executed'')', IARGDB, 0)
+SELF.
      ENDIF
*
* *** Check the number of keys
*
      IF (NWKEY.GT.MXDMDK)  THEN
        IQUEST(1) = 61
        IQUEST(11)= NWKEY
        IQUEST(12)= MXDMDK
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBREPL : Too man'//
     +  'y keys '',I6,'' maximum permitted '',I6)', IQUEST(11), 2)
+SELF.
        GO TO 999
      ENDIF
*
      IF (IOPNDA.NE.0.AND.NWKEY.GT.NINEDK)  THEN
        IQUEST(1) = 62
        IQUEST(11)= NWKEY
        IQUEST(12)= NINEDK
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBREPL : Too man'//
     +  'y keys '',I6,'' with option N - a maximum of '',I6,'' permit'//
     +  'ted'')', IQUEST(11), 2)
+SELF.
        GO TO 999
      ENDIF
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Create new subdirectories if needed
*
      IF (NWKEY.GE.NSYSDK)  THEN
        NTKEY  = NWKEY
      ELSE
        NTKEY  = NINEDK
      ENDIF
      IF (IOPNDA.NE.0)  THEN
        IF (IOPPDA.EQ.0)  THEN
          CALL DBMDIR (PATH, NTKEY, CHFTDK, CHTGDK)
        ELSE
          KEY7DK = 0
          CALL DBMDIP (PATH, NTKEY, CHFTDK, CHTGDK, MXKPDK)
        ENDIF
        IF (IQUEST(1).NE.0)   GO TO 999
      ENDIF
*
* *** Prepare the output with the old keys
*
      CALL VZERO (KEYVDK, MXDMDK)
      KEYVDK(MBVRDB) = KEYN(MBVRDB)
      KEYVDK(MEVRDB) = KEYN(MEVRDB)
      KEYVDK(MPVSDB) = KEYO(MPVSDB)
      KEYVDK(MFLGDB) = MSBIT1 (KEYVDK(MFLGDB), JIGNDB)
      IOKYDA(MPVSDB) = 1
      IF (IOKYDA(MITMDB).NE.0) KEYVDK(MITMDB) = KEYN(MITMDB)
      IF (NWKEY.GT.NSYSDK) THEN
        DO 20 NK = NSYSDK+1, NWKEY
          IOKYDA(NK) = 1
          KEYVDK(NK) = KEYO(NK)
   20   CONTINUE
      ENDIF
*
      IF (LSTRDL(3).NE.0) CALL MZDROP (IDISDB, LSTRDL(3), 'L')
      JBIAS  = 2
      CALL DBBOOK (IDISDB, LSTRDL(3), LSTRDL(3), JBIAS, 'SAME', 0, 0, 0
     +           , 2, 0)
      IF (IQUEST(1).NE.0)     GO TO 999
*
      CALL DBKOUT (PATH, IDISDB, LSTRDL(3), NTKEY, KEYVDK, IPREC)
      IF (IQUEST(1).NE.0)     GO TO 999
      IF (LSTRDL(3).NE.0) THEN
        CALL MZDROP (IDISDB, LSTRDL(3), 'L')
        LSTRDL(3) = 0
      ENDIF
*
* *** Prepare the Key vector array
*
      CALL VZERO (KEYVDK, MXDMDK)
      KEYVDK(MBVRDB) = KEYN(MBVRDB)
      KEYVDK(MEVRDB) = KEYN(MEVRDB)
      KEYVDK(MPVSDB) = KEYN(MPVSDB)
      IF (IOKYDA(MITMDB).NE.0) KEYVDK(MITMDB) = KEYN(MITMDB)
      IF (NWKEY.GT.NSYSDK) THEN
        DO 30 NK = NSYSDK+1, NWKEY
   30   KEYVDK(NK) = KEYN(NK)
      ENDIF
*
* *** Write out the data
*
      CALL DBKOUT (PATH, IUDIV, LSUP(1), NTKEY, KEYVDK, IPREC)
      IF (IQUEST(1).NE.0)     GO TO 999
*
* *** Create data bank in memory ala DBUSE
*
      IF (IOPCDA.NE.0)  THEN
*
*  **   Create database skeleton in memory (banks NODB and KYDB)
*
        IF (IOPADA.EQ.0. OR. (IOPADA.NE.0. AND. LREFDB(1).EQ.0) )  THEN
*
          CALL DBNODE (PATH, LBNODB)
          IF (IQUEST(1).NE.0) GO TO 999
*
*  *      Switch off M and/or S option of DBUSE
*
          ITMPM  = IOPMDA
          ITMPS  = IOPSDA
          IOPMDA = 0
          IOPSDA = 0
*
          CALL DBKEYS (LBNODB, KEYVDK, LBK, KEYVDK(MBVRDB))
          IF (IQUEST(1).NE.0) GO TO 999
          LREFDB(1) = LBK(1)
          IOPMDA = ITMPM
          IOPSDA = ITMPS
          CALL UCOPY (KEYVDK(1), IQ(KOFUDB+LREFDB(1)+1), NWKYDK)
          NDK    = IQ(KOFUDB+LREFDB(1)-1)
          IQ(KOFUDB+LREFDB(1)+NDK+MKYFRI) = 0
          IQ(KOFUDB+LREFDB(1)+NWKYDK+1)   = KEYVDK(MEVRDB)
*
        ELSE
+SELF, IF=$DEBUG.
*
          IF (IDEBDB.GT.0) THEN
            LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)
            NF     = IQ(KOFUDB+LBNODB+MNDNCH)
            CALL UHTOC (IQ(KOFUDB+LBNODB+MNDNAM), 4, FPATH, NF)
            FPATH  = FPATH(1:NF)
            N      = INDEX (PATH, ' ')
            IF (N.EQ.0)  N = LEN (PATH) + 1
*
   50       N      = N -1
            IF (PATH(N:N).NE.FPATH(NF:NF))  THEN
              IQUEST(1) = 63
              IQUEST(11)= N
              CALL DBPRNT (LPRTDB, '(/,'' DBREPL : Database structure'//
     +             ' in memory clobbered'')', IARGDB, 0)
              GO TO 999
            ELSE IF (N.NE.1)  THEN
              NF     = NF -1
              GO TO 50
            ENDIF
          ENDIF
+SELF.
*
          CALL UCOPY (KEYVDK(1), IQ(KOFUDB+LREFDB(1)+1), NWKYDK)
          NDK    = IQ(KOFUDB+LREFDB(1)-1)
          IQ(KOFUDB+LREFDB(1)+NDK+MKYFRI) = 0
          IQ(KOFUDB+LREFDB(1)+NWKYDK+1)   = KEYVDK(MEVRDB)
        ENDIF
*
*  **   Now copy the data banks appended at LSUP to the key bank
*
        IF (IOPRDA.EQ.0)  THEN
          CHOP   = 'NP'
        ELSE
          CHOP   = 'LP'
        ENDIF
*
        IF (IOPKDA.EQ.0 .AND. LSUP(1).NE.0) THEN
          CALL MZCOPY (IUDIV, LSUP(1), IDIVDB, LREFDB(1), -KLDADB, CHOP)
        ENDIF
*
        IF (IQUEST(1).EQ.0)  THEN
          LBD(1) = LQ(KOFUDB+LREFDB(1)-KLDADB)
        ELSE
          IQUEST(11)= IQUEST(1)
          IQUEST(1) = 64
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBREPL : Error'//
     +    ' '',I6,'' while copying the Data bank in the Node/Key stru'//
     +    'cture'')', IQUEST(11), 1)
+SELF.
        ENDIF
*
      ENDIF
*                                                             END DBREPL
  999 END
+DECK, DBRHLP.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBRHLP (PATH, LUN)
*     =============================
*
************************************************************************
*                                                                      *
*        SUBR. DBRHLP (PATH, LUN)                                      *
*                                                                      *
*   Retrieve the help information from data base and translate it      *
*   with Subroutine DBLIND and also write the ASCII format on a        *
*   given file specified by logical unit number LUN.                   *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATH     Character string describing the pathname                *
*     LUN      Logical unit number of the file with ASCII data         *
*                                                                      *
*   Called by user,   DBACPL, DBAUXI                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 66 : Illegal logical unit number                     *
*               =182 : The pathname specified does not exist           *
*               =203 : No help directory inside the data base          *
*               =204 : No help information for this path stored yet    *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, P3DBL3, IF=$P3CHILD.
      CHARACTER       PATH*(*), KLINE*80, PATHN*80, TOPN*16, PATHD*32
*
*     ------------------------------------------------------------------
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATH, PATHN, NCHAR)
*
      IF (LUN.LE.0) THEN
        IQUEST(1) = 66
        IQUEST(11)= LUN
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRHLP : Illegal'//
     +  ' unit number '',I10,'' for ASCII file'')', IQUEST(11), 1)
+SELF.
        GO TO 999
      ENDIF
*
* *** Check if the path name already exists in the help
*
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 182
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRHLP : Illgeal'//
     +  ' pathname '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      CALL RZCDIR (PATHN, 'R')
      NCHAR = LENOCC(PATHN)
*
* *** Find the unique directory identifier from the pathname
*
      CALL DBGPID (PATHN, NCHAR, TOPN, IDN)
      IF (IDN.LE.0) THEN
      IQUEST(1) = 182
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRHLP : Illgeal'//
     +  ' pathname '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Set the current directory to HELP and retrieve object
*
      NCH    = LENOCC (TOPN)
      PATHD  = '//'//TOPN(1:NCH)//'/HELP'
+SELF, IF=$DEBUG.
      NCH    = NCH + 7
+SELF.
      CALL RZCDIR (PATHD, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 203
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRHLP : Path na'//
     +  'me '//PATHD(1:NCH)//' not found'')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKEYT
      ISTP   = NWKYDK + 1
      IPNT   = KOFSDB + LCDRDB + IKDRDB
      KPNT   = IUHUNT (IDN, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)
      IF (KPNT.LE.0) THEN
        IQUEST(1) = 204
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRHLP : No help'//
     +  ' information for '//PATHN(1:NCHAR)//' available'')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      KEY1S  = (KPNT - MSERDB) / ISTP + 1
      CALL VZERO (KEYVDK, NWKYDK)
      KEYVDK(MSERDB) = KEY1S
      IF (LSTRDL(1).NE.0) THEN
        CALL MZDROP (IDISDB, LSTRDL(1), 'L')
        LSTRDL(1) = 0
      ENDIF
      IOLD1  = IOKYDA(MSERDB)
      IOLDK  = IOPKDA
      IOPKDA = 0
      IOKYDA(MSERDB) = 1
      ITIME  = 1
      CALL DBKXIN (ITIME, IDISDB, LSTRDL(1), LSTRDL(1), 2, NWKYDK,
     +             KEYVDK, IPREC)
      IER    = IQUEST(1)
      IOPKDA = IOLDK
      IOKYDA(MSERDB) = IOLD1
      IF (IER.NE.0) THEN
        CALL MZDROP (IDISDB, LSTRDL(1), 'L')
        IQUEST(1) = IER
        GO TO 999
      ENDIF
*
      IF (LSTRDL(1).GT.0) THEN
        NDATA  = IQ(KOFUDB+LSTRDL(1)-1)
        IF (NDATA.GT.0) THEN
+SELF, IF=-$P3CHILD.
*
*  **     Display data if exists, if it does not, display dummy data
*
          NTOT   = 0
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          NREC   = 0
+SELF, IF=-$P3CHILD.
  120     IF (NTOT.LT.NDATA) THEN
            CALL DBLIND (IQ(KOFUDB+LSTRDL(1)+1), NTOT, KLINE, LENG)
            IF (LENG.GT.0) THEN
              WRITE (LUN, 1000) KLINE(1:LENG)
            ELSE
              WRITE (LUN, *)
            ENDIF
+SELF, IF=$DEBUG, IF=-$P3CHILD.
            NREC   = NREC + 1
+SELF, IF=-$P3CHILD.
            GO TO 120
          ENDIF
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.1) THEN
            IARGDB(1) = NREC
            IARGDB(2) = IDN
            CALL DBPRNT (LPRTDB, '(/,'' DBRHLP : '',I10,'' records wr'//
     +           'itten for set '',I4)', IARGDB, 2)
          ENDIF
+SELF, IF=$P3CHILD.
          RNDBP3 = 'DBRHLP'
          NWDBP3 = 2
          IWDBP3(1) = LUN
          IWDBP3(2) = NDATA
          CALL DBCHLD
          IF (IQDBP3.EQ.0)
     +      CALL APFZUT (LODBP3, IDISDB, LSTRDL(1), 1, 'S', 0, 0, 0)
+SELF.
        ENDIF
      ENDIF
*
      IF (LSTRDL(1).NE.0) THEN
        IERR   = IQUEST(1)
        CALL MZDROP (IDISDB, LSTRDL(1), 'L')
        LSTRDL(1) = 0
        IQUEST(1) = IERR
      ENDIF
+SELF, IF=-$P3CHILD.
*
 1000 FORMAT (A)
+SELF.
*                                                             END DBRHLP
  999 END
+DECK, DBRKY1.
      SUBROUTINE DBRKY1 (PATHN, KEY1S, NKEY1)
*     =======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBRKY1 (PATHN, KEY1S*, *NKEY1*)                         *
*                                                                      *
*   Retrieves all the Key 1 values for the directory PATHN             *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     KEY1S(*) Vector containing the Key 1 values                      *
*     NKEY1    On input contains the maximum number of elements to be  *
*              stored in KEY1S; on return it will contain the true     *
*              number of objects                                       *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =101 : Illegal path name                               *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
      DIMENSION       KEY1S(9)
      CHARACTER       PATHN*(*), PATHY*80, PATHX*16
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Set the current directory
*
      NKMAX  = NKEY1
      NKEY1  = 0
      CALL DBSBLC (PATHN, PATHY, NCHAR)
      CALL RZCDIR (PATHY, ' ')
      IF (IQUEST(1).NE.0)            GO TO 991
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      ISTP   = NWKYDK + 1
      CALL DBKEYT
      IF (NKEYDK.EQ.0)               GO TO 999
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
      CALL RZCDIR (PATHY, 'R')
*
*  ** Find all key 1 values
*
      NCHR   = LENOCC (PATHY)
      IF (IOPTP.EQ.0) THEN
        IPNT   = KOFSDB + LCDRDB + IKDRDB
        DO 10 IK = 1, NKEYDK
          NKEY1  = NKEY1 + 1
          IF (NKEY1.LE.NKMAX) KEY1S(NKEY1) = IQ(IPNT+MSERDB)
          IPNT   = IPNT + ISTP
   10   CONTINUE
      ELSE
        NKEYS  = NKEYDK
        DO 20 IKK = 1, NKEYS
          CALL DBPATH (PATHX, IKK)
          PATHY  = PATHY(1:NCHR)//'/'//PATHX
          CALL RZCDIR (PATHY, ' ')
          IF (IQUEST(1).NE.0)        GO TO 991
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          NKEYDK = IQUEST(7)
          IPNT   = KOFSDB + LCDRDB + IKDRDB
          DO 15 IK = 1, NKEYDK
            NKEY1  = NKEY1 + 1
            IF (NKEY1.LE.NKMAX) KEY1S(NKEY1) = IQ(IPNT+MSERDB)
            IPNT   = IPNT + ISTP
   15     CONTINUE
   20   CONTINUE
      ENDIF
*
      IQUEST(1) = 0
      GO TO 999
*
* *** Error messages
*
  991 IQUEST(1) = 101
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRKY1 : Illegal '//
     +   'Path Name '//PATHY//''')', IARGDB, 0)
+SELF.
*                                                             END DBRKY1
  999 END
+DECK, DBRNAM.
      SUBROUTINE DBRNAM (PATH, NWMAX, CHTAG)
*     ======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBRNAM (PATH, *NWMAX*, CHTAG*)                          *
*                                                                      *
*   Retrieves the names of the data elements of a given directory      *
*   from the data base                                                 *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATH     Character string describing the pathname                *
*     NWMAX    Maximum number of data word elements for CHTAG          *
*              (on return it contains the number of CHTAG filled in)   *
*     CHTAG(*) Name of the data elements                               *
*                                                                      *
*   Called by user,   DBAUXI                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =182 : Illegal path name                               *
*               =201 : DICTIONARY directory not found                  *
*               =202 : No description of data elements for the given   *
*                      path name exists in the data base               *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
      CHARACTER       PATHN*80, CTAG*8, TOPN*16, PATHD*32, PATH*(*)
      CHARACTER*(*)   CHTAG(*)
*
*     ------------------------------------------------------------------
*
* *** See if the path name is correct
*
      CALL DBSBLC (PATH, PATHN, NCHAR)
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 182
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRNAM : Illegal'//
     +  ' path name '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL RZCDIR (PATHN, 'R')
      NCHAR  = LENOCC (PATHN)
      CALL DBGPID (PATHN, NCHAR, TOPN, IDN)
      IF (IDN.LE.0) THEN
        IQUEST(1) = 182
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRNAM : Illegal'//
     +  ' path name '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Set the current directory to DICTIONARY and retrieve object
*
      NCH    = LENOCC (TOPN)
      PATHD  = '//'//TOPN(1:NCH)//'/DICTIONARY'
      CALL RZCDIR (PATHD, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 201
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRNAM : Path na'//
     +  'me '//PATHD(1:NCH)//' not found'')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKEYT
      ISTP   = NWKYDK + 1
      IPNT   = KOFSDB + LCDRDB + IKDRDB
      KPNT   = IUHUNT (IDN, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)
      IF (KPNT.LE.0) THEN
        IQUEST(1) = 202
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRNAM : No info'//
     +  'rmation for '//PATHN(1:NCHAR)//' inside Data Base'')',IARGDB,0)
+SELF.
        GO TO 999
      ENDIF
      KEY1S  = (KPNT - MSERDB) / ISTP + 1
      CALL VZERO (KEYVDK, NWKYDK)
      KEYVDK(MSERDB) = KEY1S
      IF (LSTRDL(1).NE.0) THEN
        CALL MZDROP (IDISDB, LSTRDL(1), 'L')
        LSTRDL(1) = 0
      ENDIF
      IOLD1  = IOKYDA(MSERDB)
      IOLDK  = IOPKDA
      IOPKDA = 0
      IOKYDA(MSERDB) = 1
      ITIME  = 1
      CALL DBKXIN (ITIME, IDISDB, LSTRDL(1), LSTRDL(1), 2, NWKYDK,
     +             KEYVDK, IPREC)
      IER    = IQUEST(1)
      IOPKDA = IOLDK
      IOKYDA(MSERDB) = IOLD1
      IF (IER.NE.0) THEN
        CALL MZDROP (IDISDB, LSTRDL(1), 'L')
        IQUEST(1) = IER
        GO TO 999
      ENDIF
*
* *** Now store the information in the user array
*
      IPNT   = KOFUDB + LSTRDL(1)
      NWDS   = IQ(IPNT-1) / 2
      NWMAX  = MIN0 (NWDS, NWMAX)
      DO 10 I = 1, NWMAX
        CALL UHTOC (IQ(IPNT+1), 4, CTAG, 8)
        CHTAG(I) = CTAG
        IPNT   = IPNT + 2
   10 CONTINUE
      CALL MZDROP (IDISDB, LSTRDL(1), 'L')
      LSTRDL(1) = 0
      IQUEST(1) = 0
*                                                             END DBRNAM
  999 END
+DECK, DBRTFZ.
      SUBROUTINE DBRTFZ (PATHI, LUNFZ, K1MIN, K1MAX, CHOPT)
*     =====================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBRTFZ (PATHI, LUNFZ, K1MIN, K1MAX, CHOPT)              *
*                                                                      *
*   Copies a part of the directory (in the range K1MIN-K1MAX) into a   *
*   sequential file in the format of the journal file                  *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHI    Character string describing the input  pathname         *
*     LUNFZ    Logical unit number of the output FZ file               *
*     K1MIN    Minumum serial number (Key 1 value) to be copied        *
*     K1MAX    Maximum serial number (Key 1 value) to be copied        *
*     CHOPT    Character string with any of the following characters   *
*          F   Updates with a fully matched data object (in user keys) *
*                                                                      *
*   Called by user,   DBAUXI                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 71 : Illegal path name                               *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DSAVBK.
+CDE, DZPACK.
      CHARACTER       PATHY*80, PATH*80, PATHX*16, CHOPS*4
      CHARACTER       PATHI*(*), CHOPT*(*)
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Suppress blanks from the path name
*
      CALL DBOPTS (' ')
      CALL UOPTC  (CHOPT, 'F', IOPFDA)
      CALL DBSBLC (PATHI, PATH, NCHRI)
      LUFZDF = LUNFZ
      IF (LUFZDF.LE.0)             GO TO 999
      IF (K1MIN.LT.1) THEN
        KYMIN  = 1
      ELSE
        KYMIN  = K1MIN
      ENDIF
      IF (K1MAX.LT.KYMIN) THEN
        KYMAX  = KYMIN + 100000
      ELSE
        KYMAX  = K1MAX
      ENDIF
*
* *** Set the current directory for input path name
*
      PATHX  = ' '
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 71
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRTFZ : Illegal'//
     +  ' Path Name '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      KST    = NWKYDK + 1
      IF (NKEYDK.LE.0)             GO TO 999
      CALL RZCDIR (PATH, 'R')
      NCHRI  = LENOCC (PATH)
      CALL DBKEYT
      IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)
      IOPTP  = JBIT (IOPTP, JPRTDB)
*
* *** Partially fill up the header
*
      NDOP   = 1
      NWDP   = (NCHRI + 3) / 4
      NWHEDF = NWDP + NDOP + NWKYDK + 5
      IHEADF(MACTDF) = 1
      IHEADF(MNKYDF) = NWKYDK
      IHEADF(MOPTDF) = NDOP
      IHEADF(MPATDF) = NWDP
      CALL UCTOH (PATH, IHEADF(MPREDF+NWKYDK+NDOP+1), 4, 4*NWDP)
*
* *** Start reading in records from the input file
*
      ITIME  = 1
      JBIAS  = 2
      NOBJDS = 0
      IF (IOPTP.EQ.0) THEN
        DO 20 IK = 1, NKEYDK
          KEY1   = IQ(KOFSDB+LCDRDB+IKDRDB+(IK-1)*KST+MSERDB)
          IF (KEY1.GE.KYMIN.AND.KEY1.LE.KYMAX) THEN
            IOPKDA = 0
            PACKDZ = .FALSE.
            NOBJDS = 1
            KEYSDS(MSERDB,NOBJDS) = IK
            IOKYDA(MSERDB) = 1
            CALL DBKXIN (ITIME, IDISDB, LOBJDS(NOBJDS), LOBJDS(NOBJDS),
     +                   JBIAS, NWKEY, KEYSDS(1,NOBJDS), IPREC)
            IOKYDA(MSERDB) = 0
            IF (IQUEST(1).NE.0)    GO TO 997
            IF (JBIT(KEYSDS(MFLGDB,NOBJDS),JRZUDB).NE.0) THEN
              IF (JBIT(KEYSDS(MFLGDB,NOBJDS),JASFDB).NE.0) THEN
                CHOPS  = '7RT'
              ELSE
                CHOPS  = '7R'
              ENDIF
            ELSE
              CALL DBRZIN (IDISDB, LSTRDL(2), 2, IK, ICYCL, PATH)
              IF (IQUEST(1).NE.0) THEN
                IER       = IQUEST(1)
                CALL MZDROP (IDISDB, LSTRDL(2), 'L')
                IQUEST(1) = IER
                GO TO 997
              ENDIF
              CALL UCOPY (Q(KOFUDB+LSTRDL(2)+3), IXX, 1)
              IF (IQ(KOFUDB+LSTRDL(2)+1).EQ.0) THEN
                IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN
                  CHOPS  = '7SU'
                ELSE
                  CHOPS  = '7U'
                ENDIF
              ELSE
                PACKDZ = (JBIT(IXX,32).EQ.0)
                IF (PACKDZ) THEN
                  IDTY   = IDBTYP (LSTRDL(2))
                  IF (IDTY.EQ.3) THEN
                    PRECDZ =  Q(KOFUDB+LSTRDL(2)+2)
                  ELSE
                    PRECDZ = IQ(KOFUDB+LSTRDL(2)+2)
                  ENDIF
                  IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN
                    CHOPS  = '7ZS'
                  ELSE
                    CHOPS  = '7Z'
                  ENDIF
                ELSE
                  IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN
                    CHOPS  = '7S'
                  ELSE
                    CHOPS  = '7'
                  ENDIF
                ENDIF
              ENDIF
              CALL MZDROP (IDISDB, LSTRDL(2), 'L')
            ENDIF
            CALL DBFZWR (IPREC, CHOPS)
            IERR   = IQUEST(1)
            CALL MZDROP (IDISDB, LOBJDS(NOBJDS), 'L')
            NOBJDS = 0
            IQUEST(1) = IERR
            IF (IQUEST(1).NE.0)    GO TO 997
          ENDIF
   20   CONTINUE
*
      ELSE
*
*   **  Partitioned directory
*
        NKEYS  = NKEYDK
        DO 30 IKK = 1, NKEYS
          KPNT   = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                     NKEYS*KST, KST)
          IF (KPNT.GT.0) THEN
            KPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB
          ELSE
            KPNT   = KOFSDB + LCDRDB + IKDRDB + (IKK - 1) * KST
          ENDIF
          KYMP   = IQ(KPNT+MOBJDB)
          IF (KYMP.GT.KYMAX)       GO TO 30
          CALL DBPATH (PATHX, IKK)
          PATHY  = PATH(1:NCHRI)//'/'//PATHX
          CALL RZCDIR (PATHY, ' ')
          IF (IQUEST(1).NE.0) THEN
            IQUEST(1) = 71
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRTFZ : Ill'//
     +      'egal Path Name '//PATHY//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          DO 25 IK = 1, NKEYDK
            KEY1   = IQ(KOFSDB+LCDRDB+IKDRDB+(IK-1)*KST+MSERDB)
            IF (KEY1.GE.KYMIN.AND.KEY1.LE.KYMAX) THEN
              IOPKDA = 0
              PACKDZ = .FALSE.
              NOBJDS = 1
              KEYSDS(MSERDB,NOBJDS) = IK
              IOKYDA(MSERDB) = 1
              CALL DBKXIN (ITIME, IDISDB, LOBJDS(NOBJDS),LOBJDS(NOBJDS),
     +                     JBIAS, NWKEY, KEYSDS(1,NOBJDS), IPREC)
              IOKYDA(MSERDB) = 0
              IF (IQUEST(1).NE.0)  GO TO 997
              IF (JBIT(KEYSDS(MFLGDB,NOBJDS),JRZUDB).NE.0) THEN
                IF (JBIT(KEYSDS(MFLGDB,NOBJDS),JASFDB).NE.0) THEN
                  CHOPS  = '7RT'
                ELSE
                  CHOPS  = '7R'
                ENDIF
              ELSE
                CALL DBRZIN (IDISDB, LSTRDL(2), 2, IK, ICYCL, PATHY)
                IF (IQUEST(1).NE.0) THEN
                  IER    = IQUEST(1)
                  CALL MZDROP (IDISDB, LSTRDL(2), 'L')
                  IQUEST(1) = IER
                  GO TO 997
                ENDIF
                CALL UCOPY (Q(KOFUDB+LSTRDL(2)+3), IXX, 1)
                IF (IQ(KOFUDB+LSTRDL(2)+1).EQ.0) THEN
                  IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN
                    CHOPS  = '7SU'
                  ELSE
                    CHOPS  = '7U'
                  ENDIF
                ELSE
                  PACKDZ = (JBIT(IXX,32).EQ.0)
                  IF (PACKDZ) THEN
                    IDTY   = IDBTYP (LSTRDL(2))
                    IF (IDTY.EQ.3) THEN
                      PRECDZ =  Q(KOFUDB+LSTRDL(2)+2)
                    ELSE
                      PRECDZ = IQ(KOFUDB+LSTRDL(2)+2)
                    ENDIF
                    IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN
                      CHOPS  = '7ZS'
                    ELSE
                      CHOPS  = '7Z'
                    ENDIF
                  ELSE
                    IF (KEYSDS(MUPNDB,NOBJDS).EQ.0) THEN
                      CHOPS  = '7S'
                    ELSE
                      CHOPS  = '7'
                    ENDIF
                  ENDIF
                ENDIF
                CALL MZDROP (IDISDB, LSTRDL(2), 'L')
              ENDIF
              CALL DBFZWR (IPREC, CHOPS)
              IERR   = IQUEST(1)
              CALL MZDROP (IDISDB, LOBJDS(NOBJDS), 'L')
              NOBJDS = 0
              IQUEST(1) = IERR
              IF (IQUEST(1).NE.0)  GO TO 997
            ENDIF
   25     CONTINUE
*
          CALL RZCDIR (PATH, ' ')
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
   30   CONTINUE
*
      ENDIF
*
* *** Drop the stored banks
*
  997 IER    = IQUEST(1)
      IF (NOBJDS.GT.0) THEN
        DO 998 IOBJ = 1, NOBJDS
          CALL MZDROP (IDISDB, LOBJDS(IOBJ), 'L')
  998   CONTINUE
        NOBJDS = 0
        IQUEST(1) = IER
      ENDIF
*                                                             END DBRTFZ
  999 END
+DECK, DBSAVE.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBSAVE
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBSAVE                                                  *
*                                                                      *
*   Sends the spool file to the server for updating the data base.     *
*   Useful only for interactive programs running on IBM                *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
*     ------------------------------------------------------------------
*
      IQUEST(1) = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
      CALL DBSTSV (' ', 0)
+SELF.
*                                                             END DBSAVE
      END
+DECK, DBSRTM.
      SUBROUTINE DBSRTM (PATHN, MNDAT, MNTIM, MXDAT, MXTIM, IUDIV, LSUP,
     +                   IPREC)
*     ==================================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBSRTM (PATHN, MNDAT, MNTIM, MXDAT, MXTIM, IUDIV, LSUP*,*
*                      IPREC*)                                         *
*                                                                      *
*   Fetches from disk to memory an object inserted between certain     *
*   time                                                               *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     MNDAT    Minimum date for insertion                              *
*     MNTIM    Minimum time for insertion                              *
*     MXDAT    Maximum date for insertion                              *
*     MXTIM    Maximum time for insertion                              *
*     IUDIV    Division index where bank is expected                   *
*     LSUP(*)  Address of the bank in memory                           *
*     IPREC(*) Precision word; (If IPREC > 0, data are stored with     *
*              IPREC significant digits right to the decimal points; if*
*              IPREC < 0, data are stored with IPREC insignificant     *
*              digits left to the decimal point.)                      *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 31 : Illegal path name                               *
*               = 32 : No keys/data in this directory                  *
*               = 33 : No valid data for the given range of insertion  *
*                      time                                            *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
      DIMENSION       LSUP(9)
      CHARACTER       PATHN*(*), PATH*80, PATHX*16
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Initialise the option array
*
      CALL DBOPTS (' ')
      IF (IQUEST(1).NE.0)     GO TO 999
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Set the current directory
*
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0)     GO TO 991
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKEYT
      CALL RZCDIR (PATH, 'R')
+SELF, IF=$DEBUG.
      NCHAR  = INDEX (PATH, ' ') - 1
      IF (NCHAR.LT.1.OR.NCHAR.GT.MAXLDB) NCHAR = MAXLDB
+SELF.
      ITIME  = 0
      JBIAS  = 2
*
* *** Check the number of keys
*
      IF (NKEYDK.EQ.0)        GO TO 992
*
* *** Check the validity limits from the Keys
*
      IOKYDA(MSERDB) = 1
      MRET   = 0
      IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)
      IOPTP  = JBIT (IOPTP, JPRTDB)
      ISTP   = NWKYDK + 1
*
      IF (IOPTP.EQ.0)  THEN
*
*  **   For non-partitioned dataset
*
        DO 20 IK = 1, NKEYDK
*
          IPNT   = KOFSDB + LCDRDB + IKDRDB + (IK-1) * ISTP
          CALL DBUPTM (IDATE, ITIME, IQ(IPNT+MITMDB))
          IF ((IDATE.GT.MNDAT.AND.IDATE.LT.MXDAT) .OR.
     +        (IDATE.EQ.MNDAT.AND.ITIME.GE.MNTIM.AND.MNDAT.NE.MXDAT).OR.
     +        (IDATE.EQ.MXDAT.AND.ITIME.LE.MXTIM.AND.MNDAT.NE.MXDAT).OR.
     +        (IDATE.EQ.MNDAT.AND.ITIME.GE.MNTIM.AND.ITIME.LE.MXTIM.AND.
     +         MNDAT.EQ.MXDAT))  THEN
*
            IF (MRET.NE.0.AND.MRET.LT.IQ(IPNT+MITMDB))  THEN
              IF (LSUP(1).NE.0)  THEN
                CALL MZDROP (IUDIV, LSUP, ' ')
                LSUP(1) = 0
              ENDIF
              CALL VZERO (KEYVDK, NWKYDK)
              KEYVDK(MSERDB) = IK
              CALL DBKXIN (ITIME, IUDIV, LSUP(1), LSUP(1), JBIAS, NWKEY,
     +                     KEYVDK, IPREC)
*
              IF (IQUEST(1).EQ.0)  THEN
                MRET   = KEYVDK(MITMDB)
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.1) THEN
                  CALL UCOPY (KEYVDK(1), IARGDB, 5)
                  IARGDB(6) = IDATE
                  IARGDB(7) = ITIME
                  CALL DBPRNT (LPRTDB, '(/,'' DBSRTM : Data with Ke'//
     +                 'y'',2I8,2I10,I6,'' retrieved for '//PATH(1:40)
     +                 //''',/,10X,''Created on the '',I8,'' at '','//
     +                 'I6)', IARGDB, 7)
                ENDIF
+SELF.
*
              ELSE
                MRET   = 0
                IF (LSUP(1).NE.0) THEN
                  CALL MZDROP (IUDIV, LSUP, ' ')
                  LSUP(1) = 0
                ENDIF
*
              ENDIF
            ENDIF
*
          ENDIF
*
   20   CONTINUE
*
      ELSE
*
*  **   For partitioned dataset
*
        NKEYS  = NKEYDK
        KST    = NWKYDK + 1
        DO 40 JK = 1, NKEYS
          ICURDT = NKEYS + 1 - JK
*
          CALL RZCDIR (PATH, ' ')
          IF (IQUEST(1).NE.0) GO TO 991
          NWKYDK = IQUEST(8)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          KPNT   = IUHUNT (ICURDT, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                     NKEYS*KST, KST)
          IF (KPNT.NE.0) THEN
            IPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB
          ELSE
            IPNT   = KOFSDB + LCDRDB + IKDRDB + (ICURDT - 1) * KST
          ENDIF
          CALL DBUPTM (IDATE, ITIME, IQ(IPNT+MITMDB))
          IF ((IDATE.LT.MNDAT).OR.(IDATE.EQ.MNDAT.AND.ITIME.LT.MNTIM))
     +                        GO TO 40
*
          CALL DBPATH (PATHX, ICURDT)
          CALL RZCDIR (PATHX, ' ')
          IF (IQUEST(1).EQ.0)  THEN
            IQUEST(1) = 31
+SELF, IF=$DEBUG.
            PATH   = PATH(1:NCHAR)//'/'//PATHX
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBSRTM : Ill'//
     +      'egal Path Name '//PATH//''')', IARGDB, 0)
+SELF.
            IOKYDA(MSERDB) = 0
            GO TO 999
          ENDIF
          NKEYDK = IQUEST(7)
          NWKYDK = IQUEST(8)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          ISTP   = NWKYDK + 1
          CALL DBKEYT
          DO 30 IK = 1, NKEYDK
            IPNT   = KOFSDB + LCDRDB + IKDRDB + (IK-1) * ISTP
            CALL DBUPTM (IDATE, ITIME, IQ(IPNT+MITMDB))
            IF ((IDATE.GT.MNDAT.AND.IDATE.LT.MXDAT) .OR.
     +          (IDATE.EQ.MNDAT.AND.ITIME.GE.MNTIM.AND.MNDAT.NE.MXDAT)
     +      .OR.(IDATE.EQ.MXDAT.AND.ITIME.LE.MXTIM.AND.MNDAT.NE.MXDAT)
     +      .OR.(IDATE.EQ.MNDAT.AND.ITIME.GE.MNTIM.AND.ITIME.LE.MXTIM
     +           .AND.MNDAT.EQ.MXDAT))  THEN
*
              IF (MRET.NE.0.AND.MRET.LT.IQ(IPNT+MITMDB))  THEN
                IF (LSUP(1).NE.0)  THEN
                  CALL MZDROP (IUDIV, LSUP, ' ')
                  LSUP(1) = 0
                ENDIF
                CALL VZERO (KEYVDK, NWKYDK)
                KEYVDK(MSERDB) = IK
                CALL DBKXIN (ITIME, IUDIV, LSUP(1), LSUP(1), JBIAS,
     +                       NWKEY, KEYVDK, IPREC)
*
                IF (IQUEST(1).EQ.0)  THEN
*
                  MRET   = KEYVDK(MITMDB)
+SELF, IF=$DEBUG.
                  IF (IDEBDB.GT.1) THEN
                    CALL UCOPY (KEYVDK(1), IARGDB, 5)
                    IARGDB(6) = IDATE
                    IARGDB(7) = ITIME
                    CALL DBPRNT (LPRTDB, '(/,'' DBSRTM : Data with Ke'//
     +                   'y'',2I8,2I10,I6,'' retrieved for '//PATH(1:40)
     +                   //''',/,10X,''Created on the '',I8,'' at '','//
     +                   'I6)', IARGDB, 7)
                  ENDIF
+SELF.
*
                ELSE
*
                  MRET   = 0
                  IF (LSUP(1).NE.0) THEN
                    CALL MZDROP (IUDIV, LSUP, ' ')
                    LSUP(1) = 0
                  ENDIF
*
                ENDIF
              ENDIF
*
            ENDIF
*
   30     CONTINUE
*
          IF (MRET.NE.0)      GO TO 50
   40   CONTINUE
*
      ENDIF
   50 IOKYDA(MSERDB) = 0
      IF (MRET.EQ.0)          GO TO 993
      GO TO 999
*
* *** Error messages
*
  991 IQUEST(1) = 31
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBSRTM : Illegal '//
     +   'Path Name '//PATH//''')', IARGDB, 0)
+SELF.
      IOKYDA(MSERDB) = 0
      GO TO 999
*
  992 IQUEST(1) = 32
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBSRTM : No key or'//
     +   ' data for Path Name '//PATH//''')', IARGDB, 0)
+SELF.
      GO TO 999
*
  993 IQUEST(1) = 33
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) THEN
        IARGDB(1) = MNDAT
        IARGDB(2) = MNTIM
        IARGDB(3) = MXDAT
        IARGDB(4) = MXTIM
        CALL DBPRNT (LPRTDB, '(/,'' DBSRTM : No data in '//PATH(1:40)//
     +       ' inserted between '',2I8,'' and '',2I8)', IARGDB, 4)
      ENDIF
+SELF.
      GO TO 999
*                                                             END DBSRTM
  999 END
+DECK, DBTBCR.
      SUBROUTINE DBTBCR (IUDIV, LAD, LSUP, JBIAS)
*     ===========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBTBCR (IUDIV, LAD*, LSUP, JBIAS)                       *
*                                                                      *
*   Creates DBTB bank with information of the data base objects used   *
*   for this event (till the last call to DBTBCR). It stores 2 words   *
*   per object used, a unique identifier corresponding to the path     *
*   name and the serial number of the object (KEY(1) value)            *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IUDIV    User division where the DBTB bank has to be created     *
*     LAD(*)   Address of the DBTB bank (should be in the same store   *
*              as all DB objects)                                      *
*     LSUP     Address of the supporting bank                          *
*     JBIAS    Link bias as described in ZEBRA manual                  *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
      PARAMETER       (NLEVM=20, NDMAX=100)
      DIMENSION       LSUP(9), LAD(9), ISDI(NLEVM), NSDI(NLEVM)
*
*     ------------------------------------------------------------------
*
* *** Loop over all top directories
*
      LREFDB(1) = LSUP(1)
      NDAT   = 0
      LBFXDB = LTOPDB
   10 IF (LBFXDB.GT.0) THEN
        NLEV   = 0
        LBNODB = LQ(KOFUDB+LBFXDB-1)
*
*  **   Scan down the nodes to find all the subdirectories
*
   15   IF (LBNODB.GT.0) THEN
          NLEV   = NLEV + 1
          ISDI(NLEV) = 0
          NSDI(NLEV) = IQ(KOFUDB+LBNODB-KLNODB)
*
   20     ISDI(NLEV) = ISDI(NLEV) + 1
          IF (ISDI(NLEV).LE.NSDI(NLEV)) THEN
*
*  **       If a new subdirectory go down one level
*
            LBD    = LQ(KOFUDB+LBNODB-ISDI(NLEV))
            IF (LBD.GT.0) THEN
              LBNODB = LBD
              GO TO 15
            ELSE
              GO TO 20
            ENDIF
*
          ELSE
*
*  **       Loop over all the key banks
*
            NDK    = IQ(KOFUDB+LBNODB+MNDNWD)
            IDIC   = IQ(KOFUDB+LBNODB+MNDDIC)
            LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)
   25       IF (LBKYDB.GT.0) THEN
              IF (IQ(KOFUDB+LBKYDB+NDK+MKYCEV).GT.0) THEN
                IF (NDAT.EQ.0) THEN
                  NDTOT  = NDMAX
                  CALL DBBOOK (IUDIV, LAD(1), LREFDB(1), JBIAS, 'DBTB',
     +                         0, 0, NDTOT, 2, -1)
                  IF (IQUEST(1).NE.0) GO TO 999
                  LREFDB(2) = LAD(1)
                ELSE IF (NDAT.GE.NDTOT) THEN
                  NDTOT  = NDTOT + NDMAX
                  CALL DBBOOK (IUDIV, LAD(1), LREFDB(1), JBIAS, 'DBTB',
     +                         0, 0, NDTOT, 2, -1)
                  IF (IQUEST(1).NE.0) GO TO 999
                  LREFDB(2) = LAD(1)
                  LBD    = LQ(KOFUDB+LREFDB(1))
                  CALL UCOPY (IQ(KOFUDB+LBD+1), IQ(KOFUDB+LREFDB(2)+1),
     +                        NDAT)
                  CALL MZDROP (IUDIV, LBD, 'L')
                ENDIF
                IQ(KOFUDB+LREFDB(2)+NDAT+1) = IDIC
                IQ(KOFUDB+LREFDB(2)+NDAT+2) = IQ(KOFUDB+LBKYDB+MSERDB)
                NDAT   = NDAT + 2
                IQ(KOFUDB+LBKYDB+NDK+MKYCEV)  = 0
              ENDIF
              LBKYDB = LQ(KOFUDB+LBKYDB)
              GO TO 25
            ENDIF
*
*  **       Now go up one level
*
   30       NLEV   = NLEV - 1
            IF (NLEV.GT.0) THEN
              LBNODB = LQ(KOFUDB+LBNODB+1)
              GO TO 20
            ENDIF
          ENDIF
        ENDIF
*
        LBFXDB = LQ(KOFUDB+LBFXDB)
        GO TO 10
      ENDIF
*
* *** Now shrink DBTB bank if needed
*
      IF (NDAT.GT.0) THEN
        IF (NDAT.LT.NDTOT) THEN
          NDPUS  = NDAT - NDTOT
          CALL MZPUSH (IUDIV, LREFDB(2), 0, NDPUS, 'I')
        ENDIF
      ENDIF
*
      IQUEST(1) = 0
*                                                             END DBTBCR
  999 END
+DECK, DBTBPR.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBTBPR
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBTBPR                                                  *
*                                                                      *
*   Prints accumulated summary for the given run with the Data Base    *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 98 : Invalid path name in Node bank                  *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
      CHARACTER     PATH*80, CHSTR*132, CFMT*136
*
*     ------------------------------------------------------------------
*
* *** Loop over all node banks
*
      CALL DBPRNT (LPRTDB, '(/,'' DBTBPR : Summary of Database Elemen'//
     +     'ts used '',/,'' ========================================='//
     +     '= '')', IARGDB, 0)
      CALL DBPRNT (LPRTDB, '(/,20X,''Path name'',28X,''DBUSE Call/Dat'//
     +     'a Read Key 5'',5X,''User Keys'',/)', IARGDB, 0)
      CFMT(1:2)     = '('''
      CFMT(135:136) = ''')'
      CFMT(3:134)   = ' '
      LBFXDB = LTOPDB
   10 IF (LBFXDB.EQ.0)        GO TO 80
*
      LBNODB = LQ(KOFUDB+LBFXDB-1)
      IF (LBNODB.EQ.0)        GO TO 70
*
*  ** Store the number of structural links already looked
*  ** at bank number address
*
   20 IQ(KOFUDB+LBNODB-5) = IQ(KOFUDB+LBNODB-2)
*
*  *  If all the links have not been looked at; go the next
*  *  link
*
   30 IF (IQ(KOFUDB+LBNODB-5).NE.0) THEN
        IQ(KOFUDB+LBNODB-5) = IQ(KOFUDB+LBNODB-5) - 1
        N      = IQ(KOFUDB+LBNODB-2) - IQ(KOFUDB+LBNODB-5)
        LBAD   = LQ(KOFUDB+LBNODB-N)
        IF (LBAD.NE.0)  THEN
          LBNODB = LBAD
          GO TO 20
        ELSE
          GO TO 30
        ENDIF
*
*  *  Otherwise look at this Node bank
*
      ELSE
*
        NDK    = IQ(KOFUDB+LBNODB+MNDNWD)
        NCHAR  = IQ(KOFUDB+LBNODB+MNDNCH)
        CALL UHTOC (IQ(KOFUDB+LBNODB+MNDNAM), 4, PATH, NCHAR)
        PATH   = PATH(1:NCHAR)
*
        CALL RZCDIR (PATH, ' ')
        IF (IQUEST(1).NE.0)  THEN
          IQUEST(1) = 98
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBTBPR : Illeg'//
     +    'al Path name '//PATH(1:60)//' in node bank'')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
*
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        NKEYDK = IQUEST(7)
        NWKYDK = IQUEST(8)
        CALL DBKEYT
*
*  *    Loop over all key banks at this Node
*
        LBKYDB = LQ(KOFUDB+LBNODB-KLKYDB)
   40   IF (LBKYDB.EQ.0)      GO TO 60
*
*  *    Prepare the header part
*
+SELF, IF=-IBM, -$P3CHILD.
        WRITE (CHSTR, 8001) PATH, IQ(KOFUDB+LBKYDB+NDK+MKYCRU),
     +                      IQ(KOFUDB+LBKYDB+NDK+MKYRID),
     +                      IQ(KOFUDB+LBKYDB+MPVSDB)
+SELF, IF=IBM, IF=$P3CHILD.
        IARGDB(1) = IQ(KOFUDB+LBKYDB+NDK+MKYCRU)
        IARGDB(2) = IQ(KOFUDB+LBKYDB+NDK+MKYRID)
        IARGDB(3) = IQ(KOFUDB+LBKYDB+MPVSDB)
        CHSTR  = ' '
        CALL UTWRIT (CHSTR, '('' '//PATH(1:56)//''',2I10,I6)', IARGDB,3)
+SELF.
        NS1    = 84
*
*  *    Loop over user keys
*
        IF (NWKYDK.GT.NSYSDK)  THEN
          DO 50 I = NSYSDK+1, NWKYDK
            IF (NS1.GT.120)  THEN
              CFMT(3:134)   = CHSTR
              CALL DBPRNT (LPRTDB, CFMT, IARGDB, 0)
              CHSTR  = ' '
              NS1    = 84
            ENDIF
            IF (IOTYDK(I).EQ.2)  THEN
              NS2    = NS1 + 9
+SELF, IF=-IBM, -$P3CHILD.
              WRITE (CHSTR(NS1:NS2), 8002) IQ(KOFUDB+LBKYDB+I)
+SELF, IF=IBM, IF=$P3CHILD.
              CALL UTWRIT (CHSTR(NS1:NS2), '(I10)',
     +                     IQ(KOFUDB+LBKYDB+I), 1)
+SELF.
            ELSE IF (IOTYDK(I).EQ.5 .OR. IOTYDK(I).EQ.6)  THEN
              NS2    = NS1 + 7
+SELF, IF=-IBM, -$P3CHILD.
              WRITE (CHSTR(NS1:NS2), 8003) IQ(KOFUDB+LBKYDB+I)
+SELF, IF=IBM, IF=$P3CHILD.
              CALL UTWRIT (CHSTR(NS1:NS2), '(4X,A4)',
     +                     IQ(KOFUDB+LBKYDB+I), 1)
+SELF.
            ELSE
              NS2    = NS1 + 9
+SELF, IF=-IBM, -$P3CHILD.
              WRITE (CHSTR(NS1:NS2), 8004) IQ(KOFUDB+LBKYDB+I)
+SELF, IF=IBM, IF=$P3CHILD.
              CALL UTWRIT (CHSTR(NS1:NS2), '(Z10)',
     +                     IQ(KOFUDB+LBKYDB+I), 1)
+SELF.
            ENDIF
            NS1    = NS1 + 12
   50     CONTINUE
        ENDIF
*
        CFMT(3:134)   = CHSTR
        CALL DBPRNT (LPRTDB, CFMT, IARGDB, 0)
*
        LBKYDB = LQ(KOFUDB+LBKYDB)
        GO TO 40
*
   60   LBNODB = LQ(KOFUDB+LBNODB+1)
        IF (LBNODB.NE.LBFXDB) GO TO 30
      ENDIF
*
   70 LBFXDB = LQ(KOFUDB+LBFXDB)
      GO TO 10
   80 CONTINUE
+SELF, IF=-IBM, -$P3CHILD.
*
 8001 FORMAT (1X,A56,2I10,I6)
 8002 FORMAT (I10)
 8003 FORMAT (4X,A4)
 8004 FORMAT (Z10)
+SELF.
*                                                             END DBTBPR
  999 END
+DECK, DBUPTM.
      SUBROUTINE DBUPTM (IDATE, ITIME, IDATM)
*     =======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBUPTM (IDATE*, ITIME*, IDATM)                          *
*                                                                      *
*   Unpacks date and time from one word                                *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDATE*   Date : 6 Decimal integer : YYMMDD                       *
*     ITIME*   Time : 4 Decimal integer : HHMM                         *
*     IDATM    Packed date-time                                        *
*                                                                      *
*   Called by user,   DBFZUP, DBLKEY, DBNTOP, DBPRGD, DBSRTM, DBENFZ,  *
*             DBPLOB, DBDKYH, DBDKYV                                   *
*                                                                      *
************************************************************************
*
+CDE, DTMPAK.
*     ------------------------------------------------------------------
*
      III  = IDATM
      IMIN = MOD(III,MXMIN)
      III  = (III-IMIN)/MXMIN
      IHOU = MOD(III,MXHOU)
      III  = (III-IHOU)/MXHOU
      IDAY = MOD(III,MXDAY)
      III  = (III-IDAY)/MXDAY
      IMON = MOD(III,MXMON)
      IYEA = (III-IMON)/MXMON
*
      IDATE = IDAY + 100*IMON + 10000*IYEA
      ITIME = IMIN + 100*IHOU
*                                                             END DBUPTM
      END
+DECK, DBUPTS.
      SUBROUTINE DBUPTS (IDATE, ITIME, IDATM)
*     =======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBUPTS (IDATE*, ITIME*, IDATM)                          *
*                                                                      *
*   Unpacks date and time from one word                                *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDATE*   Date : 6 Decimal integer : YYMMDD                       *
*     ITIME*   Time : 6 Decimal integer : HHMMSS                       *
*     IDATM    Packed date-time                                        *
*                                                                      *
*   Called by user,   DBPLOB, DBPLOV, DBPLTI, DBAUXI, DBDISD, DBDKYH,  *
*             DBDKYV                                                   *
*                                                                      *
************************************************************************
*
+CDE, DTMPAK.
*     ------------------------------------------------------------------
*
      III  = IDATM
      ISEC = MOD(III,MXSEC)
      III  = (III-ISEC)/MXSEC
      IMIN = MOD(III,MXMIN)
      III  = (III-IMIN)/MXMIN
      IHOU = MOD(III,MXHOU)
      III  = (III-IHOU)/MXHOU
      IDAY = MOD(III,MXDAY)
      III  = (III-IDAY)/MXDAY
      IMON = MOD(III,MXMON)
      IYEA = (III-IMON)/MXMON
*
      IDATE = IDAY + 100*IMON + 10000*(IYEA + 80)
      ITIME = ISEC + 100*IMIN + 10000*IHOU
*                                                             END DBUPTS
      END
+DECK, DBUSE.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBUSE (PATHN, LBK, LBD, ITIME, KEYS, CHOPT)
*     ======================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBUSE (PATHN, *LBK*, LBD*, ITIME, KEYS, CHOPT)          *
*                                                                      *
*   Prepares the database data structure in memory for any required    *
*   Pathname and set of Keys, unless already done.                     *
*   Returns (optionally) the addresses in memory for the corresponding *
*   Key banks and Data banks after checking their validity for the     *
*   given time and keys.                                               *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     LBK(*)   Address(es) of Keys bank(s) KYDB   (INPUT or OUTPUT)    *
*              For option 'S' it is the support address of the linear  *
*              structure                                               *
*              For option 'M' with selection on user keys 8 and 9,     *
*              LBK(k) is the address corresponding to the ith Key-8    *
*              and the jth Key-9 value, where k = KEYS(8) * (j-1) + i  *
*     LBD(*)   Address(es) of Data bank(s) DADB                        *
*              For option 'S' the address of the databank can only be  *
*              obtained from the actual key-address: LK  of the linear *
*              structure as LBD = LQ(LBK-1)                            *
*     ITIME    Event data acquisition time (or 0, if Data not wanted)  *
*     KEYS     Vector of keys. Only the elements declared in CHOPT are *
*              assumed to contain useful information.                  *
*              When option 'M' is declared KEYS(n) (when user Key n    *
*              is selected should contain the number of data objects   *
*              to be retrieved according to the KEYS(n) values and     *
*              the values of the key elements for Key-n to be matched  *
*              should be stored in successive KEYS(i) elements, with   *
*              i starting from NWKEY+1 (NWKEY is the number of key     *
*              elements for this directory)                            *
*     CHOPT    Character string with any of the following characters   *
*          A   trust LBK address(es) if non-zero                       *
*          K   read only the keys (no data is required)                *
*          M   expect multiple Key banks to be returned (only up to    *
*              a maximum of 5 user keys)                               *
*          S   expect multiple Key banks satisfying selection on a     *
*              number of keys (Options S and M are mutually exclusive) *
*          V   declare the Data as being different in size to what is  *
*              already resident in memory                              *
*          3   selects objects with start validity time < KEYS(3)      *
*              (with option S)                                         *
*          4   selects objects with end validity time > KEYS(4)        *
*              (with option S)                                         *
*          5   specific Program version number required                *
*          7   select objects with insertion time < KEYS(7)            *
*          n   consider user key n (where 7 < n < 29 )                 *
*                                                                      *
*   Called by user,   DBJOIN, DBVWPR                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =  1 : Illegal character option                        *
*               =  2 : Illegal path name                               *
*               =  3 : Data base structure in memory clobbered         *
*               =  4 : Illegal key option                              *
+SELF, IF=$P3CHILD.
*               =  5 : Error in DBCHLD in P3 communication             *
*               = 36 : Data bank address zero on return from DBKXIN    *
*               = 37 : Insufficient space in USER store array          *
+SELF.
*                                                                      *
*     If IQUEST(1) =0, IQUEST(2) carries information whether data      *
*     part had been actually read from the disk or not                 *
*     IQUEST(2) =  0 : No disk i/o has been performed                  *
*               =  1 : Data have been refreshed from the disk          *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+SELF, IF= $P3CHILD.
+CDE, DLINKS.
+CDE, P3DBL3.
+CDE, MZBITS.
*
+SELF.
*     (Arbitary dimension 9 to force transmission by address for scalar)
      DIMENSION       KEYS(9), LBD(9), LBK(9)
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, FPATH*80
*
*     ------------------------------------------------------------------
*
* *** Initialize options
*
C ACP_data_retrieval_start
      LREFDB(1) = LBK(1)
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)       GO TO 999
      IF (IOPMDA.NE.0 .AND. IOPSDA.NE.0) THEN
        IQUEST(1) = 1
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUSE : Illegal '//
     +  'Character option - S/M options are mutually exclusive'')',
     +  IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Create (or complete) database skeleton in memory
*                       (banks NODB and KYDB)
*
      IF (ITIME.EQ.0 .OR. IOPADA.EQ.0. OR.
     +   (IOPADA.NE.0. AND. LREFDB(1).EQ.0) )  THEN
*
        CALL DBNODE (PATH, LBNODB)
        IF (IQUEST(1).NE.0)     GO TO 999
*
        CALL DBKEYS (LBNODB, KEYS, LBK, ITIME)
        IF (IQUEST(1).NE.0)     GO TO 999
        LREFDB(1) = LBK(1)
*
*  *    That's it, when only initialisation required
*
        IQUEST(2) = 0
        IF (ITIME.EQ.0)         GO TO 999
*
      ELSE
*
        CALL RZCDIR (PATH, ' ')
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1) = 2
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUSE : Illeg'//
     +    'al path name '//PATH//''')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
        NKEYDK = IQUEST(7)
        NWKYDK = IQUEST(8)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
*
        IF (IOPSDA.NE.0)  THEN
          LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)
          CALL DBKEYS (LBNODB, KEYS, LBK(1), ITIME)
          IF (IQUEST(1).NE.0)   GO TO 999
          LREFDB(1) = LBK(1)
        ENDIF
*
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)
          NF     = IQ(KOFUDB+LBNODB+MNDNCH)
          CALL UHTOC (IQ(KOFUDB+LBNODB+MNDNAM), 4, FPATH, NF)
          FPATH  = FPATH(1:NF)
          N      = INDEX (PATH, ' ')
          IF (N.EQ.0)  N = LEN (PATH) + 1
*
   50     N      = N -1
          IF (PATH(N:N).NE.FPATH(NF:NF))  THEN
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUSE : Data'//
     +      'base structure in memory clobbered'')', IARGDB, 0)
            IQUEST(1) = 3
            IQUEST(11)= N
            GO TO 999
          ELSE IF (N.NE.1)  THEN
            NF     = NF -1
            GO TO 50
          ENDIF
        ENDIF
+SELF.
      ENDIF
*
* *** Get number of Data banks needed
*
      NKYMX  = 1
      IF (IOPMDA.NE.0)  THEN
        IF (NWKYDK.GT.NSYSDK)  THEN
          DO 60 I = NSYSDK+1, NWKYDK
            IF (IOKYDA(I).NE.0) THEN
              IF (KEYS(I).LE.0)  THEN
*
*  **           Illegal key option
*
                IQUEST(1)  = 4
                IQUEST(11) = I
                IQUEST(12) = KEYS(I)
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) THEN
                  IARGDB(1) = IQUEST(12)
                  IARGDB(2) = IQUEST(11)
                  CALL DBPRNT (LPRTDB, '(/,'' DBUSE : Illegal key opt'//
     +                 'ion '',I3,'' for key '',I3,'' with option M'')',
     +                 IARGDB, 2)
                ENDIF
+SELF.
                GO TO 999
              ENDIF
*
              NKYMX  = NKYMX * KEYS(I)
            ENDIF
   60     CONTINUE
        ENDIF
      ENDIF
*
* *** Number of Key banks in S mode
*
      IF (IOPSDA.NE.0)  THEN
        LBNODB = LQ(KOFUDB+LREFDB(1)-KLNODB)
        LBKYDB = LREFDB(1)
        NKYMX  = NZBANK (IDIVDB, LBKYDB)
      ENDIF
*
* *** Create (or update) Data bank(s)
*
      IQUEST(2) = 0
      IQER1 = 0
+SELF, IF=$P3CHILD.
      IF (NKYMX.GT.1) THEN
        IPASP3 = 1
        NDIRP3 = 0
        NBKDP3 = 0
        NBKYP3 = 0
        INDXP3 = 1
      ELSE
        IPASP3 = 0
      ENDIF
      NKBP3  = 0
+SELF.
      I     = 0
  100 I     = I + 1
      IF (IOPSDA.EQ.0)  THEN
        LBKYDB = LBK(I)
      ENDIF
      LBDADB = LQ(KOFUDB+LBKYDB-KLDADB)
+SELF, IF=$P3CHILD.
      NBKSP3 = NBKYP3
+SELF.
      CALL DBCHCK (LBKYDB, ITIME, KEYS, LBDADB)
      IF (IOPSDA.NE.0)  THEN
        IF (I.EQ.1) LBD(1) = LBDADB
      ELSE IF (IQUEST(1).NE.0) THEN
        LBD(I) = 0
      ELSE
        LBD(I) = LBDADB
      ENDIF
+SELF, IF=$P3CHILD.
      IF (IPASP3.EQ.1.AND.IQUEST(1).EQ.0) THEN
        NKBP3  = NKBP3 + 1
        IF (NKBP3.GT.IQ(KOFUDB+LNK2P3-1))
     +    CALL MZPUSH (IXDBP3, LNK2P3, 100, 100, '....')
        LQ(KOFUDB+LNK2P3-NKBP3) = LBKYDB
        IQ(KOFUDB+LNK2P3+NKBP3) = NBKSP3+I*1000000
      ENDIF
+SELF, IF=$DEBUG.
      IF (IQUEST(1).EQ.99) THEN
         IF (IDEBDB.GT.0) THEN
           IARGDB(1) = I
           IARGDB(2) = NKYMX
           CALL DBPRNT (LPRTDB, '(/,'' DBUSE : Fatal error - No more '//
     +          'space available to lift bank for'',/,''  '//PATH(1:80)
     +          //''',2I10)', IARGDB, 2)
        ENDIF
      ENDIF
+SELF.
      IF (IQUEST(1).NE.0) IQER1 = IQUEST(1)
      IF (IOPSDA.EQ.0)  THEN
        IF (I.LT.NKYMX)         GO TO 100
      ELSE
        IF (IQUEST(1).NE.0)     GO TO 999
        LBKYDB = LQ(KOFUDB+LBKYDB)
        IF (LBKYDB.NE.0)        GO TO 100
      ENDIF
+SELF, IF= $P3CHILD.
*
      IQ1    = IQTEMP
      IQ2    = IQUEST(2)
      IF (IPASP3.NE.1)          GO TO 998
*
* *** Request the host to load the data objects from the RZ file
*
      IF (NBKYP3.EQ.0) THEN
        NKB    = 0
        GO TO 998
      ENDIF
*
      RNDBP3 = 'DBRZIN  '
      CALL UCTOH  ('DBUSE   ',IWDBP3,4,8)
      CALL DBCHLD
      IF (IQDBP3.NE.0) THEN
        IQ1    = 5
+SELF, IF=$P3CHILD, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUSE : Error '//
     +  'code'',I6,'' from DBCHLD'')', IQDBP3, 1)
+SELF, IF=$P3CHILD.
        GO TO 998
      ENDIF
*
* *** Relocate the objects
*
      IPASP3 = 2
      LNK6P3 = LQ(KOFUDB+LNK3P3-1)
      LNK7P3 = LQ(KOFUDB+LNK3P3-2)
*
      DO 120 JK = 1, NKBP3
        IP3NEW = IQ(KOFUDB+LNK2P3+JK)
        I      =     IP3NEW/1000000
        IP3NEW = MOD(IP3NEW,1000000)
        IF (JK.GT.1) THEN
          IF (IP3NEW.EQ.IP3OLD) GO TO 120
          DO 110 IP3 = IP3OLD, IP3NEW-1
            LNK4P3 = LQ(KOFUDB+LNK6P3)
            LNK5P3 = LQ(KOFUDB+LNK7P3)
            CALL MZDROP (IXDBP3,LNK6P3,'BV..')
            CALL MZDROP (IXDBP3,LNK7P3,'BV..')
            LNK6P3 = LNK4P3
            LNK7P3 = LNK5P3
  110     CONTINUE
        ELSE
          LNK4P3 = LNK6P3
          LNK5P3 = LNK7P3
        ENDIF
        IP3OLD = IP3NEW
*
        LBKYDB = LQ(KOFUDB+LNK2P3-JK)
        LBDADB = LQ(KOFUDB+LBKYDB-KLDADB)
        IF (LBDADB.EQ.0.OR.JBIT(IQ(KOFUDB+LBDADB),IQDROP).NE.0) THEN
          NDAT = 0
        ELSE
          NDAT = IQ(KOFUDB+LBDADB-1)
        ENDIF
*
        NWKEY  = IQ(KOFUDB+LBKYDB-1)
        CALL UCOPY (IQ(KOFUDB+LBKYDB+1), KEYVDK, NWKEY)
        IF (LAUXDL(9).NE.0) THEN
          CALL MZDROP (IDISDB, LAUXDL(9), 'L...')
          LAUXDL(9) = 0
        ENDIF
        CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9), 2, NWKEY,
     +               KEYVDK, IPREC)
*
        IF (LAUXDL(9).EQ.0) THEN
          IQUEST(1) = 36
+SELF, IF=$P3CHILD, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUSE : Ill'//
     +    'egal Bank address from DBKXIN'')', IARGDB, 0)
+SELF, IF=$P3CHILD.
*
        ELSE IF (NDAT.GT.0) THEN
          ND     = IQ(KOFUDB+LAUXDL(9)-1)
          IF (ND.GT.NDAT) THEN
            CALL MZDROP (IDISDB, LAUXDL(9), 'L')
            IQUEST(1) = 37
            IQUEST(11)= ND
            IQUEST(12)= NDAT
+SELF, IF=$P3CHILD, IF=$DEBUG.
            IF (IDEBDB.GT.0) THEN
              IARGDB(1) = IQUEST(12)
              IARGDB(2) = IQUEST(11)
              CALL DBPRNT (LPRTDB, '(/,'' DBUSE : Insufficient spa'//
     +             'ce '',I10,'' to store data - a minimum of '','//
     +             'I10,'' storage is needed'')', IARGDB, 2)
+SELF, IF=$P3CHILD.
            ENDIF
          ELSE
            CALL UCOPY (Q(KOFUDB+LAUXDL(9)+1), Q(KOFUDB+LBDADB+1),
     +                  ND)
            CALL MZDROP (IDISDB, LAUXDL(9), 'L...')
            LAUXDL(9) = 0
            IQUEST(1) = 0
          ENDIF
        ELSE
          CALL MZCOPY (IDISDB,LAUXDL(9), IDIVDB,LBKYDB, -KLDADB, 'P...')
          IF (IQUEST(1).EQ.0) LBDADB = LQ(KOFUDB+LBKYDB-KLDADB)
          CALL MZDROP (IDISDB, LAUXDL(9), 'L...')
          LAUXDL(9) = 0
        ENDIF
*
        IF (IQUEST(1).NE.0) THEN
          IQ1     = IQUEST(1)
        ELSE
          NDK     = IQ(KOFUDB+LBKYDB-1)
          IQ(KOFUDB+LBKYDB+NDK+MKYPRE) = IPREC
        ENDIF
*
        IF (IOPSDA.NE.0) THEN
          IF (IQUEST(1).NE.0)   GO TO 998
          IF (I.EQ.1) LBD(1) = LBDADB
        ELSE IF (IQUEST(1).NE.0) THEN
          LBD(I) = 0
        ELSE
          LBD(I) = LBDADB
        ENDIF
*
  120 CONTINUE
*
  998 CONTINUE
      IQER1     = IQ1
      IQUEST(2) = IQ2
*
+SELF.
      IF (IQUEST(1).EQ.0) IQUEST(1) = IQER1
+SELF, IF= $P3CHILD.
      IF (LNK3P3.NE.0) CALL MZDROP (IXDBP3, LNK3P3, '....')
      LNK3P3 = 0
      LNK4P3 = 0
      LNK5P3 = 0
      NBKYP3 = 0
      NDIRP3 = 0
      IPASP3 = 0
+SELF.
*                                                              END DBUSE
  999 CONTINUE
C ACP_data_retrieval_end
      END
+DECK, DBVIN.
      SUBROUTINE DBVIN (PATHN, ITIME, USER, NDAT, IDTYP, IPRVS, NWKEY,
     +                  KEY, IPREC, CHOPT)
*     ================================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBVIN (PATHN, ITIME, USER*, *NDAT*, IDTYP*, IPRVS,      *
*                   , NWKEY*, KEY*, IPREC*, CHOPT)                     *
*                                                                      *
*   Fetches from disk to a FORTRAN array data valid for a given time   *
*                                                                      *
*   Restrictions : No selection on user keys can be made               *
*                  USER should contain variables of the same type      *
*                  (Integer, Real or Holllereith)                      *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     ITIME    Time for which data are required to be valid            *
*     NDAT(*)  Maximum dimension of USER array (on input)              *
*              Number of data words fetched from disk (on output)      *
*     USER(*)  User array where data are stored                        *
*     IDTYP(*) Type of the data (2 - integer; 3 - real; 5 - Hollereith)*
*     IPRVS    Version number of program used when data were created   *
*              (if = 0, accept any)                                    *
*     NWKEY(*) Length of the key vector                                *
*     KEY(*)   Key vector elements                                     *
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *
*              IPREC significant digits right to the decimal points; if*
*              IPREC < 0, data are stored with IPREC insignificant     *
*              digits left to the decimal point.)                      *
*     CHOPT    Character string with any of the following characters   *
*          N   If data do not exist for ITIME, take the nearest data   *
*              object in time                                          *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 31 : Illegal path name                               *
*               = 32 : No keys/data in this directory                  *
*               = 36 : Data bank address zero on return from DBKXIN    *
*               = 37 : Insufficient space in USER store array          *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DLINKS.
      DIMENSION       KEY(9), USER(2)
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80, PATHX*16
*
*     ------------------------------------------------------------------
*
* *** Decode the character option
* *** Inhibit 'R' option
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0) GO TO 999
      IOPRDA = 0
      IF (IPRVS.NE.0) IOKYDA(MPVSDB) = 1
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Set the current directory
*
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0)  THEN
        IQUEST(1) = 31
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBVIN : Illegal '//
     +  'Path Name '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKEYT
      IF (IQUEST(1).NE.0) GO TO 999
*
* *** Check the number of keys
*
      IF (NKEYDK.EQ.0)  THEN
        IQUEST(1) = 32
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBVIN : No key '//
     +  'or data for Path Name '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
      CALL RZCDIR (PATH, 'R')
      NCHAR  = INDEX (PATH, ' ') - 1
      IF (NCHAR.LT.0) NCHAR = MAXLDB
      NCHRT  = INDEX (PATH(3:NCHAR), '/') - 1
      IF (NCHRT.LE.0) NCHRT = NCHAR - 2
      PATHX  = PATH(3:NCHRT+2)
      LTOP   = LTOPDB
   10 IF (LTOP.NE.0) THEN
        NCHRT  = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHRT)
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 10
        ENDIF
        KY7MDB = IQ(KOFUDB+LTOP+MUPKY7)
      ELSE
        KY7MDB = 0
      ENDIF
*
* *** Set up the key vector to be searched
*
      DO 20 I = 1, NWKYDK
        IF (IOKYDA(I).NE.0) THEN
          KEYVDK(I) = KEY(I)
        ELSE
          KEYVDK(I) = 0
        ENDIF
   20 CONTINUE
      KEYVDK(MPVSDB) = IPRVS
      JBIAS  = 2
*
* *** Read in the data
*
      CALL DBKXIN (ITIME, IDISDB, LAUXDL(7), LAUXDL(7), JBIAS, NWKEY,
     +             KEYVDK, IPREC)
*
      IF (IQUEST(1).NE.0)  THEN
*
*  **   DBKXIN encounters error in retrieving data
*
        NDAT      = 0
*
      ELSE IF (LAUXDL(7).EQ.0)  THEN
*
*  **   DBKXIN has not created the data bank
*
        IQUEST(1) = 36
        NDAT      = 0
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBVIN : Illegal '//
     +  'Bank address from DBKXIN'')', IARGDB, 0)
+SELF.
*
      ELSE
*
*  **   See if the USER array size is sufficient to store the data
*
        L      = LAUXDL(7)
        ND     = IQ(KOFUDB+L-1)
        CALL UCOPY (KEYVDK, KEY, NWKEY)
        IF (ND.GT.NDAT)  THEN
*
*  *      Insufficient space
*
          CALL MZDROP (IDISDB, LAUXDL(7), ' ')
          IQUEST(1) = 37
          IQUEST(11)= ND
          IQUEST(12)= NDAT
          NDAT      = 0
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) THEN
            IARGDB(1) = IQUEST(12)
            IARGDB(2) = IQUEST(11)
            CALL DBPRNT (LPRTDB, '(/,'' DBVIN : Insufficient space'//
     +           ' '',I10,'' to store data - a minimum of '',I10,'' '//
     +           'storage is needed'')', IARGDB, 2)
          ENDIF
+SELF.
*
        ELSE
*
*  *      Every thing is OK
*
          IQUEST(1) = 0
          IDTYP     = IDBTYP(L)
          CALL UCOPY (Q(KOFUDB+L+1), USER(1), ND)
          NDAT      = ND
          CALL MZDROP (IDISDB, LAUXDL(7), ' ')
*
        ENDIF
      ENDIF
*                                                              END DBVIN
  999 END
+DECK, DBVLDT.
      SUBROUTINE DBVLDT (ITMIN, ITMAX)
*     ================================
*
************************************************************************
*                                                                      *
*        SUBR. DBVLDT (ITMIN*, ITMAX*)                                 *
*                                                                      *
*   Finds the overlapping validity range of all data base objects      *
*   used since the last call to DBTBCR.                                *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     ITMIN(*) Lower bound of the validity range                       *
*     ITMAX(*) Upper bound of the validity range                       *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
      PARAMETER       (NLEVM=20)
      DIMENSION       ISDI(NLEVM), NSDI(NLEVM)
*
*     ------------------------------------------------------------------
*
      ITMAX  = IBIGDB
      ITMIN  = 0
*
* *** Loop over all top directories
*
      LBFXDB = LTOPDB
   10 IF (LBFXDB.GT.0) THEN
        NLEV   = 0
        LBNODB = LQ(KOFUDB+LBFXDB-1)
*
*  **   Scan down the nodes to find all the subdirectories
*
   15   IF (LBNODB.GT.0) THEN
          NLEV   = NLEV + 1
          ISDI(NLEV) = 0
          NSDI(NLEV) = IQ(KOFUDB+LBNODB-2)
*
   20     ISDI(NLEV) = ISDI(NLEV) + 1
          IF (ISDI(NLEV).LE.NSDI(NLEV)) THEN
*
*  **       If a new subdirectory go down one level
*
            LBD    = LQ(KOFUDB+LBNODB-ISDI(NLEV))
            IF (LBD.GT.0) THEN
              LBNODB = LBD
              GO TO 15
            ELSE
              GO TO 20
            ENDIF
*
          ELSE
*
*  **       Loop over all the key banks
*
            NDK    = IQ(KOFUDB+LBNODB+2)
            LBKYDB = LQ(KOFUDB+LBNODB)
   25       IF (LBKYDB.GT.0) THEN
              IOFF   = KOFUDB + LBKYDB
              IF (IQ(IOFF+NDK-3).GT.0) THEN
                IF (IQ(IOFF+MBVRDB).GT.ITMIN) ITMIN = IQ(IOFF+MBVRDB)
                IF (IQ(IOFF+MEVRDB).LT.ITMAX) ITMAX = IQ(IOFF+MEVRDB)
              ENDIF
              LBKYDB = LQ(KOFUDB+LBKYDB)
              GO TO 25
            ENDIF
*
*  **       Now go up one level
*
   30       NLEV   = NLEV - 1
            IF (NLEV.GT.0) THEN
              LBNODB = LQ(KOFUDB+LBNODB+1)
              GO TO 20
            ENDIF
          ENDIF
        ENDIF
*
        LBFXDB = LQ(KOFUDB+LBFXDB)
        GO TO 10
      ENDIF
*
      IQUEST(1) = 0
*                                                             END DBVLDT
      END
+DECK, DBVOUT.
      SUBROUTINE DBVOUT (PATHN, IVSTR, IVEND, NDAT, USER, IPRVS, NKEXT,
     +                   KEYXT, IDTYP, IPREC, CHOPT)
*     =================================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBVOUT (PATHN, IVSTR, IVEND, NDAT, USER, IPRVS, NKEXT,  *
*                      KEYXT, IDTYP, IPREC, CHOPT)                     *
*                                                                      *
*   Stores data from a FORTRAN array to disk creating simultaneousely  *
*   the directories if needed                                          *
*   Restrictions : Only directories upto 9 keys can be created and     *
*                  keys should be of type INTEGER                      *
*                  USER should contain variables of the same type      *
*                  (Integer, Real or Holllereith)                      *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     IVSTR    Start of validity period                                *
*     IVEND    End of validity period                                  *
*     NDAT     Number of data word in the user array                   *
*     USER     Array of user data words                                *
*     IPRVS    Version number of program used for creating the data    *
*     NKEXT    Number of extra keys (Beyond key 5)                     *
*     KEYXT    Vector of extra keys                                    *
*     IDTYP    Type of data (2 - Integer; 3 - Real; 5 - Hollerith)     *
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *
*              IPREC significant digits right to the decimal points; if*
*              IPREC < 0, data are stored with IPREC insignificant     *
*              digits left to the decimal point.)                      *
*     CHOPT    Character string with any of the following characters   *
*          F   Updates with a fully matched data object (in user keys) *
*          N   Create new (sub)directory(ies)                          *
*          P   Create partitioned subdirectories for the pathname      *
*          S   Create stand alone (master) data                        *
*          U   Store data uncompressed                                 *
*          Z   Store only nonzero elements. An element is considered to*
*              be zero if its absolute value is less than IPREC (real) *
*                                                                      *
*   Called by user,   DBINIT                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 62 : Too many external keys with option N            *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DZPACK.
      DIMENSION       KEYXT(9) , USER(2)
      CHARACTER       CHOPT*(*), PATHN*(*), PATH*80
*
*     ------------------------------------------------------------------
*
* *** Decode the character option
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)   GO TO 999
      PACKDZ = .FALSE.
*
      IF (IOPUDA.NE.0.AND.IOPZDA.NE.0)  THEN
        IOPZDA = 0
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBVOUT : Warning'//
     +  ' - Z option is incompatible with U option - U option will be'//
     +  ' executed'')', IARGDB, 0)
+SELF.
*
      ELSE IF (IOPZDA.NE.0)  THEN
        PACKDZ = .TRUE.
        CALL UCOPY (IPREC, PRECDZ, 1)
      ENDIF
*
      IOPRDA = 0
*
      IF (IOPNDA.NE.0.AND.NKEXT+5.GT.NINEDK)  THEN
        IQUEST(1) = 62
        IQUEST(11)= NKEXT
        IQUEST(12)= NINEDK - 5
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBVOUT : Too man'//
     +  'y external keys '',I6,'' with option N - a maximum of '',I6'//
     +  ','' permitted'')', IQUEST(11), 2)
+SELF.
        GO TO 999
      ENDIF
*
* *** Prepare the Key vector array
*
      CALL VZERO (KEYVDK, MXDMDK)
      IF (NKEXT.GT.2) CALL UCOPY (KEYXT(3), KEYVDK(8), NKEXT-2)
      KEYVDK(MBVRDB) = IVSTR
      KEYVDK(MEVRDB) = IVEND
      KEYVDK(MPVSDB) = IPRVS
      IF (NKEXT.GE.0) THEN
        NTKEY  = NKEXT + 5
      ELSE
        NTKEY  = NINEDK
      ENDIF
*
* *** Suppress blanks from the path name
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
*
* *** Create new subdirectories if needed
*
      IF (IOPNDA.NE.0)  THEN
        IF (IOPPDA.EQ.0)  THEN
          CALL DBMDIR (PATH, NTKEY, CHFTDK, CHTGDK)
        ELSE
          KEY7DK = 0
          CALL DBMDIP (PATH, NTKEY, CHFTDK, CHTGDK, MXKPDK)
        ENDIF
        IF (IQUEST(1).NE.0) GO TO 999
      ENDIF
*
* *** Create a temporary bank with the data
*
      JBIAS  = 2
      CALL DBBOOK (IDISDB, LAUXDL(7), LAUXDL(7), JBIAS, 'AUX7', 0, 0
     +           , NDAT, IDTYP, 0)
      IF (IQUEST(1).NE.0)   GO TO 999
      CALL UCOPY (USER(1), Q(KOFUDB+LAUXDL(7)+1), NDAT)
*
* *** Write out the data
*
      CALL DBKOUT (PATH, IDISDB, LAUXDL(7), NTKEY, KEYVDK, IPREC)
*
* *** Drop the temporary bank
*
      IER       = IQUEST(1)
      CALL MZDROP (IDISDB, LAUXDL(7), ' ')
      IQUEST(1) = IER
*                                                             END DBVOUT
  999 END
+PATCH, DATABASE.
+DECK, DBBOOK.
      SUBROUTINE DBBOOK (IDIV, LAD, LSUP, JBIAS, CHID, NL,NS,ND,NIO, NZ)
*     ==================================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBBOOK (IDIV, LAD*, LSUP, JBIAS, CHID, NL,NS,ND, NIO,NZ)*
*                                                                      *
*   Creates a bank taking care of total ammount of space available in  *
*   the division. When not enough space is available after garbage     *
*   collection, the banks freed by DBFREE are dropped.                 *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDIV     Division number where the object is to be created       *
*     LAD      L-address of the bank created                           *
*     LSUP     L-address of the supporting bank                        *
*     JBIAS    Link bias as described in ZEBRA manual                  *
*     CHID     Character string to specify the bank name               *
*     NL,NS,   Total number of links, number of structural links,      *
*     ND,NIO,  number of data words, I/O characteristics flag          *
*     NZ       for initialising the bank (MZBOOK standard)             *
*                                                                      *
*   Called by various routines in the DBL3 package                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 99 : No space in memory for creating the bank        *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
      CHARACTER       CHID*(*), CHID0*4
      DIMENSION       NL(9), NS(9), ND(9), NIO(9), LSUP(9), LAD(9)
*
*     ------------------------------------------------------------------
*
* *** See if enough space is available in memory
*
      NEEDW  = NL(1) + ND(1) + 20
      CALL MZNEED (IDIV, NEEDW, ' ')
      IF (IQUEST(11).LT.0)  THEN
        CALL MZNEED (IDIV, NEEDW, 'G')
        IF (IQUEST(11).LT.0)  THEN
          LGO    = 0
   10     LBFYDB = LZFIDH (IDIV, IHKYDB, LGO)
          IF (LBFYDB.NE.0)  THEN
            ND0    = IQ(KOFUDB+LBFYDB-1)
            IF (IQ(KOFUDB+LBFYDB+ND0+MKYFRI).GT.0)  THEN
              LDAT   = LQ(KOFUDB+LBFYDB-KLDADB)
              IF (LDAT.GT.0) CALL MZDROP (IDIV, LDAT, 'L')
            ENDIF
            LGO    = LBFYDB
            GO TO 10
          ENDIF
          CALL MZNEED (IDIV, NEEDW, 'G')
          IF (IQUEST(11).LT.0)  THEN
            IQUEST(1) = 99
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) THEN
              CHID0  = CHID
              CALL DBPRNT (LPRTDB, '(/,'' DBBOOK : No space left for '//
     +             'creating bank '//CHID0//' space needed '',I12)',
     +             IQUEST(11), 1)
            ENDIF
+SELF.
            GO TO 999
          ENDIF
        ENDIF
      ENDIF
*
* *** Create the bank as desired
*
      CALL MZBOOK (IDIV, LAD(1), LSUP(1), JBIAS, CHID, NL, NS, ND, NIO,
     +             NZ)
      IQUEST(1) = 0
      IQ(KOFUDB+LAD(1)-5) = 0
*                                                             END DBBOOK
  999 END
+DECK, DBCDIC, IF=-$P3CHILD.
      SUBROUTINE DBCDIC (PATH)
*     ========================
*
************************************************************************
*                                                                      *
*        SUBR. DBCDIC (PATH)                                           *
*                                                                      *
*   Create or updates the dictionary table for the Data base file      *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATH     Path name of the subdirectory                           *
*                                                                      *
*   Called by DBMDIP, DBMDIR                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =151 : Cannot find the top directory                   *
*               =152 : Illegal path name                               *
*               =153 : Illegal top directory name                      *
*               =154 : Dictionary directory cannot be loaded           *
*               =155 : Error in RZ for reading the dictionary object   *
*               =156 : Pathname already exists in dictionary           *
*               =157 : Error in RZ in writing the dictionary object    *
*               =158 : Error in RZ in purging the dictionary directory *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
      DIMENSION       KEYN(MXDMDK)
      CHARACTER       PATHN*80, PATHF*80, PATHY*80, TOPN*16, TOPN1*16
      CHARACTER       PATHD*80, PATH*(*)
*
*     ------------------------------------------------------------------
*
      JBIAS  = -KLDICT
      CALL RZCDIR (PATHN, 'R')
*
* *** Split the top directory and the rest
*
      IF (PATHN(1:2).NE.'//') THEN
        IQUEST(1) = 151
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCDIC : No top '//
     +  'directory in path name '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      DO 5 I = 3, MAXLDB
        IF (PATHN(I:I).EQ.' ') THEN
          NCH    = I - 1
          GO TO 10
        ENDIF
    5 CONTINUE
      NCH    = MAXLDB
   10 MAXL   = LEN (PATH)
      DO 15 I = 1, MAXL
        IF (PATH(I:I).EQ.' ') THEN
          NCHD   = I - 1
          GO TO 20
        ENDIF
   15 CONTINUE
      NCHD   = MAXL
   20 PATHN  = PATHN(1:NCH)//'/'//PATH(1:NCHD)
      NCH    = NCH + NCHD + 1
      DO 30 I = 3, NCH
        IF (PATHN(I:I).EQ.'/') THEN
          N1     = I
          NCHR   = NCH - I + 1
          GO TO 35
        ENDIF
   30 CONTINUE
      N1     = NCH
      NCHR   = 0
   35 IF (NCHR.LE.0) THEN
        IQUEST(1) = 152
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCDIC : Illegal'//
     +  ' path name '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      PATHY  = PATHN(N1:NCH)
      TOPN   = PATHN(3:N1-1)
      PATHD  = PATHN(1:N1)//'DICTIONARY'
*
* *** Find the corresponding top directory in the list
*
      LBNODB = LTOPDB
   40 IF (LBNODB.GT.0) THEN
        NCHT   = IQ(KOFUDB+LBNODB+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LBNODB+MUPNAM), 4, TOPN1, NCHT)
        TOPN1  = TOPN1(1:NCHT)
        IF (TOPN.NE.TOPN1) THEN
          LBNODB = LQ(KOFUDB+LBNODB)
          GO TO 40
        ENDIF
        IOPS   = MOD (IQ(KOFUDB+LBNODB+MUPSRV)/10, 10)
        IOUT   = IQ(KOFUDB+LBNODB+MUPFLG)
      ELSE
        IQUEST(1) = 153
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCDIC : Illegal'//
     +  ' top directory name in '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      IF (IOUT.EQ.0) IOPS = 0
*
* *** Check if the path name already exists in the dictionary
*
      CALL RZCDIR (PATHD, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 154
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCDIC : Cannot '//
     +  'set current directory to '//PATHD//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      ISTP   = NWKYDK + 1
      IF (NKEYDK.GT.0) THEN
        IPNT   = KOFSDB + LCDRDB + IKDRDB
        IMIN   = IUHUNT (-1, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)
        IF (IMIN.GT.0) THEN
          IMIN   = (IMIN - MSERDB) / ISTP + 1
          CALL DBKEYT
          CALL DBKEYR (IMIN, NWKYDK, KEYN)
          LFIXDB = LQ(KOFUDB+LBNODB+JBIAS)
          IF (LFIXDB.NE.0) CALL MZDROP (IDIVDB, LFIXDB, ' ')
          ICYCL  = 9999
          CALL DBRZIN (IDIVDB, LBNODB, JBIAS, IMIN, ICYCL, PATHD)
          IF (IQUEST(1).NE.0) GO TO 999
          LFIXDB = LQ(KOFUDB+LBNODB+JBIAS)
          NDWD   = IQ(KOFUDB+LFIXDB-1)
          GO TO 45
        ENDIF
      ENDIF
      KEYN(MSERDB) = -1
      KEYN(MUPNDB) = 0
      CALL DATIME (IDATE, ITIME)
      CALL DBPKTS (IDATE, ITIME*100,  KEYN(MBVRDB))
      KEYN(MEVRDB) = IBIGDB
      KEYN(MPVSDB) = 0
      KEYN(MFLGDB) = 1
      CALL DBPKTM (IDATE,  ITIME,  KEYN(MITMDB))
      LFIXDB = LQ(KOFUDB+LBNODB+JBIAS)
      IF (LFIXDB.NE.0) CALL MZDROP (IDIVDB, LFIXDB, ' ')
      NDWD   = NPUSDB*NWITDB + 1
      CALL DBBOOK (IDIVDB, LFIXDB, LBNODB, JBIAS, 'DIDB', 0, 0, NDWD,
     +             IODIDB, 0)
      IF (IQUEST(1).NE.0)     GO TO 999
*
   45 NITEM  = IQ(KOFUDB+LFIXDB+MDCNTM)
      NKEEP  = (NDWD - 1) / NWITDB
      NFREE  = 0
      IF (NITEM.GT.0) THEN
        DO 50 I = 1, NITEM
          IPNT   = KOFUDB + LFIXDB + (I - 1) * NWITDB + 1
          NCHF   = IQ(IPNT+MDCNCH)
          IF (IQ(IPNT+MDCITM).LE.0) THEN
            IF (NFREE.EQ.0) NFREE = I
          ELSE
            IF (NCHR.EQ.NCHF) THEN
              CALL UHTOC (IQ(IPNT+MDCNAM), 4, PATHF, NCHF)
              PATHF  = PATHF(1:NCHF)
              IF (PATHY.EQ.PATHF) THEN
                IQUEST(1) = 156
                IQUEST(11)= I
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCDIC :'//
     +          ' Path name already in dictionary '//PATHN//''')', IQ,0)
+SELF.
                GO TO 999
              ENDIF
            ENDIF
          ENDIF
   50   CONTINUE
      ENDIF
*
* *** Enter the new path name in the dictionary
*
      IF (NFREE.EQ.0) THEN
        NITEM  = NITEM + 1
        NFREE  = NITEM
        IF (NITEM.GT.NKEEP) THEN
          CALL ZSHUNT (IDIVDB, LFIXDB, LBDADB, 2, 0)
          LBDADB = LFIXDB
          LFIXDB = 0
          ND     = NDWD + NPUSDB * NWITDB
          CALL DBBOOK (IDIVDB, LFIXDB, LBNODB, JBIAS, 'DIDB', 0, 0, ND,
     +                 IODIDB, -1)
          IF (IQUEST(1).NE.0) THEN
            IERR   = IQUEST(1)
            CALL MZDROP (IDIVDB, LBDADB, ' ')
            IQUEST(1) = IERR
            GO TO 999
          ENDIF
          CALL UCOPY (IQ(KOFUDB+LBDADB+1), IQ(KOFUDB+LFIXDB+1), NDWD)
          CALL MZDROP (IDIVDB, LBDADB, ' ')
        ENDIF
        IQ(KOFUDB+LFIXDB+MDCNTM) = NITEM
      ENDIF
      IPNT   = KOFUDB + LFIXDB + (NFREE - 1) * NWITDB + 1
      IQ(IPNT+MDCITM) = NFREE
      IQ(IPNT+MDCNCH) = NCHR
      IQ(IPNT+MDCLUP) = 0
      CALL UCTOH ('        ', IQ(IPNT+MDCALI), 4, 8)
      CALL UCTOH (PATHY, IQ(IPNT+MDCNAM), 4, MAXLDB)
*
* *** Now update the disk file
*
      IF (IOPS.NE.0) CALL RZLOCK ('DBCDIC')
      CALL RZOUT (IDIVDB, LFIXDB, KEYN, ICYCLE, 'S')
      IERR   = IQUEST(1)
      IF (IERR.NE.0) THEN
        IF (IOPS.NE.0) CALL RZFREE ('DBCDIC')
        IQUEST(1) = 157
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCDIC : RZOUT '//
     +  'error for path name '//PATHD//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      CALL RZPURG (0)
      IERR   = IQUEST(1)
      IF (IOPS.NE.0) CALL RZFREE ('DBCDIC')
      IF (IERR.NE.0) THEN
        IQUEST(1) = 158
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCDIC : RZPURG '//
     +  'error for path name '//PATHD//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
  998 IQUEST(1) = 0
*                                                             END DBCDIC
  999 END
+DECK, DBCFRI.
      SUBROUTINE DBCFRI (IAR, CH, NWD, NCH)
*     =====================================
*
************************************************************************
*                                                                      *
*        SUBR. DBCFRI (IAR, CH*, NWD, NCH)                             *
*                                                                      *
*   Converts integer array IAR (of length NWD) to an output character  *
*   string CH (of type character and NCH long) via the look-up         *
*   table stored in CSTRDA                                             *
*                                                                      *
*   Called by DBLIND                                                   *
*                                                                      *
************************************************************************
*
+CDE, DAOPTI.
      CHARACTER       CH*(*), CH1*1
      DIMENSION       IAR(9), IB(4)
*     ------------------------------------------------------------------
*
      DO 10 J = 1, NWD
        K  = 4*J - 4
        CALL UPKBYT (IAR(J), 1, IB, 4, MPAKDA)
        DO 5 I = 1, 4
          IF (K+I.GT.NCH) GO TO 999
          CH1 = CSTRDA(63:63)
          IF (IB(I).GE.32.AND.IB(I).LE.126) CH1 = CSTRDA(IB(I):IB(I))
          CH(K+I:K+I) = CH1
    5   CONTINUE
   10 CONTINUE
*                                                             END DBCFRI
  999 END
+DECK, DBCHCK.
+SEQ, T=DUMMY, IF= $P3CHILD.
      SUBROUTINE DBCHCK (LBK, ITIME, KEYS, LBD)
*     =========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBCHCK (LBK, ITIME, KEYS, *LBD*)                        *
*                                                                      *
*   Loads data from disk according to validity time and Key values     *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LBK      Address of the bank containing the keys                 *
*     ITIME    Time for which the valid data are required              *
*     KEYS     Vector of keys                                          *
*     LBD      Address of the bank containing the data                 *
*                                                                      *
*   Called by DBABRD, DBUSE                                            *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 31 : Path name in Node bank is wrong                 *
*               = 32 : No keys/data in this directory                  *
*               = 36 : Data bank address zero on return from DBKXIN    *
*               = 37 : Insufficient space in USER store array          *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DTKXIN.
+CDE, P3DBL3, IF= $P3CHILD.
      DIMENSION       LBK(9), LBD(9), KEYS(9)
      CHARACTER       PATHN*80, PATH*80, PATHX*16
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Lock the bank
*
      LREFDB(2) = LBK(1)
      IQ2    = IQUEST(2)
      NDK    = IQ(KOFUDB+LREFDB(2)-1)
      IQ(KOFUDB+LREFDB(2)+NDK+MKYFRI) = 0
      IQ(KOFUDB+LREFDB(2)+NDK+MKYCRU) = IQ(KOFUDB+LREFDB(2)+NDK+MKYCRU)
     +                                + 1
      IQ(KOFUDB+LREFDB(2)+NDK+MKYCEV) = IQ(KOFUDB+LREFDB(2)+NDK+MKYCEV)
     +                                + 1
*
* *** Get the pathname
*
      LBUP   = LQ(KOFUDB+LREFDB(2)-KLUPDB)
      IF (LBUP.GT.0) THEN
        KY7MDB = IQ(KOFUDB+LBUP+MUPKY7)
      ELSE
        KY7MDB = 0
      ENDIF
      LBNODB = LQ(KOFUDB+LREFDB(2)-KLNODB)
      NCHAR  = IQ(KOFUDB+LBNODB+MNDNCH)
      CALL UHTOC (IQ(KOFUDB+LBNODB+MNDNAM), 4, PATH, NCHAR)
      PATHN  = PATH(1:NCHAR)
*
* *** Set the current directory
*
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0)  THEN
        IQUEST(1) = 31
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCHCK : '//
     +  'Path name '//PATHN//' from node bank illegal'')', IQ, 0)
+SELF.
        GO TO 998
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKEYT
*
* *** Check the number of keys
*
      IF (NKEYDK.EQ.0)  THEN
        IQUEST(1) = 32
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCHCK : No key '//
     +  'or data for Path Name '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 998
      ENDIF
*
      IF (IOPKDA.NE.0 .AND. IOPSDA.NE.0) THEN
        GO TO 998
      ENDIF
*
      IF (LQ(KOFUDB+LREFDB(2)-KLDADB).EQ.0) THEN
*
*  **   The bank does not exist yet - retrieve data from the Data Base
*  **   Check which keys are to be used
*
        IF (IOPSDA.EQ.0)  THEN
          DO 10 I = 1, NWKYDK
            IF (IOKYDA(I).NE.0)  THEN
              IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB.OR.I.EQ.MITMDB) THEN
                KEYVDK(I) = KEYS(I)
              ELSE
                KEYVDK(I) = IQ(KOFUDB+LREFDB(2)+I)
              ENDIF
            ELSE
              KEYVDK(I) = 0
            ENDIF
   10     CONTINUE
        ELSE
          CALL UCOPY (IQ(KOFUDB+LREFDB(2)+1), KEYVDK, NWKYDK)
        ENDIF
*
*  **   Retrieve data
*
        CALL DBKXIN (ITIME, IDIVDB, LBD(1), LBK(1), -KLDADB, NWKEY,
     +               KEYVDK, IPREC)
        IF (IQUEST(1).NE.0)                                    GO TO 998
        LREFDB(2) = LBK(1)
        LREFDB(3) = LBD(1)
        IF (IOPSDA.EQ.0) THEN
          IF (IQ(KOFUDB+LREFDB(2)+MSERDB).NE.KEYVDK(MSERDB)) IQ2 = 1
        ELSE
          IQ2 = 1
        ENDIF
*
*  *    Overwrite keys in key-bank
*
        CALL UCOPY (KEYVDK(1), IQ(KOFUDB+LREFDB(2)+1), NWKYDK)
        IQ(KOFUDB+LREFDB(2)+NDK+MKYPRE) = IPREC
        IQ(KOFUDB+LREFDB(2)+NDK+MKYRID) =IQ(KOFUDB+LREFDB(2)+NDK+MKYRID)
     +                                  + 1
        IF (IOPSDA.EQ.0) THEN
          IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).EQ.0) THEN
            IQ(KOFUDB+LREFDB(2)+NWKYDK+1) =
     +        MIN (IQ(KOFUDB+LREFDB(2)+MEVRDB), KY4MDB)
          ELSE
            IQ(KOFUDB+LREFDB(2)+NWKYDK+1) =
     +        IQ(KOFUDB+LREFDB(2)+MBVRDB) + 1
          ENDIF
        ENDIF
*
      ELSE
*
*  **   The data bank exists already
*
        LBD(1) = LQ(KOFUDB+LREFDB(2)-KLDADB)
        LREFDB(3) = LBD(1)
*
*  **   Check if data are valid
*
        IF (IOPADA.NE.0) THEN
          IF (IQ(KOFUDB+LREFDB(2)+MBVRDB).LE.ITIME .AND.
     +        IQ(KOFUDB+LREFDB(2)+NWKYDK+1).GE.ITIME)          GO TO 998
          KEY6   = IQ(KOFUDB+LREFDB(2)+MFLGDB)
        ELSE IF (IQ(KOFUDB+LREFDB(2)+MBVRDB).LE.ITIME .AND.
     +           IQ(KOFUDB+LREFDB(2)+MEVRDB).GE.ITIME)  THEN
          ISTP   = NWKYDK + 1
          IPNT   = KOFSDB + LCDRDB + IKDRDB
          MNKYDT = -998
          KEY1   = IQ(KOFUDB+LREFDB(2)+MSERDB)
          KEY6DT = 0
          IMINDT = 1
          IOPTP  = IQ(IPNT+MFLGDB)
          IOPTP  = JBIT (IOPTP, JPRTDB)
*
          IF (IOPTP.EQ.0)  THEN
*
*  *        For non-partitioned data
*
            IMIN   = IUHUNT (KEY1, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)
            IF (IMIN.GT.0) THEN
              IMINDT = (IMIN - MSERDB) / ISTP + 1
            ELSE
              IMINDT = 1
            ENDIF
            CALL DBKEYR (IMINDT, NWKYDK, KEYVDK)
            DO 15 I = 1, NWKYDK
              IF (KEYVDK(I).NE.IQ(KOFUDB+LREFDB(2)+I))         GO TO 55
   15       CONTINUE
   20       IF (IMINDT.EQ.NKEYDK)                              GO TO 998
            ICURDT = 1
            CALL DBCHKY (ITIME, KEYS)
            IF (KEY1.EQ.MNKYDT.AND.JBIT(KEY6DT,JIGNDB).EQ.0)   GO TO 998
*
          ELSE
*
*  *        For partitioned data
*
            NKEYS  = NKEYDK
            KST    = NWKYDK + 1
            ICUR   = NKEYS
            DO 25 JK = 1, NKEYS
              KPNT   = IUHUNT (JK, IQ(IPNT+MPSRDB), NKEYS*KST, KST)
              IF (KPNT.GT.0) THEN
                KPNT   = KPNT + IPNT - MPSRDB
              ELSE
                KPNT   = IPNT + (JK - 1) * KST
              ENDIF
              IF (IQ(KPNT+MOBJDB).GT.KEY1) THEN
                ICUR   = IQ(KPNT+MPSRDB) - 1
                GO TO 30
              ENDIF
   25       CONTINUE
*
   30       CALL DBPATH (PATHX, ICUR)
            PATH   = PATHN(1:NCHAR)//'/'//PATHX
            CALL RZCDIR (PATH, ' ')
            IF (IQUEST(1).NE.0)  THEN
              IQUEST(1) = 31
+SELF, IF=$DEBUG.
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCHCK : '//
     +        'Path name '//PATH//' from node bank illegal'')', IQ, 0)
+SELF.
              GO TO 998
            ENDIF
            NKEYDK = IQUEST(7)
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
            IPNT   = KOFSDB + LCDRDB + IKDRDB
            ISTP   = NWKYDK + 1
*
            IF (NKEYDK.GT.0) THEN
              IMIN   = IUHUNT (KEY1, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)
              IF (IMIN.GT.0)  THEN
                IMINDT = (IMIN - MSERDB) / ISTP + 1
              ELSE
                IMINDT = 1
              ENDIF
            ENDIF
            CALL DBKEYR (IMINDT, NWKYDK, KEYVDK)
            DO 35 I = 1, NWKYDK
              IF (KEYVDK(I).NE.IQ(KOFUDB+LREFDB(2)+I))         GO TO 55
   35       CONTINUE
*
   40       IF (ICUR.EQ.NKEYS.AND.IMINDT.EQ.NKEYDK)            GO TO 998
            IMIN   = IMINDT
            MNKYDT = KEY1
            IUSEDT = ICUR
*
            DO 45 JK = ICUR, NKEYS
              ICURDT = NKEYS + ICUR - JK
*
              CALL RZCDIR (PATHN, ' ')
              IF (IQUEST(1).NE.0)  THEN
                IQUEST(1) = 31
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCHCK :'//
     +          ' Path name '//PATHN//' from node bank illegal'')',IQ,0)
+SELF.
                GO TO 998
              ENDIF
              NKEYDK = IQUEST(7)
              LCDRDB = IQUEST(11)
              IKDRDB = IQUEST(13)
              KPNT   = IUHUNT (ICURDT, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                         NKEYS*KST, KST)
              IF (KPNT.NE.0) THEN
                IPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB
              ELSE
                IPNT   = KOFSDB + LCDRDB + IKDRDB + (ICURDT - 1) * KST
              ENDIF
              IF (IOKYDA(MITMDB).NE.0.AND.
     +            IQ(IPNT+MITMDB).GT.KEYS(MITMDB))             GO TO 45
              IF (KY7MDB.GT.0.AND.IQ(IPNT+MITMDB).GT.KY7MDB)   GO TO 45
              IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).EQ.0) THEN
                IF (ITIME.LT.IQ(IPNT+MBVRDB).OR.
     +              ITIME.GT.IQ(IPNT+MEVRDB))                  GO TO 45
              ELSE IF (IOKYDA(MBVRDB).NE.0.AND.IOKYDA(MEVRDB).EQ.0) THEN
                IF (IQ(IPNT+MBVRDB).GT.KEYS(MBVRDB))           GO TO 45
              ELSE IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).NE.0) THEN
                IF (IQ(IPNT+MEVRDB).LT.KEYS(MEVRDB))           GO TO 45
              ELSE
                IF (IQ(IPNT+MBVRDB).GT.KEYS(MBVRDB).OR.
     +              IQ(IPNT+MEVRDB).LT.KEYS(MEVRDB))           GO TO 45
              ENDIF
*
              CALL DBPATH (PATHX, ICURDT)
              PATH   = PATHN(1:NCHAR)//'/'//PATHX
              CALL RZCDIR (PATH, ' ')
              IF (IQUEST(1).NE.0)  THEN
                IQUEST(1) = 31
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCHCK :'//
     +          ' Path name '//PATH//' from node bank illegal'')', IQ,0)
+SELF.
                GO TO 998
              ENDIF
              NKEYDK = IQUEST(7)
              LCDRDB = IQUEST(11)
              IKDRDB = IQUEST(13)
              IF (ICURDT.EQ.ICUR) THEN
                IMINDT = IMIN
              ELSE
                IMINDT = 1
              ENDIF
*
              IF (NKEYDK.GE.IMINDT) THEN
                CALL DBCHKY (ITIME, KEYS)
                IF (IUSEDT.NE.ICUR.OR.MNKYDT.NE.KEY1)          GO TO 50
              ENDIF
   45       CONTINUE
*
   50       CALL RZCDIR (PATHN, ' ')
            IF (IQUEST(1).NE.0)  THEN
              IQUEST(1) = 31
+SELF, IF=$DEBUG.
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCHCK : '//
     +        'Path name '//PATHN//' from node bank illegal'')', IQ, 0)
+SELF.
              GO TO 998
            ENDIF
            NKEYDK = IQUEST(7)
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
            IF (IUSEDT.EQ.ICUR.AND.KEY1.EQ.MNKYDT.AND.
     +          JBIT(KEY6DT,JIGNDB).EQ.0)                      GO TO 998
*
          ENDIF
*
        ENDIF
*
*  *    Data should be refreshed
*  *    Check which keys are to be used
*
   55   IF (IOPSDA.EQ.0)  THEN
          DO 60 I = 1, NWKYDK
            IF (IOKYDA(I).NE.0) THEN
              IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB.OR.I.EQ.MITMDB)  THEN
                KEYVDK(I) = KEYS(I)
              ELSE
                KEYVDK(I) = IQ(KOFUDB+LREFDB(2)+I)
              ENDIF
            ELSE
              KEYVDK(I) = 0
            ENDIF
   60     CONTINUE
        ELSE
          CALL UCOPY (IQ(KOFUDB+LREFDB(2)+1), KEYVDK, NWKYDK)
        ENDIF
*
*  *    Retrieve data
*
        IDTYP  = IDBTYP (LREFDB(2))
        IF (IOPVDA.NE.0.OR. JBIT(KEY6,JRZUDB).NE.0 . OR.
     +     (IDTYP.NE.2.AND.IDTYP.NE.3.AND.IDTYP.NE.5)) THEN
*
*  *      Variable data length - attach data to a new bank
*
          CALL MZDROP (IDIVDB, LREFDB(3), 'L')
          CALL DBKXIN (ITIME, IDIVDB, LBD(1), LBK(1), -KLDADB, NWKEY,
     +                 KEYVDK, IPREC)
          IF (IQUEST(1).NE.0)                                  GO TO 998
          LREFDB(3) = LBD(1)
          IF (IOPSDA.EQ.0) THEN
            IF (IQ(KOFUDB+LREFDB(2)+MSERDB).NE.KEYVDK(MSERDB)) IQ2 = 1
          ELSE
            IQ2 = 1
          ENDIF
*
        ELSE
*
*  *      Fixed length data - overwrite existing data
*
          IF (LAUXDL(7).NE.0)  THEN
            CALL MZDROP (IDISDB, LAUXDL(7), 'L')
            LAUXDL(7) = 0
          ENDIF
          JBIAS  = 2
          NDAT   = IQ(KOFUDB+LREFDB(3)-1)
          CALL DBKXIN (ITIME, IDISDB, LAUXDL(7), LAUXDL(7), JBIAS
     +               , NWKEY, KEYVDK, IPREC)
          IF (IQUEST(1).NE.0)                                  GO TO 998
          IF (IOPSDA.EQ.0) THEN
            IF (IQ(KOFUDB+LREFDB(2)+MSERDB).NE.KEYVDK(MSERDB)) IQ2 = 1
          ELSE
            IQ2 = 1
          ENDIF
+SELF, IF= $P3CHILD.
          IF (IPASP3.EQ.1)                                     GO TO 990
+SELF.
*
          IF (LAUXDL(7).EQ.0) THEN
            IQUEST(1) = 36
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCHCK : Ill'//
     +      'egal Bank address from DBKXIN'')', IARGDB, 0)
+SELF.
            GO TO 998
*
          ELSE
*
*  **       See if the old bank size is sufficient to store the data
*
            ND     = IQ(KOFUDB+LAUXDL(7)-1)
            IF (ND.GT.NDAT) THEN
*
*  *          Insufficient space
*
              CALL MZDROP (IDISDB, LAUXDL(7), 'L')
              IQUEST(1) = 37
              IQUEST(11)= ND
              IQUEST(12)= NDAT
+SELF, IF=$DEBUG.
              IF (IDEBDB.GT.0) THEN
                IARGDB(1) = IQUEST(12)
                IARGDB(2) = IQUEST(11)
                CALL DBPRNT (LPRTDB, '(/,'' DBCHCK : Insufficient spa'//
     +               'ce '',I10,'' to store data - a minimum of '','//
     +               'I10,'' storage is needed'')', IARGDB, 2)
              ENDIF
+SELF.
              GO TO 998
*
            ELSE
*
*  *          Everything is OK
*
              CALL UCOPY (Q(KOFUDB+LAUXDL(7)+1), Q(KOFUDB+LREFDB(3)+1),
     +                    ND)
              CALL MZDROP (IDISDB, LAUXDL(7), 'L')
              IQUEST(1) = 0
*
            ENDIF
*
          ENDIF
*
        ENDIF
*
*  *    Overwrite keys in key-bank
*
  990   CALL UCOPY (KEYVDK(1), IQ(KOFUDB+LREFDB(2)+1), NWKYDK)
        IQ(KOFUDB+LREFDB(2)+NDK+MKYPRE) = IPREC
        IQ(KOFUDB+LREFDB(2)+NDK+MKYRID) =IQ(KOFUDB+LREFDB(2)+NDK+MKYRID)
     +                                  + 1
        IF (IOPSDA.EQ.0) THEN
          IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).EQ.0) THEN
            IQ(KOFUDB+LREFDB(2)+NWKYDK+1) =
     +        MIN (IQ(KOFUDB+LREFDB(2)+MEVRDB), KY4MDB)
          ELSE
            IQ(KOFUDB+LREFDB(2)+NWKYDK+1) =
     +        IQ(KOFUDB+LREFDB(2)+MBVRDB) + 1
          ENDIF
        ENDIF
*
      ENDIF
*
  998 IQUEST(2) = IQ2
*                                                             END DBCHCK
  999 END
+DECK, DBCHFI.
      SUBROUTINE DBCHFI (I, CH)
*     =========================
*
************************************************************************
*                                                                      *
*        SUBR. DBCHFI (I, CH*)                                         *
*                                                                      *
*   Converts an integer I to an output single character CH (of type    *
*   Character) via the look-up table stored in CSTRDA                  *
*   (Adapted from CHTOI from CERN Library)                             *
*                                                                      *
*   Called by DBLIND                                                   *
*                                                                      *
************************************************************************
*
+CDE, DAOPTI.
      CHARACTER       CH*1
*     ------------------------------------------------------------------
*
      CH = CSTRDA(63:63)
      IF (I.LT.32.OR.I.GT.126) GO TO 999
      CH = CSTRDA(I:I)
*                                                             END DBCHFI
  999 END
+DECK, DBCHKY.
      SUBROUTINE DBCHKY (ITIME, KEYS)
*     ===============================
*
************************************************************************
*                                                                      *
*        SUBR. DBCHKY (ITIME, KEYS)                                    *
*                                                                      *
*   Checks if the current key bank is still valid                      *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     ITIME    Time for which the valid data are required              *
*     KEYS     Vector of keys                                          *
*                                                                      *
*   Called by DBCHCK                                                   *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DTKXIN.
      DIMENSION       KEYS(9)
*
*     ------------------------------------------------------------------
*
* *** Loop over the keys
*
      DO 20 IK = IMINDT, NKEYDK
        CALL DBKEYR (IK, NWKYDK, KEYVDK)
*
        IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).EQ.0) THEN
          IF (ITIME.LT.KEYVDK(MBVRDB).OR.ITIME.GT.KEYVDK(MEVRDB))
     +                                                  GO TO 20
        ELSE IF (IOKYDA(MBVRDB).NE.0.AND.IOKYDA(MEVRDB).EQ.0) THEN
          IF (KEYVDK(MBVRDB).GT.KEYS(MBVRDB))           GO TO 20
        ELSE IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).NE.0) THEN
          IF (KEYVDK(MEVRDB).LT.KEYS(MEVRDB))           GO TO 20
        ELSE
          IF (KEYVDK(MBVRDB).GT.KEYS(MBVRDB).OR.
     +        KEYVDK(MEVRDB).LT.KEYS(MEVRDB))           GO TO 20
        ENDIF
        IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.
     +      IQ(KOFUDB+LREFDB(2)+MPVSDB))                GO TO 20
        IF (IOKYDA(MITMDB).NE.0.AND.KEYS(MITMDB).LT.KEYVDK(MITMDB))
     +                                                  GO TO 20
        IF (KY7MDB.NE.0.AND.KY7MDB.LT.KEYVDK(MITMDB))   GO TO 20
        IF (NWKYDK.GT.NSYSDK) THEN
          DO 10 J = NSYSDK+1, NWKYDK
            IF (IOKYDA(J).NE.0)  THEN
              IF (KEYVDK(J).NE.IQ(KOFUDB+LREFDB(2)+J))  GO TO 20
            ENDIF
   10     CONTINUE
        ENDIF
*
        IF (MNKYDT.LE.KEYVDK(MSERDB))  THEN
          MNKYDT = KEYVDK(MSERDB)
          KEY6DT = KEYVDK(MFLGDB)
          IUSEDT = ICURDT
        ENDIF
   20 CONTINUE
*                                                             END DBCHKY
  999 END
+DECK, DBCMPR.
      SUBROUTINE DBCMPR (LB, IADS, IER)
*     =================================
*
************************************************************************
*                                                                      *
*        SUBR. DBCMPR (LB, IADS*, IER*)                                *
*                                                                      *
*   Compresses data bank defined by LB in the Data Base                *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LB       Address of the bank to be compressed                    *
*     IADS(*)  Address of the compressed bank as LAUXDL(IADS)          *
*     IER(*)   Error Code : 0    No error                              *
*                           1-3  As in DBFLIN/DBININ                   *
*                           4    Not enough precision for packing      *
*                           5    Nonstandard Data type                 *
*                                                                      *
*   Called by DBCOMP                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IER       =  0 : No error (see above)                            *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DLINKS.
      DIMENSION       LB(9)
      SAVE            IWMX
      DATA            IWMX /1073741824/
+SEQ, L3BITX, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Data type ?
*
      LREFDB(5) = LB(1)
      IDTYP  = IDBTYP(LREFDB(5))
      NDA    = IQ(KOFUDB+LREFDB(5)-1)
      JBIAS  = 2
      CALL DBBOOK (IDISDB, LAUXDL(IADS), LAUXDL(IADS), JBIAS, 'AUX1', 0,
     +             0, NDA, 2, 0)
      IF (IQUEST(1).NE.0) GO TO 999
      LAUX1  = LAUXDL(IADS)
      IF (IDTYP.EQ.3) THEN
*
*  **   Convert real to integer data and truncate according to precision
*
        CALL DBFLIN (Q(KOFUDB+LREFDB(5)+1), IQ(KOFUDB+LAUX1+1), NDA,
     +               IPREC, IER)
        IF (IER.NE.0) THEN
          CALL MZDROP (IDISDB, LAUX1, ' ')
          GO TO 999
        ENDIF
*
      ELSE IF (IDTYP.EQ.2.OR.IDTYP.EQ.5) THEN
*
*  **   Truncate integer data according to the given precision
*
        CALL DBININ (IQ(KOFUDB+LREFDB(5)+1), IQ(KOFUDB+LAUX1+1), NDA,
     +               IPREC, IER)
        IF (IER.NE.0) THEN
          CALL MZDROP (IDISDB, LAUX1, ' ')
          GO TO 999
        ENDIF
      ELSE
*
*  **   Nonstandard data type
*
        IER    = 5
        CALL MZDROP (IDISDB, LAUX1, ' ')
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBCMPR : Data-Ty'//
     +  'pe '',I4,'' incompatible for packing'')', IDTYP, 1)
+SELF.
        GO TO 999
      ENDIF
*
* *** Convert signed integer to positive integers
*
      ND2    = NDA - 2
      LAU12  = KOFUDB + LAUX1 + 2
      IVM    = IQ(LAU12+1)
      MVM    = IQ(LAU12+1)
      DO 10 I = 2, ND2
        IF (IQ(LAU12+I).LT.IVM) IVM = IQ(LAU12+I)
        IF (IQ(LAU12+I).GT.MVM) MVM = IQ(LAU12+I)
   10 CONTINUE
*
      IF (MVM.GT.IWMX.OR.-IVM.GT.IWMX) THEN
        IER    = 4
        CALL MZDROP (IDISDB, LAUXDL(IADS),   ' ')
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBCMPR : Packing'//
     +  ' Bit Length is '',I4,'' - No Compression !'')', LBITL, 1)
+SELF.
        GO TO 999
      ENDIF
*
      IF (IVM.LT.0) THEN
        IVM    = - IVM
        DO 20 I = 1, ND2
          IQ(LAU12+I) = IQ(LAU12+I) + IVM
   20   CONTINUE
      ELSE
        IVM    = 0
      ENDIF
*
* *** Pack the positive integers into bit-string choosing optimum
* *** bit-length
*
      ND3    = ND2 + 3
      JBIAS  = 2
      CALL DBBOOK (IDISDB, LAUXDL(IADS+1), LAUXDL(IADS+1), JBIAS, 'AUX2'
     +           , 0, 0, ND3, 1, 0)
      IF (IQUEST(1).NE.0) GO TO 999
      CALL DBBOOK (IDISDB, LSTRDL(5), LSTRDL(5), JBIAS, 'WKSP', 0, 0
     +           , ND3, 1, -1)
      IF (IQUEST(1).NE.0) GO TO 999
      LAUX1  = LAUXDL(IADS)
      LAU13  = LAUX1 + 3
      LAUX2  = LAUXDL(IADS+1)
      CALL DBPACK (IQ(KOFUDB+LAU13), ND2, NDO, NAU, LBITL
     +           , IQ(KOFUDB+LAUX2+4), IQ(KOFUDB+LSTRDL(5)+1))
      CALL MZDROP (IDISDB, LSTRDL(5), ' ')
*
      IF (LBITL.EQ.32) THEN
        IER    = 4
        CALL MZDROP (IDISDB, LAUXDL(IADS),   ' ')
        CALL MZDROP (IDISDB, LAUXDL(IADS+1), ' ')
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBCMPR : Packing'//
     +  ' Bit Length is '',I4,'' - No Compression !'')', LBITL, 1)
+SELF.
        GO TO 999
      ENDIF
*
      IPREC  = IPREC + 100
      IQ(KOFUDB+LAUX2+1) = 10000*ND2 + 1000*IDTYP + IPREC
      IQ(KOFUDB+LAUX2+2) = IVM
      LAU    = LAUX2 + 3
      IQ(KOFUDB+LAU) = NAU
      IQ(KOFUDB+LAU) = MCBYT (LBITL, 1, IQ(KOFUDB+LAU), 27, 5)
      IQ(KOFUDB+LAU) = MSBIT1 (IQ(KOFUDB+LAU), 32)
*
* *** Rebook AUX1 bank with reduced datalength
*
      ND3    = NDO + 3
      CALL MZDROP (IDISDB, LAUX1, ' ')
      JBIAS  = 2
      CALL DBBOOK (IDISDB, LAUXDL(IADS), LAUXDL(IADS), JBIAS, 'AU11', 0,
     +             0, ND3, 1, 0)
      IF (IQUEST(1).NE.0) GO TO 999
      LAUX1  = LAUXDL(IADS)
      LAUX2  = LAUXDL(IADS+1)
      CALL UCOPY (IQ(KOFUDB+LAUX2+1), IQ(KOFUDB+LAUX1+1), ND3)
      CALL MZDROP (IDISDB, LAUX2, ' ')
      IER    = 0
*                                                             END DBCMPR
  999 END
+DECK, DBCMPZ.
      SUBROUTINE DBCMPZ (LB, IADS, IER)
*     =================================
*
************************************************************************
*                                                                      *
*        SUBR. DBCMPZ (LB, IADS*, IER*)                                *
*                                                                      *
*   Compresses data bank defined by LB in the Data Base                *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LB       Address of the bank to be compressed                    *
*     IADS(*)  Address of the compressed bank as LAUXDL(IADS)          *
*     IER(*)   Error Code : 0    No error                              *
*                           1    Compression does not result in gaining*
*                                space                                 *
*                           5    Nonstandard Data type                 *
*                                                                      *
*   Called by DBCOMP                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IER       =  0 : No error (see above)                            *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DLINKS.
+CDE, DZPACK.
      DIMENSION       LB(9)
*
*     ------------------------------------------------------------------
*
* *** Data type ?
*
      LREFDB(5) = LB(1)
      IDTYP  = IDBTYP (LREFDB(5))
      NDA    = IQ(KOFUDB+LREFDB(5)-1)
      ND2    = NDA - 2
      JBIAS  = 2
      CALL DBBOOK (IDISDB, LAUXDL(IADS), LAUXDL(IADS), JBIAS, 'AUX1', 0,
     +             0, NDA, IDTYP, 0)
      IF (IQUEST(1).NE.0)   GO TO 999
      LAUX1  = LAUXDL(IADS)
*
      IF (IDTYP.EQ.3) THEN
*
*  **   Compress non-0 real data
*
        CALL DBFZIN (Q(KOFUDB+LREFDB(5)+3), ND2, Q(KOFUDB+LAUX1+1), NDO,
     +               PRECDZ, IER)
        IF (IER.NE.0) THEN
          CALL MZDROP (IDISDB, LAUX1, ' ')
          GO TO 999
        ENDIF
*
*  **   Copy compressed data into reduced array with appropriate header
*
        ND3    = NDO + 3
        JBIAS  = 2
        CALL DBBOOK (IDISDB, LAUXDL(IADS+1), LAUXDL(IADS+1), JBIAS,
     +               'AUX2', 0, 0, ND3, IDTYP, 0)
        IF (IQUEST(1).NE.0) GO TO 999
        LAUX1  = LAUXDL(IADS)
        LAUX2  = LAUXDL(IADS+1)
*
        Q(KOFUDB+LAUX2+1) = ND2
        Q(KOFUDB+LAUX2+2) = PRECDZ
        Q(KOFUDB+LAUX2+3) = NDO
        CALL UCOPY (Q(KOFUDB+LAUX1+1), Q(KOFUDB+LAUX2+4), NDO)
        CALL MZDROP (IDISDB, LAUX1, ' ')
        LAUXDL(IADS) = LAUXDL(IADS+1)
        LAUXDL(IADS+1) = 0
*
       ELSE IF (IDTYP.EQ.2.OR.IDTYP.EQ.5) THEN
*
*  **   Compress non-0 integer data
*
        CALL DBIZIN (IQ(KOFUDB+LREFDB(5)+3), ND2, IQ(KOFUDB+LAUX1+1),
     +               NDO, PRECDZ, IER)
        IF (IER.NE.0) THEN
          CALL MZDROP (IDISDB, LAUX1, ' ')
          GO TO 999
        ENDIF
*
*  **   Copy compressed data into reduced array with appropriate header
*
        ND3    = NDO + 3
        JBIAS  = 2
        CALL DBBOOK (IDISDB, LAUXDL(IADS+1), LAUXDL(IADS+1), JBIAS,
     +               'AUX2', 0, 0, ND3, IDTYP, 0)
        IF (IQUEST(1).NE.0) GO TO 999
        LAUX1  = LAUXDL(IADS)
        LAUX2  = LAUXDL(IADS+1)
*
        IQ(KOFUDB+LAUX2+1) = ND2
        IQ(KOFUDB+LAUX2+2) = PRECDZ
        IQ(KOFUDB+LAUX2+3) = NDO
        CALL UCOPY (IQ(KOFUDB+LAUX1+1), IQ(KOFUDB+LAUX2+4), NDO)
        CALL MZDROP (IDISDB, LAUX1, ' ')
        LAUXDL(IADS) = LAUXDL(IADS+1)
        LAUXDL(IADS+1) = 0
*
      ELSE
*
*  **   Nonstandard Data type
*
        IER    = 5
        CALL MZDROP (IDISDB, LAUX1, ' ')
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBCMPZ : Data-Ty'//
     +  'pe'',I4,'' incompatible for packing'')', IDTYP, 1)
+SELF.
        GO TO 999
      ENDIF
*
      IER    = 0
*                                                             END DBCMPZ
  999 END
+DECK, DBCOMP.
      SUBROUTINE DBCOMP (LSUP, LUPDA, KEYS)
*     =====================================
*
************************************************************************
*                                                                      *
*        SUBR. DBCOMP (LSUP, LUPDA*, *KEYS*)                           *
*                                                                      *
*   Compresses data bank defined by LSUP in the Data Base              *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LSUP     Address of the bank to be compressed                    *
*     LUPDA(*) Address of the compressed bank                          *
*     KEYS     Vector of keys; Key 2 on return will contain the        *
*              pointer to the Key 1 of the object with reference       *
*              to which the current object has been updated            *
*                                                                      *
*   Called by DBENTB, DBNTOP, DBENFZ, DBKOUT                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DZPACK.
      PARAMETER       (MXNEI=5)
      DIMENSION       LSUP(9), LUPDA(9), KEYS(9)
*
*     ------------------------------------------------------------------
*
      IADS      = 1
      KEYS(MUPNDB)   = 0
      LREFDB(3) = LSUP(1)
*
* *** If data is of mixed type, data cannot be compressed !
*
      ITYP   = IDBTYP (LREFDB(3))
      IF (ITYP.NE.2.AND.ITYP.NE.3)  THEN
        LUPDA(1) = LREFDB(3)
        GO TO 999
      ENDIF
*
* *** Compress the data
*
      IF (PACKDZ) THEN
        CALL DBCMPZ (LSUP(1), IADS, IER)
      ELSE
        CALL DBCMPR (LSUP(1), IADS, IER)
      ENDIF
      IF (IQUEST(1).NE.0)             GO TO 999
*
* *** If IER .ne. 0 ----> Data cannot be compressed !
*
      IF (IER.EQ.0)  THEN
        LUPDA(1) = LAUXDL(IADS)
      ELSE
        LUPDA(1) = LREFDB(3)
        GOTO  999
      ENDIF
*
      IF (IQUEST(1).NE.0)             GO TO 999
      IF (IOPSDA.NE.0)                GO TO 999
      IF (NKEYDK.EQ.0)                GO TO 999
*
* *** Can we compress better by taking the difference of the present and
* ***   neighbouring objects ?
*
      ISTP   = NWKYDK + 1
*
      LREFDB(4) = LUPDA(1)
      MINWD  = IQ(KOFUDB+LREFDB(4)-1)
      IADS   = 9
      LADR   = -777
      NEIGH  = 0
      DO 50 I = 1, NKEYDK
        J      = NKEYDK + 1 - I
        IPNT   = KOFSDB + LCDRDB + IKDRDB + (J-1) * ISTP
        KEY2   = IQ(IPNT+MUPNDB)
        IF (KEY2.NE.0)                GO TO 50
        IF (IOPFDA.NE.0) THEN
          CALL DBKEYR (J, NWKYDK, KEYNDK)
          DO 10 K = NSYSDK+1, NWKYDK
            IF (KEYS(K).NE.KEYNDK(K)) GO TO 50
   10     CONTINUE
        ENDIF
        NEIGH  = NEIGH + 1
        IF (NEIGH.GT.MXNEI)           GO TO 60
*
        IF (LSTRDL(4).NE.0) CALL MZDROP (IDISDB, LSTRDL(4), 'L')
        LSTRDL(4) = 0
        JBIAS  = 2
        CALL DBRZIN (IDISDB, LSTRDL(4), JBIAS, J, ICYCL, ' ')
        IF (IQUEST(1).NE.0)  THEN
          IF (LSTRDL(4).NE.0) CALL MZDROP (IDISDB, LSTRDL(4), 'L')
          GO TO 50
        ENDIF
*
        CALL DBKEYR (J, NWKYDK, KEYNDK)
*
        LCOM   = LSTRDL(4)
*
*  **   Uncompress ?
*
        IF (IQ(KOFUDB+LCOM+1).NE.0)  THEN
          CALL DBUNCP (LSTRDL(4), LREFDL(2), 0)
          IER    = IQUEST(1)
          CALL MZDROP (IDISDB, LSTRDL(4), 'L')
          IF (IER.NE.0) THEN
            IQUEST(1) = IER
            GO TO 999
          ENDIF
          LCOM   = LREFDL(2)
        ENDIF
        LREFDL(7) = LCOM
*
*  **   Look if the data are similar - take the most similar master
*
        ND1    = IQ(KOFUDB+LREFDB(3) - 1)
        ND2    = IQ(KOFUDB+LCOM - 1)
        IF (ND2.EQ.0) THEN
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBCOMP : The '//
     +    'Data Structure does not contain data'',/)', IARGDB, 0)
+SELF.
          CALL MZDROP (IDISDB, LCOM, ' ')
          GO TO 50
        ENDIF
*
        IT1    = IDBTYP(LREFDB(3))
        IT2    = IDBTYP(LCOM)
        IF (IT1.NE.IT2)  THEN
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.1) THEN
            IARGDB(1) = IT1
            IARGDB(2) = IT2
            CALL DBPRNT (LPRTDB, '(/,'' DBCOMP : The 2 Structures hav'//
     +           'e different data type '',2I4)', IARGDB, 2)
          ENDIF
+SELF.
          CALL MZDROP (IDISDB, LCOM, ' ')
          GO TO 50
        ENDIF
        IF (ND1.NE.ND2) THEN
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.1) THEN
            IARGDB(1) = ND1
            IARGDB(2) = ND2
            CALL DBPRNT (LPRTDB, '(/,'' DBCOMP : The 2 Structures hav'//
     +      'e different # of data'',2I4)', IARGDB, 2)
          ENDIF
+SELF.
          CALL MZDROP (IDISDB, LCOM, ' ')
          GO TO 50
        ENDIF
        IF (IT1.EQ.2.OR.IT1.EQ.5) THEN
          IQ(KOFUDB+LCOM+2) = IQ(KOFUDB+LREFDB(3)+2)
          DO 20 ID = 3, ND1
   20     IQ(KOFUDB+LCOM+ID) =IQ(KOFUDB+LCOM+ID)-IQ(KOFUDB+LREFDB(3)+ID)
        ELSE
          Q(KOFUDB+LCOM+2) = Q(KOFUDB+LREFDB(3)+2)
          DO 30 ID = 3, ND1
   30     Q(KOFUDB+LCOM+ID) = Q(KOFUDB+LCOM+ID) - Q(KOFUDB+LREFDB(3)+ID)
        ENDIF
*
   40   CONTINUE
        IF (PACKDZ) THEN
          CALL DBCMPZ (LREFDL(7), IADS, IER)
        ELSE
          CALL DBCMPR (LREFDL(7), IADS, IER)
        ENDIF
        IF (IQUEST(1).NE.0) THEN
          IER       = IQUEST(1)
          CALL MZDROP (IDISDB, LREFDL(7), ' ')
          IQUEST(1) = IER
          GO TO 999
        ENDIF
        LCOM   = LREFDL(7)
        IF (IER.NE.0) THEN
          CALL MZDROP (IDISDB, LCOM, ' ')
          GO TO 50
        ENDIF
*
        LADR   = LAUXDL(IADS)
        NWORD  = IQ(KOFUDB+LADR-1)
        IF (NWORD.GE.MINWD)  THEN
          CALL MZDROP (IDISDB, LCOM, ' ')
          CALL MZDROP (IDISDB, LADR, ' ')
          GO TO 50
        ENDIF
        KEYS(MUPNDB)= KEYNDK(MSERDB)
        MINWD  = NWORD
        CALL MZDROP (IDISDB, LCOM, ' ')
        CALL MZDROP (IDISDB, LREFDB(4), ' ')
        LUPDA(1)  = LADR
        LREFDB(4) = LADR
        IF (IADS.EQ.1)  THEN
          IADS   = 9
        ELSE IF (IADS.EQ.9) THEN
          IADS   = 1
        ENDIF
   50 CONTINUE
   60 CONTINUE
      IF (LREFDB(4).NE.LADR .AND. LADR.NE.-777)
     +  CALL MZDROP (IDISDB, LADR, ' ')
      IQUEST(1) = 0
*                                                             END DBCOMP
  999 END
+DECK, DBDELK, IF=-$P3CHILD.
      SUBROUTINE DBDELK (IOPS)
*     ========================
*
************************************************************************
*                                                                      *
*        SUBR. DBDELK                                                  *
*                                                                      *
*   Deletes objects in a given directory taking care the objects with  *
*   IPURDK(n) set to 2 and those on which these objects depend are     *
*   preserved                                                          *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IOPS     Shared option (0 if stand alone)                        *
*                                                                      *
*   Called by DBPURG, DBPURK                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
*
*     ------------------------------------------------------------------
*
* *** Label by '1' those objects one should not delete
*
      IF (IOPS.NE.0) CALL RZLOCK ('DBDELK')
      IPNT   = KOFSDB + LCDRDB + IKDRDB
      ISTP   = NWKYDK + 1
      I1     = 1
      NDEL   = 0
   10 IF (I1.LE.NKEYDK)  THEN
        NN     = NKEYDK - I1 + 1
        II     = IUCOMP (2, IPURDK(I1), NN)
        IF (II.GT.0)  THEN
          II     = II + I1 - 1
          I1     = II + 1
   15     IP     = IPNT + (II - 1) * ISTP
          NO1    = IQ(IP+MUPNDB)
          II     = IUCOMP (NO1, KEY1DK, NKEYDK)
          IF (II.GT.0.AND.NO1.NE.0) THEN
            IF (IPURDK(II).NE.2) IPURDK(II) = 1
            GO TO 15
          ENDIF
          GO TO 10
        ENDIF
      ENDIF
*
      DO 20 IK1 = 1, NKEYDK
        IK     = NKEYDK + 1 - IK1
        IF (IPURDK(IK).LE.0) THEN
          CALL DBKEYR (IK, NWKYDK, KEYNDK)
          CALL RZDELK (KEYNDK, ICDUM, 'C')
          NDEL   = NDEL + 1
        ENDIF
   20 CONTINUE
      IF (IOPS.NE.0) CALL RZFREE ('DBDELK')
      IQUEST(2) = NDEL
*                                                             END DBDELK
  999 END
+DECK, DBENFZ, IF=-$P3CHILD.
      SUBROUTINE DBENFZ (PATHN, LUNFZ, IOPP, TOPN, IOPS)
*     ==================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBENFZ (PATHN, LUNFZ, IOPP, TOPN, IOPS)                 *
*                                                                      *
*   Enters data objects using either data residing in a FZ file or     *
*   data hung at address LFIXDB                                        *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     LUNFZ    Logical unit number of the FZ file                      *
*              or 0 if data does not reside on FZ file                 *
*     IOPP     Public mode flag in server environment                  *
*     TOPN     Name of the top directory                               *
*     IOPS     Flag to indicate shared mode (0 if standalone)          *
*                                                                      *
*   Called by DBFZUP                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 77 : FZOUT fails to write on to the sequential file  *
*               =141 : Read error on the FZ file                       *
*               =143 : Illegal path name in the transcript file        *
*               =144 : Error in RZ for saving the data object          *
*               =145 : Error in RZ for reanming the keys               *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DZPACK.
      DIMENSION       KEYO(MXDMDK), KEYN(MXDMDK)
      CHARACTER       PATHN*(*), PATHX*16, PATHY*80, CHFOR*100, CHOP*1
      CHARACTER       CFORM(6)*1, TOPN*(*)
      DATA            CFORM / 'B', 'I', 'F', 'D', 'H', 'A' /
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
      JBIAS  = 2
      IF (IOPUDA.NE.0) THEN
        IOPZDA = 0
        PACKDZ = .FALSE.
        IPREC  = 0
      ELSE IF (IOPZDA.NE.0) THEN
        PACKDZ = .TRUE.
        CALL UCOPY (IHEADF(MPREDF), PRECDZ, 1)
      ELSE
        PACKDZ = .FALSE.
        IPREC  = IHEADF(MPREDF)
      ENDIF
      MAXL   = LEN (PATHN)
      NCH    = INDEX (PATHN(1:MAXL), ' ') - 1
      IF (NCH.LT.1) NCH = MAXL
*
* *** Check if the object already exists in the data base
*
      IPNT   = KOFSDB + LCDRDB + IKDRDB
      ISTP   = NWKYDK + 1
      IF (NKEYDK.GT.0) THEN
        IOPTP  = JBIT (IQ(IPNT+MFLGDB), JPRTDB)
      ELSE
        IOPTP  = 0
      ENDIF
      KEY1   = IHEADF(MPREDF+MSERDB)
      IF (IOVRDB.NE.0) KEY1 = 0
      IF (IOPTP.EQ.0) THEN
        IF (KEY1.GT.0) THEN
          IFND   = IUHUNT (KEY1, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)
          IF (IFND.NE.0)                 GO TO 998
        ELSE
          KOBJ   = 0
        ENDIF
        PATHY  = PATHN
      ELSE
        MXKP   = IQ(IPNT+MXKPDB)
        NKEYS  = NKEYDK
        CALL DBKYTG
        DO 15 JK = 1, NKEYS
          IK     = NKEYS + 1 - JK
          KPNT   = IUHUNT (IK, IQ(IPNT+MPSRDB), NKEYS*ISTP, ISTP)
          IF (KPNT.NE.0) THEN
            KPNT   = IPNT + KPNT - MPSRDB
          ELSE
            KPNT   = IPNT + (IK - 1) * ISTP
          ENDIF
          IF (KEY1.GT.0) THEN
            IF (IQ(KPNT+MOBJDB).GE.KEY1) GO TO 15
          ENDIF
*
*  **     Get the appropriate sub-directory
*
          NK     = (KPNT - IPNT) / ISTP + 1
          CALL DBKEYR (NK, NWKYDK, KEYO)
          CALL DBPATH (PATHX, IK)
          PATHY  = PATHN(1:NCH)//'/'//PATHX
          CALL RZCDIR (PATHY, ' ')
          IF (IQUEST(1).NE.0) THEN
            IQUEST(1) = 143
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENFZ : Ill'//
     +      'egal path name '//PATHY//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          NKEYDK = IQUEST(7)
          NWKYDK = IQUEST(8)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          IPNT   = KOFSDB + LCDRDB + IKDRDB
          IF (KEY1.NE.0) THEN
            IFND   = IUHUNT (KEY1, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)
            IF (IFND.NE.0) THEN
              PATHY  = PATHN(1:NCH)
              CALL RZCDIR (PATHY, ' ')
              IF (IQUEST(1).NE.0) THEN
                IQUEST(1) = 143
                GO TO 999
              ENDIF
              NKEYDK = IQUEST(7)
              NWKYDK = IQUEST(8)
              LCDRDB = IQUEST(11)
              IKDRDB = IQUEST(13)
              GO TO 998
            ENDIF
          ENDIF
*
*  **     Create a new subdirectory if needed
*
          IF (IOPP.EQ.0.AND.NKEYDK.GE.MXKP) THEN
            IF (IK.EQ.NKEYS) THEN
              CHFOR  = ' '
              IF (KEY1.NE.0) THEN
                KEY7DK = IHEADF(MPREDF+MITMDB)
              ELSE
                KEY7DK = 0
              ENDIF
              DO 10 I = 1, NWKYDK
                IF (I.EQ.1) THEN
                  CHFOR  = CFORM(IOTYDK(I))
                ELSE
                  CHFOR  = CHFOR(1:I-1)//CFORM(IOTYDK(I))
                ENDIF
   10         CONTINUE
              CALL DBMDIP (PATHN, NWKYDK, CHFOR, CTAGDK, MXKP)
              CALL RZCDIR (PATHN, ' ')
              IF (IQUEST(1).NE.0) THEN
                IQUEST(1) = 143
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) THEN
                  PATHY  = PATHN
                  CALL DBPRNT (LPRTDB, '(/,'' DBENFZ : Illegal path '//
     +                 'name '//PATHY//''')', IARGDB, 0)
                ENDIF
+SELF.
                GO TO 999
              ENDIF
              NKEYDK = IQUEST(7)
              NWKYDK = IQUEST(8)
              LCDRDB = IQUEST(11)
              IKDRDB = IQUEST(13)
              IPNT   = KOFSDB + LCDRDB + IKDRDB
              NK     = IUHUNT (NKEYDK, IQ(IPNT+MPSRDB),NKEYDK*ISTP,ISTP)
              IF (NK.GT.0) THEN
                NK     = (NK - MPSRDB) / ISTP + 1
              ELSE
                NK     = NKEYDK
              ENDIF
              CALL DBKEYR (NK, NWKYDK, KEYO)
              CALL DBPATH (PATHX, NKEYDK)
              PATHY  = PATHN(1:NCH)//'/'//PATHX
              CALL RZCDIR (PATHY, ' ')
              IF (IQUEST(1).NE.0) THEN
                IQUEST(1) = 143
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENFZ :'//
     +          ' Illegal path name '//PATHY//''')', IARGDB, 0)
+SELF.
                GO TO 999
              ENDIF
              NKEYDK = IQUEST(7)
              NWKYDK = IQUEST(8)
              LCDRDB = IQUEST(11)
              IKDRDB = IQUEST(13)
            ENDIF
          ENDIF
          GO TO 20
   15   CONTINUE
   20   CALL UCOPY (KEYO, KEYN, NWKYDK)
        KOBJ   = KEYO(MOBJDB)
      ENDIF
*
      IF (KEY1.LE.0.AND.IOPP.EQ.0) THEN
        IF (NKEYDK.GT.0) THEN
          DO 25 IK = 1, NKEYDK
            IP     = KOFSDB + LCDRDB + IKDRDB + (IK-1)*ISTP + MSERDB
            IF (IQ(IP).GT.KOBJ) KOBJ = IQ(IP)
   25     CONTINUE
        ENDIF
        KOBJ   = KOBJ + 1
        IHEADF(MPREDF+MSERDB) = KOBJ
      ENDIF
      IHEADF(MPREDF+MUPNDB) = 0
      IHEADF(MPREDF+MFLGDB) = MSBIT0 (IHEADF(MPREDF+MFLGDB), JRZUDB)
      IHEADF(MPREDF+MFLGDB) = MSBIT0 (IHEADF(MPREDF+MFLGDB), JPRTDB)
      IHEADF(MPREDF+MFLGDB) = MSBIT0 (IHEADF(MPREDF+MFLGDB), JASFDB)
      IF (IOKYDA(MITMDB).EQ.0.AND.IHEADF(MPREDF+MITMDB).LE.0) THEN
        CALL DATIME (IDATE, ITIME)
        CALL DBPKTM (IDATE, ITIME, IHEADF(MPREDF+MITMDB))
      ENDIF
*
* *** Now read the data part of the transcript file
*
      IF (LUNFZ.GT.0) THEN
        CALL FZIN (LUNFZ, IDISDB, LFIXDB, JBIAS, 'A', 0, 0)
        IF (IQUEST(1).GT.0) THEN
          IQUEST(1) = -1
          GO TO 999
        ELSE IF (IQUEST(1).NE.0) THEN
          IQUEST(11) = IQUEST(1)
          IQUEST(1)  = 141
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBENFZ : FZ er'//
     +    'ror type '',I12)', IQUEST(11), 1)
+SELF.
          GO TO 999
        ENDIF
      ENDIF
*
      IDB    = IDBTYP (LFIXDB)
      IF (IDB.EQ.2.OR.IDB.EQ.3) THEN
        IOPTR  = 0
      ELSE
        IOPTR  = 1
      ENDIF
*
      IF (IOPRDA.NE.0 .OR. IOPTR.NE.0 .OR. IOPTDA.NE.0) THEN
        IF (IOPTDA.NE.0) THEN
          CHOP   = 'S'
        ELSE IF (IOPRDA.NE.0) THEN
          CHOP   = 'L'
        ELSE
          CHOP   = ' '
        ENDIF
      ELSE
        CHOP   = 'S'
      ENDIF
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
      IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER.
        CALL DBWLOK
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER.
        CALL DBSTSV (TOPN, 0)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        IF (IQUEST(1).NE.0) THEN
          IRC    = IQUEST(1)
          CALL MZDROP (IDISDB, LFIXDB, 'L')
          IQUEST(1) = IRC
          GO TO 999
        ENDIF
      ENDIF
+SELF.
*
*  ** Write the sequential output if needed
*
      IF (LUFZDF.GT.0) THEN
        CALL FZOUT (LUFZDF, IDISDB, LFIXDB, 1, CHOP, IOFMDF, NWHEDF,
     +              IHEADF)
        IER    = IQUEST(1)
        IF (IER.NE.0) THEN
          CALL MZDROP (IDISDB, LFIXDB, 'L')
          IQUEST(1)  = 77
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) THEN
            PATHY  = PATHN
            CALL DBPRNT (LPRTDB, '(/,'' DBENFZ : Error in FZOUT for'//
     +           ' '//PATHY//''')', IARGDB, 0)
          ENDIF
+SELF.
          GO TO 999
        ENDIF
      ENDIF
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
      IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER.
        ISAVW  = IQUEST(9)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        CALL MZDROP (IDISDB, LFIXDB, 'L')
+SELF, IF=VAX, IF=$SERVER.
        IQUEST(9) = ISAVW
        CALL DBCWSV
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        GO TO 999
      ENDIF
+SELF.
*
* *** Compress the data if needed
*
      IF (IOPRDA.NE.0 .OR. IOPTR.NE.0 .OR. IOPTDA.NE.0) THEN
        IHEADF(MPREDF+MFLGDB) = MSBIT1 (IHEADF(MPREDF+MFLGDB), JRZUDB)
        IF (IOPTDA.NE.0)
     +    IHEADF(MPREDF+MFLGDB) = MSBIT1 (IHEADF(MPREDF+MFLGDB), JASFDB)
      ELSE
        LBDADB = LFIXDB
        LFIXDB = 0
        IF (IQ(KOFUDB+LBDADB-1).EQ.0) IOPUDA = 1
        CALL DBFRUS (LBDADB, LSTRDL(1), IPREC)
        IER    = IQUEST(1)
        CALL MZDROP (IDISDB, LBDADB, 'L')
        IF (IER.NE.0) THEN
          IQUEST(1) = IER
          GO TO 999
        ELSE
          IQUEST(1) = 0
        ENDIF
        IF (IOPUDA.NE.0) THEN
          LFIXDB = LSTRDL(1)
        ELSE
          CALL DBCOMP (LSTRDL(1), LFIXDB, IHEADF(MPREDF+1))
          IER    = IQUEST(1)
          IF (LSTRDL(1).NE.LFIXDB) CALL MZDROP (IDISDB, LSTRDL(1),'L')
          IF (IER.NE.0) THEN
            IQUEST(1) = IER
            GO TO 999
          ELSE
            IQUEST(1) = 0
          ENDIF
        ENDIF
      ENDIF
*
* *** Save the record on data base
*
      IF (IOPS.NE.0) CALL RZLOCK ('DBENFZ')
      CALL RZOUT (IDISDB, LFIXDB, IHEADF(MPREDF+1), ICYCL, CHOP)
      IER    = IQUEST(1)
      IF (IOPS.NE.0) CALL RZFREE ('DBENFZ')
      CALL MZDROP (IDISDB, LFIXDB, 'L')
      IF (IER.NE.0) THEN
        IQUEST(1) = 144
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          PATHY  = PATHN
          CALL DBPRNT (LPRTDB, '(/,'' DBENFZ : RZOUT  error for path '//
     +         'name '//PATHY//''')', IARGDB, 0)
        ENDIF
+SELF.
        GO TO 999
      ELSE
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) THEN
          CALL UCOPY (IHEADF(MPREDF+1), KEYNDK, NWKYDK)
          CALL DBUPTM (IARGDB(1), IARGDB(2), KEYNDK(MITMDB))
          CALL DBPRNT (LPRTDB, '(/,'' DBENFZ : Data was inserted into'//
     +         '   '//PATHY//''',/,10X,''on the '',I8,'' at '',I6,'' '//
     +         'with Key-Vector '')', IARGDB, 2)
          CALL DBKEYT
          CALL DBPRKY (NWKYDK, KEYNDK, IOTYDK)
        ENDIF
+SELF.
        IF (IOPTP.NE.0) THEN
          KEYN(MBVRDB) = MIN0 (KEYN(MBVRDB), IHEADF(MPREDF+MBVRDB))
          KEYN(MEVRDB) = MAX0 (KEYN(MEVRDB), IHEADF(MPREDF+MEVRDB))
          CALL RZCDIR (PATHN, ' ')
          IF (IQUEST(1).NE.0) THEN
            IQUEST(1) = 143
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) THEN
              PATHY  = PATHN
              CALL DBPRNT (LPRTDB, '(/,'' DBENFZ : Illegal path name'//
     +             ' '//PATHY//''')', IARGDB, 0)
            ENDIF
+SELF.
            GO TO 999
          ENDIF
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          IF (IOPS.NE.0) CALL RZLOCK ('DBENFZ')
          CALL RZRENK (KEYO, KEYN)
          IERR   = IQUEST(1)
          IF (IOPS.NE.0) CALL RZFREE ('DBENFZ')
          IF (IERR.NE.0) THEN
            IQUEST(1) = 145
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) THEN
              PATHY  = PATHN
              CALL DBPRNT (LPRTDB, '(/,'' DBENFZ : RZRENK error for '//
     +             'path name '//PATHY//''')', IARGDB, 0)
            ENDIF
+SELF.
            GO TO 999
          ENDIF
        ENDIF
      ENDIF
*
  998 IQUEST(1) = 0
*                                                             END DBENFZ
  999 END
+DECK, DBFLIN.
      SUBROUTINE DBFLIN (A, IA, N, IPREC, IER)
*     ========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBFLIN (A, IA*, N, IPREC, IER*)                         *
*                                                                      *
*   Converts floating to signed integer according to the given         *
*   precision                                                          *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     A        Input array of real numbers                             *
*     IA(*)    Output array of signed integers                         *
*     N        Length of the array                                     *
*     IPREC    Signed precision word; the data are truncated after     *
*              having multiplied by 10**IPREC                          *
*     IER(*)   Error Code : 0    No error                              *
*                           1    Precision not given or not correct    *
*                           2    Data exceeds 32 bits                  *
*                           3    Data is not uncompressed              *
*                                                                      *
*   Called by DBCMPR                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IER       =  0 : No error (see above)                            *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
      DIMENSION       A(N), IA(N)
*
      DATA            TOOBIG /2.1474E9/
*
*     ------------------------------------------------------------------
*
      IER    = 0
*
* *** Is data uncompressed ?
*
      IF (A(1).NE.0.) THEN
        IER    = 3
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBFLIN : Data is'//
     +  ' not uncompressed !'')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Precision ?
*
      IPREC  = A(2)
      IF (IPREC.LT.-99.OR.IPREC.GT.99) THEN
        IER    = 1
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBFLIN : Precisi'//
     +  'on is not correctly given - no compression'',/)', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      IF (IPREC.EQ.0) THEN
        IER    = 1
+SELF, IF=$DEBUG.
CCC     IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBFLIN : Precisi'//
CCC  +  'on is not given - Compression cannot be made'',/)', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      IPR1   = 0
      IPR2   = 0
      IF (IPREC.GT.0) IPR2 = IPREC
      IF (IPREC.LT.0) IPR1 = -IPREC
*
      IF (IPR1.NE.0) THEN
        XMULT  = 1./10.**IPR1
        DO 10 I = 3, N
          XXX    = A(I)*XMULT
*
*  **     Test overflow of IA - if overflow occurs, do not pack !
*
          IF (ABS(XXX).GT.TOOBIG) THEN
            IER    = 2
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBFLIN : Qua'//
     +      'ntity to be packed exceeds 32-Bit Integer size - no pack'//
     +      'ing'',/)', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
*
          IA(I) = XXX
   10   CONTINUE
      ELSE
        XMULT  = 10.**IPR2
        DO 20 I = 3, N
          XXX    = A(I)*XMULT
*
*  **     Test overflow of IA - if overflow occurs, do not pack !
*
          IF (ABS(XXX).GT.TOOBIG) THEN
            IER    = 2
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBFLIN : Qua'//
     +      'ntity to be packed exceeds 32-Bit Integer size - no pack'//
     +      'ing'',/)', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
*
          IF (XXX.GE.0.) THEN
            IA(I) = IFIX (XXX + 0.5)
          ELSE
            IA(I) = IFIX (XXX - 0.5)
          ENDIF
   20   CONTINUE
      ENDIF
*                                                             END DBFLIN
  999 END
+DECK, DBFPAT.
+SEQ, T=DUMMY, IF=$P3CHILD, IF=IBM.
      SUBROUTINE DBFPAT (CPATH, LEVMX, LAD)
*     =====================================
*
************************************************************************
*                                                                      *
*        SUBR. DBFPAT (CPATH, LEVMX, LAD*)                             *
*                                                                      *
*   Store the information of the directory tree CPATH in a bank        *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     CPATH    The pathname of the directory tree about which the      *
*              information has to be provided                          *
*     LEVMX    Number of levels below CPATH about which information    *
*              has to be accumulated                                   *
*     LAD(*)   Address of the bank containing the information          *
*                                                                      *
*   Called by DBKEPT, DBACPL                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =161 : Illegal path name                               *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
      PARAMETER       (NLEVM=20, NWITM=28, NPUSH=10)
      PARAMETER       (NWLEV=8, NWNOD=6)
      DIMENSION       NKEY(NLEVM), NCHD(NLEVM), ISDI(NLEVM)
      DIMENSION       NSDI(NLEVM), IOPT(NLEVM)
      DIMENSION       NODES(NLEVM), IHDIR(4), LAD(9)
      CHARACTER       PATHN*80, PATHX*16, PATHY*80, PATHD*80, PATHZ*16
      CHARACTER       CPATH*(*), PATHF*80
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
      IF (LAD(1).NE.0) THEN
        CALL MZDROP (IDIVDB, LAD(1), 'L')
        LAD(1) = 0
      ENDIF
      IF (LEVMX.LE.0) THEN
        LEVEL  = NLEVM
      ELSE
        LEVEL  = LEVMX
      ENDIF
      CALL VZERO (NODES, NLEVM)
      CALL DBSBLC (CPATH, PATHN, NCHAR)
      CALL RZCDIR (PATHD, 'R')
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 161
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFPAT : Illegal'//
     +  ' path name '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 100
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      IF (NKEYDK.LE.0) THEN
        IOPTP  = 0
      ELSE
        IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
      ENDIF
      CALL RZCDIR (PATHN, 'R')
      NCHR   = INDEX (PATHN, ' ') - 1
      IF (NCHR.LE.0.OR.NCHR.GT.MAXLDB) NCHR = MAXLDB
      NLEV   = 1
      NCHD(NLEV) = NCHR
*
* *** Create a temporary bank for storing information
*
      NDWD   = NPUSH * NWITM
      NKEEP  = NPUSH
      NITEM  = 0
      NLEVT  = NLEV
      NWDSN  = 0
      CALL DBBOOK (IDIVDB, LFIXDB, LFIXDB, 2, 'TEMP', 0, 0, NDWD, 0, -1)
      IF (IQUEST(1).NE.0)                 GO TO 100
*
* *** Now scan down to find all the subdirectories
*
   10 IF (NLEV.GT.1) THEN
        PATHN  = PATHN(1:NCHD(NLEV-1))//'/'//PATHX
        NCHD(NLEV) = NCHD(NLEV-1) + NCHR + 1
        CALL RZCDIR (PATHN, ' ')
        NKEYDK = IQUEST(7)
        NWKYDK = IQUEST(8)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        IF (NKEYDK.GT.0) THEN
          IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
        ELSE
          IOPTP  = 0
        ENDIF
      ENDIF
      NKEY(NLEV) = NKEYDK
      IOPT(NLEV) = IOPTP
      ISDI(NLEV) = 0
      NSDI(NLEV) = IQ(KOFSDB+LCDRDB+KNSDDB)
      IF (NLEV.EQ.LEVEL) NSDI(NLEV) = 0
*
   20 ISDI(NLEV) = ISDI(NLEV) + 1
      IF (ISDI(NLEV).LE.NSDI(NLEV)) THEN
*
*  **   If a new subdirectory go down one level
*
        LS    = IQ(KOFSDB+LCDRDB+KLSDDB)
        IPNT  = LS + 7 * (ISDI(NLEV) - 1)
        CALL ZITOH (IQ(KOFSDB+LCDRDB+IPNT), IHDIR, 4)
        CALL UHTOC (IHDIR, 4, PATHX, 16)
        NCHR  = INDEX (PATHX, ' ') - 1
        IF (NCHR.LE.0.OR.NCHR.GT.16) NCHR = 16
        IF (IOPTP.NE.0) THEN
          DO 30 IK = 1, NKEYDK
            KK     = IK
            IDIG   = 0
   25       IF (KK.GT.0) THEN
              KK     = KK / 10
              IDIG   = IDIG + 1
              GO TO 25
            ENDIF
            IF (NCHR.EQ.IDIG) THEN
+SELF, IF=-IBM, -$P3CHILD.
              WRITE (PATHY, '(I8)') IK
+SELF, IF=IBM, IF=$P3CHILD.
              CALL UTWRIT (PATHY, '(I8)', IK, 1)
+SELF.
              I1     = 8 - IDIG + 1
              PATHZ  = PATHY(I1:8)
              IF (PATHZ.EQ.PATHX)         GO TO 20
            ENDIF
   30     CONTINUE
        ENDIF
        NLEV   = NLEV +1
        IF (NLEV.GT.NLEVT) NLEVT = NLEV
        GO TO 10
*
      ELSE
*
*  **   Enter the new path name in the temporary space
*
        IF (NLEV.EQ.1) THEN
          NSTR   = 2
          DO 35 I = 3, NCHD(1)
            IF (PATHN(I:I).EQ.'/') NSTR = I
   35     CONTINUE
          PATHZ  = PATHN(NSTR+1:NCHD(NLEV))
          NCHR   = NCHD(NLEV) - NSTR
          NCHRT  = NSTR - 1
          PATHF  = PATHN(1:NCHRT)
        ELSE
          PATHZ  = PATHN(NCHD(NLEV-1)+2:NCHD(NLEV))
          NCHR   = NCHD(NLEV) - NCHD(NLEV-1) - 1
          PATHF  = PATHN(1:NCHD(NLEV-1))
          NCHRT  = NCHD(NLEV-1)
        ENDIF
        NODES(NLEV) = NODES(NLEV) + 1
*
        NITEM  = NITEM + 1
        IF (NITEM.GT.NKEEP) THEN
          LBDADB = LFIXDB
          LFIXDB = 0
          ND     = NDWD + NPUSH * NWITM
          CALL DBBOOK (IDIVDB, LFIXDB, LFIXDB, 2, 'TEMP', 0,0, ND, 0,-1)
          IF (IQUEST(1).NE.0) THEN
            IERR   = IQUEST(1)
            CALL MZDROP (IDIVDB, LBDADB, ' ')
            IQUEST(1) = IERR
            GO TO 100
          ENDIF
          CALL UCOPY (IQ(KOFUDB+LBDADB+1), IQ(KOFUDB+LFIXDB+1), NDWD)
          CALL MZDROP (IDIVDB, LBDADB, ' ')
          NDWD   = IQ(KOFUDB+LFIXDB-1)
          NKEEP  = NKEEP + NPUSH
        ENDIF
        NWDN   = (NCHR + 3) / 4
        NWDSN  = NWDSN + NWDN
        IPNT   = KOFUDB + LFIXDB + (NITEM - 1) * NWITM
        IQ(IPNT+1) = NLEV
        IQ(IPNT+2) = NODES(NLEV)
        IQ(IPNT+3) = NCHR
        IQ(IPNT+4) = NCHRT
        CALL UCTOH (PATHZ, IQ(IPNT+5), 4, 16)
        CALL UCTOH (PATHF, IQ(IPNT+9), 4, 80)
*
   50   NLEV   = NLEV - 1
        IF (NLEV.GE.1) THEN
          LUP    = LQ(KOFSDB+LCDRDB+1)
          CALL MZDROP (0, LCDRDB, ' ')
          LCDRDB = LUP
          NKEYDK = NKEY(NLEV)
          IOPTP  = IOPT(NLEV)
          GO TO 20
        ENDIF
      ENDIF
*
* *** All subdirectories looked at; now store dictionary if permitted
*
   60 IF (NLEVT.GT.0) THEN
        ND     = 3 + NWLEV*NLEVT + NWNOD*NITEM + NWDSN
        CALL DBBOOK (IDIVDB, LAD(1), LAD(1), 2, 'NAME', 0, 0, ND, 0, -1)
        IF (IQUEST(1).NE.0) THEN
          IERR   = IQUEST(1)
          CALL MZDROP (IDIVDB, LFIXDB, ' ')
          IQUEST(1) = IERR
          GO TO 100
        ENDIF
        IOFF   = KOFUDB + LAD(1)
        KPNTL  = 3
        IQ(IOFF+MPNLDB) = KPNTL
        IQ(IOFF+MNLVDB) = NLEVT
         Q(IOFF+MHFMDB) = 0.
        IQ(IOFF+KPNTL+MPPLDB) = 0
        DO 90 ILEV = 1, NLEVT
          KPNTN  = KPNTL + NWLEV
          NODET  = 0
          DO 80 IN = 1, NITEM
            IPNT   = KOFUDB + LFIXDB + (IN - 1) * NWITM
            IF (IQ(IPNT+1).NE.ILEV)       GO TO 80
            NODE   = IQ(IPNT+2)
            NCHR   = IQ(IPNT+3)
            NCHRT  = IQ(IPNT+4)
            CALL UHTOC (IQ(IPNT+5), 4, PATHX, 16)
            CALL UHTOC (IQ(IPNT+9), 4, PATHY, 80)
            PATHF  = PATHY(1:NCHRT)//'/'//PATHX
            NCHRP  = NCHRT + NCHR + 1
            IF (ILEV.EQ.1) THEN
              IUP    = 0
            ELSE
              DO 65 IM = 1, NITEM
                IPNT   = KOFUDB + LFIXDB + (IM - 1) * NWITM
                IF (IQ(IPNT+1).NE.ILEV-1) GO TO 65
                NCHRU  = IQ(IPNT+3)
                NCHRF  = IQ(IPNT+4)
                IF (NCHRT.EQ.NCHRU+NCHRF+1) THEN
                  CALL UHTOC (IQ(IPNT+5), 4, PATHZ, 16)
                  CALL UHTOC (IQ(IPNT+9), 4, PATHY, 80)
                  PATHY  = PATHY(1:NCHRF)//'/'//PATHZ
                  IF (PATHF(1:NCHRT).EQ.PATHY(1:NCHRT)) THEN
                    IUP    = IQ(IPNT+2)
                    GO TO 70
                  ENDIF
                ENDIF
   65         CONTINUE
            ENDIF
   70       NDOWN   = 0
            IF (ILEV.LT.NLEVT) THEN
              DO 75 IM = 1, NITEM
                IPNT   = KOFUDB + LFIXDB + (IM - 1) * NWITM
                IF (IQ(IPNT+1).NE.ILEV+1) GO TO 75
                NCHRU  = IQ(IPNT+4)
                IF (NCHRP.EQ.NCHRU) THEN
                  CALL UHTOC (IQ(IPNT+9), 4, PATHY, 80)
                  IF (PATHF(1:NCHRP).EQ.PATHY(1:NCHRP)) NDOWN = NDOWN +1
                ENDIF
   75         CONTINUE
            ENDIF
            NWDN   = (NCHR + 3) / 4
            NTOT   = NWDN + NWNOD
            NODET  = NODET + 1
            IPNTN  = KPNTN
            KPNTN  = IPNTN + NTOT
            IQ(IOFF+IPNTN+MPNLDB) = KPNTN
            IQ(IOFF+IPNTN+MNNUDB) = NODE
            IQ(IOFF+IPNTN+MNFNDB) = IUP
            IQ(IOFF+IPNTN+MNDWDB) = NDOWN
            IQ(IOFF+IPNTN+MNCHDB) = NCHR
             Q(IOFF+IPNTN+MYFNDB) = 0.
            CALL UCTOH (PATHX, IQ(IOFF+IPNTN+MNAMDB), 4, NCHR)
   80     CONTINUE
          IPNTL  = KPNTL
          KPNTL  = KPNTN
          IQ(IOFF+IPNTN+MPNLDB) = 0
          IQ(IOFF+IPNTL+MLEVDB) = ILEV
          IQ(IOFF+IPNTL+MNODDB) = NODET
           Q(IOFF+IPNTL+MXOFDB) = 0.
           Q(IOFF+IPNTL+MXWDDB) = 0.
           Q(IOFF+IPNTL+MYFLDB) = 0.
          IF (ILEV.LT.NLEVT) IQ(IOFF+KPNTL+MPPLDB) = IPNTL
          IF (NODET.GT.0) THEN
            IQ(IOFF+IPNTL+MPNNDB) = IPNTL + NWLEV
            IQ(IOFF+IPNTL+MPNLDB) = KPNTL
          ELSE
            IQ(IOFF+IPNTL+MPNNDB) = 0
            IQ(IOFF+IPNTL+MPNLDB) = KPNTL
          ENDIF
   90   CONTINUE
        IQ(IOFF+IPNTL+MPNLDB) = 0
      ENDIF
      IF (LFIXDB.GT.0) CALL MZDROP (IDIVDB, LFIXDB, ' ')
*
      IQUEST(1) = 0
  100 IERR   = IQUEST(1)
      CALL RZCDIR (PATHD, ' ')
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      IQUEST(1) = IERR
*                                                             END DBFPAT
  999 END
+DECK, DBFRST.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBFRST (IDIV)
*     ========================
*
************************************************************************
*                                                                      *
*        SUBR. DBFRST (IDIV)                                           *
*                                                                      *
*   Initializes of the Data Base Package (for each file)               *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDIV     User Division                                           *
*                                                                      *
*   Called by DBINIT                                                   *
*                                                                      *
************************************************************************
*
      PARAMETER       (MNSYS = 10000)
*
*             ZEBRA system common blocks
*
+CDE, ZUNIT.
+CDE, MZCB.
+CDE, MZCC.
      COMMON /ZEBQ/  IQFENC(4), LQZEB(100)
*
+CDE, DAOPTI.
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DSAVBK.
+CDE, P3DBL3, IF=$P3CHILD.
      CHARACTER       CHFOR*9, CHTAG(NINEDK)*8, CHFRM*20
      CHARACTER       CHNAM*62
*
      DATA            CHFOR /'IIIIIIIII'/
      DATA            CHTAG /'SERIAL_#', 'POINTER ', 'STR_VALI',
     +                       'END_VALI', 'PRG_VERS', 'FLAGS   ',
     +                       'INS_TIME', 'KEY 8   ', 'KEY 9   '/
      DATA            CHNAM
     +/'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz'/
*
*     ------------------------------------------------------------------
*
* *** DB System initialization
*
      LPRTDB = IQPRNT
      IDIVDB = IDIV
      IDEBDB = 0
      LQST   = LOCF(LQ(1)) - 1
      LQZB   = LQST + 1 - LOCF(LQZEB(1))
      CALL MZSDIV (0, -1)
      KOFSDB = KQS - LQZB
      CALL MZSDIV (IDIVDB, -1)
      KOFUDB = KQS - LQZB
      MXSYS  = 4*NQDMAX(KQT+1)/5
      CALL MZDIV  (IDIVDB, IDISDB, 'DB-SYSTM', MNSYS, MXSYS, 'LC')
      CALL MZLINK (IDIVDB, '/DLINKS/', LSTRDL(1), LSTRDL(1),
     +             LREFDL(10))
      CALL MZLINK (IDIVDB, '/DBUSER/', LBADDB, LBDADB, LTOPDB)
      CALL MZLINK (IDISDB, '/DSAVBK/', LOBJDS(1), LOBJDS(1),
     +             LOBJDS(NSVMDS))
      CALL MZLINK (0, '/DBSTOR/', LCDRDB, LCDRDB, LJNKDB)
*
* *** Initialize the IO descriptors
*
      ICHR0  = ICHAR ('0')
      CHFRM  = '4I '//CHAR(NWNODB/10+ICHR0)//
     +                CHAR(MOD(NWNODB,10)+ICHR0)//'B -H'
      CALL MZFORM ('NODB', CHFRM, IONODB)
      CALL MZFORM ('UPDB', '8I -H', IUPDB)
      CALL MZFORM ('DIDB', '1I / 3I 22H', IODIDB)
      CALL UCTOH  ('KYDB', IHKYDB, 4, 4)
      CHFRM  = CHAR(MFZDIR+ICHR0-1)//'H / 1I 20H'
      CALL MZFORM ('FZDB', CHFRM, IOFZDB)
      CALL MZFORM ('FDDB', '/ 1I 20H', IOFDDB)
*
      INSRDB = 0
      KY7MDB = 0
      NTOPDB = 0
      CALL DBPKTS (991231, 235959, IBIGDB)
*
      NUFZDF = 0
      KEY7DK = 0
      CHFTDK = CHFOR
      DO 10 I = 1, 9
   10 CHTGDK(I) = CHTAG(I)
*
      DO 15 K = 1, 62
   15 CALFDA(K) = CHNAM(K:K)
      CALL VZERO (IOPADA, MXKYDA+26)
      MPAKDA(1) = 8
      MPAKDA(2) = 4
+SELF, IF=APOLLO,CRAY,HPUX,IBM,IBMRT,VAX.
      CSTRDA( 32: 47) = ' !"#$%&''()*+,-./'
+SELF, IF=MIP.
      CSTRDA( 32: 47) = '  "#$%&''()*+,-./'
      CSTRDA( 33: 33) = '21'X
+SELF.
      CSTRDA( 48: 57) = '0123456789'
      CSTRDA( 58: 64) = ':;<=>?@'
      CSTRDA( 65: 90) = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+SELF, IF=APOLLO,CRAY,IBM,VAX.
      CSTRDA( 91: 96) = '[\]^_`'
+SELF, IF=HPUX.
      CSTRDA( 91: 96) = '[ ]^_`'
      CSTRDA( 92: 92) = CHAR(92)
+SELF, IF=IBMRT,MIP.
      CSTRDA( 91: 96) = '[\\]^_`'
+SELF.
      CSTRDA( 97:122) = 'abcdefghijklmnopqrstuvwxyz'
      CSTRDA(123:126) = '{|}~'
*
      TOPLDI = ' '
+SELF, IF=$P3CHILD.
*
      NWDBP3 = 0
      LIDBP3 = 0
      LODBP3 = 0
      IXDBP3 = IDIVDB
      CALL MZLINK (IXDBP3, '/P3DBL3/', LNK1P3, LNK1P3, LNK9P3)
      IPASP3 = 0
      NDIRP3 = 0
      NBKDP3 = 0
      NBKYP3 = 0
      INDXP3 = 1
      CALL MZBOOK (IDISDB, LNK1P3, 0, 2, 'DBP3',   0, 0, 122, 2, 0)
      CALL MZBOOK (IXDBP3, LNK2P3, 0, 2, 'P3LK', 100, 0, 100, 2, 0)
+SELF.
*                                                             END DBFRST
      END
+DECK, DBFRUS.
      SUBROUTINE DBFRUS (LC, LU, IPREC)
*     =================================
*
************************************************************************
*                                                                      *
*        SUBR. DBFRUS (LC, LU*, IPREC)                                 *
*                                                                      *
*   Copies bank of LC from the user system to bank at LU of the Data   *
*   Base internal system (where 1st word = 0, 2nd word = IPREC)        *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LC       Address of the input bank                               *
*     LU(*)    Address of the output bank                              *
*     IPREC    Signed precision word; the data are truncated after     *
*              having multiplied by 10**IPREC                          *
*                                                                      *
*   Called by DBENTB, DBNTOP, DBENFZ, DBKOUT                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 92 : Nonstandard IO descriptor                       *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DZPACK.
      DIMENSION       LC(9), LU(9)
*
*     ------------------------------------------------------------------
*
      LREFDB(4) = LC(1)
      NDU    = IQ(KOFUDB+LREFDB(4)-1) + 2
      ITU    = IDBTYP (LREFDB(4))
      IF (ITU.NE.2 .AND. ITU.NE.3 .AND. ITU.NE.5) THEN
        IQUEST(1) = 92
        IQUEST(11)= ITU
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFRUS : Illegal'//
     +  ' Data-type '',I5,/)', IQUEST(11), 1)
+SELF.
        GO TO 999
      ENDIF
      JBIAS  = 2
      CALL DBBOOK (IDISDB, LU(1), LU(1), JBIAS, 'BASE', 0, 0, NDU, ITU,
     +             0)
      IF (IQUEST(1).NE.0) GO TO 999
      IF (ITU.EQ.3) THEN
        CALL UCOPY (Q(KOFUDB+LREFDB(4)+1), Q(KOFUDB+LU(1)+3), NDU-2)
        Q (KOFUDB+LU(1)+1) = 0.
        IF (PACKDZ) THEN
          Q (KOFUDB+LU(1)+2) = 0.
        ELSE
          Q (KOFUDB+LU(1)+2) = IPREC
        ENDIF
      ELSE IF (ITU.EQ.2) THEN
        CALL UCOPY (IQ(KOFUDB+LREFDB(4)+1), IQ(KOFUDB+LU(1)+3), NDU-2)
        IQ(KOFUDB+LU(1)+1) = 0
        IF (PACKDZ) THEN
          IQ(KOFUDB+LU(1)+2) = 0
        ELSE
          IQ(KOFUDB+LU(1)+2) = IPREC
        ENDIF
      ELSE IF (ITU.EQ.5) THEN
        CALL UCOPY (IQ(KOFUDB+LREFDB(4)+1), IQ(KOFUDB+LU(1)+3), NDU-2)
        IQ(KOFUDB+LU(1)+1) = 0
        IQ(KOFUDB+LU(1)+2) = 0
      ENDIF
*                                                             END DBFRUS
  999 END
+DECK, DBFZIN.
      SUBROUTINE DBFZIN (AI, NDI, AO, NDO, EPSIL, IER)
*     ================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBFZIN (AI, NDI, AO*, NDO*, EPSIL, IER*)                *
*                                                                      *
*   Compress floating point data (only nonzero elements are stored).   *
*   Data are set to 0 if their absolute value is less than EPSIL       *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     AI       Input array to be compressed                            *
*     NDI      Number of elements in AI                                *
*     AO(*)    Output array of the nonzero elements                    *
*     NDO(*)   Number of elements in AO                                *
*     EPSIL    Cutoff value                                            *
*     IER(*)   Error Code : 0    No error                              *
*                           1    NDO .ge. NDI                          *
*                                                                      *
*   Called by DBCMPZ                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IER       =  0 : No error (see above)                            *
*                                                                      *
************************************************************************
*
      DIMENSION       AI(NDI), AO(NDI)
*
*     ------------------------------------------------------------------
*
      IER    = 0
*
      NDO    = 0
      DO 10 I = 1, NDI
        IF (ABS(AI(I)).LE.EPSIL) GO TO 10
        NDO    = NDO + 1
        IF (NDO.GE.NDI) THEN
          IER    = 1
          GO TO 999
        ENDIF
        AO(NDO) = I
        NDO    = NDO + 1
        IF (NDO.GE.NDI) THEN
          IER    = 1
          GO TO 999
        ENDIF
        AO(NDO) = AI(I)
   10 CONTINUE
*                                                             END DBFZIN
  999 END
+DECK, DBFZWR.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBFZWR (IPREC, CHOPT)
*     ================================
*
************************************************************************
*                                                                      *
*        SUBR. DBFZWR (IPREC, CHOPT)                                   *
*                                                                      *
*   Copies the current data structure in memory into the journal file  *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IPREC    Precision word used in the packing algorithm            *
*     CHOPT    Character string to be written in the journal file      *
*                                                                      *
*   Called by DBRTFZ                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 76 : Cannot form the IO descriptor for the FZ header *
*               = 77 : FZOUT fails to write on to the sequential file  *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DKKEYS.
+CDE, DSAVBK.
+CDE, DZPACK.
      PARAMETER       (NLEVM=20)
      INTEGER         NLCUR(NLEVM)
      CHARACTER       CHCUR(NLEVM)*1, CHFRM*100, CFORM(6)*1, CHOP0*4
      CHARACTER       CHOPT*(*)
      DATA            CFORM /'B', 'I', 'F', 'D', 'H', 'A'/
*
*     ------------------------------------------------------------------
*
* *** Write the sequential output if needed
*
      IF (IOPFDA.EQ.0) THEN
        CHOP0  = CHOPT
      ELSE
        CHOP0  = 'F'//CHOPT
      ENDIF
*
*  ** Find the IO descriptor of the header
*
      NLEV   = 1
      NCUR   = 5
      IFORO  = 2
      CHCUR(NLEV) = CFORM(IFORO)
      IF (INDEX(CHOP0,'Z').NE.0) THEN
        NLCUR(NLEV) = 4
        IFORO  = 3
        NCUR   = 1
        NLEV   = NLEV + 1
        CHCUR(NLEV) = CFORM(IFORO)
        CALL UCOPY (PRECDZ, IHEADF(MPREDF), 1)
      ELSE
        IHEADF(MPREDF) = IPREC
      ENDIF
      DO 10 I = 1, NWKYDK
        IFORM  = IOTYDK(I)
        IF (IFORM.EQ.6) IFORM = 5
        IF (IFORM.EQ.IFORO) THEN
          NCUR   = NCUR + 1
        ELSE
          NLCUR(NLEV) = NCUR
          IF (NLEV.GE.NLEVM) THEN
            IQUEST(1) = 76
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZWR : Can'//
     +      'not get IO descriptor '')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          NLEV   = NLEV + 1
          CHCUR(NLEV) = CFORM(IFORM)
          NCUR   = 1
          IFORO  = IFORM
        ENDIF
   10 CONTINUE
      NLCUR(NLEV) = NCUR
+SELF, IF=-IBM, -$P3CHILD.
      WRITE (CHFRM, 2001) (NLCUR(I), CHCUR(I), I = 1, NLEV)
+SELF, IF=IBM, IF=$P3CHILD.
      CHFRM = ' '
      II    = 1
      DO 11 I = 1, NLEV
        CALL UTWRIT (CHFRM(II:II+1), '(I2)', NLCUR(I))
        II     = II + 2
        CHFRM(II:II) = CHCUR(I)
        II     = II + 2
   11 CONTINUE
+SELF.
      II     = 4 *NLEV
      CHFRM = CHFRM(1:II)//' -H'
      CALL MZIOCH (IOFMDF, NWFMDF, CHFRM(1:II+3))
*
*  ** Write on the FZ file
*
      CALL UCTOH (CHOP0, IHEADF(MPREDF+NWKYDK+1), 4, 4)
      CALL UCOPY (KEYSDS(1,1), IHEADF(MPREDF+1), NWKYDK)
      CALL FZOUT (LUFZDF, IDISDB, LOBJDS(1), 1, 'L', IOFMDF,
     +            NWHEDF, IHEADF)
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1)  = 77
        IQUEST(11) = 1
        IQUEST(12) = 1
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBFZWR : Error '//
     +  'in FZOUT while writing Data'')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
+SELF, IF=-IBM, -$P3CHILD.
*
 2001 FORMAT (20(I2,A1,1X))
+SELF.
*                                                             END DBFZWR
  999 END
+DECK, DBGNAM.
      SUBROUTINE DBGNAM (PATH, CHTAG, IOBJ)
*     =====================================
*
************************************************************************
*                                                                      *
*        SUBR. DBGNAM (PATH, CHTAG, IOBJ*)                             *
*                                                                      *
*   Identifies the object element number from its name and the name    *
*   of the directory path name                                         *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATH     Character string describing the pathname                *
*     CHTAG    Name of the data element                                *
*     IOBJ(*)  Object element number (0 if not found)                  *
*                                                                      *
*   Called by DBACPL                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =182 : Illegal path name                               *
*               =201 : DICTIONARY directory not found                  *
*               =202 : No description of data elements for the given   *
*                      path name exists in the data base               *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
      CHARACTER       PATHN*80, CTAG*8, TOPN*16, PATHD*32, PATH*(*)
      CHARACTER       CHTAG*(*)
*
*     ------------------------------------------------------------------
*
* *** See if the path name is correct
*
      IOBJ   = 0
      CALL DBSBLC (PATH, PATHN, NCHAR)
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 182
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGNAM : Illegal'//
     +  ' path name '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL RZCDIR (PATHN, 'R')
      NCHAR  = LENOCC (PATHN)
      CALL DBGPID (PATHN, NCHAR, TOPN, IDN)
      IF (IDN.LE.0) THEN
        IQUEST(1) = 182
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGNAM : Illegal'//
     +  ' path name '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Set the current directory to DICTIONARY and retrieve object
*
      NCH    = LENOCC (TOPN)
      PATHD  = '//'//TOPN(1:NCH)//'/DICTIONARY'
      CALL RZCDIR (PATHD, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 201
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGNAM : Path na'//
     +  'me '//PATHD(1:NCH)//' not found'')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKEYT
      ISTP   = NWKYDK + 1
      IPNT   = KOFSDB + LCDRDB + IKDRDB
      KPNT   = IUHUNT (IDN, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)
      IF (KPNT.LE.0) THEN
        IQUEST(1) = 202
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGNAM : No info'//
     +  'rmation for '//PATHN(1:NCHAR)//' inside Data Base'')',IARGDB,0)
+SELF.
        GO TO 999
      ENDIF
      KEY1S  = (KPNT - MSERDB) / ISTP + 1
      CALL VZERO (KEYVDK, NWKYDK)
      KEYVDK(1) = KEY1S
      IF (LSTRDL(1).NE.0) THEN
        CALL MZDROP (IDISDB, LSTRDL(1), 'L')
        LSTRDL(1) = 0
      ENDIF
      IOLD1  = IOKYDA(MSERDB)
      IOLDK  = IOPKDA
      IOPKDA = 0
      IOKYDA(MSERDB) = 1
      ITIME  = 1
      CALL DBKXIN (ITIME, IDISDB, LSTRDL(1), LSTRDL(1), 2, NWKYDK,
     +             KEYVDK, IPREC)
      IER    = IQUEST(1)
      IOPKDA = IOLDK
      IOKYDA(MSERDB) = IOLD1
      IF (IER.NE.0) THEN
        CALL MZDROP (IDISDB, LSTRDL(1), 'L')
        IQUEST(1) = IER
        GO TO 999
      ENDIF
*
* *** Now store the information in the user array
*
      IPNT   = KOFUDB + LSTRDL(1)
      NWDS   = IQ(IPNT-1) / 2
      DO 10 I = 1, NWDS
        CALL UHTOC (IQ(IPNT+1), 4, CTAG, 8)
        IF (CTAG.EQ.CHTAG) THEN
          IOBJ   = I
          GO TO 20
        ENDIF
        IPNT   = IPNT + 2
   10 CONTINUE
   20 CALL MZDROP (IDISDB, LSTRDL(1), 'L')
      LSTRDL(1) = 0
      IQUEST(1) = 0
*                                                             END DBGNAM
  999 END
+DECK, DBGPID.
      SUBROUTINE DBGPID (PATH, NCHAR, TOPN, IDN)
*     ==========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBGPID (PATH, NCHAR, TOPN*, IDN*)                       *
*                                                                      *
*   Finds the unique directory identifier from the path name           *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATH     Character string describing the pathname                *
*     NCHAR    Number of characters in PATH                            *
*     TOPN(*)  Name of the top directory                               *
*     IDN(*)   Unique directory identifier                             *
*                                                                      *
*   Called by DBEALI, DBEHLP, DBENAM, DBRHLP, DBRNAM, DBGNAM           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IDN       >  0 : No error                                        *
*               =  0 : No dictionary for directory identifier          *
*               <  0 : Illegal path name                               *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DINITL.
      CHARACTER       PATHY*80, PATHZ*80, TOPN*(*), PATH*(*)
*
*     ------------------------------------------------------------------
*
* *** Extract the top directory and the trailing part from the path name
*
      IF (NCHAR.LT.3.OR.PATH(1:2).NE.'//') GO TO 999
      NCHRT  = INDEX (PATH(3:NCHAR), '/') - 1
      IF (NCHRT.LE.0) NCHRT = NCHAR - 2
      TOPN   = PATH(3:NCHRT+2)
      IDN    = -1
      NCHF   = NCHRT + 2
      IF (NCHAR.LE.NCHF)                   GO TO 999
      PATHY  = PATH(NCHF+1:NCHAR)
      NCHR   = NCHAR - NCHF
      IDN    = 0
*
* *** Find the appropriate dictionary for the directory path name
*
      LTOP   = LTOPDB
   10 IF (LTOP.NE.0) THEN
        NCH    = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCH)
        TOPNDI = TOPNDI(1:NCH)
        IF (TOPN.NE.TOPNDI) THEN
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 10
        ENDIF
      ELSE
        GO TO 999
      ENDIF
      LDIC   = LQ(KOFUDB+LTOP-KLDICT)
      IF (LDIC.LE.0)                       GO TO 999
      NITEM  = IQ(KOFUDB+LDIC+MDCNTM)
*
* *** Look the current path in the dictionary
*
      DO 20 ITEM = 1, NITEM
        IPNT   = KOFUDB + LDIC + (ITEM - 1) * NWITDB + 1
        IF (IQ(IPNT+MDCITM).GT.0) THEN
          IF (NCHR.EQ.IQ(IPNT+MDCNCH)) THEN
            CALL UHTOC (IQ(IPNT+MDCNAM), 4, PATHZ, NCHR)
            IF (PATHZ(1:NCHR).EQ.PATHY(1:NCHR)) THEN
              IDN    = IQ(IPNT+MDCITM)
              GO TO 999
            ENDIF
          ENDIF
        ENDIF
   20 CONTINUE
*                                                             END DBGPID
  999 END
+DECK, DBHUNT.
      SUBROUTINE DBHUNT (KEYV)
*     ========================
*
************************************************************************
*                                                                      *
*        SUBR. DBHUNT (KEYV*)                                          *
*                                                                      *
*   Returns the key elements of an object with matching user keys as   *
*   in KEYVDK and with Key(2) = 0 (not updated)                        *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     KEYV(*)  Key vector found (if none found, set KEYV(1) = 0)       *
*                                                                      *
*   Called by DBDONT                                                   *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
      DIMENSION       KEYV(9)
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Look at all the keys in the subdirectory
*
      DO 20 IK1 = 1, NKEYDK
        IK     = NKEYDK - IK1 + 1
        CALL DBKEYR (IK, NWKYDK, KEYV)
*
        IF (KEYV(MUPNDB).NE.0)              GO TO 20
        IF (KEYV(MPVSDB).NE.KEYVDK(MPVSDB)) GO TO 20
        DO 10 I = NSYSDK+1, NWKYDK
          IF (KEYV(I).NE.KEYVDK(I))         GO TO 20
   10   CONTINUE
        IF (JBIT(KEYV(MFLGDB),JRZUDB).EQ.0) GO TO 20
        GO TO 999
   20 CONTINUE
      KEYV(1) = 0
*                                                             END DBHUNT
  999 END
+DECK, DBIFCH.
      SUBROUTINE DBIFCH (CH, I)
*     =========================
*
************************************************************************
*                                                                      *
*        SUBR. DBIFCH (CH, I*)                                         *
*                                                                      *
*   Converts single character CH (of type character) to an output      *
*   integer I via the look-up table stored in CSTRDA                   *
*   (Adapted from CHTOI from CERN Library)                             *
*                                                                      *
*   Called by DBLINC                                                   *
*                                                                      *
************************************************************************
*
+CDE, DAOPTI.
      CHARACTER       CH*1
*     ------------------------------------------------------------------
*
      I = INDEX (CSTRDA(32:126), CH)
      I = I + 31
*                                                             END DBIFCH
      END
+DECK, DBIFRC.
      SUBROUTINE DBIFRC (CH, IAR, NWD, NCH)
*     =====================================
*
************************************************************************
*                                                                      *
*        SUBR. DBIFRC (CH, IAR*, NWD, NCH)                             *
*                                                                      *
*   Converts character string CH (of type character and NCH long)      *
*   to an output integer array IAR (of length NWD) via the look-up     *
*   table stored in CSTRDA                                             *
*                                                                      *
*   Called by DBLINC                                                   *
*                                                                      *
************************************************************************
*
+CDE, DAOPTI.
      CHARACTER       CH*(*)
      DIMENSION       IAR(9), IB(4)
*     ------------------------------------------------------------------
*
      DO 10 J = 1, NWD
        K   = 4*J - 4
        DO 5 L = 1, 4
          IF (K+L.LE.NCH) THEN
            I = INDEX (CSTRDA(32:126), CH(K+L:K+L))
            IB(L) = I + 31
          ELSE
            IB(L) = 31
          ENDIF
    5   CONTINUE
        CALL PKBYT (IB, IAR(J), 1, 4, MPAKDA)
   10 CONTINUE
*                                                             END DBIFRC
  999 END
+DECK, DBININ.
      SUBROUTINE DBININ (IA1, IA2, N, IPREC, IER)
*     ===========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBININ (IA1, IA2*, N, IPREC, IER*)                      *
*                                                                      *
*   Truncates integer to signed integer according to the given         *
*   precision                                                          *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IA1      Input array of integer numbers                          *
*     IA2(*)   Output array of signed integers                         *
*     N        Length of the array                                     *
*     IPREC    Signed precision word; the data are truncated after     *
*              having multiplied by 10**IPREC                          *
*     IER(*)   Error Code : 0    No error                              *
*                           1    Precision not given or not correct    *
*                           3    Data is not uncompressed              *
*                                                                      *
*   Called by DBCMPR                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IER       =  0 : No error (see above)                            *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
      DIMENSION       IA1(N), IA2(N)
*
*     ------------------------------------------------------------------
*
      IER    = 0
*
* *** Is data uncompressed ?
*
      IF (IA1(1).NE.0) THEN
        IER    = 3
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBININ : Data is'//
     +  ' not uncompressed - no compression'')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Precision ?
*
      IPREC  = IA1(2)
*
      IF (IPREC.GT.0) THEN
        IER    = 1
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBININ : Precisi'//
     +  'on is not correctly given - no compression'')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      IPR1   = -IPREC
*
      IF (IPR1.EQ.0) THEN
        CALL UCOPY (IA1, IA2, N)
        GO TO 999
      ENDIF
      XMULT  = 1./10**IPR1
      DO 10 I = 3, N
   10 IA2(I) = IA1(I)*XMULT
      IA2(1) = IA1(1)
      IA2(2) = IA1(2)
*                                                             END DBININ
  999 END
+DECK, DBIZIN.
      SUBROUTINE DBIZIN (IAI, NDI, IAO, NDO, EPSIL, IER)
*     ==================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBIZIN (IAI, NDI, IAO*, NDO*, EPSIL, IER*)              *
*                                                                      *
*   Compress integer data (only nonzero elements are stored).          *
*   Data are set to 0 if their absolute value is less than EPSIL       *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IAI      Input array to be compressed                            *
*     NDI      Number of elements in IAI                               *
*     IAO(*)   Output array of the nonzero elements                    *
*     NDO(*)   Number of elements in IAO                               *
*     EPSIL    Cutoff value                                            *
*     IER(*)   Error Code : 0    No error                              *
*                           1    NDO .ge. NDI                          *
*                                                                      *
*   Called by DBCMPZ                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IER       =  0 : No error (see above)                            *
*                                                                      *
************************************************************************
*
      DIMENSION       IAI(NDI), IAO(NDI)
*
*     ------------------------------------------------------------------
*
      IER    = 0
      IEPSI  = EPSIL
*
      NDO    = 0
      DO 10 I = 1, NDI
        IF (IABS(IAI(I)).LE.IEPSI) GO TO 10
        NDO    = NDO + 1
        IF (NDO.GE.NDI) THEN
          IER    = 1
          GO TO 999
        ENDIF
        IAO(NDO) = I
        NDO    = NDO + 1
        IF (NDO.GE.NDI) THEN
          IER    = 1
          GO TO 999
        ENDIF
        IAO(NDO) = IAI(I)
   10 CONTINUE
*                                                             END DBIZIN
  999 END
+DECK, DBKEYR.
      SUBROUTINE DBKEYR (IKEY, NWKEY, KEY)
*     ====================================
*
************************************************************************
*                                                                      *
*        SUBR. DBKEYR (IKEY, NWKEY, KEY*)                              *
*                                                                      *
*   Loads the Key vector in the array KEY                              *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IKEY     Index of the key                                        *
*     NWKEY    Number of key elements to be fetched                    *
*     KEY(*)   The Key vector which will contain the Key elements      *
*              for key IKEY on output                                  *
*                                                                      *
*   Called by DBDLET, DBEALI, DBENTB, DBGET,  DBGETS, DBNTOP, DBPRGD,  *
*             DBPURG, DBRENK, DBCDIC, DBCHCK, DBCHKY, DBCOMP, DBDELK,  *
*             DBENFZ, DBKOUT, DBKXIN, DBKYSE, DBPRDT, DBSEKY, DBSNAM,  *
*             DBUDIC, DBUNCP, DBPLNT, DBPLOB, DBPLOV, DBPLTI           *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
      DIMENSION       KEY(9)
*
*     ------------------------------------------------------------------
* *** Retrieve the keys
*
      ISTP   = NWKYDK + 1
      IPNT   = KOFSDB + LCDRDB + IKDRDB + (IKEY - 1) * ISTP
      DO 10 I = 1, NWKEY
        IF (IOTYDK(I).EQ.5 .OR. IOTYDK(I).EQ.6)  THEN
          CALL ZITOH (IQ(IPNT+I), KEY(I), 1)
        ELSE
          KEY(I) = IQ(IPNT+I)
        ENDIF
   10 CONTINUE
*                                                             END DBKEYR
  999 END
+DECK, DBKEYS.
      SUBROUTINE DBKEYS (LBN, KEYS, LBK, ITIME)
*     =========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBKEYS (LBN, KEYS, LBK*, ITIME)                         *
*                                                                      *
*   Creates or completes the Key banks supported as next of same type  *
*   to the Node bank                                                   *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LBN      L-address of the Node bank                              *
*     KEYS     Vector of keys                                          *
*     LBK(*)   Address(es) of Keys bank(s) KYDB                        *
*     ITIME    Time for which the valid keys are required              *
*              (in option S)                                           *
*                                                                      *
*   Called by DBABRD, DBABWR, DBENTR, DBPURK, DBREPL, DBUSE            *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 21 : Too many keys with option M                     *
*               = 22 : Illegal key option                              *
*               = 23 : Key bank cannot be created; no space in memory  *
*               = 24 : No Key bank created satisfying key options for  *
*                      option S                                        *
*               = 25 : Illegal Path Name                               *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DMULOP.
+CDE, DTKXIN.
      PARAMETER       (NZ=0)
      DIMENSION       LBN(9), KEYS(9), LBK(9)
      CHARACTER       PATH*80, PATHN*80, PATHX*16
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
      LREFDB(2) = LBN(1)
      IQUEST(1) = 0
      NCHR   = IQ(KOFUDB+LREFDB(2)+MNDNCH)
      CALL UHTOC (IQ(KOFUDB+LREFDB(2)+MNDNAM), 4, PATH, NCHR)
      PATH   = PATH(1:NCHR)
      NCHRT  = INDEX (PATH(3:NCHR), '/') - 1
      IF (NCHRT.LE.0) NCHRT = NCHR - 2
      PATHX  = PATH(3:NCHRT+2)
      LBFXDB = LTOPDB
    5 IF (LBFXDB.NE.0) THEN
        NCHRT  = IQ(KOFUDB+LBFXDB+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LBFXDB+MUPNAM), 4, TOPNDI, NCHRT)
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN
          LBFXDB = LQ(KOFUDB+LBFXDB)
          GO TO 5
        ENDIF
        KY7MDB = IQ(KOFUDB+LBFXDB+MUPKY7)
      ELSE
        KY7MDB = 0
      ENDIF
      IF (IOPSDA.NE.0)                                      GO TO 70
*
* *** Get number of key banks needed
*
      NMUL   = 0
      NKYMX  = 1
      ISTKY  = NWKYDK
      IF (IOPMDA.NE.0)  THEN
        IF (NWKYDK.GT.NSYSDK)  THEN
          DO 10 I = NSYSDK+1, NWKYDK
            IF (IOKYDA(I).NE.0) THEN
              IF (NMUL.GE.NMLMDM)  THEN
*
*  **           Too many keys with option M
*
                IQUEST(1)  = 21
                IQUEST(11) = NMLMDM + 1
                IQUEST(12) = I
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEYS :'//
     +          ' Too many keys '',I3,'' with M option - Last Key'',I3)'
     +,         IQUEST(11), 2)
+SELF.
                GO TO 999
              ENDIF
*
              IF (KEYS(I).LE.0)  THEN
*
*  **           Illegal key option
*
                IQUEST(1)  = 22
                IQUEST(11) = I
                IQUEST(12) = KEYS(I)
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) THEN
                  IARGDB(1) = IQUEST(12)
                  IARGDB(2) = IQUEST(11)
                  CALL DBPRNT (LPRTDB, '(/,'' DBKEYS : Illegal key op'//
     +                 'tion '',I3,'' for key '',I3,'' with option M'')'
     +,                IARGDB, 2)
                ENDIF
+SELF.
                GO TO 999
              ENDIF
*
*  **         Build up the array of keys used for option M
*
              NMUL   = NMUL + 1
              NOCCDM(NMUL) = KEYS(I)
              LFKYDM(NMUL) = ISTKY
              KTYPDM(NMUL) = I
              ISTKY  = ISTKY + KEYS(I)
              NKYMX  = NKYMX * KEYS(I)
            ENDIF
   10     CONTINUE
        ENDIF
      ENDIF
*
* *** Loop over all possible Key Banks
*
      NK     = 0
   15 NK     = NK + 1
*
*  ** For option 'M', find the corresponding key values
*
      IF (NMUL.GT.0)  THEN
        DO 25 I = 1, NMUL
          NK0    = NK
          IF (I.NE.1)  THEN
            DO 20 J = 1, I-1
              NK0    = (NK0 - INDXDM(J)) / NOCCDM(J) + 1
   20       CONTINUE
          ENDIF
          NK0    = MOD (NK0, NOCCDM(I))
          IF (NK0.EQ.0) NK0 = NOCCDM(I)
          INDXDM(I) = NK0
          KEYVDM(I) = KEYS(LFKYDM(I)+NK0)
   25   CONTINUE
      ENDIF
*
*  ** Check if this Key bank already exists
*
      LSAVDB = LREFDB(2)
      JBIAS  = -KLKYDB
      ND     = IQ(KOFUDB+LSAVDB+MNDNWD)
      LBKYDB = LQ(KOFUDB+LSAVDB-KLKYDB)
   30 IF (LBKYDB.NE.0)  THEN
        IF (NWKYDK.GT.NSYSDK)  THEN
          IF (NMUL.EQ.0)  THEN
            DO 35 I = NSYSDK+1, NWKYDK
              IF (IOKYDA(I).NE.0)  THEN
                IF (KEYS(I).NE.IQ(KOFUDB+LBKYDB+I))         GO TO 45
              ENDIF
   35       CONTINUE
            GO TO 50
          ELSE
            DO 40 I = 1, NMUL
              NU     = KTYPDM(I)
              IF (KEYVDM(I).NE.IQ(KOFUDB+LBKYDB+NU))        GO TO 45
   40       CONTINUE
            GO TO 50
          ENDIF
        ELSE
          GO TO 50
        ENDIF
   45   LSAVDB = LBKYDB
        LBKYDB = LQ(KOFUDB+LSAVDB)
        JBIAS  = 0
        GO TO 30
      ELSE
*
*  *    The Key bank does not exist, create it
*
        CALL UCOPY  (IQ(KOFUDB+LREFDB(2)+MNDIOF), IOKYDB, NWNODB)
        CALL DBBOOK (IDIVDB, LBKYDB, LSAVDB, JBIAS, 'KYDB', NLKYDB,
     +               NSKYDB, ND, IOKYDB, NZ)
        IF (IQUEST(1).NE.0)  THEN
          IQUEST(1) = 23
          IQUEST(11)= NK
          IQUEST(12)= NKYMX
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEYS : No sp'//
     +    'ace in memory to create Key bank '',I3,'' out of '',I3)',
     +    IQUEST(11), 2)
+SELF.
          GO TO 999
        ENDIF
        LQ(KOFUDB+LBKYDB-KLNODB) = LREFDB(2)
        LQ(KOFUDB+LBKYDB-KLUPDB) = LBFXDB
      ENDIF
*
* *** Copy the key vector into Key bank
*
   50 LBK(NK) = LBKYDB
      DO 55 I = 1, NSYSDK
        IF (IOKYDA(I).NE.0) IQ(KOFUDB+LBKYDB+I) = KEYS(I)
   55 CONTINUE
      IF (NWKYDK.GT.NSYSDK)  THEN
        IF (NMUL.EQ.0)  THEN
          DO 60 I = NSYSDK+1, NWKYDK
            IF (IOKYDA(I).NE.0) IQ(KOFUDB+LBKYDB+I) = KEYS(I)
   60     CONTINUE
        ELSE
          DO 65 I = 1, NMUL
            NU     = KTYPDM(I)
            IQ(KOFUDB+LBKYDB+NU) = KEYVDM(I)
   65     CONTINUE
        ENDIF
      ENDIF
*
      IF (NK.LT.NKYMX)                                      GO TO 15
      GO TO 999
*
* *** 'S' option
*
   70 LFIXDB = LREFDB(2)
*
*  ** Start from the end of the existing chain
*
      IF (LQ(KOFUDB+LFIXDB-KLKYDB).NE.0) THEN
        LBKYDB = LZLAST (IDIVDB, LQ(KOFUDB+LFIXDB-KLKYDB))
        IF (LBKYDB.NE.0) LFIXDB = LBKYDB
      ENDIF
*
*  ** Loop over all keys
*
      IF (NKEYDK.LE.0)  THEN
        IQUEST(1) = 24
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEYS : No comp'//
     +  'atible object for specified options'')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      LSAVDB = LFIXDB
      CALL DBKEYT
      IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)
      IOPTP  = JBIT (IOPTP, JPRTDB)
      KY4MDB = IBIGDB
*
      IF (IOPTP.EQ.0)  THEN
        CALL DBKYSE (KEYS, ITIME)
      ELSE
        CALL RZCDIR (PATH, 'R')
        MAXL   = INDEX (PATH, ' ') - 1
        IF (MAXL.LT.1.OR.MAXL.GT.MAXLDB) MAXL = MAXLDB
        NKEYS   = NKEYDK
        KST     = NWKYDK + 1
*
*  **   Loop over all subdirectories
*
        DO 80 IK = 1, NKEYS
          ICURDT = NKEYS + 1 - IK
*
*  *      Fast selection
*
          IF (IK.NE.1) THEN
            CALL RZCDIR (PATH, ' ')
            IF (IQUEST(1).NE.0)  THEN
              IQUEST(1) = 25
+SELF, IF=$DEBUG.
              IF (IDEBDB.NE.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEYS : I'//
     +        'llegal Path name '//PATH//''')', IARGDB, 0)
+SELF.
              GO TO 999
            ENDIF
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
            NWKYDK = IQUEST(8)
          ENDIF
*
          KPNT   = IUHUNT (ICURDT, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                     NKEYS*KST, KST)
          IF (KPNT.NE.0) THEN
            IPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB
          ELSE
            IPNT   = KOFSDB + LCDRDB + IKDRDB + (ICURDT - 1) * KST
          ENDIF
          IF (IOKYDA(MITMDB).NE.0.AND.IQ(IPNT+MITMDB).GT.KEYS(MITMDB))
     +                                                      GO TO 80
          IF (KY7MDB.GT.0.AND.IQ(IPNT+MITMDB).GT.KY7MDB)    GO TO 80
          IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).EQ.0) THEN
            IF (ITIME.GT.IQ(IPNT+MEVRDB))                   GO TO 80
            IF (ITIME.LT.IQ(IPNT+MBVRDB)) THEN
              IF (KY4MDB.GT.IQ(IPNT+MBVRDB)) KY4MDB = IQ(IPNT+MBVRDB)
              GO TO 80
            ENDIF
          ELSE IF (IOKYDA(MBVRDB).NE.0.AND.IOKYDA(MEVRDB).EQ.0) THEN
            IF (IQ(IPNT+MBVRDB).GT.KEYS(MBVRDB))            GO TO 80
          ELSE IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).NE.0) THEN
            IF (IQ(IPNT+MEVRDB).LT.KEYS(MEVRDB))            GO TO 80
          ELSE
            IF (IQ(IPNT+MBVRDB).GT.KEYS(MBVRDB).OR.
     +          IQ(IPNT+MEVRDB).LT.KEYS(MEVRDB))            GO TO 80
          ENDIF
*
          CALL DBPATH (PATHX, ICURDT)
          PATHN  = PATH(1:MAXL)//'/'//PATHX
          CALL RZCDIR (PATHX, ' ')
          IF (IQUEST(1).NE.0)  THEN
            IQUEST(1) = 25
+SELF, IF=$DEBUG.
            IF (IDEBDB.NE.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEYS : Ill'//
     +      'egal Path name '//PATHN//''')', IARGDB, 0)
+SELF.
            GO TO 100
          ENDIF
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          NKEYDK = IQUEST(7)
          NWKYDK = IQUEST(8)
          CALL DBKEYT
          CALL DBKYSE (KEYS, ITIME)
          IF (IQUEST(1).NE.0)                               GO TO 100
   80   CONTINUE
      ENDIF
*
* *** Discard all keys with discard bit set
*
      LSAVDB = LFIXDB
      IF (LFIXDB.EQ.LREFDB(2)) THEN
        LBKYDB = LQ(KOFUDB+LSAVDB-KLKYDB)
      ELSE
        LBKYDB = LQ(KOFUDB+LSAVDB)
      ENDIF
   90 IF (LBKYDB.NE.0)  THEN
        KEY6   = IQ(KOFUDB+LBKYDB+MFLGDB)
        IF (JBIT(KEY6,JIGNDB).NE.0)  THEN
          CALL MZDROP (IDIVDB, LBKYDB, ' ')
        ELSE
          LSAVDB = LBKYDB
          IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).EQ.0) THEN
            IQ(KOFUDB+LBKYDB+NWKYDK+1) =
     +        MIN(IQ(KOFUDB+LBKYDB+MEVRDB),KY4MDB)
          ENDIF
        ENDIF
        LBKYDB = LQ(KOFUDB+LSAVDB)
        GO TO 90
      ENDIF
*
* *** Reset the current directory if needed
*
  100 IER    = IQUEST(1)
      IF (IOPTP.NE.0)  THEN
        CALL RZCDIR (PATH, ' ')
        IF (IQUEST(1).NE.0)  THEN
          IF (IER.EQ.0)  THEN
            IQUEST(1) = 25
+SELF, IF=$DEBUG.
            IF (IDEBDB.NE.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEYS : Ill'//
     +      'egal Path name '//PATH//''')', IARGDB, 0)
+SELF.
          ELSE
            IQUEST(1) = IER
          ENDIF
        ELSE
          IQUEST(1) = IER
          NKEYDK = IQUEST(7)
          NWKYDK = IQUEST(8)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          CALL DBKEYT
        ENDIF
      ENDIF
*
      IF (LFIXDB.EQ.LREFDB(2)) THEN
        LBK(1) = LQ(KOFUDB+LFIXDB-KLKYDB)
      ELSE
        LBK(1) = LQ(KOFUDB+LFIXDB)
      ENDIF
      IF (LBK(1).EQ.0)  THEN
        IQUEST(1) = 24
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKEYS : No comp'//
     +  'atible object for specified options'')', IARGDB, 0)
+SELF.
      ENDIF
*                                                             END DBKEYS
  999 END
+DECK, DBKEYT.
      SUBROUTINE DBKEYT
*     ==================
*
************************************************************************
*                                                                      *
*        SUBR. DBKEYT                                                  *
*                                                                      *
*   Retrieves the I/O descriptor for the current directory             *
*                                                                      *
*   Called by various routines in the DBL3 package                     *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
      DO 10 I = 1, NWKYDK
        IN     = (I - 1) / 10
        JB     = 3*I - 30*IN - 2
        IWD    = IQ(KOFSDB+LCDRDB+IKTYDB+IN)
        IFORM  = JBYT (IWD, JB, 3)
        IF (IFORM.EQ.3) THEN
          IFORM  = 5
        ELSE IF (IFORM.EQ.4) THEN
          IFORM  = 6
        ELSE IF (IFORM.EQ.5)  THEN
          IFORM  = 3
        ELSE IF (IFORM.LT.1.OR.IFORM.GT.5)  THEN
          IFORM  = 2
        ENDIF
        IOTYDK(I) = IFORM
   10 CONTINUE
*                                                             END DBKEYT
  999 END
+DECK, DBKOUT.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBKOUT (PATHN, IUDIV, LSUP, NTKEY, KEY, IPREC)
*     =========================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBKOUT (PATHN, IUDIV, LSUP, NTKEY, *KEY*, IPREC)        *
*                                                                      *
*   Stores data from memory to disk                                    *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     IUDIV    Division index where the data reside                    *
*     LSUP     Address of the bank where data reside                   *
*     NTKEY    Number of key elements                                  *
*     KEY(*)   Vector of keys (Keys 3,4,5 and 8 onwards to be filled   *
*              in by user on input; the DB system keys will be filled  *
*              in here at the time of output)                          *
*     IPREC    Precision word; (If IPREC > 0, data are stored with     *
*              IPREC significant digits right to the decimal points; if*
*              IPREC < 0, data are stored with IPREC insignificant     *
*              digits left to the decimal point.)                      *
*                                                                      *
*   Called by DBABWR, DBENTR, DBOUT, DBREPL, DBVOUT                    *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 71 : Illegal path name                               *
*               = 72 : Number of keys does not match with that         *
*                      specified in the directory                      *
*               = 73 : RZOUT fails to write on disk                    *
*               = 74 : Error in RZRENK in updating key values for      *
*                      partitioned data set                            *
*               = 75 : Cannot find the Top directory name in pathname  *
*               = 76 : Cannot form the IO descriptor for the FZ header *
*               = 77 : FZOUT fails to write on to the sequential file  *
*               = 78 : Illegal number of keys in data base             *
*                                                                      *
************************************************************************
*
+CDE, DAOPTI.
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DZPACK.
+CDE, P3DBL3, IF=$P3CHILD.
      PARAMETER       (NLEVM=20)
      DIMENSION       KEY(9), LSUP(9), KEYO(MXDMDK), KEYN(MXDMDK)
      CHARACTER       PATHY*80, PATHX*16, CHFOR*100, CFORM(6)*1
      CHARACTER       CHCUR(NLEVM)*1, TOPN*16, PATHN*(*), CHOPT*28
      CHARACTER       CHOP*1, PATHL*80
      INTEGER         NLCUR(NLEVM), IOPTS(26)
      EQUIVALENCE     (IOPADA, IOPTS(1))
      DATA            CFORM /'B', 'I', 'F', 'D', 'H', 'A'/
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Set the current directory path name
*
      LREFDB(2) = LSUP(1)
      PATHX  = ' '
      PATHY  = PATHN
      PATHL  = ' '
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0)          GO TO 991
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      KST    = NWKYDK + 1
      CALL RZCDIR (PATHY, 'R')
      CALL DBKYTG
      IF (NKEYDK.NE.0)  THEN
        IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)
        IOPTP  = JBIT (IOPTP, JPRTDB)
      ELSE
        IOPTP  = 0
      ENDIF
*
      IF (NWKYDK.LT.NSYSDK.OR.NWKYDK.GT.MXDMDK) THEN
        IQUEST(1) = 78
        IQUEST(11)= NWKYDK
        IQUEST(12)= NSYSDK
        IQUEST(13)= MXDMDK
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : Illegal'//
     +  ' number of keys '',I10,'' permitted range '',2I6)', IQUEST(11),
     +  3)
+SELF.
        GO TO 999
      ENDIF
*
* *** Extract the Top level directory name
*
      I1     = 0
      I11    = 0
      DO 10 I0 = 1, MAXLDB
        IF (PATHY(I0:I0).EQ.'/'.OR.PATHY(I0:I0).EQ.' ') THEN
          IF (I1.GT.0) THEN
            TOPN   = PATHY(I11:I0-1)
            GO TO 15
          ENDIF
          IF (PATHY(I0:I0).EQ.' ') GO TO 15
        ELSE
          IF (I1.EQ.0) I11 = I0
          I1     = I1 +1
        ENDIF
   10 CONTINUE
   15 IF (I1.EQ.0) THEN
        IQUEST(1) = 75
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : No top '//
     +  'directory for '//PATHY//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** See if transcript file is needed
*
      LTOP   = LTOPDB
      IOPS   = 0
      IOUT   = 0
   20 IF (LTOP.NE.0) THEN
        NCH    = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCH)
        TOPNDI = TOPNDI(1:NCH)
        IF (TOPN.EQ.TOPNDI) THEN
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)
          IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10)
          IF (IOPBDA.EQ.0) THEN
            LUFZDF = IQ(KOFUDB+LTOP+MUPJFL)
          ELSE
            LUFZDF = IQ(KOFUDB+LTOP+MUPBAK)
          ENDIF
        ELSE
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 20
        ENDIF
      ELSE
        LUFZDF = 0
        IOPP   = 0
      ENDIF
      IF (IOUT.EQ.0) IOPS = 0
*
* *** Fill up Key 1, 2, 7
*
      KEY(MSERDB) = 0
      KEY(MUPNDB) = 0
      IF (IOKYDA(MITMDB).EQ.0.OR.KEY(MITMDB).LE.0) THEN
        CALL DATIME (IDATE, ITIME)
        CALL DBPKTM (IDATE, ITIME, IDATM)
        KEY(MITMDB) = IDATM
      ENDIF
*
      IDB    = IDBTYP (LREFDB(2))
      IF (IDB.EQ.2.OR.IDB.EQ.3) THEN
        IOPTR  = 0
      ELSE
        IOPTR  = 1
      ENDIF
*
      IF (IOPRDA.NE.0 .OR. IOPTR.NE.0 .OR. IOPTDA.NE.0) THEN
        IF (IOPTDA.NE.0) THEN
          CHOP   = 'S'
        ELSE IF (IOPRDA.NE.0) THEN
          CHOP   = 'L'
        ELSE
          CHOP   = ' '
        ENDIF
      ELSE
        CHOP   = 'S'
      ENDIF
*
* *** Encode the character option, IO descriptor for the header
*
      IF (IOPP.NE.0.OR.LUFZDF.GT.0) THEN
        CHOPT  = '7'
        NDOP   = 1
        DO 25 I = 1, 26
          IF (IOPTS(I).NE.0) THEN
            IF (NDOP.EQ.0) THEN
              CHOPT  = CALFDA(I)
            ELSE
              CHOPT  = CHOPT(1:NDOP)//CALFDA(I)
            ENDIF
            NDOP   = NDOP + 1
          ENDIF
   25   CONTINUE
        NDOP   = (NDOP + 3) / 4
*
        NLEV   = 1
        NCUR   = 5
        IFORO  = 2
        CHCUR(NLEV) = CFORM(IFORO)
        IF (PACKDZ.AND.IOPUDA.EQ.0) THEN
          NLCUR(NLEV) = 4
          IFORO  = 3
          NCUR   = 1
          NLEV   = NLEV + 1
          CHCUR(NLEV) = CFORM(IFORO)
          CALL UCOPY (PRECDZ, IHEADF(MPREDF), 1)
        ELSE
          IHEADF(MPREDF) = IPREC
        ENDIF
        DO 30 I = 1, NWKYDK
          IFORM  = IOTYDK(I)
          IF (IFORM.EQ.6) IFORM = 5
          IF (IFORM.EQ.IFORO) THEN
            NCUR   = NCUR + 1
          ELSE
            NLCUR(NLEV) = NCUR
            IF (NLEV.GE.NLEVM) THEN
              IQUEST(1) = 76
+SELF, IF=$DEBUG.
              IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : '//
     +        'Cannot get IO descriptor '//PATHY//''')', IARGDB, 0)
+SELF.
              GO TO 999
            ENDIF
            NLEV   = NLEV + 1
            CHCUR(NLEV) = CFORM(IFORM)
            NCUR   = 1
            IFORO  = IFORM
          ENDIF
   30   CONTINUE
        NLCUR(NLEV) = NCUR
*
+SELF, IF=-IBM, -$P3CHILD.
        WRITE (CHFOR, 2001) (NLCUR(I), CHCUR(I), I = 1, NLEV)
+SELF, IF=IBM, IF=$P3CHILD.
        CHFOR  = ' '
        II     = 1
        DO 31 I = 1, NLEV
          CALL UTWRIT (CHFOR(II:II+1), '(I2)', NLCUR(I))
          II     = II + 2
          CHFOR(II:II) = CHCUR(I)
          II     = II + 2
   31   CONTINUE
+SELF.
        II     = 4 *NLEV
        CHFOR = CHFOR(1:II)//' -H'
        CALL MZIOCH (IOFMDF, NWFMDF, CHFOR(1:II+3))
*
*  **   Complete the header
*
        NCHR   = INDEX (PATHY, ' ') - 1
        IF (NCHR.LT.1.OR.NCHR.GT.MAXLDB) NCHR = MAXLDB
        NWDP   = (NCHR + 3) / 4
        NWDH   = NWDP + NDOP + NWKYDK + 5
        IHEADF(MACTDF) = 1
        IHEADF(MNKYDF) = NWKYDK
        IHEADF(MOPTDF) = NDOP
        IHEADF(MPATDF) = NWDP
        IF (NDOP.GT.0)
     +    CALL UCTOH (CHOPT, IHEADF(MPREDF+NWKYDK+1), 4, 4*NDOP)
        CALL UCTOH (PATHY, IHEADF(MPREDF+NWKYDK+NDOP+1), 4, 4*NWDP)
        CALL UCOPY (KEY, IHEADF(MPREDF+1), NWKYDK)
      ENDIF
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
      IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
        CALL DBWLOK
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
        CALL DBSTSV (TOPN, 0)
+SELF, IF=$P3CHILD.
        LUFZDF = LODBP3
        RNDBP3 = 'DBKOUT '
        NWDBP3 = 2
        CALL UCTOH ('JOURNAL ', IWDBP3, 4, 8)
        CALL DBCHLD
        IQUEST(1) = IQDBP3
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        IF (IQUEST(1).NE.0)        GO TO 999
*
*  **   Copy the record to CLUSCOM or SPOOL
*
        CALL FZOUT (LUFZDF, IUDIV, LREFDB(2), 1, CHOP, IOFMDF, NWDH,
     +              IHEADF)
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1)  = 77
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : Error'//
     +    ' in FZOUT while writing Data for '//PATHY//''')', IARGDB, 0)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          GO TO 999
        ENDIF
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
*
        CALL DBCWSV
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        GO TO 999
      ENDIF
+SELF, IF=-$P3CHILD.
*
* *** Take necessary action for partitioned and nonpartiitined datasets
*
      IF (IOPTP.EQ.0) THEN
        KOBJ   = 0
      ELSE
        KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                   NKEYDK*KST, KST)
        IF (KPNT.NE.0) THEN
          NK     = (KPNT - MPSRDB) / KST + 1
        ELSE
          NK     = NKEYDK
        ENDIF
        CALL DBKEYR (NK, NWKYDK, KEYO)
        KOBJ   = KEYO(MOBJDB)
        MXKP   = KEYO(MXKPDB)
        CALL DBPATH (PATHX, NKEYDK)
        CALL RZCDIR (PATHX, ' ')
        IF (IQUEST(1).NE.0)        GO TO 991
        NKEYDK = IQUEST(7)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
*
*  **   Make a different subdirectory if there are too many keys
*
        IF (NKEYDK.GE.MXKP) THEN
          NWKEY  = NWKYDK
          CHFOR = ' '
          DO 35 I = 1, NWKEY
            IF (I.EQ.1) THEN
              CHFOR  = CFORM(IOTYDK(I))
            ELSE
              CHFOR  = CHFOR(1:I-1)//CFORM(IOTYDK(I))
            ENDIF
   35     CONTINUE
          IF (IOKYDA(MITMDB).EQ.0.OR.KEY(MITMDB).LE.0) THEN
            KEY7DK = 0
          ELSE
            KEY7DK = KEY(MITMDB)
          ENDIF
          CALL DBMDIP (PATHY, NWKEY, CHFOR, CTAGDK, MXKP)
          IF (IQUEST(1).NE.0)      GO TO 999
          CALL RZCDIR (PATHY, ' ')
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                     NKEYDK*KST, KST)
          IF (KPNT.NE.0) THEN
            NK     = (KPNT - MPSRDB) / KST + 1
          ELSE
            NK     = NKEYDK
          ENDIF
          CALL DBKEYR (NK, NWKYDK, KEYO)
          KOBJ   = KEYO(MOBJDB)
          CALL DBPATH (PATHX, NKEYDK)
          CALL RZCDIR (PATHX, ' ')
          IF (IQUEST(1).NE.0)      GO TO 991
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
        ENDIF
        CALL UCOPY (KEYO, KEYN, NWKYDK)
*
      ENDIF
*
* *** Check the number of keys
*
      IF (NTKEY.NE.NWKYDK)         GO TO 992
      LOBJ   = KOBJ
      IF (NKEYDK.GT.0) THEN
        ISTP   = NWKYDK + 1
        DO 40 IK = 1, NKEYDK
          IP     = KOFSDB + LCDRDB + IKDRDB + (IK-1)*ISTP + MSERDB
          IF (IQ(IP).GT.LOBJ) LOBJ = IQ(IP)
   40   CONTINUE
      ENDIF
      LOBJ   = LOBJ + 1
*
*  ** Write the sequential output if needed
*
      IF (LUFZDF.GT.0) THEN
        IHEADF(MPREDF+MSERDB) = LOBJ
        CALL FZOUT (LUFZDF, IUDIV, LREFDB(2), 1, CHOP, IOFMDF, NWDH,
     +              IHEADF)
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1)  = 77
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : Error'//
     +    ' in FZOUT while writing Data for '//PATHY//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
          GO TO 998
        ENDIF
      ENDIF
*
* *** Fill up Key vectors 1,2,6,7
*
      KEY(MSERDB) = LOBJ
      KEY(MFLGDB) = MSBIT0 (KEY(MFLGDB), JRZUDB)
      KEY(MFLGDB) = MSBIT0 (KEY(MFLGDB), JPRTDB)
      KEY(MFLGDB) = MSBIT0 (KEY(MFLGDB), JASFDB)
*
* *** Lock the directory if necessary
*
      IF (IOPP.EQ.0.AND.IOPS.NE.0) THEN
        CALL RZCDIR (PATHY, ' ')
        NKEYDK = IQUEST(7)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        CALL RZLOCK ('DBKOUT')
        PATHL  = PATHY
        IF (IOPTP.NE.0) THEN
          CALL RZCDIR (PATHX, ' ')
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
        ENDIF
      ENDIF
*
      IF (IOPRDA.NE.0 .OR. IOPTR.NE.0 .OR. IOPTDA.NE.0) THEN
*
*  **   RZ mode output
*
        KEY(MFLGDB) = MSBIT1 (KEY(MFLGDB), JRZUDB)
        IF (IOPTDA.NE.0) KEY(MFLGDB) = MSBIT1 (KEY(MFLGDB), JASFDB)
*
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')
+SELF, IF=-$P3CHILD.
        CALL RZOUT (IUDIV, LREFDB(2), KEY, ICYCLE, CHOP)
*
      ELSE
*
*  **   Copy data to DB internal store
*
*  **   0 Data word : do not pack
*
        IF (IQ(KOFUDB+LREFDB(2)-1).EQ.0) IOPUDA = 1
        CALL DBFRUS (LREFDB(2), LSTRDL(1), IPREC)
        IF (IQUEST(1).NE.0)        GO TO 998
*
*  **   Compress the data if requested
*
        IF (IOPUDA.NE.0)  THEN
          LREFDL(1) = LSTRDL(1)
        ELSE
          CALL DBCOMP (LSTRDL(1), LREFDL(1), KEY(1))
        ENDIF
        IF (IQUEST(1).NE.0)        GO TO 998
*
*  **   Drop the uncompressed data
*
        IF (LREFDL(1).NE.LSTRDL(1)) CALL MZDROP (IDISDB, LSTRDL(1), 'L')
*
*  **   Write on to disk
*
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.2) CALL RZLDIR (' ', ' ')
+SELF, IF=-$P3CHILD.
        CALL RZOUT (IDISDB, LREFDL(1), KEY, ICYCLE, 'S')
        IER       = IQUEST(1)
        CALL MZDROP (IDISDB, LREFDL(1), 'L')
        IQUEST(1) = IER
*
      ENDIF
      CALL UCOPY (KEY, KEYNDK, NWKYDK)
*
      IF (IQUEST(1).NE.0)          GO TO 993
+SELF, IF=$DEBUG, IF=-$P3CHILD.
      IF (IDEBDB.GT.1) THEN
        IARGDB(1) = IDATE
        IARGDB(2) = ITIME
        CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : Data was inserted into'//
     +       '   '//PATHY//''',/,10X,''on the '',I8,'' at '',I6,'' '//
     +       'with Key-Vector '')', IARGDB, 2)
        CALL DBKEYT
        CALL DBPRKY (NWKYDK, KEYNDK, IOTYDK)
      ENDIF
+SELF, IF=-$P3CHILD.
      GO TO 998
+SELF, IF=$P3CHILD.
      GO TO 999
+SELF.
*
* *** Error messages
*
  991 IQUEST(1) = 71
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : Illegal '//
     +   'Path Name '//PATHY//PATHX(1:8)//''')', IARGDB, 0)
+SELF.
      GO TO 999
+SELF, IF=-$P3CHILD.
*
  992 IQUEST(1) = 72
      IQUEST(11)= NTKEY
      IQUEST(12)= NWKYDK
+SELF, IF=$DEBUG, IF=-$P3CHILD.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : Number of'//
     +   ' keys '',I4,'' does not match with that specified '',I4,'' '//
     +   'in the directory'')', IQUEST(11), 2)
+SELF, IF=-$P3CHILD.
      GO TO 998
*
  993 IQUEST(1) = 73
+SELF, IF=$DEBUG, IF=-$P3CHILD.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : Error in '//
     +   'RZOUT while writing Data for '//PATHY//PATHX(1:8)//''')',IQ,0)
+SELF, IF=-$P3CHILD.
*
  998 IER   = IQUEST(1)
      IF (IOPTP.NE.0)  THEN
        CALL RZCDIR (PATHY, ' ')
        IF (IQUEST(1).NE.0) THEN
          IF (IER.EQ.0) THEN
            IF (PATHL.NE.' ') THEN
              CALL RZCDIR (PATHL, ' ')
              CALL RZFREE ('DBKOUT')
            ENDIF
            GO TO 991
          ELSE
            IQUEST(1) = IER
          ENDIF
        ELSE
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          NKEYDK = IQUEST(7)
          IQUEST(1) = IER
*
*  **     Rename Keys 3 and 4 of the latest subdirectory
*
          IF (IER.EQ.0) THEN
            KEYN(MBVRDB) = MIN0 (KEYN(MBVRDB), KEY(MBVRDB))
            KEYN(MEVRDB) = MAX0 (KEYN(MEVRDB), KEY(MEVRDB))
            CALL RZRENK (KEYO, KEYN)
            IF (IQUEST(1).NE.0) THEN
              IQUEST(1) = 74
+SELF, IF=$DEBUG, IF=-$P3CHILD.
              IF (IDEBDB.GT.0) THEN
                CALL UCOPY (KEYO, IARGDB(1),        NSYSDK)
                CALL UCOPY (KEYN, IARGDB(NSYSDK+1), NSYSDK)
                CALL DBPRNT (LPRTDB, '(/,'' DBKOUT : Error in RZRENK '//
     +               'while writing data for '//PATHY//''',/(10X,7I12))'
     +,              IARGDB, 2*NSYSDK)
              ENDIF
+SELF, IF=-$P3CHILD.
            ENDIF
          ENDIF
        ENDIF
      ENDIF
*
      IF (PATHL.NE.' ') THEN
        IERR   = IQUEST(1)
        CALL RZCDIR (PATHL, ' ')
        CALL RZFREE ('DBKOUT')
        IQUEST(1) = IERR
      ENDIF
+SELF, IF=-IBM, -$P3CHILD.
*
 2001 FORMAT (20(I2,A1,1X))
+SELF.
*                                                             END DBKOUT
  999 END
+DECK, DBKXIN.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBKXIN (ITIME, IUDIV, LU, LSUP, JBIAS, NWKEY, KEY,
     +                   IPREC)
*     =============================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBKXIN (ITIME, IUDIV, LU*, LSUP, JBIAS, NWKEY*, *KEY*,  *
*                      IPREC*)                                         *
*                                                                      *
*   Fetches from disk to a ZEBRA bank data valid for a given time      *
*                                                                      *
*   Restrictions : This routine is called internally by other routines *
*                  in DBL3. One should be very careful in using this   *
*                  routine. For example, the character option for      *
*                  special selection scheme like options S or N in     *
*                  DBUSE is not present in this routine and they can   *
*                  be switched on or off only by a prior call to DBUSE *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     ITIME    Time for which data are required to be valid            *
*     IUDIV    Division index where bank is expected                   *
*     LU(*)    Address of the bank in memory                           *
*     LSUP     Supporting link of the bank (see MZBOOK)                *
*     JBIAS    Link bias for creating the data bank (see MZBOOK)       *
*     NWKEY    Number of key elements                                  *
*     KEY(*)   Vector of keys (On input if any key beyond element 8 or *
*              element 5 is nonzero,data are retrieved according to its*
*              content; on output it contains the key elements for the *
*              current data)                                           *
*     IPREC(*) Precision word; (If IPREC > 0, data are stored with     *
*              IPREC significant digits right to the decimal points; if*
*              IPREC < 0, data are stored with IPREC insignificant     *
*              digits left to the decimal point.)                      *
*                                                                      *
*   Called by DBIN,   DBGET,  DBGETS, DBKIN,  DBKVIN, DBNTOP, DBPURK,  *
*             DBRHLP, DBRNAM, DBRTFZ, DBSRTM, DBVIN,  DBCHCK, DBGNAM,  *
*             DBPRDT, DBPLNT, DBPLOB, DBPLOV, DBAIRD, DBDISD, DBDISH,  *
*             DBDISV, DBEDKY, DBPEEK                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 31 : Illegal Pathname                                *
*               = 33 : No valid data for the given set of keys and     *
*                      program version number                          *
*               = 35 : Wrong reference to data objects in update mode  *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DTKXIN.
+CDE, P3DBL3, IF= $P3CHILD.
      DIMENSION       KEY(9), LSUP(9), LU(9)
      CHARACTER       PATHN*80, PATH*80, PATHX*16
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
+SELF, IF= $P3CHILD.
      IF (IPASP3.GT.1) THEN
        IKYLDT = KEY(MSERDB)
        IPRVDT = IKYLDT
        NWKYDK = NWKEY
        CALL UCOPY (KEY,KEYNDK,NWKEY)
        GO TO 2
      ENDIF
+SELF.
      IPRVDT = KEY(MPVSDB)
      NWKEY  = NWKYDK
      NKEYS  = NKEYDK
      CALL RZCDIR (PATHN, 'R')
      MAXL   = INDEX (PATHN, ' ') - 1
      IF (MAXL.LT.1.OR.MAXL.GT.MAXLDB) MAXL = MAXLDB
*
* *** Check the validity limits from the Keys
*
    2 NTIMDT = 0
      MNKYDT = -999
      INRSDT = 100000
      IDNRDT = 0
      KEY6DT = 0
      KY6NDT = 0
      ICURDT = 1
      ISTP   = NWKYDK + 1
+SELF, IF= $P3CHILD.
      IF (IPASP3.GT.1)                                      GO TO 27
+SELF.
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
*
* *** Select by the key number
*
      IF (IOKYDA(MSERDB).NE.0)  THEN
        IKYLDT = KEY(MSERDB)
        IPRVDT = IKYLDT
*
        IF (IOPTP.EQ.0)  THEN
*
          IF (IKYLDT.GT.0 .AND. IKYLDT.LE.NKEYDK)  THEN
            GO TO 25
          ELSE
            GO TO 993
          ENDIF
*
        ELSE
*
          DO 5 JK = 1, NKEYDK
            IK     = NKEYDK + 1 - JK
            KPNT   = IUHUNT (IK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                       NKEYDK*ISTP, ISTP)
            IF (KPNT.NE.0) THEN
              IPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB
            ELSE
              IPNT   = KOFSDB + LCDRDB + IKDRDB + (IK - 1) * ISTP
            ENDIF
            KEY5   = IQ(IPNT+MOBJDB)
            IF (IKYLDT.GT.KEY5)                             GO TO 10
    5     CONTINUE
          GO TO 993
   10     KOFF   = KEY5
          CALL DBPATH (PATHX, IK)
          CALL RZCDIR (PATHX, ' ')
          IF (IQUEST(1).NE.0)                               GO TO 991
          IKYLDT = KEY(MSERDB) - KOFF
          IF (IKYLDT.GT.IQUEST(7)) THEN
            GO TO 993
          ELSE
            NKEYDK = IQUEST(7)
            NWKYDK = IQUEST(8)
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
            CALL DBKEYT
            ISTP   = NWKYDK + 1
            GO TO 25
          ENDIF
        ENDIF
*
      ENDIF
*
* *** Select by the Key values
*
      KY4MDB = IBIGDB
      IF (IOPTP.EQ.0)  THEN
*
        CALL DBSEKY (ITIME, KEY)
*
      ELSE
*
        DO 15 JK = 1, NKEYS
          ICURDT = NKEYS + 1 - JK
          CALL DBPATH (PATHX, ICURDT)
          IF (JK.NE.1) THEN
            CALL RZCDIR (PATHN, ' ')
            IF (IQUEST(1).NE.0)                             GO TO 991
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
          ENDIF
          KPNT   = IUHUNT (ICURDT, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                     NKEYS*ISTP, ISTP)
          IF (KPNT.NE.0) THEN
            IPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB
          ELSE
            IPNT   = KOFSDB + LCDRDB + IKDRDB + (ICURDT - 1) * ISTP
          ENDIF
          IF (IOKYDA(MITMDB).NE.0.AND.KEY(MITMDB).LT.IQ(IPNT+MITMDB))
     +                                                      GO TO 15
          IF (KY7MDB.GT.0.AND.KY7MDB.LT.IQ(IPNT+MITMDB))    GO TO 15
          IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).EQ.0) THEN
            IF (ITIME.GT.IQ(IPNT+MEVRDB))                   GO TO 15
            IF (ITIME.LT.IQ(IPNT+MBVRDB)) THEN
              IF (KY4MDB.GT.IQ(IPNT+MBVRDB)) KY4MDB = IQ(IPNT+MBVRDB)
              GO TO 15
            ENDIF
          ELSE IF (IOKYDA(MBVRDB).NE.0.AND.IOKYDA(MEVRDB).EQ.0) THEN
            IF (IQ(IPNT+MBVRDB).GT.KEY(MBVRDB))             GO TO 15
          ELSE IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).NE.0) THEN
            IF (IQ(IPNT+MEVRDB).LT.KEY(MEVRDB))             GO TO 15
          ELSE
            IF (IQ(IPNT+MBVRDB).GT.KEY(MBVRDB).OR.
     +          IQ(IPNT+MEVRDB).LT.KEY(MEVRDB))             GO TO 15
          ENDIF
*
          CALL RZCDIR (PATHX, ' ')
          IF (IQUEST(1).NE.0)                               GO TO 991
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          CALL DBSEKY (ITIME, KEY)
          IF (NTIMDT.NE.0 .AND. JBIT(KEY6DT,JIGNDB).EQ.0)   GO TO 20
*
   15   CONTINUE
*
      ENDIF
*
* *** Check if valid data exist
*
   20 ISTP   = NWKYDK + 1
      IF (NTIMDT.EQ.0 .OR. JBIT(KEY6DT,JIGNDB).NE.0)  THEN
*
        IF (KY6NDT.NE.0)  THEN
          IKYLDT = KY6NDT
*
        ELSE IF (IOPNDA.NE.0 .AND. IDNRDT.NE.0)  THEN
*
*  **     Take the nearest neighbour
*
          NTIMDT = -1
          IKYLDT = IDNRDT
          IF (IOPTP.NE.0 .AND. IUSEDT.NE.ICURDT)  THEN
            CALL DBPATH (PATHX, IUSEDT)
            PATH   = PATHN(1:MAXL)//'/'//PATHX
            CALL RZCDIR (PATH, ' ')
            IF (IQUEST(1).NE.0)                             GO TO 991
            NKEYDK = IQUEST(7)
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
          ENDIF
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.1)  THEN
            IPNT   = KOFSDB + LCDRDB + IKDRDB + (IDNRDT - 1) * ISTP
            IARGDB(1) = ITIME
            IARGDB(2) = IQ(IPNT+MBVRDB)
            IARGDB(3) = IQ(IPNT+MEVRDB)
            CALL DBPRNT (LPRTDB, '(/,'' DBKXIN : Warning --> Data val'//
     +           'id at time '',I10,'' does not exist. Data valid bet'//
     +           'ween '',2I10,'' are returned'')', IARGDB, 3)
          ENDIF
+SELF.
*
        ELSE
*
*  **     None exists; return with error message
*
          GO TO 993
*
        ENDIF
*
      ENDIF
*
* *** Read in the data
*
   25 ICYCL  = 9999
      CALL DBKEYR (IKYLDT, NWKYDK, KEYNDK)
   27 KEY6DT = KEYNDK(MFLGDB)
      IF (JBIT(KEY6DT,JIGNDB).NE.0)                         GO TO 993
      KEY(MSERDB) = IKYLDT
      LSTRDL(2) = 0
      IF (NTIMDT.EQ.-1) KY4MDB = KEYNDK(MBVRDB) + 1
*
      IF (IOPKDA.NE.0)  THEN
*
*  **   Only the keys are needed
*
        CALL UCOPY (KEYNDK, KEY, NWKYDK)
*
      ELSE IF (JBIT(KEY6DT,JRZUDB) .NE. 0)  THEN
*
*  **   Data are stored in RZ way
*
        LSTRDL(2) = LSUP(1)
        CALL DBRZIN (IUDIV, LSTRDL(2), JBIAS, KEY, ICYCL, PATHN)
        LSUP(1) = LSTRDL(2)
        LSTRDL(2) = 0
        IF (JBIAS.GT.0)  THEN
          LU(1)  = LSUP(1)
        ELSE
          LU(1)  = LQ(KOFUDB+LSUP(1)+JBIAS)
        ENDIF
        IF (IQUEST(1).NE.0)                                 GO TO 998
*
        CALL UCOPY (KEYNDK, KEY, NWKYDK)
*
      ELSE
*
*  **   Read in standard DB format
*
        CALL DBRZIN (IDISDB, LSTRDL(2), 2, KEY, ICYCL, PATHN)
        IF (IQUEST(1).NE.0)                                 GO TO 998
        CALL UCOPY (KEYNDK, KEY, NWKYDK)
*
*  **   If the data is update - uncompress and proceed updating
*
        IF (KEY(MUPNDB).NE.0)  THEN
+SELF, IF=$P3CHILD.
          IF (IPASP3.EQ.2) THEN
            IK   = 1
            GO TO 35
          ENDIF
+SELF.
          DO 30 I = 1, NKEYDK
            IPNT   = KOFSDB + LCDRDB + IKDRDB + ISTP * (I-1)
            IF (KEY(MUPNDB).EQ.IQ(IPNT+MSERDB))  THEN
              IK     = I
+SELF, IF=$P3CHILD.
              IF (IPASP3.EQ.1) THEN
                IQUEST(1) = 0
                CALL DBRZIN (IDISDB, LREFDB(5), 2, IK, ' ')
                GO TO 998
              ENDIF
+SELF.
              GO TO 35
            ENDIF
   30     CONTINUE
          GO TO 995
*
   35     CALL DBUNCP (LSTRDL(2), LREFDL(3), IK)
        ELSE
+SELF, IF=$P3CHILD.
          IF (IPASP3.EQ.1) THEN
            IQUEST(1) = 0
            GO TO 998
          ENDIF
+SELF.
          CALL DBUNCP (LSTRDL(2), LREFDL(3), 0)
        ENDIF
*
*  **   Drop the compressed data
*
        IER       = IQUEST(1)
        CALL MZDROP (IDISDB, LSTRDL(2), ' ')
        IQUEST(1) = IER
        IF (IQUEST(1).NE.0)                                 GO TO 998
*
*  **   Copy from internal Data Base system to user format
*
        CALL DBTOUS (LREFDL(3), IUDIV, LU(1), LSUP(1), JBIAS, IPREC)
*
        IER       = IQUEST(1)
        CALL MZDROP (IDISDB, LREFDL(3), ' ')
        IQUEST(1) = IER
        IF (IQUEST(1).NE.0)                                 GO TO 998
*
      ENDIF
      GO TO 998
*
* *** Error messages
*
  991 IQUEST(1) = 31
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKXIN : Illegal '//
     +   'path name '//PATHN//PATHX(1:8)//''')', IARGDB, 0)
+SELF.
      GO TO 999
*
  993 IQUEST(1) = 33
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) THEN
        IARGDB(1) = ITIME
        IARGDB(2) = IPRVDT
        CALL DBPRNT (LPRTDB, '(/,'' DBKXIN : No valid data can be fou'//
     +       'nd for time'',I10,'' and Program Version'',I6)', IARGDB,2)
      ENDIF
+SELF.
      GO TO 998
*
  995 IQUEST(1) = 35
      IQUEST(11)= KEY(MUPNDB)
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKXIN : Key 2 ref'//
     +   'erence '',I4,'' cannot be found among the Key 1 values'')',
     +   IQUEST(11), 1)
+SELF.
      GO TO 998
*
  998 IER   = IQUEST(1)
      IF (IOPTP.NE.0)  THEN
        CALL RZCDIR (PATHN, ' ')
        IF (IQUEST(1).NE.0) THEN
          IF (IER.EQ.0) THEN
            GO TO 991
          ELSE
            IQUEST(1) = IER
          ENDIF
        ELSE
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          NKEYDK = IQUEST(7)
          NWKYDK = IQUEST(8)
          IQUEST(1) = IER
        ENDIF
      ENDIF
*                                                             END DBKXIN
  999 END
+DECK, DBKYSE.
      SUBROUTINE DBKYSE (KEYS, ITIME)
*     ===============================
*
************************************************************************
*                                                                      *
*        SUBR. DBKYSE (KEYS, ITIME)                                    *
*                                                                      *
*   Creates or completes the Key banks supported as next of same type  *
*   to the Node bank for 'S' option                                    *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     KEYS     Vector of keys                                          *
*     ITIME    Time for which the valid keys are required              *
*                                                                      *
*   Called by DBKEYS                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 23 : Key bank cannot be created; no space in memory  *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
      PARAMETER       (NZ=0)
      DIMENSION       KEYS(9)
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
      IQUEST(1) = 0
      IF (LFIXDB.EQ.LREFDB(2)) THEN
        JBIAS  = -KLKYDB
      ELSE
        JBIAS  = 0
      ENDIF
      ND     = IQ(KOFUDB+LREFDB(2)+MNDNWD)
      IF (IOKYDA(MBVRDB).EQ.0.AND.IOKYDA(MEVRDB).EQ.0)   GO TO 20
      DO 15 JK = 1, NKEYDK
*
*  *    Load the keys for this serial number
*
        IK     = NKEYDK + 1 - JK
        CALL DBKEYR (IK, NWKYDK, KEYNDK)
*
*  *    Use the selection
*
        DO 10 I = 3, NWKYDK
*
*  *      Keys 3, 4, 6 and 7 have special meannings
*
          IF (I.EQ.MBVRDB) THEN
            IF (IOKYDA(I).NE.0.AND.KEYNDK(I).GT.KEYS(I)) GO TO 15
          ELSE IF (I.EQ.MEVRDB)  THEN
            IF (IOKYDA(I).NE.0.AND.KEYNDK(I).LT.KEYS(I)) GO TO 15
          ELSE IF (I.EQ.MITMDB)  THEN
            IF (IOKYDA(I).NE.0.AND.KEYNDK(I).GT.KEYS(I)) GO TO 15
            IF (KY7MDB.GT.0.AND.KEYNDK(I).GT.KY7MDB)     GO TO 15
          ELSE IF (I.EQ.MFLGDB)  THEN
            IF (JBIT(KEYNDK(I),JIGNDB).NE.0)             GO TO 15
          ELSE
            IF (IOKYDA(I).NE.0.AND.KEYNDK(I).NE.KEYS(I)) GO TO 15
          ENDIF
   10   CONTINUE
*
*  *    Create a new Key bank
*
        CALL UCOPY  (IQ(KOFUDB+LREFDB(2)+MNDIOF), IOKYDB, NWNODB)
        CALL DBBOOK (IDIVDB, LBKYDB, LFIXDB, JBIAS, 'KYDB', NLKYDB,
     +               NSKYDB, ND, IOKYDB, NZ)
        IF (IQUEST(1).NE.0)  THEN
          IQUEST(1) = 23
          IQUEST(11)= IK
          IQUEST(12)= NKEYDK
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKYSE : No sp'//
     +    'ace in memory to create Key bank '',I3,'' out of '',I3)',
     +    IQUEST(11), 2)
+SELF.
          GO TO 999
        ENDIF
*
        LQ(KOFUDB+LBKYDB-KLNODB) = LREFDB(2)
        LQ(KOFUDB+LBKYDB-KLUPDB) = LBFXDB
        CALL UCOPY (KEYNDK, IQ(KOFUDB+LBKYDB+1), NWKYDK)
        IQ(KOFUDB+LBKYDB+NWKYDK+1) = KEYNDK(MBVRDB) + 1
*
   15 CONTINUE
      GO TO 999
*
*  ** S option with time validity (Last inserted ones only)
*
   20 LBKYDB = LSAVDB
      DO 50 JK = 1, NKEYDK
*
*  *    Load the keys for this serial number
*
        IK     = NKEYDK + 1 - JK
        CALL DBKEYR (IK, NWKYDK, KEYNDK)
*
*  *    Use the selection
*
        IF (ITIME.GT.KEYNDK(MEVRDB))                     GO TO 50
        DO 30 I = 5, NWKYDK
*
*  *      Keys (MFLGDB) and (MITMDB) have special meannings
*
          IF (I.EQ.MITMDB)  THEN
            IF (IOKYDA(I).NE.0.AND.KEYNDK(I).GT.KEYS(I)) GO TO 50
            IF (KY7MDB.GT.0.AND.KEYNDK(I).GT.KY7MDB)     GO TO 50
          ELSE IF (I.EQ.MFLGDB)  THEN
            GO TO 30
          ELSE
            IF (IOKYDA(I).NE.0.AND.KEYNDK(I).NE.KEYS(I)) GO TO 50
          ENDIF
   30   CONTINUE
        IF (ITIME.LT.KEYNDK(MBVRDB)) THEN
          IF (KY4MDB.GT.KEYNDK(MBVRDB)) KY4MDB = KEYNDK(MBVRDB)
          GO TO 50
        ENDIF
*
*  **   See if such Key bank already exists
*
        LBKYDB = LFIXDB
   35   LBKYDB = LQ(KOFUDB+LBKYDB)
        IF (LBKYDB.NE.0)  THEN
          DO 40 I = 5, NWKYDK
            IF (I.EQ.MFLGDB.OR.I.EQ.MITMDB)  THEN
              GO TO 40
            ELSE
              IF (KEYNDK(I).NE.IQ(KOFUDB+LBKYDB+I))      GO TO 35
            ENDIF
   40     CONTINUE
          IF (IQ(KOFUDB+LBKYDB+MSERDB).LT.KEYNDK(MSERDB))  THEN
            CALL UCOPY (KEYNDK, IQ(KOFUDB+LBKYDB+1), NWKYDK)
          ENDIF
          GO TO 50
        ENDIF
*
*  *    Create a new Key bank
*
        CALL UCOPY  (IQ(KOFUDB+LREFDB(2)+MNDIOF), IOKYDB, NWNODB)
        CALL DBBOOK (IDIVDB, LBKYDB, LFIXDB, JBIAS, 'KYDB', NLKYDB,
     +               NSKYDB, ND, IOKYDB, NZ)
        IF (IQUEST(1).NE.0)  THEN
          IQUEST(1) = 23
          IQUEST(11)= IK
          IQUEST(12)= NKEYDK
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBKYSE : No sp'//
     +    'ace in memory to create Key bank '',I3,'' out of '',I3)',
     +    IQUEST(11), 2)
+SELF.
          GO TO 999
        ENDIF
*
        LQ(KOFUDB+LBKYDB-KLNODB) = LREFDB(2)
        LQ(KOFUDB+LBKYDB-KLUPDB) = LBFXDB
        CALL UCOPY (KEYNDK, IQ(KOFUDB+LBKYDB+1), NWKYDK)
   50 CONTINUE
*                                                             END DBKYSE
  999 END
+DECK, DBKYTG.
      SUBROUTINE DBKYTG
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBKYTG                                                  *
*                                                                      *
*   Retrieves the I/O descriptor and the Tags of the Key elements      *
*   of the current directory                                           *
*                                                                      *
*   Called by DBENTB, DBKTYP, DBNTOP, DBPRIN, DBENFZ, DBKOUT, DBPLNT,  *
*             DBPLOB, DBAUXI, DBDISD, DBDISP, DBEDAS, DBJOIN, DBVWPR   *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
      DIMENSION       IHTAG(2)
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
      KTAG   = IKTYDB + (NWKYDK-1)/10 + 1
      DO 10 I = 1, NWKYDK
        CALL ZITOH (IQ(KOFSDB+LCDRDB+KTAG+2*I-2), IHTAG, 2)
        CALL UHTOC (IHTAG, 4, CTAGDK(I), 8)
        IN     = (I - 1) / 10
        JB     = 3*I - 30*IN - 2
        IWD    = IQ(KOFSDB+LCDRDB+IKTYDB+IN)
        IFORM  = JBYT (IWD, JB, 3)
        IF (IFORM.EQ.3) THEN
          IFORM  = 5
        ELSE IF (IFORM.EQ.4) THEN
          IFORM  = 6
        ELSE IF (IFORM.EQ.5)  THEN
          IFORM  = 3
        ELSE IF (IFORM.LT.1.OR.IFORM.GT.5)  THEN
          IFORM  = 2
        ENDIF
        IOTYDK(I) = IFORM
   10 CONTINUE
*                                                             END DBKYTG
  999 END
+DECK, DBLINC, IF=-$P3CHILD.
      SUBROUTINE DBLINC (CLINE, LENGTH, IDATA, NDATA)
*     ===============================================
*
************************************************************************
*                                                                      *
*        SUBR. DBLINC (CLINE, LENGTH, IDATA*, *NDATA*)                 *
*                                                                      *
*   Encodes a character string into a buffer IDATA                     *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     CLINE    Character string of maximum 80 characters               *
*     LENGTH   Length of the string                                    *
*     IDATA(*) Array to contain the encoded information                *
*     NDATA(*) Length of the array IDATA used so far                   *
*                                                                      *
*   Called by DBABWR, DBEHLP, DBAIWR                                   *
*                                                                      *
*   Original Code : CPLINE in CMZ Package                              *
*                                                                      *
************************************************************************
*
      CHARACTER       CLINE*(*)
      CHARACTER*4     FWORD(5), KBLANK
      CHARACTER*1     KONE, CAR, KTWO*(3)
      CHARACTER*80    KLINE
      DIMENSION       LINE(20), ILINE(20)
+SELF, IF=VAX.
      PARAMETER       (IND1=2, IND2=1)
+SELF, IF=APOLLO,IBM,UNIX,CRAY.
      PARAMETER       (IND1=1, IND2=2)
+SELF.
      CHARACTER       KENDIF*5, KELSE*4, KEND*3, KEYW*8, KCONT*8, KRET*6
+SELF, IF=-CRAY.
      INTEGER*2       IWD1(2), IWD2(2)
      EQUIVALENCE     (IWORD1, IWD1(1))
      EQUIVALENCE     (IWORD2, IWD2(1))
+SELF, IF=CRAY.
      INTEGER         IWD1(2), IWD2(2)
+SELF.
      DIMENSION       IDATA(9), ICODE(6)
      SAVE            KBLAN, IFIRST
*
      DATA            FWORD /'+DEC','+KEE','+SEQ','+CDE','+SEL'/
      DATA            ICODE /   125,   124,   123,   122,   121,   120/
      DATA            KENDIF, KEND, KRET /'ENDIF', 'END', 'RETURN'/
      DATA            KELSE, KCONT /'ELSE', 'CONTINUE'/
      DATA            KBLANK /'    '/
      DATA            IFIRST /0/
+SEQ, L3BITX, T=PASS.
*
*     ------------------------------------------------------------------
*
      IF (IFIRST.EQ.0) THEN
        IFIRST = 1
        CALL UCTOH (KBLANK, KBLAN, 4, 4)
      ENDIF
*
      KLINE = CLINE
      CALL UCTOH (CLINE, LINE, 4, 80)
      IF (LENGTH.EQ.0) THEN
        NDATA = NDATA +1
        IDATA(NDATA)=0
        GO TO 999
      ENDIF
+SELF, IF=-CRAY.
      IWORD2 = 0
+SELF, IF=CRAY.
      IWD1(1) = 0
      IWD1(2) = 0
      IWD2(1) = 0
      IWD2(2) = 0
+SELF.
      KONE   = KLINE(:1)
      KTWO   = KLINE(2:4)
      CALL DBIFCH (KONE, IKONE)
+SELF, IF=-CRAY.
      IWORD1 = IKONE
+SELF, IF=CRAY.
      IWD1(2) = IKONE
+SELF.
      ILASTW = (LENGTH+3)/4
*
* *** Treatment of special cases : +DECK, +KEEP, +SEQ, +CDE,+SELF,+SELF.
*
      IF (KONE.EQ.'+') THEN
        DO 10 NCAS = 1, 4
          IF (KLINE(1:4).EQ.FWORD(NCAS)) THEN
            IWD1(IND1) = ICODE(NCAS)*128
            GO TO 20
          ENDIF
   10   CONTINUE
        IF (KLINE(1:4).NE.FWORD(5))         GO TO 40
        IWD1(IND1) = ICODE(5)*128
        IF (KLINE(6:6).EQ.'.'.AND.LENGTH.EQ.6) THEN
          IWD1(IND1) = ICODE(6)*128
+SELF, IF=-CRAY.
          IDATA(NDATA+1) = IWORD1
+SELF, IF=CRAY.
          IDATA(NDATA+1) = IWD1(2)
          IDATA(NDATA+1) = MSBYT (IWD1(1), IDATA(NDATA+1), 17, 16)
+SELF.
          NDATA = NDATA + 1
          GO TO 999
        ENDIF
   20   IWD1(IND1) = IWD1(IND1) + ILASTW
        CALL DBIFRC (CLINE, ILINE, ILASTW, 4*ILASTW)
        DO 30 IW = 2, ILASTW
          IDATA(NDATA+IW) = ILINE(IW)
   30   CONTINUE
+SELF, IF=-CRAY.
        IDATA(NDATA+1) = IWORD1
+SELF, IF=CRAY.
        IDATA(NDATA+1) = IWD1(2)
        IDATA(NDATA+1) = MSBYT (IWD1(1), IDATA(NDATA+1), 17, 16)
+SELF.
        NDATA = NDATA + ILASTW
        GO TO 999
      ENDIF
*
   40 NWI    = 1
      IFIRW  = 1
      IF (ILASTW.EQ.1)                      GO TO 80
      DO 50 I = 2, 20
        IF (LINE(I).EQ.KBLAN)               GO TO 50
        IFIRW = I
        GO TO 60
   50 CONTINUE
   60 CONTINUE
*
* *** For ENDIF , ELSE , END (without label) and RETURN (without label),
* *** use code in bits 24 to 30 = 127, 126, 118, 116
*
      IF (KLINE(:6).EQ.' ') THEN
        NC1 = (IFIRW-1)*4+1
   70   IF (KLINE(NC1:NC1).EQ.'.') THEN
          NC1 = NC1 + 1
          GO TO 70
        ENDIF
        IF (LENGTH-NC1.GT.5)                GO TO 170
        KEYW = KLINE(NC1:LENGTH)
        CALL CLTOU (KEYW(:LENGTH-NC1+1))
        IF (KEYW.EQ.KENDIF) THEN
          IWD1(IND1) = 127*128 + NC1
        ELSE IF (KEYW.EQ.KELSE) THEN
          IWD1(IND1) = 126*128 + NC1
        ELSE IF (KEYW.EQ.KEND) THEN
          IWD1(IND1) = 118*128 + NC1
        ELSE IF (KEYW.EQ.KRET) THEN
          IWD1(IND1) = 116*128 + NC1
        ELSE
          GO TO 170
        ENDIF
        NDATA = NDATA + 1
+SELF, IF=-CRAY.
        IDATA(NDATA) = IWORD1
+SELF, IF=CRAY.
        IDATA(NDATA) = IWD1(2)
        IDATA(NDATA) = MSBYT (IWD1(1), IDATA(NDATA), 17, 16)
+SELF.
        GO TO 999
      ENDIF
*
   80 IF (KTWO.NE.' ') THEN
*
* ***   Bit 31 = 1
*
        IWD1(IND1) = 16384
        NWI    = 2
        CALL DBIFRC (KTWO, IDATA(NDATA+2), 1, 3)
      ENDIF
*
      IF (KONE.EQ.'C') THEN
        ICOM = 4
      ELSE IF (KONE.EQ.'c') THEN
        ICOM = 8
      ELSE IF (KONE.EQ.'*') THEN
        ICOM = 12
      ELSE
        ICOM = 0
      ENDIF
      IF (ICOM.NE.0) THEN
*
* ***   Bit 32 = 1  and bits 1-4 = 4 or 8 or 12 depending
* ***                  upon KONE = C or c or *
*
+SELF, IF=APOLLO,UNIX.
        IWD1(IND1) = IWD1(IND1) + 32768
+SELF, IF=VAX,IBM.
        IWORD1  = MSBIT1 (IWORD1, 32)
+SELF, IF=CRAY.
        IWD1(1) = MSBIT1 (IWD1(1), 16)
+SELF.
*
        IWD1(IND2) = ICOM
*
        IF (KTWO.EQ.'.')THEN
*
* ***     Bit 2 =1 and Bit 31 = 0
*
+SELF, IF=APOLLO,UNIX.
          IWD1(IND1) = 32768
+SELF, IF=VAX,IBM.
          IWORD1  = MSBIT0 (IWORD1, 31)
+SELF, IF=CRAY.
          IWD1(1) = MSBIT0 (IWD1(1), 15)
+SELF.
          NWI = 1
          IWD1(IND2) = IWD1(IND2) + 2
        ENDIF
        IF (ILASTW.LE.2)                    GO TO 170
*
*  **   Is there a box ?
*  **   Look for last isolated character
*
        LEN2 = LENOCC (KLINE(:(LENGTH-1)))
        IF ((LENGTH-LEN2).GT.7) THEN
*
*  **     A box is there ====> Bit 1 =1
*
          IWD1(IND2) = IWD1(IND2) + 1
          ILASTW = (LEN2+3)/4
          CALL DBIFCH (KLINE(LENGTH:LENGTH), IKLIN)
          IWD2(IND2) = LENGTH*256 + IKLIN
*
*  **     Look for the first isolated character
*
          NC1   = (IFIRW-1)*4+1
          NC2   = NC1+3
          NKAR  = 0
          DO 90 IC = NC1, NC2
            IF (KLINE(IC:IC).EQ.' ')        GO TO 90
            IPOS = IC
            NKAR = NKAR+1
   90     CONTINUE
          IF (NKAR.EQ.1) THEN
            DO 100 IST = IFIRW+1, ILASTW
              IF (LINE(IST).EQ.KBLAN)       GO TO 100
              IFIRW = IST
              CALL DBIFCH (KLINE(IPOS:IPOS), IKLIN)
              IWD2(IND1) = IPOS*256 + IKLIN
              GO TO 110
  100       CONTINUE
          ENDIF
  110     NWI=NWI+1
+SELF, IF=-CRAY.
          IDATA(NDATA+NWI) = IWORD2
+SELF, IF=CRAY.
          IDATA(NDATA+NWI) = IWD2(2)
          IDATA(NDATA+NWI) = MSBYT (IWD2(1), IDATA(NDATA+NWI), 17, 16)
+SELF.
        ENDIF
*
*  **   Is any character repeated ?
*
        IF (ILASTW.EQ.1)                    GO TO 170
        DO 120 I = IFIRW+2, ILASTW-1
          IF (LINE(I).NE.LINE(I-1))         GO TO 170
  120   CONTINUE
*
*  **   Are the characters identical ?
*  **   NFCOL2 = first column number of the second non-blank character
*  **   NLCOL2 = last    "      "             "       "         "
*
        NFCOL2 = IFIRW*4+1
        NLCOL2 = NFCOL2+3
        DO 130 I = NFCOL2+1, NLCOL2
          IF (KLINE(I:I).NE.KLINE(I-1:I-1)) GO TO 170
  130   CONTINUE
        CAR    = KLINE(NFCOL2:NFCOL2)
*
*  **   Check whether the non-blank characters in the first and
*  **   the last word are also identical to CAR
*
        NFCOL  = (IFIRW-1)*4 + 1
        NLCOL  = NFCOL + 3
        NFIRST = NFCOL
        DO 150 J = 1, 2
          DO 140 I = NFCOL, NLCOL
            IF (KLINE(I:I).EQ.' ') THEN
              IF (J.EQ.1) NFIRST = I + 1
              GO TO 140
            ENDIF
            IF (KLINE(I:I).NE.CAR)          GO TO 170
            NLAST = I
  140     CONTINUE
          NFCOL = (ILASTW-1)*4 + 1
          NLCOL = NFCOL + 3
  150   CONTINUE
*
*  **   All characters are identical
*  **   NFIRST = number of the first non-blank character
*  **   NLAST  =   "           last     "         "
*
        IWD1(IND1) = IWD1(IND1) + NLAST*128 + NFIRST
        CALL DBIFCH (CAR, IKLIN)
        IWD1(IND2) = IWD1(IND2) + 256*IKLIN
+SELF, IF=-CRAY.
        IDATA(NDATA+1) = IWORD1
+SELF, IF=CRAY.
        IDATA(NDATA+1) = IWD1(2)
        IDATA(NDATA+1) = MSBYT (IWD1(1), IDATA(NDATA+1), 17, 16)
+SELF.
        NDATA = NDATA + NWI
        GO TO 999
      ELSE IF (KONE.NE.'%' .AND. KONE.NE.'+' .AND. KLINE(6:6).EQ.' '
     +   .AND. LENGTH.GT.7) THEN
*
*  **   For cases : CONTINUE , END and RETURN preceded by a label,
*  **   use code in bits 24 to 30 = 117 , 119 or 115
*
        NC1    = 7
  160   IF (KLINE(NC1:NC1).EQ.' ') THEN
          NC1  = NC1 + 1
          GO TO 160
        ENDIF
        IF (LENGTH-NC1.GT.7)                GO TO 170
        KEYW   = KLINE(NC1:LENGTH)
        CALL CLTOU (KEYW(:LENGTH-NC1+1))
        IF (KEYW.EQ.KEND) THEN
          IWD1(IND1) = IWD1(IND1) + 119*128 + NC1
        ELSE IF(KEYW.EQ.KCONT) THEN
          IWD1(IND1) = IWD1(IND1) + 117*128 + NC1
        ELSE IF(KEYW.EQ.KRET) THEN
          IWD1(IND1) = IWD1(IND1) + 115*128 + NC1
        ELSE
          GO TO 170
        ENDIF
        CALL DBIFCH (KLINE(5:5), IKLIN)
        IWD1(IND2) = IWD1(IND2) + 256*IKLIN
+SELF, IF=-CRAY.
        IDATA(NDATA+1) = IWORD1
+SELF, IF=CRAY.
        IDATA(NDATA+1) = IWD1(2)
        IDATA(NDATA+1) = MSBYT (IWD1(1), IDATA(NDATA+1), 17, 16)
+SELF.
        NDATA = NDATA+NWI
        GO TO 999
      ENDIF
  170 CONTINUE
      IWD1(IND1) = IWD1(IND1) + ILASTW*128 + IFIRW
+SELF, IF=-CRAY.
      IDATA(NDATA+1) = IWORD1
+SELF, IF=CRAY.
      IDATA(NDATA+1) = IWD1(2)
      IDATA(NDATA+1) = MSBYT (IWD1(1), IDATA(NDATA+1), 17, 16)
+SELF.
      IF (ILASTW.EQ.1) THEN
        NDATA = NDATA + NWI
        GO TO 999
      ENDIF
      CALL DBIFRC (CLINE, ILINE, ILASTW, 4*ILASTW)
      DO 180 IW = IFIRW, ILASTW
        JW    = NDATA + NWI + IW - IFIRW + 1
        IDATA(JW) = ILINE(IW)
  180 CONTINUE
      NDATA = JW
*                                                             END DBLINC
  999 END
+DECK, DBLIND, IF=-$P3CHILD.
      SUBROUTINE DBLIND (IDATA, NTOT, CLINE, LENGTH)
*     ==============================================
*
************************************************************************
*                                                                      *
*        SUBR. DBLIND (IDATA, *NTOT*, CLINE*, LENGTH*)                 *
*                                                                      *
*   Decodes an encdoed array into a string of characters               *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDATA    Array containing the encoded information                *
*     *NTOT*   Current location of the array IDATA to be decoded       *
*     CLINE(*) Character string of maximum 80 characters               *
*     LENGTH(*)Length of the string                                    *
*                                                                      *
*   Called by DBABRD, DBRHLP, DBAIRD                                   *
*                                                                      *
*   Original Code : DPLINE in CMZ Package                              *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
      CHARACTER       CLINE*(*), KLINE*80
      DIMENSION       LINE(20), IDATA(9)
      CHARACTER*8     KEYW(13)
      CHARACTER*1     CAR, KONE, KTWO*(3)
      DIMENSION       NCHKEY(13)
+SELF, IF=IBM.
      CHARACTER       CHIBM*4
      INTEGER*4       ICIBM
      EQUIVALENCE     (CHIBM, ICIBM)
      DATA            ICIBM /Z5F6AC0D0/
+SELF.
*
      DATA            KEYW /'RETURN','RETURN','CONTINUE','END','END',
     +                      '+SELF.','+SEL','+CDE','+SEQ','+KEE','+DEC',
     +                      'ELSE','ENDIF'/
      DATA            NCHKEY /6, 6, 8, 3, 3, 6, 4, 4, 4, 4, 4, 4, 5/
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
      ICADRE = 0
      IWORD  = IDATA(NTOT+1)
      IF (IWORD.EQ.0) THEN
        LENGTH = 0
        CLINE  = ' '
        NTOT   = NTOT + 1
        GO TO 999
      ENDIF
*
      LENGTH = 0
      KLINE  = ' '
      IBIT31 = JBIT (IWORD, 31)
      IBIT32 = JBIT (IWORD, 32)
      IF (IBIT31.NE.0) THEN
        ITWO   = IDATA(NTOT+2)
        NWI    = 2
        CALL DBCFRI (ITWO, KTWO, 1, 3)
      ELSE
        KTWO   = ' '
        NWI    = 1
      ENDIF
      KCODE  = JBYT (IWORD, 1, 8)
      IF (IBIT32.NE.0) THEN
*
* ***   Study the comment cards
*
        ICODE  = KCODE
        ICADRE = MOD (ICODE, 2)
        IPOINT = MOD (ICODE, 4)
        ICMMNT = ICODE/4
        IF (ICMMNT.EQ.1) THEN
          KONE   = 'C'
        ELSE IF (ICMMNT.EQ.2) THEN
          KONE   = 'c'
        ELSE
          KONE   = '*'
        ENDIF
        IF (IPOINT.GT.1) THEN
          KTWO   = '.'
        ENDIF
        KLINE  = KONE//KTWO
        LENGTH = 4
*
*  **   Is there a box ?
*
        IF (ICADRE.NE.0) THEN
          NWI    = NWI + 1
          IPOS1  = JBYT (IDATA(NTOT+NWI), 25, 8)
          IPOS2  = JBYT (IDATA(NTOT+NWI),  9, 8)
          IKLIN  = JBYT(IDATA(NTOT+NWI),1,8)
          CALL DBCHFI (IKLIN, KLINE(IPOS2:IPOS2))
          LENGTH = IPOS2
          IF (IPOS1.NE.0) THEN
            IKLIN  = JBYT(IDATA(NTOT+NWI),17,8)
            CALL DBCHFI (IKLIN, KLINE(IPOS1:IPOS1))
          ENDIF
        ENDIF
*
* ***   Is there a character to repeat?
*
        ICAR   = JBYT (IWORD, 9, 8)
        IF (ICAR.EQ.0) THEN
*
*  **     No character to repeat.
*
          IFWORD = JBYT (IWORD, 17, 7)
          ILASTW = JBYT (IWORD, 24, 7)
          IF (ILASTW.EQ.1) THEN
            NTOT   = NTOT + NWI
            GO TO 70
          ENDIF
*
          IF (ILASTW.GT.20 .OR. IFWORD.GT.ILASTW) GO TO 100
*
          DO 10 IW = IFWORD, ILASTW
            JW     = NTOT + NWI + IW - IFWORD + 1
            LINE(IW) = IDATA(JW)
   10     CONTINUE
          NTOT   = JW
          GO TO 60
        ELSE
*
*  **     Character must be repeated.
*
          CALL DBCHFI (ICAR, CAR)
          IFIRST = JBYT (IWORD, 17, 7)
          ILAST  = JBYT (IWORD, 24, 7)
*
          IF (ILAST.GT.80 .OR. IFIRST.GT.ILAST)   GO TO 100
*
          DO 20 I = IFIRST, ILAST
            KLINE(I:I) = CAR
   20     CONTINUE
          NTOT   = NTOT + NWI
          IF (ICADRE.EQ.0) LENGTH = ILAST
          GO TO 70
        ENDIF
      ELSE
*
* ***   Special cases
*
        ICODE  = JBYT (IWORD, 24, 7)
        ICOD   = ICODE - 114
*
*  **   Case ENDIF or ELSE or END or CONTINUE or RETURN
*  **   Case +PATCH,+DECK,+KEEP,+SEQ,+CDE,+SELF
*
*        ICODE = 115  ICOD = 1  'RETURN with label'
*              = 116       = 2  'RETURN without label'
*              = 117         3  'CONTINUE'
*              = 118         4  'END without label'
*              = 119         5  'END with label'
*              = 120         6  '+SELF.'
*              = 121         7  '+SELF,'
*              = 122         8  '+CDE'
*              = 123         9  '+SEQ'
*              = 124        10  '+KEEP,'
*              = 125        11  '+DECK,'
*              = 126        12  'ELSE'
*              = 127        13  'ENDIF'
*
        IF (ICOD.LE.0)                            GO TO 40
        IF (ICOD.LT.6 .OR. ICOD.GT.11) THEN
          IFIRST = JBYT (IWORD, 17, 7)
          CLINE(1:IFIRST) = ' '
          IF (ICOD.EQ.1 .OR. ICOD.EQ.3 .OR. ICOD.EQ.5) THEN
            CALL DBCHFI (KCODE, KONE)
            IKLIN = JBYT (IWORD, 9, 8)
            CALL DBCHFI (IKLIN, CLINE(5:5))
            CLINE(:4)  = KONE//KTWO
          ENDIF
          LENGTH = IFIRST+NCHKEY(ICOD)-1
          CLINE(IFIRST:LENGTH) = KEYW(ICOD)
          NTOT   = NTOT + NWI
          GO TO 900
        ENDIF
*
* ***   Case +PATCH,+DECK,+KEEP,+SEQ,+CDE,+SELF
*
        IF (ICOD .EQ. 6) THEN
          CLINE(:6) = '+SELF.'
          NTOT   = NTOT + 1
          LENGTH = 6
          GO TO 900
        ENDIF
*
        IFWORD = 2
        KLINE(1:4) = KEYW(ICOD)
        ILASTW = JBYT (IWORD, 17, 7)
        DO 30 IW = 2, ILASTW
          LINE(IW) = IDATA(NTOT+IW)
   30   CONTINUE
        NTOT   = NTOT + ILASTW
        GO TO 60
      ENDIF
*
   40 CONTINUE
*
* *** Normal instructions
*
      CALL DBCHFI (KCODE, KONE)
      KLINE  = KONE//KTWO
      ILASTW = ICODE
      IF (ILASTW.LT.2) THEN
        NTOT   = NTOT+NWI
        LENGTH = 4
        GO TO 70
      ENDIF
      IFWORD = JBYT (IWORD, 17, 7)
*
      IF (ILASTW.GT.20 .OR. IFWORD.GT.ILASTW)     GO TO 100
*
      DO 50 IW = IFWORD, ILASTW
        JW     = NTOT + NWI + IW - IFWORD + 1
        LINE(IW) = IDATA(JW)
   50 CONTINUE
      NTOT   = JW
   60 CONTINUE
      NC     = (IFWORD-1)*4 + 1
      LENGW  = ILASTW-IFWORD+1
      LENG   = 4*LENGW
      CALL DBCFRI (LINE(IFWORD), KLINE(NC:), LENGW, LENG)
      IF (ICADRE.EQ.0) LENGTH = ILASTW*4
   70 I1     = LENGTH
      DO 80 I = I1, 1, -1
        IF (KLINE(I:I).NE.' ')                    GO TO 90
        LENGTH = LENGTH - 1
   80 CONTINUE
*
   90 CLINE  = KLINE(1:LENGTH)
      GO TO 900
*
  100 CALL DBPRNT (LPRTDB, '('' **** WARNING : Data in deck is corrup'//
     +     'ted ****'')', IARGDB, 0)
      CLINE  = ' '
      LENGTH = 0
  900 CONTINUE
+SELF, IF=IBM.
*
* *** Special patch up for old data inserted on IBM with wrong table
*
      IF (KEYVDK(7).LT.58415125) THEN
        DO 910 I = 1, LENGTH
          IF (CLINE(I:I).EQ.'~') THEN
            CLINE(I:I) = CHIBM(1:1)
          ELSE IF (CLINE(I:I).EQ.'^') THEN
            CLINE(I:I) = CHIBM(2:2)
          ENDIF
  910   CONTINUE
      ENDIF
+SELF.
*                                                             END DBLIND
  999 END
+DECK, DBNODE.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBNODE (PATH, LBN)
*     =============================
*
************************************************************************
*                                                                      *
*        SUBR. DBNODE (PATH, LBN*)                                     *
*                                                                      *
*   Creates a Node structure in memory for given directory pathname    *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATH     Character string describing the pathname                *
*     LBN      L-address of the lowest level Node bank                 *
*                                                                      *
*   Called by DBABRD, DBABWR, DBENTR, DBGET,  DBGETS, DBPURK, DBREPL,  *
*             DBUSE                                                    *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 11 : Pathname not found in the RZ directory          *
*               = 12 : Illegal pathname                                *
*               = 13 : Not enough structural link to support a new Node*
*               = 14 : No space available to create bank NODB          *
*               = 15 : Cannot define IO descriptor for Key bank        *
*               = 16 : Cannot find appropriate top directory           *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
      PARAMETER       (NLEVM=20, NWFXM=6, MAXD=1)
      CHARACTER       CHFRM(5)*1, CFORM*80, CHCUR(NLEVM)*1
      CHARACTER       FPATH*80, FTEMP*80, FTMP1*80, CNODE(20)*16, CHL*16
      CHARACTER       PATH*(*)
      INTEGER         NUCUR(NLEVM), NCHL(NLEVM), LBN(9)
      DATA            CHFRM / 'B', 'I', 'F', 'D', 'H'/,  NZ / 0/
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Get the full pathname
*
      LREFDB(2) = LBN(1)
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1) .NE. 0)  THEN
        IQUEST(1) = 11
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          FPATH  = PATH
          CALL DBPRNT (LPRTDB, '(/,'' DBNODE : Pathname '//FPATH//' n'//
     +         'ot found in RZ directory'')', IARGDB, 0)
        ENDIF
+SELF.
        GO TO 999
      ENDIF
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      CALL RZCDIR (FPATH, 'R')
*
* *** Get list of Nodes
*
      NODES  = 0
      I0     = 0
   10 I1     = I0 + 1
      IF (I1.GT.MAXLDB)          GO TO 35
      DO 15 I0 = I1, MAXLDB
        IF (FPATH(I0:I0).EQ.' ') GO TO 25
        IF (FPATH(I0:I0).EQ.'/') GO TO 20
   15 CONTINUE
      I0     = MAXLDB + 1
   20 I2     = I0 - 1
      GO TO 30
   25 I2     = I0 - 1
      I0     = MAXLDB + 1
   30 IF (I2.LT.I1)              GO TO 10
      NODES  = NODES + 1
      CNODE(NODES) = FPATH(I1:I2)
      NCHL (NODES) = I2 - I1 + 1
      GO TO 10
*
* *** Number of Nodes found should be nonzero
*
   35 IF (NODES.EQ.0)  THEN
        IQUEST(1) = 12
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNODE : Illegal'//
     +  ' pathname '//FPATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
* *** Find the appropriate top-directory bank
*
      LTOP   = LTOPDB
   40 IF (LTOP.NE.0)  THEN
        NCH    = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, CHL, NCH)
        CHL    = CHL(1:NCH)
        IF (CHL.EQ.CNODE(1)) THEN
          IFLG   = IQ(KOFUDB+LTOP+MUPFLG)
          ITOP   = IQ(KOFUDB+LTOP+MUPDIC)
          LBFXDB = LTOP
          LBKYDB = LQ(KOFUDB+LTOP-KLDICT)
          IF (LBKYDB.GT.0) THEN
            NITEM  = IQ(KOFUDB+LBKYDB+MDCNTM)
          ELSE
            NITEM  = 0
          ENDIF
        ELSE
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 40
        ENDIF
      ELSE
        IQUEST(1) = 16
        IQUEST(11)= NODES
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNODE : Cannot '//
     +  'find top directory '//CNODE(1)//' in tree with'',I6,'' names'//
     +  ' '')', IQUEST(11), 1)
+SELF.
        GO TO 999
      ENDIF
*
*  ** Check if all Nodes already exist in memory
*
      IN     = 0
   45 IN     = IN + 1
*
*  ** Construct the pathname from the Node names
*
      NCHAR  = 1
      FPATH  = '/'
      DO 50 I = 1, IN
        CHL    = CNODE(I)
        NMAX   = NCHL (I)
        IF (NCHAR+NMAX .GT. MAXLDB) THEN
          NMAX  = MAXLDB - NCHAR - 1
          IF (NMAX.LE.0)         GO TO 50
        ENDIF
        FPATH  = FPATH(1:NCHAR)//'/'//CHL(1:NMAX)
        NCHAR  = NCHAR + NMAX + 1
        IF (NCHAR.EQ.MAXLDB)     GO TO 55
   50 CONTINUE
*
*  ** The first Node should be at the top directory
*
   55 I0     = 0
      IF (IN.EQ.1) THEN
        NMAX   = 1
      ELSE
        NMAX   = IQ(KOFUDB+LREFDB(2)-2)
      ENDIF
*
   60 I0     = I0 + 1
*
*  *  No link left to insert a new Node bank
*
      IF (I0.GT.NMAX)  THEN
        IF (IN.EQ.1.OR.IFLG.EQ.0)  THEN
          IQUEST(1) = 13
          IQUEST(11)= IN
          IQUEST(12)= NODES
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNODE : No li'//
     +    'nk left to insert the Node '//CNODE(IN)//' at level '',I3'//
     +    ','' out of '',I3)', IQUEST(11), 2)
+SELF.
          GO TO 999
*
        ELSE
*
          CALL MZPUSH (IDIVDB, LREFDB(2), 1, 0, ' ')
          LSAVDB = LREFDB(2)
          JBIAS  = -I0
          IDIC   = 0
          GO TO 75
        ENDIF
      ENDIF
*
      IF (IN.EQ.1)  THEN
        LSAVDB = LQ(KOFUDB+LBFXDB-1)
      ELSE
        LSAVDB = LQ(KOFUDB+LREFDB(2)-I0)
      ENDIF
*
*  *  Check the full pathname in the Node bank name against
*  *  the current pathname
*
      IF (LSAVDB.NE.0)  THEN
        MCHAR  = IQ(KOFUDB+LSAVDB+MNDNCH)
        IF (MCHAR.GT.MAXLDB) MCHAR  = MAXLDB
        CALL UHTOC (IQ(KOFUDB+LSAVDB+MNDNAM), 4, FTMP1, MCHAR)
        FTEMP  = FTMP1(1:MCHAR)
        IF (FTEMP.NE.FPATH)      GO TO 60
        GO TO 90
      ELSE
*
*  *    Find the dictionary number
*
        IF (IN.EQ.1)  THEN
          IDIC   = ITOP * 10000
          LSAVDB = LBFXDB
          JBIAS  = -1
        ELSE
          LSAVDB = LREFDB(2)
          JBIAS  = -I0
          IDIC   = ITOP * 10000
          IF (NITEM.GT.0) THEN
            FTEMP  = FPATH(NCHL(1)+3:NCHAR)
            MCHAR  = NCHAR - NCHL(1) - 2
            DO 65 ITEM = 1, NITEM
              IPNT   = KOFUDB + LBKYDB + (ITEM - 1) * NWITDB + 1
              IF (IQ(IPNT+MDCITM).GT.0) THEN
                IF (MCHAR.EQ.IQ(IPNT+MDCNCH)) THEN
                  CALL UHTOC (IQ(IPNT+MDCNAM), 4, FTMP1, MCHAR)
                  FTMP1  = FTMP1(1:MCHAR)
                  IF (FTEMP.EQ.FTMP1) THEN
                    IDIC   = IDIC + IQ(IPNT+MDCITM)
                    GO TO 70
                  ENDIF
                ENDIF
              ENDIF
   65       CONTINUE
          ENDIF
   70     CONTINUE
        ENDIF
      ENDIF
*
*  *  The Node bank does not exist; create it
*
   75 ND     = NCHAR/4
      IF (NCHAR.GT.ND*4) ND = ND + 1
      ND     = ND + NWNODB + 4
      CALL RZCDIR (FPATH, ' ')
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      CALL RZRDIR (MAXD, FTMP1, NL)
      IF (IQUEST(1).EQ.1) NL = IQUEST(11)
      IF (NKEYDK.GT.0) THEN
        IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)
        IOPTP  = JBIT (IOPTP, JPRTDB)
        IF (IOPTP.NE.0) THEN
          NL     = NL - NKEYDK
          IF (NL.LT.0) NL = 0
        ENDIF
      ENDIF
*
      CALL DBBOOK (IDIVDB, LA, LSAVDB, JBIAS, 'NODB', NL, NL, ND,
     +             IONODB, NZ)
      IF (IQUEST(1).NE.0)  THEN
        IQUEST(1) = 14
        IQUEST(11)= IN
        IQUEST(12)= NODES
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBNODE : No sp'//
     +  'ace in memory to create Node bank '//CNODE(IN)//' at level'//
     +  ' '',I3,'' out of '',I3)', IQUEST(11), 2)
+SELF.
        GO TO 999
      ENDIF
*
*  *  Find IO descriptor for the Key banks attached to this Node
*
      NLEV   = 0
      NCUR   = 0
      IFORO  = 0
      CALL DBKEYT
      DO 80 I = 1, NWKYDK
        IFORM  = IOTYDK(I)
        IF (IFORM.EQ.6) IFORM = 5
        IF (IFORM.EQ.IFORO)  THEN
          NCUR   = NCUR + 1
        ELSE
          IF (NLEV.GT.0) NUCUR(NLEV) = NCUR
          IF (NLEV.GE.NLEVM)  THEN
            IQUEST(1) = 15
            IQUEST(11)= I
            IQUEST(12)= NLEVM
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) THEN
              IARGDB(1) = IQUEST(12)
              IARGDB(2) = IQUEST(11)
              CALL DBPRNT (LPRTDB, '(/,'' DBNODE : Too many type of'//
     +             ' variables for IO descriptor of Key bank at Key'//
     +             ' '',I3,'' Maximum level '',I3)', IARGDB, 2)
            ENDIF
+SELF.
            GO TO 999
          ENDIF
          NLEV   = NLEV + 1
          CHCUR(NLEV) = CHFRM(IFORM)
          NCUR   = 1
          IFORO  = IFORM
        ENDIF
   80 CONTINUE
*
      IF (NLEV.GT.0)  THEN
        NUCUR(NLEV) = NCUR
        IF (CHCUR(NLEV).EQ.CHFRM(2))  THEN
          NUCUR(NLEV) = NCUR + NWFXM
        ELSE
          IF (NLEV.GE.NLEVM)  THEN
            IQUEST(1) = 15
            IQUEST(11)= NWKYDK + 1
            IQUEST(12)= NLEVM
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) THEN
              IARGDB(1) = IQUEST(12)
              IARGDB(2) = IQUEST(11)
              CALL DBPRNT (LPRTDB, '(/,'' DBNODE : Too many type of'//
     +             ' variables for IO descriptor of Key bank at Key'//
     +             ' '',I3,'' Maximum level '',I3)', IARGDB, 2)
            ENDIF
+SELF.
            GO TO 999
          ENDIF
          NLEV   = NLEV + 1
          CHCUR(NLEV) = CHFRM(2)
          NUCUR(NLEV) = NWFXM
        ENDIF
      ELSE
        NLEV   = 1
        CHCUR(NLEV) = CHFRM(2)
        NUCUR(NLEV) = NWFXM
      ENDIF
*
+SELF, IF=-IBM, -$P3CHILD.
      WRITE (CFORM, 2001) (NUCUR(I), CHCUR(I), I = 1, NLEV)
+SELF, IF=IBM, IF=$P3CHILD.
      CFORM  = ' '
      II     = 1
      DO 81 I = 1, NLEV
        CALL UTWRIT (CFORM(II:II+1), '(I2)', NUCUR(I))
        II     = II + 2
        CFORM(II:II) = CHCUR(I)
        II     = II + 2
   81 CONTINUE
+SELF.
      I      = 4*NLEV
*
      LSAVDB = LA
      IQ(KOFUDB+LSAVDB+MNDNWK) = NWKYDK
      IQ(KOFUDB+LSAVDB+MNDNWD) = NWKYDK + NWFXM
      IQ(KOFUDB+LSAVDB+MNDNCH) = NCHAR
      IQ(KOFUDB+LSAVDB+MNDDIC) = IDIC
      CALL MZIOCH (IQ(KOFUDB+LSAVDB+MNDIOF), NWNODB, CFORM(1:I))
      CALL UCTOH (FPATH, IQ(KOFUDB+LSAVDB+MNDNAM), 4, NCHAR)
*
   90 LBN(1) = LSAVDB
      LREFDB(2) = LSAVDB
      LSAVDB = 0
      IF (IN.LT.NODES)           GO TO 45
*
* *** The Node exists; Normal return
*
  100 IQUEST(1) = 0
+SELF, IF=-IBM, -$P3CHILD.
*
 2001 FORMAT (20(I2,A1,1X))
+SELF.
*                                                             END DBNODE
  999 END
+DECK, DBOPTS.
      SUBROUTINE DBOPTS (CHOPT)
*     =========================
*
************************************************************************
*                                                                      *
*        SUBR. DBOPTS (CHOPT)                                          *
*                                                                      *
*   Decode the character option and fill up the common block /DAOPTS/  *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     CHOPT    Character option supplied by user                       *
*                                                                      *
*   Called by various routines in the DBL3 package                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 91 : Illegal Character Option                        *
*                                                                      *
************************************************************************
*
+CDE, DAOPTI.
+CDE, DAOPTS.
+CDE, DBSTOR.
      CHARACTER       CHOPT*(*), CTEST*1, BLANK*1, CTMP*80
      DIMENSION       ICOPT(300), IALFA(55)
      EQUIVALENCE     (IALFA(1), IOPADA)
      DATA            BLANK / ' '/
*
*     ------------------------------------------------------------------
*
      IQUEST(1) = 0
      DO 5 K = 1, 26+29
        IALFA(K) = 0
    5 CONTINUE
*
* *** Convert CHOPT into a list of integer variables
*
      MAXL   = LEN (CHOPT)
      I1     = 0
      DO 20 I0 = 1, MAXL
        CTEST  = CHOPT(I0:I0)
        DO 10 I = 1, 62
          IF (CTEST.EQ.CALFDA(I)) GO TO 15
   10   CONTINUE
        IF (CTEST.NE.BLANK)       GO TO 991
        GO TO 20
   15   I1     = I1 + 1
        IF (I.GT.36) I = I - 36
        ICOPT(I1) = I
   20 CONTINUE
      MAXU   = I1
*
* *** Now fill up the common /DAOPTS/
*
      I0     = 0
   30 I0     = I0 + 1
      IF (I0.GT.MAXU)             GO TO 999
      I      = ICOPT(I0)
*
*  ** Alphabetic options
*
      IF (I.LE.26) THEN
        IALFA(I) = 1
        GO TO 30
      ENDIF
*
*  ** Numeric options (at the moment 3-29 only)
*  ** If first digit = 1 or 2, it has to be a 2 digit number
*  **                = 3 .. 9, it can only be one digit number
*  ** First digit can never be 0.
*
      I1     = I - 27
      IF (I1.EQ.0)                GO TO 991
      IF (I1.GE.3.AND.I1.LE.9) THEN
        IOKYDA(I1) = 1
        GO TO 30
      ENDIF
      IF (I0.GE.MAXU)             GO TO 991
      I      = ICOPT(I0+1) - 27
      IF (I.LT.0)                 GO TO 991
      IOKYDA(I1*10+I) = 1
      I0     = I0 + 1
      GO TO 30
*
* *** Illegal Character option
*
  991 IQUEST(1)  = 91
      IQUEST(11) = I0
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) THEN
        CTMP   = CHOPT
        CALL DBPRNT (LPRTDB, '('' DBOPTS : Illegal Character option a'//
     +       'fter '',I2,'' in '//CTMP//''')', IQUEST(11), 1)
      ENDIF
+SELF.
*                                                             END DBOPTS
  999 END
+DECK, DBPACK.
      SUBROUTINE DBPACK (IAIN, LIN, LOU, LAUX, LBITL, IAOU, IAUX)
*     ===========================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBPACK (IAIN, LIN, LOU*, LAUX*, LBITL, IAOU*, IAUX)     *
*                                                                      *
*   Compresses data from 32 to LBITL bit size                          *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IAIN     Input array                                             *
*     LIN      Length of the input array                               *
*     LOU(*)   Length of the output array                              *
*     LAUX(*)  Number of words exceeding the length LBITL and therefore*
*              are stored in 32 bits with locations given              *
*     LBITL    Number of bits to be used for storing                   *
*     IAOU(*)  Output array                                            *
*     IAUX     Auxiliary array for internal working space              *
*                                                                      *
*   Called by DBCMPR                                                   *
*                                                                      *
************************************************************************
*
      DIMENSION       IAIN(LIN), IAOU(LIN), IAUX(LIN)
      DIMENSION       IHB(33), LHB(32), AHB(32)
      DATA            MINBIT /2/  , IBIG /9999999/
+SEQ, L3BITX, T=PASS.
*
*     ------------------------------------------------------------------
*
      CALL VZERO (IHB, 33)
      CALL VZERO (IAOU, LIN)
      CALL VFILL (LHB, 32, IBIG)
*
* *** Histogram of the input stream bit-length
*
      DO 3 I = 1, LIN
        DO 1 J = 1, 32
          J1    = 33 - J
          IF (JBIT(IAIN(I),J1).EQ.1) GO TO 2
    1   CONTINUE
    2   IHB(J1) = IHB(J1) + 1
    3 CONTINUE
*
* *** Look for the minimum storage length
*
      NW    = 0
      JJ    = 33 - MINBIT
      DO 4 J = 1, JJ
        J1    = 33 - J
        NW    = NW + IHB(J1+1)
        LHB(J1) = (LIN*J1-1)/32 + 2*NW
    4 CONTINUE
*
      CALL VFLOAT (LHB, AHB, 32)
      LBITL = LVMIN (AHB, 32)
      IF (LHB(LBITL)+1.GE.LIN)       GO TO 991
*
      ICOMP = LBITL + 1
      NCOMP = 32 - LBITL
*
* *** Pack the input with LBITL byte size
* ***    (If input is longer then LBITL, write it in a separate
* ***     output word at the end of the buffer)
*
      LAUX  = 0
      LOU   = 1
      IN    = 1
      IB    = 1
   11 CONTINUE
      IF (NCOMP.GT.0) THEN
        ICHECK = JBYT (IAIN(IN), ICOMP, NCOMP)
      ELSE
        ICHECK = 0
      ENDIF
      IBA   = IB + LBITL
      IF (IBA.LE.32) THEN
        IF (LBITL.GT.0)
     +  IAOU(LOU) = MSBYT (IAIN(IN), IAOU(LOU), IB, LBITL)
        IB = IBA
      ELSE
        LBIT1 = 32 - IB + 1
        IF (LBIT1.GT.0)
     +  IAOU(LOU) = MSBYT (IAIN(IN), IAOU(LOU), IB, LBIT1)
*       ITEST = JBYT (IAOU(LOU), IB, LBIT1)
        IB    = IBA - 32
        LOU   = LOU + 1
        IF (IB.GT.1)
     +    IAOU(LOU) = MCBYT (IAIN(IN), LBIT1+1, IAOU(LOU), 1, IB-1)
*       ITEST = MSBYT (IAOU(LOU), ITEST, LBIT1+1, IB-1)
      ENDIF
      IF (ICHECK.NE.0) THEN
        IF (LAUX+2.GT.LIN)           GO TO 991
        IAUX(LAUX+1) = IN
        IAUX(LAUX+2) = IAIN(IN)
        LAUX  = LAUX + 2
      ENDIF
      IF (IN.LT.LIN) THEN
        IN    = IN + 1
        GO TO 11
      ENDIF
*
      ICAR  = 0
      IF (IAOU(LOU+1).NE.0) ICAR = IAOU(LOU+1)
      IF (LAUX.GT.0) THEN
        IF (LOU+LAUX.GT.LIN)         GO TO 991
        DO 21 I = 1, LAUX
   21   IAOU(LOU+I) = IAUX(I)
        IF (ICAR.NE.0) IAOU(LIN) = ICAR
        LOU   = LOU + LAUX
      ENDIF
      GO TO 999
*
  991 CONTINUE
      CALL UCOPY (IAIN, IAOU, LIN)
      LOU   = LIN
      LBITL = 32
      LAUX  = 0
*                                                             END DBPACK
  999 END
+DECK, DBPATH.
+SEQ, T=DUMMY, IF=$P3CHILD, IF=IBM.
      SUBROUTINE DBPATH (PATHX, IK)
*     =============================
*
************************************************************************
*                                                                      *
*        SUBR. DBPATH (PATHX*, IK)                                     *
*                                                                      *
*   Get the subdirectory address of a partitioned data set             *
*   from the Subdirectory number                                       *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHX(*) Character string specifying the subdirectory path name  *
*     IK       Subdirectory number                                     *
*                                                                      *
*   Called by various routines in the DBL3 package                     *
*                                                                      *
************************************************************************
*
      CHARACTER       PATHX*(*)
      DATA            I2 / 8/
*
*     ------------------------------------------------------------------
*
+SELF, IF=-IBM, -$P3CHILD.
      WRITE (PATHX, '(I8)') IK
+SELF, IF=IBM, IF=$P3CHILD.
      CALL UTWRIT (PATHX, '(I8)', IK, 1)
+SELF.
      I3     = 10
      DO 10 I = 1, I2
        IF (IK.LT.I3) THEN
          I1     = I2 + 1 - I
          PATHX  = PATHX(I1:I2)
          GO TO 999
        ENDIF
        I3     = I3 * 10
   10 CONTINUE
*                                                             END DBPATH
  999 END
+DECK, DBPRDT.
      SUBROUTINE DBPRDT
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBPRDT                                                  *
*                                                                      *
*   Prints all objects for the current subdirectory                    *
*                                                                      *
*   Called by DBPRIN                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =104 : Read error in getting the RZ date and time      *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
* *** Find the objects to be printed
*
      IOKYDA(MSERDB) = 1
      ITIME  = 0
      JBIAS  = 2
      CALL VZERO (INDKDK, NKEYDK)
      IL     = 1
   10 IN     = IL
      MNKYDT = 0
      DO 20 IK = 1, NKEYDK
        IF (INDKDK(IK).NE.0)                    GO TO 20
        CALL DBKEYR (IK, NWKYDK, KEYVDK)
        IF (MNKYDT.EQ.0)  THEN
          MNKYDT = KEYVDK(MSERDB)
          KEY6DT = KEYVDK(MFLGDB)
        ELSE
          IF (KEYVDK(MPVSDB).NE.KEYNDK(MPVSDB)) GO TO 20
          DO 15 I = 3, NWKYDK
            IF (I.EQ.MFLGDB.OR.I.EQ.MITMDB) THEN
              GO TO 15
            ELSE
              IF (KEYVDK(I).NE.KEYNDK(I))       GO TO 20
            ENDIF
   15     CONTINUE
          IF (MNKYDT.LT.KEYNDK(MSERDB))  THEN
            MNKYDT = KEYNDK(MSERDB)
            KEY6DT = KEYNDK(MFLGDB)
          ENDIF
        ENDIF
        INDKDK(IK) = 1
   20 CONTINUE
*
* *** Now print the objects
*
      IF (MNKYDT.NE.0)  THEN
        KEY6   = JBIT (KEY6DT, JIGNDB)
        IFLG   = 0
        DO 30 IK = IN, NKEYDK
          IF (INDKDK(IK).NE.1)  THEN
            IFLG   = 1
          ELSE
            INDKDK(IK) = 2
            IF (IFLG.EQ.0) IL = IK + 1
            IF (KEY6.EQ.0)  THEN
              CALL DBKEYR (IK, NWKYDK, KEYNDK)
              IF (IOPDDA.NE.0) CALL DBPRNT (LPRTDB, '(//,15X,''======'//
     +        '====== Keys and Time ============'',/)', IARGDB, 0)
              CALL DBPRKY (NWKYDK, KEYNDK, IOTYDK)
              IF (IQUEST(1).NE.0)               GO TO 990
              IF (IOPIDA.NE.0) THEN
                JBIAS  = 2
                CALL RZIN (IDISDB, LDUMM, JBIAS, KEYNDK, 9999, 'C')
                IF (IQUEST(1).NE.0) THEN
                  IQUEST(1) = 104
+SELF, IF=$DEBUG.
                  IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRDT'//
     +            ' : RZIN error in getting the cycle information'')',
     +            IARGDB, 0)
+SELF.
                  GO TO 990
                ENDIF
                INSTM = IQUEST(14)
                CALL RZDATE (INSTM, IARGDB(1), IARGDB(2), 1)
                CALL DBPRNT (LPRTDB, '(12X,''Date : '',I10,''   Time '//
     +               ': '',I10)', IARGDB, 2)
              ENDIF
              IF (IOPDDA.NE.0)  THEN
                LAUXDL(8) = 0
                CALL VZERO (KEYVDK, NWKYDK)
                KEYVDK(MSERDB) = IK
                CALL DBKXIN (ITIME, IDISDB, LAUXDL(8), LAUXDL(8),
     +                       JBIAS, NWKEY, KEYVDK, IPREC)
                IER    = IQUEST(1)
                IF (LAUXDL(8).NE.0) THEN
                  CALL DZSHOW ('*DBPRDT*', IDISDB, LAUXDL(8), 'BLV',
     +                         0, 0, 0, 0)
                  CALL MZDROP (IDISDB, LAUXDL(8), 'L')
                ENDIF
                IQUEST(1) = IER
                IF (IQUEST(1).NE.0)             GO TO 990
              ENDIF
            ENDIF
          ENDIF
   30   CONTINUE
*
        IF (IL.EQ.IN) IL = IN + 1
        IF (IL.LE.NKEYDK)                       GO TO 10
      ENDIF
*
  990 IOKYDA(MSERDB) = 0
*                                                             END DBPRDT
  999 END
+DECK, DBPRKY.
+SEQ, T=DUMMY, IF=$P3CHILD, IF=IBM.
      SUBROUTINE DBPRKY (NW, KY, KT)
*     ==============================
*
************************************************************************
*                                                                      *
*        SUBR. DBPRKY (NW, KY, KT)                                     *
*                                                                      *
*   Prints a vector KY of elements NW according to its type KT         *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     NW       Number of elements in the array KY (and KT)             *
*     KY       Vector to be printed                                    *
*     KT       Type of the vector elements                             *
*          1 - Binary                                                  *
*          2   Integer                                                 *
*          3   Floating                                                *
*          4   Double Precision (not yet implemented)                  *
*          5   Hollerith                                               *
*                                                                      *
*   Called by DBENTB, DBNTOP, DBPRGD, DBENFZ, DBKOUT, DBPRDT           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =103 : Illegal data type                               *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
      CHARACTER       CHPRT*132
      DIMENSION       KY(NW), KT(NW)
*
*     ------------------------------------------------------------------
*
      IPR   = 0
      I1    = 3
      CHPRT = ' '
      DO 10 I = 1, NW
        IPR   = IPR + 1
        IF (IPR.GT.10) THEN
          CALL DBPRNT (LPRTDB, '('''//CHPRT//''')', IARGDB, 0)
          IPR   = 1
          I1    = 3
          CHPRT = ' '
        ENDIF
        KK    = KT(I)
        IF (KK.LT.1.OR.KK.EQ.4.OR.KK.GT.6) GO TO 901
        GO TO (1,2,3,4,5,5), KK
    1   CONTINUE
*
*  **   Binary
*
        I2 = I1 + 11
+SELF, IF=-IBM, -$P3CHILD.
        WRITE (CHPRT(I1:I2), '(2X,Z10)') KY(I)
+SELF, IF=IBM, IF=$P3CHILD.
        CALL UTWRIT (CHPRT(I1:I2), '(2X,Z10)', KY(I), 1)
+SELF.
        I1 = I2 + 1
        GO TO 10
    2   CONTINUE
*
*  **   Integer
*
        I2 = I1 + 11
+SELF, IF=-IBM, -$P3CHILD.
        WRITE (CHPRT(I1:I2), '(2X,I10)') KY(I)
+SELF, IF=IBM, IF=$P3CHILD.
        CALL UTWRIT (CHPRT(I1:I2), '(2X,I10)', KY(I), 1)
+SELF.
        I1 = I2 + 1
        GO TO 10
    3   CONTINUE
*
*  **   Floating
*
        I2 = I1 + 11
+SELF, IF=-IBM, -$P3CHILD.
        WRITE (CHPRT(I1:I2), '(G12.4)') KY(I)
+SELF, IF=IBM, IF=$P3CHILD.
        CALL UTWRIT (CHPRT(I1:I2), '(G12.4)', KY(I), 1)
+SELF.
        I1 = I2 + 1
        GO TO 10
    4   CONTINUE
        GO TO 901
    5   CONTINUE
*
*  **   Hollerith
*
        I2 = I1 + 11
+SELF, IF=-IBM, -$P3CHILD.
        WRITE (CHPRT(I1:I2), '(8X,A4)') KY(I)
+SELF, IF=IBM, IF=$P3CHILD.
        CALL UTWRIT (CHPRT(I1:I2), '(8X,A4)', KY(I), 1)
+SELF.
        I1 = I2 + 1
        GO TO 10
*
   10 CONTINUE
      IF (I1.GT.3) CALL DBPRNT (LPRTDB, '('''//CHPRT//''')', IARGDB, 0)
      IQUEST(1) = 0
      GO TO 999
*
* *** Error codes
*
  901 CONTINUE
      IQUEST(1) = 103
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPRKY : Illegal '//
     +   'data type to be printed = '',I10/)', KK, 1)
+SELF.
      GO TO 999
*                                                             END DBPRKY
  999 END
+DECK, DBPRNT.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBPRNT (LUN, CFORM, IARG, NARG)
*     ==========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBPRNT (LUN, CFORM, IARG, NARG)                         *
*                                                                      *
*   Prints a vector IARG of NARG elements on logical unit LUN          *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUN      Logical unit number of the output                       *
*     CFORM    Format specification                                    *
*     IARG     Array of numbers to be printed                          *
*     NARG     Number of elements in array IARG                        *
*          2   Integer                                                 *
*          3   Floating                                                *
*          4   Double Precision (not yet implemented)                  *
*          5   Hollerith                                               *
*                                                                      *
*   Called by various routines in the DBL3 package                     *
*                                                                      *
************************************************************************
*
      CHARACTER       CFORM*(*)
      DIMENSION       IARG(9)
*
*     ------------------------------------------------------------------
*
+SELF, IF=-$P3CHILD.
      WRITE (LUN, CFORM, ERR=999) (IARG(I), I = 1, NARG)
+SELF, IF=$P3CHILD.
      CALL UTPRNT (LUN, CFORM, IARG, NARG)
+SELF.
*                                                             END DBPRNT
  999 END
+DECK, DBROPN.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBROPN (LUN, CHOPT, CFNAM, NRECL, IOERR)
*     ===================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBROPN (LUN, CHOPT, CFNAM, NRECL, IOERR*)               *
*                                                                      *
*   Opens a random access file                                         *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUN      Logical unit number                                     *
*     CHOPT    Character string with any of the following characters   *
*          O   Output file (default is input)                          *
*          Z   File to be overwritten if exists                        *
*     CFNAM    File name                                               *
*     NRECL    Record length in bytes                                  *
*     IOERR    Error code (0 if no error)                              *
*                                                                      *
*   Called by DBEXAMn                                                  *
*                                                                      *
************************************************************************
*
      DIMENSION       IOPT(2)
      CHARACTER       CHOPT*(*), CFNAM*(*), NAME*80, STATE*10
      EQUIVALENCE     (IOPTO, IOPT(1)), (IOPTZ, IOPT(2))
*
*     ------------------------------------------------------------------
*
* *** Check if Filename is meaningful
*
      NCH    = LENOCC (CFNAM)
      IF (NCH.LT.1)        GO TO 999
      NCHM   = MIN (50, NCH)
+SELF, IF=IBM, IF=-$P3CHILD.
      NAME   = '/'//CFNAM
+SELF, IF=$P3CHILD.
      NAME   = CFNAM
+SELF, IF=IBM, $P3CHILD.
   10 L      = INDEX (NAME, '.')
      IF (L.NE.0) THEN
        NAME(L:L) = ' '
        GO TO 10
      ENDIF
+SELF, IF=-IBM, IF=-$P3CHILD.
      NAME   = CFNAM
+SELF, IF=APOLLO,CRAY,MIP, IF=-$P3CHILD.
      CALL CUTOL (NAME)
+SELF, IF=-$P3CHILD.
*
* *** Analyse the option
*
      CALL UOPTC  (CHOPT, 'OZ', IOPT)
      IF (IOPTZ.NE.0) IOPTO = 1
*
* *** Decide on the record length
*
      IF (NRECL.GT.0) THEN
        NREC   = NRECL
      ELSE
        NREC   = 4096
      ENDIF
+SELF, IF=VAX, IF=-$P3CHILD.
      NBLK   = NREC
      NREC   = NREC/4
+SELF, IF=-$P3CHILD.
*
* *** Decide on state and form
*
      IF (IOPTO.EQ.0) THEN
+SELF, IF=APOLLO, IF=-$P3CHILD.
        STATE  = 'READONLY'
+SELF, IF=-APOLLO, IF=-$P3CHILD.
        STATE  = 'OLD'
+SELF, IF=-$P3CHILD.
      ELSE
        STATE  = 'UNKNOWN'
      ENDIF
*
* *** Now open the file
*
+SELF, IF=IBM, IF=-$P3CHILD.
      CALL FILEINF (IOERR, 'MAXREC', 2)
      IF (IOERR.NE.0)      GO TO 50
      IF (IOPTZ.NE.0) THEN
        OPEN (UNIT=LUN, FILE=NAME, FORM='UNFORMATTED', RECL=NREC,
     +        ACCESS='DIRECT', STATUS=STATE, IOSTAT=IOERR)
        IF (IOERR.NE.0)    GO TO 50
        CLOSE (LUN)
      ENDIF
      CALL FILEINF (IOERR, 'MAXREC', 16777215)
      IF (IOERR.NE.0)      GO TO 50
      OPEN (UNIT=LUN, FILE=NAME, FORM='UNFORMATTED', RECL=NREC,
     +      ACCESS='DIRECT', STATUS=STATE, IOSTAT=IOERR)
      IF (IOERR.NE.0)      GO TO 50
+SELF, IF=APOLLO, CRAY, MIP, IF=-$P3CHILD.
      OPEN (UNIT=LUN, FILE=NAME, ACCESS='DIRECT', STATUS=STATE,
     +      RECL=NREC, FORM='UNFORMATTED', ERR=50, IOSTAT=IOERR)
+SELF, IF=VAX, IF=-$P3CHILD.
      IF (IOPTO.EQ.0) THEN
        OPEN (UNIT=LUN, FILE=NAME, ACCESS='DIRECT', STATUS=STATE,
     +        READONLY, SHARED, FORM='UNFORMATTED', ERR=50,
     +        IOSTAT=IOERR)
      ELSE
        OPEN (UNIT=LUN, FILE=NAME, ACCESS='DIRECT', STATUS=STATE,
     +        SHARED, RECL=NREC, FORM='UNFORMATTED', ERR=50,
     +        IOSTAT=IOERR)
      ENDIF
+SELF, IF=$P3CHILD.
      CALL APOPNF (LUN, NAME, 'DIRECT', 'UNFORMATTED', 'F', NREC, 0,
     +             IOERR)
      IF (IOERR.NE.0)      GO TO 50
+SELF.
      IOPT(1) = LUN
      IOPT(2) = NREC
      CALL DBPRNT (6, '('' DBROPN : '//NAME(1:NCHM)//' opened on Unit'//
     +     ' '',I4,'' with RECL '',I8)', IOPT, 2)
      GO TO 999
*
   50 IOPT(1) = IOERR
      IOPT(2) = LUN
      CALL DBPRNT (6, '('' DBROPN Error : IOSTAT = '',I11,'' in openi'//
     +     'ng '//NAME(1:NCHM)//' on unit '',I4)', IOPT, 2)
*                                                             END DBROPN
  999 END
+DECK, DBRZIN.
+SEQ, T=DUMMY, IF= $P3CHILD.
      SUBROUTINE DBRZIN (IDIV, LAD, JBIAS, ICUR, ICYCL, PATHN)
*     ========================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBRZIN (IDIV, *LAD*, JBIAS, ICUR, ICYCL*, PATHN)        *
*                                                                      *
*   Checks if enough space is left in memory before loading the data   *
*   part of an object. When not enough space is available after        *
*   garbage collection, the banks freed by DBFREE are dropped.         *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDIV     Division number where the object is to be created       *
*     LAD      Address of the data bank as returned by RZIN            *
*     JBIAS    Link bias as supplied to RZIN                           *
*     ICUR     RZ key number of the object to be loaded                *
*     ICYCL    Cycle number of the data object                         *
*     PATHN    Path name (only needed in the printout)                 *
*                                                                      *
*   Called by DBDELT, DBNTOP, DBPRGD, DBRTFZ, DBCDIC, DBCOMP, DBKXIN,  *
*             DBUDIC, DBUNCP                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 34 : Error in RZ for reading the object              *
*               = 99 : No space in memory for creating the bank        *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
+SELF, IF= $P3CHILD.
+CDE, P3DBL3.
      CHARACTER       RZDIP3*80
+SELF.
      DIMENSION       LAD(9)
      CHARACTER       PATHD*80, PATHN*(*)
+CDE, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
+SELF, IF=$P3CHILD.
*
      IF (IPASP3.EQ.1) THEN
*
* *** Stack the directory names and the key sequence numbers
*
        MSDBP3 = ' '
        CALL RZCDIR (MSDBP3, 'R...')
        IF (NDIRP3.EQ.0.OR.MSDBP3.NE.RZDIP3) THEN
*            New directory
          NDIRP3 = NDIRP3+1
          RZDIP3 = MSDBP3
          IF (NDIRP3.EQ.1) THEN
            INDXP3 = 1
          ELSE
            INDXP3 = INDXP3+IQ(KOFUDB+LNK1P3+INDXP3+1)+21
          ENDIF
          IF (INDXP3+22.GT.IQ(KOFUDB+LNK1P3-1))
     +        CALL MZPUSH (IXDBP3, LNK1P3, 0, 122, '....')
          CALL UCTOH  (RZDIP3, IWDBP3, 4, 80)
          CALL ZHTOI  (IWDBP3, IQ(KOFUDB+LNK1P3+INDXP3+2), 20)
          NBKDP3 = 0
        ENDIF
*         New key in this directory
        NBKDP3 = NBKDP3+1
        IQ(KOFUDB+LNK1P3+INDXP3+1) = NBKDP3
        IND = INDXP3+NBKDP3+21
        IF (IND.GT.IQ(KOFUDB+LNK1P3-1)-20)
     +    CALL MZPUSH (IDISDB, LNK1P3, 0, 100, '....')
        IQ(KOFUDB+LNK1P3+IND) = ICUR
*
        NBKYP3 = NBKYP3+1
        IQUEST(1) = 0
        GO TO 999
*
      ELSE IF (IPASP3.EQ.2) THEN
        IF (LNK4P3.EQ.0.OR.LNK5P3.EQ.0) THEN
          IQUEST(1) = 1
          GO TO 990
        ENDIF
*         Get size of data object
        NWDS = IQ(KOFUDB+LNK4P3-1)
        GO TO 5
*
      ENDIF
+SELF.
*
* *** Find number of data words
*
      IPNT   = KOFSDB + LCDRDB + IKDRDB + (ICUR - 1) * (NWKYDK + 1)
      LCYC   = IQ(IPNT)
      NWDS   = JBYT (IQ(KOFSDB+LCDRDB+LCYC+3), 1, 20)
*
* *** See if enough space is available in memory
*
    5 NEEDW  = NWDS + 100
      CALL MZNEED (IDIV, NEEDW, ' ')
      IF (IQUEST(11).LT.0)  THEN
        CALL MZNEED (IDIV, NEEDW, 'G')
        IF (IQUEST(11).LT.0)  THEN
          LGO    = 0
   10     LBFYDB = LZFIDH (IDIV, IHKYDB, LGO)
          IF (LBFYDB.NE.0)  THEN
            ND0    = IQ(KOFUDB+LBFYDB-1)
            IF (IQ(KOFUDB+LBFYDB+ND0+MKYFRI).GT.0)  THEN
              LDAT   = LQ(KOFUDB+LBFYDB-KLDADB)
              IF (LDAT.GT.0) CALL MZDROP (IDIV, LDAT, 'L')
            ENDIF
            LGO    = LBFYDB
            GO TO 10
          ENDIF
          CALL MZNEED (IDIV, NEEDW, 'G')
          IF (IQUEST(11).LT.0)  THEN
            IQUEST(1) = 99
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) THEN
              CALL DBPRNT (LPRTDB, '(/,'' DBRZIN : No space left for '//
     +             'loading object from disk == space needed '',I12)',
     +             IQUEST(11), 1)
            ENDIF
+SELF.
            GO TO 999
          ENDIF
        ENDIF
      ENDIF
*
* *** Now call RZIN
*
+SELF, IF=$P3CHILD.
      IF (IPASP3.EQ.2) THEN
        CALL MZCOPY (IXDBP3, LNK4P3, IDIV, LAD(1), JBIAS, 'P...')
        CALL UCOPY  (IQ(KOFUDB+LNK5P3+1), IQUEST(96), 5)
        LNK4P3 = LQ(KOFUDB+LNK4P3)
        LNK5P3 = LQ(KOFUDB+LNK5P3)
        IF (IQUEST(1).NE.0) GO TO 999
        IF (JBIAS.GT.0) THEN
          LBANK = LAD(1)
        ELSE
          LBANK = LQ(KOFUDB+LAD(1)+JBIAS)
        ENDIF
        IQUEST(11) = LBANK
        GO TO 999
      ENDIF
*
+SELF.
      ICYCL  = 999999
      CALL RZIN (IDIV, LAD(1), JBIAS, ICUR, ICYCL, 'S')
  990 IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 34
+SELF, IF=$DEBUG.
        PATHD  = PATHN
        NCH    = LENOCC (PATHD)
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBRZIN : '//
     +  'RZIN error for path name '//PATHD(1:NCH)//''')', IARGDB, 0)
+SELF.
      ENDIF
*                                                             END DBRZIN
  999 END
+DECK, DBSBLC.
      SUBROUTINE DBSBLC (PATHN, PATH, NCHAR)
*     ======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBSBLC (PATHN, PATH*, NCHAR*)                           *
*                                                                      *
*   Suppresses the blank characters in a string                        *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Input character string                                  *
*     PATH(*)  Output character string with all blank characters       *
*              removed                                                 *
*     NCHAR(*) Number of non-blank characters in PATH                  *
*                                                                      *
*   Called by various routines in the DBL3 package                     *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
      CHARACTER       PATHN*(*), PATH*(*)
*
*     ------------------------------------------------------------------
*
* *** Suppress blanks from the path name
*
      MAXL   = MIN (MAXLDB, LEN (PATHN)) + 1
      NCHAR  = 0
      ISWT   = 0
      DO 10 I = 1, MAXL
        LBLK   = 1
        IF (I.EQ.MAXL) GO TO 5
        IF (PATHN(I:I).NE.' ') LBLK = 0
        IF (ISWT.EQ.0.AND.LBLK.EQ.0) THEN
          ISWT   = 1
          I11    = I
        ENDIF
    5   IF (ISWT.NE.0.AND.LBLK.NE.0) THEN
          IF (NCHAR.EQ.0) THEN
            PATH   = PATHN(I11:I-1)
            NCHAR  = I - I11
          ELSE
            PATH   = PATH(1:NCHAR)//PATHN(I11:I-1)
            NCHAR  = NCHAR + I - I11
          ENDIF
          ISWT   = 0
        ENDIF
   10 CONTINUE
      IF (NCHAR.EQ.0) PATH   = ' '
*                                                             END DBSBLC
      END
+DECK, DBSDIR.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBSDIR (PATHN, NWKEY, CHFOR, CHTAG, MXKP, IOPP, IOPS)
*     ================================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBSDIR (PATHN, NWKEY, CHFOR, CHTAG, MXKP, IOPP*, IOPS*) *
*                                                                      *
*   Saves the directory creation information in the Journal file.      *
*   It creates a single header record (with zero data) for each entry. *
*   The header contains Action Code (2), Number of keys, numbers of    *
*   charcaters for option and pathname, MXKP, followed by Character    *
*   option, CHFOR, CHTAG and the pathname                              *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     NWKEY    Number of key elements                                  *
*     CHFOR    Character variable describing each element of the key   *
*              vector                                                  *
*     CHTAG    Character array defined as CHARACTER*8 (NWKEY)          *
*     MXKP     Maximum number of objects in each partition             *
*              (0 means non-partitioned directories)                   *
*     IOPP(*)  Server option (0 means standalone or Server)            *
*     IOPS(*)  Shared option (0 means standalone)                      *
*                                                                      *
*   Called by DBMDIP, DBMDIR                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 49 : FZOUT fails to write on the sequential file     *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, P3DBL3, IF=$P3CHILD.
      CHARACTER       CTAG*8, TOPN*16, PATHN*(*), CHFOR*(*), PATH*80
      CHARACTER*(*)   CHTAG(*)
*
*     ------------------------------------------------------------------
*
* *** Find the logical unit number of the Journal file
*
      KEY7   = KEY7DK
      KEY7DK = 0
      NCHR   = LEN (PATHN)
      IF (NCHR.GT.MAXLDB) NCHR = MAXLDB
      I1     = 0
      I11    = 0
      I2     = 0
      NCH    = NCHR
      DO 10 I0 = 1, NCHR
        IF (PATHN(I0:I0).EQ.' ') THEN
          NCH    = I0 - 1
          GO TO 15
        ENDIF
        IF (I2.GT.0)        GO TO 10
        IF (PATHN(I0:I0).EQ.'/') THEN
          I2     = I1
          IF (I1.GT.0) TOPN = PATHN(I11:I0-1)
        ELSE
          IF (I1.EQ.0) I11  = I0
          I1     = I1 + 1
        ENDIF
   10 CONTINUE
*
   15 LTOP   = LTOPDB
      IOPS   = 0
      IOUT   = 0
   20 IF (LTOP.NE.0) THEN
        NCHT   = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHT)
        TOPNDI = TOPNDI(1:NCHT)
        IF (TOPN.EQ.TOPNDI) THEN
          LUFZDF = IQ(KOFUDB+LTOP+MUPJFL)
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10)
+SELF.
        ELSE
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 20
        ENDIF
      ELSE
        LUFZDF = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        IOPP   = 0
+SELF.
      ENDIF
      IF (IOUT.EQ.0) IOPS = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
      IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
        CALL DBWLOK
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
        CALL DBSTSV (TOPN, 0)
+SELF, IF=$P3CHILD.
        LUFZDF = LODBP3
        IQUEST(1) = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        IF (IQUEST(1).NE.0) GO TO 999
      ENDIF
+SELF.
*
      IF (LUFZDF.GT.0) THEN
*
*  **   Prepare the header containing all the information
*
        NCHD   = (NCH + 3) / 4
        CALL MZIOCH (IOFMDF, NWFMDF, '7I -H')
        IHEADF(MACTDF) = 2
        IHEADF(MNKYDF) = NWKEY
        IHEADF(MPATDF) = NCHD
        IF (MXKP.GT.0) THEN
          IHEADF(MOPTDF) = 1
          IHEADF(MXKPDF) = MXKP
          CALL UCTOH ('P   ', IHEADF(MRECDF+1), 4, 4)
        ELSE
          IHEADF(MOPTDF) = 0
          IHEADF(MXKPDF) = 0
        ENDIF
        IF (KEY7.LE.0) THEN
          CALL DATIME (IDATE, ITIME)
          CALL DBPKTM (IDATE, ITIME, KEY7)
        ENDIF
        IHEADF(MINSDF) = KEY7
        IHEADF(MRECDF) = 0
        NCFO   = (NWKEY + 3) / 4
        NPNT   = IHEADF(MOPTDF) + MRECDF + 1
        CALL UCTOH (CHFOR, IHEADF(NPNT), 4, NWKEY)
        NPNT   = NPNT + NCFO
        DO 30 I = 1, NWKEY
          CTAG   = CHTAG(I)
          CALL UCTOH (CTAG, IHEADF(NPNT), 4, 8)
          NPNT   = NPNT + 2
   30   CONTINUE
        CALL UCTOH (PATHN, IHEADF(NPNT), 4, 4*NCHD)
        NWDH   = NPNT + NCHD - 1
*
*  **   Now write on the sequential output
*
+SELF, IF=$P3CHILD.
        RNDBP3 = 'DBSDIR '
        NWDBP3 = 2
        CALL UCTOH ('JOURNAL ', IWDBP3, 4, 8)
        CALL DBCHLD
        IQUEST(1) = IQDBP3
        IF (IQUEST(1).NE.0) GO TO 999
+SELF.
        CALL FZOUT (LUFZDF, IDIVDB, 0, 1, 'Z', IOFMDF, NWDH, IHEADF)
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1) = 49
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) THEN
            PATH   = PATHN
            CALL DBPRNT (LPRTDB, '(/,'' DBSDIR : FZOUT error for path'//
     +           ' name '//PATH//''')', IARGDB, 0)
          ENDIF
+SELF.
          GO TO 999
        ENDIF
      ENDIF
*
      IQUEST(1) = 0
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
*
* *** Server environment, Public mode
*
      IF (IOPP.NE.0) THEN
        IOPBDA = 0
        CALL DBCWSV
        GO TO 999
      ENDIF
+SELF.
*                                                             END DBSDIR
  999 END
+DECK, DBSEKY.
      SUBROUTINE DBSEKY (ITIME, KEY)
*     ==============================
*
************************************************************************
*                                                                      *
*        SUBR. DBSEKY (ITIME, KEY)                                     *
*                                                                      *
*   Select on the values of key elements                               *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     ITIME    Time for which data are required to be valid            *
*     KEY      Vector of keys (on the basis of which selection is to   *
*              be made)                                                *
*                                                                      *
*   Called by DBKXIN                                                   *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DTKXIN.
      DIMENSION       KEY(9)
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Look at all the keys in the subdirectory
*
      IF (IOPSDA.NE.0) THEN
        IPNT   = KOFSDB + LCDRDB + IKDRDB
        ISTP   = NWKYDK + 1
        KPNT   = IUHUNT (KEY(MSERDB), IQ(IPNT+MSERDB), NKEYDK*ISTP,ISTP)
        IF (KPNT.GT.0) THEN
          IK     = (KPNT - MSERDB)/ ISTP + 1
        ELSE
          GO TO 999
        ENDIF
        CALL DBKEYR (IK, NWKYDK, KEYNDK)
        NTIMDT = NTIMDT + 1
        KEY1DK(NTIMDT) = KEYNDK(MSERDB)
        IF (MNKYDT.LE.KEYNDK(MSERDB))  THEN
          IKYLDT = IK
          MNKYDT = KEYNDK(MSERDB)
          KEY6DT = KEYNDK(MFLGDB)
        ENDIF
*
      ELSE
*
        DO 20 IK = 1, NKEYDK
          CALL DBKEYR (IK, NWKYDK, KEYNDK)
*
          IF (IPRVDT.NE.0 .AND. IPRVDT.NE.KEYNDK(MPVSDB))   GO TO 20
          IF (IOKYDA(MITMDB).NE.0 .AND. KEY(MITMDB).LT.KEYNDK(MITMDB))
     +                                                      GO TO 20
          IF (KY7MDB.GT.0  .AND. KY7MDB.LT.KEYNDK(MITMDB))  GO TO 20
*
          IF (NWKYDK.GT.NSYSDK)  THEN
            DO 10 J = NSYSDK+1, NWKYDK
              IF (IOKYDA(J).NE.0. AND. KEY(J).NE.KEYNDK(J)) GO TO 20
   10       CONTINUE
          ENDIF
*
          ICLOS  = MIN0 (IABS(ITIME-KEYNDK(MBVRDB)),
     +                   IABS(ITIME-KEYNDK(MEVRDB)))
          IF (ICLOS.LT.INRSDT.AND.JBIT(KEYNDK(MFLGDB),JIGNDB).NE.0) THEN
            IDNRDT = IK
            INRSDT = ICLOS
            IUSEDT = ICURDT
          ENDIF
*
          IF ((ITIME.GE.KEYNDK(MBVRDB).AND.ITIME.LE.KEYNDK(MEVRDB)).OR.
     +        (KEY(MEVRDB).LE.KEYNDK(MEVRDB).AND.IOKYDA(MEVRDB).NE.0)
     +    .OR.(KEY(MBVRDB).GE.KEYNDK(MBVRDB).AND.IOKYDA(MBVRDB).NE.0))
     +                                                              THEN
            NTIMDT = NTIMDT + 1
            KEY1DK(NTIMDT) = KEYNDK(MSERDB)
            IF (MNKYDT.LE.KEYNDK(MSERDB))  THEN
              IKYLDT = IK
              MNKYDT = KEYNDK(MSERDB)
              KEY6DT = KEYNDK(MFLGDB)
              IF (JBIT(KEY6DT,JIGNDB).EQ.0) KY6NDT = IK
            ENDIF
          ELSE IF (ITIME.LT.KEYNDK(MBVRDB)) THEN
            IF (KY4MDB.GT.KEYNDK(MBVRDB)) KY4MDB = KEYNDK(MBVRDB)
          ENDIF
   20   CONTINUE
      ENDIF
*                                                             END DBSEKY
  999 END
+DECK, DBSNAM.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBSNAM (IFLG, KEYS, LBK, TOPN, LUNFZ)
*     ================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBSNAM (IFLG, KEYS, LBK, TOPN, LUNFZ)                   *
*                                                                      *
*   Saves the help file or name of the data objects in the journal     *
*   file or/and in the data base. The data part contains the encoded   *
*   data and the header contains Action code (6), number of keys,      *
*   number of characters for option (0) and pathname, followed by the  *
*   flag (1 for help file; 2 for data names), the keys and the path    *
*   name.                                                              *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IFLG     Flag for help information(1) or name of data elements(2)*
*     KEYS     Vector of keys                                          *
*     LBK      Address of the data bank to be stored (or 0)            *
*     TOPN     Name of the top directory                               *
*     LUNFZ    Logical unit number of FZ file (or 0)                   *
*                                                                      *
*   Called by DBEHLP, DBENAM, DBFZUP                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =184 : Illegal flag (IFLAG)                            *
*               =185 : Illegal top directory name                      *
*               =186 : FZIN error for reading the data structure       *
*               =187 : FZOUT fails to write on the sequential file     *
*               =188 : Error in RZ for writing to the R.A. file        *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, P3DBL3, IF=$P3CHILD.
      CHARACTER       PATHN*32, TOPN*(*), PATHL*80
      DIMENSION       KEYO(MXDMDK), LBK(9), KEYS(9)
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Find the path name for storing the information
*
      LREFDB(2) = LBK(1)
      PATHL  = ' '
      NCH    = LENOCC (TOPN)
      IF (IFLG.EQ.1) THEN
        PATHN  = '//'//TOPN(1:NCH)//'/HELP'
        NCHAR  = NCH + 7
      ELSE IF (IFLG.EQ.2) THEN
        PATHN  = '//'//TOPN(1:NCH)//'/DICTIONARY'
        NCHAR  = NCH + 13
      ELSE
        IQUEST(1) = 184
        IQUEST(11)= IFLG
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBSNAM : Illgeal'//
     +  ' flag '',I12)', IQUEST(11), 1)
+SELF.
        GO TO 999
      ENDIF
*
* *** Fill up the key vector
*
      IF (LUNFZ.GT.0) THEN
        CALL UCOPY (KEYS(1), KEYNDK, NSYSDK)
      ELSE
        KEYNDK(MSERDB) = KEYS(MSERDB)
        KEYNDK(MUPNDB) = 0
        CALL DATIME (IDATE, ITIME)
        CALL DBPKTS (IDATE, ITIME*100, KEYNDK(MBVRDB))
        KEYNDK(MEVRDB) = IBIGDB
        KEYNDK(MPVSDB) = 0
        KEYNDK(MFLGDB) = 0
        KEYNDK(MFLGDB) = MSBIT1 (KEYNDK(MFLGDB), JRZUDB)
        IF (IFLG.EQ.1) KEYNDK(MFLGDB) = MSBIT1 (KEYNDK(MFLGDB), JASFDB)
        CALL DBPKTM (IDATE, ITIME, KEYNDK(MITMDB))
      ENDIF
*
* *** Find the logical unit number of the Journal file
*
      LTOP   = LTOPDB
   10 IF (LTOP.NE.0) THEN
        NCHT   = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHT)
        IF (TOPN(1:NCH).EQ.TOPNDI(1:NCHT)) THEN
          LUFZDF = IQ(KOFUDB+LTOP+MUPJFL)
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10)
+SELF.
        ELSE
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 10
        ENDIF
      ELSE
        IQUEST(1) = 185
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          TOPNDI = TOPN
          CALL DBPRNT (LPRTDB, '(/,'' DBSNAM : Illegal top directory '//
     +         'name '//TOPNDI//''')', IARGDB, 0)
        ENDIF
+SELF.
        GO TO 999
      ENDIF
      IF (IOUT.EQ.0) IOPS = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
      IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
        CALL DBWLOK
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
        CALL DBSTSV (TOPN, 0)
+SELF, IF= $P3CHILD.
        LUFZDF = LODBP3
        IQUEST(1) = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        IF (IQUEST(1).NE.0) GO TO 999
      ENDIF
+SELF.
*
* *** Now get the bank (either supplied by user or from FZ file)
*
      IF (LUNFZ.EQ.0) THEN
        LBDADB = LREFDB(2)
      ELSE
+SELF, IF=$P3CHILD.
        RNDBP3 = 'DBSNAM '
        NWDBP3 = 1
        IWDBP3(1) = LUNFZ
        CALL DBCHLD
        IQUEST(1) = IQDBP3
        IF (IQUEST(1).NE.0) GO TO 999
+SELF.
        CALL FZIN (LUNFZ, IDISDB, LBDADB, 2, 'A', 0, 0)
        IF (IQUEST(1).GT.0) THEN
          IQUEST(1) = -1
          GO TO 999
        ELSE IF (IQUEST(1).NE.0) THEN
          IQUEST(11)= IQUEST(1)
          IQUEST(1) = 186
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBSNAM : FZIN '//
     +    ' error type '',I12)', IQUEST(11), 1)
+SELF.
          GO TO 999
        ENDIF
      ENDIF
*
      IF (LUFZDF.GT.0) THEN
*
*  **   Prepare the header containing all the information
*
        NCHD   = (NCHAR + 3) / 4
        CALL MZIOCH (IOFMDF, NWFMDF, '12I -H')
        IHEADF(MACTDF) = 6
        IHEADF(MNKYDF) = NSYSDK
        IHEADF(MOPTDF) = 0
        IHEADF(MPATDF) = NCHD
        IHEADF(MFLGDF) = IFLG
        CALL UCOPY (KEYNDK, IHEADF(MFLGDF+1), NSYSDK)
        NPNT   = NSYSDK + MFLGDF + 1
        CALL UCTOH (PATHN, IHEADF(NPNT), 4, 4*NCHD)
        NWDH   = NPNT + NCHD - 1
*
*  **   Now write on the sequential output
*
+SELF, IF=$P3CHILD.
        RNDBP3 = 'DBSNAM '
        NWDBP3 = 2
        CALL UCTOH ('JOURNAL ', IWDBP3, 4, 8)
        CALL DBCHLD
        IQUEST(1) = IQDBP3
        IF (IQUEST(1).NE.0) GO TO 999
+SELF.
        CALL FZOUT (LUFZDF, IDISDB, LBDADB, 1, ' ', IOFMDF, NWDH,IHEADF)
        IF (IQUEST(1).NE.0) THEN
          IF (LUNFZ.NE.0) CALL MZDROP (IDISDB, LBDADB, 'L')
          IQUEST(1) = 187
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBSNAM : FZOUT'//
     +    ' error for path name '//PATHN//''')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
      ENDIF
*
      IQUEST(1) = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
* *** Server environment, Public mode
*
      IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
        ISAVW  = IQUEST(9)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        IF (LUNFZ.NE.0) CALL MZDROP (IDISDB, LBDADB, 'L')
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
        IQUEST(9) = ISAVW
        IOPBDA = 0
        CALL DBCWSV
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        GO TO 999
      ENDIF
+SELF, IF=-$P3CHILD.
*
* *** Enter the bank into data base
*
      ISTEP  = 1
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0)   GO TO 900
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      IF (IOPS.NE.0) THEN
        CALL RZLOCK ('DBSNAM')
        PATHL  = PATHN
      ENDIF
      CALL DBKEYT
      ISTP   = NWKYDK + 1
      ISTEP  = 2
      KPNT   = IUHUNT (KEYNDK(MSERDB), IQ(KOFSDB+LCDRDB+IKDRDB+MSERDB),
     +                 NKEYDK*ISTP, ISTP)
      IF (KPNT.GT.0) THEN
        IK     = (KPNT - MSERDB) / ISTP + 1
        CALL DBKEYR (IK, NWKYDK, KEYO)
        CALL RZDELK (KEYO, ICDUM, 'C')
        IF (IQUEST(1).NE.0) GO TO 800
      ENDIF
      ISTEP  = 3
      CALL RZOUT (IDISDB, LBDADB, KEYNDK, ICYCLE, 'S')
*
  800 IF (PATHL.NE.' ') THEN
        IERR   = IQUEST(1)
        CALL RZCDIR (PATHL, ' ')
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        CALL RZFREE ('DBSNAM')
        IQUEST(1) = IERR
      ENDIF
  900 IERR   = IQUEST(1)
      IF (LUNFZ.NE.0) CALL MZDROP (IDISDB, LBDADB, 'L')
      IF (IERR.NE.0) THEN
        IQUEST(1) = 188
        IQUEST(11)= ISTEP
+SELF, IF=$DEBUG, IF=-$P3CHILD.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBSNAM : RZ erro'//
     +  'r in step '',I3,'' for path name '//PATHN//''')', IQUEST(11),1)
+SELF, IF=-$P3CHILD.
      ENDIF
+SELF.
*                                                             END DBSNAM
  999 END
+DECK, DBSOPN.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBSOPN (LUN, CHOPT, CFNAM, NRECL, IOERR)
*     ===================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBSOPN (LUN, CHOPT, CFNAM, NRECL, IOERR*)               *
*                                                                      *
*   Opens a sequential FZ file                                         *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUN      Logical unit number                                     *
*     CHOPT    Character string with any of the following characters   *
*          A   ASCII file format                                       *
*          O   Output file (default is input)                          *
*          X   Exchange binary format                                  *
*          Z   File to be overwritten if exists                        *
*     CFNAM    File name                                               *
*     NRECL    Record length in bytes                                  *
*     IOERR    Error code (0 if no error)                              *
*                                                                      *
*   Called by DBEXAMn                                                  *
*                                                                      *
************************************************************************
*
      DIMENSION       IOPT(5)
      CHARACTER       CHOPT*(*), CFNAM*(*), NAME*80, STATE*10, FORMT*12
      CHARACTER       CHOP*8
      EQUIVALENCE     (IOPTA, IOPT(1)), (IOPTI, IOPT(2))
     +              , (IOPTO, IOPT(3)), (IOPTX, IOPT(4))
     +              , (IOPTZ, IOPT(5))
+SELF, IF=IBM.
      CHARACTER       FILE*96, CHLUN*2, CHREC*5, CHFIL*96
+SELF.
*
*     ------------------------------------------------------------------
*
* *** Access the file name, etc.
*
      NCH    = LENOCC (CFNAM)
      IF (NCH.LT.1)          GO TO 999
      NCHM   = MIN (50, NCH)
      NAME   = CFNAM
+SELF, IF=IBM, $P3CHILD.
   10 L      = INDEX (NAME, '.')
      IF (L.NE.0) THEN
        NAME(L:L) = ' '
        GO TO 10
      ENDIF
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP, IF=-$P3CHILD.
      CALL CUTOL (NAME)
+SELF.
*
* *** Analyse the option
*
      CALL UOPTC  (CHOPT, 'AIOXZ', IOPT)
*
* *** Decide on the record length
*
      IF (NRECL.GT.0) THEN
        NREC   = NRECL
      ELSE IF (IOPTX.NE.0) THEN
        NREC   = 3600
      ELSE IF (IOPTA.NE.0) THEN
        NREC   = 80
      ELSE
        NREC   = 10000
      ENDIF
      CHOP   = CHOPT
+SELF, IF=CRAY.
      LREC   = NREC/8
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,MIP.
      LREC   = NREC/4
+SELF.
*
* *** Decide on state and form
*
      IF (IOPTO.EQ.0) THEN
        STATE  = 'OLD'
      ELSE
+SELF, IF=VAX.
        IF (IOPTZ.EQ.0) THEN
          STATE  = 'NEW'
        ELSE
          STATE  = 'UNKNOWN'
        ENDIF
+SELF, IF=APOLLO,CRAY,HPUX,IBM,IBMRT,MIP.
        STATE  = 'UNKNOWN'
+SELF.
      ENDIF
      IF (IOPTA.NE.0) THEN
        FORMT = 'FORMATTED'
      ELSE
        FORMT = 'UNFORMATTED'
      ENDIF
*
* *** Now open the file
*
+SELF, IF=IBM, IF=-$P3CHILD.
      WRITE (CHLUN, '(I2.2)') LUN
      WRITE (CHREC, '(I5)')   NREC
      IF (IOPTX.NE.0) THEN
        FILE   = 'FILEDEF IOFILE'//CHLUN//' DISK '//NAME
        NCH    = LENOCC (FILE)
        CHFIL  = FILE(1:NCH)//' (RECFM U BLKSIZE '//CHREC//' PERM'
        CHOP   = 'Y'//CHOPT
      ELSE
        FILE   = 'FILEDEF '//CHLUN//' DISK '//NAME
        NCH    = LENOCC (FILE)
        IF (IOPTA.NE.0) THEN
          CHFIL  = FILE(1:NCH)//' (RECFM FB BLKSIZE '//CHREC//' PERM'
        ELSE
          CHFIL  = FILE(1:NCH)//' (RECFM U BLKSIZE '//CHREC//' PERM'
        ENDIF
      ENDIF
      CALL VMCMS (CHFIL, IOERR)
      IF (IOERR.NE.0)        GO TO 50
      OPEN (UNIT=LUN, FORM=FORMT)
+SELF, IF=APOLLO, IF=-$P3CHILD.
      OPEN (UNIT=LUN, FILE=NAME, FORM=FORMT, STATUS=STATE,
     +      RECL=NREC, ERR=50, IOSTAT=IOERR)
+SELF, IF=CRAY,HPUX,IBMRT,MIP, IF=-$P3CHILD.
      OPEN (UNIT=LUN, FILE=NAME, FORM=FORMT, STATUS=STATE,
     +      ERR=50, IOSTAT=IOERR)
+SELF, IF=VAX, IF=-$P3CHILD.
      IF (STATE.EQ.'OLD') THEN
        OPEN (UNIT=LUN, FILE=NAME, FORM=FORMT, STATUS=STATE,
     +        READONLY, SHARED, ERR=50, IOSTAT=IOERR)
      ELSE IF (IOPTX.NE.0) THEN
        OPEN (UNIT=LUN, FILE=NAME, FORM=FORMT, STATUS=STATE,
     +        RECORDTYPE='FIXED', RECL=LREC, BLOCKSIZE=NREC, ERR=50,
     +        IOSTAT=IOERR)
      ELSE
        OPEN (UNIT=LUN, FILE=NAME, FORM=FORMT, STATUS='UNKNOWN',
     +        RECL=NREC, ERR=50, IOSTAT=IOERR)
      ENDIF
+SELF, IF=$P3CHILD.
      CALL APOPNF (LUN, NAME, 'SEQUENTIAL', FORMT, 'F', NREC, 0, IOERR)
      IF (IOERR.NE.0)        GO TO 50
+SELF.
      IOPT(1) = LUN
      IOPT(2) = NREC
      CALL DBPRNT (6, '('' DBSOPN : '//NAME(1:NCHM)//' opened on Unit'//
     +     ' '',I4,'' with RECL '',I8)', IOPT, 2)
*
      CALL FZFILE (LUN, LREC, CHOP)
      GO TO 999
*
   50 IOPT(1) = IOERR
      IOPT(2) = LUN
      CALL DBPRNT (6, '('' DBSOPN Error : IOSTAT = '',I11,'' in openi'//
     +     'ng '//NAME(1:NCHM)//' on unit '',I4)', IOPT, 2)
*                                                             END DBSOPN
  999 END
+DECK, DBSPUR.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBSPUR (PATHN, NWKEY, ITIME, KEYS, CHOPT, IOPP, IOPS)
*     ================================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBSPUR (PATHN, NWKEY, ITIME, KEYS, CHOPT, IOPP*, IOPS*) *
*                                                                      *
*   Saves the object purging information in the Journal file.          *
*   It creates a single header record (with zero data) for each entry. *
*   The header contains Action Code (3), Number of keys, numbers of    *
*   charcaters for option and pathname, ITIME, current time (like Key  *
*   7), followed by KEYS, Character option and the pathname.           *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     NWKEY    Number of key elements                                  *
*     ITIME    Flag (If > 0, ITIME value as indicated in DBPURK, or    *
*              < 0, a call from DBPURG)                                *
*     KEYS     Vector of keys, if called from DBPURK                   *
*              Vector containing KYDAT, KYTIM, if called from DBPURG   *
*     CHOPT    Character option as used in the calls to DBPURG/DBPURK  *
*     IOPP(*)  Server option (0 means standalone or Server)            *
*     IOPS(*)  Shared option (0 means standalone)                      *
*                                                                      *
*   Called by DBPURG, DBPURK                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =115 : Cannot form the IO descriptor for the FZ header *
*               =116 : FZOUT fails to write on the sequential file     *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, P3DBL3, IF=$P3CHILD.
      PARAMETER       (NLEVM=20)
      CHARACTER       CHCUR(NLEVM)*1, CHFOR*100, CFORM(6)*1
      CHARACTER       CHOP*80, TOPN*16, PATHN*(*), CHOPT*(*)
      DIMENSION       KEYS(9), NLCUR(NLEVM)
      DATA            CFORM /'B', 'I', 'F', 'D', 'H', 'A'/
*
*     ------------------------------------------------------------------
*
* *** Find the logical unit number of the Journal file
*
      KEY7   = KEY7DK
      KEY7DK = 0
      NCH    = INDEX (PATHN, ' ') - 1
      I1     = 0
      I11    = 0
      DO 10 I0 = 1, NCH
        IF (PATHN(I0:I0).EQ.'/'.OR.PATHN(I0:I0).EQ.' ') THEN
          IF (I1.GT.0) THEN
            TOPN   = PATHN(I11:I0-1)
            GO TO 15
          ENDIF
          IF (PATHN(I0:I0).EQ.' ') GO TO 15
        ELSE
          IF (I1.EQ.0) I11 = I0
          I1     = I1 +1
        ENDIF
   10 CONTINUE
*
   15 LTOP   = LTOPDB
      IOPS   = 0
      IOUT   = 0
   20 IF (LTOP.NE.0) THEN
        NCHT   = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHT)
        TOPNDI = TOPNDI(1:NCHT)
        IF (TOPN.EQ.TOPNDI) THEN
          IF (IOPBDA.EQ.0) THEN
            LUFZDF = IQ(KOFUDB+LTOP+MUPJFL)
          ELSE
            LUFZDF = IQ(KOFUDB+LTOP+MUPBAK)
          ENDIF
          IOPS   = MOD (IQ(KOFUDB+LTOP+MUPSRV)/10, 10)
          IOUT   = IQ(KOFUDB+LTOP+MUPFLG)
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
          IOPP   = MOD (IQ(KOFUDB+LTOP+MUPSRV), 10)
+SELF.
        ELSE
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 20
        ENDIF
      ELSE
        LUFZDF = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        IOPP   = 0
+SELF.
      ENDIF
      IF (IOUT.EQ.0) IOPS = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
*
      IF (IOPP.NE.0) THEN
+SELF, IF=VAX, IF=$SERVER, IF=-$P3CHILD.
        CALL DBWLOK
+SELF, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER, IF=-$P3CHILD.
        CALL DBSTSV (TOPN, 0)
+SELF, IF= $P3CHILD.
        LUFZDF = LODBP3
        IQUEST(1) = 0
+SELF, IF=APOLLO,HPUX,IBM,IBMRT,VAX, IF=$SERVER.
        IF (IQUEST(1).NE.0)        GO TO 999
      ENDIF
+SELF.
*
      IF (LUFZDF.GT.0) THEN
*
*  **   Prepare the header containing all the information
*
        NCHD   = (NCH + 3) / 4
        IHEADF(MACTDF) = 3
        IHEADF(MNKYDF) = NWKEY
        IHEADF(MPATDF) = NCHD
        IF (ITIME.GT.0) THEN
          IHEADF(MTIMDF) = ITIME
          IFLAG          = 1
        ELSE
          IHEADF(MTIMDF) = -1
          IFLAG          = 0
        ENDIF
        IF (KEY7.GT.0) THEN
          IHEADF(MINSDF) = KEY7
        ELSE
          CALL DATIME (IDATX, ITIMX)
          CALL DBPKTM (IDATX, ITIMX, IHEADF(MINSDF))
        ENDIF
        NCHP   = LEN (CHOPT)
        IF (NCHP.GT.MAXLDB) NCHP = MAXLDB
        NCHOP  = 0
        DO 25 I = 1, NCHP
          IF (CHOPT(I:I).NE.' ') THEN
            IF (NCHOP.EQ.0) THEN
              CHOP   = CHOPT(I:I)
            ELSE
              CHOP   = CHOP(1:NCHOP)//CHOPT(I:I)
            ENDIF
            NCHOP  = NCHOP + 1
          ENDIF
   25   CONTINUE
        NWDOP  = (NCHOP + 3) / 4
        NPNT   = NWKEY + MINSDF + 1
        IHEADF(MOPTDF) = NWDOP
        IF (NWDOP.GT.0) CALL UCTOH (CHOP, IHEADF(NPNT), 4, 4*NWDOP)
        NPNT   = NPNT + NWDOP
        CALL UCTOH (PATHN, IHEADF(NPNT), 4, 4*NCHD)
        NWDH   = NPNT + NCHD - 1
*
*  **   Get the IO format for the header
*
        NLEV   = 1
        NCUR   = 6
        IFORO  = 2
        CHCUR(NLEV) = CFORM(IFORO)
        DO 30 I = 1, NWKEY
          IFORM  = IOTYDK(I)
          IF (IFORM.EQ.6) IFORM = 5
          IF (IFORM.EQ.IFORO) THEN
            NCUR   = NCUR + 1
          ELSE
            NLCUR(NLEV) = NCUR
            IF (NLEV.GE.NLEVM) THEN
              IQUEST(1) = 115
+SELF, IF=$DEBUG.
              IF (IDEBDB.GT.0) THEN
                CHFOR  = PATHN
                CALL DBPRNT (LPRTDB, '(/,'' DBSPUR : Cannot form IO '//
     +               'descriptor '//CHFOR(1:80)//''')', IARGDB, 0)
              ENDIF
+SELF.
              GO TO 999
            ENDIF
            NLEV   = NLEV + 1
            CHCUR(NLEV) = CFORM(IFORM)
            NCUR   = 1
            IFORO  = IFORM
          ENDIF
          IF (IFLAG.NE.0) THEN
            IHEADF(MINSDF+I) = KEYS(I)
          ELSE
            IF (I.LE.NSYSDK) THEN
              IHEADF(MINSDF+I) = KEYS(I)
            ELSE IF (IFORM.EQ.5) THEN
              CALL UCTOH ('    ', IHEADF(MINSDF+I), 4, 4)
            ELSE
              IHEADF(MINSDF+I) = 0
            ENDIF
          ENDIF
   30   CONTINUE
        NLCUR(NLEV) = NCUR
*
+SELF, IF=-IBM, -$P3CHILD.
        WRITE (CHFOR, 2001) (NLCUR(I), CHCUR(I), I = 1, NLEV)
+SELF, IF=IBM, IF=$P3CHILD.
        CHFOR  = ' '
        II     = 1
        DO 31 I = 1, NLEV
          CALL UTWRIT (CHFOR(II:II+1), '(I2)', NLCUR(I))
          II     = II + 2
          CHFOR(II:II) = CHCUR(I)
          II     = II + 2
   31   CONTINUE
+SELF.
        II     = 4 *NLEV
        CHFOR = CHFOR(1:II)//' -H'
        CALL MZIOCH (IOFMDF, NWFMDF, CHFOR(1:II+3))
*
*  **   Now write on the sequential output
*
+SELF, IF=$P3CHILD.
        RNDBP3 = 'DBSPUR '
        NWDBP3 = 2
        CALL UCTOH ('JOURNAL ', IWDBP3, 4, 8)
        CALL DBCHLD
        IQUEST(1) = IQDBP3
        IF (IQUEST(1).NE.0)        GO TO 999
+SELF.
        CALL FZOUT (LUFZDF, IDIVDB, 0, 1, 'Z', IOFMDF, NWDH, IHEADF)
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1) = 116
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) THEN
            CHFOR  = PATHN
            CALL DBPRNT (LPRTDB, '(/,'' DBSPUR : FZOUT error for path'//
     +           ' name '//CHFOR(1:80)//''')', IARGDB, 0)
          ENDIF
+SELF.
          GO TO 999
        ENDIF
      ENDIF
*
      IQUEST(1) = 0
+SELF, IF=VAX, IF=$SERVER.
*
* *** Server environment, Public mode
*
      IF (IOPP.NE.0) THEN
        CALL DBCWSV
        GO TO 999
      ENDIF
+SELF, IF=-IBM, -$P3CHILD.
*
 2001 FORMAT (20(I2,A1,1X))
+SELF.
*                                                             END DBSPUR
  999 END
+DECK, DBTOPN.
      SUBROUTINE DBTOPN (PATHN, TOPN, NCH)
*     ====================================
*
************************************************************************
*                                                                      *
*        SUBR. DBTOPN (PATHN, TOPN*, NCH*)                             *
*                                                                      *
*   Extracts the top directory name from the path name                 *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     TOPN(*)  Name of the top directory                               *
*     NCH(*)   Number of characters in TOPN                            *
*                                                                      *
*   Called by DBDONT                                                   *
*                                                                      *
************************************************************************
*
      CHARACTER       PATHN*(*), TOPN*(*)
*
*     ------------------------------------------------------------------
*
      NCTOT  = LENOCC (PATHN)
      I1     = 0
      I11    = 0
      DO 10 I0 = 1, NCTOT
        IF (PATHN(I0:I0).EQ.'/') THEN
          IF (I1.GT.0) THEN
            TOPN   = PATHN(I11:I0-1)
            NCH    = I0 - I11
            GO TO 15
          ENDIF
        ELSE
          IF (I1.EQ.0) I11 = I0
          I1     = I1 +1
        ENDIF
   10 CONTINUE
      NCH    = 0
      TOPN   = ' '
   15 CONTINUE
*                                                             END DBTOPN
      END
+DECK, DBTOUS.
      SUBROUTINE DBTOUS (LC, IUDIV, LU, LSUP, JBIAS, IPREC)
*     =====================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBTOUS (LC, IUDIV, LU*, LSUP, JBIAS, IPREC)             *
*                                                                      *
*   Copies Single Bank at LC from the Data Base system into Bank at LU *
*   in the user division in the user system                            *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LC       Address of the bank to be copied                        *
*     IUDIV    Division index of the user division                     *
*     LU(*)    Address of the copied bank                              *
*     LSUP     Address of the supporting bank (see MZBOOK)             *
*     JBIAS    Link Bias (see MZBOOK)                                  *
*     IPREC    Signed precision word; the data are truncated after     *
*              having multiplied by 10**IPREC                          *
*                                                                      *
*   Called by DBKXIN                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
      DIMENSION       LC(9), LSUP(9), LU(9)
*
*     ------------------------------------------------------------------
*
      LREFDB(4) = LC(1)
      NDU    = IQ(KOFUDB+LREFDB(4)-1) - 2
      ITU    = IDBTYP (LREFDB(4))
      CALL DBBOOK (IUDIV, LU(1), LSUP(1), JBIAS, 'USER', 0, 0, NDU, ITU,
     +             0)
      IF (IQUEST(1).NE.0) GO TO 999
      IF (ITU.EQ.3) THEN
        CALL UCOPY (Q(KOFUDB+LREFDB(4)+3), Q(KOFUDB+LU(1)+1), NDU)
        IPREC = Q(KOFUDB+LREFDB(4)+2)
      ELSE
        CALL UCOPY (IQ(KOFUDB+LREFDB(4)+3), IQ(KOFUDB+LU(1)+1), NDU)
        IPREC = IQ(KOFUDB+LREFDB(4)+2)
      ENDIF
*                                                             END DBTOUS
  999 END
+DECK, DBUCMP.
      SUBROUTINE DBUCMP (LB, IADS)
*     ============================
*
************************************************************************
*                                                                      *
*        SUBR. DBUCMP (LB, IADS*)                                      *
*                                                                      *
*   Uncompresses data bank defined by LB in the Data Base              *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LB       Address of the bank to be uncompressed                  *
*     IADS(*)  Address of the uncompressed bank as LAUXDL(IADS)        *
*                                                                      *
*   Called by DBUNCP                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 81 : Precision is not correctly given                *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DLINKS.
      DIMENSION       LB(9)
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
      LREFDB(7) = LB(1)
      NDI    = IQ(KOFUDB+LREFDB(7)-1) - 3
      LB3    = LREFDB(7) + 3
      NAU    = JBYT (IQ(KOFUDB+LB3), 1, 26)
      LBITL  = JBYT (IQ(KOFUDB+LB3), 27, 5)
      IVM    = IQ(KOFUDB+LREFDB(7)+2)
      LB1    = LREFDB(7) + 1
      NDO    = IQ(KOFUDB+LB1)/10000
      IDT    = MOD (IQ(KOFUDB+LB1), 10000)
      IPREC  = MOD (IDT, 1000)
      IDT    = IDT/1000
      IPREC  = IPREC - 100
*
      ND2    = NDO + 2
      JBIAS  = 2
      CALL DBBOOK (IDISDB, LAUXDL(IADS), LAUXDL(IADS), JBIAS, 'AUX3', 0,
     +             0, ND2, 2, 0)
      IF (IQUEST(1).NE.0)              GO TO 999
*
      LAUX3  = LAUXDL(IADS)
      LAU33  = LAUX3 + 3
      CALL DBUPCK (IQ(KOFUDB+LREFDB(7)+4), NDI, NDO, NAU, LBITL,
     +             IQ(KOFUDB+LAU33))
*
      LAU32  = KOFUDB + LAUX3 + 2
      IF (IVM.GT.0) THEN
        DO 10 I = 1, NDO
          IQ(LAU32+I) = IQ(LAU32+I) - IVM
   10   CONTINUE
      ENDIF
*
* *** Precision
*
      IF (IPREC.LT.-99.OR.IPREC.GT.99) GO TO 991
      IPR1   = 0
      IPR2   = 0
      IF (IPREC.GT.0) IPR2 = IPREC
      IF (IPREC.LT.0) IPR1 = -IPREC
*
      IF (IDT.EQ.3) THEN
        CALL VFLOAT (IQ(KOFUDB+LAU33), Q(KOFUDB+LAU33), NDO)
        IF (IPR1.GT.0) THEN
          XMULT  = 10.**IPR1
          CALL VSCALE (Q(KOFUDB+LAU33), XMULT, Q(KOFUDB+LAU33), NDO)
        ELSE IF (IPR2.GT.0) THEN
          XMULT  = 1./10.**IPR2
          CALL VSCALE (Q(KOFUDB+LAU33), XMULT, Q(KOFUDB+LAU33), NDO)
        ENDIF
*
        JBIAS  = 2
        CALL DBBOOK (IDISDB, LAUXDL(IADS-1), LAUXDL(IADS-1), JBIAS,
     +               'AUX4', 0, 0, ND2, 3, 0)
        IF (IQUEST(1).NE.0)            GO TO 999
        LAUX3  = LAUXDL(IADS)
        LAU33  = LAUX3 + 3
        LAUX4  = LAUXDL(IADS-1)
        Q(KOFUDB+LAUX4+2) = IPREC
        CALL UCOPY (Q(KOFUDB+LAU33), Q(KOFUDB+LAUX4+3), NDO)
        CALL MZDROP (IDISDB, LAUX3, ' ')
      ELSE IF (IDT.EQ.2 .OR. IDT.EQ.5)  THEN
        IF (IPR1.GT.0) THEN
          IMULT  = 10**IPR1
          DO 20 I = 1, NDO
            IQ(LAU32+I) = IQ(LAU32+I) * IMULT
   20     CONTINUE
        ELSE IF (IPR2.GT.0) THEN
          XMULT  = 1./10**IPR2
          DO 30 I = 1, NDO
            IQ(LAU32+I) = IQ(LAU32+I) * XMULT
   30     CONTINUE
        ENDIF
*
        JBIAS  = 2
        CALL DBBOOK (IDISDB, LAUXDL(IADS-1), LAUXDL(IADS-1), JBIAS,
     +               'AUX4', 0, 0, ND2, IDT, 0)
        IF (IQUEST(1).NE.0)            GO TO 999
        LAUX3  = LAUXDL(IADS)
        LAU33  = LAUX3 + 3
        LAUX4  = LAUXDL(IADS-1)
        IQ(KOFUDB+LAUX4+2) = IPREC
        CALL UCOPY (Q(KOFUDB+LAU33), IQ(KOFUDB+LAUX4+3), NDO)
        CALL MZDROP (IDISDB, LAUX3, ' ')
      ENDIF
      GO TO 999
*
* *** Error Condition
*
  991 IQUEST(1) = 81
      IQUEST(11)= IPREC
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUCMP : Precision'//
     +   ' is not correctly given -'',I8,'' no uncompression'')',
     +   IQUEST(11), 1)
+SELF.
      GO TO 999
*                                                             END DBUCMP
  999 END
+DECK, DBUCMZ.
      SUBROUTINE DBUCMZ (LB, IADS)
*     ============================
*
************************************************************************
*                                                                      *
*        SUBR. DBUCMZ (LB, IADS*)                                      *
*                                                                      *
*   Uncompresses data bank defined by LB in the Data Base              *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LB       Address of the bank to be uncompressed                  *
*     IADS(*)  Address of the uncompressed bank as LAUXDL(IADS)        *
*                                                                      *
*   Called by DBUNCP                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 82 : Illegal Data Type                               *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DLINKS.
+CDE, DZPACK.
      DIMENSION       LB(9)
*
*     ------------------------------------------------------------------
*
      LREFDB(7) = LB(1)
      IDTYP  = IDBTYP (LREFDB(7))
*
      IF (IDTYP.EQ.3) THEN
        NDI    = IQ(KOFUDB+LREFDB(7)-1) - 3
        NDO    = Q(KOFUDB+LREFDB(7)+1)
        PRECDZ = Q(KOFUDB+LREFDB(7)+2)
        ND2    = NDO + 2
        JBIAS  = 2
        CALL DBBOOK (IDISDB, LAUXDL(IADS), LAUXDL(IADS), JBIAS, 'AUX3',
     +               0, 0, ND2, IDTYP, 0)
        IF (IQUEST(1).NE.0) GO TO 999
        LAUX3  = LAUXDL(IADS)
        LAU33  = LAUX3 + 3
        IF (NDI.LE.0) THEN
          CALL VZERO (Q(KOFUDB+LAU33), NDO)
        ELSE
          CALL DBUPFZ (Q(KOFUDB+LREFDB(7)+4), NDI, Q(KOFUDB+LAU33), NDO)
        ENDIF
      ELSE IF (IDTYP.EQ.2.OR.IDTYP.EQ.5) THEN
        NDI    = IQ(KOFUDB+LREFDB(7)-1) - 3
        NDO    = IQ(KOFUDB+LREFDB(7)+1)
        PRECDZ = IQ(KOFUDB+LREFDB(7)+2)
        ND2    = NDO + 2
        JBIAS  = 2
        CALL DBBOOK (IDISDB, LAUXDL(IADS), LAUXDL(IADS), JBIAS, 'AUX3',
     +               0, 0, ND2, IDTYP, 0)
        IF (IQUEST(1).NE.0) GO TO 999
        LAUX3  = LAUXDL(IADS)
        LAU33  = LAUX3 + 3
        IF (NDI.LE.0) THEN
          CALL VZERO (IQ(KOFUDB+LAU33), NDO)
        ELSE
          CALL DBUPIZ (IQ(KOFUDB+LREFDB(7)+4),NDI, IQ(KOFUDB+LAU33),NDO)
        ENDIF
      ELSE
        GO TO 991
      ENDIF
      GO TO 999
*
* *** Error codes
*
  991 IQUEST(1) = 82
      IQUEST(11)= IDTYP
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUCMZ : Data-type'//
     +   ' '',I4,'' illegal for uncompression'')', IQUEST(11), 1)
+SELF.
      GO TO 999
*                                                             END DBUCMZ
  999 END
+DECK, DBUDIC.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBUDIC (LTOP)
*     ========================
*
************************************************************************
*                                                                      *
*        SUBR. DBUDIC (LTOP)                                           *
*                                                                      *
*   Updates the dictionary information if not yet available in the     *
*   disk file                                                          *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LTOP     Address of the top directory                            *
*                                                                      *
*   Called by DBINIT                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =150 : Error in loading Top directory                  *
*               =155 : Error in RZ for reading the dictionary object   *
*               =157 : Error in RZ in writing the dictionary object    *
*               =158 : Error in RZ in purging the dictionary directory *
*               =159 : Error in creating the DICTIONARY/HELP directory *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
      PARAMETER       (NLEVM=20)
      DIMENSION       KEYN(MXDMDK), NCHD(NLEVM), ISDI(NLEVM)
      DIMENSION       NKEY(NLEVM), IOPT(NLEVM), NSDI(NLEVM)
      DIMENSION       IHDIR(4), LTOP(9)
      CHARACTER       PATHN*80, PATHX*16, PATHY*80, PATHF*80, PATHZ*16
      CHARACTER       PATHD*80
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
      LBNODB = LTOP(1)
      JBIAS  = -KLDICT
      NLEV   = 1
      IOUT   = IQ(KOFUDB+LBNODB+MUPFLG)
      IOPP   = MOD (IQ(KOFUDB+LBNODB+MUPSRV), 10)
      IOPS   = MOD (IQ(KOFUDB+LBNODB+MUPSRV)/10, 10)
      IF (IOPP.NE.0) IOUT = 0
      NCHR   = IQ(KOFUDB+LBNODB+MUPNCH)
      CALL UHTOC (IQ(KOFUDB+LBNODB+MUPNAM), 4, PATHZ, NCHR)
      PATHZ  = PATHZ(1:NCHR)
      PATHN  = '//'//PATHZ
      NCHD(NLEV) = NCHR + 2
      PATHD  = PATHN(1:NCHD(NLEV))//'/DICTIONARY'
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 150
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUDIC : Illegal'//
     +  ' top directory '//PATHN//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
+SELF, IF=-$P3CHILD.
*
* *** Create the help file if it does not exist
*
      IF (IOUT.NE.0) THEN
        PATHY  = PATHN(1:NCHD(NLEV))//'/HELP'
        CALL RZCDIR (PATHY, ' ')
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1) = 0
          CALL RZCDIR (PATHN, ' ')
          IF (IOPS.NE.0) CALL RZLOCK ('DBUDIC')
          CALL RZMDIR ('HELP', NSYSDK, CHFTDK, CHTGDK)
          IERR   = IQUEST(1)
          IF (IOPS.NE.0) THEN
            CALL RZCDIR (PATHN, ' ')
            CALL RZFREE ('DBUDIC')
          ENDIF
          IF (IERR.NE.0) THEN
            IQUEST(1) = 159
+SELF, IF=$DEBUG, IF=-$P3CHILD.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUDIC : RZM'//
     +      'DIR error for path name '//PATHY//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
            GO TO 999
          ENDIF
        ENDIF
      ENDIF
+SELF.
*
* *** Try to load the dictionary information if it exists
*
      CALL RZCDIR (PATHD, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 0
+SELF, IF=-$P3CHILD.
        IF (IOUT.NE.0) THEN
          CALL RZCDIR (PATHN, ' ')
          IF (IOPS.NE.0) CALL RZLOCK ('DBUDIC')
          CALL RZMDIR ('DICTIONARY', NSYSDK, CHFTDK, CHTGDK)
          IERR   = IQUEST(1)
          IF (IOPS.NE.0) THEN
            CALL RZCDIR (PATHN, ' ')
            CALL RZFREE ('DBUDIC')
          ENDIF
          IF (IERR.NE.0) THEN
            IQUEST(1) = 159
+SELF, IF=$DEBUG, IF=-$P3CHILD.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUDIC : RZM'//
     +      'DIR error for path name '//PATHD//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
            GO TO 999
          ENDIF
        ENDIF
+SELF.
        GO TO 5
      ENDIF
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      ISTP   = NWKYDK + 1
      IF (NKEYDK.GT.0) THEN
        IPNT   = KOFSDB + LCDRDB + IKDRDB
        IMIN   = IUHUNT (-1, IQ(IPNT+MSERDB), NKEYDK*ISTP, ISTP)
        IF (IMIN.GT.0) THEN
          IMIN   = (IMIN - MSERDB) / ISTP + 1
          CALL DBKEYT
          CALL DBKEYR (IMIN, NWKYDK, KEYN)
          LFIXDB = LQ(KOFUDB+LBNODB+JBIAS)
          IF (LFIXDB.NE.0) CALL MZDROP (IDIVDB, LFIXDB, ' ')
          CALL DBRZIN (IDIVDB, LBNODB, JBIAS, IMIN, ICYCL, PATHD)
          IF (IQUEST(1).EQ.0)          GO TO 999
          IOUT   = 0
        ENDIF
      ENDIF
*
    5 KEYN(MSERDB) = -1
      KEYN(MUPNDB) = 0
      CALL DATIME (IDATE, ITIME)
      CALL DBPKTS (IDATE, ITIME*100,  KEYN(MBVRDB))
      KEYN(MEVRDB) = IBIGDB
      KEYN(MPVSDB) = 0
      KEYN(MFLGDB) = 1
      CALL DBPKTM (IDATE,  ITIME,  KEYN(MITMDB))
      LFIXDB = LQ(KOFUDB+LBNODB+JBIAS)
      IF (LFIXDB.NE.0) CALL MZDROP (IDIVDB, LFIXDB, ' ')
      NDWD   = NPUSDB*NWITDB + 1
      CALL DBBOOK (IDIVDB, LFIXDB, LBNODB, JBIAS, 'DIDB', 0, 0, NDWD,
     +             IODIDB, 0)
      IF (IQUEST(1).NE.0)              GO TO 999
      NITEM  = 0
      NKEEP  = NPUSDB
      CALL RZCDIR (PATHN, ' ')
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      IOPTP  = 0
*
* *** Now scan down to find all the subdirectories
*
   10 IF (NLEV.GT.1) THEN
        PATHN  = PATHN(1:NCHD(NLEV-1))//'/'//PATHX
        NCHD(NLEV) = NCHD(NLEV-1) + NCHR + 1
        CALL RZCDIR (PATHN, ' ')
        NKEYDK = IQUEST(7)
        NWKYDK = IQUEST(8)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        IF (NKEYDK.GT.0) THEN
          IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
        ELSE
          IOPTP  = 0
        ENDIF
      ENDIF
      NKEY(NLEV) = NKEYDK
      IOPT(NLEV) = IOPTP
      ISDI(NLEV) = 0
      NSDI(NLEV) = IQ(KOFSDB+LCDRDB+KNSDDB)
*
   20 ISDI(NLEV) = ISDI(NLEV) + 1
      IF (ISDI(NLEV).LE.NSDI(NLEV)) THEN
*
*  **   If a new subdirectory go down one level
*
        LS    = IQ(KOFSDB+LCDRDB+KLSDDB)
        IPNT  = LS + 7 * (ISDI(NLEV) - 1)
        CALL ZITOH (IQ(KOFSDB+LCDRDB+IPNT), IHDIR, 4)
        CALL UHTOC (IHDIR, 4, PATHX, 16)
        NCHR  = INDEX (PATHX, ' ') - 1
        IF (NCHR.LE.0.OR.NCHR.GT.16) NCHR = 16
        IF (IOPTP.NE.0) THEN
          DO 35 IK = 1, NKEYDK
            KK     = IK
            IDIG   = 0
   30       IF (KK.GT.0) THEN
              KK     = KK / 10
              IDIG   = IDIG + 1
              GO TO 30
            ENDIF
            IF (NCHR.EQ.IDIG) THEN
+SELF, IF=-IBM, -$P3CHILD.
              WRITE (PATHY, '(I8)') IK
+SELF, IF=IBM, IF=$P3CHILD.
              PATHY  = ' '
              CALL UTWRIT (PATHY, '(I8)', IK ,1)
+SELF.
              I1     = 8 - IDIG + 1
              PATHZ  = PATHY(I1:8)
              IF (PATHZ.EQ.PATHX)      GO TO 20
            ENDIF
   35     CONTINUE
        ELSE IF (NLEV.EQ.1) THEN
          IF (NCHR.EQ.10) THEN
            IF (PATHX.EQ.'DICTIONARY') GO TO 20
          ENDIF
        ENDIF
        NLEV   = NLEV +1
        GO TO 10
*
      ELSE
*
*  **   Check if the name is to be entered
*
        IF (NLEV.EQ.1)                 GO TO 60
        IF (NLEV.EQ.2) THEN
          IF ((NCHD(2)-NCHD(1)-1).EQ.10) THEN
            PATHZ  = PATHN(NCHD(1)+2:NCHD(2))
            IF (PATHZ.EQ.'DICTIONARY') GO TO 50
          ENDIF
        ENDIF
        PATHY  = PATHN(NCHD(1)+1:NCHD(NLEV))
        NCHR   = NCHD(NLEV) - NCHD(1)
        NFREE  = 0
        IF (NITEM.GT.0) THEN
          DO 40 I = 1, NITEM
            IPNT   = KOFUDB + LFIXDB + (I - 1) * NWITDB + 1
            NCHF   = IQ(IPNT+MDCNCH)
            IF (IQ(IPNT+MDCITM).GT.0) THEN
              IF (NCHR.EQ.NCHF) THEN
                CALL UHTOC (IQ(IPNT+MDCNAM), 4, PATHF, NCHF)
                PATHF  = PATHF(1:NCHF)
                IF (PATHY.EQ.PATHF)    GO TO 50
              ENDIF
            ELSE
              IF (NFREE.EQ.0) NFREE = I
            ENDIF
   40     CONTINUE
        ENDIF
*
*  **   Enter the new path name in the dictionary
*
        IF (NFREE.EQ.0) THEN
          NITEM  = NITEM + 1
          NFREE  = NITEM
          IF (NITEM.GT.NKEEP) THEN
            CALL ZSHUNT (IDIVDB, LFIXDB, LBDADB, 2, 0)
            LBDADB = LFIXDB
            LFIXDB = 0
            ND     = NDWD + NPUSDB * NWITDB
            CALL DBBOOK (IDIVDB, LFIXDB, LBNODB, JBIAS, 'DIDB', 0, 0,
     +                   ND, IODIDB, -1)
            IF (IQUEST(1).NE.0) THEN
              IERR   = IQUEST(1)
              CALL MZDROP (IDIVDB, LBDADB, ' ')
              IQUEST(1) = IERR
               GO TO 999
            ENDIF
            CALL UCOPY (IQ(KOFUDB+LBDADB+1), IQ(KOFUDB+LFIXDB+1), NDWD)
            CALL MZDROP (IDIVDB, LBDADB, ' ')
            NDWD   = IQ(KOFUDB+LFIXDB-1)
            NKEEP  = NKEEP + NPUSDB
          ENDIF
          IQ(KOFUDB+LFIXDB+MDCNTM) = NITEM
        ENDIF
        IPNT   = KOFUDB + LFIXDB + (NFREE - 1) * NWITDB + 1
        IQ(IPNT+MDCITM) = NFREE
        IQ(IPNT+MDCNCH) = NCHR
        IQ(IPNT+MDCLUP) = 0
        CALL UCTOH ('        ', IQ(IPNT+MDCALI), 4, 8)
        CALL UCTOH (PATHY, IQ(IPNT+MDCNAM), 4, NCHR)
*
   50   NLEV   = NLEV - 1
        IF (NLEV.GE.1) THEN
          LUP    = LQ(KOFSDB+LCDRDB+1)
          CALL MZDROP (0, LCDRDB, ' ')
          LCDRDB = LUP
          NKEYDK = NKEY(NLEV)
          IOPTP  = IOPT(NLEV)
          GO TO 20
        ENDIF
      ENDIF
*
   60 CONTINUE
+SELF, IF=-$P3CHILD.
*
* *** All subdirectories looked at; now store dictionary if permitted
*
      IF (IOUT.NE.0) THEN
        CALL RZCDIR (PATHD, ' ')
        IF (IOPS.NE.0) CALL RZLOCK ('DBUDIC')
        CALL RZOUT (IDIVDB, LFIXDB, KEYN, ICYCLE, 'S')
        IERR   = IQUEST(1)
        IF (IERR.NE.0) THEN
          IF (IOPS.NE.0) CALL RZFREE ('DBUDIC')
          IQUEST(1) = 157
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUDIC : RZOUT'//
     +    ' error for path name '//PATHD//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
          GO TO 999
        ENDIF
        CALL RZPURG (0)
        IERR   = IQUEST(1)
        IF (IOPS.NE.0) CALL RZFREE ('DBUDIC')
        IF (IERR.NE.0) THEN
          IQUEST(1) = 158
+SELF, IF=$DEBUG, IF=-$P3CHILD.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUDIC : RZPUR'//
     +    'G error for path name '//PATHD//''')', IARGDB, 0)
+SELF, IF=-$P3CHILD.
          GO TO 999
        ENDIF
      ENDIF
+SELF.
*
  100 IQUEST(1) = 0
*                                                             END DBUDIC
  999 END
+DECK, DBUNCP.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBUNCP (LC, LU, IK)
*     ==============================
*
************************************************************************
*                                                                      *
*        SUBR. DBUNCP (LC, LU*, IK)                                    *
*                                                                      *
*   Uncompresses data bank defined by LC in the Data Base              *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LC       Address of the bank to be uncompressed                  *
*     LU(*)    Address of the uncompressed bank                        *
*     IK       If nonzero the Key 1 of the master bank with reference  *
*              to which the bank is to be updated                      *
*                                                                      *
*   Called by DBCOMP, DBKXIN                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               = 83 : Data update but uncompreseed                    *
*               = 84 : The update structure has different number of    *
*                      data words                                      *
*               = 85 : No data in the structure                        *
*               = 86 : The update structure has different data type    *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DZPACK.
+CDE, P3DBL3, IF=$P3CHILD.
      DIMENSION       LC(9), LU(9), KEY(NINEDK)
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
      LREFDB(5) = LC(1)
      ITU    = IDBTYP (LREFDB(5))
+SELF, IF=$P3CHILD .
*
* *** Compression parameters are put by RZIN in IQUEST(96 .. 100)
*
      IF (ITU.EQ.5) THEN
        CALL UCOPY (IQUEST(96), IQ(KOFUDB+LREFDB(5)+1), 2)
      ENDIF
+SELF.
*
* *** Data uncompressed ?
*
      NWKEY  = MIN (NWKYDK, NINEDK)
      IF (IQ(KOFUDB+LREFDB(5)+1).EQ.0) THEN
        IF (IK.NE.0)        GO TO 991
        NDU    = IQ(KOFUDB+LREFDB(5)-1)
        JBIAS  = 2
        CALL DBBOOK (IDISDB, LU(1), LU(1), JBIAS, 'SAME', 0, 0, NDU,
     +               ITU, 0)
        IF (IQUEST(1).NE.0) GO TO 999
        IF (ITU.EQ.3)  THEN
          CALL UCOPY (Q(KOFUDB+LREFDB(5)+1), Q(KOFUDB+LU(1)+1), NDU)
        ELSE
          CALL UCOPY (IQ(KOFUDB+LREFDB(5)+1), IQ(KOFUDB+LU(1)+1), NDU)
        ENDIF
        GO TO 999
      ENDIF
*
* *** Uncompress data
* *** Which packing mode ?
*
      CALL UCOPY (Q(KOFUDB+LREFDB(5)+3), IXX, 1)
+SELF, IF=$P3CHILD.
      IF (ITU.EQ.5) IXX = IQUEST(98)
+SELF.
      PACKDZ = (JBIT (IXX, 32)) .EQ. 0
*
      IADS   = 5
*
      IF (PACKDZ) THEN
        CALL DBUCMZ (LREFDB(5), IADS)
        LU(1) = LAUXDL(IADS)
      ELSE
+SELF, IF=$P3CHILD.
        CALL UCOPY  (IQUEST(96), IQ(KOFUDB+LC(1)+1), 3)
+SELF.
        CALL DBUCMP (LREFDB(5), IADS)
        LU(1) = LAUXDL(IADS-1)
      ENDIF
      IF (IQUEST(1).NE.0)   GO TO 999
*
      IF (IK.EQ.0)          GO TO 999
      IF (NKEYDK.EQ.0)      GO TO 999
*
      CALL MZDROP (IDISDB, LREFDB(5), ' ')
*
      LREFDB(5) = 0
      LREFDB(6) = LU(1)
      LC(1)     = 0
      JBIAS  = 2
      CALL DBRZIN (IDISDB, LREFDB(5), JBIAS, IK, ICYCL, ' ')
      IF (IQUEST(1).NE.0)   GO TO 999
      LC(1)     = LREFDB(5)
+SELF, IF=$P3CHILD .
*
* *** Compression parameters are put by RZIN in IQUEST(96 .. 100)
*
      ITU    = IDBTYP (LREFDB(5))
      IF (ITU.EQ.5) THEN
        CALL UCOPY (IQUEST(96), IQ(KOFUDB+LREFDB(5)+1), 2)
      ENDIF
      IF (IPASP3.GT.1)      GO TO 10
+SELF.
      CALL DBKEYR (IK, NWKEY, KEY)
   10 LCC    = LREFDB(5)
*
* *** Uncompress master ?
*
      IF (IQ(KOFUDB+LREFDB(5)+1).NE.0) THEN
        IADS   = 5
        IF (PACKDZ) THEN
          CALL DBUCMZ (LREFDB(5), IADS)
          LCC    = LAUXDL(IADS)
        ELSE
+SELF, IF=$P3CHILD.
          CALL UCOPY  (IQUEST(96), IQ(KOFUDB+LC(1)+1), 3)
+SELF.
          CALL DBUCMP (LREFDB(5), IADS)
          LCC    = LAUXDL(IADS-1)
        ENDIF
      ENDIF
      IF (IQUEST(1).NE.0)   GO TO 999
*
* *** Update
* *** Look if the data are similar - STOP if they are not
*
      ND1    = IQ(KOFUDB+LREFDB(6) - 1)
      ND2    = IQ(KOFUDB+LCC - 1)
      IF (ND1.NE.ND2)       GO TO 992
      IF (ND1.EQ.0)         GO TO 993
*
      IT1    = IDBTYP (LREFDB(6))
      IT2    = IDBTYP (LCC)
      IF (IT1.NE.IT2)       GO TO 994
      IF (IT1.EQ.2.OR.IT1.EQ.5) THEN
        DO 20 ID = 3, ND1
          IQ(KOFUDB+LREFDB(6)+ID) = IQ(KOFUDB+LCC+ID)
     +                            - IQ(KOFUDB+LREFDB(6)+ID)
   20   CONTINUE
      ELSE
        DO 30 ID = 3, ND1
          Q(KOFUDB+LREFDB(6)+ID) = Q(KOFUDB+LCC+ID)
     +                           - Q(KOFUDB+LREFDB(6)+ID)
   30   CONTINUE
      ENDIF
   40 IF (LREFDB(5).NE.LCC) CALL MZDROP (IDISDB, LCC, ' ')
      GO TO 999
*
* *** Error codes
*
  991 IQUEST(1) = 83
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUNCP : Incompati'//
     +   'bility - Data is an update but uncompressed'')', IARGDB, 0)
+SELF.
      GO TO 999
*
  992 IQUEST(1) = 84
      IQUEST(11)= ND1
      IQUEST(12)= ND2
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUNCP : The 2 str'//
     +   'uctures have different number of data = '',2I4)',IQUEST(11),2)
+SELF.
      GO TO 999
*
  993 IQUEST(1) = 85
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUNCP : The data '//
     +   'structure does not have data'')', IARGDB, 0)
+SELF.
      GO TO 999
*
  994 IQUEST(1) = 86
      IQUEST(11)= IT1
      IQUEST(12)= IT2
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBUNCP : The 2 Str'//
     +   'uctures have different data type '',2I4)', IQUEST(11), 2)
+SELF.
      GO TO 999
*                                                             END DBUNCP
  999 END
+DECK, DBUPCK.
      SUBROUTINE DBUPCK (IAIN, LIN, LOU, LAUX, LBITL, IAOU)
*     =====================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBUPCK (IAIN, LIN, LOU*, LAUX, LBITL, IAOU*)            *
*                                                                      *
*   Uncompresses data from LBITL to 32 bit size                        *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IAIN     Input array                                             *
*     LIN      Length of the input array                               *
*     LOU(*)   Length of the output array                              *
*     LAUX     Number of words exceeding the length LBITL and therefore*
*              are stored in 32 bits with locations given              *
*     LBITL    Number of bits to be used for storing                   *
*     IAOU(*)  Output array                                            *
*                                                                      *
*   Called by DBUCMP                                                   *
*                                                                      *
*                                                                      *
************************************************************************
*
      DIMENSION       IAIN(LIN), IAOU(LIN)
      LOGICAL         AUXI, AUXIL
+SEQ, L3BITX, T=PASS.
*
*     ------------------------------------------------------------------
*
      CALL VZERO (IAOU, LOU)
*
      AUXI   = LAUX.GT.0
*
      LAUX   = LIN - LAUX + 1
      IN     = 1
      IB     = 1
      IO     = 1
   10 CONTINUE
      AUXIL  = (AUXI.AND.(IAIN(LAUX).EQ.IO))
      IF (AUXIL) THEN
        LAUX   = LAUX + 1
        IAOU(IO) = IAIN(LAUX)
        LAUX   = LAUX + 1
      ENDIF
      AUXIL  = .NOT.AUXIL
      IBA    = IB + LBITL
      IF (IBA.LE.32) THEN
        IF (AUXIL.AND.LBITL.GT.0) IAOU(IO) = JBYT (IAIN(IN), IB, LBITL)
        IB     = IBA
      ELSE
        LBIT1  = 32 - IB + 1
        IF (AUXIL.AND.LBIT1.GT.0) IAOU(IO) = JBYT (IAIN(IN), IB, LBIT1)
        IB     = IBA - 32
        IN     = IN + 1
        IF (AUXIL.AND.IB.GT.1)
     +  IAOU(IO) = MSBYT (IAIN(IN), IAOU(IO), LBIT1+1, IB-1)
      ENDIF
      IF (IO.LT.LOU) THEN
        IO     = IO + 1
        GO TO 10
      ENDIF
*                                                             END DBUPCK
      END
+DECK, DBUPFZ.
      SUBROUTINE DBUPFZ (AI, NDI, AO, NDO)
*     ====================================
*
************************************************************************
*                                                                      *
*        SUBR. DBUPFZ (AI, NDI, AO*, NDO)                              *
*                                                                      *
*   Unompress floating point data  when only nonzero elements are      *
*   stored                                                             *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     AI       Input array to be uncompressed                          *
*     NDI      Number of elements in AI                                *
*     AO(*)    Output array of the uncompressed elements               *
*     NDO      Number of elements in AO                                *
*                                                                      *
*   Called by DBUCMZ                                                   *
*                                                                      *
************************************************************************
*
      DIMENSION       AI(NDO), AO(NDO)
*
*     ------------------------------------------------------------------
*
      CALL VZERO (AO(1), NDO)
*
      DO 10 I = 1, NDI
        I2     = 2*I
        I1     = I2 - 1
        J      = AI(I1)
        AO(J)  = AI(I2)
   10 CONTINUE
*                                                             END DBUPFZ
      END
+DECK, DBUPIZ.
      SUBROUTINE DBUPIZ (IAI, NDI, IAO, NDO)
*     ======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBUPIZ (IAI, NDI, IAO*, NDO)                            *
*                                                                      *
*   Uncompress integer data when only nonzero elements are stored      *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IAI      Input array to be uncompressed                          *
*     NDI      Number of elements in IAI                               *
*     IAO(*)   Output array of the uncompressed elements               *
*     NDO      Number of elements in IAO                               *
*                                                                      *
*   Called by DBUCMZ                                                   *
*                                                                      *
************************************************************************
*
      DIMENSION       IAI(NDO), IAO(NDO)
*
*     ------------------------------------------------------------------
*
      CALL VZERO (IAO(1), NDO)
*
      DO 10 I = 1, NDI
        I2     = 2*I
        I1     = I2 - 1
        J      = IAI(I1)
        IAO(J) = IAI(I2)
   10 CONTINUE
*                                                             END DBUPIZ
      END
+DECK, DBUVTX.
      SUBROUTINE DBUVTX (IDAY, ITIM)
*     ==============================
*
************************************************************************
*                                                                      *
*        SUBR. DBUVTX (IDAY*, ITIM*)                                   *
*                                                                      *
*   Returns the current date and time                                  *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDAY     Date in YYMMDD                                          *
*     ITIM     Time in seconds                                         *
*                                                                      *
*   Called by DBFOPN, DBxxxx in the Example patches                    *
*                                                                      *
************************************************************************
*
+SELF, IF=-VAX.
      COMMON /SLATE/  ISLAT(40)
+SELF.
      INTEGER         IDAY, ITIM
*
*     ------------------------------------------------------------------
*
* ** Get date and time for constructing the return arguments
*
+SELF, IF=-VAX.
      CALL DATIME (IDAY, ITIM)
      IDAY = MOD (IDAY, 1000000)
      ITIM = ISLAT(4) * 3600 + ISLAT(5) * 60 + ISLAT(6)
+SELF, IF=VAX.
      CALL LIB$DAY (IDAY,,ITIM)
+SELF.
*                                                             END DBUVTX
      END
+DECK, IDBTYP.
      FUNCTION IDBTYP (L)
*     ===================
*
************************************************************************
*                                                                      *
*        FUNC. IDBTYP (L)                                              *
*                                                                      *
*   Gets the bank I/O type from the address of L                       *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     L        Address of the bank                                     *
*                                                                      *
*   Called by several DB routines                                      *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
      LST = L - IQ(KOFUDB+L-3) - JBYT(IQ(KOFUDB+L),19,4) - 1
      IDBTYP = JBYT (LQ(KOFUDB+LST), 17, 16)
*                                                             END IDBTYP
      END
+PATCH, DBONLINE, IF=VAX, IF=$SERVER.
+DECK, DBCHKCLI.
      SUBROUTINE DB_CHK_CLIENT (DB_CURRENT_SNAME, DB_CURRENT_LNAME,
     +                          DB_CLUSCOM_NAME, IERR)
*     =============================================================
*
************************************************************************
*                                                                      *
*        SUBR. DB_CHK_CLIENT (DB_CURRENT_SNAME*, DB_CURRENT_LNAME*,    *
*                             DB_CLUSCOM_NAME*, IERR*)                 *
*                                                                      *
*   Finds the short, long names and the CLUSCOM name for the task      *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     DB_CURRENT_SNAME(*) Short name                                   *
*     DB_CURRENT_LNAME(*) Long name                                    *
*     DB_CLUSCOM_NAME(*)  Name of the CLUSCOM                          *
*     IERR(*)             Error code (0 if no error)                   *
*                                                                      *
*   Called by DBINIT                                                   *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
      CHARACTER*2     DB_CURRENT_SNAME
      CHARACTER*4     DB_CURRENT_LNAME
      CHARACTER*9     DB_CLUSCOM_NAME
      CHARACTER*2     CLIENT_LABEL
*           Process names stuff
      CHARACTER       P_NODENAME*31, P_PRCNAME*31, P_IMGNAME*80
      INTEGER*4       P_NODEN_L , P_PRCN_L, P_IMGN_L
      LOGICAL         VALID_PRC , VALID_IMG
*           Database Ids for logical names
      PARAMETER       (NUM_DB=8)
      CHARACTER*2     DB_SNAME(NUM_DB)
      CHARACTER*4     DB_LNAME(NUM_DB)
      DATA            DB_SNAME /'TE', 'EC', 'HC', 'MU', 'FL', 'JT',
     +                          'L3', 'SC'/
      DATA            DB_LNAME /'TECH', 'ECAL', 'HCAL', 'MUCH', 'FLUM',
     +                          'TRIG', 'L3RC', 'SCNT'/
*
*     ------------------------------------------------------------------
*
      VALID_IMG    = .FALSE.
      VALID_PRC    = .FALSE.
      CLIENT_LABEL = 'XX'
      CALL DB_G_NODE    (P_NODENAME, P_NODEN_L)
      CALL DB_G_NAME    (P_PRCNAME , P_PRCN_L)
      CALL DB_G_IMGNAME (P_IMGNAME , P_IMGN_L)
      K_DB_P     = 0
      K_DB_I     = 0
      DO 10 I = 1, NUM_DB
        IF (P_IMGNAME(1:1).EQ.DB_SNAME(I)(1:1)) THEN
          VALID_IMG = .TRUE.
          K_DB_I    = I
        ENDIF
   10 CONTINUE
      IF (.NOT.VALID_IMG) THEN
        CALL DBPRNT (L3PRDB, '('' DB_CHK_CLIENT (DBINIT) NON FATAL ER'//
     +       'ROR -Incorrect Image Name: '//P_IMGNAME(1:P_IMGN_L)//''')'
     +,      IARGDB, 0)
        DO 15 I = 1, NUM_DB
          IF (P_PRCNAME(1:1).EQ.DB_SNAME(I)(1:1)) THEN
            VALID_PRC = .TRUE.
            K_DB_P    = I
          ENDIF
   15   CONTINUE
        IF (VALID_PRC) THEN
          DB_CURRENT_SNAME = DB_SNAME(K_DB_P)
          DB_CURRENT_LNAME = DB_LNAME(K_DB_P)
          IF (P_PRCN_L.EQ.9) CLIENT_LABEL = P_PRCNAME(8:9)
        ENDIF
      ELSE
        DB_CURRENT_SNAME = DB_SNAME(K_DB_I)
        DB_CURRENT_LNAME = DB_LNAME(K_DB_I)
        IF(P_IMGN_L.EQ.9) CLIENT_LABEL = P_IMGNAME(8:9)
      ENDIF
      IF (VALID_PRC.OR.VALID_IMG) THEN
        DB_CLUSCOM_NAME(1:2) = DB_CURRENT_SNAME
        DB_CLUSCOM_NAME(3:7) = '_DBC_'
        DB_CLUSCOM_NAME(8:9) = CLIENT_LABEL
        IERR = 0
      ELSE
        DB_CLUSCOM_NAME = 'WRONGNAME'
        IERR = 1
      ENDIF
*                                                      END DB_CHK_CLIENT
      END
+DECK, DBCWSV.
      SUBROUTINE DBCWSV
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBCWSV                                                  *
*                                                                      *
*   Releases the CLUSCOM and communicates with the server              *
*                                                                      *
*   Called by DBDELT, DBEALI, DBENTB, DBNTOP, DBPRGD, DBRENK, DBENFZ,  *
*             DBKOUT, DBSDIR, DBSNAM, DBSPUR                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =222 : Error in CC_RELEASE for releasing the CLUSCOM   *
*               =223 : Error in ICSIGNAL for signalling the VAX server *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DBSRVR.
+CDE, DRCCOM.
      INTEGER         ICACHE(4)
      BYTE            BCACHE(16)
      EQUIVALENCE     (BCACHE, ICACHE)
*
*     ------------------------------------------------------------------
*
      IWORDR(1) = IQUEST(9)
      CALL CC_RELEASE ('DRCCOM', ' ', IERR)
      IF (IERR.NE.0) THEN
        IQUEST(1) = 222
        IQUEST(11)= IERR
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCWSV : Error'//
     +  ' '',I10,'' in CC_RELEASE'')', IQUEST(11), 1)
+SELF.
        GO TO 999
      ENDIF
      TIMEOUT = 100
*
*  ** First 2 bytes of the cache contain identifier
*  ** of calling client; last word contains a flag
*  ** to be changed by the server.
*
      BCACHE(1) = ICHAR(FILEDB(20:20))
      BCACHE(2) = ICHAR(FILEDB(21:21))
      ICACHE(3) = IOPBDA
      ICACHE(4) = -1
      CALL IC_SIGNAL (CACHDB, ICACHE, TIMEOUT, ' ', IERR)
      IF (IERR.NE.0) THEN
        IQUEST(1) = 223
        IQUEST(11)= IERR
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBCWSV : Error'//
     +  ' '',I10,'' in IC_SIGNAL'')', IQUEST(11), 1)
+SELF.
        GO TO 999
      ENDIF
      IQUEST(1) = ICACHE(3)
      IQUEST(2) = ICACHE(2)
*                                                             END DBCWSV
  999 END
+DECK, DBGIMGNA.
      SUBROUTINE DB_G_IMGNAME (NAME, LENGTH)
*     ======================================
*
************************************************************************
*                                                                      *
*        SUBR. DB_G_IMGNAME (NAME*, LENGTH*)                           *
*                                                                      *
*   Finds the executing image name in the character variable NAME      *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     NAME     Name of the task                                        *
*     LENGTH   Length of the character string NAME                     *
*                                                                      *
*   Called by DB_CHK_CLIENT                                            *
*                                                                      *
************************************************************************
*
      CHARACTER*(*)   NAME
      INCLUDE '($JPIDEF)'
      STRUCTURE /ITMLST/
         UNION
            MAP
               INTEGER*2 BUFLEN
               INTEGER*2 CODE
               INTEGER*4 BUFADR
               INTEGER*4 RETLENADR
            END MAP
            MAP
               INTEGER*4 END_LIST
            END MAP
         END UNION
      END STRUCTURE
      RECORD /ITMLST/ JPI_LIST(2)
      INTEGER*4 STATUS,SYS$GETJPIW
*
*     ------------------------------------------------------------------
*
      JPI_LIST(1).BUFLEN    = 80
      JPI_LIST(1).CODE      = JPI$_IMAGNAME
      JPI_LIST(1).BUFADR    = %LOC(NAME)
      JPI_LIST(1).RETLENADR = %LOC(LENGTH)
      JPI_LIST(2).END_LIST  = 0
 
      STATUS = SYS$GETJPIW (,,,JPI_LIST,,,)
      IF (.NOT. STATUS) CALL LIB$SIGNAL (%VAL(STATUS))
*
* *** Parse full image name and strip off device,directory,file type
* *** and version.
*
      CALL STR$UPCASE ( NAME(1:LENGTH), NAME(1:LENGTH) )
      DO 10 J=1,LENGTH
        IF(NAME(J:J).EQ.']') LOC_OFFSET = J
   10 CONTINUE
      DO 20 J=LOC_OFFSET+1,LENGTH
        IF(NAME(J:J).EQ.'.') LOC_BORDER = J
   20 CONTINUE
      LENGTH1 = LOC_BORDER - LOC_OFFSET - 1
      DO 30 J=1,LENGTH1
        NAME(J:J) = NAME(LOC_OFFSET+J:LOC_OFFSET+J)
   30 CONTINUE
      LENGTH = LENGTH1
*                                                       END DB_G_IMGNAME
      END
+DECK, DBGNAME.
      SUBROUTINE DB_G_NAME (NAME, LENGTH)
*     ===================================
*
************************************************************************
*                                                                      *
*        SUBR. DB_G_NAME (NAME*, LENGTH*)                              *
*                                                                      *
*   Finds the task name in the character variable NAME                 *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     NAME     Name of the task                                        *
*     LENGTH   Length of the character string NAME                     *
*                                                                      *
*   Called by DB_CHK_CLIENT                                            *
*                                                                      *
************************************************************************
*
      CHARACTER*(*)   NAME
      INCLUDE '($JPIDEF)'
      STRUCTURE /ITMLST/
         UNION
            MAP
               INTEGER*2 BUFLEN
               INTEGER*2 CODE
               INTEGER*4 BUFADR
               INTEGER*4 RETLENADR
            END MAP
            MAP
               INTEGER*4 END_LIST
            END MAP
         END UNION
      END STRUCTURE
      RECORD /ITMLST/ JPI_LIST(2)
      INTEGER*4 STATUS,SYS$GETJPIW
*
*     ------------------------------------------------------------------
*
      JPI_LIST(1).BUFLEN    = 15
      JPI_LIST(1).CODE      = JPI$_PRCNAM
      JPI_LIST(1).BUFADR    = %LOC(NAME)
      JPI_LIST(1).RETLENADR = %LOC(LENGTH)
      JPI_LIST(2).END_LIST  = 0
*
      STATUS = SYS$GETJPIW (,,,JPI_LIST,,,)
      IF (.NOT. STATUS) CALL LIB$SIGNAL (%VAL(STATUS))
*
      STATUS = SYS$GETJPIW (,,,JPI_LIST,,,)
      IF (.NOT. STATUS) CALL LIB$SIGNAL (%VAL(STATUS))
*                                                          END DB_G_NAME
      END
+DECK, DBGNODE.
      SUBROUTINE DB_G_NODE (NAME, LENGTH)
*     ===================================
*
************************************************************************
*                                                                      *
*        SUBR. DB_G_NODE (NAME*, LENGTH*)                              *
*                                                                      *
*   Finds the name of the node where the program is running            *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     NAME     Name of the node                                        *
*     LENGTH   Length of the character string NAME                     *
*                                                                      *
*   Called by DB_CHK_CLIENT                                            *
*                                                                      *
************************************************************************
*
      CHARACTER*(*)   NAME
      INCLUDE '($LNMDEF)'
      STRUCTURE /ITMLST/
         UNION
            MAP
               INTEGER*2 BUFLEN
               INTEGER*2 CODE
               INTEGER*4 BUFADR
               INTEGER*4 RETLENADR
            END MAP
            MAP
               INTEGER*4 END_LIST
            END MAP
         END UNION
      END STRUCTURE
      RECORD /ITMLST/ TRN_LIST(2)
      INTEGER*4 STATUS,SYS$TRNLNM
*
*     ------------------------------------------------------------------
*
      TRN_LIST(1).BUFLEN    = 15
      TRN_LIST(1).CODE      = LNM$_STRING
      TRN_LIST(1).BUFADR    = %LOC(NAME)
      TRN_LIST(1).RETLENADR = %LOC(LENGTH)
      TRN_LIST(2).END_LIST  = 0
*
      STATUS = SYS$TRNLNM (,'LNM$SYSTEM_TABLE','SYS$NODE',,TRN_LIST)
      IF (.NOT. STATUS) CALL LIB$SIGNAL (%VAL(STATUS))
*                                                          END DB_G_NODE
      END
+DECK, DBWLOK.
      SUBROUTINE DBWLOK
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBWLOK                                                  *
*                                                                      *
*   Locks the CLUSCOM before writing onto it and communicating to the  *
*   server                                                             *
*                                                                      *
*   Called by DBDELT, DBEALI, DBENTB, DBNTOP, DBPRGD, DBRENK, DBENFZ,  *
*             DBKOUT, DBSDIR, DBSNAM, DBSPUR                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =221 : Error in CC_WRITELOCK for locking the CLUSCOM   *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DBSRVR.
+CDE, DRCCOM.
*
*     ------------------------------------------------------------------
*
      LUFZDF = LUFMDB
*
      CALL CC_WRITELOCK ('DRCCOM', ' ', IRC)
      IF (IRC.NE.0) THEN
        IQUEST(1) = 221
        IQUEST(11)= IRC
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBWLOK : Error'//
     +  ' '',I10,'' in CC_WRITELOCK '')', IQUEST(11), 1)
+SELF.
      ELSE
        IQUEST(1) = 0
      ENDIF
*                                                             END DBWLOK
      END
+PATCH, DBOFFLIN, IF=APOLLO,HPUX,IBM,IBMRT, IF=$SERVER.
+DECK, DBFOPN, IF=APOLLO,HPUX,IBMRT.
      SUBROUTINE DBFOPN (LUN, IRC)
*     ============================
*
************************************************************************
*                                                                      *
*        SUBR. DBFOPN (LUN, IRC*)                                      *
*                                                                      *
*   Opens an file ascii file on the specified unit for Apollo          *
*   with time upto second embedded in it to ensure a unique filename   *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IRC      Error code (0 if no error)                              *
*     LUN      Unit number for opening the file                        *
*                                                                      *
*   Called by DBINIT, DBSTSV                                           *
*                                                                      *
************************************************************************
*
      INTEGER*2       YEAR, MONTH, DAY, HOUR, MINUTE, SECOND
      CHARACTER       CYEAR*2, CMON*2, CDAY*2, CHOUR*2
      CHARACTER       CMIN*2, CSEC*2, FNAME*80
      LOGICAL         EXIST
*
*     ------------------------------------------------------------------
*
* *** Get date and time for constructing the file name
*
   10 CALL DBUVTX (IDAY, ITIM)
      YEAR   = MOD (IDAY/10000, 100)
      MONTH  = MOD (IDAY/100  , 100)
      DAY    = MOD (IDAY      , 100)
      HOUR   = MOD (ITIM/3600 , 100)
      MINUTE = MOD (ITIM/60   ,  60)
      SECOND = MOD (ITIM      ,  60)
*
      WRITE (CYEAR, '(I2.2)') YEAR
      WRITE (CMON,  '(I2.2)') MONTH
      WRITE (CDAY,  '(I2.2)') DAY
      WRITE (CHOUR, '(I2.2)') HOUR
      WRITE (CMIN,  '(I2.2)') MINUTE
      WRITE (CSEC,  '(I2.2)') SECOND
+SELF, IF=APOLLO.
      FNAME = 'ap'//CYEAR//CMON//CDAY//'.t'//CHOUR//CMIN//CSEC
+SELF, IF=HPUX.
      FNAME = 'hp'//CYEAR//CMON//CDAY//'.t'//CHOUR//CMIN//CSEC
+SELF, IF=IBMRT.
      FNAME = 'ib'//CYEAR//CMON//CDAY//'.t'//CHOUR//CMIN//CSEC
+SELF.
*
* ** If file already exists then go back to get a new time
*
      INQUIRE (FILE=FNAME, EXIST=EXIST)
      IF (EXIST) GO TO 10
*
* *** Open the file with an Open Statement
*
      OPEN (UNIT=LUN, ACCESS='SEQUENTIAL',
     +      FORM='FORMATTED', STATUS ='NEW', IOSTAT=ISTAT,
     +      FILE  = FNAME)
      IF (ISTAT .NE. 0) THEN
        IRC = 1
      ELSE
        IRC = 0
      ENDIF
*                                                             END DBFOPN
      END
+DECK, DBFSEND, T=DATA, IF=APOLLO,HPUX,IBMRT.
#!/bin/sh
########################################################################
#  Script to send a journal file from the users directory              #
#  when it is closed to the journal files directory                    #
#                                                                      #
#  Called By DBFSND                           Author: Nica Colino      #
########################################################################
 
jourdir="/l3/prod/jour"
PATH="/bin:/etc:/usr/ucb:/usr/bin"
 
#
# ## Get the user name and node to put in the file name
#
node=`hostname`
file2="$2.$LOGNAME.$node"
 
# the file exists ?
 
if test -r "$1"
  then
   continue
  else
   echo "$0: The file $1 does not exist" 1>&2
   exit 1
fi
 
# change the name
 
if mv $1 $file2 2> /dev/null
  then
   continue
  else
    echo "$0: mv $1 $file2 fails. File left in `pwd`/$1" 1>&2
    exit 2
fi
 
#  check if the file already exists in the jourdir
 
if test -w $jourdir/$file2
  then
   echo "$0: The file $file2 already exist in $jourdir."\
                 "File left in `pwd`/$file2" 1>&2
   exit 3
fi
 
#  move the file to the jourdir
 
if mv $file2 $jourdir 2> /dev/null
  then
    continue
  else
    echo "$0: mv fails, file $1 left in `pwd`/$file2" 1>&2
    exit 4
fi
 
#  wakeup tolepics server
 
if test -f /usr/apollo/bin/prism
  then
 
#   apollo case
 
    if test -f /prod/db/server/tolepics/wakeup
      then
        if /usr/apollo/bin/prism
          then
            /prod/db/server/tolepics/wakeup \
                 /prod/db/server/tolepics/ipc_tolepics
          else
            /prod/db/server/tolepics/wakeup_68m \
                 /prod/db/server/tolepics/ipc_tolepics
        fi
      else
        rsh a-l3wlk2 /prod/db/server/tolepics/wakeup \
            /prod/db/server/tolepics/ipc_tolepics 1>/dev/null 2>&1 &
 
    fi
  else
 
#   other unix system case
 
    remsh a-l3wlk2 /prod/db/server/tolepics/wakeup \
            /prod/db/server/tolepics/ipc_tolepics 1>/dev/null 2>&1 &
fi
exit 0
+DECK, DBFSND, IF=APOLLO,HPUX,IBMRT.
      SUBROUTINE DBFSND (LUN, CTOP, IERR)
*     ===================================
*
************************************************************************
*                                                                      *
*        SUBR. DBFSND (LUN, CTOP, IERR*)                               *
*                                                                      *
*   Closes an  ascii file on the specified unit for Apollo.            *
*   invokes a shell script in the '/l3/bin' directory to send the      *
*   file to '/l3/prod/jour' directory.                                 *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUN      Logical unit number where the file sits                 *
*     CTOP     First 2 characters of the file after being moved        *
*     IERR     Error code (0 if no error)                              *
*                                                                      *
*   Called by DBSTSV                                                   *
*                                                                      *
************************************************************************
*
      LOGICAL         OPEN, EXIST
      CHARACTER       NAMEO*80, NAMEN*80, CTOP*(*), CH2*2, ARGS*256
+SELF, IF=UNIX.
      INTEGER         DBSYSTEM
+SELF, IF=-UNIX.
      INTEGER         DBSYSTEM_
+SELF.
*
*     ------------------------------------------------------------------
*
* ** Get the name of the file and close it
*
      IERR = 0
      INQUIRE (LUN, OPENED=OPEN, NAME=NAMEO)
      IF (.NOT.OPEN) GO TO 999
      NCH  = LENOCC (NAMEO)
      DO 10 I = NCH, 1, -1
        IF (NAMEO(I:I).EQ.'/') THEN
          I1   = I + 1
          GO TO 20
        ENDIF
   10 CONTINUE
      I1   = 1
   20 CH2  = CTOP
      CH2  = CTOP
      CALL CUTOL (CH2)
      NCH2 = LENOCC (CH2)
      IF (NCH2.GT.0.AND.NCH.GT.I1+1) THEN
        NAMEN = CH2(1:NCH2)//NAMEO(I1+2:NCH)
      ELSE IF (NCH2.GT.0) THEN
        NAMEN = CH2(1:NCH2)//NAMEO(I1:NCH)
      ELSE
        NAMEN = NAMEO(I1:NCH)
      ENDIF
      INQUIRE (FILE='/l3/bin/dbfsend', EXIST=EXIST)
      IF (EXIST) THEN
        ARGS = '/l3/bin/dbfsend '//NAMEO(I1:NCH)//' '//NAMEN
      ELSE
        ARGS = 'dbfsend '//NAMEO(I1:NCH)//' '//NAMEN
      ENDIF
      CLOSE (LUN)
*
* *** Invoke the shell script to send the file
*
+SELF, IF=UNIX.
      IERR = DBSYSTEM (ARGS)
+SELF, IF=-UNIX.
      IERR = DBSYSTEM_(ARGS)
+SELF.
*                                                             END DBFSND
  999 END
+DECK, DBFZLO.
      SUBROUTINE DBFZLO (LUN, IFND)
*     =============================
*
************************************************************************
*                                                                      *
*        SUBR. DBFZLO (LUN, IFND*)                                     *
*                                                                      *
*   Sees if the FZ file is already opened                              *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUN      Logical unit number                                     *
*     IFND(*)  Return flag (0 if not found; 1 if found)                *
*                                                                      *
*   Called by DBINIT                                                   *
*                                                                      *
************************************************************************
*
+CDE, MQSYS.
+CDE, EQLQF.
*
*     ------------------------------------------------------------------
*
* *** Loop over control banks
*
      LQFF   = LQFS
   10 IF (LQFF.NE.0) THEN
        IF (IQ(KQSP+LQFF-5).EQ.LUN) THEN
          IFND   = 1
        ELSE
          LQFF   = LQ(KQSP+LQFF)
          GO TO 10
        ENDIF
      ELSE
        IFND   = 0
      ENDIF
*                                                             END DBFZLO
      END
+DECK, DBSTSV.
      SUBROUTINE DBSTSV (TOPN, IFL)
*     =============================
*
************************************************************************
*                                                                      *
*        SUBR. DBSTSV (TOPN)                                           *
*                                                                      *
*   Sends the journal file to the offline server if required           *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     TOPN     Name of the top directory for the current update        *
*     IFL      Flag (0 if journal file to be reopened; -1 if not)      *
*                                                                      *
*   Called by DBDELT, DBEALI, DBEND,  DBENDF, DBENTB, DBNTOP, DBPRGD,  *
*             DBRENK, DBSAVE, DBENFZ, DBKOUT, DBSDIR, DBSNAM, DBSPUR   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =225 : Error in sending the spool file to the server   *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DFZLUN.
+CDE, DINITL.
      CHARACTER       TOPN*(*)
*
*     ------------------------------------------------------------------
*
+SELF, IF=APOLLO,HPUX,IBMRT.
      LUFZDF = LUFMDB
+SELF, IF=IBM.
      LUFZDF = 7
+SELF.
      IF (TOPN.NE.TOPLDI.AND.TOPLDI(1:1).NE.' ') THEN
        CALL FZENDO (LUFZDF, 'QTE')
+SELF, IF=IBM.
        CALL VMCMS ('EXEC DBSENDSM '//TOPLDI(3:4), IRC)
+SELF, IF=APOLLO,HPUX,IBMRT.
        CALL DBFSND (LUFZDF, TOPLDI(3:4), IRC)
+SELF.
        IF (IFL.EQ.0) THEN
+SELF, IF=APOLLO,HPUX,IBMRT.
          CALL DBFOPN (LUFZDF, IRC2)
          IF (IRC.EQ.0) IRC = IRC2
+SELF.
          CALL FZFILE (LUFZDF, 0, 'AOQ')
        ENDIF
        IF (IRC.NE.0) THEN
          IQUEST(1) = 225
          IQUEST(11)= IRC
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '('' DBSTSV : Error'//
     +    ' '',I6,'' in sending file to server for '//TOPLDI//''')',
     +    IQUEST(11), 1)
+SELF.
          TOPLDI = ' '
          GO TO 999
        ENDIF
        IQUEST(1) = 0
      ELSE
        IQUEST(1) = 0
+SELF, IF=APOLLO,HPUX,IBMRT.
        IF (IFL.EQ.-1) THEN
          CLOSE (LUFZDF, STATUS='DELETE')
        ENDIF
+SELF.
      ENDIF
      IF (IFL.EQ.0) THEN
        TOPLDI = TOPN
      ELSE
        TOPLDI = ' '
      ENDIF
*                                                             END DBSTSV
  999 END
+DECK, DBSENDSM, T=DATA, IF=IBM.
/**********************************************************************/
/*                                                                    */
/*                    EXEC    DBSENDSM                                */
/*                                                                    */
/*                                                                    */
/*                                           89/07/06  Nica Colino    */
/*                             Modified the  91/11/07  Nica Colino    */
/*                                                                    */
/**********************************************************************/
 
/*   Return codes:
                  If time = 0
                               RC =  0  File sent to the server
                               RC = -5  Error sending the file
                  If time ^= 0
                               RC =  0  File process without errors
                               RC =  1  File queued
                               RC =  2  File sent
                               RC = -1  File queued and requeued
                               RC = -2  File processed with error
*/
 
Address command
Trace Off
/*'TIME'("E")*/
Parse arg db time
sm_exec = "L3DBSM"
sm_user = "L3DBSM"
sm_node = "LEPICS"
If time="" | ^'DATATYPE'(time,"N") | time<0 | time>999 then wait = 0
Else wait = time
'MAKEBUF'
bufn =rc
'IDENTIFY ( LIFO'
Parse pull myuser . mynode . myrscs .
 
/* In batch mode send the file always to the A class */
 
If myuser ^= 'XNAME'("USERID") then wait = 0
 
'CPUSH'("PUN")
If mynode ^= sm_node then do
  'CP TAG DEV PUNCH' sm_node sm_user
  user_dest = myrscs
End
Else do
  user_dest = sm_user
  'CP TAG DEV PUNCH'
End
 
If wait = 0 then class = "A"
Else             class = "X"
'EXECIO 0 CP ( STRING SPOOL PUNCH NOCONT'
'EXECIO 1 CP ( STRING CLOSE PUNCH CLASS' class 'NOHOLD COPY 1 TO',
    user_dest 'NAME' db'XXXXXX' sm_exec
rcsave = rc
If rcsave = 2 then do
  sp='QSPOOL'("PUN","LATEST","SPOOLID")
  'EXECIO 0 CP ( STRING CHANGE PUN' sp 'CLASS' class 'NAME',
                 db'XXXXXX' sm_exec
  'CP TAG FILE' sp sm_node sm_user
  'EXECIO 1 CP ( STRING TRANSFER PUN' sp 'TO' user_dest
  rcsave=rc
End
If rcsave = 0 then do
  Parse pull . . . . . . . . check .
End
 
'CPOP'("PUN")
'DROPBUF' bufn
If rcsave ^= 0 then Exit -5
If wait = 0 then Exit 0
/*Say 'TIME'("E")*/
 
check_q = check "QUEUED"
check_p = check "PROCESSED"
Queued = 0
process = 0
'CPUSH'("SET")
  'NUCXLOAD IUCVTRAP ( SYSTEM '
  'CP SET MSG     IUCV'
  'IUCVTRAP ON'
do forever
  'IUCVTRAP EXTRACT ( WAIT' wait
   rcsave = rc
   If Rcsave = 2 | Rcsave = 3 then leave
   Else do
     Parse var iucvmsg . "from" ruser ": " text
     If ruser = XNAME("RSCSID") | ruser = "DECMCS" then do
       Parse Var text . "FROM" ruser_node text
       Parse Var ruser_node rnode "(" ruser ")" .
     End
     If text = check_q then do
       queued = 1
/*Say 'TIME'("E")*/
       iterate
     End
     Parse var text rc_ret text
     If text = check_p then do
       process = 1
       leave
     End
   End
end
'IUCVTRAP OFF'
'CPOP'('SET')
/*Say 'TIME'("R")*/
If process = 0 then Exit 2-Queued
Else Exit rc_ret
+DECK, DBSYSTEM, T=A, IF=APOLLO,HPUX,IBMRT.
int dbsystem_(arg,larg)
int larg;
char *arg;
{
  return system(arg)>>8;
}
+PATCH, DBPLOT.
+DECK, DBIOTY.
      SUBROUTINE DBIOTY (LAD, NOBJ, KOBJ, IOTY)
*     =========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBIOTY (LAD, NOBJ, KOBJ, IOTY*)                         *
*                                                                      *
*   Prepares the IO format of a list of elements in a bank from the    *
*   bank IO descriptor                                                 *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LAD      Address of the data in DBSTOR                           *
*     NOBJ     Number of elements to be considered                     *
*     KOBJ     Indices of the elements                                 *
*     IOTY(*)  Variable type (2 for integer, 3 for floating point,..)  *
*                                                                      *
*   Called by DBPLNT, DBPLOB, DBPLOV                                   *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, MZIOC.
      DIMENSION       KOBJ(9), IOTY(9)
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
*  ** No data to display
*
      IF (NOBJ.LE.0)        GO TO 999
      DO 5 I = 1, NOBJ
    5 IOTY(I) = 3
      IF (LAD.LE.0)         GO TO 999
      NDAT = IQ(KOFUDB+LAD-1)
      IF (NDAT.LE.0)        GO TO 999
*
*  ** Crack I/O Words into the character description
*
      LIO = LAD - IQ(KOFUDB+LAD-3) - JBYT(IQ(KOFUDB+LAD),19,4) - 1
      CALL MZIOCR (LQ(KOFUDB+LIO))
*
*  ** This part (upto the RETURN) is by courtesy of J. Zoll
*
      NDONE = 0
      JFOCUR = 0
   10 ITYPE = MFO(JFOCUR+1)
      IF (ITYPE.EQ.7)       GO TO 15
      NWSEC = MFO(JFOCUR+2)
      NDO   = NWSEC
      IT    = ITYPE
      IF (NDO.GT.0)         GO TO 30
*
      IF (NDO.LT.0)  THEN
*
*  *    Rest of the bank
*
        NDO = NDAT
      ELSE
*
*  *    Dynamic sector
*
        NDONE = NDONE + 1
        NDO   = IQ(KOFUDB+LAD+NDONE)
      ENDIF
      GO TO 20
*
*  ** Self-describing sector
*
   15 NDONE  = NDONE + 1
      IWORD  = IQ(KOFUDB+LAD+NDONE)
      IT     = MOD (IWORD,16)
      NDO    = IWORD/16
*
   20 IF (IT.GE.8)          GO TO 999
      IF (NDO.LT.0)         GO TO 999
      IF (NDO.EQ.0)         GO TO 999
*
   30 JS     = NDONE + 1
      JE     = MIN (NDONE+NDO, NDAT)
      DO 35 I = 1, NOBJ
        IF (KOBJ(I).GE.JS.AND.KOBJ(I).LE.JE) IOTY(I) = IT
   35 CONTINUE
      NDONE = JE
      IF (NDONE.GE.NDAT)    GO TO 999
*
      JFOCUR = JFOCUR + 2
      IF (JFOCUR.LT.JFOEND) GO TO 10
      JFOCUR = JFOREP
      GO TO 10
*                                                             END DBIOTY
  999 END
+DECK, DBPLBK.
      SUBROUTINE DBPLBK (LAD)
*     =======================
*
************************************************************************
*                                                                      *
*        SUBR. DBPLBK (LAD)                                            *
*                                                                      *
*   Draw the nodes on the screen as given in the bank addressed by LAD *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LAD      Address of the bank containing the information          *
*                                                                      *
*   Called by DBACPL                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
      CHARACTER       CHVAR*16
      DIMENSION       X(5), Y(5), LAD(9)
      PARAMETER       (XRNG=24.0, YRNG=24.0, HIGH=0.5, SMARG=1.0)
      PARAMETER       (CSIZ=0.6, HSIZ=1.5, GAP=3.5, FRAM=1.2)
*
*     ------------------------------------------------------------------
*
* *** Derive the number of tree structure levels
*
      LREFDB(1) = LAD(1)
      NLEV = IQ(KOFUDB+LREFDB(1)+MNLVDB)
      IF (NLEV.LE.0)            GO TO 999
*
* *** Set the default values first
*
      SIZH = HSIZ
      SIZC = CSIZ
      GAPH = GAP
      GAPV = HIGH
      SGAP = SMARG
*
* *** Find the X- and Y- ranges in each level
*
      IPNL  = IQ(KOFUDB+LREFDB(1)+MPNLDB)
      YSIZM = FRAM*25+GAPV*24+SGAP*2+SIZH
      XSIZE = 0.
      NTEMP = 0
      KMAX  = 1
      DO 15 ILEV  =1, NLEV
        NODES = IQ(KOFUDB+LREFDB(1)+IPNL+MNODDB)
        IPNN  = IQ(KOFUDB+LREFDB(1)+IPNL+MPNNDB)
        MXNCH = 0
        DO 10 INOD =1, NODES
          NCHRN = IQ(KOFUDB+LREFDB(1)+IPNN+MNCHDB)
          IF (NCHRN.GT.MXNCH) MXNCH = NCHRN
          IPNN  = IQ(KOFUDB+LREFDB(1)+IPNN+MPNLDB)
   10   CONTINUE
        XSIZE = XSIZE + SIZC*MXNCH
        Q(KOFUDB+LREFDB(1)+IPNL+MYFLDB) = NODES*FRAM + (NODES-1)*GAPV
     +                                  + SGAP*2
        IF (NTEMP.LT.NODES) THEN
          NTEMP = NODES
          KMAX  = ILEV
        ENDIF
        IPNL  = IQ(KOFUDB+LREFDB(1)+IPNL+MPNLDB)
   15 CONTINUE
      XSIZE = XSIZE+(NLEV-1)*GAPH+SGAP*2
      NTEMP = NTEMP + 6
      YSIZE = FRAM*NTEMP + GAPV*(NTEMP-1) + SGAP*2 + SIZH
      IF (YSIZE.LT.YSIZM) YSIZE = YSIZM
*
* *** Now choose the scaling factor
*
      SCAL  = XRNG/XSIZE
      SCL0  = YRNG/YSIZE
      IF (SCAL.GT.SCL0) THEN
        SCAL = SCL0
        XOFF = 0.5*(XRNG-SCAL*XSIZE)
      ELSE
        XOFF = 0.
      ENDIF
      SIZH  = SCAL*SIZH
      SIZC  = SCAL*SIZC
      SGAP  = SCAL*SGAP
      GAPH  = SCAL*GAPH
      GAPV  = SCAL*GAPV
      HFRAM = SCAL*FRAM
      XVAL  = XOFF+SGAP
      Q(KOFUDB+LREFDB(1)+MHFMDB) = HFRAM
      IPNL  = IQ(KOFUDB+LREFDB(1)+MPNLDB)
      DO 25 ILEV =1, NLEV
        NODES = IQ(KOFUDB+LREFDB(1)+IPNL+MNODDB)
        IPNN  = IQ(KOFUDB+LREFDB(1)+IPNL+MPNNDB)
        MXNCH = 0
        DO 20 INOD =1, NODES
          NCHRN = IQ(KOFUDB+LREFDB(1)+IPNN+MNCHDB)
          IF (NCHRN.GT.MXNCH) MXNCH = NCHRN
          IPNN  = IQ(KOFUDB+LREFDB(1)+IPNN+MPNLDB)
   20   CONTINUE
        YSIZV = Q(KOFUDB+LREFDB(1)+IPNL+MYFLDB)
        Q(KOFUDB+LREFDB(1)+IPNL+MXOFDB) = XVAL
        Q(KOFUDB+LREFDB(1)+IPNL+MYFLDB) = YRNG - 2*SGAP
     +                                  - 0.5*(YRNG-SCAL*YSIZV)
        Q(KOFUDB+LREFDB(1)+IPNL+MXWDDB) = SIZC*MXNCH
        XVAL  = XVAL + Q(KOFUDB+LREFDB(1)+IPNL+MXWDDB) + GAPH
        IPNL  = IQ(KOFUDB+LREFDB(1)+IPNL+MPNLDB)
   25 CONTINUE
*
* *** Now set the range; choose colour, line style, line width
*
      CALL IGRNG (XRNG, YRNG)
      CALL ISPLCI (7)
      CALL ISLN (1)
      CALL ISLWSC (2.0)
*
* *** Now draw the box and title
*
      CALL IGBOX (0., XRNG, 0.,YRNG)
      CALL IGTEXT (0.5*XRNG, SGAP, 'DBL3 Tree Structure', SIZH, 0., 'C')
*
* *** Now arrange the node places into the tree
*
      YOFF1 = 0.
*
*  ** Start with the level with maximum number of nodes
*
      LPNL  = IQ(KOFUDB+LREFDB(1)+MPNLDB)
      IF (KMAX.GT.1) THEN
        DO 30 I = 2, KMAX
   30   LPNL  = IQ(KOFUDB+LREFDB(1)+LPNL+MPNLDB)
      ENDIF
      YOFFN =  Q(KOFUDB+LREFDB(1)+LPNL+MYFLDB)
      IPNN  = IQ(KOFUDB+LREFDB(1)+LPNL+MPNNDB)
      NODES = IQ(KOFUDB+LREFDB(1)+LPNL+MNODDB)
      DO 35 INOD = 1, NODES
        NDOWN = IQ(KOFUDB+LREFDB(1)+IPNN+MNDWDB)
        IF (NDOWN.GT.0) THEN
          IF (YOFF1.GT.0) THEN
            IF (YOFFN.GT.YOFF1) YOFFN = YOFF1
          ENDIF
          Q(KOFUDB+LREFDB(1)+IPNN+MYFNDB) = YOFFN
          HH    = 0.5 * (NDOWN*HFRAM + (NDOWN-1)*GAPV)
          YOFF1 = YOFFN - HH - GAPV - HFRAM*0.5
          YOFFN = YOFFN - HFRAM - GAPV
        ELSE
          Q(KOFUDB+LREFDB(1)+IPNN+MYFNDB) = YOFFN
          YOFFN = YOFFN - HFRAM - GAPV
        ENDIF
        IPNN  = IQ(KOFUDB+LREFDB(1)+IPNN+MPNLDB)
   35 CONTINUE
*
*  ** Go up with level number from one with maximum nodes
*
      YOFFP = 0.
      KPNL  = LPNL
      DO 55 ILEV = KMAX+1,  NLEV
        IPNL  = IQ(KOFUDB+LREFDB(1)+KPNL+MPNLDB)
        IPNNU = IQ(KOFUDB+LREFDB(1)+KPNL+MPNNDB)
        KDOWN = 1
        NODES = IQ(KOFUDB+LREFDB(1)+KPNL+MNODDB)
        NODEH = IQ(KOFUDB+LREFDB(1)+IPNL+MNODDB)
        DO 45 IUP = 1, NODES
          NDOWN = IQ(KOFUDB+LREFDB(1)+IPNNU+MNDWDB)
          IF (NDOWN.GT.0) THEN
            HH    = 0.5 * (NDOWN*HFRAM + (NDOWN-1)*GAPV)
            YOFFN = HH + Q(KOFUDB+LREFDB(1)+IPNNU+MYFNDB) - HFRAM*0.5
            IF (KDOWN.GT.1) THEN
              IF (YOFFN.GT.YOFFP) YOFFN = YOFFP
            ENDIF
            IPNN  = IQ(KOFUDB+LREFDB(1)+IPNL+MPNNDB)
            DO 40 INOD = 1, NODEH
              IF (IQ(KOFUDB+LREFDB(1)+IPNN+MNFNDB).EQ.IUP) THEN
                Q(KOFUDB+LREFDB(1)+IPNN+MYFNDB) = YOFFN
                YOFFN = YOFFN - HFRAM - GAPV
                KDOWN = KDOWN + 1
              ENDIF
              IPNN  = IQ(KOFUDB+LREFDB(1)+IPNN+MPNLDB)
   40       CONTINUE
            IF (KDOWN.GT.NODEH) GO TO 50
            YOFFP = YOFFN
          ENDIF
          IPNNU = IQ(KOFUDB+LREFDB(1)+IPNNU+MPNLDB)
   45   CONTINUE
   50   KPNL  = IPNL
   55 CONTINUE
*
*  ** Now go down with level number from one with maximum nodes
*
      KPNL  = LPNL
      DO 75 ILEV = 1, KMAX-1
        IPNL  = IQ(KOFUDB+LREFDB(1)+KPNL+MPPLDB)
        IPNNU = IQ(KOFUDB+LREFDB(1)+IPNL+MPNNDB)
        YOFFP = 0.
        NODES = IQ(KOFUDB+LREFDB(1)+IPNL+MNODDB)
        NODEH = IQ(KOFUDB+LREFDB(1)+KPNL+MNODDB)
        KCOUN = 0
        LCOUN = 0
        DO 65 IUP = 1, NODES
          NDOWN = IQ(KOFUDB+LREFDB(1)+IPNNU+MNDWDB)
          IF (NDOWN.GT.0) THEN
            ICOUN = 0
            IPNN  = IQ(KOFUDB+LREFDB(1)+KPNL+MPNNDB)
            DO 60 INOD = 1, NODEH
              IF (IQ(KOFUDB+LREFDB(1)+IPNN+MNFNDB).EQ.IUP) THEN
                ICOUN = ICOUN + 1
                IF (ICOUN.EQ.1) YSTRT = Q(KOFUDB+LREFDB(1)+IPNN+MYFNDB)
                YSTOP = Q(KOFUDB+LREFDB(1)+IPNN+MYFNDB)
              ENDIF
              IPNN  = IQ(KOFUDB+LREFDB(1)+IPNN+MPNLDB)
   60       CONTINUE
            YOFFN = (YSTRT+YSTOP)*0.5
            Q(KOFUDB+LREFDB(1)+IPNNU+MYFNDB) = YOFFN
            KCOUN = KCOUN + 1
            IF (KCOUN.EQ.1) YOFFP = YOFFN
          ELSE
            IF (KCOUN.GT.0) THEN
              YOFFN = YOFFN - GAPV - HFRAM
              Q(KOFUDB+LREFDB(1)+IPNNU+MYFNDB) = YOFFN
            ELSE
              LCOUN = LCOUN + 1
            ENDIF
          ENDIF
          IPNNU = IQ(KOFUDB+LREFDB(1)+IPNNU+MPNLDB)
   65   CONTINUE
        YOFFN = YOFFP
        IPNNU = IQ(KOFUDB+LREFDB(1)+IPNL+MPNNDB)
        DO 70 I = 1, LCOUN
          Q(KOFUDB+LREFDB(1)+IPNNU+MYFNDB) = YOFFP
     +                                     + (LCOUN-I+1)*(HFRAM+GAPV)
          IPNNU = IQ(KOFUDB+LREFDB(1)+IPNNU+MPNLDB)
   70   CONTINUE
        KPNL  = IPNL
   75 CONTINUE
*
* *** Now draw the tree structure for DBL3
*
      IPNL = IQ(KOFUDB+LREFDB(1)+MPNLDB)
      DO 95 ILEV = 1, NLEV
        IPNN  = IQ(KOFUDB+LREFDB(1)+IPNL+MPNNDB)
        NODES = IQ(KOFUDB+LREFDB(1)+IPNL+MNODDB)
        XOFF  =  Q(KOFUDB+LREFDB(1)+IPNL+MXOFDB)
        XWID  =  Q(KOFUDB+LREFDB(1)+IPNL+MXWDDB)
        IF (ILEV.LT.NLEV) THEN
          LPNL  = IQ(KOFUDB+LREFDB(1)+IPNL+MPNLDB)
          XOFFL =  Q(KOFUDB+LREFDB(1)+LPNL+MXOFDB)
          NODEH = IQ(KOFUDB+LREFDB(1)+LPNL+MNODDB)
        ENDIF
        DO 90 INOD = 1, NODES
          NCH   = IQ(KOFUDB+LREFDB(1)+IPNN+MNCHDB)
          NDOWN = IQ(KOFUDB+LREFDB(1)+IPNN+MNDWDB)
          YOFF  =  Q(KOFUDB+LREFDB(1)+IPNN+MYFNDB)
          X(1)  = XOFF
          X(2)  = X(1) + XWID
          X(3)  = X(2)
          X(4)  = X(1)
          X(5)  = X(1)
          XCEN  = 0.5 * (X(1) + X(2))
          Y(1)  = YOFF
          Y(2)  = Y(1)
          Y(3)  = Y(1) + HFRAM
          Y(4)  = Y(3)
          Y(5)  = Y(1)
          YCEN  = Y(1) + 0.5*(HFRAM-SIZC)
          CALL IPL (5,X,Y)
          CALL UHTOC (IQ(KOFUDB+LREFDB(1)+IPNN+MNAMDB), 4, CHVAR, NCH)
          CALL IGTEXT (XCEN, YCEN, CHVAR(1:NCH), SIZC, 0., 'C')
          IF (ILEV.LT.NLEV.AND.NDOWN.GT.0) THEN
            IPNND = IQ(KOFUDB+LREFDB(1)+LPNL+MPNNDB)
            YUP   =  Q(KOFUDB+LREFDB(1)+IPNN+MYFNDB) + HFRAM*0.5
            XUP   = XOFF + XWID
            YDOW1 = -1
            XDOWN = XOFFL
            XLINE = XDOWN - GAPH/6.
            DO 80 IDOWN = 1, NODEH
              ITEMP   =IQ(KOFUDB+LREFDB(1)+IPNND+MNFNDB)
              IF (INOD.EQ.ITEMP) THEN
                YDOW2 = Q(KOFUDB+LREFDB(1)+IPNND+MYFNDB) + HFRAM*0.5
                IF (YDOW1.LT.0.) THEN
                  YDOW1 = YDOW2
                  YFRST = YDOW1
                  Y(1)  = YDOW1
                  Y(2)  = Y(1)
                  X(1)  = XDOWN
                  X(2)  = XLINE
                  CALL IPL (2, X, Y)
                ELSE
                  Y(1)  = YDOW1
                  Y(2)  = YDOW2
                  Y(3)  = Y(2)
                  X(1)  = XLINE
                  X(2)  = X(1)
                  X(3)  = XDOWN
                  CALL IPL (3, X, Y)
                  YDOW1 = YDOW2
                ENDIF
              ENDIF
              IPNND = IQ(KOFUDB+LREFDB(1)+IPNND+MPNLDB)
   80       CONTINUE
            YEND  = YDOW1
   85       IF (YDOW1.GE.0) THEN
              Y(1)  = YUP
              Y(2)  = (YFRST+YEND)*0.5
              X(1)  = XUP
              X(2)  = XLINE
              CALL IPL (2, X, Y)
            ENDIF
          ENDIF
          IPNN  = IQ(KOFUDB+LREFDB(1)+IPNN+MPNLDB)
   90   CONTINUE
        IPNL  = IQ(KOFUDB+LREFDB(1)+IPNL+MPNLDB)
   95 CONTINUE
*                                                             END DBPLBK
  999 END
+DECK, DBPLNT.
      SUBROUTINE DBPLNT (NTUP, PATHS, NPATH, NOBJS, KOBJS, NKEYX,
     +                   KEYXS, KEYS, CHOPT)
*     ===========================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBPLNT (NTUP, PATHS, NPATH, NOBJS, KOBJS, NKEYX,        *
*                      KEYXS, KEYS, CHOPT)                             *
*                                                                      *
*   Fills an N-tuple with data and key elements from multiple          *
*   directories as requested by the user                               *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     NTUP     Integer identifier of the ntuple                        *
*     PATHS    Character array describing the path names               *
*     NPATH    Number of paths given in PATHS                          *
*     NOBJS    Array giving the number of data elements to be stored   *
*              for PATHS(i)                                            *
*     KOBJS    Vector specifying the element indices to be stored for  *
*              PATHS(i)                                                *
*     NKEYX    Array giving the number of key elements to be stored    *
*              with data for PATHS(i)                                  *
*     KEYXS    Array giving key element indices to be stored with the  *
*              data. For a given path, data elements follow the key    *
*              elements                                                *
*     KEYS     Vector of keys. Only the elements declared in CHOPT are *
*              considered to contain useful information. The vector as *
*              well as CHOPT refers to the PATHS(1). Selections for    *
*              all subsequent paths is done on the basis of start      *
*              validity period from path 1 and a correlation table     *
*              between the user keys.                                  *
*     CHOPT    Character string with any of the following characters   *
*          T   Transforms the Keys 3,4,7 to seconds/minutes passed     *
*              since midnight January 1, 1980                          *
*          3   selects objects with start validity time > KEYS(3)      *
*          4   selects objects with start validity time < KEYS(4)      *
*          5   specific Program version number required                *
*          7   selects objects with insertion      time < KEYS(7)      *
*          n   consider user key n (where 7 < n < 30)                  *
*                                                                      *
*   Called by user,   DBAUXI                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =161 : Illegal path name                               *
*               =162 : No keys or data in the directory                *
*               =163 : Illegal number of objects                       *
*               =164 : Illegal number of path names                    *
*               =165 : Illegal object element indices                  *
*               =166 : Illegal key element indices                     *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DPLOTS.
      CHARACTER       PATH*80, PATHX*16, PATHY*80, PATHN*80, CTAG(25)*16
      CHARACTER*(*)   PATHS(*), CHOPT
      DIMENSION       KEYS(9), KEYXS(9), KOBJS(9), NKEYX(9), NOBJS(9)
      DOUBLE PRECISION DVAL
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Prepare object and key vector specifiers for different paths
*
      IF (NPATH.LT.1.OR.NPATH.GT.NPMXDP) THEN
        IQUEST(1) = 164
        IQUEST(11)= NPATH
        IQUEST(12)= NPMXDP
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT : Illegal'//
     +  ' number of path names '',2I10)', IQUEST(11), 2)
+SELF.
        GO TO 999
      ENDIF
*
      NDSMDP(1) = 0
      NKSMDP(1) = 0
      NKSTDP(1)  = 0
      DO 10 J = 1, NPATH
        IF (NKEYX(J).LT.0.OR.NOBJS(J).LT.0.OR.NKEYX(J)+NOBJS(J).LE.0)
     +                                                              THEN
          IQUEST(1) = 163
          IQUEST(11)= MIN0 (NKEYX(J), NOBJS(J))
          IQUEST(12)= NOBMDP
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) THEN
            PATH   = PATHS(J)
            CALL DBPRNT (LPRTDB, '(/,'' DBPLNT : Illegal number of ob'//
     +           'jects '',2I9,'' for '//PATH(1:40)//''')',IQUEST(11),2)
          ENDIF
+SELF.
          GO TO 999
        ENDIF
        IF (J.GT.1) THEN
          NDSMDP(J) = NDSMDP(J-1) + NOBJS(J-1)
          NKSMDP(J) = NKSMDP(J-1) + NKEYX(J-1)
          NKSTDP(J)  = NDSTDP(J-1)  + NOBJS(J-1)
        ENDIF
        NDSTDP(J)  = NKSTDP(J)    + NKEYX(J)
        IBEGDP(J)  = 0
        NDEMDP(J)  = 0
        DO 5 I = 1, NOBJS(J)
          IOBJ   = KOBJS(NDSMDP(J)+I)
          IF (IOBJ.LT.1) THEN
            IQUEST(1) = 165
            IQUEST(11)= IOBJ
            IQUEST(12)= I
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) THEN
              PATH   = PATHS(J)
              CALL DBPRNT (LPRTDB, '(/,'' DBPLNT : Illegal data eleme'//
     +             'nt index '',2I9,'' for '//PATH(1:40)//''')',
     +             IQUEST(11), 2)
            ENDIF
+SELF.
            GO TO 999
          ENDIF
          IF (IOBJ.GT.NDEMDP(J)) NDEMDP(J) = IOBJ
    5   CONTINUE
   10 CONTINUE
      NTOT   = NDSTDP(NPATH) + NOBJS(NPATH)
      IF (NTOT.LE.0.OR.NTOT.GT.NOBMDP) THEN
        IQUEST(1) = 163
        IQUEST(11)= NTOT
        IQUEST(12)= NOBMDP
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT : Illegal'//
     +  ' number of objects '',2I9,'' for All Paths'')', IQUEST(11), 2)
+SELF.
        GO TO 999
      ENDIF
      CALL VZERO (IOTYDP, NTOT)
      NPLM  = NPLMDP
      CALL HCDIR (PATHN, 'R')
*
* *** Decode the character option
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)                                     GO TO 999
*
* *** Find the keys on the basis of which selection is to be made
*
      DO 35 NPT = 1, NPATH
*
*  **   Suppress blanks from the pathname and set current directory
*
        PATHY  = PATHS(NPT)
        CALL DBSBLC (PATHY, PATH, NCHAR)
        CALL RZCDIR (PATH, ' ')
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1) = 161
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT :'//
     +    ' Illegal pathname '//PATH//''')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
        NKEYDK = IQUEST(7)
        NWKYDK = IQUEST(8)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        CALL DBKYTG
*
        IF (NKEYDK.LE.0) THEN
          IQUEST(1) = 162
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT : No '//
     +    'keys in directory '//PATH//''')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
*
*  **   Load number of user keys to be tested for selection
*  **   for each path and their indices
*
        NSKYDP(NPT) = 0
        IF (NPT.EQ.1) THEN
          DO 15 I = NSYSDK + 1, NWKYDK
            IF (IOKYDA(I).NE.0) THEN
              NSKYDP(NPT) = NSKYDP(NPT) + 1
              NKEYDP(NSKYDP(NPT),NPT) = I
              KKEYDP(NSKYDP(NPT),NPT) = I
              CTAG(NSKYDP(NPT))     = CTAGDK(I)
            ENDIF
   15     CONTINUE
        ELSE IF (NSKYDP(1).GT.0) THEN
          DO 25 I = 1, NSKYDP(1)
            DO 20 J = NSYSDK+1, NWKYDK
              IF (CTAG(I).EQ.CTAGDK(J)) THEN
                NSKYDP(NPT) = NSKYDP(NPT) + 1
                NKEYDP(NSKYDP(NPT),NPT) = J
                KKEYDP(NSKYDP(NPT),NPT) = NKEYDP(I,1)
                GO TO 25
              ENDIF
   20       CONTINUE
   25     CONTINUE
        ENDIF
*
*  **   Load the IO type of the keys
*
        DO 30 I = 1, NKEYX(NPT)
          IK     = KEYXS(NKSMDP(NPT)+I)
          IF (IK.LT.1.OR.IK.GT.NWKYDK) THEN
            IQUEST(1) = 166
            IQUEST(11)= I
            IQUEST(12)= IK
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT : Ill'//
     +      'egal key  element index '',2I9,'' for '//PATH(1:40)//''')',
     +      IQUEST(11), 2)
+SELF.
            GO TO 999
          ENDIF
          IF (IOTYDK(IK).NE.6) THEN
            IOTYDP(NKSTDP(NPT)+I) = IOTYDK(IK)
          ELSE
            IOTYDP(NKSTDP(NPT)+I) = 5
          ENDIF
   30   CONTINUE
*
*  **   Find maximum number of objects from Path 1
*
        IF (NPT.EQ.1) THEN
          IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
          IF (IOPTP.EQ.0)THEN
            IF (NKEYDK.LT.NPLM) NPLM = NKEYDK
          ENDIF
        ENDIF
   35 CONTINUE
*
* *** Prepare temporary storage
*
      CALL DATIME (IDATX, ITIMX)
      CALL DBPKTS (IDATX, ITIMX*100, ITNOW)
      ND    = (NTOT + 1) * NPLM
      IF (LAUXDL(10).NE.0) CALL MZDROP (IDISDB, LAUXDL(10), 'L')
      CALL DBBOOK (IDISDB, LAUXDL(10), LAUXDL(10), 2, 'TEMP', 0, 0, ND,
     +             0, -1)
      IF (IQUEST(1).NE.0)                                     GO TO 999
      NCUR   = 0
      NCURD  = 0
      NBAD   = 0
      NOLD   = 0
      NOLDD  = 0
      JBIAS  = 2
*
* *** Load useful data in the temp bank from Path 1
*
   40 ITIME  = 1
      NPL    = 0
      PATHY  = PATHS(1)
      CALL DBSBLC (PATHY, PATH, NCHAR)
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 161
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT :'//
     +  ' Illegal pathname '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      CALL RZCDIR (PATH, 'R')
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKEYT
      NCHR   = INDEX (PATH, ' ') - 1
      IF (NCHR.LT.1) NCHR = MAXLDB
      NCHRT  = INDEX (PATH(3:NCHR), '/') - 1
      IF (NCHRT.LE.0) NCHRT = NCHR - 2
      PATHX  = PATH(3:NCHRT+2)
      LTOP   = LTOPDB
   42 IF (LTOP.NE.0) THEN
        NCHRT  = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHRT)
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 42
        ENDIF
        KY7MDB = IQ(KOFUDB+LTOP+MUPKY7)
      ELSE
        KY7MDB = 0
      ENDIF
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
      IF (LAUXDL(9).NE.0) THEN
        CALL MZDROP (IDISDB, LAUXDL(9), 'L')
        LAUXDL(9) = 0
      ENDIF
*
      IF (IOPTP.EQ.0) THEN
*
*  **   For non-parttioned directories
*
        DO 60 IK = NCUR+1, NKEYDK
          CALL DBKEYR (IK, NWKYDK, KEYVDK)
*
*  **     Store the time values for the subsequent loop runs
*
          IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB))
     +                                                        GO TO 60
          IF (KEYVDK(MBVRDB).GT.ITNOW)                        GO TO 60
          IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB))
     +                                                        GO TO 60
          IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))
     +                                                        GO TO 60
          IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))
     +                                                        GO TO 60
          IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)       GO TO 60
          IF (NSKYDP(1).GT.0) THEN
            DO 45 I = 1, NSKYDP(1)
              IIK    = NKEYDP(I,1)
              IF (KEYVDK(IIK).NE.KEYS(IIK))                   GO TO 60
   45       CONTINUE
          ENDIF
          IF (NOBJS(1).GT.0) THEN
            LAUXDL(9) = 0
            CALL VZERO (KEYVDK, NWKYDK)
            KEYVDK(MSERDB) = IK
            IOKYDA(MSERDB) = 1
            CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9), JBIAS,
     +                   NWKYDK, KEYVDK, IPREC)
            IOKYDA(MSERDB) = 0
            IF (IQUEST(1).NE.0) THEN
              IF (LAUXDL(9).NE.0) CALL MZDROP (IDISDB, LAUXDL(9), 'L')
              IQUEST(1) = 0
              GO TO 60
            ENDIF
            IF (NDEMDP(1).GT.IQ(KOFUDB+LAUXDL(9)-1)) THEN
              NBAD   = NBAD +1
              CALL MZDROP (IDISDB, LAUXDL(9), 'L')
              GO TO 60
            ENDIF
            IF (IBEGDP(1).EQ.0) THEN
              IBEGDP(1) = 1
              CALL DBIOTY (LAUXDL(9), NOBJS(1), KOBJS(NDSMDP(1)+1),
     +                     IOTYDP(NDSTDP(1)+1))
            ENDIF
          ENDIF
          NPL    = NPL + 1
          IF (NPL.GT.NPLM) THEN
            NPL    = NPLM
            NCUR   = IK - 1
            GO TO 100
          ENDIF
*
*  **     Load the requested keys and key(3)
*
          IPNT = KOFUDB + LAUXDL(10) + (NPL - 1) * (NTOT + 1)
          IQ(IPNT+1) = KEYVDK(MBVRDB)
          DO 50 I = 1, NKEYX(1)
            IND = KEYXS(NKSMDP(1)+I)
            IF (IOPTDA.EQ.0.OR.(IND.NE.MBVRDB.AND.IND.NE.MEVRDB.AND.
     +          IND.NE.MITMDB))                      THEN
              Q(IPNT+NKSTDP(1)+I+1) = KEYVDK(IND)
            ELSE IF (IND.EQ.MBVRDB.OR.IND.EQ.MEVRDB) THEN
              CALL DBUTIS (KEYVDK(IND), IVAL)
              Q(IPNT+NKSTDP(1)+I+1) = IVAL
            ELSE
              CALL DBUTIM (KEYVDK(IND), IVAL)
              Q(IPNT+NKSTDP(1)+I+1) = IVAL
            ENDIF
   50     CONTINUE
          DO 55 I = 1, NOBJS(1)
            ID     = NDSTDP(1) + I
            II     = KOBJS(NDSMDP(1)+I)
            IF (IOTYDP(ID).EQ.1.OR.IOTYDP(ID).EQ.2.OR.IOTYDP(ID).EQ.5)
     +                                THEN
              IVAL   = IQ(KOFUDB+LAUXDL(9)+II)
              Q(IPNT+ID+1) = IVAL
            ELSE IF (IOTYDP(ID).EQ.4) THEN
              CALL UCOPY (Q(KOFUDB+LAUXDL(9)+II), DVAL, 2)
              Q(IPNT+ID+1) = DVAL
            ELSE
              Q(IPNT+ID+1) = Q(KOFUDB+LAUXDL(9)+II)
            ENDIF
   55     CONTINUE
          CALL MZDROP (IDISDB, LAUXDL(9), 'L')
   60   CONTINUE
*
      ELSE
*
*   **  Partitioned directory
*
        KST    = NWKYDK + 1
        NKEYS  = NKEYDK
        NCUS   = NCUR
        DO 90 IKK = NCURD+1, NKEYS
          KPNT = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                   NKEYS*KST, KST)
          IF (KPNT.GT.0) THEN
            KPNT  = KOFSDB + LCDRDB + IKDRDB +KPNT - MPSRDB
          ELSE
            KPNT  = KOFSDB + LCDRDB + IKDRDB + (IKK - 1) * KST
          ENDIF
          IF (IOKYDA(MBVRDB).NE.0.AND.IQ(KPNT+MEVRDB).LT.KEYS(MBVRDB))
     +                                                        GO TO 90
          IF (IQ(KPNT+MBVRDB).GT.ITNOW)                       GO TO 90
          IF (IOKYDA(MEVRDB).NE.0.AND.IQ(KPNT+MBVRDB).GT.KEYS(MEVRDB))
     +                                                        GO TO 90
          IF (IOKYDA(MITMDB).NE.0.AND.IQ(KPNT+MITMDB).GT.KEYS(MITMDB))
     +                                                        GO TO 90
          IF (KY7MDB.GT.0.AND.IQ(KPNT+MITMDB).GT.KY7MDB)      GO TO 90
*
          CALL DBPATH (PATHX, IKK)
          PATHY  = PATH(1:NCHR)//'/'//PATHX
          CALL RZCDIR (PATHY, ' ')
          IF (IQUEST(1).NE.0) THEN
            CALL MZDROP (IDISDB, LAUXDL(10), 'L')
            IQUEST(1) = 161
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT :'//
     +      ' Illegal pathname '//PATHY//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
*
          DO 80 IK = NCUS+1, NKEYDK
            CALL DBKEYR (IK, NWKYDK, KEYVDK)
*
*  **       Store the time values for the subsequent loop runs
*
            IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB))
     +                                                        GO TO 80
            IF (KEYVDK(MBVRDB).GT.ITNOW)                      GO TO 80
            IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB))
     +                                                        GO TO 80
            IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))
     +                                                        GO TO 80
            IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))
     +                                                        GO TO 80
            IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)     GO TO 80
            IF (NSKYDP(1).GT.0) THEN
              DO 65 I = 1, NSKYDP(1)
                IIK    = NKEYDP(I,1)
                IF (KEYVDK(IIK).NE.KEYS(IIK))                 GO TO 80
   65         CONTINUE
            ENDIF
            IF (NOBJS(1).GT.0) THEN
              LAUXDL(9) = 0
              CALL VZERO (KEYVDK, NWKYDK)
              KEYVDK(MSERDB) = IK
              IOKYDA(MSERDB) = 1
              CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9), JBIAS,
     +                     NWKYDK, KEYVDK, IPREC)
              IOKYDA(MSERDB) = 0
              IF (IQUEST(1).NE.0) THEN
                IF (LAUXDL(9).NE.0) CALL MZDROP (IDISDB, LAUXDL(9), 'L')
                IQUEST(1) = 0
                GO TO 80
              ENDIF
              IF (NDEMDP(1).GT.IQ(KOFUDB+LAUXDL(9)-1)) THEN
                NBAD   = NBAD +1
                CALL MZDROP (IDISDB, LAUXDL(9), 'L')
                GO TO 80
              ENDIF
              IF (IBEGDP(1).EQ.0) THEN
                IBEGDP(1) = 1
                CALL DBIOTY (LAUXDL(9), NOBJS(1), KOBJS(NDSMDP(1)+1),
     +                       IOTYDP(NDSTDP(1)+1))
              ENDIF
            ENDIF
            NPL    = NPL + 1
            IF (NPL.GT.NPLM) THEN
              NPL    = NPLM
              NCUR   = IK - 1
              NCURD  = IKK - 1
              GO TO 100
            ENDIF
*
*  **       Load the requested keys and key(3)
*
            IPNT = KOFUDB + LAUXDL(10) + (NPL - 1) * (NTOT + 1)
            IQ(IPNT+1) = KEYVDK(MBVRDB)
            DO 70 I = 1, NKEYX(1)
              IND = KEYXS(NKSMDP(1)+I)
              IF (IOPTDA.EQ.0.OR.(IND.NE.MBVRDB.AND.IND.NE.MEVRDB.AND.
     +            IND.NE.MITMDB))                                 THEN
                Q(IPNT+NKSTDP(1)+I+1) = KEYVDK(IND)
              ELSE IF (IND.EQ.MBVRDB.OR.IND.EQ.MEVRDB) THEN
                CALL DBUTIS (KEYVDK(IND), IVAL)
                Q(IPNT+NKSTDP(1)+I+1) = IVAL
              ELSE
                CALL DBUTIM (KEYVDK(IND), IVAL)
                Q(IPNT+NKSTDP(1)+I+1) = IVAL
              ENDIF
   70       CONTINUE
            DO 75 I = 1, NOBJS(1)
              ID     = NDSTDP(1) + I
              II     = KOBJS(NDSMDP(1)+I)
              IF (IOTYDP(ID).EQ.1.OR.IOTYDP(ID).EQ.2.OR.IOTYDP(ID).EQ.5)
     +                                  THEN
                IVAL   = IQ(KOFUDB+LAUXDL(9)+II)
                Q(IPNT+ID+1) = IVAL
              ELSE IF (IOTYDP(ID).EQ.4) THEN
                CALL UCOPY (Q(KOFUDB+LAUXDL(9)+II), DVAL, 2)
                Q(IPNT+ID+1) = DVAL
              ELSE
                Q(IPNT+ID+1) = Q(KOFUDB+LAUXDL(9)+II)
              ENDIF
   75       CONTINUE
            CALL MZDROP (IDISDB, LAUXDL(9), 'L')
   80     CONTINUE
*
          NCUS   = 0
          CALL RZCDIR (PATH, ' ' )
          IF (IQUEST(1).NE.0) THEN
            CALL MZDROP (IDISDB, LAUXDL(10), 'L')
            IQUEST(1) = 161
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT :'//
     +      ' Illegal pathname '//PATH//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
   90   CONTINUE
      ENDIF
*
* ** Check if objects collected
*
  100 IF (NPL.EQ.0) THEN
        CALL MZDROP (IDISDB, LAUXDL(10), 'L')
        IQUEST(1) = 0
        GO TO 999
      ENDIF
*
* *** Loop over the secondary directories and fill the rest
*
      DO 180 NPT = 2, NPATH
        PATHY  = PATHS(NPT)
        CALL DBSBLC (PATHY, PATH, NCHAR)
        CALL RZCDIR (PATH, ' ')
        IF (IQUEST(1).NE.0) THEN
          IQUEST(1) = 161
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT :'//
     +    ' Illegal pathname '//PATH//''')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
        CALL RZCDIR (PATH, 'R')
        NKEYDK = IQUEST(7)
        NWKYDK = IQUEST(8)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
        CALL DBKEYT
        NCHR   = INDEX (PATH, ' ') - 1
        IF (NCHR.LT.1) NCHR = MAXLDB
        NCHRT  = INDEX (PATH(3:NCHR), '/') - 1
        IF (NCHRT.LE.0) NCHRT = NCHR - 2
        PATHX  = PATH(3:NCHRT+2)
        LTOP   = LTOPDB
  102   IF (LTOP.NE.0) THEN
          NCHRT  = IQ(KOFUDB+LTOP+MUPNCH)
          CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHRT)
          IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN
            LTOP   = LQ(KOFUDB+LTOP)
            GO TO 102
          ENDIF
          KY7MDB = IQ(KOFUDB+LTOP+MUPKY7)
        ELSE
          KY7MDB = 0
        ENDIF
        IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
*
        DO 170 IO = 1, NPL
          IPNT   = KOFUDB + LAUXDL(10) + (IO - 1) * (NTOT + 1)
          ITIME  = IQ(IPNT+1)
          IF (ITIME.LE.0)                                     GO TO 170
          IF (IOPTP.EQ.0) THEN
*
*  **       For non-parttioned directories
*
            DO 120 JK = 1, NKEYDK
              IK     = NKEYDK + 1 - JK
              CALL DBKEYR (IK, NWKYDK, KEYVDK)
*
*  **         Select on the basis of start validity from Path 1
*
              IF (ITIME.LT.KEYVDK(MBVRDB).OR.ITIME.GT.KEYVDK(MEVRDB))
     +                                                        GO TO 120
              IF (IOKYDA(MPVSDB).NE.0.AND.
     +            KEYVDK(MPVSDB).NE.KEYS(MPVSDB))             GO TO 120
              IF (IOKYDA(MITMDB).NE.0.AND.
     +            KEYVDK(MITMDB).GT.KEYS(MITMDB))             GO TO 120
              IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)   GO TO 120
              IF (NSKYDP(NPT).GT.0) THEN
                DO 105 I = 1, NSKYDP(NPT)
                  IIK    = NKEYDP(I,NPT)
                  IJK    = KKEYDP(I,NPT)
                  IF (KEYVDK(IIK).NE.KEYS(IJK))               GO TO 120
  105           CONTINUE
              ENDIF
              IF (NOBJS(NPT).GT.0) THEN
                LAUXDL(9) = 0
                CALL VZERO (KEYVDK, NWKYDK)
                KEYVDK(MSERDB) = IK
                IOKYDA(MSERDB) = 1
                CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9), JBIAS,
     +                       NWKYDK, KEYVDK, IPREC)
                IOKYDA(MSERDB) = 0
                IF (IQUEST(1).NE.0) THEN
                  NBAD   = NBAD + 1
                  IF (LAUXDL(9).NE.0)
     +              CALL MZDROP (IDISDB, LAUXDL(9), 'L')
                  IQUEST(1) = 0
                  IPNT   = KOFUDB + LAUXDL(10) + (IO - 1) * (NTOT + 1)
                  IQ(IPNT+1) = -1
                  GO TO 170
                ENDIF
                IF (NDEMDP(NPT).GT.IQ(KOFUDB+LAUXDL(9)-1)) THEN
                  NBAD   = NBAD +1
                  CALL MZDROP (IDISDB, LAUXDL(9), 'L')
                  IPNT   = KOFUDB + LAUXDL(10) + (IO - 1) * (NTOT + 1)
                  IQ(IPNT+1) = -1
                  GO TO 170
                ENDIF
                IF (IBEGDP(NPT).EQ.0) THEN
                  IBEGDP(NPT) = 1
                  CALL DBIOTY (LAUXDL(9), NOBJS(NPT),
     +            KOBJS(NDSMDP(NPT)+1), IOTYDP(NDSTDP(NPT)+1))
                ENDIF
              ENDIF
*
*  **         Load the requested keys and data elements
*
              IPNT = KOFUDB + LAUXDL(10) + (IO - 1) * (NTOT + 1)
              DO 110 I = 1, NKEYX(NPT)
                IND = KEYXS(NKSMDP(NPT)+I)
                IF (IOPTDA.EQ.0.OR.(IND.NE.MBVRDB.AND.IND.NE.MEVRDB.AND.
     +              IND.NE.MITMDB))                                 THEN
                  Q(IPNT+NKSTDP(NPT)+I+1) = KEYVDK(IND)
                ELSE IF (IND.EQ.MBVRDB.OR.IND.EQ.MEVRDB) THEN
                  CALL DBUTIS (KEYVDK(IND), IVAL)
                  Q(IPNT+NKSTDP(NPT)+I+1) = IVAL
                ELSE
                  CALL DBUTIM (KEYVDK(IND), IVAL)
                  Q(IPNT+NKSTDP(NPT)+I+1) = IVAL
                ENDIF
  110         CONTINUE
              DO 115 I = 1, NOBJS(NPT)
                ID     = NDSTDP(NPT) + I
                II     = KOBJS(NDSMDP(NPT)+I)
                IF (IOTYDP(ID).EQ.1.OR.IOTYDP(ID).EQ.2.OR.
     +              IOTYDP(ID).EQ.5)      THEN
                  IVAL   = IQ(KOFUDB+LAUXDL(9)+II)
                  Q(IPNT+ID+1) = IVAL
                ELSE IF (IOTYDP(ID).EQ.4) THEN
                  CALL UCOPY (Q(KOFUDB+LAUXDL(9)+II), DVAL, 2)
                  Q(IPNT+ID+1) = DVAL
                ELSE
                  Q(IPNT+ID+1) = Q(KOFUDB+LAUXDL(9)+II)
                ENDIF
  115         CONTINUE
              IF (LAUXDL(9).NE.0) CALL MZDROP (IDISDB, LAUXDL(9), 'L')
              GO TO 170
  120       CONTINUE
            IPNT   = KOFUDB + LAUXDL(10) + (IO - 1) * (NTOT + 1)
            IQ(IPNT+1) = -1
            GO TO 170
*
          ELSE
*
*   **      Partitioned directory
*
            KST    = NWKYDK + 1
            NKEYS  = NKEYDK
            DO 150 JKK = 1, NKEYS
              IKK  = NKEYS + 1 - JKK
              KPNT = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                       NKEYS*KST, KST)
              IF (KPNT.GT.0) THEN
                KPNT  = KOFSDB + LCDRDB + IKDRDB +KPNT - MPSRDB
              ELSE
                KPNT  = KOFSDB + LCDRDB + IKDRDB + (IKK - 1) * KST
              ENDIF
              IF (ITIME.LT.IQ(KPNT+MBVRDB).OR.ITIME.GT.IQ(KPNT+MEVRDB))
     +                                                        GO TO 150
              IF (IOKYDA(MITMDB).NE.0.AND.
     +            IQ(KPNT+MITMDB).GT.KEYS(MITMDB))            GO TO 150
              IF (KY7MDB.GT.0.AND.IQ(KPNT+MITMDB).GT.KY7MDB)  GO TO 150
*
              CALL DBPATH (PATHX, IKK)
              PATHY  = PATH(1:NCHR)//'/'//PATHX
              CALL RZCDIR (PATHY, ' ')
              IF (IQUEST(1).NE.0) THEN
                CALL MZDROP (IDISDB, LAUXDL(10), 'L')
                IQUEST(1) = 161
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT :'//
     +          ' Illegal pathname '//PATHY//''')', IARGDB, 0)
+SELF.
                GO TO 999
              ENDIF
              NKEYDK = IQUEST(7)
              LCDRDB = IQUEST(11)
              IKDRDB = IQUEST(13)
*
              DO 140 JK = 1, NKEYDK
                IK     = NKEYDK + 1 -JK
                CALL DBKEYR (IK, NWKYDK, KEYVDK)
*
*  **           Select on the basis of start validity from Path 1
*
                IF (ITIME.LT.KEYVDK(MBVRDB).OR.ITIME.GT.KEYVDK(MEVRDB))
     +                                                        GO TO 140
                IF (IOKYDA(MPVSDB).NE.0.AND.
     +              KEYVDK(MPVSDB).NE.KEYS(MPVSDB))           GO TO 140
                IF (IOKYDA(MITMDB).NE.0.AND.
     +              KEYVDK(MITMDB).GT.KEYS(MITMDB))           GO TO 140
                IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB) GO TO 140
                IF (NSKYDP(NPT).GT.0) THEN
                  DO 125 I = 1, NSKYDP(NPT)
                    IIK    = NKEYDP(I,NPT)
                    IJK    = KKEYDP(I,NPT)
                    IF (KEYVDK(IIK).NE.KEYS(IJK))             GO TO 140
  125             CONTINUE
                ENDIF
                IF (NOBJS(NPT).GT.0) THEN
                  LAUXDL(9) = 0
                  CALL VZERO (KEYVDK, NWKYDK)
                  KEYVDK(MSERDB) = IK
                  IOKYDA(MSERDB) = 1
                  CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9),
     +                         JBIAS, NWKYDK, KEYVDK, IPREC)
                  IOKYDA(MSERDB) = 0
                  IF (IQUEST(1).NE.0) THEN
                    NBAD   = NBAD + 1
                    IF (LAUXDL(9).NE.0)
     +                CALL MZDROP (IDISDB, LAUXDL(9), 'L')
                    IQUEST(1) = 0
                    IPNT   = KOFUDB + LAUXDL(10) + (IO - 1) * (NTOT + 1)
                    IQ(IPNT+1) = -1
                    GO TO 160
                  ENDIF
                  IF (NDEMDP(NPT).GT.IQ(KOFUDB+LAUXDL(9)-1)) THEN
                    NBAD   = NBAD +1
                    CALL MZDROP (IDISDB, LAUXDL(9), 'L')
                    IPNT   = KOFUDB + LAUXDL(10) + (IO - 1) * (NTOT + 1)
                    IQ(IPNT+1) = -1
                    GO TO 160
                  ENDIF
                  IF (IBEGDP(NPT).EQ.0) THEN
                    IBEGDP(NPT) = 1
                    CALL DBIOTY (LAUXDL(9), NOBJS(NPT),
     +              KOBJS(NDSMDP(NPT)+1), IOTYDP(NDSTDP(NPT)+1))
                  ENDIF
                ENDIF
*
*  **           Load the requested keys and object elements
*
                IPNT = KOFUDB + LAUXDL(10) + (NPL - 1) * (NTOT + 1)
                DO 130 I = 1, NKEYX(NPT)
                  IND = KEYXS(NKSMDP(NPT)+I)
                  IF (IOPTDA.EQ.0.OR.(IND.NE.MBVRDB.AND.IND.NE.MEVRDB
     +                .AND.IND.NE.MITMDB))                       THEN
                    Q(IPNT+NKSTDP(NPT)+I+1) = KEYVDK(IND)
                  ELSE IF (IND.EQ.MBVRDB.OR.IND.EQ.MEVRDB) THEN
                    CALL DBUTIS (KEYVDK(IND), IVAL)
                    Q(IPNT+NKSTDP(NPT)+I+1) = IVAL
                  ELSE
                    CALL DBUTIM (KEYVDK(IND), IVAL)
                    Q(IPNT+NKSTDP(NPT)+I+1) = IVAL
                  ENDIF
  130           CONTINUE
                DO 135 I = 1, NOBJS(1)
                  ID     = NDSTDP(1) + I
                  II     = KOBJS(NDSMDP(1)+I)
                  IF (IOTYDP(ID).EQ.1.OR.IOTYDP(ID).EQ.2.OR.
     +                IOTYDP(ID).EQ.5)      THEN
                    IVAL   = IQ(KOFUDB+LAUXDL(9)+II)
                    Q(IPNT+ID+1) = IVAL
                  ELSE IF (IOTYDP(ID).EQ.4) THEN
                    CALL UCOPY (Q(KOFUDB+LAUXDL(9)+II), DVAL, 2)
                    Q(IPNT+ID+1) = DVAL
                  ELSE
                    Q(IPNT+ID+1) = Q(KOFUDB+LAUXDL(9)+II)
                  ENDIF
  135           CONTINUE
                IF (LAUXDL(9).NE.0) CALL MZDROP (IDISDB, LAUXDL(9), 'L')
                GO TO 160
  140         CONTINUE
*
              CALL RZCDIR (PATH, ' ' )
              IF (IQUEST(1).NE.0) THEN
                CALL MZDROP (IDISDB, LAUXDL(10), 'L')
                IQUEST(1) = 161
+SELF, IF=$DEBUG.
                IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT :'//
     +          ' Illegal pathname '//PATH//''')', IARGDB, 0)
+SELF.
                GO TO 999
              ENDIF
              LCDRDB = IQUEST(11)
              IKDRDB = IQUEST(13)
  150       CONTINUE
          ENDIF
          IPNT   = KOFUDB + LAUXDL(10) + (NPL - 1) * (NTOT + 1)
          IQ(IPNT+1) = -1
*
  160     CALL RZCDIR (PATH, ' ' )
          IF (IQUEST(1).NE.0) THEN
            CALL MZDROP (IDISDB, LAUXDL(10), 'L')
            IQUEST(1) = 161
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLNT :'//
     +      ' Illegal pathname '//PATH//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
  170   CONTINUE
  180 CONTINUE
*
* *** Fill the N-tuples
*
      CALL HCDIR (PATHN, ' ')
      DO 190 IP = 1, NPL
        IPNT   = KOFUDB + LAUXDL(10) + (IP - 1) * (NTOT + 1)
        IF (IQ(IPNT+1).GT.0) THEN
          CALL HFN (NTUP, Q(IPNT+2))
        ENDIF
  190 CONTINUE
*
* *** Go back and repeat if not yet completed
*
      IF (NOLD.NE.NCUR.OR.NOLDD.NE.NCURD) THEN
        NOLD   = NCUR
        NOLDD  = NCURD
        GO TO 40
      ENDIF
*                                                             END DBPLNT
  999 END
+DECK, DBPLOB.
+SEQ, T=DUMMY, IF=$P3CHILD, IF=IBM.
      SUBROUTINE DBPLOB (PATHN, KEYS, NOBJ, KOBJ, KEX, NST, CHOPT)
*     ============================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBPLOB (PATHN, KEYS, NOBJ, KOBJ, KEX, NST, CHOPT)       *
*                                                                      *
*   Plots data elemnet(s) versus a key element for a given path name   *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     KEYS     Vector of keys. Only the elements declared in CHOPT are *
*              assumed to contain useful information.                  *
*     NOBJ     Number of data objects to be plotted                    *
*     KOBJ     Vector specifying the element numbers to be plotted     *
*     KEX      Key index for the abcissa                               *
*     NST      Step size for selection of object number                *
*     CHOPT    Character string with any of the following characters   *
*          L   a line to be drawn through the points                   *
*              (needed only when symbol and line both to be drawn)     *
*          P   a symbol to be drawn at each point                      *
*              (Default is a line to be drawn through the points)      *
*          S   all elements shown on the same plot                     *
*              (Default is a seperate plot for each variable)          *
*          3   selects objects with start validity time > KEYS(3)      *
*          4   selects objects with start validity time < KEYS(4)      *
*          5   specific Program version number required                *
*          7   selects objects with insertion      time < KEYS(7)      *
*          n   consider user key n (where 7 < n < 30)                  *
*                                                                      *
*   Called by user,   DBACPL                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =161 : Illegal path name                               *
*               =162 : No keys or data in the directory                *
*               =163 : Illegal number of objects                       *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DPLOTS.
      PARAMETER       (MXSYM=12)
      LOGICAL         HEXIST
      CHARACTER       PATH*80, PATHX*16, PATHY*80, CHTAG(7)*16, CTAG*16
      CHARACTER       PATHN*(*), CHOPT*(*)
      DIMENSION       KEYS(9), KOBJ(9), ISYMB(MXSYM)
      DOUBLE PRECISION DVAL
      DATA            CHTAG /'Serial Number   ', 'Pointer         ',
     +                       'Start Validity  ', 'End Validity    ',
     +                       'Program Version ', 'Flags           ',
     +                       'Insertion Time  '/
      DATA            ISYMB /20,21,22,23,24,25,26,27,28,29,30,31/
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Decode the character option
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)                                    GO TO 999
      IF (KEX.EQ.MBVRDB.OR.KEX.EQ.MEVRDB.OR.KEX.EQ.MITMDB) THEN
        KABS   = KEX
      ELSE
        KABS   = MBVRDB
      ENDIF
      IF (NST.GT.0) THEN
        NSTEP  = NST
      ELSE
        NSTEP  = 1
      ENDIF
      IF (NOBJ.LT.1.OR.NOBJ.GT.NOBMDP) THEN
        IQUEST(1) = 163
        IQUEST(11)= NOBJ
        IQUEST(12)= NOBMDP
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOB : Illegal'//
     +  ' number of objects '',2I12)', IQUEST(11), 2)
+SELF.
        GO TO 999
      ENDIF
      NOBM   = KOBJ(1)
      DO 5 I = 2, NOBJ
        IF (KOBJ(I).GT.NOBM) NOBM = KOBJ(I)
    5 CONTINUE
*
* *** Suppress blanks from the pathname and sets current directory
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 161
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOB : Ill'//
     +  'egal pathname '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      CALL RZCDIR (PATH, 'R')
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKYTG
*
      IF (NKEYDK.LE.0) THEN
        IQUEST(1) = 162
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOB : No keys'//
     +  ' in directory '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
      NCHR   = INDEX (PATH, ' ') - 1
      IF (NCHR.LT.1) NCHR = MAXLDB
      NCHRT  = INDEX (PATH(3:NCHR), '/') - 1
      IF (NCHRT.LE.0) NCHRT = NCHR - 2
      PATHX  = PATH(3:NCHRT+2)
      LTOP   = LTOPDB
    8 IF (LTOP.NE.0) THEN
        NCHRT  = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHRT)
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 8
        ENDIF
        KY7MDB = IQ(KOFUDB+LTOP+MUPKY7)
      ELSE
        KY7MDB = 0
      ENDIF
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
      NTOT   = 0
      IF (KEX.GT.0.AND.KEX.LE.NWKYDK) THEN
        KPEX   = KEX
      ELSE
        KPEX   = 3
      ENDIF
      IF (KPEX.LT.NSYSDK) THEN
        CTAG   = CHTAG(KPEX)
      ELSE
        CTAG   = CTAGDK(KPEX)
      ENDIF
*
* *** Prepare a temporary storage for useful information
*
      CALL DATIME (IDATX, ITIMX)
      IF (KABS.EQ.MITMDB) THEN
        CALL DBPKTM (IDATX, ITIMX, ITNOW)
        CALL DBPKTS (IDATX, ITIMX*100, INOWS)
      ELSE
        CALL DBPKTS (IDATX, ITIMX*100, ITNOW)
        INOWS  = ITNOW
      ENDIF
      NPLM   = NPLMDP
      IF (IOPTP.EQ.0) THEN
        IF (NKEYDK.LT.NPLM) NPLM = NKEYDK
      ENDIF
      ND     = (NOBJ + 1) * NPLM
+SELF, IF=$DEBUG.
      NBAD   = 0
+SELF.
      IF (LAUXDL(10).NE.0) CALL MZDROP (IDISDB, LAUXDL(10), 'L')
      CALL DBBOOK (IDISDB, LAUXDL(10), LAUXDL(10), 2, 'TEMP', 0, 0, ND,
     +             0, -1)
      IF (IQUEST(1).NE.0)                                    GO TO 999
      VMINDP = 9.0E20
      VMAXDP =-9.0E20
      IF (LAUXDL(9).NE.0) THEN
        CALL MZDROP (IDISDB, LAUXDL(9), 'L')
        LAUXDL(9) = 0
      ENDIF
*
* *** Load useful data in the temporary bank
*
      IMIN   = ITNOW
      IMAX   = -1
      ITIME  = 1
      JBIAS  = 2
      NPL    = 0
      IF (IOPTP.EQ.0) THEN
        DO 20 JK = 1, NKEYDK
          IK     = NKEYDK + 1 - JK
          CALL DBKEYR (IK, NWKYDK, KEYVDK)
          IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB))
     +                                                       GO TO 20
          IF (KEYVDK(MBVRDB).GT.INOWS)                       GO TO 20
          IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB))
     +                                                       GO TO 20
          IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))
     +                                                       GO TO 20
          IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))
     +                                                       GO TO 20
          IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)      GO TO 20
          IF (NWKYDK.GT.NSYSDK) THEN
            DO 10 I = NSYSDK+1, NWKYDK
              IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I))   GO TO 20
   10       CONTINUE
          ENDIF
          NTOT   = NTOT + 1
          IF (NSTEP.GT.1) THEN
            IF (MOD(NTOT,NSTEP).NE.1)                        GO TO 20
          ENDIF
          LAUXDL(9) = 0
          KTIME  = KEYVDK(KABS)
          KYVAL  = KEYVDK(KPEX)
          CALL VZERO (KEYVDK, NWKYDK)
          KEYVDK(MSERDB) = IK
          IOKYDA(MSERDB) = 1
          CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9), JBIAS,
     +                 NWKYDK, KEYVDK, IPREC)
          IOKYDA(MSERDB) = 0
          IF (IQUEST(1).NE.0) THEN
            IF (LAUXDL(9).NE.0)
     +        CALL MZDROP (IDISDB, LAUXDL(9), 'L')
+SELF, IF=$DEBUG.
            NBAD   = NBAD + 1
+SELF.
            IQUEST(1) = 0
            GO TO 20
          ENDIF
          IF (NOBM.GT.IQ(KOFUDB+LAUXDL(9)-1)) THEN
+SELF, IF=$DEBUG.
            NBAD   = NBAD + 1
+SELF.
            CALL MZDROP (IDISDB, LAUXDL(9), 'L')
            GO TO 20
          ENDIF
          IF (NPL.EQ.0) CALL DBIOTY (LAUXDL(9), NOBJ, KOBJ, IOTYDP)
          NPL    = NPL + 1
          IF (NPL.LE.NPLM) THEN
            IPNT   = KOFUDB + LAUXDL(10) + (NPL - 1) * (NOBJ + 1)
            IQ(IPNT+1) = KYVAL
            DO 15 I = 1, NOBJ
              IF (IOTYDP(I).EQ.1.OR.IOTYDP(I).EQ.2.OR.IOTYDP(I).EQ.5)
     +                                                     THEN
                IVAL   = IQ(KOFUDB+LAUXDL(9)+KOBJ(I))
                Q(IPNT+I+1) = IVAL
              ELSE IF (IOTYDP(I).EQ.4) THEN
                CALL UCOPY (Q(KOFUDB+LAUXDL(9)+KOBJ(I)), DVAL, 2)
                Q(IPNT+I+1) = DVAL
              ELSE
                Q(IPNT+I+1) = Q(KOFUDB+LAUXDL(9)+KOBJ(I))
              ENDIF
              IF (Q(IPNT+I+1).GT.VMAXDP) VMAXDP = Q(IPNT+I+1)
              IF (Q(IPNT+I+1).LT.VMINDP) VMINDP = Q(IPNT+I+1)
   15       CONTINUE
            IF (KTIME.LT.IMIN) IMIN = KTIME
            IF (KTIME.GT.IMAX) IMAX = KTIME
          ENDIF
          CALL MZDROP (IDISDB, LAUXDL(9), 'L')
   20   CONTINUE
*
      ELSE
        KST    = NWKYDK + 1
        NKEYS  = NKEYDK
        DO 40 JKK = 1, NKEYS
          IKK    = NKEYS + 1 - JKK
          KPNT   = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                     NKEYS*KST, KST)
          IF (KPNT.GT.0) THEN
            KPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB
          ELSE
            KPNT   = KOFSDB + LCDRDB + IKDRDB + (IKK - 1) * KST
          ENDIF
          IF (IOKYDA(MBVRDB).NE.0.AND.IQ(KPNT+MEVRDB).LT.KEYS(MBVRDB))
     +                                                       GO TO 40
          IF (IQ(KPNT+MBVRDB).GT.INOWS)                      GO TO 40
          IF (IOKYDA(MEVRDB).NE.0.AND.IQ(KPNT+MBVRDB).GT.KEYS(MEVRDB))
     +                                                       GO TO 40
          IF (IOKYDA(MITMDB).NE.0.AND.IQ(KPNT+MITMDB).GT.KEYS(MITMDB))
     +                                                       GO TO 40
          IF (KY7MDB.GT.0.AND.IQ(KPNT+MITMDB).GT.KY7MDB)     GO TO 40
*
          CALL DBPATH (PATHX, IKK)
          PATHY  = PATH(1:NCHR)//'/'//PATHX
          CALL RZCDIR (PATHY, ' ')
          IF (IQUEST(1).NE.0) THEN
            CALL MZDROP (IDISDB, LAUXDL(10), ' ')
            IQUEST(1) = 161
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOB : Ill'//
     +      'egal pathname '//PATHY//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          DO 35 JK = 1, NKEYDK
            IK     = NKEYDK + 1 - JK
            CALL DBKEYR (IK, NWKYDK, KEYVDK)
            IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB))
     +                                                       GO TO 35
            IF (KEYVDK(MBVRDB).GT.INOWS)                     GO TO 35
            IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB))
     +                                                       GO TO 35
            IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))
     +                                                       GO TO 35
            IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))
     +                                                       GO TO 35
            IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)    GO TO 35
            IF (NWKYDK.GT.NSYSDK) THEN
              DO 25 I = NSYSDK+1, NWKYDK
                IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I)) GO TO 35
   25         CONTINUE
            ENDIF
            NTOT   = NTOT + 1
            IF (NSTEP.GT.1) THEN
              IF (MOD(NTOT,NSTEP).NE.1)                      GO TO 35
            ENDIF
            LAUXDL(9) = 0
            KTIME  = KEYVDK(KABS)
            KYVAL  = KEYVDK(KPEX)
            CALL VZERO (KEYVDK, NWKYDK)
            KEYVDK(MSERDB) = IK
            IOKYDA(MSERDB) = 1
            CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9), JBIAS,
     +                   NWKYDK, KEYVDK, IPREC)
            IOKYDA(MSERDB) = 0
            IF (IQUEST(1).NE.0) THEN
              IF (LAUXDL(9).NE.0)
     +          CALL MZDROP (IDISDB, LAUXDL(9), 'L')
+SELF, IF=$DEBUG.
              NBAD   = NBAD + 1
+SELF.
              IQUEST(1) = 0
              GO TO 35
            ENDIF
            IF (NOBM.GT.IQ(KOFUDB+LAUXDL(9)-1)) THEN
+SELF, IF=$DEBUG.
              NBAD   = NBAD + 1
+SELF.
              CALL MZDROP (IDISDB, LAUXDL(9), 'L')
              GO TO 35
            ENDIF
            IF (NPL.EQ.0) CALL DBIOTY (LAUXDL(9), NOBJ, KOBJ, IOTYDP)
            NPL    = NPL + 1
            IF (NPL.LE.NPLM) THEN
              IPNT   = KOFUDB + LAUXDL(10) + (NPL - 1) * (NOBJ + 1)
              IQ(IPNT+1) = KYVAL
              DO 30 I = 1, NOBJ
                IF (IOTYDP(I).EQ.1.OR.IOTYDP(I).EQ.2.OR.IOTYDP(I).EQ.5)
     +                                                     THEN
                  IVAL   = IQ(KOFUDB+LAUXDL(9)+KOBJ(I))
                  Q(IPNT+I+1) = IVAL
                ELSE IF (IOTYDP(I).EQ.4) THEN
                  CALL UCOPY (Q(KOFUDB+LAUXDL(9)+KOBJ(I)), DVAL, 2)
                  Q(IPNT+I+1) = DVAL
                ELSE
                  Q(IPNT+I+1) = Q(KOFUDB+LAUXDL(9)+KOBJ(I))
                ENDIF
                IF (Q(IPNT+I+1).GT.VMAXDP) VMAXDP = Q(IPNT+I+1)
                IF (Q(IPNT+I+1).LT.VMINDP) VMINDP = Q(IPNT+I+1)
   30         CONTINUE
              IF (KTIME.LT.IMIN) IMIN = KTIME
              IF (KTIME.GT.IMAX) IMAX = KTIME
            ENDIF
            CALL MZDROP (IDISDB, LAUXDL(9), 'L')
   35     CONTINUE
          CALL RZCDIR (PATH, ' ')
          IF (IQUEST(1).NE.0) THEN
            CALL MZDROP (IDISDB, LAUXDL(10), ' ')
            IQUEST(1) = 161
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOB : Ill'//
     +      'egal pathname '//PATH//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          IF (NPL.GT.NPLM)                                   GO TO 45
   40   CONTINUE
*
      ENDIF
*
* *** All points collected
*
   45 CONTINUE
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBPLOB : Number of'//
     +   ' bad objects '',I12)', NBAD, 1)
+SELF.
      IF (NPL.EQ.0) THEN
        CALL MZDROP (IDISDB, LAUXDL(10), ' ')
        GO TO 999
      ENDIF
      IF (NPL.GT.NPLM) THEN
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          IARGDB(1) = NPL
          IARGDB(2) = NPLM
          CALL DBPRNT (LPRTDB, '(/,'' DBPLOB : Too many objects '','//
     +         'I6,'' only '',I6,'' shown'')', IARGDB, 2)
        ENDIF
+SELF.
        NPL    = NPLM
      ENDIF
*
* *** Sort the objects in increasing time
*
      CALL DBBOOK (IDISDB, LAUXDL(9), LAUXDL(9), 2, 'TIME', 0, 0, 4*NPL,
     +             0, -1)
      IF (IQUEST(1).NE.0) THEN
        IER    = IQUEST(1)
        CALL MZDROP (IDISDB, LAUXDL(10), ' ')
        IQUEST(1) = IER
        GO TO 999
      ENDIF
      DO 50 IK = 1, NPL
        IQ(KOFUDB+LAUXDL(9)+IK) = IQ(KOFUDB+LAUXDL(10)+(IK-1)*(NOBJ+1)
     +                              +1)
   50 CONTINUE
      CALL SORTZV (IQ(KOFUDB+LAUXDL(9)+1), IQ(KOFUDB+LAUXDL(9)+NPL+1),
     +             NPL, -1, 0, 0)
*
* *** Set up the header
*
      IF (IMAX.GT.ITNOW) IMAX = ITNOW
      IF (KABS.EQ.MITMDB) THEN
        CALL DBUPTM (IDATX, ITIMX, IMIN)
        ITIMX  = ITIMX * 100
      ELSE
        CALL DBUPTS (IDATX, ITIMX, IMIN)
      ENDIF
      CALL DBTIME (IDATX, ITIMX)
      IBINDP(3) = IDATX/10000 + 1900
      IBINDP(2) = MOD (IDATX/100, 100)
      IBINDP(1) = MOD (IDATX    , 100)
      CALL CALDAT (101, CHRPDP, IBINDP, IRET)
      DYSTDP = CHRPDP(26:34)
      IF (KABS.EQ.MITMDB) THEN
        CALL DBUPTM (IDATX, ITIMX, IMAX)
        ITIMX  = ITIMX * 100
      ELSE
        CALL DBUPTS (IDATX, ITIMX, IMAX)
      ENDIF
      CALL DBTIME (IDATX, ITIMX)
      IBINDP(3) = IDATX/10000 + 1900
      IBINDP(2) = MOD (IDATX/100, 100)
      IBINDP(1) = MOD (IDATX    , 100)
      CALL CALDAT (101, CHRPDP, IBINDP, IRET)
      DYENDP = CHRPDP(26:34)
*
* *** Now setup the x-scale
*
      DO 55 IK = 1, NPL
        IPNT   = IQ(KOFUDB+LAUXDL(9)+NPL+IK)
        KYVAL  = IQ(KOFUDB+LAUXDL(9)+IPNT)
        IF (KPEX.EQ.MBVRDB.OR.KPEX.EQ.MEVRDB.OR.KPEX.EQ.MITMDB) THEN
          IF (KPEX.EQ.MITMDB) THEN
            CALL DBUPTM (IDATX, ITIMX, KYVAL)
            ITIMX  = ITIMX * 100
          ELSE
            CALL DBUPTS (IDATX, ITIMX, KYVAL)
          ENDIF
          CALL DBTIME (IDATX, ITIMX)
          NHOUR  = ITIMX / 10000
          NMIN   = MOD (ITIMX/100, 100)
          NSEC   = MOD (ITIMX    , 100)
          HOUR   = NHOUR + FLOAT(NMIN)/60.0 + FLOAT(NSEC)/3600.0
          IBINDP(3) = IDATX/10000 + 1900
          IBINDP(2) = MOD (IDATX/100, 100)
          IBINDP(1) = MOD (IDATX    , 100)
          CALL CALDAT (101, CHRPDP, IBINDP, IRET)
          IF (IK.EQ.1) IDAY1 = IBINDP(6)
          IDAY   = IBINDP(6) - IDAY1
          HOUR   = HOUR + 24.0 * IDAY
          Q(KOFUDB+LAUXDL(9)+2*NPL+IK) = HOUR
        ELSE
          Q(KOFUDB+LAUXDL(9)+2*NPL+IK) = KYVAL
        ENDIF
   55 CONTINUE
      IF (KPEX.EQ.MBVRDB.OR.KPEX.EQ.MEVRDB.OR.KPEX.EQ.MITMDB) THEN
        XMIN   = Q(KOFUDB+LAUXDL(9)+2*NPL+1) - 0.1
        XMAX   = Q(KOFUDB+LAUXDL(9)+3*NPL)   + 0.1
      ELSE
        XMIN   = Q(KOFUDB+LAUXDL(9)+2*NPL+1) - 0.5
        XMAX   = Q(KOFUDB+LAUXDL(9)+3*NPL)   + 0.5
      ENDIF
      CALL HTITLE (PATH)
*
* *** Now plot the object elements
*
      YRAN   = 0.1 * (VMAXDP - VMINDP)
      YMIN   = VMINDP - YRAN
      YMAX   = VMAXDP + YRAN
      IF (IOPSDA.NE.0) THEN
+SELF, IF=-IBM, -$P3CHILD.
        WRITE (CTTLDP, 2001) KOBJ(1), CTAG, DYSTDP, DYENDP
+SELF, IF=IBM, IF=$P3CHILD.
        CALL UTWRIT (CITLDP, '(''Object '',I6,'',... vs. '//CTAG(1:16)//
     +       ' '//DYSTDP(1:9)//' - '//DYENDP(1:9)//''')', KOBJ(1), 1)
+SELF.
        IF (HEXIST(-101)) CALL HDELET (-101)
        CALL HBOOK1 (-101, CTTLDP, 2, XMIN, XMAX, 0.)
        CALL HPLOPT ('HORI', 1)
        CALL HMINIM (-101, YMIN)
        CALL HMAXIM (-101, YMAX)
        CALL HPLOT  (-101, ' ', 'HIST', 0)
      ENDIF
      DO 70 IK = 1, NOBJ
        IF (IOPSDA.EQ.0) THEN
+SELF, IF=-IBM, -$P3CHILD.
          WRITE (CTTLDP, 2002) KOBJ(IK), CTAG, DYSTDP, DYENDP
+SELF, IF=IBM, IF=$P3CHILD.
          CALL UTWRIT (CITLDP, '(''Object '',I6,'' vs. '//CTAG(1:16)//
     +         ' '//DYSTDP(1:9)//' - '//DYENDP(1:9)//''')', KOBJ(1), 1)
+SELF.
          IF (HEXIST(-101)) CALL HDELET (-101)
          CALL HBOOK1 (-101, CTTLDP, 2, XMIN, XMAX, 0.)
          CALL HPLOPT ('HORI', 1)
          CALL HMINIM (-101, YMIN)
          CALL HMAXIM (-101, YMAX)
          CALL HPLOT  (-101, ' ', 'HIST', 0)
        ENDIF
        KSYM   = MOD (IK, MXSYM)
        IF (KSYM.EQ.0) THEN
          ISYM   = ISYMB(MXSYM)
        ELSE
          ISYM   = ISYMB(KSYM)
        ENDIF
        DO 60 JK = 1, NPL
          IPNT   = IQ(KOFUDB+LAUXDL(9)+NPL+JK)
          KPNT   = (IPNT - 1) * (NOBJ + 1)
          Q(KOFUDB+LAUXDL(9)+3*NPL+JK) = Q(KOFUDB+LAUXDL(10)+KPNT+IK+1)
   60   CONTINUE
        IF (IOPPDA.NE.0) THEN
          CALL HPLSYM (Q(KOFUDB+LAUXDL(9)+2*NPL+1),
     +                 Q(KOFUDB+LAUXDL(9)+3*NPL+1), NPL, ISYM, 0.1, ' ')
        ENDIF
        IF (IOPPDA.EQ.0.OR.IOPLDA.NE.0) THEN
          CALL HPLINE (Q(KOFUDB+LAUXDL(9)+2*NPL+1),
     +                 Q(KOFUDB+LAUXDL(9)+3*NPL+1), NPL, ' ')
        ENDIF
        IF (IOPSDA.EQ.0.AND.IK.NE.NOBJ) CALL DBUSIN
   70 CONTINUE
*
   80 IF (LAUXDL(10).NE.0) CALL MZDROP (IDISDB, LAUXDL(10), ' ')
      IF (LAUXDL(9) .NE.0) CALL MZDROP (IDISDB, LAUXDL(9),  ' ')
      IF (HEXIST(-101)) CALL HDELET (-101)
      IQUEST(1) = 0
+SELF, IF=-IBM, -$P3CHILD.
*
 2001 FORMAT ('Object ',I6,',... vs. ',A16,1X,A9,' - ',A9)
 2002 FORMAT ('Object ',I6,' vs. ',A16,1X,A9,' - ',A9)
+SELF.
*                                                             END DBPLOB
  999 END
+DECK, DBPLOV.
+SEQ, T=DUMMY, IF=$P3CHILD, IF=IBM.
      SUBROUTINE DBPLOV (PATHN, KEYS, NOBJ, KOBJ, NST, CHOPT)
*     =======================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBPLOV (PATHN, KEYS, NOBJ, KOBJ, NST, CHOPT)            *
*                                                                      *
*   Plots data elemnet(s) versus data element(s) for a given path name *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     KEYS     Vector of keys. Only the elements declared in CHOPT are *
*              assumed to contain useful information.                  *
*     NOBJ     Number of data objects to be plotted                    *
*     KOBJ     Vector specifying the element numbers to be plotted     *
*     NST      Step size for selection of object number                *
*     CHOPT    Character string with any of the following characters   *
*          L   line to be drawn through the points                     *
*          P   a symbol to be drawn at each point                      *
*              (If L or P not chosen, a default marker to be drawn     *
*               at each point)                                         *
*          3   selects objects with start validity time > KEYS(3)      *
*          4   selects objects with start validity time < KEYS(4)      *
*          5   specific Program version number required                *
*          7   selects objects with insertion      time < KEYS(7)      *
*          n   consider user key n (where 7 < n < 30)                  *
*                                                                      *
*   Called by user,   DBACPL                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =161 : Illegal path name                               *
*               =162 : No keys or data in the directory                *
*               =163 : Illegal number of objects                       *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DINITL.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DPLOTS.
      LOGICAL         HEXIST
      CHARACTER       PATH*80, PATHX*16, PATHY*80
      CHARACTER       PATHN*(*), CHOPT*(*)
      DIMENSION       KEYS(9), KOBJ(2,9)
      DOUBLE PRECISION DVAL
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Decode the character option
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)                                    GO TO 999
      KABS   = 3
      IF (NST.GT.0) THEN
        NSTEP  = NST
      ELSE
        NSTEP  = 1
      ENDIF
      IF (NOBJ.LT.1.OR.NOBJ.GT.NOBMDP) THEN
        IQUEST(1) = 163
        IQUEST(11)= NOBJ
        IQUEST(12)= NOBMDP
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOV : Illegal'//
     +  ' number of objects '',2I12)', IQUEST(11), 2)
+SELF.
        GO TO 999
      ENDIF
      NOBJDP = 0
      NOBM   = KOBJ(1,1)
      DO 5 IK = 1, NOBJ
        II     = IUCOMP (KOBJ(1,IK), KOBJDP, NOBJDP)
        IF (II.EQ.0) THEN
          NOBJDP = NOBJDP + 1
          II     = NOBJDP
          KOBJDP(II) = KOBJ(1,IK)
          IF (KOBJDP(II).GT.NOBM) NOBM = KOBJDP(II)
        ENDIF
        INDXDP(1,IK) = II
        II     = IUCOMP (KOBJ(2,IK), KOBJDP, NOBJDP)
        IF (II.EQ.0) THEN
          NOBJDP = NOBJDP + 1
          II     = NOBJDP
          KOBJDP(II) = KOBJ(2,IK)
        ENDIF
        INDXDP(2,IK) = II
    5 CONTINUE
*
* *** Suppress blanks from the pathname and sets current directory
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 161
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOV : Ill'//
     +  'egal pathname '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      CALL RZCDIR (PATH, 'R')
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKEYT
*
      IF (NKEYDK.LE.0) THEN
        IQUEST(1) = 162
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOV : No keys'//
     +  ' in directory '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
*
      NCHR   = INDEX (PATH, ' ') - 1
      IF (NCHR.LT.1) NCHR = MAXLDB
      NCHRT  = INDEX (PATH(3:NCHR), '/') - 1
      IF (NCHRT.LE.0) NCHRT = NCHR - 2
      PATHX  = PATH(3:NCHRT+2)
      LTOP   = LTOPDB
    8 IF (LTOP.NE.0) THEN
        NCHRT  = IQ(KOFUDB+LTOP+MUPNCH)
        CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHRT)
        IF (PATHX.NE.TOPNDI(1:NCHRT)) THEN
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 8
        ENDIF
        KY7MDB = IQ(KOFUDB+LTOP+MUPKY7)
      ELSE
        KY7MDB = 0
      ENDIF
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
      NTOT   = 0
+SELF, IF=$DEBUG.
      NBAD   = 0
+SELF.
*
* *** Prepare a temporary storage for useful information
*
      CALL DATIME (IDATX, ITIMX)
      CALL DBPKTS (IDATX, ITIMX*100, ITNOW)
      NPLM   = NPLMDP
      IF (IOPTP.EQ.0) THEN
        IF (NKEYDK.LT.NPLM) NPLM = NKEYDK
      ENDIF
      ND     = (NOBJDP + 1) * NPLM
      IF (LAUXDL(10).NE.0) CALL MZDROP (IDISDB, LAUXDL(10), 'L')
      CALL DBBOOK (IDISDB, LAUXDL(10), LAUXDL(10), 2, 'TEMP', 0, 0, ND,
     +             0, -1)
      IF (IQUEST(1).NE.0)                                    GO TO 999
      VMINDP = 9.0E20
      VMAXDP =-9.0E20
      IF (LAUXDL(9).NE.0) THEN
        CALL MZDROP (IDISDB, LAUXDL(9), 'L')
        LAUXDL(9) = 0
      ENDIF
*
* *** Load useful data in the temporary bank
*
      IMIN   = ITNOW
      IMAX   = -1
      ITIME  = 1
      JBIAS  = 2
      NPL    = 0
      IF (IOPTP.EQ.0) THEN
        DO 20 JK = 1, NKEYDK
          IK     = NKEYDK + 1 - JK
          CALL DBKEYR (IK, NWKYDK, KEYVDK)
          IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB))
     +                                                       GO TO 20
          IF (KEYVDK(MBVRDB).GT.ITNOW)                       GO TO 20
          IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB))
     +                                                       GO TO 20
          IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))
     +                                                       GO TO 20
          IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))
     +                                                       GO TO 20
          IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)      GO TO 20
          IF (NWKYDK.GT.NSYSDK) THEN
            DO 10 I = NSYSDK+1, NWKYDK
              IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I))   GO TO 20
   10       CONTINUE
          ENDIF
          NTOT   = NTOT + 1
          IF (NSTEP.GT.1) THEN
            IF (MOD(NTOT,NSTEP).NE.1)                        GO TO 20
          ENDIF
          LAUXDL(9) = 0
          KTIME  = KEYVDK(KABS)
          CALL VZERO (KEYVDK, NWKYDK)
          KEYVDK(MSERDB) = IK
          IOKYDA(MSERDB) = 1
          CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9), JBIAS,
     +                 NWKYDK, KEYVDK, IPREC)
          IOKYDA(MSERDB) = 0
          IF (IQUEST(1).NE.0) THEN
            IF (LAUXDL(9).NE.0)
     +        CALL MZDROP (IDISDB, LAUXDL(9), 'L')
            IQUEST(1) = 0
+SELF, IF=$DEBUG.
            NBAD   = NBAD + 1
+SELF.
            GO TO 20
          ENDIF
          IF (NOBM.GT.IQ(KOFUDB+LAUXDL(9)-1)) THEN
+SELF, IF=$DEBUG.
            NBAD   = NBAD + 1
+SELF.
            CALL MZDROP (IDISDB, LAUXDL(9), 'L')
            GO TO 20
          ENDIF
          IF (NPL.EQ.0) CALL DBIOTY (LAUXDL(9), NOBJDP, KOBJDP, IOTYDP)
          NPL    = NPL + 1
          IF (NPL.LE.NPLM) THEN
            IPNT   = KOFUDB + LAUXDL(10) + (NPL - 1) * (NOBJDP + 1)
            IQ(IPNT+1) = KTIME
            DO 15 I = 1, NOBJDP
              IF (IOTYDP(I).EQ.1.OR.IOTYDP(I).EQ.2.OR.IOTYDP(I).EQ.5)
     +                                                     THEN
                IVAL   = IQ(KOFUDB+LAUXDL(9)+KOBJDP(I))
                Q(IPNT+I+1) = IVAL
              ELSE IF (IOTYDP(I).EQ.4) THEN
                CALL UCOPY (Q(KOFUDB+LAUXDL(9)+KOBJDP(I)), DVAL, 2)
                Q(IPNT+I+1) = DVAL
              ELSE
                Q(IPNT+I+1) = Q(KOFUDB+LAUXDL(9)+KOBJDP(I))
              ENDIF
              IF (Q(IPNT+I+1).GT.VMAXDP) VMAXDP = Q(IPNT+I+1)
              IF (Q(IPNT+I+1).LT.VMINDP) VMINDP = Q(IPNT+I+1)
   15       CONTINUE
            IF (KTIME.LT.IMIN) IMIN = KTIME
            IF (KTIME.GT.IMAX) IMAX = KTIME
          ENDIF
          CALL MZDROP (IDISDB, LAUXDL(9), ' ')
   20   CONTINUE
*
      ELSE
        KST    = NWKYDK + 1
        NKEYS  = NKEYDK
        DO 40 JKK = 1, NKEYS
          IKK    = NKEYS + 1 - JKK
          KPNT   = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                     NKEYS*KST, KST)
          IF (KPNT.GT.0) THEN
            KPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB
          ELSE
            KPNT   = KOFSDB + LCDRDB + IKDRDB + (IKK - 1) * KST
          ENDIF
          IF (IOKYDA(MBVRDB).NE.0.AND.IQ(KPNT+MEVRDB).LT.KEYS(MBVRDB))
     +                                                       GO TO 40
          IF (IQ(KPNT+MBVRDB).GT.ITNOW)                      GO TO 40
          IF (IOKYDA(MEVRDB).NE.0.AND.IQ(KPNT+MBVRDB).GT.KEYS(MEVRDB))
     +                                                       GO TO 40
          IF (IOKYDA(MITMDB).NE.0.AND.IQ(KPNT+MITMDB).GT.KEYS(MITMDB))
     +                                                       GO TO 40
          IF (KY7MDB.GT.0.AND.IQ(KPNT+MITMDB).GT.KY7MDB)     GO TO 40
*
          CALL DBPATH (PATHX, IKK)
          PATHY  = PATH(1:NCHR)//'/'//PATHX
          CALL RZCDIR (PATHY, ' ')
          IF (IQUEST(1).NE.0) THEN
            CALL MZDROP (IDISDB, LAUXDL(10), ' ')
            IQUEST(1) = 161
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOV : Ill'//
     +      'egal pathname '//PATHY//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          DO 35 JK = 1, NKEYDK
            IK     = NKEYDK + 1 - JK
            CALL DBKEYR (IK, NWKYDK, KEYVDK)
            IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB))
     +                                                       GO TO 35
            IF (KEYVDK(MBVRDB).GT.ITNOW)                     GO TO 35
            IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB))
     +                                                       GO TO 35
            IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))
     +                                                       GO TO 35
            IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))
     +                                                       GO TO 35
            IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)    GO TO 35
            IF (NWKYDK.GT.NSYSDK) THEN
              DO 25 I = NSYSDK+1, NWKYDK
                IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I)) GO TO 35
   25         CONTINUE
            ENDIF
            NTOT   = NTOT + 1
            IF (NSTEP.GT.1) THEN
              IF (MOD(NTOT,NSTEP).NE.1)                      GO TO 35
            ENDIF
            LAUXDL(9) = 0
            KTIME  = KEYVDK(KABS)
            CALL VZERO (KEYVDK, NWKYDK)
            KEYVDK(MSERDB) = IK
            IOKYDA(MSERDB) = 1
            CALL DBKXIN (ITIME, IDISDB, LAUXDL(9), LAUXDL(9), JBIAS,
     +                   NWKYDK, KEYVDK, IPREC)
            IOKYDA(MSERDB) = 0
            IF (IQUEST(1).NE.0) THEN
              IF (LAUXDL(9).NE.0)
     +          CALL MZDROP (IDISDB, LAUXDL(9), 'L')
              IQUEST(1) = 0
+SELF, IF=$DEBUG.
              NBAD   = NBAD + 1
+SELF.
              GO TO 35
            ENDIF
            IF (NOBM.GT.IQ(KOFUDB+LAUXDL(9)-1)) THEN
+SELF, IF=$DEBUG.
              NBAD   = NBAD + 1
+SELF.
              CALL MZDROP (IDISDB, LAUXDL(9), 'L')
              GO TO 35
            ENDIF
            IF (NPL.EQ.0) CALL DBIOTY (LAUXDL(9), NOBJDP,KOBJDP, IOTYDP)
            NPL    = NPL + 1
            IF (NPL.LE.NPLM) THEN
              IPNT   = KOFUDB + LAUXDL(10) + (NPL - 1) * (NOBJDP + 1)
              IQ(IPNT+1) = KTIME
              DO 30 I = 1, NOBJDP
                IF (IOTYDP(I).EQ.1.OR.IOTYDP(I).EQ.2.OR.IOTYDP(I).EQ.5)
     +                                                     THEN
                  IVAL   = IQ(KOFUDB+LAUXDL(9)+KOBJDP(I))
                  Q(IPNT+I+1) = IVAL
                ELSE IF (IOTYDP(I).EQ.4) THEN
                  CALL UCOPY (Q(KOFUDB+LAUXDL(9)+KOBJDP(I)), DVAL, 2)
                  Q(IPNT+I+1) = DVAL
                ELSE
                  Q(IPNT+I+1) = Q(KOFUDB+LAUXDL(9)+KOBJDP(I))
                ENDIF
                IF (Q(IPNT+I+1).GT.VMAXDP) VMAXDP = Q(IPNT+I+1)
                IF (Q(IPNT+I+1).LT.VMINDP) VMINDP = Q(IPNT+I+1)
   30         CONTINUE
              IF (KTIME.LT.IMIN) IMIN = KTIME
              IF (KTIME.GT.IMAX) IMAX = KTIME
            ENDIF
            CALL MZDROP (IDISDB, LAUXDL(9), ' ')
   35     CONTINUE
          CALL RZCDIR (PATH, ' ')
          IF (IQUEST(1).NE.0) THEN
            CALL MZDROP (IDISDB, LAUXDL(10), ' ')
            IQUEST(1) = 161
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLOV : Ill'//
     +      'egal pathname '//PATH//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          IF (NPL.GT.NPLM)                                   GO TO 45
   40   CONTINUE
*
      ENDIF
*
* *** All points collected
*
   45 CONTINUE
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBPLOV : Number of'//
     +   ' bad objects '',I12)', NBAD, 1)
+SELF.
      IF (NPL.EQ.0) THEN
        CALL MZDROP (IDISDB, LAUXDL(10), ' ')
        GO TO 999
      ENDIF
      IF (NPL.GT.NPLM) THEN
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          IARGDB(1) = NPL
          IARGDB(1) = NPLM
          CALL DBPRNT (LPRTDB, '(/,'' DBPLOV : Too many objects '','//
     +         'I6,'' only '',I6,'' shown'')', IARGDB, 2)
        ENDIF
+SELF.
        NPL    = NPLM
      ENDIF
*
* *** Sort the objects in increasing time
*
      CALL DBBOOK (IDISDB, LAUXDL(9), LAUXDL(9), 2, 'TIME', 0, 0, 4*NPL,
     +             0, -1)
      IF (IQUEST(1).NE.0) THEN
        IER    = IQUEST(1)
        CALL MZDROP (IDISDB, LAUXDL(10), ' ')
        IQUEST(1) = IER
        GO TO 999
      ENDIF
      DO 50 IK = 1, NPL
        IQ(KOFUDB+LAUXDL(9)+IK) = IQ(KOFUDB+LAUXDL(10)+(IK-1)*(NOBJDP+1)
     +                              +1)
   50 CONTINUE
      CALL SORTZV (IQ(KOFUDB+LAUXDL(9)+1), IQ(KOFUDB+LAUXDL(9)+NPL+1),
     +             NPL, -1, 0, 0)
*
* *** Set up the header
*
      IF (IMAX.GT.ITNOW) IMAX = ITNOW
      CALL DBUPTS (IDATX, ITIMX, IMIN)
      CALL DBTIME (IDATX, ITIMX)
      IBINDP(3) = IDATX/10000 + 1900
      IBINDP(2) = MOD (IDATX/100, 100)
      IBINDP(1) = MOD (IDATX    , 100)
      CALL CALDAT (101, CHRPDP, IBINDP, IRET)
      DYSTDP = CHRPDP(26:34)
      CALL DBUPTS (IDATX, ITIMX, IMAX)
      CALL DBTIME (IDATX, ITIMX)
      IBINDP(3) = IDATX/10000 + 1900
      IBINDP(2) = MOD (IDATX/100, 100)
      IBINDP(1) = MOD (IDATX    , 100)
      CALL CALDAT (101, CHRPDP, IBINDP, IRET)
      DYENDP = CHRPDP(26:34)
      CALL HTITLE (PATH)
      CALL HPLOPT ('HORI', 1)
*
* *** Now make the plots
*
      DO 70 JK = 1, NOBJ
        IK1    = INDXDP(1,JK)
        IK2    = INDXDP(2,JK)
+SELF, IF=-IBM, -$P3CHILD.
        WRITE (CTTLDP, 2000) KOBJDP(IK2), KOBJDP(IK1), DYSTDP, DYENDP
+SELF, IF=IBM, IF=$P3CHILD.
        IARGDB(1) = KOBJDP(IK2)
        IARGDB(2) = KOBJDP(IK1)
        CALL UTWRIT (CITLDP, '(''Object '',I5,'' vs. Object '',I5,5X'//
     +       ','''//DYSTDP(1:9)//' - '//DYENDP(1:9)//''')', IARGDB, 2)
+SELF.
        XRAN   = 0.1 * (VMAXDP - VMINDP)
        IF (XRAN.EQ.0.0) XRAN = 0.01
        XMIN   = VMINDP - XRAN
        XMAX   = VMAXDP + XRAN
        YRAN   = 0.1 * (VMAXDP - VMINDP)
        IF (YRAN.EQ.0.0) YRAN = 0.01
        YMIN   = VMINDP - YRAN
        YMAX   = VMAXDP + YRAN
        IF (HEXIST(-101)) CALL HDELET (-101)
        CALL HBOOK1 (-101, CTTLDP, 2, XMIN, XMAX, 0.)
        CALL HMINIM (-101, YMIN)
        CALL HMAXIM (-101, YMAX)
        DO 60 IK = 1, NPL
          IPNT   = IQ(KOFUDB+LAUXDL(9)+NPL+IK)
          KPNT   = KOFUDB + LAUXDL(10) + (IPNT - 1) * (NOBJDP + 1) + 1
          Q(KOFUDB+LAUXDL(9)+2*NPL+IK) = Q(KPNT+IK1)
          Q(KOFUDB+LAUXDL(9)+3*NPL+IK) = Q(KPNT+IK2)
   60   CONTINUE
        CALL HPLOT  (-101, ' ', 'HIST', 0)
        IF (IOPPDA.NE.0) THEN
          CALL HPLSYM (Q(KOFUDB+LAUXDL(9)+2*NPL+1),
     +                 Q(KOFUDB+LAUXDL(9)+3*NPL+1), NPL, 31, 0.1, ' ')
        ELSE IF (IOPLDA.NE.0) THEN
          CALL HPLINE (Q(KOFUDB+LAUXDL(9)+2*NPL+1),
     +                 Q(KOFUDB+LAUXDL(9)+3*NPL+1), NPL, ' ')
        ELSE
          CALL HPLSYM (Q(KOFUDB+LAUXDL(9)+2*NPL+1),
     +                 Q(KOFUDB+LAUXDL(9)+3*NPL+1), NPL, 24, 0.05, ' ')
        ENDIF
        IF (JK.NE.NOBJ) CALL DBUSIN
   70 CONTINUE
*
   80 IF (LAUXDL(10).NE.0) CALL MZDROP (IDISDB, LAUXDL(10), ' ')
      IF (LAUXDL(9) .NE.0) CALL MZDROP (IDISDB, LAUXDL(9),  ' ')
      IF (HEXIST(-101)) CALL HDELET (-101)
      IQUEST(1) = 0
+SELF, IF=-IBM, -$P3CHILD.
*
 2000 FORMAT ('Object ',I5,' vs. Object ',I5,5X,A9,' - ',A9)
+SELF.
*                                                             END DBPLOV
  999 END
+DECK, DBPLTI.
+SEQ, T=DUMMY, IF=$P3CHILD, IF=IBM.
      SUBROUTINE DBPLTI (PATHN, KEYS, CHOPT)
*     ======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBPLTI (PATHN, KEYS, CHOPT)                             *
*                                                                      *
*   Plots the validity time of data objects in a given directory       *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     KEYS     Vector of keys. Only the elements declared in CHOPT are *
*              assumed to contain useful information.                  *
*     CHOPT    Character string with any of the following characters   *
*          3   selects objects with start validity time > KEYS(3)      *
*          4   selects objects with start validity time < KEYS(4)      *
*          5   specific Program version number required                *
*          7   selects objects with insertion      time < KEYS(7)      *
*          n   consider user key n (where 7 < n < 30)                  *
*                                                                      *
*   Called by user,   DBACPL                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =161 : Illegal path name                               *
*               =162 : No keys or data in the directory                *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DPLOTS.
      LOGICAL         HEXIST
      CHARACTER       PATH*80, PATHX*16, PATHY*80, PATHN*(*), CHOPT*(*)
      DIMENSION       KEYS(9), XU(2), YU(2)
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Decode the character option
*
      CALL DBOPTS (CHOPT)
      IF (IQUEST(1).NE.0)                                    GO TO 999
*
* *** Suppress blanks from the pathname and sets current directory
*
      CALL DBSBLC (PATHN, PATH, NCHAR)
      CALL RZCDIR (PATH, ' ')
      IF (IQUEST(1).NE.0) THEN
        IQUEST(1) = 161
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLTI : Ill'//
     +  'egal pathname '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      CALL RZCDIR (PATH, 'R')
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKEYT
      IF (NKEYDK.LE.0) THEN
        IQUEST(1) = 162
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLTI : No keys'//
     +  ' in directory '//PATH//''')', IARGDB, 0)
+SELF.
        GO TO 999
      ENDIF
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
*
* *** Prepare a temporary storage for useful information
*
      CALL DATIME (IDATX, ITIMX)
      CALL DBPKTS (IDATX, ITIMX*100, ITNOW)
      NPLM   = NPLMDP
      IF (IOPTP.EQ.0) THEN
        IF (NKEYDK.LT.NPLM) NPLM = NKEYDK
      ENDIF
      ND     = 3 * NPLM
      IF (LAUXDL(10).NE.0) CALL MZDROP (IDISDB, LAUXDL(10), 'L')
      CALL DBBOOK (IDISDB, LAUXDL(10), LAUXDL(10), 2, 'TEMP', 0, 0, ND,
     +             2, -1)
      IF (IQUEST(1).NE.0)                                    GO TO 999
*
* *** Load useful data in the temporary bank
*
      IMIN   = ITNOW
      IMAX   = -1
      NPL    = 0
      IKMAX  = 0
      IF (IOPTP.EQ.0) THEN
        DO 15 JK = 1, NKEYDK
          IK     = NKEYDK + 1 - JK
          CALL DBKEYR (IK, NWKYDK, KEYVDK)
          IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB))
     +                                                       GO TO 15
          IF (KEYVDK(MBVRDB).GT.ITNOW)                       GO TO 15
          IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB))
     +                                                       GO TO 15
          IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))
     +                                                       GO TO 15
          IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))
     +                                                       GO TO 15
          IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)      GO TO 15
          IF (NWKYDK.GT.NSYSDK) THEN
            DO 10 I = NSYSDK+1, NWKYDK
              IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I))   GO TO 15
   10       CONTINUE
          ENDIF
          NPL    = NPL + 1
          IF (NPL.LE.NPLM) THEN
            IPNT   = KOFUDB + LAUXDL(10) + (NPL - 1) * 3
            IQ(IPNT+1) = KEYVDK(MSERDB)
            IQ(IPNT+2) = KEYVDK(MBVRDB)
            IQ(IPNT+3) = KEYVDK(MEVRDB)
            IF (KEYVDK(MEVRDB).GT.IMAX)  IMAX  = KEYVDK(MEVRDB)
            IF (KEYVDK(MBVRDB).LT.IMIN)  IMIN  = KEYVDK(MBVRDB)
            IF (IKMAX.LT.KEYVDK(MSERDB)) IKMAX = KEYVDK(MSERDB)
          ENDIF
   15   CONTINUE
*
      ELSE
        KST    = NWKYDK + 1
        NKEYS  = NKEYDK
        NCHR   = INDEX (PATH, ' ') - 1
        IF (NCHR.LT.1) NCHR = MAXLDB
        DO 30 JKK = 1, NKEYS
          IKK    = NKEYS + 1 - JKK
          KPNT   = IUHUNT (IKK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                     NKEYS*KST, KST)
          IF (KPNT.GT.0) THEN
            KPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB
          ELSE
            KPNT   = KOFSDB + LCDRDB + IKDRDB + (IKK - 1) * KST
          ENDIF
          IF (IOKYDA(MBVRDB).NE.0.AND.IQ(KPNT+MEVRDB).LT.KEYS(MBVRDB))
     +                                                       GO TO 30
          IF (IQ(KPNT+MBVRDB).GT.ITNOW)                      GO TO 30
          IF (IOKYDA(MEVRDB).NE.0.AND.IQ(KPNT+MBVRDB).GT.KEYS(MEVRDB))
     +                                                       GO TO 30
          IF (IOKYDA(MITMDB).NE.0.AND.IQ(KPNT+MITMDB).GT.KEYS(MITMDB))
     +                                                       GO TO 30
          IF (KY7MDB.GT.0.AND.IQ(KPNT+MITMDB).GT.KY7MDB)     GO TO 30
*
          CALL DBPATH (PATHX, IKK)
          PATHY  = PATH(1:NCHR)//'/'//PATHX
          CALL RZCDIR (PATHY, ' ')
          IF (IQUEST(1).NE.0) THEN
            CALL MZDROP (IDISDB, LAUXDL(10), ' ')
            IQUEST(1) = 161
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLTI : Ill'//
     +      'egal pathname '//PATHY//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          NKEYDK = IQUEST(7)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          DO 25 JK = 1, NKEYDK
            IK     = NKEYDK + 1 - JK
            CALL DBKEYR (IK, NWKYDK, KEYVDK)
            IF (IOKYDA(MBVRDB).NE.0.AND.KEYVDK(MBVRDB).LT.KEYS(MBVRDB))
     +                                                       GO TO 25
            IF (KEYVDK(MBVRDB).GT.ITNOW)                     GO TO 25
            IF (IOKYDA(MEVRDB).NE.0.AND.KEYVDK(MBVRDB).GT.KEYS(MEVRDB))
     +                                                       GO TO 25
            IF (IOKYDA(MPVSDB).NE.0.AND.KEYVDK(MPVSDB).NE.KEYS(MPVSDB))
     +                                                       GO TO 25
            IF (IOKYDA(MITMDB).NE.0.AND.KEYVDK(MITMDB).GT.KEYS(MITMDB))
     +                                                       GO TO 25
            IF (KY7MDB.GT.0.AND.KEYVDK(MITMDB).GT.KY7MDB)    GO TO 25
            IF (NWKYDK.GT.NSYSDK) THEN
              DO 20 I = NSYSDK+1, NWKYDK
                IF (IOKYDA(I).NE.0.AND.KEYVDK(I).NE.KEYS(I)) GO TO 25
   20         CONTINUE
            ENDIF
            NPL    = NPL + 1
            IF (NPL.LE.NPLM) THEN
              IPNT   = KOFUDB + LAUXDL(10) + (NPL - 1) * 3
              IQ(IPNT+1) = KEYVDK(MSERDB)
              IQ(IPNT+2) = KEYVDK(MBVRDB)
              IQ(IPNT+3) = KEYVDK(MEVRDB)
              IF (KEYVDK(MEVRDB).GT.IMAX)  IMAX  = KEYVDK(MEVRDB)
              IF (KEYVDK(MBVRDB).LT.IMIN)  IMIN  = KEYVDK(MBVRDB)
              IF (IKMAX.LT.KEYVDK(MSERDB)) IKMAX = KEYVDK(MSERDB)
            ENDIF
   25     CONTINUE
          CALL RZCDIR (PATH, ' ')
          IF (IQUEST(1).NE.0) THEN
            CALL MZDROP (IDISDB, LAUXDL(10), ' ')
            IQUEST(1) = 161
+SELF, IF=$DEBUG.
            IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBPLTI : Ill'//
     +      'egal pathname '//PATH//''')', IARGDB, 0)
+SELF.
            GO TO 999
          ENDIF
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          IF (NPL.GT.NPLM)                                   GO TO 35
   30   CONTINUE
*
      ENDIF
*
* *** All points collected; now decide the scale and header
*
   35 IF (NPL.EQ.0) THEN
        CALL MZDROP (IDISDB, LAUXDL(10), ' ')
        GO TO 999
      ENDIF
      IF (NPL.GT.NPLM) THEN
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) THEN
          IARGDB(1) = NPL
          IARGDB(2) = NPLM
          CALL DBPRNT (LPRTDB, '(/,'' DBPLTI : Too many objects '','//
     +         'I6,'' only '',I6,'' shown'')', IARGDB, 2)
        ENDIF
+SELF.
        NPL    = NPLM
      ENDIF
      IF (IMAX.GT.ITNOW) IMAX = ITNOW
      CALL DBUPTS (IDATX, ITIMX, IMIN)
      CALL DBTIME (IDATX, ITIMX)
      IBINDP(3) = IDATX/10000 + 1900
      IBINDP(2) = MOD (IDATX/100, 100)
      IBINDP(1) = MOD (IDATX    , 100)
      CALL CALDAT (101, CHRPDP, IBINDP, IRET)
      DYSTDP = CHRPDP(26:34)
      IDAY1  = IBINDP(6)
      CALL DBUPTS (IDATX, ITIMX, IMAX)
      CALL DBTIME (IDATX, ITIMX)
      IBINDP(3) = IDATX/10000 + 1900
      IBINDP(2) = MOD (IDATX/100, 100)
      IBINDP(1) = MOD (IDATX    , 100)
      CALL CALDAT (101, CHRPDP, IBINDP, IRET)
      DYENDP = CHRPDP(26:34)
      IDAY2  = IBINDP(6) - IDAY1 + 1
      TMAX   = 24.0 * IDAY2
+SELF, IF=-IBM, -$P3CHILD.
      WRITE (CTTLDP, 2000) DYSTDP, DYENDP
+SELF, IF=IBM, IF=$P3CHILD.
      CALL UTWRIT (CITLDP, '(''Object Validity Range during '//
     +     DYSTDP(1:9)//' - '//DYENDP(1:9)//''')', IARGDB, 0)
+SELF.
      IF (HEXIST(-101)) CALL HDELET (-101)
      CALL HBOOK1 (-101, CTTLDP, 2, 0., TMAX, 0.)
      CALL HMINIM (-101, 0.)
      CALL HMAXIM (-101, FLOAT(IKMAX)+2.)
      CALL HTITLE (PATH)
      CALL HPLOPT ('HORI', 1)
      CALL HPLOT  (-101, ' ', 'HIST', 0)
*
* *** Now plot the keys
*
      DO 40 JK = 1, NPL
        IPNT   = KOFUDB + LAUXDL(10) + (JK - 1) * 3
        IK     = IQ(IPNT+1)
        CALL DBUPTS (IDATX, ITIMX, IQ(IPNT+2))
        CALL DBTIME (IDATX, ITIMX)
        IBINDP(3) = IDATX/10000 + 1900
        IBINDP(2) = MOD (IDATX/100, 100)
        IBINDP(1) = MOD (IDATX    , 100)
        CALL CALDAT (101, CHRPDP, IBINDP, IRET)
        IDAY   = IBINDP(6) - IDAY1
        NHOUR  = ITIMX / 10000
        NMIN   = MOD (ITIMX/100, 100)
        NSEC   = MOD (ITIMX    , 100)
        HOURS  = NHOUR + FLOAT(NMIN)/60. + FLOAT(NSEC)/3600.
        XU(1)  = HOURS + 24.0 * IDAY
        CALL DBUPTS (IDATX, ITIMX, IQ(IPNT+MBVRDB))
        CALL DBTIME (IDATX, ITIMX)
        IBINDP(3) = IDATX/10000 + 1900
        IBINDP(2) = MOD (IDATX/100, 100)
        IBINDP(1) = MOD (IDATX    , 100)
        CALL CALDAT (101, CHRPDP, IBINDP, IRET)
        IDAY   = IBINDP(6) - IDAY1
        NHOUR  = ITIMX / 10000
        NMIN   = MOD (ITIMX/100, 100)
        NSEC   = MOD (ITIMX    , 100)
        HOURS  = NHOUR + FLOAT(NMIN)/60. + FLOAT(NSEC)/3600.
        XU(2)  = HOURS + 24.0 * IDAY
        IF (XU(2).GT.TMAX) XU(2) = TMAX
        YU(1)  = FLOAT(IK)
        YU(2)  = YU(1)
        CALL HPLINE (XU, YU, 2, ' ')
   40 CONTINUE
*
   50 IF (LAUXDL(10).NE.0) CALL MZDROP (IDISDB, LAUXDL(10), ' ')
      IF (HEXIST(-101)) CALL HDELET (-101)
      IQUEST(1) = 0
+SELF, IF=-IBM, -$P3CHILD.
*
 2000 FORMAT ('Object Validity Range during ',A9,' - ',A9)
+SELF.
*                                                             END DBPLTI
  999 END
+DECK, DBTIME.
      SUBROUTINE DBTIME (IDATX, ITIMX)
*     ================================
*
************************************************************************
*                                                                      *
*        SUBR. DBTIME (*IDATX*, *ITIMX*)                               *
*                                                                      *
*   Checks the date and time for plotting purpose                      *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDATX    Date : 6 Decimal integer : YYMMDD                       *
*     ITIMX    Time : 6 Decimal integer : HHMMSS                       *
*                                                                      *
*   Called by DBPLOB, DBPLOV, DBPLTI                                   *
*                                                                      *
************************************************************************
*
      DIMENSION       IDAYM(12)
      DATA            IDAYM /31, 28, 31, 30, 31, 30,
     +                       31, 31, 30, 31, 30, 31/
*
*     ------------------------------------------------------------------
*
      ISEC = MOD (ITIMX, 100)
      IMIN = MOD (ITIMX/100, 100)
      IHOU = MOD (ITIMX/10000, 100)
*
      IDAY = MOD (IDATX, 100)
      IMON = MOD (IDATX/100, 100)
      IYEA = MOD (IDATX/10000, 100)
*
      IF (ISEC.GT.59) THEN
        ISEC = 59
      ELSE IF (ISEC.LT.0) THEN
        ISEC = 0
      ENDIF
      IF (IMIN.GT.59) THEN
        IMIN = 59
      ELSE IF (IMIN.LT.0) THEN
        IMIN = 0
      ENDIF
      IF (IHOU.GT.23) THEN
        IHOU = 23
      ELSE IF (IHOU.LT.0) THEN
        IHOU = 0
      ENDIF
      IF (IMON.LT.1) THEN
        IMON = 1
      ELSE IF (IMON.GT.12) THEN
        IMON = 12
      ENDIF
      IF (IDAY.LT.1) THEN
        IDAY = 1
      ELSE IF (IDAY.GT.IDAYM(IMON)) THEN
        IDAY = IDAYM(IMON)
      ENDIF
      IDATX = IYEA*10000 + IMON*100 + IDAY
      ITIMX = IHOU*10000 + IMIN*100 + ISEC
*                                                             END DBTIME
      END
+DECK, DBUSIN.
      SUBROUTINE DBUSIN
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBUSIN                                                  *
*                                                                      *
*   Default user routine for action needed in between 2 plots          *
*                                                                      *
*   Called by DBPLOB, DBPLOV                                           *
*                                                                      *
************************************************************************
*
      IWKST  = 1
      CALL IGSA (IWKST)
*                                                             END DBUSIN
      END
+DECK, DBUTIM.
      SUBROUTINE DBUTIM (IDATM, IMINS)
*     ================================
*
************************************************************************
*                                                                      *
*        SUBR. DBUTIM (IDATM, IMINS*)                                  *
*                                                                      *
*   Computes number of minutes passed since midnight of January 1,1980 *
*   from the packed date and time (ala DBPKTM)                         *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDATM    Packed date-time                                        *
*     IMINS*   Number of minutes passed from 00.00 on Jan 1, 1980      *
*                                                                      *
*   Called by DBPLNT                                                   *
*                                                                      *
************************************************************************
*
+CDE, DTMPAK.
*     ------------------------------------------------------------------
*
      III  = IDATM
      IMIN = MOD (III, MXMIN)
      III  = (III-IMIN)/MXMIN
      IHOU = MOD (III, MXHOU)
      III  = (III-IHOU)/MXHOU
      IDAY = MOD (III, MXDAY)
      III  = (III-IDAY)/MXDAY
      IMON = MOD (III, MXMON)
      IYEA = (III-IMON)/MXMON - 80
      IF (IYEA.LT.1) THEN
        IADD = 0
        ITYP = 2
      ELSE IF (IYEA.GT.20) THEN
        IADD = IDAYY(20)
        ITYP = 2
      ELSE
        IADD = IDAYY(IYEA)
        ITYP = MOD (IYEA, 4)
        IF (ITYP.EQ.0) THEN
          ITYP = 2
        ELSE
          ITYP = 1
        ENDIF
      ENDIF
*
      IDAYS = IDAY + IADD + IDAYM(IMON,ITYP)
      IMINS = IMIN + 60*(IHOU + 24*IDAYS)
*                                                             END DBUTIM
      END
+DECK, DBUTIS.
      SUBROUTINE DBUTIS (IDATM, ISECS)
*     ================================
*
************************************************************************
*                                                                      *
*        SUBR. DBUTIS (IDATM, ISECS*)                                  *
*                                                                      *
*   Computes number of seconds passed since midnight of January 1,1980 *
*   from the packed date and time (ala DBPKTS)                         *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDATM    Packed date-time                                        *
*     IMINS*   Number of seconds passed from 00.00 on Jan 1, 1980      *
*                                                                      *
*   Called by DBPLNT                                                   *
*                                                                      *
************************************************************************
*
+CDE, DTMPAK.
*     ------------------------------------------------------------------
*
      III  = IDATM
      ISEC = MOD (III, MXSEC)
      III  = (III-ISEC)/MXSEC
      IMIN = MOD (III, MXMIN)
      III  = (III-IMIN)/MXMIN
      IHOU = MOD (III, MXHOU)
      III  = (III-IHOU)/MXHOU
      IDAY = MOD (III, MXDAY)
      III  = (III-IDAY)/MXDAY
      IMON = MOD (III, MXMON)
      IYEA = (III-IMON)/MXMON
      IF (IYEA.LT.1) THEN
        IADD = 0
        ITYP = 2
      ELSE IF (IYEA.GT.20) THEN
        IADD = IDAYY(20)
        ITYP = 2
      ELSE
        IADD = IDAYY(IYEA)
        ITYP = MOD (IYEA, 4)
        IF (ITYP.EQ.0) THEN
          ITYP = 2
        ELSE
          ITYP = 1
        ENDIF
      ENDIF
*
      IDAYS = IDAY + IADD + IDAYM(IMON,ITYP)
      ISECS = ISEC + 60*(IMIN + 60*(IHOU + 24*IDAYS))
*                                                             END DBUTIS
      END
+PATCH, DBP3, IF=APOLLO,IBM.
+DECK, DBCHLD, IF=$P3CHILD.
+SEQ, T=DUMMY, IF=$P3CHILD.
      SUBROUTINE DBCHLD
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBCHLD                                                  *
*                                                                      *
*   Prepares the interrupt message vector and halts execution          *
*                                                                      *
*   Called by DBABRD, DBABWR, DBDELT, DBEALI, DBEHLP, DBENTB, DBINIT,  *
*             DBNTOP, DBPRGD, DBRENK, DBRHLP, DBKOUT, DBSDIR, DBSNAM,  *
*             DBSPUR                                                   *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, P3DBL3.
*     ------------------------------------------------------------------
*
      IF (RNDBP3.EQ.'DBRZIN  ')  GO TO 100
*
*  ** Encode name of calling routine
*
      CALL UCTOH (RNDBP3, IWDBP3(NWDBP3+1), 4, 8)
      NWDBP3 = NWDBP3 + 2
*
*  ** Interrupt host
*
      CALL APPAUS ('DBCHLD', NWDBP3, IWDBP3)
*
*  ** Extract Host return code
*
      IQDBP3 = IWDBP3(NWDBP3)
      NWDBP3 = NWDBP3 - 1
*
      GO TO 999
*
* *** Called in conjunction with DBRZIN
*
  100 IF (NBKDP3.GT.0) INDXP3 = INDXP3+NBKDP3+21
      IF (INDXP3.LE.1) THEN
        IQDBP3=99
        GO TO 999
      ENDIF
      IQ(KOFUDB+LNK1P3+1) = NDIRP3
*
*  ** Interrupt host
*
      IWDBP3(3) = INDXP3
      CALL UCTOH (RNDBP3, IWDBP3(4), 4, 8)
      NWDBP3 = 5
      CALL APSEND (IQDBP3, 'DBCHLD', NWDBP3, IWDBP3,
     +                          IQ(KOFUDB+LNK1P3+1), INDXP3)
*
      NDIRP3=0
      NBKYP3=0
      NBKDP3=0
      INDXP3=1
      IF (IQDBP3.EQ.0) IQDBP3=IWDBP3(1)
      IF (IQDBP3.NE.0)           GO TO 999
*
*  ** Read the objects now
*
      IF (LNK3P3.NE.0) THEN
        CALL MZDROP (IXDBP3, LNK3P3, 'BVL.')
        LNK3P3 = 0
      ENDIF
      NWDBP3 = 32
      CALL APFZIN (IDDBP3, IXDBP3, LNK3P3, 2, '....', NWDBP3, IWDBP3)
      IQDBP3 = IQUEST(1)
*                                                             END DBCHLD
  999 END
+DECK, DBHOST, IF=-$P3CHILD.
      SUBROUTINE DBHOST (IDTASK, NWUSER, IWUSER)
*     ==========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBHOST (IDTASK,NWUSER,IWUSER)                           *
*                                                                      *
*   Service routine for DBL3 requests from child tasks                 *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDTASK   Child identifier                                        *
*     NWUSER   Number of words in the message vector                   *
*     IWUSER   Message vector                                          *
*                                                                      *
*   Called by <user>                                                   *
*                                                                      *
************************************************************************
*
+CDE, ZUNIT .
+CDE, MQSYS .
+CDE, DAOPTI.
+CDE, DBUSER.
+CDE, P3DBL3.
      COMMON /P3ZEBR/ ZEBRP3(35), IDTZP3
*
      DIMENSION       IWUSER(9)
      DIMENSION       INKEYS(3), IARG(6), MLDBP3(8)
      CHARACTER       CHNAME*8 , OLDDIR*96
*
      DATA            INITDB, INITZ , INITRZ  /0,0,0/
      DATA            INKEYS        /4HEBRA, 4HINIT, 4HDONE/
      DATA            CHNAME        /'ABCDEFGH'/
*
*     ------------------------------------------------------------------
*
      CALL APTBEG (INDXT)
*
*  ** Check that ZEBRA system has been initialized
*
      IF (INITZ.EQ.0) THEN
        DO 2 K=1,3
          IF (MQKEYS(K).NE.INKEYS(K))   GO TO 900
    2   CONTINUE
        IF (NQSTOR.LT.0)                GO TO 902
        LIDBP3 = 0
        LODBP3 = 0
        INITZ  = 1
        CALL P3UNIT (LPRTAP)
      ENDIF
*
*  ** Check that DBL3 system has been initialized
*
      IF (INITDB.EQ.0) THEN
        DO 4 K=1,8
          IF (CALFDA(K).NE.CHNAME(K:K)) GO TO 10
    4   CONTINUE
        INITDB = IDIVDB
      ENDIF
*
*  ** Load the message vector
*
   10 CALL APHTOC (IWUSER(NWUSER-1), RNDBP3, 8)
      IDDBP3 = IDTASK
      NWDBP3 = NWUSER - 2
      CALL UCOPY (IWUSER, IWDBP3, NWDBP3)
      MSDBP3 = ' '
      CALL APHTOC (IWUSER, MSDBP3, 8)
      IQDBP3 = -1
*
      CALL P3LOGQ (LOGLAP)
      IF (LOGLAP.GT.1) CALL DBPRNT (LPRTAP, '(/,'' DBHOST : Invoked '//
     +   'by Task'',I3,'', Routine '//RNDBP3//''')', IDTASK, 1)
*
*  ** Select action to take
*
      IF (RNDBP3.EQ.'DBRZIN') THEN
        ICODE = 7
      ELSE IF (RNDBP3.EQ.'DBABRD') THEN
        ICODE = 3
      ELSE IF (RNDBP3.EQ.'DBABWR') THEN
        ICODE = 4
      ELSE IF (RNDBP3.EQ.'DBEHLP') THEN
        ICODE = 4
      ELSE IF (RNDBP3.EQ.'DBEND ') THEN
        ICODE = 6
      ELSE IF (RNDBP3.EQ.'DBINIT') THEN
        ICODE = 1
      ELSE IF (RNDBP3.EQ.'DBRHLP') THEN
        ICODE = 3
      ELSE IF (RNDBP3.EQ.'DBSNAM') THEN
        IF (MSDBP3.EQ.'JOURNAL') THEN
          ICODE = 2
        ELSE
          ICODE = 5
        ENDIF
      ELSE IF (MSDBP3.EQ.'JOURNAL') THEN
        ICODE = 2
      ELSE
        GO TO 910
      ENDIF
*
      GO TO (100,200,300,400,500,600,100), ICODE
*
*  ** DBINIT : open Database file in update mode
*
  100 IF (INITDB.NE.0)                  GO TO 150
*
*  ** Database not initialized: look for largest store
*
      IBIG   = 0
      MYSTOR = -1
      DO 120 JQ=0,NQSTOR
        KQ    = NQOFFT(JQ+1)
        ISIZE = LQSTA(KQ+21) - LQSTA(KQ+1)
        IF (ISIZE.GT.IBIG) THEN
          IBIG   = ISIZE
          MYSTOR = JQ
        ENDIF
  120 CONTINUE
*
*  ** Create a division in the largest store
*
      MYSTOR = ISHFT (MYSTOR, 26)
      CALL MZDIV (MYSTOR, INITDB, 'APDBL3', 5000, 16384, 'PR')
*
*  ** O.K., we can go now
*
  150 IF (ICODE .EQ.7)                  GO TO 700
*
      IF (NWDBP3.LT.8)                  GO TO 920
      LUN    = IWDBP3(1)
      MSDBP3 = ' '
      CALL APHTOC (IWDBP3(2), MSDBP3, 16)
      NRECS  = IWDBP3(6)
      CALL APHTOC (IWDBP3(7), MSDBP3(17:24), 8)
      IF (LOGLAP.GT.-1) THEN
        IF (LOGLAP.LT.2)
     +   CALL DBPRNT (LPRTAP, '(/,'' DBHOST : Invoked '//
     +   'by Task'',I3,'', Routine '//RNDBP3//''')', IDTASK, 1)
        IARG(1) = LUN
        IARG(2) = NRECS
        CALL DBPRNT (LPRTAP, '(''            Initialize directory '//
     +       MSDBP3(1:16)//' on unit'',I3,'', options '//MSDBP3(17:24)//
     +       ', record length'',I6)', IARG, 2)
      ENDIF
      CALL DBINIT (INITDB, LUN, MSDBP3(1:16), LTOP, NRECS,MSDBP3(17:24))
      IQDBP3 = IQUEST(1)
      IF (IQDBP3.EQ.-2) IQDBP3 = 0
      IF (LIDBP3.EQ. 0) CALL APOPCH (LIDBP3, 0, IQDBP3)
      NWDBP3 = 0
      CALL DBLOGL (LUN, LOGLAP)
      GO TO 800
*
*  ** "Journal file": update database
*
  200 IF (INITDB.EQ.0)                  GO TO 930
      IF (LOGLAP.GT.1) CALL DBPRNT (LPRTAP, '(''            Update '//
     +   'Database'')', IARG, 0)
      IF (LIDBP3.EQ.0) CALL APOPCH (LIDBP3, 0, IQDBP3)
      IQDBP3 = 0
      NWDBP3 = 0
      GO TO 800
*
*  ** Update Database by reading journal file
*
  250 IDTZP3 = IDDBP3
      CALL DBFZUP (LIDBP3,'S')
      GO TO 999
*
*  ** DBABRD,DBRHLP: copy text onto external file from a bank
*
  300 LUN    = IWDBP3(1)
      NDATA  = IWDBP3(2)
      IQDBP3 = 0
      IF (LIDBP3.EQ.0) CALL APOPCH (LIDBP3, 0, IQDBP3)
      NWDBP3 = 0
      GO TO 800
*
  350 CALL APFZIN (IDDBP3,JQPDVL,LBANK,2,'A',0,0)
      IF (IQUEST(1).NE.0)               GO TO 999
      NDATA = IQ(KQS+LBANK-1)
      IF (NDATA.LE.0)                   GO TO 999
      NTOT  = 0
  360 IF (NTOT.LT.NDATA) THEN
        CALL DBLIND (IQ(KQS+LBANK+1), NTOT, MSDBP3, LENG)
        IF (LENG.GT.0) THEN
          WRITE (LUN,'(A)') MSDBP3(1:LENG)
        ELSE
          WRITE (LUN,*)
        ENDIF
        GO TO 360
      ENDIF
      CALL MZDROP (JQPDVL, LBANK, 'L')
      GO TO 999
*
*  ** DBABWR,DBEHLP: copy text from external file into a bank
*
  400 LUN   = IWDBP3(1)
      NDATA = NDMXDB
      CALL UCTOH  ('APDB', ITEMP3, 4, 4)
      CALL MZBOOK (JQPDVL, LBANK , 0, 2, ITEMP3, 0, 0, NDATA, 1, -1)
      NDAT  = 0
  410 READ (LUN, '(A80)', ERR=420, END=420) MSDBP3
      LENG  = LENOCC (MSDBP3)
      CALL DBLINC (MSDBP3, LENG, IQ(KQS+LBANK+1), NDAT)
      IF (NDAT.GT.NDATA-20) THEN
        IQDBP3 = -1
        GO TO 800
      ENDIF
      GO TO 410
  420 NDP   = NDAT - NDATA
      IF (NDP.LT.0) CALL MZPUSH (JQPDVL, LBANK, 0, NDP, 'I')
      IQDBP3 = 0
      NWDBP3 = 1
      IWDBP3(1) = NDAT
      IF (LODBP3.EQ.0) CALL APOPCH (LODBP3, 1, IQDBP3)
      LBANK = LZFIDH (JQPDVL, ITEMP3, 0)
      GO TO 800
*
  450 CALL APFZUT (IDDBP3, JQPDVL, LBANK, 1, 'S', 1, 0, 0)
      CALL MZDROP (JQPDVL, LBANK, '    ')
      GO TO 999
*
*  ** DBSNAM: copy bank from external file
*
  500 LUN    = IWDBP3(1)
      IF (LODBP3.EQ.0) CALL APOPCH (LODBP3, 1, IQDBP3)
      CALL FZIN (LUN, JQPDVL, LBANK, 2, 'A', 0, 0)
      IQDBP3 = IQUEST(1)
      NWDBP3 = 0
      GO TO 800
*
*  ** DBEND : ready for future applications
*
  600 IQDBP3 = 0
      NWDBP3 = 0
      GO TO 800
  650 CONTINUE
      GO TO 999
*
*  ** DBRZIN: retrieve set of data objects
*
  700 IF (INITRZ.EQ.0) THEN
        INITRZ = 1
        IXSTP3 = ISHFT(INITDB,-26)
        IXDBP3 = ISHFT(IXSTP3, 26) +  2
        IXSYP3 = ISHFT(IXSTP3, 26) + 24
        CALL MZLINK (IXDBP3, '/P3DBL3/', LNK1P3, LNK1P3, LNK9P3)
        CALL UCTOH  ('DBRZ', MLDBP3(1), 4, 4)
        MLDBP3(2) = 0
        MLDBP3(3) = 0
        MLDBP3(4) = 5
        CALL MZIOBK (MLDBP3, 8, '2I 1B 2F')
        CALL MZBOOK (IXSYP3, LNK1P3, 0, 2, 'DBP3', 0, 0, 122, 2, 0)
        NBDBP3 = 122
        KQSP3  = KQS
      ENDIF
*       Receive list of requests
      INDXP3 = IWDBP3(3)
      NWDBP3 = 0
      CHNAME = MSDBP3
      IF (LOGLAP.GT.1) CALL DBPRNT (LPRTAP, '(/,''           Called '//
     +   'by '//CHNAME//' with'',I6,'' data words'')', INDXP3, 1)
      IF (INDXP3.GT.NBDBP3) THEN
        INC = INDXP3-NBDBP3
        CALL MZNEED (IXSYP3, INC, 'G...')
        IF (IQUEST(11).LT.0) THEN
          IQDBP3 = 11
          GO TO 790
        ENDIF
        CALL MZPUSH (IXSYP3, LNK1P3, 0, INC, 'I...')
        NBDBP3 = INDXP3
      ENDIF
*
      CALL P3RECV (IDDBP3, IQ(KQSP3+LNK1P3+1), NW, NBDBP3, IQDBP3)
*
      IF (IQDBP3.EQ.0.AND.NW.LT.INDXP3) THEN
        IQDBP3 = 12
        GO TO 790
      ENDIF
*       Nb. of directories
      NDIRP3 = IQ(KQSP3+LNK1P3+1)
*       Prepare banks
      IF (LNK2P3.NE.0) CALL MZDROP (IXDBP3, LNK2P3, 'L...')
      CALL MZBOOK (IXDBP3, LNK2P3, 0, 2, 'DBP3', 2, 2, 0, 2, 0)
*       Retrieve objects
      NBRETR = 0
      INDXP3 = 1
      CALL RZCDIR (OLDDIR, 'R...')
*
      DO 740 NDIR = 1, NDIRP3
* Set directory
        CALL ZITOH  (IQ(KQSP3+LNK1P3+INDXP3+2), IWDBP3, 20)
        CALL UHTOC  (IWDBP3, 4, MSDBP3, 80)
        CALL RZCDIR (MSDBP3,'....')
        IF (IQUEST(1).NE.0) THEN
          IQDBP3 = 13
          GO TO 790
        ENDIF
* Nb. of keys
        NBKDP3 = IQ(KQSP3+LNK1P3+INDXP3+1)
* Read data banks
        INDXP3 = INDXP3+21
        DO 730 NBK = 1, NBKDP3
          INDXP3 = INDXP3+1
          ICUR = IQ(KQSP3+LNK1P3+INDXP3)
          IF (NBRETR.EQ.0) THEN
            LNK9P3 = LNK2P3
            JBP3 = -1
          ELSE
            LNK9P3 = LNK3P3
            JBP3 =  0
          ENDIF
          LBANK = LNK9P3
          CALL RZIN (IXDBP3, LBANK, JBP3, ICUR, 999999, 'S...')
          IF (IQUEST(1).NE.0) THEN
            IQDBP3 = 14
            GO TO 790
          ENDIF
          LNK3P3 = LQ(KQSP3+LNK9P3+JBP3)
          LNK9P3 = 0
* Save first words in a special bank (unpacking,backwards compatib.)
          CALL MZNEED (IXDBP3, 20, 'G...')
          IF (IQUEST(11).LT.0) THEN
            IQDBP3 = 15
            GO TO 790
          ENDIF
          IF (NBRETR.EQ.0) THEN
            CALL MZLIFT (IXDBP3, LNK4P3, LNK2P3,-2, MLDBP3, 0)
          ELSE
            CALL MZLIFT (IXDBP3, LBANK,  LNK4P3, 0, MLDBP3, 0)
            LNK4P3 = LBANK
          ENDIF
          DO 725 I = 1, 2
            IQ(KQSP3+LNK4P3+I  ) = IQ(KQSP3+LNK3P3+I)
             Q(KQSP3+LNK4P3+I+3) =  Q(KQSP3+LNK3P3+I)
  725     CONTINUE
          IQ(KQSP3+LNK4P3+3) = IQ(KQSP3+LNK3P3+3)
*
          NBRETR = NBRETR+1
  730   CONTINUE
*
        IF (LOGLAP.GT.1) CALL DBPRNT (LPRTAP, '(I10,'' Data objects '//
     +   'retrieved from '//MSDBP3//' '')', NBKDP3, 1)
*
  740 CONTINUE
      IF (LOGLAP.GT.1) CALL DBPRNT (LPRTAP, '(I10,'' Data objects '//
     +   'retrieved'')', NBRETR, 1)
      IQDBP3=0
*       Reset directory
      CALL RZCDIR (OLDDIR, '....')
      GO TO 800
*
* ** Transfer objects to child
*
  750 CALL APFZUT (IDDBP3, IXDBP3, LNK2P3, 1, '....', 2, 0, IWDBP3)
      CALL MZDROP (IXDBP3, LNK2P3, '....')
      CALL MZGARB (IXDBP3, 0)
      CALL MZDRED (IXDBP3)
      GO TO 999
*
* ** Errors
*
  790 IF (LOGLAP.LT.1)                  GO TO 800
      IF (LOGLAP.LT.2) THEN
        CALL DBPRNT (LPRTAP, '(/,'' DBHOST : Invoked '//
     +   'by Task'',I3,'', Routine '//RNDBP3//''')', IDTASK, 1)
        CALL DBPRNT (LPRTAP, '(/,''           Called '//
     +   'by '//CHNAME//' with'',I6,'' data words'')', INDXP3, 1)
      ENDIF
*
      GO TO (791,792,793,794,795), IQDBP3-10
*
  791 CALL DBPRNT (LPRTAP,
     +  '('' ******   Error : No more space available in system '//
     +     'division to store list of requests'')', IARG, 0)
      GO TO 800
*
  792 IARG(1) = INDXP3
      IARG(2) = NW
      CALL DBPRNT (LPRTAP,
     +  '('' ******   Error in P3RECV:'',I6,'' Words expected,'',
     +     I6,'' Words received'')', IARG, 2)
      GO TO 800
*
  793 CALL DBPRNT (LPRTAP,
     +  '('' ******   Error : Unknow directory '//MSDBP3//' '')',
     +     IARG, 0)
      GO TO 800
*
  794 IARG(1) = IQUEST(1)
      IARG(2) = ICUR
      CALL DBPRNT (LPRTAP,
     +  '('' ******   RZIN Error'',I6,'' for Key'',I5,'' in'//
     +     MSDBP3//' '')', IARG, 2)
      GO TO 800
*
  795 CALL DBPRNT (LPRTAP,
     +  '('' ******   Error : No more space available in user '//
     +     'division to store auxiliary data'')', IARG, 0)
      GO TO 800
*
*  ** Restart child task
*
  800 NWDBP3 = NWDBP3+1
      IWDBP3(NWDBP3) = IQDBP3
      CALL APCONT (IDDBP3, IRET, NWDBP3, IWDBP3)
      IF (IQDBP3.NE.0.OR.IRET.NE.0)     GO TO 999
*
      GO TO (999,250,350,450,450,650,750), ICODE
*
*  ** Errors
*
  900 CALL DBPRNT (6, '(/,'' DBHOST : ZEBRA system not initialized'')',
     +     IARG, 0)
      GO TO 990
  902 CALL DBPRNT (IQPRNT, '(/,'' DBHOST : no ZEBRA store was initial'//
     +     'ized'')', IARG, 0)
      GO TO 990
  910 CALL DBPRNT (IQPRNT, '(/,'' DBHOST : Unknown request '//RNDBP3//
     +     ''')', IARG, 0)
      GO TO 990
  920 CALL DBPRNT (IQPRNT, '(/,''  DBHOST : not enough message words '//
     +     'received ('',I2,'') -- 8 expected'')', NWDBP3, 1)
      GO TO 990
  930 CALL DBPRNT (IQPRNT, '(/,'' DBHOST : DBL3 not initialized yet'')',
     +     IARG, 0)
*
  990 IQDBP3 = -1
      NWDBP3 = 0
      GO TO 800
*                                                             END DBHOST
  999 CALL APTEND (INDXT,'DBHOST',IDTASK)
      END
+PATCH, DBXINT.
+DECK, DBACPL.
      SUBROUTINE DBACPL
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBACPL                                                  *
*                                                                      *
*   Action Routines for menu /DBL3/PLOT                                *
*                                                                      *
*   Allowed Actions :                                                  *
*                                                                      *
*     DBHELP, DBPLOB, DBPLOT, DBPLOV, DBPLTI, DBREAD, DBTREE           *
*                                                                      *
*   Called by KUIP routine                                             *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DDISPL.
+CDE, DKKEYS.
+CDE, DPLOTS.
+CDE, DXLINK.
      PARAMETER       (L3WKST=1)
      DIMENSION       KEYS(100), KOBJ2(2,NOBMDP), KOBJ1(NOBMDP)
      CHARACTER       CPATL*32, CHOPT*32, PATHN*80
      CHARACTER       TOPN*16, PATH*80, CFNAM*80, ALIAS*8, CHTAG*8
      DATA            PATHN /' '/, ALIAS /' '/, CHTAG /' '/
*
*     ------------------------------------------------------------------
*
      CALL KUPATL (CPATL, NPAR)
*
      IF (CPATL.EQ.'DBHELP') THEN
*
*  **   DBHELP
*
        TOPN   = '*'
        CALL KUGETC (TOPN, NCH)
        IF (LTOPDB.NE.0) THEN
          IF (TOPN(1:1).EQ.'*') THEN
            NCHR   = IQ(KOFUDB+LTOPDB+MUPNCH)
            CALL UHTOC (IQ(KOFUDB+LTOPDB+MUPNAM), 4, TOPN, NCHR)
            TOPN   = TOPN(1:NCHR)
          ENDIF
          PATHN  = '//'//TOPN
          CALL DBFPAT (PATHN, 20, LFRSDX)
          IF (IQUEST(1).EQ.0.AND.LFRSDX.NE.0) THEN
            CALL IGSG (L3WKST)
            CALL ICLRWK (1, 1)
            CALL DBPLBK (LFRSDX)
            CALL IRQLC (1, 1, IST, NT, X, Y)
            CALL IGSA (L3WKST)
            IF (IST.NE.0) THEN
              CALL DBLOOK (LFRSDX, X, Y, PATH)
              CALL MZDROP (IDIVDB, LFRSDX, ' ')
              LFRSDX = 0
              IF (PATH(1:1).NE.' ') THEN
                CALL KUGETC (CFNAM, NCF)
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
                CALL CUTOL  (CFNAM)
+SELF.
                CALL DBOPEN (LUKYDX, CFNAM, 'UNKNOWN', ISTAT)
                IF (ISTAT.NE.0) THEN
                  CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error '',I12'//
     +                 ','' in opening file '//CFNAM(1:NCF)//''')',
     +                 ISTAT, 1)
                  GO TO 999
                ENDIF
                CALL DBRHLP (PATH, LUKYDX)
                IERR = IQUEST(1)
                IF (IERR.NE.0) CALL DBPRNT (LUKYDX, '(/,'' DBACPL : '//
     +          'Error '',I12,'' in getting help info. for '',/,'' '//
     +          PATH(1:72)//''')', IERR, 1)
                CALL DBCLOS (LUKYDX)
                CALL KUEDIT (CFNAM, IST)
              ELSE
                CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Cursor does not '//
     +               'point to any valid path'')', IARGDB, 0)
              ENDIF
            ELSE
              CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error '',I12,'' in'//
     +             ' picking operation'')', IST, 1)
            ENDIF
          ELSE
            CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error '',I12,'' in '//
     +           'finding the tree for '//TOPN//''')', IQUEST(1), 1)
          ENDIF
          IF (LFRSDX.NE.0) THEN
            CALL MZDROP (IDIVDB, LFRSDX, ' ')
            LFRSDX = 0
          ENDIF
        ENDIF
*
      ELSE IF (CPATL.EQ.'DBPLOB') THEN
*
*  **   DBPLOB
*
        CALL KUGETC (PATHN, NCH)
        CALL KUGETI (NOBJ)
        IF (NOBJ.LT.1) THEN
          NOBJ = 1
        ELSE IF (NOBJ.GT.NOBMDP) THEN
          NOBJ = NOBMDP
        ENDIF
        CALL KUGETI (KEX)
        CALL KUGETI (NST)
        CALL KUGETC (CHOPT, NCH)
        CALL DBOPTS (CHOPT)
        IF (IQUEST(1).NE.0) THEN
          CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error in decoding CHOP'//
     +         'T '//CHOPT(1:NCH)//''')', IARGDB, 0)
          GO TO 999
        ENDIF
        CALL VZERO (KEYS, 100)
        CALL DBRVPL (1, NOBJ, KOBJ1, KOBJ2, KEYS)
        IF (IQUEST(1).NE.0) GO TO 999
        CALL IGSG (L3WKST)
        CALL DBPLOB (PATHN, KEYS, NOBJ, KOBJ1, KEX, NST, CHOPT)
        IF (IQUEST(1).NE.0) CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Erro'//
     +  'r '',I12,'' in routine DBPLOB'')', IQUEST(1), 1)
        CALL IGSA (L3WKST)
*
      ELSE IF (CPATL(1:6).EQ.'DBPLOT') THEN
*
*  **   DBPLOT
*
        CALL KUGETC (ALIAS, NCH)
        CALL DBRALI (ALIAS, PATHN)
        IF (IQUEST(1).NE.0) THEN
          CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error in the alias nam'//
     +         'e '//ALIAS//''')', IARGDB, 0)
          GO TO 999
        ENDIF
        CALL KUGETC (CHTAG, NCH)
        CALL DBGNAM (PATHN, CHTAG, IOBJ)
        IF (IQUEST(1).NE.0.OR.IOBJ.EQ.0) THEN
          CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error in the object '//
     +         'name '//CHTAG//''')', IARGDB, 0)
          GO TO 999
        ENDIF
        CALL KUGETC (CHOPT, NCH)
        CALL DBOPTS (CHOPT)
        IF (IQUEST(1).NE.0) THEN
          CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error in decoding CHOP'//
     +         'T '//CHOPT(1:NCH)//''')', IARGDB, 0)
          GO TO 999
        ENDIF
        CALL VZERO (KEYS, 100)
        CALL DBRVPL (0, NOBJ, KOBJ1, KOBJ2, KEYS)
        IF (IQUEST(1).NE.0) GO TO 999
        NOBJ   = 1
        KEX    = 3
        NST    = 1
        CALL IGSG (L3WKST)
        CALL DBPLOB (PATHN, KEYS, NOBJ, IOBJ, KEX, NST, CHOPT)
        IF (IQUEST(1).NE.0) CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Erro'//
     +  'r '',I12,'' in routine DBPLOB'')', IQUEST(1), 1)
        CALL IGSA (L3WKST)
*
      ELSE IF (CPATL.EQ.'DBPLOV') THEN
*
*  **   DBPLOV
*
        CALL KUGETC (PATHN, NCH)
        CALL KUGETI (NOBJ)
        IF (NOBJ.LT.1) THEN
          NOBJ = 1
        ELSE IF (NOBJ.GT.NOBMDP) THEN
          NOBJ = NOBMDP
        ENDIF
        CALL KUGETI (NST)
        CALL KUGETC (CHOPT, NCH)
        CALL DBOPTS (CHOPT)
        IF (IQUEST(1).NE.0) THEN
          CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error in decoding CHOP'//
     +         'T '//CHOPT(1:NCH)//''')', IARGDB, 0)
          GO TO 999
        ENDIF
        CALL VZERO (KEYS, 100)
        CALL DBRVPL (2, NOBJ, KOBJ1, KOBJ2, KEYS)
        IF (IQUEST(1).NE.0) GO TO 999
        CALL IGSG (L3WKST)
        CALL DBPLOV (PATHN, KEYS, NOBJ, KOBJ2, NST, CHOPT)
        IF (IQUEST(1).NE.0) CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Erro'//
     +  'r '',I12,'' in routine DBPLOV'')', IQUEST(1), 1)
        CALL IGSA (L3WKST)
*
      ELSE IF (CPATL.EQ.'DBPLTI') THEN
*
*  **   DBPLTI
*
        CALL KUGETC (PATHN, NCH)
        CALL KUGETC (CHOPT, NCH)
        CALL DBOPTS (CHOPT)
        IF (IQUEST(1).NE.0) THEN
          CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error in decoding CHOP'//
     +         'T '//CHOPT(1:NCH)//''')', IARGDB, 0)
          GO TO 999
        ENDIF
        CALL VZERO (KEYS, 100)
        CALL DBRVPL (0, NOBJ, KOBJ1, KOBJ2, KEYS)
        IF (IQUEST(1).NE.0) GO TO 999
        CALL IGSG (L3WKST)
        CALL DBPLTI (PATHN, KEYS, CHOPT)
        IF (IQUEST(1).NE.0) CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Erro'//
     +  'r '',I12,'' in routine DBPLTI'')', IQUEST(1), 1)
        CALL IGSA (L3WKST)
*
      ELSE IF (CPATL.EQ.'DBREAD') THEN
*
*  **   DBREAD
*
        TOPN   = '*'
        CALL KUGETC (TOPN, NCH)
        IF (LTOPDB.NE.0) THEN
          IF (TOPN(1:1).EQ.'*') THEN
            NCHR   = IQ(KOFUDB+LTOPDB+MUPNCH)
            CALL UHTOC (IQ(KOFUDB+LTOPDB+MUPNAM), 4, TOPN, NCHR)
            TOPN   = TOPN(1:NCHR)
          ENDIF
          PATHN  = '//'//TOPN
          CALL DBFPAT (PATHN, 20, LFRSDX)
          IF (IQUEST(1).EQ.0.AND.LFRSDX.NE.0) THEN
            CALL IGSG (L3WKST)
            CALL ICLRWK (1, 1)
            CALL DBPLBK (LFRSDX)
            CALL IRQLC (1, 1, IST, NT, X, Y)
            CALL IGSA (L3WKST)
            IF (IST.NE.0) THEN
              CALL DBLOOK (LFRSDX, X, Y, PATH)
              CALL MZDROP (IDIVDB, LFRSDX, ' ')
              LFRSDX = 0
              IF (PATH(1:1).NE.' ') THEN
                CALL KUGETC (CFNAM, NCF)
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
                CALL CUTOL  (CFNAM)
+SELF.
                CALL DBOPEN (LUKYDX, CFNAM, 'UNKNOWN', ISTAT)
                IF (ISTAT.NE.0) THEN
                  CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error '',I12'//
     +                 ','' in opening file '//CFNAM(1:NCF)//''')',
     +                 ISTAT, 1)
                  GO TO 999
                ENDIF
                CALL KUGETC (CHOPT, NCH)
                CALL UOPTC (CHOPT, 'H', IOPHDD)
                CALL DBPEEK (CFNAM, NCF, PATH)
              ELSE
                CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Cursor does not '//
     +               'point to any valid path'')', IARGDB, 0)
              ENDIF
            ELSE
              CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error '',I12,'' in'//
     +             ' picking operation'')', IST, 1)
            ENDIF
          ELSE
            CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error '',I12,'' in '//
     +           'finding the tree for '//TOPN//''')', IQUEST(1), 1)
          ENDIF
          IF (LFRSDX.NE.0) THEN
            CALL MZDROP (IDIVDB, LFRSDX, ' ')
            LFRSDX = 0
          ENDIF
        ENDIF
*
      ELSE IF (CPATL.EQ.'DBTREE') THEN
*
*  **   DBTREE
*
        TOPN   = '*'
        CALL KUGETC (TOPN, NCH)
        IF (LTOPDB.NE.0) THEN
          IF (TOPN(1:1).EQ.'*') THEN
            NCHR   = IQ(KOFUDB+LTOPDB+MUPNCH)
            CALL UHTOC (IQ(KOFUDB+LTOPDB+MUPNAM), 4, TOPN, NCHR)
            TOPN   = TOPN(1:NCHR)
          ENDIF
          PATHN  = '//'//TOPN
          CALL DBFPAT (PATHN, 20, LFRSDX)
          IF (IQUEST(1).EQ.0.AND.LFRSDX.NE.0) THEN
            CALL IGSG (L3WKST)
            CALL ICLRWK (1, 1)
            CALL DBPLBK (LFRSDX)
            CALL IGSA (L3WKST)
          ELSE
            CALL DBPRNT (L3PRDX, '(/,'' DBACPL : Error '',I12,'' in '//
     +           'finding the tree for '//TOPN//''')', IQUEST(1), 1)
          ENDIF
          IF (LFRSDX.NE.0) THEN
            CALL MZDROP (IDIVDB, LFRSDX, ' ')
            LFRSDX = 0
          ENDIF
        ENDIF
*
      ENDIF
*                                                             END DBACPL
  999 END
+DECK, DBACTI.
      SUBROUTINE DBACTI
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBACTI                                                  *
*                                                                      *
*   Action Routines for menu /DBL3/INITCLOSE                           *
*                                                                      *
*   Allowed Actions :                                                  *
*                                                                      *
*     DBCRDR, DBDELT, DBEFOR, DBENFL, DBEND,  DBFZOP, DBFZUP, DBILDF,  *
*     DBILDU, DBINIT, DBLOGL, DBNTOP, DBOPEN, DBSAVE, DBSETD           *
*                                                                      *
*   Called by KUIP routine                                             *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DDISPL.
+CDE, DINITL.
+CDE, DXLINK.
      PARAMETER       (MXLUN=10)
      CHARACTER       CPATL*32, CHOPT*32, TOPNM*32, PATHN*80, CHOP*32
      CHARACTER       PATHI*80, CFNAM*80
      DIMENSION       LUNRZ(MXLUN)
      DATA            PATHN /' '/, TOPNM /' '/, CFNAM /' '/, PATHI /' '/
      DATA            IDATE /800101/, ITIME /0/, LUNF /0/, LUNI /0/
*
*     ------------------------------------------------------------------
*
      CALL KUPATL (CPATL, NPAR)
*
      IF (CPATL.EQ.'DBCRDR') THEN
*
*  **   DBCRDR
*
        CALL KUGETC (PATHN, NCH)
        CALL DBCRDR (PATHN)
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : Create directory for '//
     +       PATHN(1:NCH)//''',/,''          return code '',I12)',
     +       IQUEST(1), 1)
*
      ELSE IF (CPATL.EQ.'DBDELT') THEN
*
*  **   DBDELT
*
        CALL KUGETC (PATHN, NCH)
        CALL DBDELT (PATHN, ' ')
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : Delete the directory tre'//
     +       'e '//PATHN(1:NCH)//''',/,''          return code '',I12)',
     +       IQUEST(1), 1)
*
      ELSE IF (CPATL.EQ.'DBEFOR') THEN
*
*  **   DBEFOR
*
        CALL KUGETC (TOPNM, NCH)
        CALL KUGETI (IDATE)
        CALL KUGETI (ITIME)
        CALL DBEFOR (TOPNM, IDATE, ITIME)
        IARGDB(1) = IDATE
        IARGDB(2) = ITIME
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : Retrieve data for '//
     +       TOPNM(1:NCH)//' before '',2I8)', IARGDB, 2)
*
      ELSE IF (CPATL.EQ.'DBENFL') THEN
*
*  **   DBENFL
*
        CALL KUGETC (TOPNM, NCH)
        NLUNS  = 0
        LTOP   = LTOPDB
    5   IF (LTOP.GT.0) THEN
          NCHR   = IQ(KOFUDB+LTOP+MUPNCH)
          CALL UHTOC (IQ(KOFUDB+LTOP+MUPNAM), 4, TOPNDI, NCHR)
          TOPNDI = TOPNDI(1:NCHR)
          IF (TOPNDI.EQ.TOPNM) THEN
            NLUNS  = NLUNS + 1
            LUNRZ(NLUNS) = IQ(KOFUDB+LTOP+MUPLUN)
            GO TO 10
          ELSE
            LTOP   = LQ(KOFUDB+LTOP)
            GO TO 5
          ENDIF
        ENDIF
   10   CALL DBENDF (TOPNM)
        IF (NLUNS.GT.0) THEN
          DO 15 ILUN = 1, NLUNS
            CALL DBCLOS (LUNRZ(ILUN))
   15     CONTINUE
        ENDIF
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : Close data base file for'//
     +       ' '//TOPNM//''')', IARGDB, 0)
*
      ELSE IF (CPATL.EQ.'DBEND') THEN
*
*  **   DBEND
*
        NLUNS  = 0
        LTOP   = LTOPDB
   20   IF (LTOP.GT.0.AND.NLUNS.LT.MXLUN) THEN
          NLUNS  = NLUNS + 1
          LUNRZ(NLUNS) = IQ(KOFUDB+LTOP+MUPLUN)
          LTOP   = LQ(KOFUDB+LTOP)
          GO TO 20
        ENDIF
        CALL DBEND
        IF (NLUNS.GT.0) THEN
          DO 25 ILUN = 1, NLUNS
            CALL DBCLOS (LUNRZ(ILUN))
   25     CONTINUE
        ENDIF
*
      ELSE IF (CPATL.EQ.'DBFZOP') THEN
*
*  **   DBFZOP
*
        CALL KUGETC (TOPNM, NCH)
        CALL KUGETI (LUNF)
        CALL KUGETC (CHOPT, NCH)
        CALL DBFZOP (LUNF, TOPNM, CHOPT)
        IARGDB(1) = LUNF
        IARGDB(2) = IQUEST(1)
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : Open Journal file '',I4'//
     +       ','' for '//TOPNM(1:10)//CHOPT(1:2)//''',/,''          '//
     +       'return code '',I12)', IARGDB, 2)
*
      ELSE IF (CPATL.EQ.'DBFZUP') THEN
*
*  **   DBFZUP
*
        CALL KUGETI (LUNF)
        CALL KUGETC (CHOPT, NCH)
        CALL DBFZUP (LUNF, CHOPT)
        IARGDB(1) = LUNF
        IARGDB(2) = IQUEST(1)
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : Update from Journal file'//
     +       ' '',I4,'' return code'',I12)', IARGDB, 2)
*
      ELSE IF (CPATL.EQ.'DBILDF') THEN
*
*  **   DBILDF
*
        CALL KUGETI (LUNI)
        CALL KUGETC (CFNAM, NCH)
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
        CALL CUTOL  (CFNAM)
+SELF.
        CALL DBOPEN (LUNI, CFNAM, 'OLD', ISTAT)
        IF (ISTAT.EQ.0) THEN
          CALL KUGETC (CHOPT, NCH)
          CALL DBILDF (LUNI, CHOPT)
          CALL DBCLOS (LUNI)
          IARGDB(1) = IQUEST(11)
          IARGDB(2) = IQUEST(1)
          CALL DBPRNT (L3PRDX, '(/,'' DBACTI : list of'',I6,'' direct'//
     +         'ories read from '//CFNAM(1:40)//' error code'',I12)',
     +         IARGDB, 2)
        ELSE
          CALL DBPRNT (L3PRDX, '(/,'' DBACTI : error in opening file '//
     +         CFNAM(1:40)//' on unit '',I6)', LUNI, 1)
        ENDIF
*
      ELSE IF (CPATL.EQ.'DBILDU') THEN
*
*  **   DBILDU
*
        CALL KUGETI (LUNI)
        CALL KUGETC (CFNAM, NCH)
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
        CALL CUTOL  (CFNAM)
+SELF.
        CALL DBOPEN (LUNI, CFNAM, 'OLD', ISTAT)
        IF (ISTAT.EQ.0) THEN
          CALL KUGETC (TOPNM, NCH)
          CALL KUGETC (CHOPT, NCH)
          CALL DBILDU (LUNI, TOPNM, CHOPT)
          CALL DBCLOS (LUNI)
          IARGDB(1) = IQUEST(11)
          IARGDB(2) = IQUEST(1)
          CALL DBPRNT (L3PRDX, '(/,'' DBACTI : list of'',I6,'' direct'//
     +         'ories read from '//CFNAM(1:40)//' error code'',I12)',
     +         IARGDB, 2)
        ELSE
          CALL DBPRNT (L3PRDX, '(/,'' DBACTI : error in opening file '//
     +         CFNAM(1:40)//' on unit '',I6)', LUNI, 1)
        ENDIF
*
      ELSE IF (CPATL.EQ.'DBINIT') THEN
*
*  **   DBINIT
*
        CALL KUGETI (NREC)
        IF (NREC.LT.0) NREC = 0
        IF (NREC.EQ.0) THEN
          CALL INZROP ('FILE', LUNRZ, CHOPT)
        ELSE
          CALL INZROP ('MAKE', LUNRZ, CHOP)
          CHOPT  = 'Z'//CHOP
        ENDIF
        IF (IQUEST(1).NE.0) GO TO 999
        CALL KUGETI (IDIV)
        CALL KUGETC (TOPNM, NCH)
        CALL DBINIT (IDIV, LUNRZ, TOPNM, LTOP, NREC, CHOPT)
        IF (IQUEST(1).NE.0) THEN
          IERR   = IQUEST(1)
          CALL DBCLOS (LUNRZ)
          IQUEST(1) = IERR
        ENDIF
*
      ELSE IF (CPATL.EQ.'DBLOGL') THEN
*
*  **   DBLOGL
*
        CALL KUGETI (LUNRZ)
        CALL KUGETI (LOGL)
        CALL DBLOGL (LUNRZ, LOGL)
*
      ELSE IF (CPATL.EQ.'DBNTOP') THEN
*
*  **   DBNTOP
*
        CALL KUGETC (PATHI, NCHI)
        CALL KUGETC (PATHN, NCHO)
        CALL KUGETI (MXKP)
        CALL KUGETI (NSAV)
        CALL KUGETC (CHOPT, NCH)
        CALL DBNTOP (PATHI, PATHN, MXKP, NSAV, CHOPT)
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : Copies '//PATHI(1:NCHI)//
     +       ' to '',/,''                 '//PATHN(1:NCHO)//' return '//
     +       'code '',I12)', IQUEST(1), 1)
*
      ELSE IF (CPATL.EQ.'DBOPEN') THEN
*
*  **   DBOPEN
*
        CALL KUGETI (NREC)
        IF (NREC.LT.0) NREC = 0
        IF (NREC.EQ.0) THEN
          CALL INZROP ('FILE', LUNRZ, CHOPT)
        ELSE
          CALL INZROP ('MAKE', LUNRZ, CHOPT)
        ENDIF
*
      ELSE IF (CPATL.EQ.'DBSAVE') THEN
*
*  **   DBSAVE
*
        CALL DBSAVE
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : Saves the changes to '//
     +       'data base - return code'',I12)', IQUEST(1), 1)
*
      ELSE IF (CPATL.EQ.'DBSETD') THEN
*
*  **   DBSETD
*
        CALL KUGETI (MXDIS)
        IF (MXDIS.LE.0) THEN
          MXDPDD = 80
        ELSE IF (MXDIS.GT.512) THEN
          MXDPDD = 512
        ELSE
          MXDPDD = MXDIS
        ENDIF
        WRITE (CFMTDD, '(''(A'',I3,'')'')') MXDPDD
        CALL DBPRNT (L3PRDX, '(/,'' DBACTI : MXDIS is set to '',I10)',
     +       MXDPDD, 1)
*
      ENDIF
*                                                             END DBACTI
  999 END
+DECK, DBAIRD.
      SUBROUTINE DBAIRD (LUN, PATHN, KEYX, CHOPT)
*     ===========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBAIRD (LUN, PATHN, KEYX, CHOPT)                        *
*                                                                      *
*   Display the data attached to the directory PATHN and KEY for       *
*   ASCII type of data                                                 *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUN      Unit number of file for display                         *
*     PATHN    Character string describing the pathname                *
*     KEYX     Key-vector                                              *
*     CHOPT    Character option                                        *
*          E   Object already exists at LFRSDX                         *
*          L   The last object to be shown                             *
*                                                                      *
*   Called by DBAIWR, DBPEEK                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =101 : Illegal path name                               *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DXLINK.
      DIMENSION       KEYX(9), IOPTS(2)
      CHARACTER       PATHN*(*), CHOPT*(*), PATHY*80, PATHX*16
      CHARACTER       KLINE*80
      EQUIVALENCE     (IOPTS(1), IOPTE), (IOPTS(2), IOPTL)
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Set the current directory
*
      CALL UOPTC (CHOPT, 'EL', IOPTS)
      IOPTP  = 0
      IF (IOPTE.NE.0)                            GO TO 40
      PATHY  = PATHN
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0)                        GO TO 991
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKEYT
*
*  ** Find the appropriate object number
*
      NCHR   = LEN (PATHN)
      NCH    = INDEX (PATHN, ' ') - 1
      IF (NCH.EQ.0) NCH = NCHR
      IF (NKEYDK.LE.0)                           GO TO 55
      IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
      ISTP   = NWKYDK + 1
      IF (IOPTL.EQ.0) THEN
        IF (IOPTP.EQ.0) THEN
          IPNT   = KOFSDB + LCDRDB + IKDRDB
          KPNT   = IUHUNT (KEYX(MSERDB), IQ(IPNT+MSERDB), ISTP*NKEYDK,
     +                     ISTP)
          IF (KPNT.GT.0) THEN
            IKMAX  = (KPNT - MSERDB) / ISTP + 1
          ELSE
            IKMAX  = NKEYDK
          ENDIF
        ELSE
          NKEYS  = NKEYDK
          IPNT   = KOFSDB + LCDRDB + IKDRDB
          DO 10 JK = 1, NKEYS
            IK     = NKEYS + 1 - JK
            KPNT   = IUHUNT (IK, IQ(IPNT+MPSRDB), NKEYS*ISTP, ISTP)
            IF (KPNT.GT.0) THEN
              KPNT   = IPNT + KPNT - MPSRDB
            ELSE
              KPNT   = IPNT + (IK - 1) * ISTP
            ENDIF
            IF (IQ(KPNT+MOBJDB).GT.KEYX(MSERDB)) GO TO 10
            CALL DBPATH (PATHX, IK)
            PATHY  = PATHN(1:NCH)//'/'//PATHX
            CALL RZCDIR (PATHY, ' ')
            IF (IQUEST(1).NE.0)                  GO TO 991
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
            NKEYDK = IQUEST(7)
            IPNT   = KOFSDB + LCDRDB + IKDRDB
            KPNT   = IUHUNT (KEYX(MSERDB), IQ(IPNT+MSERDB), ISTP*NKEYDK,
     +                       ISTP)
            IF (KPNT.GT.0) THEN
              IKMAX  = (KPNT - MSERDB) / ISTP + 1
            ELSE
              IKMAX  = NKEYDK
            ENDIF
            GO TO 35
   10     CONTINUE
        ENDIF
      ELSE
        IF (IOPTP.EQ.0) THEN
          KPNT   = KOFSDB + LCDRDB + IKDRDB + (NKEYDK - 1) * ISTP
          KMAX   = IQ(KPNT+MSERDB)
          IKMAX  = NKEYDK
          DO 20 I = 2, NKEYDK
            KPNT   = KPNT - ISTP
            IF (IQ(KPNT+MSERDB).GT.KMAX) THEN
              KMAX   = IQ(KPNT+MSERDB)
              IKMAX  = NKEYDK - I + 1
            ENDIF
   20     CONTINUE
        ELSE
          NKEYS  = NKEYDK
          DO 30 IK = 1, NKEYS
            JK     = NKEYS + 1 - IK
            CALL DBPATH (PATHX, JK)
            PATHY  = PATHN(1:NCH)//'/'//PATHX
            CALL RZCDIR (PATHY, ' ')
            IF (IQUEST(1).NE.0)                  GO TO 991
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
            NKEYDK = IQUEST(7)
            IF (NKEYDK.GT.0) THEN
              KPNT   = KOFSDB + LCDRDB + IKDRDB + (NKEYDK-1)*ISTP
              KMAX   = IQ(KPNT+MSERDB)
              IKMAX  = NKEYDK
              DO 25 I = 2, NKEYDK
                KPNT   = KPNT - ISTP
                IF (IQ(KPNT+MSERDB).GT.KMAX) THEN
                  KMAX   = IQ(KPNT+MSERDB)
                  IKMAX  = NKEYDK - I + 1
                ENDIF
   25         CONTINUE
              GO TO 35
            ENDIF
   30     CONTINUE
        ENDIF
      ENDIF
   35 KEYVDK(MSERDB) = IKMAX
*
*  ** Read in the data
*
      IOLD1  = IOKYDA(MSERDB)
      IOLDK  = IOPKDA
      IOKYDA(MSERDB) = 1
      IOPKDA = 0
      JBIAS  = 2
      IF (LFRSDX.GT.0) THEN
        CALL MZDROP (IDIVDB, LFRSDX, 'L')
        LFRSDX = 0
      ENDIF
      ITIME  = 1
      CALL DBKXIN (ITIME, IDIVDB, LFRSDX, LFRSDX, JBIAS, NWKYDK, KEYVDK,
     +             IPREC)
      IOKYDA(MSERDB) = IOLD1
      IOPKDA = IOLDK
      IF (IQUEST(1).NE.0)                        GO TO 55
   40 IF (LFRSDX.EQ.0)                           GO TO 55
      NDATA  = IQ(KOFUDB+LFRSDX-1)
      IF (NDATA.LE.0)                            GO TO 55
*
*  ** Display data if exists, if it does not, display dummy data
*
   45 NTOT   = 0
+SELF, IF=$DEBUG.
      NREC   = 0
+SELF.
   50 IF (NTOT.LT.NDATA) THEN
        CALL DBLIND (IQ(KOFUDB+LFRSDX+1), NTOT, KLINE, LENG)
        IF (LENG.GT.0) THEN
          WRITE (LUN, 1001) KLINE(1:LENG)
        ELSE
          WRITE (LUN, *)
        ENDIF
+SELF, IF=$DEBUG.
        NREC   = NREC + 1
+SELF.
        GO TO 50
      ENDIF
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBAIRD : '',I8,'' '//
     +   'records written on the file'')', NREC, 1)
+SELF.
      GO TO 60
*
   55 WRITE (LUN, 1001) 'There is no data '
   60 IF (IOPTE.EQ.0) THEN
        IF (LFRSDX.NE.0) CALL MZDROP (IDIVDB, LFRSDX, 'L')
      ENDIF
      IF (IOPTP.NE.0) THEN
        CALL RZCDIR (PATHN, ' ')
        NKEYDK = IQUEST(7)
        LCDRDB = IQUEST(11)
        IKDRDB = IQUEST(13)
      ENDIF
      IQUEST(1) = 0
      GO TO 999
*
* *** Error messages
*
  991 IQUEST(1) = 101
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBAIRD : Illegal '//
     +   'Path Name '//PATHY//''')', IARGDB, 0)
+SELF.
      GO TO 999
*
 1001 FORMAT (A)
*                                                             END DBAIRD
  999 END
+DECK, DBAIWR.
      SUBROUTINE DBAIWR (KEYX, KEYO, PATHN, CHOPT)
*     ============================================
*
************************************************************************
*                                                                      *
*        SUBR. DBAIWR (KEYX, KEYO, PATHN, CHOPT)                       *
*                                                                      *
*   Insert/Update ASCII files in the current working directory         *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     KEYX     Key-Vector containing the new Key values                *
*     KEYO     Key-Vector containing the old Key values                *
*     PATHN    Pathname of the directory                               *
*     CHOPT    Character options                                       *
*         I    Insert new Key                                          *
*         X    Replace (update) old key                                *
*                                                                      *
*   Called by DBEDKY                                                   *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DXLINK.
      DIMENSION       IOPTS(2), KEYX(9), KEYO(9)
      CHARACTER       CFNAM*80, KLINE*80
      CHARACTER       PATHN*(*), CHOPT*(*)
      EQUIVALENCE     (IOPTI, IOPTS(1)), (IOPTX, IOPTS(2))
*
*     ------------------------------------------------------------------
*
*  ** Open the file to editing
*
      CALL KUPROC ('Give Data File-Name (e.g. DFNAME) ',CFNAM, LFNAM)
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP,VAX.
      CFNAM  = CFNAM(1:LFNAM)//'.FILEXT'
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
      CALL CUTOL  (CFNAM)
+SELF, IF=IBM.
      CFNAM  = CFNAM(1:LFNAM)//'.FILEXT.A'
+SELF.
      CALL DBOPEN (LUDADX, CFNAM, 'UNKNOWN', ISTAT)
      IF (ISTAT.NE.0)     GO TO 999
*
* *** Decode the character option
*
      CALL UOPTC (CHOPT, 'IX', IOPTS)
      IF (IOPTX.NE.0) THEN
        CALL DBAIRD (LUDADX, PATHN, KEYO, ' ')
      ELSE
        CALL DBAIRD (LUDADX, PATHN, KEYX, 'L')
      ENDIF
      CALL DBCLOS (LUDADX)
      IF (IQUEST(1).NE.0) GO TO 999
*
*  ** Edits the file containing the data
*
      CALL KUEDIT (CFNAM, IST)
      IF (IST.NE.0)       GO TO 999
*
*  ** Read the data part
*
      IF (LFRSDX.NE.0) CALL MZDROP (IDIVDB, LFRSDX, 'L')
      NDATA  = NDMXDB
      CALL DBBOOK (IDIVDB, LFRSDX, LFRSDX, 2, 'USER', 0,0, NDATA, 1, -1)
      IF (IQUEST(1).NE.0) GO TO 999
      CALL DBOPEN (LUDADX, CFNAM, 'OLD', ISTAT)
      IF (ISTAT.NE.0)     GO TO 50
*
*  ** Now read the file
*
      NDAT   = 0
+SELF, IF=$DEBUG.
      NREC   = 0
+SELF.
   10 READ (LUDADX, 1000, ERR=20, END=20) KLINE
+SELF, IF=$DEBUG.
      NREC   = NREC + 1
+SELF.
      LENG   = LENOCC (KLINE)
      CALL DBLINC (KLINE, LENG, IQ(KOFUDB+LFRSDX+1), NDAT)
      IF (NDAT.GT.NDATA-20) THEN
        PRINT 1000, ' Out of buffer space'
        GO TO 20
      ENDIF
      GO TO 10
*
   20 NDP    = NDAT - NDATA
      CALL DBCLOS (LUDADX)
      IF (NDP.LT.0) CALL MZPUSH (IDIVDB, LFRSDX, 0, NDP, 'I')
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.1) CALL DBPRNT (LPRTDB, '(/,'' DBAIWR : '',I8,'' '//
     +   'records read from the file'')', NREC, 1)
+SELF.
*
      IQUEST(1) = 0
      IF (IOPTX.NE.0) THEN
        CALL DBREPL (PATHN, LKVWDX(1), LDVWDX(1), IDIVDB, LFRSDX,
     +               NWKYDK, KEYO, KEYX, 0, 'RT')
      ELSE
        CALL DBENTR (PATHN, LKVWDX(1), LDVWDX(1), IDIVDB, LFRSDX,
     +               NWKYDK, KEYX, 0, 'RT')
      ENDIF
*
   50 IER    = IQUEST(1)
      CALL MZDROP (IDIVDB, LFRSDX, ' ')
      IQUEST(1) = IER
*
 1000 FORMAT (A80)
*                                                             END DBAIWR
  999 END
+DECK, DBAUXI.
      SUBROUTINE DBAUXI
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBAUXI                                                  *
*                                                                      *
*   Action Routines for menu /DBL3/AUXILIARY                           *
*                                                                      *
*   Allowed Actions :                                                  *
*                                                                      *
*     DBASCI, DBDISP, DBEALI, DBEDIT, DBEHLP, DBENAM, DBKEPT, DBPEEK,  *
*     DBPLNT, DBPRGD, DBPTIM, DBPURG, DBRALI, DBRENK, DBRHLP, DBRNAM,  *
*     DBRTFZ, DBSHOW, DBUTIM, DBVIEW, DBWRITE                          *
*                                                                      *
*   Called by KUIP routine                                             *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DDISPL.
+CDE, DKKEYS.
+CDE, DPLOTS.
+CDE, DXLINK.
      PARAMETER       (NOBJM=100)
      DIMENSION       KEYS(MXDMDK), NKEYX(NPMXDP), NOBJS(NPMXDP)
      DIMENSION       KEYXS(NOBJM), KOBJS(NOBJM)
      CHARACTER       CPATL*32, CHOPT*32, PATHN*80, CHPRO*32, CTEMP*5
      CHARACTER       YESNO*4, PATH*80, CFNAM*80, PATHS(NPMXDP)*80
      CHARACTER       CRZPA*80, CTITL*80, CTAG(NOBJM)*8, CHOP*32
      CHARACTER       ALIAS*8, CHTAG*8, PATHX*16, CFMT*120
      DATA            PATHN /' '/, ALIAS /' '/, CTITL /' '/
      DATA            NWDS /0/, NPATH /1/, IDN /0/, KYI /0/, KYEL /0/
      DATA            LUNFZ /0/, IDATM /0/
*
*     ------------------------------------------------------------------
*
      CALL KUPATL (CPATL, NPAR)
*
      IF (CPATL.EQ.'DBASCI') THEN
*
*  **   DBASCI
*
        CALL KUGETC (PATHN, NCH)
        CALL KUGETC (CFNAM, NCH)
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
        CALL CUTOL  (CFNAM)
+SELF.
        CALL DBEDAS (CFNAM, NCH, PATHN)
*
      ELSE IF (CPATL.EQ.'DBDISP') THEN
*
*  **   DBDISP
*
        CALL KUGETC (PATHN, NCH)
        CALL KUGETC (CFNAM, NCF)
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
        CALL CUTOL  (CFNAM)
+SELF.
        CALL DBOPEN (LUKYDX, CFNAM, 'UNKNOWN', ISTAT)
        IF (ISTAT.NE.0) THEN
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : error '',I12,'' in ope'//
     +         'ning file '//CFNAM(1:NCF)//''')', ISTAT, 1)
          GO TO 999
        ENDIF
        CALL KUGETC (CHOPT, NCH)
        CALL UOPTC (CHOPT, 'H', IOPHDD)
        CHOP   = 'K'//CHOPT
        CALL DBDISP (LUKYDX, PATHN, CHOP)
        CALL DBCLOS (LUKYDX)
        CALL KUEDIT (CFNAM, IST)
*
      ELSE IF (CPATL.EQ.'DBEALI') THEN
*
*  **   DBEALI
*
        CALL KUGETC (PATHN, NCT)
        CALL KUGETC (ALIAS, NCH)
        CALL KUGETI (IFLAG)
        CALL DBEALI (PATHN, ALIAS, IFLAG)
        IF (IQUEST(1).EQ.0) THEN
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Alias name of '//
     +         PATHN(1:NCT)//' is '//ALIAS//''')', IARGDB, 0)
        ELSE
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Error in entering alia'//
     +         's name for '//PATHN(1:NCT)//''')', IARGDB, 0)
        ENDIF
*
      ELSE IF (CPATL.EQ.'DBEDIT') THEN
*
*  **   DBEDIT
*
        CALL KUGETC (PATHN, NCH)
        CALL KUGETC (CFNAM, NCF)
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
        CALL CUTOL  (CFNAM)
+SELF.
        CALL KUPROC ('Create Directory ? (Y/N)', YESNO, NCH)
        IF (YESNO(1:1).EQ.'Y') CALL DBCRDR (PATHN)
        CALL KUPROC ('Keys Insert/Update ? (Y/N)', YESNO, NCH)
        IF (YESNO(1:1).EQ.'Y') THEN
          CALL KUPROC ('Horizontal or Vertical Mode ? (H/V)',
     +                  YESNO, NCH)
          CALL UOPTC (YESNO, 'H', IOPHDD)
          CALL DBEDKY (CFNAM, NCF, PATHN, 'S')
        ENDIF
*
      ELSE IF (CPATL.EQ.'DBEHLP') THEN
*
*  **   DBEHLP
*
        CALL KUGETC (PATHN, NCT)
        CALL KUGETC (CFNAM, NCH)
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
        CALL CUTOL  (CFNAM)
+SELF.
        CALL KUEDIT (CFNAM, IST)
        IF (IST.EQ.0) THEN
          CALL DBOPEN (LUKYDX, CFNAM, 'UNKNOWN', ISTAT)
          IF (ISTAT.EQ.0) THEN
            CALL DBEHLP (PATHN, LUKYDX)
            CALL DBCLOS (LUKYDX)
            IF (IQUEST(1).EQ.0) THEN
              CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Help info. for '//
     +             PATHN(1:NCT)//' is stored'')', IARGDB, 0)
            ELSE
              CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : error '',I6,'' in '//
     +             'storing Help info. for '//PATHN(1:NCT)//''')',
     +             IQUEST(1), 1)
            ENDIF
          ELSE
            CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : error '',I12,'' in o'//
     +           'pening file '//CFNAM(1:NCH)//''')', ISTAT, 1)
          ENDIF
        ELSE
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : error '',I12,'' in ed'//
     +         'iting file '//CFNAM(1:NCH)//''')', IST, 1)
        ENDIF
*
      ELSE IF (CPATL.EQ.'DBENAM') THEN
*
*  **   DBENAM
*
        CALL KUGETC (PATHN, NCT)
        CALL KUGETI (NWDS)
        IF (NWDS.GT.NOBJM) THEN
          IARGDB(1) = NWDS
          IARGDB(2) = NOBJM
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Too many data elements'//
     +         ' '',I12,'' maximum '',I5,'' is allowed'')', IARGDB, 2)
          GO TO 999
        ENDIF
        IF (NWDS.GT.0) THEN
          DO 5 I = 1, NWDS
            WRITE (CHPRO, 1001) I
            CALL DBPROC (CHPRO(1:10), CHTAG, NCH)
            CTAG(I) = CHTAG
    5     CONTINUE
          CALL DBENAM (PATHN, NWDS, CTAG)
          IF (IQUEST(1).EQ.0) THEN
            CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Tags of data for '//
     +           PATHN(1:NCT)//' is stored'')', IARGDB, 0)
          ELSE
            CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : error '',I6,'' in st'//
     +           'oring Tags of data for '//PATHN(1:NCT)//''')',
     +           IQUEST(1), 1)
          ENDIF
        ENDIF
*
      ELSE IF (CPATL.EQ.'DBKEPT') THEN
*
*  **   DBKEPT
*
        CALL KUGETI (NPATH)
        CALL KUGETC (CHOPT, NCH)
        IF (NPATH.GT.0) THEN
          DO 10 IP = 1, NPATH
            WRITE (CHPRO, 1002) IP
            CALL KUPROC (CHPRO(1:15), PATHS(IP), NCH)
   10     CONTINUE
          CALL DBKEPT (PATHS, NPATH, CHOPT)
          IARGDB(1) = NPATH
          IARGDB(2) = IQUEST(1)
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : All but '',I6,'' direc'//
     +         'tory trees deleted - return code '',I6)', IARGDB, 2)
        ENDIF
*
      ELSE IF (CPATL.EQ.'DBPEEK') THEN
*
*  **   DBPEEK
*
        CALL KUGETC (PATHN, NCH)
        CALL KUGETC (CFNAM, NCF)
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
        CALL CUTOL  (CFNAM)
+SELF.
        CALL DBOPEN (LUKYDX, CFNAM, 'UNKNOWN', ISTAT)
        IF (ISTAT.NE.0) THEN
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : error '',I12,'' in ope'//
     +         'ning file '//CFNAM(1:NCF)//''')', ISTAT, 1)
          GO TO 999
        ENDIF
        CALL KUGETC (CHOPT, NCH)
        CALL UOPTC (CHOPT, 'H', IOPHDD)
        CALL DBPEEK (CFNAM, NCF, PATHN)
*
      ELSE IF (CPATL.EQ.'DBPLNT') THEN
*
*  **   DBPLNT
*
        CALL KUGETI (NPATH)
        IF (NPATH.LT.1) THEN
          NPATH = 1
        ELSE IF (NPATH.GT.NPMXDP) THEN
          NPATH = NPMXDP
        ENDIF
        CALL KUGETC (CHOPT, NCH)
        CALL KUGETI (IDN)
        CALL KUGETC (CTITL, NCT)
        CALL KUGETC (CRZPA, NCR)
        CALL KUGETI (NPRIM)
        CALL HCDIR  (PATH, 'R')
        CALL HCDIR  (CRZPA, ' ')
        IF (IQUEST(1).NE.0) THEN
          CALL DBPRNT (L3PRDX, '('' RZ-path '//CRZPA(1:NCR)//' for '//
     +         'N-tuple is illegal'')', IARGDB, 0)
          GO TO 999
        ENDIF
        CALL HCDIR (CRZPA, 'R')
        CALL DBOPTS (CHOPT)
        IF (IQUEST(1).NE.0)               GO TO 999
        CALL VZERO (KEYS, MXDMDK)
        CALL DBRVNT (NPATH, PATHS, KEYS, NVAR, NKST, NDST, NKEYX, KEYXS,
     1               NOBJS, KOBJS, CTAG, NOBJM)
        IF (IQUEST(1).NE.0)               GO TO 999
        IF (NVAR.LT.1) THEN
          CALL DBPRNT (L3PRDX, '('' Too few  variables for N-tuple'')',
     +         IARGDB, 0)
          GO TO 999
        ENDIF
*  **    Book the N-tuple
        CALL HCDIR  (PATH, ' ')
        CALL HBOOKN (IDN, CTITL(1:NCT), NVAR, CRZPA, NPRIM, CTAG)
        CALL DBPLNT (IDN, PATHS, NPATH, NOBJS, KOBJS, NKEYX, KEYXS,
     +               KEYS, CHOPT)
        IF (IQUEST(1).NE.0) CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : erro'//
     +  'r '',I12,'' in routine DBPLNT'')', IQUEST(1), 1)
        CALL HCDIR  (PATH, ' ')
*
      ELSE IF (CPATL.EQ.'DBPRGD') THEN
*
*  **   DBPRGD
*
        CALL KUGETC (PATHN, NCH)
        CALL KUGETI (IKEEP)
        CALL DBPRGD (PATHN, IKEEP, ' ')
        IARGDB(1) = IKEEP
        IARGDB(2) = IQUEST(1)
        CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : all but'',I6,'' partitio'//
     +       'ns deleted from '//PATHN(1:60)//' return code '',I6)',
     +       IARGDB, 2)
*
      ELSE IF (CPATL.EQ.'DBPTIM') THEN
*
*  **   DBPTIM
*
        CALL KUGETI (IDATE)
        CALL KUGETI (ITIME)
        CALL DBPKTS (IDATE, ITIME, IARGDB(1))
        IARGDB(2) = IDATE
        IARGDB(3) = ITIME
        CALL DBPRNT (L3PRDX, '(/,2X,I10,'' is the packed integer for '//
     +       'date and time : '',2I10,/)', IARGDB, 3)
*
      ELSE IF (CPATL.EQ.'DBPURG') THEN
*
*  **   DBPURG
*
        CALL KUGETC (PATHN, NCH)
        CALL KUGETI (KYDAT)
        CALL KUGETI (KYTIM)
        CALL KUGETC (CHOPT, NCH)
        CALL DBPURG (PATHN, KYDAT, KYTIM, CHOPT)
        NCH    = LENOCC (PATHN)
        IF (NCH.GT.40) NCH = 40
        CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : DBPURG deletes in Path '//
     +       PATHN(1:NCH)//' return code '',I6)', IQUEST(1), 1)
*
      ELSE IF (CPATL.EQ.'DBRALI') THEN
*
*  **   DBRALI
*
        CALL KUGETC (ALIAS, NCH)
        CALL DBRALI (ALIAS, PATHN)
        CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Path name for alias '//
     +       ALIAS//' is '//PATHN//''')', IARGDB, 0)
*
      ELSE IF (CPATL.EQ.'DBRENK') THEN
*
*  **   DBRENK
*
        CALL KUGETC (PATHN, NCH)
        CALL KUGETI (KYI)
        CALL KUGETI (KYEL)
        CALL DBSBLC (PATHN, PATH, NCHAR)
        CALL RZCDIR (PATH, ' ')
        IF (IQUEST(1).EQ.0) THEN
          NKEYDK = IQUEST(7)
          NWKYDK = IQUEST(8)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          KST    = NWKYDK + 1
          CALL DBKEYT
          IF (NKEYDK.NE.0)  THEN
            IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)
            IOPTP  = JBIT (IOPTP, JPRTDB)
          ELSE
            IOPTP  = 0
          ENDIF
          IF (IOPTP.NE.0) THEN
            CALL RZCDIR (PATH, 'R')
            NCHAR  = LENOCC (PATH)
            NKEYS  = NKEYDK
            DO 45 JK = 1, NKEYS
              IK     = NKEYS + 1 - JK
              KPNT   = IUHUNT (IK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                         NKEYS*KST, KST)
              IF (KPNT.GT.0) THEN
                IPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB
              ELSE
                IPNT   = KOFSDB + LCDRDB + IKDRDB + (NKEYDK - 1) * KST
              ENDIF
              IF (IQ(IPNT+MOBJDB).GT.KYI) GO TO 45
              CALL DBPATH (PATHX, IK)
              CALL RZCDIR (PATHX, ' ')
              IF (IQUEST(1).NE.0) THEN
                PATHN  = PATH(1:NCHAR)//'/'//PATHX
                CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Illegal Path name '
     +               //PATHN//''')', IARGDB, 0)
                GO TO 999
              ENDIF
              NKEYDK = IQUEST(7)
              LCDRDB = IQUEST(11)
              IKDRDB = IQUEST(13)
              KK     = IUHUNT (KYI, IQ(KOFSDB+LCDRDB+IKDRDB+MSERDB),
     +                         NKEYDK*KST, KST)
              IF (KK.GT.0) THEN
                KK     = (KK - MSERDB) / KST + 1
                GO TO 50
              ELSE
                CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Object '',I12'//
     +               ','' not found in '//PATH//''')', KYI, 1)
                GO TO 999
              ENDIF
   45       CONTINUE
            CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Object '',I12'//
     +           ','' not found in '//PATH//''')', KYI, 1)
            GO TO 999
          ELSE
            KK     = IUHUNT (KYI, IQ(KOFSDB+LCDRDB+IKDRDB+MSERDB),
     +                       NKEYDK*KST, KST)
            IF (KK.GT.0) THEN
              KK     = (KK - MSERDB) / KST + 1
            ELSE
              CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Object '',I12'//
     +             ','' not found in '//PATH//''')', KYI, 1)
              GO TO 999
            ENDIF
          ENDIF
   50     CALL DBKEYR (KK, NWKYDK, KEYS)
          CALL UCOPY  (KEYS, KEYXS, NWKYDK)
          IF (KYEL.GT.2.AND.KYEL.LE.NWKYDK.AND.KYEL.NE.MFLGDB.AND.
     +        KYEL.NE.MITMDB)                     THEN
            IF (KYEL.EQ.MBVRDB.OR.KYEL.EQ.MEVRDB) THEN
              IF (KYEL.EQ.MBVRDB) THEN
                CTEMP  = 'Begin'
              ELSE
                CTEMP  = 'End'
              ENDIF
              WRITE (CHPRO, 1003) 'YYMMDD', CTEMP
              CALL KUPROI (CHPRO, IDATE)
              WRITE (CHPRO, 1003) 'HHMMSS', CTEMP
              CALL KUPROI (CHPRO, ITIME)
              CALL DBPKTS (IDATE, ITIME, KEYXS(KYEL))
            ELSE
              WRITE (CHPRO, 1004) KYEL
              IF (IOTYDK(KYEL).LE.2) THEN
                CALL KUPROI (CHPRO, KEYXS(KYEL))
              ELSE
                CALL KUPROC (CHPRO, CTEMP, NCH)
                CALL UCTOH  (CTEMP, KEYXS(KYEL), 4, 4)
              ENDIF
            ENDIF
            CALL DBRENK (PATH, KEYS, KEYXS)
            IARGDB(1) = KYEL
            IARGDB(2) = KYI
            IARGDB(3) = IQUEST(1)
            CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Key '',I4,'' changed'//
     +           ' for Object '',I12,'' in '//PATH(1:40)//' return co'//
     +           'de '',I6)', IARGDB, 3)
          ELSE
            IARGDB(1) = KYEL
            IARGDB(2) = NWKYDK
            CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Key '',I4,'' illegal'//
     +           ' for DBRENK - NWKYDK '',I8)', IARGDB, 2)
          ENDIF
        ELSE
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Illegal Path name '//
     +         PATH//''')', IARGDB, 0)
        ENDIF
*
      ELSE IF (CPATL.EQ.'DBRHLP') THEN
*
*  **   DBRHLP
*
        CALL KUGETC (PATHN, NCH)
        CALL KUGETC (CFNAM, NCH)
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
        CALL CUTOL  (CFNAM)
+SELF.
        CALL DBOPEN (LUKYDX, CFNAM, 'UNKNOWN', ISTAT)
        IF (ISTAT.EQ.0) THEN
          CALL DBRHLP (PATHN, LUKYDX)
          IERR = IQUEST(1)
          IF (IERR.NE.0) CALL DBPRNT (LUKYDX, '(/,'' DBAUXI : Error'//
     +    ' '',I12,'' in getting help info. for '',/,'' '//PATHN(1:72)
     +    //''')', IERR, 1)
          CALL DBCLOS (LUKYDX)
          CALL KUEDIT (CFNAM, IST)
        ELSE
          CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : error '',I12,'' in ope'//
     +         'ning file '//CFNAM(1:NCH)//''')', ISTAT, 1)
        ENDIF
*
      ELSE IF (CPATL.EQ.'DBRNAM') THEN
*
*  **   DBRNAM
*
        CALL KUGETC (PATHN, NCH)
        NWMAX  = NOBJM
        CALL DBRNAM (PATHN, NWMAX, CTAG)
        CFMT(1:1)     = '('
        CFMT(120:120) = ')'
        DO 60 I1 = 1, NWMAX, 5
          I2     = I1 + 4
          IF (I2.GT.NWMAX) I2 = NWMAX
          CFMT(2:119) = ' '
          DO 55 I = I1, I2
            IARGDB(I-I1+1) = I
            K1             = (I - I1) * 23 + 2
            K2             = K1 + 22
            CFMT(K1:K2)    = ''' Tag '',I2,''         '','
            CFMT(K1+13:K1+20) = CTAG(I)
   55     CONTINUE
          NARG   = I2 - I1 + 1
          CALL DBPRNT (L3PRDX, CFMT, IARGDB, NARG)
   60   CONTINUE
*
      ELSE IF (CPATL.EQ.'DBRTFZ') THEN
*
*  **   DBRTFZ
*
        CALL KUGETC (PATHN, NCH)
        CALL KUGETI (LUNFZ)
        CALL KUGETI (K1MIN)
        CALL KUGETI (K1MAX)
        CALL KUGETC (CHOPT, NCH)
        CALL DBRTFZ (PATHN, LUNFZ, K1MIN, K1MAX, CHOPT)
        NCH    = LENOCC (PATHN)
        IF (NCH.GT.36) NCH = 36
        IARGDB(1) = K1MIN
        IARGDB(2) = K1MAX
        IARGDB(3) = LUNFZ
        IARGDB(4) = IQUEST(1)
        CALL DBPRNT (L3PRDX, '(/,'' DBAUXI : Transfers '',I8,'' to'//
     +       ' '',I8,'' objects from '//PATHN(1:NCH)//' to unit '',I4'//
     +       ','' return code '',I6)', IARGDB, 4)
*
      ELSE IF (CPATL.EQ.'DBSHOW') THEN
*
*  **   DBSHOW
*
        CALL KUGETC (PATHN, NCH)
        CALL KUGETC (CHOPT, NCH)
        CALL DBPRIN (PATHN, CHOPT)
*
      ELSE IF (CPATL.EQ.'DBUTIM') THEN
*
*  **   DBUTIM
*
        CALL KUGETI (IDATM)
        CALL DBUPTS (IARGDB(2), IARGDB(3), IDATM)
        IARGDB(1) = IDATM
        CALL DBPRNT (L3PRDX, '(/,2X,I10,'' is the packed integer for '//
     +       'date and time : '',2I10,/)', IARGDB, 3)
*
      ELSE IF (CPATL.EQ.'DBVIEW') THEN
*
*  **   DBVIEW
*
        CALL KUGETC (PATHN, NCH)
        CALL KUGETC (CFNAM, NCF)
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
        CALL CUTOL  (CFNAM)
+SELF.
        CALL DBVIEW (CFNAM, PATHN)
*
      ELSE IF (CPATL.EQ.'DBWRITE') THEN
*
*  **   DBWRITE
*
        CALL KUGETC (PATHN, NCH)
        CALL KUGETC (CFNAM, NCF)
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
        CALL CUTOL  (CFNAM)
+SELF.
        CALL KUPROC ('Create Directory ? (Y/N)', YESNO, NCH)
        IF (YESNO(1:1).EQ.'Y') CALL DBCRDR (PATHN)
        CALL KUPROC ('Keys Insert/Update ? (Y/N)', YESNO, NCH)
        IF (YESNO(1:1).EQ.'Y') THEN
          CALL KUPROC ('Horizontal or Vertical Mode ? (H/V)',
     +                  YESNO, NCH)
          CALL UOPTC (YESNO, 'H', IOPHDD)
          CALL DBEDKY (CFNAM, NCF, PATHN, 'A')
        ENDIF
*
      ENDIF
*
 1001 FORMAT ('Tag(',I2,')')
 1002 FORMAT (I2,'th Path name')
 1003 FORMAT (A,' of ',A,' Range')
 1004 FORMAT ('Key(',I2,') ?')
*                                                             END DBAUXI
  999 END
+DECK, DBCLOS.
      SUBROUTINE DBCLOS (LUN)
*     =======================
*
************************************************************************
*                                                                      *
*        SUBR. DBCLOS (LUN)                                            *
*                                                                      *
*   Closes unit LUN                                                    *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUN      Logical unit number                                     *
*                                                                      *
*   Called by DBACPL, DBACTI, DBAIWR, DBAUXI, DBEDAS, DBEDKY, DBPEEK,  *
*             DBPRES, DBRDDA, DBRDIO                                   *
*                                                                      *
************************************************************************
*
+SELF, IF=IBM.
      CHARACTER       CTEMP*20, CHLUN*3
*
+SELF.
*     ------------------------------------------------------------------
*
      CLOSE (LUN)
+SELF, IF=IBM.
      WRITE (CHLUN, '(I3)') LUN
      CTEMP  = 'FILEDEF '//CHLUN//'  CLEAR'
      CALL VMCMS (CTEMP, ISTAT)
+SELF.
*                                                             END DBCLOS
  999 END
+DECK, DBCONC.
      SUBROUTINE DBCONC (IOT, N, ICON, NSK)
*     =====================================
*
************************************************************************
*                                                                      *
*        SUBR. DBCONC (IOT, N, ICON*, NSK*)                            *
*                                                                      *
*   Routine to calculate the number of concatenated keys               *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IOT      I/O Type of the keys                                    *
*     N        Length of the key-vector                                *
*     ICON     Number of concatenated keys to present key              *
*     NSK      Total number of concatenated keys                       *
*                                                                      *
*   Called by DBDISP, DBEDAS, DBJOIN, DBVWPR                           *
*                                                                      *
************************************************************************
*
+CDE, DCONCT.
      DIMENSION       ICON(9), IOT(9)
*
*     ------------------------------------------------------------------
*
      CALL VZERO (ICON(1), N)
      NSK  = 0
      I    = 0
      ISYS = 0
      IUSE = 0
    5 CONTINUE
      I    = I + 1
      J    = 0
      IF (I.GT.N) GO TO 999
      IF (IOT(I).EQ.5) THEN
        ISYS = ISYS + 1
        IUSE = IUSE + 1
        IUSEDC(ISYS) = IUSE
        ISYSDC(IUSE) = ISYS
   10   K    = I + J + 1
        IF (K.LE.N.AND.IOT(K).EQ.6) THEN
          ISYS = ISYS + 1
          IUSEDC(ISYS) = IUSE
          J    = J + 1
          GO TO 10
        ENDIF
        ICON(I) = J
        NSK  = NSK + J
      ELSE
        ISYS = ISYS + 1
        IUSE = IUSE + 1
        IUSEDC(ISYS) = IUSE
        ISYSDC(IUSE) = ISYS
      ENDIF
      GO TO 5
*                                                             END DBCONC
  999 END
+DECK, DBCRDR.
      SUBROUTINE DBCRDR (PATHN)
*     =========================
*
************************************************************************
*                                                                      *
*        SUBR. DBCRDR (PATHN)                                          *
*                                                                      *
*   Routine to create DB Directory interactively                       *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*                                                                      *
*   Called by DBACTI, DBAUXI                                           *
*                                                                      *
************************************************************************
*
+CDE, DKKEYS.
      CHARACTER       PATHN*(*), CHKTY*100, KEYNM*8, KEYTP*1, YESNO*1
*
*     ------------------------------------------------------------------
*
*  **   Insert the System-Keys
*
      CHKTY  = CHFTDK
      DO 10 I = 1, NSYSDK
   10 CTAGDK(I) = CHTGDK(I)
*
* *** Check if it is a partitioned directory
*
      CALL KUPROC ('Is it a partitioned Directory ? (Y/N) ', YESNO, LYN)
      IF (YESNO.EQ.'Y') THEN
        CALL KUPROI ('Maximum number of objects in a partition ', MXKP)
        IF (MXKP.LT.1.OR.MXKP.GT.MXKYDK) MXKP = MXKPDK
      ELSE
        MXKP   = 0
      ENDIF
*
*  ** Get the Users Keys (Name and Type)
*
      NKEYS  = NSYSDK
   15 CONTINUE
      CALL KUPROC ('Key-Name ? (No more : |)', KEYNM, LKNM)
      IF (KEYNM(1:1).EQ.'|') GO TO 30
      NKEYS  = NKEYS + 1
      CTAGDK(NKEYS) = KEYNM
   20 CONTINUE
      CALL KUPROC ('Key-Type ? (I,H,B or A)', KEYTP, LKTP)
      IF (KEYTP.NE.'I'.AND.KEYTP.NE.'H'.AND.KEYTP.NE.'B'.AND.
     +    KEYTP.NE.'A')      GO TO 20
      CHKTY(NKEYS:NKEYS) = KEYTP
      GO TO 15
*
*  ** Create the Directory
*
   30 CONTINUE
      IF (MXKP.LE.0) THEN
        CALL DBMDIR (PATHN, NKEYS, CHKTY, CTAGDK)
      ELSE
        CALL DBMDIP (PATHN, NKEYS, CHKTY, CTAGDK, MXKP)
      ENDIF
*                                                             END DBCRDR
  999 END
+DECK, DBCTOB.
      SUBROUTINE DBCTOB (CVAL, ZVAL)
*     ==============================
*
************************************************************************
*                                                                      *
*        SUBR. DBCTOB (CVAL, ZVAL*)                                    *
*                                                                      *
*   Converts character string into hexadecimal bit string              *
*                                                                      *
*   This routine is taken from R.Brun                                  *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     CVAL     Character string (input)                                *
*     ZVAL(*)  Hexadecimal bit string (output)                         *
*                                                                      *
*   Called by DBDCKH, DBDCKV, DBRDDA                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =100 : Error in decoding                               *
*                                                                      *
************************************************************************
*
      COMMON /QUEST/  IQUEST(100)
      PARAMETER       (MXD=15)
      CHARACTER       CVAL*(*)
      CHARACTER*(MXD) CTEMP, BLANK
      REAL*4          ZVAL
*
*     ------------------------------------------------------------------
*
      IQUEST(1) = 0
      L  = LENOCC(CVAL)
      IF (L.EQ.0) GO TO 999
      IF (L.GT.MXD) THEN
        IQUEST(1) = 100
        GO TO 999
      ENDIF
      BLANK = ' '
      IF (L.EQ.MXD) THEN
        CTEMP = CVAL
      ELSE
        CTEMP = BLANK(1:MXD-L)//CVAL
      ENDIF
      READ (CTEMP, '(Z15)', ERR=100) ZVAL
      GO TO 999
  100 IQUEST(1) = 100
*                                                             END DBCTOB
  999 END
+DECK, DBCTOI.
      SUBROUTINE DBCTOI (CVAL, IVAL)
*     ==============================
*
************************************************************************
*                                                                      *
*        SUBR. DBCTOI (CVAL, IVAL*)                                    *
*                                                                      *
*   Converts character string into integer value                       *
*                                                                      *
*   This routine is taken from R.Brun                                  *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     CVAL     Character string (input)                                *
*     IVAL(*)  Integer value (output)                                  *
*                                                                      *
*   Called by DBCTOR, DBDCKH, DBDCKV, DBRDDA                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =100 : Error in decoding                               *
*                                                                      *
************************************************************************
*
      COMMON /QUEST/  IQUEST(100)
      PARAMETER       (MXD=15)
      CHARACTER       CVAL*(*)
      CHARACTER*(MXD) CTEMP, BLANK
      INTEGER         IVAL
*
*     ------------------------------------------------------------------
*
      IQUEST(1) = 0
      L  = LENOCC(CVAL)
      IF (L.EQ.0) GO TO 999
      IF (L.GT.MXD) THEN
        IQUEST(1) = 100
        GO TO 999
      ENDIF
      BLANK = ' '
      IF (L.EQ.MXD) THEN
        CTEMP = CVAL
      ELSE
        CTEMP = BLANK(1:MXD-L)//CVAL
      ENDIF
      READ (CTEMP, '(I15)', ERR=100) IVAL
      GO TO 999
  100 IQUEST(1) = 100
*                                                             END DBCTOI
  999 END
+DECK, DBCTOR.
      SUBROUTINE DBCTOR (CVAL, RVAL)
*     ==============================
*
************************************************************************
*                                                                      *
*        SUBR. DBCTOR (CVAL, RVAL*)                                    *
*                                                                      *
*   Converts character string into real value                          *
*                                                                      *
*   This routine is taken from R.Brun                                  *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     CVAL     Character string (input)                                *
*     RVAL(*)  Real value (output)                                     *
*                                                                      *
*   Called by DBDCKV, DBRDDA                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =100 : Error in decoding                               *
*                                                                      *
************************************************************************
*
      COMMON /QUEST/  IQUEST(100)
      PARAMETER       (MXD=15)
      CHARACTER       CVAL*(*)
      CHARACTER*(MXD) CTEMP, BLANK
      REAL            RVAL
*
*     ------------------------------------------------------------------
*
      IQUEST(1) = 0
      L  = LENOCC(CVAL)
      IF (L.EQ.0)       GO TO 999
      IF (L.GT.MXD)     GO TO 900
      BLANK = ' '
      IF (L.EQ.MXD) THEN
        CTEMP = CVAL
      ELSE
        CTEMP = BLANK(1:MXD-L)//CVAL
      ENDIF
*
      CALL CLTOU (CTEMP)
*
      I1  = INDEX (CTEMP, '.')
      II1 = 0
      IF (I1.LT.L) II1 = INDEX (CTEMP(I1+1:MXD), '.')
      I2  = INDEX (CTEMP, 'E')
      II2 = 0
      IF (I2.LT.L) II2 = INDEX (CTEMP(I2+1:MXD), 'E')
*
      IF (II1+II2.NE.0) GO TO 900
*
      IF (I1+I2.EQ.0) THEN
        CALL DBCTOI (CTEMP,IVAL)
        RVAL = IVAL
      ELSE IF (I1.EQ.L.AND.I2.EQ.0) THEN
        CALL DBCTOI (CTEMP(:I1-1), IVAL)
        RVAL = IVAL
      ELSE
        READ (CTEMP, '(G15.9)', END=999, ERR=900) RVAL
      ENDIF
      GO TO 999
*
  900 IQUEST(1) = 100
*                                                             END DBCTOR
  999 END
+DECK, DBDCKH.
      SUBROUTINE DBDCKH (CHPRT, KY, IKEY)
*     ===================================
*
************************************************************************
*                                                                      *
*        SUBR. DBDCKH (CHPRT, KY*, IKEY*)                              *
*                                                                      *
*   Fills a vector KY of elements NWKYDK according to its type IOTYDD  *
*   from the character string CHPRT in Horizontal Mode                 *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     CHPRT    Character string containing the keys to be decoded      *
*     KY       Vector to be filled with the decoded elements           *
*     IKEY     Serial number of the key to be filled                   *
*                                                                      *
*   Other variables :                                                  *
*                                                                      *
*     IOTYDD   Type of the vector elements                             *
*          1 - Binary                                                  *
*          2   Integer                                                 *
*          3   Floating                                                *
*          4   Double Precision (not yet implemented)                  *
*          5   Hollerith                                               *
*          6   Hollerith concatenetad to previous hollerith            *
*          7   Packed integer - time packed upto seconds               *
*          8   Packed integer - time packed upto minutes               *
*          9   Data which should not be displayed                      *
*     ICONDK   Number of keys concatenated to the present one          *
*     NWKYDK   Number of elements in the array KY (and IOTYDD)         *
*                                                                      *
*   Called by  DBEDAS, DBEDKY                                          *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DDISPL.
+CDE, DKKEYS.
      CHARACTER       CHPRT*(*)
      DIMENSION       KY(9)
*
*     ------------------------------------------------------------------
*
      READ (CHPRT(2:9), '(I8)') IKEY
      CALL VZERO (KY(1), NWKYDK)
      ISTR = 12
      DO 10 I = 1, NWKYDK
        KK    = IOTYDD(I)
        GO TO (1,2,10,10,5,10,7,8,10), KK
    1   CONTINUE
*
*  **   Binary
*
        IEND = ISTR + NUMCDD(I) - 3
        CALL DBCTOB (CHPRT(ISTR:IEND), KY(I))
        ISTR = IEND + 3
        GO TO 10
    2   CONTINUE
*
*  **   Integer
*
        IEND = ISTR + NUMCDD(I) - 3
        CALL DBCTOI (CHPRT(ISTR:IEND), KY(I))
        ISTR = IEND + 3
        GO TO 10
    5   CONTINUE
*
*  **   Hollerith
*
        IEND = ISTR + NUMCDD(I) - 3
        IREP = ICONDK(I) + 1
        IF (IREP.EQ.1) THEN
          DO 51 J = ISTR, IEND
            IF (CHPRT(J:J).EQ.' ') THEN
              GO TO 51
            ELSE IF (CHPRT(J:J).EQ.'''') THEN
              IST = J + 1
              GO TO 52
            ELSE
              IST = J
              GO TO 52
            ENDIF
   51     CONTINUE
   52     CONTINUE
          ISTR = IST
        ENDIF
        CALL UCTOH (CHPRT(ISTR:IEND), KY(I), 4, 4*IREP)
        ISTR = IEND + 3
        GO TO 10
    7   CONTINUE
*
*  **   Packed Integer (upto seconds)
*
        IEND = ISTR + NUMCDD(I) - 3
        I1 = ISTR
        I2 = I1 + 5
        READ  (CHPRT(I1:I2), '(I6)') IDATE
        I1 = I2 + 2
        I2 = I1 + 5
        READ  (CHPRT(I1:I2), '(I6)') ITIME
        ISTR = IEND + 3
        CALL DBPKTS (IDATE, ITIME, KY(I))
        GO TO 10
    8   CONTINUE
*
*  **   Packed Integer (upto minutes)
*
        IEND = ISTR + NUMCDD(I) - 3
        I1 = ISTR
        I2 = I1 + 5
        READ  (CHPRT(I1:I2), '(I6)') IDATE
        I1 = I2 + 2
        I2 = I1 + 5
        READ  (CHPRT(I1:I2), '(I6)') ITIME
        ISTR = IEND + 3
        CALL DBPKTM (IDATE, ITIME, KY(I))
        GO TO 10
*
   10 CONTINUE
      IQUEST(1) = 0
      GO TO 999
*                                                             END DBDCKH
  999 END
+DECK, DBDCKV.
      SUBROUTINE DBDCKV (LUN, IC, KY)
*     ===============================
*
************************************************************************
*                                                                      *
*        SUBR. DBDCKV (LUN, IC, KY*)                                   *
*                                                                      *
*   Decodes values of a key vector (KY) stored in Vertical mode        *
*   (in NL lines on a file on unit LUN)                                *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUN      Logical Unit number containing the file to be decoded   *
*     IC       Number of keys concatenated to the present one          *
*     KY       Vector containing the decoded elements                  *
*                                                                      *
*   Called by  DBEDAS, DBEDKY                                          *
*                                                                      *
************************************************************************
*
+CDE, DKKEYS.
      CHARACTER       LINE*80, CHFOR*1, CHVAL*80
      DIMENSION       KY(9), IC(9)
*
*     ------------------------------------------------------------------
*
      J = 0
    5 READ (LUN, '(A80)', END=999) LINE
*
      NCH = LENOCC (LINE)
      IF (NCH.LE.0)    GO TO 30
      CHVAL = ' '
      I = 13
      CHFOR = LINE(I:I)
      DO 6 K = I+1, NCH
        IF (LINE(K:K).NE.' ') THEN
          CHVAL = LINE(K:NCH)
          GO TO 20
        ENDIF
    6 CONTINUE
*
   20 J = J + 1
      IF (CHFOR.EQ.'I') THEN
        CALL DBCTOI (CHVAL, KY(J))
      ELSE IF (CHFOR.EQ.'F') THEN
        CALL DBCTOR (CHVAL, KY(J))
      ELSE IF (CHFOR.EQ.'B') THEN
        CALL DBCTOB (CHVAL, KY(J))
      ELSE IF (CHFOR.EQ.'H') THEN
        NREP = IC(J)
        LCDAT = 4*(NREP+1)
        CALL UCTOH (CHVAL, KY(J), 4, LCDAT)
        J = J + NREP
      ELSE IF (CHFOR.EQ.'S') THEN
        NC = LENOCC (CHVAL)
        DO 21 K = 1, NC
          IF (CHVAL(K:K).EQ.' ') THEN
            KK = K
            GO TO 22
          ENDIF
   21   CONTINUE
        KY(J) = 0
        GO TO 25
   22   CONTINUE
        CALL DBCTOI (CHVAL(1:KK-1), IDATE)
        CALL DBCTOI (CHVAL(KK:NC),  ITIME)
        CALL DBPKTS (IDATE, ITIME, KY(J))
      ELSE IF (CHFOR.EQ.'M') THEN
        NC = LENOCC (CHVAL)
        DO 23 K = 1, NC
          IF (CHVAL(K:K).EQ.' ') THEN
            KK = K
            GO TO 24
          ENDIF
   23   CONTINUE
        KY(J) = 0
        GO TO 25
   24   CONTINUE
        CALL DBCTOI (CHVAL(1:KK-1), IDATE)
        CALL DBCTOI (CHVAL(KK:NC),  ITIME)
        CALL DBPKTM (IDATE, ITIME, KY(J))
      ENDIF
   25 IF (J.LT.NWKYDK) GO TO 5
   30 CONTINUE
*                                                             END DBDCKV
  999 END
+DECK, DBDHEA.
      SUBROUTINE DBDHEA (IOKEY, NK, CHEAD)
*     ====================================
*
************************************************************************
*                                                                      *
*        SUBR. DBDHEA (IOKEY, NK, *CHEAD)                              *
*                                                                      *
*   Writes the Header of the Display in Horizontal Mode into the       *
*   Character Variable CHEAD                                           *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IOKEY    Type of the Key                                         *
*          1 - Binary                                                  *
*          2   Integer                                                 *
*          3   Floating                                                *
*          4   Double Precision (not yet implemented)                  *
*          5   Hollerith                                               *
*          6   Hollerith concatenetad to previous hollerith            *
*          7   Packed integer - time packed upto seconds               *
*          8   Packed integer - time packed upto minutes               *
*          9   Data which should not be displayed                      *
*     NK       Number of Keys                                          *
*     CHEAD    Character variable containing the header                *
*                                                                      *
*   Called by DBDISD, DBDISH                                           *
*                                                                      *
************************************************************************
*
+CDE, DKKEYS.
+CDE, DDISPL.
      DIMENSION       IOKEY(NK)
      CHARACTER       CHEAD*(*)
*
*     ------------------------------------------------------------------
*
      IPOS = 11
      DO 5 I = 1,NK
        IF (IOKEY(I).NE.9) THEN
          NSP = MAX0 ((NUMCDD(I)-8)/2,1)
          IW = IPOS + NSP
          CHEAD(IW:IW+7) = CTAGDK(I)
          IPOS = IPOS + NUMCDD(I)
        ENDIF
    5 CONTINUE
*                                                             END DBDHEA
      END
+DECK, DBDISD.
      SUBROUTINE DBDISD (LUN, PATHN, KEYX, CHOPT)
*     ===========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBDISD (LUN, PATHN, KEYX, CHOPT)                        *
*                                                                      *
*   Display the data attached to the directory PATHN and KEY           *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUN      Unit number of file for display                         *
*     PATHN    Character string describing the pathname                *
*     KEYX     Key-vector                                              *
*     CHOPT    Character option                                        *
*          E   Only example for display to be shown                    *
*                                                                      *
*   Called by DBRDIO                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =101 : Illegal path name                               *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DDISPL.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DXLINK.
      DIMENSION       KEYX(9)
      CHARACTER       PATHN*(*), CHOPT*(*), CHEAD*300
      CHARACTER       PATHY*80, PATHX*16
      CHARACTER       CB*1, CC*1, CI*1, CF*1, DC*4, BLANK*10
      INTEGER         DB, DI
      DATA            CB /'B'/, CC /'H'/, CI /'I'/, CF /'F'/
      DATA            BLANK /' '/
      DATA            DB /101/, DC /'DATA'/, DI /77/, DF /777.777/
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Set the current directory
*
      CALL UOPTC (CHOPT, 'E', IOPTE)
      PATHY  = PATHN
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0)                        GO TO 991
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      ISTP   = NWKYDK + 1
      IF (NKEYDK.GT.0) THEN
        IOPTP  = JBIT (IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB), JPRTDB)
      ELSE
        IOPTP  = 0
      ENDIF
      CALL DBKYTG
*
*  ** Display keys
*
      NCHR   = LEN (PATHN)
      NCH    = INDEX (PATHN, ' ') - 1
      IF (NCH.EQ.0) NCH = NCHR
      WRITE (LUN, 1001) PATHN(1:NCH)
      IF ((IOPTE.NE.0) .OR. (IOPHDD.EQ.0)) THEN
        WRITE (LUN, 1002) CTAGDK(1)
      ELSE
        CHEAD = ' '
        CALL DBDHEA (IOTYDD(1), NWKYDK, CHEAD)
        WRITE (LUN, 1003) CHEAD(1:MXDPDD)
      ENDIF
*
      IF (IOPTE.NE.0) THEN
        CALL DBUPTS (IDV1, ITV1, KEYX(MBVRDB))
        CALL DBUPTS (IDV2, ITV2, KEYX(MEVRDB))
        WRITE (LUN, 1004) IDV1, ITV1, IDV2, ITV2
*
*  **   Write steering lines as format indication
*
        WRITE (LUN, 1005) CB, DB, CC, DC, CI, DI, CF, DF
      ELSE
*
*  **   Read in the data
*
        JBIAS  = 2
        IF (LFRSDX.NE.0) THEN
          CALL MZDROP (IDIVDB, LFRSDX, 'L')
          LFRSDX = 0
        ENDIF
        IF (NKEYDK.EQ.0) THEN
          CALL UCOPY (KEYX, KEYVDK, NWKYDK)
          GO TO 20
        ENDIF
        IF (IOPTP.EQ.0) THEN
          IPNT   = KOFSDB + LCDRDB + IKDRDB
          KPNT   = IUHUNT (KEYX(MSERDB), IQ(IPNT+MSERDB), ISTP*NKEYDK,
     +                     ISTP)
          IF (KPNT.GT.0) THEN
            KEYVDK(MSERDB) = (KPNT - MSERDB) / ISTP + 1
          ELSE
            KEYVDK(MSERDB) = NKEYDK
          ENDIF
        ELSE
          NKEYS  = NKEYDK
          IPNT   = KOFSDB + LCDRDB + IKDRDB
          DO 10 JK = 1, NKEYS
            IK     = NKEYS + 1 - JK
            KPNT   = IUHUNT (IK, IQ(IPNT+MPSRDB), NKEYS*ISTP, ISTP)
            IF (KPNT.GT.0) THEN
              KPNT   = IPNT + KPNT - MPSRDB
            ELSE
              KPNT   = IPNT + (IK - 1) * ISTP
            ENDIF
            IF (IQ(KPNT+MOBJDB).GT.KEYX(MSERDB)) GO TO 10
            CALL DBPATH (PATHX, IK)
            PATHY  = PATHN(1:NCH)//'/'//PATHX
            CALL RZCDIR (PATHY, ' ')
            IF (IQUEST(1).NE.0)                  GO TO 991
            LCDRDB = IQUEST(11)
            IKDRDB = IQUEST(13)
            NKEYDK = IQUEST(7)
            IPNT   = KOFSDB + LCDRDB + IKDRDB
            KPNT   = IUHUNT (KEYX(MSERDB), IQ(IPNT+MSERDB), ISTP*NKEYDK,
     +                       ISTP)
            IF (KPNT.GT.0) THEN
              KEYVDK(MSERDB) = (KPNT - MSERDB) / ISTP + 1
            ELSE
              KEYVDK(MSERDB) = NKEYDK
            ENDIF
            GO TO 15
   10     CONTINUE
        ENDIF
   15   ITIME  = 1
        IOLD1  = IOKYDA(MSERDB)
        IOLDK  = IOPKDA
        IOKYDA(MSERDB) = 1
        IOPKDA = 0
        CALL DBKXIN (ITIME, IDIVDB, LFRSDX, LFRSDX, JBIAS, NWKYDK,
     +               KEYVDK, IPREC)
        IOKYDA(MSERDB) = IOLD1
        IOPKDA = IOLDK
        IF (IOPTP.NE.0) THEN
          IER    = IQUEST(1)
          CALL RZCDIR (PATHN, ' ')
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          NKEYDK = IQUEST(7)
          IQUEST(1) = IER
        ENDIF
*
   20   IF (IOPHDD.EQ.0) THEN
          WRITE (LUN, 1006) KEYX(MSERDB)
        ELSE
          CALL DBDKYH (LUN, NWKYDK, KEYVDK, IOTYDD, ICONDK, IKEY)
        ENDIF
*
*  **   Display data if exists, if it does not, display dummy data
*
        IF ((IQUEST(1).EQ.0) .AND. (IQ(KOFUDB+LFRSDX-1).GT.0)) THEN
          CALL DBWRDP (LUN, LFRSDX)
        ELSE
          WRITE (LUN, 1005) CB, DB, CC, DC, CI, DI, CF, DF
        ENDIF
        IF (LFRSDX.NE.0) THEN
          IER    = IQUEST(1)
          CALL MZDROP (IDIVDB, LFRSDX, ' ')
          IQUEST(1) = IER
        ENDIF
        IF (IQUEST(1).NE.0)                      GO TO 999
      ENDIF
*
      IQUEST(1) = 0
      WRITE (LUN, 1007)
      GO TO 999
*
* *** Error messages
*
  991 IQUEST(1) = 101
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDISD : Illegal '//
     +   'Path Name '//PATHY//''')', IARGDB, 0)
+SELF.
      GO TO 999
*
 1001 FORMAT ('     Data in Directory and Key-Vector'/A)
 1002 FORMAT (/3X,A8,3X)
 1003 FORMAT (/A)
 1004 FORMAT (10X,'Object inserted with validity ',2I8,' to ',2I8)
 1005 FORMAT (1X,A,4X,'1',4X,Z10,10X, 'This line is only an example !'
     +      /,1X,A,4X,'2',4X,A4 ,16X, 'This line is only an example !'
     +      /,1X,A,4X,'3',4X,I10,10X, 'This line is only an example !'
     +      /,1X,A,4X,'4',4X,E12.4,8X,'This line is only an example !')
 1006 FORMAT (I10)
 1007 FORMAT (4X,'We have reached the End of File Position - ',
     +        'do not delete this line !!')
*                                                             END DBDISD
  999 END
+DECK, DBDISH.
      SUBROUTINE DBDISH (LUN, PATHN, MINKY, MAXKY, IFLG, CHOPT)
*     =========================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBDISH (LUN, PATHN, MINKY, MAXKY, IFLG, CHOPT)          *
*                                                                      *
*   Displays the keys in horizontal mode                               *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUN      Unit number of file for display                         *
*     PATHN    Character string describing the pathname                *
*     MINKY    Minimum object number to be displayed (for IFLG=0)      *
*     MAXKY    Maximum object number to be displayed (for IFLG=0)      *
*     IFLG     Flag to decide if objects (=0) or only template (=1)    *
*              to be shown                                             *
*     CHOPT    Character with any of the follwing characters           *
*          K   Display all the keys (Default)                          *
*          U   Display only user keys and validities                   *
*                                                                      *
*   Called by DBDISP                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DDISPL.
+CDE, DLINKS.
+CDE, DKKEYS.
      CHARACTER       PATHN*(*), CHOPT*(*), CHEAD*300
      DIMENSION       IDPFL(100)
*
*     ------------------------------------------------------------------
*
      NCHR   = LEN (PATHN)
      NCH    = INDEX (PATHN, ' ') - 1
      IF (NCH.EQ.0) NCH = NCHR
      WRITE (LUN, 1001) PATHN(1:NCH)
      IF (IFLG.NE.0) GO TO 20
*
* *** Range of the keys to be displayed
*
    5 CONTINUE
      IF (CHOPT.EQ.'U') THEN
        CALL DBDPRG (IDPFL, NWKYDK, 'EDIT')
      ELSE
        CALL DBDPRG (IDPFL, NWKYDK, 'TERM')
      ENDIF
      CALL DBRGCK (IDPFL, NWKYDK, NDISP, IOTYDD)
      IF (NDISP.GT.MXDPDD) THEN
        CALL DBPRNT (LPRTDB, '(''   DBDISH : Not enough space to disp'//
     +       'lay.'',/,''   Enlarge display range by DBSETD or use V-'//
     +       'mode.'')', IARGDB, 0)
        IF (CHOPT.EQ.'U') THEN
          WRITE (LUN, 1002)
          GO TO 999
        ENDIF
        GO TO 5
      ENDIF
*
*  ** Display header with a template
*
      CHEAD  = ' '
      CALL DBDHEA (IOTYDD(1), NWKYDK, CHEAD)
      CALL DBTEMP (IOTYDD(1), NWKYDK, CHEAD)
      WRITE (LUN, 1003) CHEAD(1:MXDPDD)
*
*  ** Display keys
*
      IOLD1  = IOKYDA(MSERDB)
      IOLDK  = IOPKDA
      IOPKDA = 1
      IOKYDA(MSERDB) = 1
      ITIME  = 1
      JBIAS  = 2
      DO 10 IKEY = MINKY, MAXKY
        KEYVDK(MSERDB) = IKEY
        CALL DBKXIN (ITIME, IDISDB, LAUXDL(7), LAUXDL(7), JBIAS, NWKEY,
     +               KEYVDK, IPREC)
        IF (IQUEST(1).EQ.0) THEN
          CALL DBDKYH (LUN, NWKYDK, KEYVDK, IOTYDD, ICONDK, IKEY)
        ENDIF
   10 CONTINUE
*
      IQUEST(1) = 0
      IOKYDA(MSERDB) = IOLD1
      IOPKDA = IOLDK
      WRITE (LUN, 1004)
      GO TO 999
*
* *** Display the template
*
   20 CONTINUE
      CALL DBDPRG (IDPFL, NWKYDK, ' ')
      CALL DBRGCK (IDPFL, NWKYDK, NDISP, IOTYDD)
      IF (NDISP.GT.MXDPDD) THEN
        CALL DBPRNT (LPRTDB, '(''   DBDISH : Not enough space to disp'//
     +       'lay.'',/,''   Enlarge display range by DBSETD or use V-'//
     +       'mode.'')', IARGDB, 0)
        WRITE (LUN, 1002)
        GO TO 999
      ENDIF
*
*  ** Display header
*
        CHEAD = ' '
        CALL DBDHEA (IOTYDD(1), NWKYDK, CHEAD)
        WRITE (LUN, 1003) CHEAD(1:MXDPDD)
*
*  ** Display template
*
      CHEAD  = 'N'
      CHEAD(9:9) = '1'
      CALL DBTEMP (IOTYDD(1), NWKYDK, CHEAD)
      WRITE (LUN, 1003) CHEAD(1:MXDPDD)
      WRITE (LUN, 1005)
      IQUEST(1) = 0
      WRITE (LUN, 1004)
*
 1001 FORMAT ('   Keys in Directory to be displayed/updated: '/A)
 1002 FORMAT ('   DBDISH : Not enough space to display.'
     +       /'   Enlarge display range by DBSETD or use V-mode.')
 1003 FORMAT (/A)
 1004 FORMAT ('    We have reached the End of File Position')
 1005 FORMAT ('    The Directory does not contain any object  '
     +       /'    Insert the value of the keys for the first object'
     +       /'    between the vertical bars on the template')
*                                                             END DBDISH
  999 END
+DECK, DBDISP.
      SUBROUTINE DBDISP (LUN, PATHN, CHOPT)
*     =====================================
*
************************************************************************
*                                                                      *
*        SUBR. DBDISP (LUN, PATHN, *CHOPT*)                            *
*                                                                      *
*   Displays objects attached to the directory PATHN                   *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUN      Unit number of file for display                         *
*     PATHN    Character string describing the pathname                *
*     CHOPT    Character with any of the follwing characters           *
*          K   Display all the keys (Default)                          *
*          U   Display only user keys and validities                   *
*     (*)  I   Display template to type in new keys (Return value)     *
*                                                                      *
*   Called by DBAUXI, DBEDKY, DBPEEK                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =101 : Illegal path name                               *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DDISPL.
+CDE, DKKEYS.
      CHARACTER       PATHN*(*), CHOPT*(*), PATHX*16, CFORM*67
      DATA            MAXLN /1000/
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Set the current directory
*
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0)     GO TO 991
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKYTG
      CALL DBCONC (IOTYDK(1), NWKYDK, ICONDK(1), NSKPDK)
      CALL UCOPY  (IOTYDK(1), IOTYDD(1), NWKYDK)
*
* *** Check the number of keys
*
      IF (NKEYDK.EQ.0) THEN
        IFLG   = 1
      ELSE
        IFLG   = 0
        MINKY  = 1
        IOPTP  = IQ(KOFSDB+LCDRDB+IKDRDB+MFLGDB)
        IOPTP  = JBIT (IOPTP, JPRTDB)
        IF (IOPTP.EQ.0) THEN
          MAXKY  = NKEYDK
        ELSE
          KST    = NWKYDK + 1
          KPNT   = IUHUNT (NKEYDK, IQ(KOFSDB+LCDRDB+IKDRDB+MPSRDB),
     +                     NKEYDK*KST, KST)
          IF (KPNT.GT.0) THEN
            IPNT   = KOFSDB + LCDRDB + IKDRDB + KPNT - MPSRDB
          ELSE
            IPNT   = KOFSDB + LCDRDB + IKDRDB + (NKEYDK - 1) * KST
          ENDIF
          KOBJ   = IQ(IPNT+MOBJDB)
          CALL DBPATH (PATHX, NKEYDK)
          CALL RZCDIR (PATHX, ' ')
          IF (IQUEST(1).NE.0) GO TO 991
          NKEYS  = IQUEST(7)
          MAXKY  = KOBJ + NKEYS
          IF (MAXKY.LE.0) IFLG = 1
          CALL RZCDIR (PATHN, ' ')
          IF (IQUEST(1).NE.0) GO TO 991
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
        ENDIF
        IF (IOPHDD.NE.0) THEN
          LENOB  = MAXKY
        ELSE
          LENOB  = MAXKY * NWKYDK
        ENDIF
        IF (LENOB.GT.MAXLN) THEN
          WRITE (CFORM, 1000) MAXKY
          CALL KUPROI (CFORM, MINKY)
          IF (IOPHDD.NE.0) THEN
            MAXK   = MINKY + MAXLN
          ELSE
            MAXK   = MINKY + MAXLN/NWKYDK
          ENDIF
          MAXKY = MIN0 (MAXKY, MAXK)
        ENDIF
      ENDIF
*
* *** Now display the keys
*
      IF (IOPHDD.NE.0) THEN
        CALL DBDISH (LUN, PATHN, MINKY, MAXKY, IFLG, CHOPT)
      ELSE
        CALL DBDISV (LUN, PATHN, MINKY, MAXKY, IFLG, CHOPT)
      ENDIF
      IQUEST(1) = 0
      IF (IFLG.EQ.1) CHOPT = 'I'
      GO TO 999
*
* *** Error messages
*
  991 IQUEST(1) = 101
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) THEN
        CFORM  = PATHN
        CALL DBPRNT (LPRTDB, '(/,'' DBDISP : Illegal Path Name '//CFORM
     +       //''')', IARGDB, 0)
      ENDIF
+SELF.
      GO TO 999
*
 1000 FORMAT ('Directory too Long --',I10,' Objects - First Object to'
     +,' Display ?')
*                                                             END DBDISP
  999 END
+DECK, DBDISV.
      SUBROUTINE DBDISV (LUN, PATHN, MINKY, MAXKY, IFLG, CHOPT)
*     =========================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBDISV (LUN, PATHN, MINKY, MAXKY, IFLG, CHOPT)          *
*                                                                      *
*   Displays the keys in vertical mode                                 *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUN      Unit number of file for display                         *
*     PATHN    Character string describing the pathname                *
*     MINKY    Minimum object number to be displayed (for IFLG=0)      *
*     MAXKY    Maximum object number to be displayed (for IFLG=0)      *
*     IFLG     Flag to decide if objects (=0) or only template (=1)    *
*              to be shown                                             *
*     CHOPT    Character with any of the follwing characters           *
*          K   Display all the keys (Default)                          *
*          U   Display only user keys and validities                   *
*                                                                      *
*   Called by DBDISP                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DDISPL.
+CDE, DLINKS.
+CDE, DKKEYS.
      CHARACTER       DEFST(7)*20, CHPRT*40, CFORS(7)*1, CFOR*1
      CHARACTER       PATHN*(*), CHOPT*(*)
*
      DATA         DEFST /'                    ','                    '
     +                   ,'800000          0   ','991231     235959   ',
     +                    '     1              ','                    ',
     +                    '                    '/
      DATA            CHPRT /'  Object Number :               ==>    D'/
      DATA            CFORS  /'U', 'U', 'S', 'S', 'I', 'U', 'U'/
*
*     ------------------------------------------------------------------
*
      NCHR   = LEN (PATHN)
      NCH    = INDEX (PATHN, ' ') - 1
      IF (NCH.EQ.0) NCH = NCHR
      WRITE (LUN, 1001) PATHN(1:NCH)
      IF (IFLG.NE.0)     GO TO 20
*
*  ** Display keys
*
      IOTYDD(MBVRDB) = 7
      IOTYDD(MEVRDB) = 7
      IOTYDD(MITMDB) = 8
      IF (CHOPT.EQ.'U') THEN
        IOTYDD(MSERDB) = 9
        IOTYDD(MUPNDB) = 9
        IOTYDD(MFLGDB) = 9
      ENDIF
*
      CHPRT(40:40) = 'D'
      IOLD1  = IOKYDA(MSERDB)
      IOLDK  = IOPKDA
      IOPKDA = 1
      IOKYDA(MSERDB) = 1
      ITIME  = 1
      JBIAS  = 2
      DO 10 IKEY = MINKY, MAXKY
        KEYVDK(MSERDB) = IKEY
        CALL DBKXIN (ITIME, IDISDB, LAUXDL(7), LAUXDL(7), JBIAS, NWKEY,
     +               KEYVDK, IPREC)
        IF (IQUEST(1).EQ.0) THEN
          WRITE (CHPRT(21:30), 1002) IKEY
          WRITE (LUN, 1003) CHPRT
          CALL DBDKYV (LUN, NWKYDK, CTAGDK, KEYVDK, IOTYDD, ICONDK)
        ENDIF
   10 CONTINUE
*
      IQUEST(1) = 0
      IOKYDA(MSERDB) = IOLD1
      IOPKDA = IOLDK
      WRITE (LUN, 1004)
      GO TO 999
*
* *** No keys prepare the template
*
   20 IKEY = 1
      CHPRT(40:40) = 'N'
      WRITE (CHPRT(21:30), 1002) IKEY
      WRITE (LUN, 1003) CHPRT
      DO 25 IPR = 1, 7
        WRITE (LUN, 1005) CTAGDK(IPR), CFORS(IPR), DEFST(IPR)
   25 CONTINUE
      IPR  = 7
   30 CONTINUE
      IPR  = IPR + 1
      IF (IPR.GT.NWKYDK) GO TO 35
      CFOR = 'I'
      IF (IOTYDK(IPR).EQ.1) CFOR = 'B'
      IF (IOTYDK(IPR).EQ.5) CFOR = 'H'
      WRITE (LUN, 1005) CTAGDK(IPR), CFOR
      IF (CFOR.EQ.'H') THEN
        NREP = ICONDK(IPR)
        IPR  = IPR + NREP
      ENDIF
      GO TO 30
   35 WRITE (LUN, 1006)
      IQUEST(1) = 0
*
 1001 FORMAT ('   Keys in Directory to be displayed/updated: '/A)
 1002 FORMAT (I10)
 1003 FORMAT (A)
 1004 FORMAT ('    We have reached the End of File Position')
 1005 FORMAT ('  ',A8,'  ',A1,'                ',A)
 1006 FORMAT ('   The Directory does not contain any object - '
     +       /'  The above line contains the default values for the'
     +       /'  system keys and a format specification for the others')
*                                                             END DBDISV
  999 END
+DECK, DBDKYH.
      SUBROUTINE DBDKYH (LUN, NW, KY, KT, ICON, IKEY)
*     ===============================================
*
************************************************************************
*                                                                      *
*        SUBR. DBDKYH (LUN, NW, KY, KT, ICON, IKEY)                    *
*                                                                      *
*   Displays a vector KY of elements NW according to its type KT       *
*   in Horizontal Mode                                                 *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUN      Unit number of the file on which to display             *
*     NW       Number of elements in the array KY (and KT)             *
*     KY       Vector to be printed                                    *
*     KT       Type of the vector elements                             *
*          1 - Binary                                                  *
*          2   Integer                                                 *
*          3   Floating                                                *
*          4   Double Precision (not yet implemented)                  *
*          5   Hollerith                                               *
*          6   Hollerith concatenetad to previous hollerith            *
*          7   Packed integer - time packed upto seconds               *
*          8   Packed integer - time packed upto minutes               *
*          9   Data which should not be displayed                      *
*     ICON     Number of keys concatenated to the present one          *
*     IKEY     Serial number of the key to be displayed                *
*                                                                      *
*   Called by DBDISD, DBDISH, DBPRES                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =103 : Illegal data type                               *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DDISPL.
+CDE, DKKEYS.
      CHARACTER       CHPRT*300, CFORM*5
      DIMENSION       KY(9), KT(9), ICON(9)
*
*     ------------------------------------------------------------------
*
      CHPRT = ' '
      IF (IKEY.GT.0) THEN
         WRITE (CHPRT(2:9), 1001) IKEY
      ENDIF
      I1    = 11
      DO 10 I = 1, NW
        KK    = KT(I)
        IF (KK.LT.1.OR.KK.EQ.4.OR.KK.GT.9) GO TO 901
        GO TO (1,2,10,10,5,10,7,8,10), KK
    1   CONTINUE
*
*  **   Binary
*
        I1 = I1 + 1
        I2 = I1 + NUMCDD(I) - 3
        CFORM(1:2) = '(Z'
        CFORM(5:5) = ')'
        WRITE (CFORM(3:4), 1002) NUMCDD(I)-2
        WRITE (CHPRT(I1:I2), CFORM) KY(I)
        I1 = I2 + 2
        GO TO 10
    2   CONTINUE
*
*  **   Integer
*
        I1 = I1 + 1
        I2 = I1 + NUMCDD(I) - 3
        CFORM(1:2) = '(I'
        CFORM(5:5) = ')'
        WRITE (CFORM(3:4), 1002) NUMCDD(I)-2
        WRITE (CHPRT(I1:I2), CFORM) KY(I)
        I1 = I2 + 2
        GO TO 10
    5   CONTINUE
*
*  **   Hollerith
*
        IREP = ICON(I) + 1
        I1 = I1 + 1
        DO 6 J = 1, IREP
          I2 = I1 + 3
          IF (IREP.EQ.1) THEN
             I1 = I1 + 2
             I2 = I2 + 2
          ENDIF
          WRITE (CHPRT(I1:I2), 1003) KY(I+J-1)
          I1 = I2 + 1
    6   CONTINUE
        I1 = I1 + 1
        GO TO 10
    7   CONTINUE
*
*  **   Packed Integer (upto seconds)
*
        CALL DBUPTS (IDATE, ITIME, KY(I))
        I1 = I1 + 1
        I2 = I1 + 5
        WRITE (CHPRT(I1:I2), 1004) IDATE
        I1 = I2 + 2
        I2 = I1 + 5
        WRITE (CHPRT(I1:I2), 1004) ITIME
        I1 = I2 + 2
        GO TO 10
    8   CONTINUE
*
*  **   Packed Integer (upto minutes)
*
        CALL DBUPTM (IDATE, ITIME, KY(I))
        I1 = I1 + 1
        I2 = I1 + 5
        WRITE (CHPRT(I1:I2), 1004) IDATE
        I1 = I2 + 2
        I2 = I1 + 5
        WRITE (CHPRT(I1:I2), 1004) ITIME
        I1 = I2 + 2
        GO TO 10
*
   10 CONTINUE
      WRITE (LUN, 2001) CHPRT(1:MXDPDD)
      IQUEST(1) = 0
      GO TO 999
*
* *** Error codes
*
  901 IQUEST(1) = 103
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDKYH : Illegal '//
     +   'data type to be printed = '',I10,/)', KK, 1)
+SELF.
*
 1001 FORMAT (I8)
 1002 FORMAT (I2)
 1003 FORMAT (A4)
 1004 FORMAT (I6)
 2001 FORMAT (A)
*                                                             END DBDKYH
  999 END
+DECK, DBDKYV.
      SUBROUTINE DBDKYV (LUN, NW, CT, KY, KT, ICON)
*     =============================================
*
************************************************************************
*                                                                      *
*        SUBR. DBDKYV (LUN, NW, CT, KY, KT, ICON)                      *
*                                                                      *
*   Displays a vector KY of elements NW according to its type KT       *
*   in Vertical Mode (Concatenated keys are printed in 1 line)         *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUN      Unit number of the file on which to display             *
*     NW       Number of elements in the array KY (and KT)             *
*     CT       Character-Name of the Key to be printed                 *
*     KY       Vector to be printed                                    *
*     KT       Type of the vector elements                             *
*          1 - Binary                                                  *
*          2   Integer                                                 *
*          3   Floating                                                *
*          4   Double Precision (not yet implemented)                  *
*          5   Hollerith                                               *
*          6   Hollerith concatenetad to previous hollerith            *
*          7   Packed integer - time packed upto seconds               *
*          8   Packed integer - time packed upto minutes               *
*          9   Data which should not be displayed                      *
*     ICON     Number of keys concatenated to the present one          *
*                                                                      *
*   Called by DBDISV, DBPEEK, DBPRES                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =103 : Illegal data type                               *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
      CHARACTER       CHPRT*80, CT(*)*8
      DIMENSION       KY(9), KT(9), ICON(9)
*
*     ------------------------------------------------------------------
*
      CHPRT = ' '
      I = 1
   15 CONTINUE
        CHPRT = ' '
        I1 = 20
        CHPRT(3:10) = CT(I)
        KK    = KT(I)
        IF (KK.EQ.6) KK = 5
        IF (KK.LT.1.OR.KK.EQ.4.OR.KK.GT.9) GO TO 901
        GO TO (1,2,3,4,5,5,7,8,9), KK
    1   CONTINUE
*
*  **   Binary
*
        CHPRT(13:13) = 'B'
        I1 = I1 + 2
        I2 = I1 + 9
        WRITE (CHPRT(I1:I2), 1001) KY(I)
        I = I + 1
        GO TO 10
    2   CONTINUE
*
*  **   Integer
*
        CHPRT(13:13) = 'I'
        I1 = I1 + 2
        I2 = I1 + 9
        WRITE (CHPRT(I1:I2), 1002) KY(I)
        I = I + 1
        GO TO 10
    3   CONTINUE
*
*  **   Floating
*
        CHPRT(13:13) = 'F'
        I1 = I1 + 1
        I2 = I1 + 11
        WRITE (CHPRT(I1:I2), 1003) KY(I)
        I = I + 1
        GO TO 10
    4   CONTINUE
        GO TO 901
    5   CONTINUE
*
*  **   Hollerith
*
         CHPRT(13:13) = 'H'
         I1 = I1 + 5
         I2 = I1 + 3
         WRITE (CHPRT(I1:I2), 1005) KY(I)
         I = I + 1
*          Is Key  concatenated with the next one ?
         NCONC = ICON(I-1)
         IF (NCONC.EQ.0)                   GO TO 10
         DO 51 J = 1, NCONC
            I1 = I2 + 1
            I2 = I1 + 3
            WRITE (CHPRT(I1:I2), 1005) KY(I)
            I = I + 1
   51    CONTINUE
         GO TO 10
    7   CONTINUE
*
*  **   Packed Integer - Time packed upto seconds
*
        CHPRT(13:13) = 'S'
        CALL DBUPTS (IDATE, ITIME, KY(I))
        I1 = I1 + 2
        I2 = I1 + 9
        WRITE (CHPRT(I1:I2), 1002) IDATE
        I1 = I2 + 2
        I2 = I1 + 9
        WRITE (CHPRT(I1:I2), 1002) ITIME
        I = I + 1
        GO TO 10
    8   CONTINUE
*
*  **   Packed Integer - Time packed upto minutes
*
        CHPRT(13:13) = 'M'
        CALL DBUPTM (IDATE, ITIME, KY(I))
        I1 = I1 + 2
        I2 = I1 + 9
        WRITE (CHPRT(I1:I2), 1002) IDATE
        I1 = I2 + 2
        I2 = I1 + 9
        WRITE (CHPRT(I1:I2), 1002) ITIME
        I = I + 1
        GO TO 10
    9   CONTINUE
*
*  **   Key_value should not be visible
*
        CHPRT = ' '
        CHPRT(13:13) = 'U'
        I = I + 1
        GO TO 10
*
   10 CONTINUE
      WRITE (LUN, 2001) CHPRT
      IF (I.LE.NW)                         GO TO 15
      IQUEST(1) = 0
      GO TO 999
*
* *** Error codes
*
  901 IQUEST(1) = 103
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBDKYV : Illegal '//
     +   'data type to be printed = '',I10,/)', KK, 1)
+SELF.
*
 1001 FORMAT (Z10)
 1002 FORMAT (I10)
 1003 FORMAT (E12.4)
 1005 FORMAT (A4)
 2001 FORMAT (A)
*                                                             END DBDKYV
  999 END
+DECK, DBDPRG.
      SUBROUTINE DBDPRG (KDISP, NK, CHOPT)
*     ====================================
*
************************************************************************
*                                                                      *
*        SUBR. DBDPRG (*KDISP, NK, CHOPT)                              *
*                                                                      *
*   Sets flag to keys to be displayed (requested by the user)          *
*      in Horizontal Mode                                              *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     KDISP    Key Flag = 0 for No Display, = 1 for Key to be displayed*
*     NK       Number of Keys                                          *
*     CHOPT    Character string specifying following options           *
*        TERM  Range of keys requested from terminal                   *
*                                                                      *
*   Called by DBDISH                                                   *
*                                                                      *
************************************************************************
*
+CDE, DCONCT.
+CDE, DKKEYS.
      CHARACTER       CRANG*80, CUSE*2, CHOPT*(*)
      DIMENSION       KDISP (NK)
*
*     ------------------------------------------------------------------
*
      CALL VZERO (KDISP, NK)
*
      IF (CHOPT.EQ.'TERM') THEN
        CALL KUPROC ('Range of Keys to display: K1-K2,K3-K4,..',
     +              CRANG, LCRNG)
      ELSE IF (CHOPT.EQ.'EDIT') THEN
        WRITE (CUSE, '(I2)') IUSEDC(NK)
        CRANG = '3-5,8-'//CUSE
        LCRNG = 8
      ELSE
        WRITE (CUSE, '(I2)') IUSEDC(NK)
        CRANG = '3-5,8-'//CUSE
        LCRNG = 8
      ENDIF
      IF ((CRANG.EQ.' ') .OR. (LCRNG.EQ.0)) GO TO 20
      NUMB = 0
      NUMB1 = 0
      NUMB2 = 0
      I = 0
    5 CONTINUE
      I = I + 1
      IF ((I.LE.LCRNG) .AND. (CRANG(I:I).EQ.','.OR.CRANG.EQ.' ')
     +  .OR. (I.GT.LCRNG)) THEN
        IF (NUMB.NE.0) THEN
          IF (NUMB1.EQ.0) THEN
            NUMB1 = NUMB
          ELSE
            NUMB2 = NUMB
          ENDIF
          IF (NUMB2.LT.NUMB1) NUMB2 = NUMB1
          NUMB2 = MIN0 (NUMB2, NK)
          NUMBF = ISYSDC(NUMB1)
          NUMBL = ISYSDC(NUMB2)
          NUMBL = NUMBL + ICONDK(NUMBL)
          DO 10 J = NUMBF, NUMBL
   10     KDISP(J) = 1
          NUMB = 0
          NUMB1 = 0
          NUMB2 = 0
        ENDIF
      ELSE IF (CRANG(I:I).EQ.'-') THEN
        NUMB1 = NUMB
        NUMB = 0
      ELSE
        READ (CRANG(I:I), '(I1)') IMANT
        IF (IMANT.GE.0.AND.IMANT.LE.9) THEN
          NUMB = NUMB*10 + IMANT
        ENDIF
      ENDIF
      IF (I.LE.LCRNG)                       GO TO 5
      GO TO 999
   20 CONTINUE
      DO 30 I = 1, NK
   30 KDISP(I) = 1
      GO TO 999
*                                                             END DBDPRG
  999 END
+DECK, DBEDAS.
      SUBROUTINE DBEDAS (CFNAM, NCF, PATHN)
*     =====================================
*
************************************************************************
*                                                                      *
*        SUBR. DBEDAS (CFNAM, NCF, PATHN)                              *
*                                                                      *
*   Routine to insert objects from a pre-edited ascii file             *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     CFNAM    Character string describing the name of the file used   *
*              for the editing                                         *
*     NCF      Number of characters in the string CFNAM                *
*     PATHN    Character string describing the pathname                *
*                                                                      *
*   Called by DBAUXI                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =101 : Illegal path name                               *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DDISPL.
+CDE, DLINKS.
+CDE, DKKEYS.
+CDE, DXLINK.
      CHARACTER       CFNAM*(*), PATHN*(*), STRFL*300
      CHARACTER       CHOPT*4, YESNO*1
      DIMENSION       KEYS(MXDMDK), KEYO(MXDMDK)
*
*     ------------------------------------------------------------------
*
* *** Set the current directory
*
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0)        GO TO 991
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKYTG
      IF (IQUEST(1).NE.0)        GO TO 999
      CALL DBCONC (IOTYDK(1), NWKYDK, ICONDK(1), NSKPDK)
*
      CALL KUPROC ('Data is to be inserted ? (Y/N) ', YESNO, LYN)
      IF (YESNO.EQ.'Y') THEN
        CHOPT  = 'IAD'
      ELSE
        CHOPT  = 'IAW'
      ENDIF
      CALL DBOPEN (LUKYDX, CFNAM, 'OLD', ISTAT)
      IF (ISTAT.NE.0)            GO TO 999
      CALL KUPROC ('Horizontal or Vertical Mode ? (H/V) ', YESNO, LYN)
      IF (YESNO.EQ.'H') THEN
        CHOPT(4:4) = 'H'
        READ (LUKYDX, 1001, ERR=20, END=20)
        CALL VZERO (KEYO, NWKYDK)
*
   10   CONTINUE
        READ (LUKYDX, CFMTDD, ERR=20, END=20) STRFL(1:MXDPDD)
        IF (STRFL(1:20).EQ.' ') THEN
          GO TO 20
        ELSE IF (STRFL(1:1).EQ.'D') THEN
*
*  **     The object is to be inserted
*
          CALL VZERO (KEYS, NWKYDK)
          CALL DBDCKH (STRFL, KEYS(1), IKEY)
          KEYS(MSERDB) = IKEY
          CALL DBUPKY (KEYS, KEYO, PATHN, CHOPT)
          IF (IQUEST(1).NE.0)    GO TO 20
        ENDIF
        GO TO 10
      ELSE
        CHOPT(4:4) = 'V'
        CALL VZERO (KEYS, NWKYDK)
        READ (LUKYDX, 1002, ERR=20, END=20)
   15   CONTINUE
        READ (LUKYDX, '(A80)', ERR=20, END=20) STRFL(1:80)
        IF (STRFL(40:40).NE.'D') GO TO 20
        READ (STRFL(21:30), 1004, ERR=20) KEYS(MSERDB)
        CALL DBDCKV (LUKYDX, ICONDK(1), KEYS(1))
        CALL DBUPKY (KEYS, KEYO, PATHN,  CHOPT)
        IF (IQUEST(1).NE.0)      GO TO 20
        GO TO 15
      ENDIF
*
   20 CALL DBCLOS (LUKYDX)
      GO TO 999
*
* *** Error messages
*
  991 IQUEST(1) = 101
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) THEN
        STRFL  = PATHN
        CALL DBPRNT (LPRTDB, '(/,'' DBEDAS : Illegal Path Name '//
     +       STRFL(1:80)//''')', IARGDB, 0)
      ENDIF
+SELF.
      GO TO 999
*
 1001 FORMAT (///)
 1002 FORMAT (/)
 1003 FORMAT (A)
 1004 FORMAT (I10)
*                                                             END DBEDAS
 999  END
+DECK, DBEDKY.
      SUBROUTINE DBEDKY (CFNAM, NCF, PATHN, CHOPT)
*     ============================================
*
************************************************************************
*                                                                      *
*        SUBR. DBEDKY (CFNAM, NCF, PATHN)                              *
*                                                                      *
*   Edits keys and data in an interactive session                      *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     CFNAM    Character string describing the name of the file used   *
*              for editing                                             *
*     NCF      Number of characters in the string CFNAM                *
*     PATHN    Character string describing the pathname                *
*     CHOPT    Character with any of the follwing characters           *
*          A   ASCII type data                                         *
*          S   Standard ZEBRA data bank (default)                      *
*                                                                      *
*   Called by DBAUXI                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DDISPL.
+CDE, DLINKS.
+CDE, DKKEYS.
+CDE, DXLINK.
      CHARACTER       CFNAM*(*), PATHN*(*), CHOP1*1, CHOP2*1, CHOP0*4
      CHARACTER       CHSLA*100, STRFL*300, CHOPT*(*), CFMT*20
      DIMENSION       KEYS(MXDMDK), KEYO(MXDMDK), IOPTS(2)
      EQUIVALENCE     (IOPTS(1), IOPA), (IOPTS(2), IOPS)
*
*     ------------------------------------------------------------------
*
* *** Open the file for editing
*
      CALL DBOPEN (LUKYDX, CFNAM, 'UNKNOWN', ISTAT)
      CHOP1   = 'U'
      IF (ISTAT.NE.0)       GO TO 999
      IF (IOPHDD.NE.0) THEN
        IMAX   = MXDPDD
        IMRK   = 1
        I1     = 2
        I2     = 9
        CFMT   = CFMTDD
      ELSE
        IMAX   = 80
        IMRK   = 40
        I1     = 23
        I2     = 30
        CFMT   = '(A80)'
      ENDIF
      CALL DBDISP (LUKYDX, PATHN, CHOP1)
      IERR   = IQUEST(1)
      CALL DBCLOS (LUKYDX)
      CALL UOPTC (CHOPT, 'AS', IOPTS)
      IF (IERR.NE.0)        GO TO 999
      CALL KUEDIT (CFNAM, IST)
*
* *** Read back the edited file
*
      CALL DBOPEN (LUKYDX, CFNAM, 'OLD', ISTAT)
      IF (ISTAT.NE.0)       GO TO 999
      CHOP2  = ' '
      CALL VZERO (KEYO, MXDMDK)
      CHSLA  = ' '
      IF (IOPHDD.NE.0) THEN
        READ (LUKYDX, 1001, ERR=20, END=20)
      ELSE
        READ (LUKYDX, 1002, ERR=20, END=20)
        NINCR  = NWKYDK - NSKPDK - 1
        CHSLA(1:1) = '('
        CHSLA(NINCR+2:NINCR+2) = ')'
        DO 5 I = 1, NINCR
    5   CHSLA(I+1:I+1) = '/'
      ENDIF
*
   10 CONTINUE
      READ (LUKYDX, CFMT, ERR=20, END=20) STRFL(1:IMAX)
      IF ((IOPHDD.NE.0) .AND. (STRFL(1:20).EQ.' ')) THEN
        GO TO 20
      ELSE IF ((IOPHDD.EQ.0) .AND. (STRFL(IMRK:IMRK).EQ.'D')) THEN
        READ (LUKYDX, CHSLA(1:NINCR+2), ERR=20, END=20)
        GO TO 10
      ELSE IF (STRFL(IMRK:IMRK).EQ.'N') THEN
*
*  **   The object is to be inserted
*
        CALL VZERO (KEYS, NWKYDK)
        IF (IOPHDD.NE.0) THEN
          CALL DBDCKH (STRFL, KEYS(1), IKEY)
          KEYS(MSERDB) = IKEY
          CHOP0   = 'V'
        ELSE
          READ (STRFL(21:30), 1004, ERR=20) KEYS(MSERDB)
          CALL DBDCKV (LUKYDX, ICONDK(1), KEYS(1))
          CHOP0   = 'H'
        ENDIF
        IF (CHOP1.EQ.'I') THEN
          CHOP0  = CHOP0(1:1)//'EI'
        ELSE IF (CHOP2.EQ.'X') THEN
          CHOP0  = CHOP0(1:1)//CHOP2
        ELSE
          CHOP0  = CHOP0(1:1)//'I'
        ENDIF
        IF (IOPA.EQ.0) THEN
          CALL DBUPKY (KEYS, KEYO, PATHN, CHOP0)
        ELSE
          CALL DBAIWR (KEYS, KEYO, PATHN, CHOP0)
        ENDIF
        IF (IQUEST(1).NE.0) GO TO 20
        GO TO 10
      ELSE IF (STRFL(IMRK:IMRK).EQ.'R') THEN
*
*  **   An existing object is modified
*
        READ (STRFL(I1:I2), 1005, ERR=20) KEYO(MSERDB)
        IOLD1  = IOKYDA(MSERDB)
        IOLDK  = IOPKDA
        ITIME  = 1
        JBIAS  = 2
        IOPKDA = 1
        IOKYDA(MSERDB) = 1
        CALL DBKXIN (ITIME, IDISDB, LAUXDL(7), LAUXDL(7), JBIAS, NWKEY,
     +               KEYO, IPREC)
        IOPKDA = IOLDK
        IOKYDA(MSERDB) = IOLD1
        CHOP2  = 'X'
        IF (IOPHDD.EQ.0) READ (LUKYDX, CHSLA(1:NINCR+2), ERR=20, END=20)
        GO TO 10
      ELSE IF (IOPHDD.NE.0) THEN
        GO TO 10
      ENDIF
*
   20 CALL DBCLOS (LUKYDX)
*
 1001 FORMAT (///)
 1002 FORMAT (/)
 1003 FORMAT (A)
 1004 FORMAT (I10)
 1005 FORMAT (I8)
*                                                             END DBEDKY
  999 END
+DECK, DBFTIO.
      SUBROUTINE DBFTIO (IODV, CHIDH)
*     ===============================
*
************************************************************************
*                                                                      *
*        SUBR. DBFTIO (IODV, CHIDH*)                                   *
*                                                                      *
*   Routine to fetch the I/O characteristic of a bank from             *
*   the IODV words into the character string CHIDH                     *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IODV     I/O word of the bank                                    *
*     CHIDH    I/O characteristics of the bank                         *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
************************************************************************
*
+CDE, ZBCD, ZUNIT, QUEST, MZIOC.
C-------------------------  CDE  -----------------------------------
 
      CHARACTER       CHIDH*(*)
      DIMENSION       IODV(20), MTR(500), INV(7)
      DATA  INV       / 2, 9, 6, 4, 8, 24, 19 /
*
      CALL MZIOCR (IODV)
*
      JT = 1
   21 IF (JFOCUR.EQ.JFOREP)  THEN
        MTR(JT)   = IQSLAS
        MTR(JT+1) = 0
        JT = JT + 2
      ENDIF
*
      JF = MFO(JFOCUR+1)
      JC = MFO(JFOCUR+2)
*
      IF    (JC)             24, 25, 26
   24 MTR(JT) = IQMINS
      JT = JT + 1
      GO TO 28
*
   25 MTR(JT) = IQSTAR
      JT = JT + 1
      GO TO 28
*
   26 CALL USET (JC,MTR(JT),1,6)
      JT = JT + 6
*
   28 JF = INV(JF)
      MTR(JT)   = IQLETT(JF)
      MTR(JT+1) = 0
      JT = JT + 2
 
      JFOCUR = JFOCUR + 2
      IF (JFOCUR.LT.JFOEND)  GO TO 21
*
      JT = JT - 2
      CALL ULEFT (MTR,1,JT)
      NT = IULAST (IQBLAN,MTR,JT)
*
      DO 33 JT=1,NT
      IF (MTR(JT).NE.0)      GO TO 33
      MTR(JT) = IQBLAN
   33 CONTINUE
      CALL UH1TOC (MTR, CHIDH, NT)
*                                                             END DBFTIO
   99 END
+DECK, DBJOIN.
      SUBROUTINE DBJOIN (PATHN, IDATM, NI, NOBI, CHTI, IOTI, ICONI,
     +                           KEYI, NO, NOBO, CHTO, IOTO, ICONO)
*     =============================================================
*
************************************************************************
*                                                                      *
*        SUBR.DBJOIN (PATHN, IDATM, NI, NOBI, CHTI, IOTI, ICONI,       *
*                            KEYI, NO*, NOBO*, CHTO*, IOTO*, ICONO)    *
*                                                                      *
*   Routine to Join a Table of Name PATHN                              *
*   The values of the Keys to be presented can be found at             *
*                 IQ(LJOIDX+1,..,NO,NO+1,...,NO*NOBO)                  *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Pathname of the Table                                   *
*     IDATM    Packed Date and Time (or Run #) at which the table is   *
*              valid                                                   *
*     NI       Number of Coloumns to join                              *
*     NOBI     Number of Rows (Data) to join                           *
*     CHTI     Name of Keys to which to join                           *
*     IOTI     Type of Keys to which to join                           *
*     ICONI    Number of concatenated keys to join                     *
*     KEYI     Value of Keys to which to join                          *
*     NO       Number of Keys to be Presented                          *
*     NOBO     Number of Objects to be presented                       *
*     CHTO     Name of Keys used for Presentation                      *
*     IOTO     Type of Keys used for Presentation                      *
*     ICONO    Number of concatenated keys to present                  *
*                                                                      *
*   Called by DBVIEW                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =101 : Illegal path name                               *
*               =102 : No key or data for the path name                *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DLINKS.
+CDE, DKKEYS.
+CDE, DVIEWS.
+CDE, DXLINK.
      DIMENSION       IOTI(NI), IOTO(9), KEYI(NI, NOBI)
      DIMENSION       ICONI(9), ICONO(9), IFLAG(100)
      CHARACTER       PATHN*(*), CHTI(NI)*8, CHTO(*)*8, CHTG(100)*8
      CHARACTER       CHOPT*40, KYNAM*8, KYVAL*20, BLANK*20, PATHY*80
      CHARACTER       KY10*10, CHPRO*50
      DATA            BLANK /' '/
*
*     ------------------------------------------------------------------
*
* *** Set the current directory
*
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0)   GO TO 991
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      IF (NWKYDK.LE.NSYSDK) GO TO 992
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKYTG
      IF (IQUEST(1).NE.0)   GO TO 999
*
*  ** Fill concatenation flag (if non-zero: number of concatenated keys
*
      CALL DBCONC (IOTYDK(1), NWKYDK, ICONDK(1), NSKPDK)
*
*  ** Get the Coloumn Names in the Table to Join
*
      CALL VZERO (IFKYDV, NWKYDK)
      CALL VZERO (IFLAG, NWKYDK)
      I = 1
    1 CONTINUE
      I = I + 1
      IF (I.GT.NI)          GO TO 7
    2 CONTINUE
      I1 = I-1
      CHPRO = 'Give name for '//CHTI(I)
      CALL KUPROC (CHPRO(1:23), CHTG(I1), LCHT)
      IOTYDV(I1) = IOTI(I)
      DO 3 J = NSYSDK+1, NWKYDK
        IF (CHTG(I1).EQ.CTAGDK(J)) THEN
          JST = J
          IFKYDV(I1) = J
          IC = 2*I1
          WRITE (CHOPT(IC-1:IC), 1001) J
          GO TO 5
        ENDIF
    3 CONTINUE
      GO TO 2
    5 CONTINUE
      IF (ICONI(I).EQ.0)    GO TO 1
      NREP = ICONI(I)
      DO 6 J = 1, NREP
        I = I + 1
        K = JST + J
        I1 = I - 1
        IC = IC + 2
        IFKYDV(I1) = K
        IFLAG(K) = 1
        WRITE (CHOPT(IC-1:IC), 1001) K
        IOTYDV(I1) = IOTYDK(K)
        CHTG(I1) = CTAGDK(K)
    6 CONTINUE
      GO TO 1
    7 CONTINUE
*
*  ** Get additional Key-Names and Key-Values to Search
*
      CALL VZERO (KEYSDV, NWKYDK)
      IK = NI-1
   10 CONTINUE
      CALL KUPROC ('Key-Name to Search (if no more - |) ?', KYNAM, LKEY)
      IF (KYNAM.EQ.'|')     GO TO 20
      I = NSYSDK+1
   11 IF (I.GT.NWKYDK)      GO TO 13
      IF (KYNAM.EQ.CTAGDK(I).AND.IFLAG(I).EQ.0) THEN
        IFLAG(I) = 1
        IKEY = I
        IK = IK + 1
        IC = 2*IK
        IFKYDV(IK) = I
        WRITE (CHOPT(IC-1:IC), 1001) I
        CHTG(IK)   = CTAGDK(I)
        IOTYDV(IK) = IOTYDK(I)
        ICONI(IK)  = ICONDK(I)
        NREP = 0
        IF (ICONI(IK).GT.0) THEN
          NREP = ICONI(IK)
          DO 12 J = 1, NREP
            I = I + 1
            IC = IC + 2
            IFKYDV(IK+J) = I
            WRITE (CHOPT(IC-1:IC), 1001) I
            CHTG(IK+J)   = CTAGDK(I)
            IOTYDV(IK+J) = IOTYDK(I)
            ICONI(IK+J)  = ICONDK(I)
            IFLAG(I)     = 1
   12     CONTINUE
        ENDIF
        GO TO 15
      ENDIF
      I = I + 1
      GO TO 11
   13 CONTINUE
      GO TO 10
   15 CONTINUE
      CALL KUPROC ('Key-Value ?', KYVAL, LKEY)
      IF (IOTYDK(IKEY).EQ.5) THEN
*  *        Hollerith
        LCDAT = (NREP+1)*4
        CALL UCTOH (KYVAL(1:LCDAT), KEYSDV(IKEY), 4, LCDAT)
        IK = IK + NREP
      ELSE IF (IOTYDK(IKEY).EQ.2) THEN
*  *        Integer
        LEN  = MIN (10,LKEY)
        KY10 = BLANK(1:10-LEN)//KYVAL(1:LEN)
        READ (KY10(1:10), 1002) KEYSDV(IKEY)
      ELSE IF (IOTYDK(IKEY).EQ.1) THEN
*  *        Bit-string
        LEN  = MIN (8,LKEY)
        KY10 = BLANK(1:8-LEN)//KYVAL(1:LEN)
        READ (KY10(1:8), 1003) KEYSDV(IKEY)
      ENDIF
      GO TO 10
   20 CONTINUE
*  *        Variable data-length and Search Options in CHOPT
      CHOPT(IC+1:IC+2) = 'VS'
*
*  ** Loop on Input Objects
*
      LKJNDX(1) = 0
      LKJNDX(2) = 0
      DO 23 I = 1, NOBI
*    *      Key-Vector for DBUSE
        DO 22 J = 2, NI
          INDX = IFKYDV(J-1)
*    *  The following equality can be later replaced by other relation:
          KEYSDV(INDX) = KEYI(J,I)
   22   CONTINUE
*
        IF (I.EQ.1) THEN
          CALL DBUSE (PATHN, LKJNDX(1), LDJNDX(1), IDATM, KEYSDV(1),
     +                CHOPT(1:IC+2))
        ELSE
          CALL DBUSE (PATHN, LKJNDX(2), LDJNDX(2), IDATM, KEYSDV(1),
     +                CHOPT(1:IC+2))
          IF (LKJNDX(1).EQ.0) LKJNDX(1) = LKJNDX(2)
        ENDIF
   23 CONTINUE
*
*  ** Get the Key-Names to Present
*
      CALL VZERO (JFKYDV, NWKYDK)
      CALL VZERO (IFLAG, NWKYDK)
      IP = 1
      ICONO(I) = 0
      CHTO(1)  = CTAGDK(MSERDB)
      IOTO(1)  = IOTYDK(MSERDB)
      JFKYDV(1) = MSERDB
   25 CALL KUPROC ('Key-Name to Present (if no more: |) ?', KYNAM, LKEY)
      IF (KYNAM.EQ.'|')     GO TO 30
      I = NSYSDK+1
   26 IF (I.GT.NWKYDK)      GO TO 28
      IF (KYNAM.EQ.CTAGDK(I).AND.IFLAG(I).EQ.0) THEN
        IFLAG(I) = 1
        IP = IP + 1
        CHTO(IP)   = CTAGDK(I)
        IOTO(IP)   = IOTYDK(I)
        ICONO(IP)  = ICONDK(I)
        JFKYDV(IP) = I
        IF (ICONO(IP).LE.0) THEN
          GO TO 25
        ELSE
          NREP = ICONO(IP)
          DO 27 J = 1,NREP
            IP = IP + 1
            I = I + 1
            IFLAG(I) = 1
            CHTO(IP)  = CTAGDK(I)
            IOTO(IP)  = IOTYDK(I)
            ICONO(IP) = ICONDK(I)
            JFKYDV(IP) = I
   27     CONTINUE
        ENDIF
        GO TO 25
      ENDIF
      I = I + 1
      GO TO 26
   28 CONTINUE
      GO TO 25
   30 CONTINUE
*
*  ** Lift Bank for Output
*
      NO = IP
      IF (NO.LE.0)          GO TO 999
      NOBO =  NZBANK (IDIVDB, LKJNDX(1))
      IF (NOBO.LE.0)        GO TO 999
      NDAT = NO *  NOBO
      CALL DBBOOK (IDIVDB, LJOIDX, LJOIDX, 2, 'JOIN', 0, 0, NDAT, 2, 0)
      IF (IQUEST(1).NE.0)   GO TO 999
*
*  ** Fill-Up 'JOIN' Bank and free LKJNDX
*
      IPOIN = LJOIDX
      NKOBJ = NZBANK (IDIVDB, LKJNDX(1))
      IF (NKOBJ.GT.0) THEN
        LFRSDX = LKJNDX(1)
        DO 40 K = 1, NKOBJ
          IF (LFRSDX.GT.0) THEN
            DO 35 J = 1, NO
              IPOIN = IPOIN + 1
              IQ(KOFUDB+IPOIN) = IQ(KOFUDB+LFRSDX+JFKYDV(J))
   35       CONTINUE
          ENDIF
          LFRSDX = LQ(KOFUDB+LFRSDX)
   40   CONTINUE
      ENDIF
      CALL MZDROP (IDIVDB, LKJNDX(1), 'L')
      GO TO 999
*
* *** Error messages
*
  991 IQUEST(1) = 101
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) THEN
        PATHY  = PATHN
        CALL DBPRNT (LPRTDB, '(/,'' DBJOIN : Illegal Path Name '//PATHY
     +       //''')', IARGDB, 0)
      ENDIF
+SELF.
      GO TO 999
*
  992 IQUEST(1) = 102
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) THEN
        PATHY  = PATHN
        CALL DBPRNT (LPRTDB, '(/,'' DBJOIN : Less than '',I5,'' key '//
     +       'for Path Name '//PATHY//''')', NSYSDK, 1)
      ENDIF
+SELF.
      GO TO 999
*
 1001 FORMAT (I2)
 1002 FORMAT (I10)
 1003 FORMAT (Z8)
*                                                             END DBJOIN
  999 END
+DECK, DBLOOK.
      SUBROUTINE DBLOOK (LAD, X, Y, PATH)
*     ===================================
*
************************************************************************
*                                                                      *
*        SUBR. DBLOOK (LAD, X, Y, PATH*)                               *
*                                                                      *
*   Returns the path name picked up by the cursor at x, y              *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LAD      Address of the bank containing information about the    *
*              tree structure starting from the top level              *
*     X        X coordinate of the cursor position                     *
*     Y        Y coordinate of the cursor position                     *
*     PATH(*)  Complete path name as picked up by the user             *
*                                                                      *
*   Called by DBACPL                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
      DIMENSION       LAD(9)
      CHARACTER       PATHX*17, PATHY*80, PATHZ*80, PATH*(*)
*
*     ------------------------------------------------------------------
*
      PATH   = ' '
      IF (LAD(1).LE.0) GO TO 999
      NLEV   = IQ(KOFUDB+LAD(1)+MNLVDB)
      IF (NLEV.LE.0)   GO TO 999
*
* *** Find the level number from the x coordinate
*
      IPNL   = IQ(KOFUDB+LAD(1)+MPNLDB)
      HFRAM  =  Q(KOFUDB+LAD(1)+MHFMDB)
      KLEV   = 0
      DO 10 ILEV = 1, NLEV
        XDIST  = X - Q(KOFUDB+LAD(1)+IPNL+MXOFDB)
        DELX   = Q(KOFUDB+LAD(1)+IPNL+MXWDDB)
        IF (XDIST.GE.0.AND.XDIST.LE.DELX) THEN
          KLEV   = ILEV
        ENDIF
        IPNL   = IQ(KOFUDB+LAD(1)+IPNL+MPNLDB)
   10 CONTINUE
      IF (KLEV.LE.0)   GO TO 999
*
* *** Find the node number from the y coordinate
*
      IPNL   = IQ(KOFUDB+LAD(1)+MPNLDB)
      NODE   = 0
      IF (KLEV.GT.1) THEN
        DO 15 ILEV = 2, KLEV
          IPNL   = IQ(KOFUDB+LAD(1)+IPNL+MPNLDB)
   15   CONTINUE
      ENDIF
      NODES  = IQ(KOFUDB+LAD(1)+IPNL+MNODDB)
      IPNN   = IQ(KOFUDB+LAD(1)+IPNL+MPNNDB)
      DO 20 INOD = 1, NODES
        YDIST  = Y- Q(KOFUDB+LAD(1)+IPNN+MYFNDB)
        IF (YDIST.GE.0.AND.YDIST.LE.HFRAM) THEN
          NODE   = INOD
        ENDIF
        IPNN   = IQ(KOFUDB+LAD(1)+IPNN+MPNLDB)
   20 CONTINUE
      IF (NODE.LE.0)   GO TO 999
*
* *** Correct node is identified; now compute the Path
*
      IUPN   = NODE
      NCHRT  = 0
      PATHY  = ' '
      DO 40 ILEV = 1, KLEV
        JLEV   = KLEV + 1 - ILEV
        IPNL   = IQ(KOFUDB+LAD(1)+MPNLDB)
        IF (JLEV.GT.1) THEN
          DO 25 IL = 2, JLEV
            IPNL   = IQ(KOFUDB+LAD(1)+IPNL+MPNLDB)
   25     CONTINUE
        ENDIF
        IPNN   = IQ(KOFUDB+LAD(1)+IPNL+MPNNDB)
        IF (IUPN.GT.1) THEN
          DO 30 INOD = 2, IUPN
            IPNN   = IQ(KOFUDB+LAD(1)+IPNN+MPNLDB)
   30     CONTINUE
        ENDIF
        NCHR   = IQ(KOFUDB+LAD(1)+IPNN+MNCHDB)
        IUPN   = IQ(KOFUDB+LAD(1)+IPNN+MNFNDB)
        CALL UHTOC (IQ(KOFUDB+LAD(1)+IPNN+MNAMDB), 4, PATHZ, NCHR)
        PATHX  = '/'//PATHZ(1:NCHR)
        NCHR   =NCHR+1
        IF (NCHRT.GT.0) THEN
          PATHZ  = PATHX(1:NCHR)//PATHY(1:NCHRT)
        ELSE
          PATHZ  = PATHX
        ENDIF
        PATHY  = PATHZ
        NCHRT  = NCHRT + NCHR
   40 CONTINUE
      PATH  = '/'//PATHY
*                                                             END DBLOOK
  999 END
+DECK, DBOPEN.
      SUBROUTINE DBOPEN (LUN, CHNAM, STATE, ISTAT)
*     ============================================
*
************************************************************************
*                                                                      *
*        SUBR. DBOPEN (LUN, CHNAM, STATE, ISTAT*)                      *
*                                                                      *
*   Opens a sequential formatted file through a FOTRAN OPEN statement  *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUN      Logical unit number                                     *
*     CHNAM    Character string specifying the file name               *
*     STATE    Status of the file                                      *
*     ISTAT(*) Error code for opening the file (0 if no error)         *
*                                                                      *
*   Called by DBACPL, DBAIWR, DBAUXI, DBEDAS, DBEDKY, DBPEEK, DBPRES,  *
*             DBRDIO                                                   *
*                                                                      *
************************************************************************
*
      CHARACTER      CHNAM*(*), STATE*(*)
+SELF, IF=IBM.
      CHARACTER      NAME*128
+SELF.
*
*     ------------------------------------------------------------------
*
* *** Open the file
*
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
      OPEN (UNIT=LUN, FILE=CHNAM, ACCESS='SEQUENTIAL', STATUS=STATE,
     +      FORM='FORMATTED', IOSTAT=ISTAT, ERR=20)
+SELF, IF=IBM.
      NAME   = '/'//CHNAM
   10 L = INDEX (NAME, '.')
      IF (L.NE.0) THEN
        NAME(L:L) = ' '
        GO TO 10
      ENDIF
      OPEN (UNIT=LUN, FILE=NAME, ACCESS='SEQUENTIAL', STATUS=STATE,
     +      FORM='FORMATTED', IOSTAT=ISTAT, ERR=20)
+SELF, IF=VAX.
      IF (STATE.EQ.'OLD') THEN
        OPEN (UNIT=LUN, FILE=CHNAM, ACCESS='SEQUENTIAL', STATUS=STATE,
     +        FORM='FORMATTED', READONLY, IOSTAT=ISTAT, ERR=20)
      ELSE
        OPEN (UNIT=LUN, FILE=CHNAM, ACCESS='SEQUENTIAL', STATUS=STATE,
     +        FORM='FORMATTED', IOSTAT=ISTAT, ERR=20)
      ENDIF
+SELF.
      ISTAT  = 0
   20 CONTINUE
*                                                             END DBOPEN
  999 END
+DECK, DBPEEK.
      SUBROUTINE DBPEEK (CFNAM, NCF, PATHN)
*     =====================================
*
************************************************************************
*                                                                      *
*        SUBR. DBPEEK (CFNAM, NCF, PATHN)                              *
*                                                                      *
*   Displays keys and data in an interactive session                   *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     CFNAM    Character string describing the name of the file used   *
*     NCF      Number of characters in the string CFNAM                *
*     PATHN    Character string describing the pathname                *
*                                                                      *
*   Called by DBACPL, DBAUXI                                           *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DDISPL.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DXLINK.
      CHARACTER       CFNAM*(*), PATHN*(*), CHOP1*1, CHSLA*100, STRFL*40
      CHARACTER       DFNAM*20
      DIMENSION       KEYX(MXDMDK)
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
* *** Display the keys
*
      IF (IOPHDD.NE.0) THEN
        IMRK   = 1
        I1     = 2
        I2     = 9
        CHOP1  = 'K'
      ELSE
        IMRK   = 40
        I1     = 23
        I2     = 30
        CHOP1  = 'U'
      ENDIF
      CALL DBDISP (LUKYDX, PATHN, CHOP1)
      IERR   = IQUEST(1)
      CALL DBCLOS (LUKYDX)
      IF (IERR.NE.0) THEN
        CHSLA  = PATHN
        NCH    = LENOCC (CHSLA)
        CALL DBPRNT (LPRTDB, '(/,'' DBPEEK : Error '',I6,'' from DBDI'//
     +       'SP for '//CHSLA(1:NCH)//''')', IERR, 1)
        GO TO 999
      ENDIF
*
* *** Open the file for editing
* *** If Data are to be displayed - replace 'D' by an asterix
*
      CALL KUEDIT (CFNAM, IST)
      IF (IST.NE.0) THEN
        CHSLA  = CFNAM
        NCH    = LENOCC (CHSLA)
        IF (IST.NE.1)
     +    CALL DBPRNT (LPRTDB, '(/,'' DBPEEK : Error '',I12,'' in edi'//
     +         'ting file '//CHSLA(1:NCH)//''')', IST, 1)
        GO TO 999
      ENDIF
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP,VAX.
      DFNAM  = 'DFNAME.FILEXT'
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
      CALL CUTOL  (DFNAM)
+SELF, IF=IBM.
      DFNAM  = 'DFNAME.FILEXT.A1'
+SELF.
*
* *** Read back the edited file -- look for the '*'
*
      CALL DBOPEN (LUKYDX, CFNAM, 'OLD', ISTAT)
      IF (ISTAT.NE.0) THEN
        CHSLA  = CFNAM
        NCH    = LENOCC (CHSLA)
        CALL DBPRNT (LPRTDB, '(/,'' DBPEEK : Error '',I12,'' in open'//
     +       'ing file '//CHSLA(1:NCH)//''')', ISTAT, 1)
        GO TO 999
      ENDIF
      CALL UCOPY (IOTYDK, IOTYDD, NWKYDK)
      IOTYDD(MBVRDB) = 7
      IOTYDD(MEVRDB) = 7
      IOTYDD(MITMDB) = 8
      CHSLA  = ' '
      IF (IOPHDD.NE.0) THEN
        READ (LUKYDX, 1001, ERR=20, END=20)
      ELSE
        READ (LUKYDX, 1002, ERR=20, END=20)
        NINCR  = NWKYDK - NSKPDK - 1
        CHSLA(1:1) = '('
        CHSLA(NINCR+2:NINCR+2) = ')'
        DO 5 I = 1, NINCR
    5   CHSLA(I+1:I+1) = '/'
      ENDIF
*
   10 CONTINUE
      READ (LUKYDX, 1003, ERR=20, END=20) STRFL
      IF ((IOPHDD.NE.0) .AND. (STRFL(1:20).EQ.' ')) THEN
        GO TO 20
      ELSE IF ((IOPHDD.EQ.0) .AND. (STRFL(IMRK:IMRK).EQ.'D')) THEN
        READ (LUKYDX, CHSLA(1:NINCR+2), ERR=20, END=20)
        GO TO 10
      ELSE IF (STRFL(IMRK:IMRK).EQ.'*') THEN
*
*  **   Fetch the data according to the key vector
*
        READ (STRFL(I1:I2), 1004, ERR=20) KEYX(MSERDB)
        IOLD   = IOKYDA(MSERDB)
        IOKYDA(MSERDB) = 1
        JBIAS  = 2
        ITIME  = 1
        CALL DBKXIN (ITIME, IDIVDB, LFRSDX, LFRSDX, JBIAS, NWKEY, KEYX,
     +               IPREC)
        IOKYDA(MSERDB) = IOLD
        IF (IQUEST(1).EQ.0.AND.IQ(KOFUDB+LFRSDX-1).GT.0) THEN
*
*   *     Display the data
*
          CALL DBOPEN (LUDADX, DFNAM, 'UNKNOWN', IST1)
          IF (IST1.NE.0) THEN
            CHSLA  = DFNAM
            NCH    = LENOCC (CHSLA)
            CALL DBPRNT (LPRTDB, '(/,'' DBPEEK : Error '',I12,'' in '//
     +           'opening file '//CHSLA(1:NCH)//''')', IST1, 1)
            GO TO 20
          ENDIF
          IF (JBIT(KEYX(MFLGDB), JASFDB).EQ.0) THEN
            CALL DBDKYV (LUDADX, NWKYDK, CTAGDK, KEYX, IOTYDD, ICONDK)
            CALL DBWRDP (LUDADX, LFRSDX)
          ELSE
            CALL DBAIRD (LUDADX, PATHN, KEYX, 'E')
          ENDIF
          CALL DBCLOS (LUDADX)
          CALL KUEDIT (DFNAM, IST2)
        ELSE
          IF (IQUEST(1).NE.0) THEN
            IARGDB(1) = IQUEST(1)
            IARGDB(2) = KEYX(MSERDB)
            CALL DBPRNT (LPRTDB, '(/,'' DBPEEK : Error '',I12,'' in '//
     +           'reading data for '',I12)', IARGDB, 2)
          ELSE
            CALL DBPRNT (LPRTDB, '(/,'' DBPEEK : Empty data structure'//
     +           ' for '',I12)', KEYX(MSERDB), 1)
          ENDIF
        ENDIF
*
        IF (LFRSDX.NE.0) CALL MZDROP (IDIVDB, LFRSDX, 'L')
        IF (IOPHDD.EQ.0) THEN
          READ (LUKYDX, CHSLA(1:NINCR+2), ERR=20, END=20)
        ENDIF
        GO TO 10
      ELSE IF (IOPHDD.NE.0) THEN
        GO TO 10
      ENDIF
*
   20 CALL DBCLOS (LUKYDX)
*
 1001 FORMAT (///)
 1002 FORMAT (/)
 1003 FORMAT (A40)
 1004 FORMAT (I8)
*                                                             END DBPEEK
  999 END
+DECK, DBPRES.
      SUBROUTINE DBPRES (PATHI, PATHO, IOTI, IOTO, CHTI, CHTO, KEYI,
     +                       KEYO, ICONI, ICONO, NI, NO, NOB, CFNAM)
*     ==============================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBPRES (PATHI, PATHO, IOTI, IOTO, CHTI, CHTO, KEYI,     *
*                      KEYO, ICONI, ICONO, NI, NO, NOB, CFNAM)         *
*                                                                      *
*   Routine to Present the "View"                                      *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHI    Pathname of the First Table                             *
*     PATHO    Pathname of the Last  Table                             *
*     IOTI     Type of Keys used for Search                            *
*     IOTO     Type of Keys used for Presentation                      *
*     CHTI     Name of Keys used for Search                            *
*     CHTO     Name of Keys used for Presentation                      *
*     KEYI     Value of Keys used for Search                           *
*     KEYO     Value of Keys to be presented                           *
*     ICONI    Number of keys concatenated to this key                 *
*     ICONO    Number of keys concatenated to this key                 *
*     NI       Number of Keys used for Search                          *
*     NO       Number of Keys to be Presented                          *
*     NOB      Number of Objects to be presented                       *
*     CFNAM    File Name used for presentation                         *
*                                                                      *
*   Called by DBVIEW                                                   *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DDISPL.
+CDE, DXLINK.
      DIMENSION       IDPFL(100)
      DIMENSION       IOTI(NI), IOTO(NO), KEYI(NI), KEYO(NO,NOB)
      DIMENSION       ICONI(NI), ICONO(NO)
      CHARACTER       PATHI*(*), PATHO*(*), CFNAM*(*)
      CHARACTER       CHTI(NI)*8, CHTO(NO)*8, CHEAD*300
*
*     ------------------------------------------------------------------
*
* *** Open file for Presentation
*
      LUN = LUKYDX
      CALL DBOPEN (LUN, CFNAM, 'UNKNOWN', ISTAT)
      IF (ISTAT.NE.0) RETURN
*
* *** Header Line
*
      WRITE (LUN, 1001) PATHO
      IF (IOPHDD.NE.0) THEN
*
*  **   Check if display is wide enough
*
        NW = NO - 1
        IF (NW.GT.0) THEN
          DO 1 I = 1, NW
    1     IDPFL(I) = 1
          CALL DBRGCV (IDPFL, NW, NDISP, IOTO(2))
          IF (NDISP.GT.MXDPDD) THEN
            CALL DBPRNT (LPRTDB, '(/,'' DBPRES : Not enough space to '//
     +           'display.'',/,'' Enlarge display range by DBSETD or '//
     +           'use V-mode.'')', IARGDB, 0)
            WRITE (LUN, 1007)
            GO TO 999
          ENDIF
*
*  **     Display header
*
          CHEAD = ' '
          CHEAD(4:9) = 'Serial'
          CALL DBVHEA (IOTO(2), CHTO(2), NW, CHEAD)
          WRITE (LUN, '(A/)') CHEAD(1:MXDPDD)
*
*  **     Display the Objects if there is any
*
          WRITE (LUN, 1003)
          IF (NOB.GT.0) THEN
            DO 5 I = 1, NOB
              CALL DBDKYH (LUN, NW, KEYO(2,I), IOTO(2), ICONO(2),
     +                              KEYO(1,I))
    5       CONTINUE
          ENDIF
        ENDIF
      ELSE
        WRITE (LUN, '(/)')
*
*  **   Display the Objects if there is any
*
        IF (NOB.GT.0) THEN
          DO 10 I = 1, NOB
            WRITE (LUN, 1005) KEYO(1,I)
            CALL DBDKYV (LUN, NO-1, CHTO(2), KEYO(2,I), IOTO(2),
     +                   ICONO(2))
   10     CONTINUE
        ENDIF
      ENDIF
*
* *** Closing Phrase
*
      WRITE (LUN, 1004) PATHI
      IF (IOPHDD.NE.0) THEN
*
*   *   Check if display is wide enough
*
        IF (NI.GT.0) THEN
          NW = NI
          DO 11 I = 1, NW
   11     IDPFL(I) = 1
          CALL DBRGCV (IDPFL, NW, NDISP, IOTI(1))
          IF (NDISP.GT.MXDPDD) THEN
            CALL DBPRNT (LPRTDB, '(/,'' DBPRES : Not enough space to '//
     +           'display.'',/,'' Enlarge display range by DBSETD or '//
     +           'use V-mode.'')', IARGDB, 0)
            WRITE (LUN, 1007)
            GO TO 999
          ENDIF
*
*  **     Display header
*
          CHEAD = ' '
          CHEAD(4:9) = 'Serial'
          CALL DBVHEA (IOTI(1), CHTI(1), NW, CHEAD)
          WRITE (LUN, '(A/)') CHEAD(1:MXDPDD)
*
          WRITE (LUN, 1003)
          CALL DBDKYH (LUN, NW, KEYI(1), IOTI(1), ICONI(1), -1)
        ENDIF
      ELSE
        WRITE (LUN, '(/)')
        IF (NI.GT.0) THEN
          CALL DBDKYV (LUN, NI, CHTI, KEYI(1), IOTI(1), ICONI(1))
        ENDIF
      ENDIF
*
      CALL DBCLOS (LUN)
      CALL KUEDIT (CFNAM, IST)
*
 1001 FORMAT (/2X,' Objects in Directory ',A/)
 1002 FORMAT (/20(3X,A8,3X)/)
 1003 FORMAT (/)
 1004 FORMAT (////2X,' Satisfy the Search in Directory ',A//)
 1005 FORMAT (/2X,' ---- Object-Serial : ',I10,' ----'/)
 1007 FORMAT (/,' DBPRES : Not enough space to display.' /
     +          ' Enlarge display range by DBSETD or use V-mode.')
*                                                             END DBPRES
 999  END
+DECK, DBPROC.
      SUBROUTINE DBPROC (CPRO, CPAR, NCH)
*     ===================================
*
************************************************************************
*                                                                      *
*        SUBR. DBPROC (CPRO, CPAR*, NCH*)                              *
*                                                                      *
*   Reads a character variable from the screen                         *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     CPRO     Prompt to be printed on the screen                      *
*     CPAR(*)  Character variable as supplied by user                  *
*     NCH(*)   Length of the variable CPAR                             *
*                                                                      *
*   Called by DBAUXI                                                   *
*                                                                      *
************************************************************************
*
      PARAMETER       (LUNI=5, LUNO=6)
      CHARACTER       CPRO*(*), CPAR*(*), CHVAL*80
*
*     ------------------------------------------------------------------
*
*  ** Set default and write the prompt
*
      CPAR   = ' '
      NCH    = 0
      WRITE (LUNO, 1001) CPRO
*
*  ** Now read in the line
*
      READ (LUNI, 1002, ERR=999, END=999) CHVAL
      CPAR   = CHVAL
      NCH    = LENOCC (CPAR)
      IF (NCH.GT.0) CALL CLTOU (CPAR(:NCH))
*
+SELF, IF=IBM.
 1001 FORMAT (' ',A,':')
+SELF, IF=-IBM.
 1001 FORMAT (' ',A,': ',$)
+SELF.
 1002 FORMAT (A80)
*                                                             END DBPROC
  999 END
+DECK, DBRDDA.
      SUBROUTINE DBRDDA (DATA)
*     ========================
*
************************************************************************
*                                                                      *
*        SUBR. DBRDDA (DATA*)                                          *
*                                                                      *
*   Routine to Decode the Data from the Display file                   *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     DATA     Data Items                                              *
*                                                                      *
*   Called by DBUPKY                                                   *
*                                                                      *
************************************************************************
*
+CDE, DXLINK.
      CHARACTER       IOC*1, STRFIL*80, CHVAL*80
      DIMENSION       DATA (9)
*
*     ------------------------------------------------------------------
*
*  ** Decode the Data part of the edited file
*
      REWIND (LUDADX)
      READ (LUDADX, 1001, ERR=10, END=10)
*
      I = 1
    2 CONTINUE
      READ (LUDADX, 1002, ERR=10, END=10) STRFIL
      CHVAL = ' '
      NCH = LENOCC (STRFIL)
      NCH = MIN0 (NCH, 80)
      IF (NCH.EQ.0) GO TO 10
      DO 3 J = 1, NCH
        IF (STRFIL(J:J).NE.' ') THEN
          IOC = STRFIL(J:J)
          JST = J + 6
          GO TO 4
        ENDIF
    3 CONTINUE
    4 CONTINUE
      LCDAT = 4
      LWRDH = 1
      DO 5 J = JST, NCH
        IF (STRFIL(J:J).NE.' ') THEN
          CHVAL = STRFIL(J:NCH)
          LCDAT = NCH-J+1
          LWRDH = (LCDAT-1)/4 + 1
          GO TO 6
        ENDIF
    5 CONTINUE
    6 CONTINUE
      IF (IOC.EQ.'B') THEN
        CALL DBCTOB (CHVAL, DATA(I))
        I = I + 1
      ELSE IF (IOC.EQ.'I') THEN
        CALL DBCTOI (CHVAL, ISTR)
        CALL UCOPY (ISTR, DATA(I), 1)
        I = I + 1
      ELSE IF (IOC.EQ.'F') THEN
        CALL DBCTOR (CHVAL, DATA(I))
        I = I + 1
      ELSE IF (IOC.EQ.'H') THEN
        CALL UCTOH (CHVAL, DATA(I), 4, LCDAT)
        I = I + LWRDH
      ELSE
        DATA(I) = 0.
        I = I + 1
      ENDIF
      GO TO 2
   10 CONTINUE
*
      CALL DBCLOS (LUDADX)
*
 1001 FORMAT (////)
 1002 FORMAT (A80)
*                                                             END DBRDDA
      END
+DECK, DBRDIO.
      SUBROUTINE DBRDIO (PATHN, KEYX, NDAT, CHIDH, LENCH, CHOPT)
*     ==========================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBRDIO (PATHN, KEYX, NDAT*, CHIDH*, LENCH*, CHOPT)      *
*                                                                      *
*   Reads the I/O-Descriptor of the Data-Bank from the display-file    *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Character string describing the pathname                *
*     KEYX     Key-vector                                              *
*     NDAT     Number of Data in the Data-bank associated to the key   *
*     CHIDH    IO Characteristics of the Data-bank                     *
*     LENCH    Length of CHIDH                                         *
*     CHOPT    Character string with any of the following characters   *
*          E   Display only example (template)                         *
*                                                                      *
*   Called by DBUPKY                                                   *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DXLINK.
      CHARACTER       CFNAM*32, PATHN*(*), STRFIL*40
      CHARACTER       IOO*1, ION*1, IOC*2, CHIDH*(*), CHOPT*(*)
      DIMENSION       KEYX(100)
*
*     ------------------------------------------------------------------
*
      NDAT  = 0
*
*  ** Open the file to editing
*
      CALL KUPROC ('Give Data File-Name (e.g. DFNAME) ',CFNAM, LFNAM)
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP,VAX.
      CFNAM  = CFNAM(1:LFNAM)//'.FILEXT'
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
      CALL CUTOL  (CFNAM)
+SELF, IF=IBM.
      CFNAM  = CFNAM(1:LFNAM)//'.FILEXT.A'
+SELF.
      CALL DBOPEN (LUDADX, CFNAM, 'UNKNOWN', ISTAT)
      IF (ISTAT.NE.0)     GO TO 999
*
*  ** Prepares the Data file for PATHN and KEYX vector
*
      CALL DBDISD (LUDADX, PATHN, KEYX, CHOPT)
      CALL DBCLOS (LUDADX)
      IF (IQUEST(1).NE.0) GO TO 999
*
*  ** Edits the file containing the Data
*
      CALL KUEDIT (CFNAM, IST)
*
*  ** Decode the Key part of the edited file
*
      LENCH = 0
      CALL DBOPEN (LUDADX, CFNAM, 'OLD', ISTAT)
      IF (ISTAT.NE.0) RETURN
      READ (LUDADX, 1001, ERR=20, END=20)
*
*  ** Build-up I/O descriptor
*
      IT    = -1
      IOO   = ' '
   10 CONTINUE
      READ (LUDADX, 1002, ERR=20, END=20) STRFIL
      NCH   = LENOCC (STRFIL)
      NCH   = MIN0 (NCH, 80)
      ION   = ' '
      DO 15 J = 1, NCH
        IF (STRFIL(J:J).NE.' ') THEN
          ION = STRFIL(J:J)
          JST = J + 6
          GO TO 16
        ENDIF
   15 CONTINUE
   16 CONTINUE
      LWRDH = 1
      DO 17 J = JST, NCH
        IF (STRFIL(J:J).NE.' ') THEN
          LCDAT = NCH-J+1
          LWRDH = (LCDAT-1)/4 + 1
          GO TO 18
        ENDIF
   17 CONTINUE
   18 CONTINUE
      IF (IOO.NE.ION) THEN
        IF (IT.EQ.-1) THEN
          IT = 0
          IS = 1
          IF (ION.EQ.'H') IS = LWRDH
        ELSE
          WRITE (IOC, 1003) IS
          NDAT = NDAT + IS
          IF (IT.EQ.0) THEN
            CHIDH = IOC//IOO
          ELSE
            CHIDH = CHIDH(1:IT)//IOC//IOO
          ENDIF
          IF (ION.EQ.' ') GO TO 20
          IS = 1
          IF (ION.EQ.'H') IS = LWRDH
          CHIDH(IT+4:IT+4) = ' '
          IT = IT + 4
        ENDIF
        IOO = ION
      ELSE
        INCR = 1
        IF (ION.EQ.'H') INCR = LWRDH
        IS = IS + INCR
      ENDIF
      GO TO 10
   20 CONTINUE
      LENCH = IT + 3
      IF (NDAT.EQ.0) CALL DBCLOS (LUDADX)
*
 1001 FORMAT (////)
 1002 FORMAT (A40)
 1003 FORMAT (I2)
*                                                             END DBRDIO
  999 END
+DECK, DBRGCK.
      SUBROUTINE DBRGCK (KDISP, NK, NTOT, IOKEY)
*     ==========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBRGCK (KDISP, NK, *NTOT, *IOKEY*)                      *
*                                                                      *
*   Checks if the display Range is enough to display data              *
*      in Horizontal Mode (except for DBVIEW action)                   *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     KDISP    Key Flag = 0 for No Display, = 1 for Key to be displayed*
*     NK       Number of Keys                                          *
*     NTOT     Place occupied by displaying the keys                   *
*     IOKEY    Type of the Key                                         *
*          1 - Binary                                                  *
*          2   Integer                                                 *
*          3   Floating                                                *
*          4   Double Precision (not yet implemented)                  *
*          5   Hollerith                                               *
*          6   Hollerith concatenetad to previous hollerith            *
*          7   Packed integer - time packed upto seconds               *
*          8   Packed integer - time packed upto minutes               *
*          9   Data which should not be displayed                      *
*                                                                      *
*   Called by DBDISH                                                   *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DDISPL.
+CDE, DKKEYS.
      DIMENSION       KDISP (NK), NUMBS(7), IOKEY(NK)
      DATA            NUMBS /12, 12, 15, 15, 12, 12, 15/
      DATA            NUMBI, NUMIN, NUMHO /12, 12, 6/
*
*     ------------------------------------------------------------------
*
      NTOT = 10
*
*  ** System Keys
*
      IOKEY(MBVRDB) = 7
      IOKEY(MEVRDB) = 7
      IOKEY(MITMDB) = 8
      DO 5 I = 1, NSYSDK
        IF (KDISP(I).NE.0) THEN
          NUMCDD(I) = NUMBS(I)
          NTOT = NTOT + NUMCDD(I)
        ELSE
          IOKEY(I) = 9
          NUMCDD(I) = 0
        ENDIF
    5 CONTINUE
*
*  ** User Keys
*
      DO 10 I = NSYSDK+1, NK
        IF (KDISP(I).NE.0) THEN
          IF (IOKEY(I).EQ.6) THEN
            IOKEY(I) = 9
            NUMCDD(I) = 0
          ELSE IF (IOKEY(I).EQ.1) THEN
            NUMCDD(I) = NUMBI
            NTOT = NTOT + NUMBI
          ELSE IF (IOKEY(I).EQ.2) THEN
            NUMCDD(I) = NUMIN
            NTOT = NTOT + NUMIN
          ELSE IF (IOKEY(I).EQ.5) THEN
            NUMCDD(I) = NUMHO + 4*ICONDK(I)
            NUMCDD(I) = MAX0 (10, NUMCDD(I))
            NTOT = NTOT + NUMCDD(I)
          ENDIF
        ELSE
          IOKEY(I) = 9
          NUMCDD(I) = 0
        ENDIF
   10 CONTINUE
*                                                             END DBRGCK
      END
+DECK, DBRGCV.
      SUBROUTINE DBRGCV (KDISP, NK, NTOT, IOKEY)
*     ==========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBRGCV (KDISP, NK, *NTOT, *IOKEY*)                      *
*                                                                      *
*   Checks if the display Range is enough to display data              *
*      in Horizontal Mode (for DBVIEW action)                          *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     KDISP    Key Flag = 0 for No Display, = 1 for Key to be displayed*
*     NK       Number of Keys                                          *
*     NTOT     Place occupied by displaying the keys                   *
*     IOKEY    Type of the Key                                         *
*          1 - Binary                                                  *
*          2   Integer                                                 *
*          3   Floating                                                *
*          4   Double Precision (not yet implemented)                  *
*          5   Hollerith                                               *
*          6   Hollerith concatenetad to previous hollerith            *
*          7   Packed integer - time packed upto seconds               *
*          8   Packed integer - time packed upto minutes               *
*          9   Data which should not be displayed                      *
*                                                                      *
*   Called by DBPRES                                                   *
*                                                                      *
************************************************************************
*
+CDE, DDISPL.
+CDE, DKKEYS.
      DIMENSION       KDISP (NK), NUMBS(7), IOKEY(NK)
      DATA            NUMBS /12, 12, 15, 15, 12, 12, 15/
      DATA            NUMBI, NUMIN, NUMHO /12, 12, 6/
*
*     ------------------------------------------------------------------
*
      NTOT = 10
*
*  ** Input Keys (cannot be system keys)
*
      DO 10 I = 1,NK
        IF (KDISP(I).NE.0) THEN
          IF (IOKEY(I).EQ.6) THEN
            IOKEY(I) = 9
            NUMCDD(I) = 0
          ELSE IF (IOKEY(I).EQ.1) THEN
            NUMCDD(I) = NUMBI
            NTOT = NTOT + NUMBI
          ELSE IF (IOKEY(I).EQ.2) THEN
            NUMCDD(I) = NUMIN
            NTOT = NTOT + NUMIN
          ELSE IF (IOKEY(I).EQ.5) THEN
            NUMCDD(I) = NUMHO + 4*ICONDK(I)
            NUMCDD(I) = MAX0 (10, NUMCDD(I))
            NTOT = NTOT + NUMCDD(I)
          ENDIF
        ELSE
          IOKEY(I) = 9
          NUMCDD(I) = 0
        ENDIF
   10 CONTINUE
*                                                             END DBRGCV
      END
+DECK, DBRVNT.
      SUBROUTINE DBRVNT (NPATH, PATHS, KEYS, NVAR, NKST, NDST, NKEYX,
     1                              KEYXS, NOBJS, KOBJS, CTAG, NOBJM)
*     ===============================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBRVNT (NPATH, PATHS*, KEYS*, NVAR*, NKST*, NDST*,      *
*                      NKEYX*, KEYXS*, NOBJS*, KOBJS*, CTAG*, NOBJM)   *
*                                                                      *
*   Reads variables for DBACPL from command line or external file      *
*                                                                      *
*   Argements :                                                        *
*                                                                      *
*     NPATH    Number of pathnames for the directories                 *
*     PATHS    Names of the directory paths                            *
*     KEYS     Vector of keys for character option                     *
*     NVAR     Total number of variables                               *
*     NKST     Number of key  elements selected                        *
*     NDST     Number of data elements selected                        *
*     NKEYX    Number of key  elements for each paths                  *
*     KEYXS    Key  element indices                                    *
*     NOBJS    Number of data elements for each paths                  *
*     KOBJS    Data element indices                                    *
*     CTAG     Tag for each of the elements                            *
*     NOBJM    Maximum number of variables                             *
*                                                                      *
*   Called by DBAUXI                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =167 : Error in reading from the file                  *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DXLINK.
      DIMENSION       KEYS(9), NKEYX(9), KEYXS(9), KOBJS(9), NOBJS(9)
      CHARACTER       CFNAM*80, CHPRO*32, PATHN*80, CTEMP*5
      CHARACTER*(*)   PATHS(*), CTAG(*)
*
*     ------------------------------------------------------------------
*
      CALL KUGETI (LUNI)
      CALL KUGETC (CFNAM, NCF)
      NVAR   = 0
      NKST   = 0
      NDST   = 0
*
      IF (LUNI.GT.0.AND.CFNAM.NE.' ') THEN
*
* ***   Read the information from an external file
*
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
        CALL CUTOL  (CFNAM)
+SELF.
        CALL DBOPEN (LUNI, CFNAM, 'OLD', ISTAT)
        IF (ISTAT.NE.0) THEN
          CALL DBPRNT (L3PRDX, '(/,'' DBRVNT : Error '',I12,'' in ope'//
     +         'ning file '//CFNAM(1:NCF)//''')', ISTAT, 1)
          IQUEST(1) = 167
          GO TO 999
        ENDIF
*
*  **   Read in the path names first
*
        DO 5 I = 1, NPATH
          READ (LUNI, *, ERR=30, END=30) PATHS(I)
          PATHN = PATHS(I)
          CALL RZCDIR (PATHN, ' ')
          IF (IQUEST(1).NE.0) THEN
            NCH   = LENOCC (PATHN)
            CALL DBPRNT (L3PRDX, '('' DB-path '//PATHN(1:NCH)//' is '//
     +           'illegal'')', IARGDB, 0)
            IQUEST(1) = 167
            GO TO 30
          ENDIF
    5   CONTINUE
*
*  **   Now read the key values
*
        DO 10 I = 1, 29
          IF (IOKYDA(I).NE.0) THEN
            IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB.OR.I.EQ.MITMDB) THEN
              READ (LUNI, *, ERR=30, END=30) IDATE, ITIME
              IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB) THEN
                CALL DBPKTS (IDATE, ITIME, KEYS(I))
              ELSE
                CALL DBPKTM (IDATE, ITIME, KEYS(I))
              ENDIF
            ELSE
              READ (LUNI, *, ERR=30, END=30) KEYS(I)
            ENDIF
          ENDIF
   10   CONTINUE
*
*  **   Now read the items to be stored
*
        DO 25 I = 1, NPATH
          PATHN  = PATHS(I)
          CALL RZCDIR (PATHN, ' ')
          NKEYDK = IQUEST(7)
          NWKYDK = IQUEST(8)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          CALL DBKYTG
          READ (LUNI, *, ERR=30, END=30) NKEYX(I)
          IF (NKEYX(I).LT.1) THEN
            NKEYX(I) = 0
          ELSE IF (NKEYX(I).GT.NWKYDK) THEN
            NKEYX(I) = NWKYDK
          ENDIF
          IF (NVAR+NKEYX(I).GT.NOBJM) THEN
            CALL DBPRNT (L3PRDX, '('' Too many variables for N-tuple'')'
     +,          IARGDB, 0)
            IQUEST(1) = 167
            GO TO 30
          ENDIF
          DO 15 J = 1, NKEYX(I)
            READ (LUNI, *, ERR=30, END=30) KEYXS(NKST+J)
            IF (KEYXS(NKST+J).LT.1.OR.KEYXS(NKST+J).GT.NWKYDK) THEN
              CALL DBPRNT (L3PRDX, '('' Invalid Key index'',I12)',
     +             KEYXS(NKST+J), 1)
              IQUEST(1) = 167
              GO TO 30
            ENDIF
            CTAG(NVAR+J) = CTAGDK(KEYXS(NKST+J))
   15     CONTINUE
          NVAR   = NVAR + NKEYX(I)
          NKST   = NKST + NKEYX(I)
          READ (LUNI, *, ERR=30, END=30) NOBJS(I)
          IF (NOBJS(I).LT.1) NOBJS(I) = 0
          IF (NVAR+NOBJS(I).GT.NOBJM) THEN
            CALL DBPRNT (L3PRDX, '('' Too many variables for N-tuple'')'
     +,          IARGDB, 0)
            IQUEST(1) = 167
            GO TO 30
          ENDIF
          DO 20 J = 1, NOBJS(I)
            READ (LUNI, *, ERR=30, END=30) KOBJS(NDST+J), CTAG(NVAR+J)
            IF (KOBJS(NDST+J).LT.1) KOBJS(NDST+J) = 1
   20     CONTINUE
          NVAR   = NVAR + NOBJS(I)
          NDST   = NDST + NOBJS(I)
   25   CONTINUE
        IQUEST(1) = 0
        GO TO 40
*
   30   CALL DBPRNT (L3PRDX, '(/,'' DBRVNT : Error in reading file '//
     +       CFNAM(1:NCF)//''')', ISTAT, 0)
        IQUEST(1) = 167
   40   CALL DBCLOS (LUNI)
*
      ELSE
*
* ***   Read the information from the command line
*
        DO 45 I = 1, NPATH
          WRITE (CHPRO, 1001) I
          CALL KUPROC (CHPRO, PATHS(I), NCH)
          PATHN  = PATHS(I)
          CALL RZCDIR (PATHN, ' ')
          IF (IQUEST(1).NE.0) THEN
            CALL DBPRNT (L3PRDX, '('' DB-path '//PATHN(1:NCH)//' is '//
     +           'illegal'')', IARGDB, 0)
            IQUEST(1) = 167
            GO TO 999
          ENDIF
   45   CONTINUE
*
*  **   Now read the key values
*
        DO 50 I = 1, 29
          IF (IOKYDA(I).NE.0) THEN
            IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB) THEN
              IF (I.EQ.MBVRDB) THEN
                CTEMP  = 'Begin'
              ELSE
                CTEMP  = 'End'
              ENDIF
              WRITE (CHPRO, 1002) 'YYMMDD', CTEMP
              CALL KUPROI (CHPRO, IDATE)
              WRITE (CHPRO, 1002) 'HHMMSS', CTEMP
              CALL KUPROI (CHPRO, ITIME)
              CALL DBPKTS (IDATE, ITIME, KEYS(I))
            ELSE IF (I.EQ.MITMDB) THEN
              WRITE (CHPRO, 1003) 'YYMMDD'
              CALL KUPROI (CHPRO, IDATE)
              WRITE (CHPRO, 1003) 'HHMM'
              CALL KUPROI (CHPRO, ITIME)
              CALL DBPKTM (IDATE, ITIME, KEYS(I))
            ELSE
              WRITE (CHPRO, 1004) I
              CALL KUPROI (CHPRO, KEYS(I))
            ENDIF
          ENDIF
   50   CONTINUE
*
*  **   Now read the items to be stored
*
        DO 70 I = 1, NPATH
          PATHN  = PATHS(I)
          CALL RZCDIR (PATHN, ' ')
          NKEYDK = IQUEST(7)
          NWKYDK = IQUEST(8)
          LCDRDB = IQUEST(11)
          IKDRDB = IQUEST(13)
          CALL DBKYTG
          WRITE (CHPRO, 1005) I
          CALL KUPROI (CHPRO, NKEYX(I))
          IF (NKEYX(I).LT.1) THEN
            NKEYX(I) = 0
          ELSE IF (NKEYX(I).GT.NWKYDK) THEN
            NKEYX(I) = NWKYDK
          ENDIF
          IF (NVAR+NKEYX(I).GT.NOBJM) THEN
            CALL DBPRNT (L3PRDX, '('' Too many variables for N-tuple'')'
     +,          IARGDB, 0)
            IQUEST(1) = 167
            GO TO 999
          ENDIF
          DO 60 J = 1, NKEYX(I)
            WRITE (CHPRO, 1006) J, I
   55       CALL KUPROI (CHPRO, KEYXS(NKST+J))
            IF (KEYXS(NKST+J).LT.1.OR.KEYXS(NKST+J).GT.NWKYDK) GO TO 55
            CTAG(NVAR+J) = CTAGDK(KEYXS(NKST+J))
   60     CONTINUE
          NVAR   = NVAR + NKEYX(I)
          NKST   = NKST + NKEYX(I)
          WRITE (CHPRO, 1007) I
          CALL KUPROI (CHPRO, NOBJS(I))
          IF (NOBJS(I).LT.1) NOBJS(I) = 0
          IF (NVAR+NOBJS(I).GT.NOBJM) THEN
            CALL DBPRNT (L3PRDX, '('' Too many variables for N-tuple'')'
     +,          IARGDB, 0)
            IQUEST(1) = 167
            GO TO 999
          ENDIF
          DO 65 J = 1, NOBJS(I)
            WRITE (CHPRO, 1008) J, I
            CALL KUPROI (CHPRO, KOBJS(NDST+J))
            IF (KOBJS(NDST+J).LT.1) KOBJS(NDST+J) = 1
            WRITE (CHPRO, 1009) KOBJS(NDST+J)
            CALL DBPROC (CHPRO, CTAG(NVAR+J), NCH)
   65     CONTINUE
          NVAR   = NVAR + NOBJS(I)
          NDST   = NDST + NOBJS(I)
   70   CONTINUE
        IQUEST(1) = 0
*
      ENDIF
*
 1001 FORMAT (I2,'th Path name')
 1002 FORMAT (A,' of ',A,' Range')
 1003 FORMAT (A,' of cut in insertion time')
 1004 FORMAT ('Key(',I2,') ?')
 1005 FORMAT ('No. of keys to store for path ',I2)
 1006 FORMAT (I2,'th Key element for path ',I2)
 1007 FORMAT ('No. of data to store for path ',I2)
 1008 FORMAT (I2,'th data element for path ',I2)
 1009 FORMAT ('Tag for',I3,'th data element')
*                                                             END DBRVNT
  999 END
+DECK, DBRVPL.
      SUBROUTINE DBRVPL (INDX, NOBJ, KOBJ1, KOBJ2, KEYS)
*     ==================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBRVPL (INDX, NOBJ, KOBJ1*, KOBJ2*, KEYS*)              *
*                                                                      *
*   Reads variables for DBACPL from command line or external file      *
*                                                                      *
*   Argements :                                                        *
*                                                                      *
*     INDX     Type of input (1 for DBPLOB; 2 for DBPLOV; 0 otherwise) *
*     NOBJ     Number of objects                                       *
*     KOBJ1    Array for object indices for DBPLOB                     *
*     KOBJ2    Array for pair of object indices for DBPLOV             *
*     KEYS     Key indices                                             *
*                                                                      *
*   Called by DBACPL                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =167 : Error in reading from the file                  *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DXLINK.
      DIMENSION       KEYS(9), KOBJ2(2,9), KOBJ1(9)
      CHARACTER       CFNAM*80, CHPRO*32, CTEMP*5
*
*     ------------------------------------------------------------------
*
      CALL KUGETI (LUNI)
      CALL KUGETC (CFNAM, NCF)
*
      IF (LUNI.GT.0.AND.CFNAM.NE.' ') THEN
*
* ***   Read the information from an external file
*
+SELF, IF=APOLLO,CRAY,HPUX,IBMRT,MIP.
        CALL CUTOL  (CFNAM)
+SELF.
        CALL DBOPEN (LUNI, CFNAM, 'OLD', ISTAT)
        IF (ISTAT.NE.0) THEN
          CALL DBPRNT (L3PRDX, '(/,'' DBRVPL : Error '',I12,'' in ope'//
     +         'ning file '//CFNAM(1:NCF)//''')', ISTAT, 1)
          IQUEST(1) = 167
          GO TO 999
        ENDIF
*
*  **   Read the object indices first
*
        IF (INDX.EQ.1) THEN
          DO 10 I = 1, NOBJ
            READ (LUNI, *, ERR=25, END=25) KOBJ1(I)
   10     CONTINUE
        ELSE IF (INDX.EQ.2) THEN
          DO 15 I = 1, NOBJ
            READ (LUNI, *, ERR=25, END=25) KOBJ2(1,I), KOBJ2(2,I)
   15     CONTINUE
        ENDIF
*
*  **   Now read the key values
*
        DO 20 I = 1, 29
          IF (IOKYDA(I).NE.0) THEN
            IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB.OR.I.EQ.MITMDB) THEN
              READ (LUNI, *, ERR=25, END=25) IDATE, ITIME
              IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB) THEN
                CALL DBPKTS (IDATE, ITIME, KEYS(I))
              ELSE
                CALL DBPKTM (IDATE, ITIME, KEYS(I))
              ENDIF
            ELSE
              READ (LUNI, *, ERR=25, END=25) KEYS(I)
            ENDIF
          ENDIF
   20   CONTINUE
        IQUEST(1) = 0
        GO TO 30
*
   25   CALL DBPRNT (L3PRDX, '(/,'' DBRVPL : Error in reading file '//
     +       CFNAM(1:NCF)//''')', ISTAT, 0)
        IQUEST(1) = 167
   30   CALL DBCLOS (LUNI)
*
      ELSE
*
* ***   Read the information from the command line
*
        IF (INDX.EQ.1) THEN
          DO 35 I = 1, NOBJ
            WRITE (CHPRO, 1001) I
            CALL KUPROI (CHPRO, KOBJ1(I))
   35     CONTINUE
        ELSE IF (INDX.EQ.2) THEN
          DO 40 I = 1, NOBJ
            WRITE (CHPRO, 1002) 'First ',I
            CALL KUPROI (CHPRO, KOBJ2(1,I))
            WRITE (CHPRO, 1002) 'Second',I
            CALL KUPROI (CHPRO, KOBJ2(2,I))
   40     CONTINUE
        ENDIF
*
*  **   Now read the key values
*
        DO 45 I = 1, 29
          IF (IOKYDA(I).NE.0) THEN
            IF (I.EQ.MBVRDB.OR.I.EQ.MEVRDB) THEN
              IF (I.EQ.MBVRDB) THEN
                CTEMP  = 'Begin'
              ELSE
                CTEMP  = 'End'
              ENDIF
              WRITE (CHPRO, 1003) 'YYMMDD', CTEMP
              CALL KUPROI (CHPRO, IDATE)
              WRITE (CHPRO, 1003) 'HHMMSS', CTEMP
              CALL KUPROI (CHPRO, ITIME)
              CALL DBPKTS (IDATE, ITIME, KEYS(I))
            ELSE IF (I.EQ.MITMDB) THEN
              WRITE (CHPRO, 1004) 'YYMMDD'
              CALL KUPROI (CHPRO, IDATE)
              WRITE (CHPRO, 1004) 'HHMM'
              CALL KUPROI (CHPRO, ITIME)
              CALL DBPKTM (IDATE, ITIME, KEYS(I))
            ELSE
              WRITE (CHPRO, 1005) I
              CALL KUPROI (CHPRO, KEYS(I))
            ENDIF
          ENDIF
   45   CONTINUE
        IQUEST(1) = 0
      ENDIF
*
 1001 FORMAT ('Index for Object',I2,' ?')
 1002 FORMAT (A,' index for Object',I2,' ?')
 1003 FORMAT (A,' of ',A,' Range')
 1004 FORMAT (A,' of cut in insertion time')
 1005 FORMAT ('Key(',I2,') ?')
*                                                             END DBRVPL
  999 END
+DECK, DBTEMP.
      SUBROUTINE DBTEMP (IOKEY, NK, CHEAD)
*     ====================================
*
************************************************************************
*                                                                      *
*        SUBR. DBTEMP (IOKEY, NK, *CHEAD)                              *
*                                                                      *
*   Writes a Template of the Display in Horizontal Mode into           *
*   the Character Variable CHEAD                                       *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IOKEY    Type of the Key                                         *
*          1 - Binary                                                  *
*          2   Integer                                                 *
*          3   Floating                                                *
*          4   Double Precision (not yet implemented)                  *
*          5   Hollerith                                               *
*          6   Hollerith concatenetad to previous hollerith            *
*          7   Packed integer - time packed upto seconds               *
*          8   Packed integer - time packed upto minutes               *
*          9   Data which should not be displayed                      *
*     NK       Number of Keys                                          *
*     CHEAD    Character variable containing the header                *
*                                                                      *
*   Called by DBDISH                                                   *
*                                                                      *
************************************************************************
*
+CDE, DDISPL.
+CDE, DKKEYS.
      DIMENSION       IOKEY(9)
      CHARACTER       CHEAD*(*)
*
*     ------------------------------------------------------------------
*
      IPOS = 11
      DO 5 I = 1,NK
        IF (IOKEY(I).NE.9) THEN
          IW1 = IPOS
          IW2 = IPOS + NUMCDD(I) - 1
          CHEAD(IW1:IW1) = '|'
          CHEAD(IW2:IW2) = '|'
          IPOS = IPOS + NUMCDD(I)
        ENDIF
    5 CONTINUE
*                                                             END DBTEMP
      END
+DECK, DBUPKY.
      SUBROUTINE DBUPKY (KEYX, KEYO, PATHN, CHOPT)
*     ============================================
*
************************************************************************
*                                                                      *
*        SUBR. DBUPKY (KEYX, KEYO, PATHN, CHOPT)                       *
*                                                                      *
*   Insert/Update Keys in CWD                                          *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     KEYX     Key-Vector containing the new Key values                *
*     KEYO     Key-Vector containing the new Key values                *
*     PATHN    Pathname of the directory                               *
*     CHOPT    Character options                                       *
*         A    Insert objects from Ascii file                          *
*         E    Object is new - Data-template shown                     *
*         I    Insert new Key                                          *
*         W    Insert objects from Ascii file without data             *
*         X    Replace (update) old key                                *
*                                                                      *
*   Called by DBEDAS, DBEDKY                                           *
*                                                                      *
************************************************************************
*
+CDE, DAOPTS.
+CDE, DBSTOR.
+CDE, DDISPL.
+CDE, DKKEYS.
+CDE, DLINKS.
+CDE, DXLINK.
      DIMENSION       IOPTS(5), KEYX(9), KEYO(9), IOWDS(16)
      CHARACTER       YESNO*1, CHIDH*120
      CHARACTER       PATHN*(*), CHOPT*(*), CHOP*1
      EQUIVALENCE     (IOPTA, IOPTS(1)), (IOPTE, IOPTS(2)),
     +                (IOPTI, IOPTS(3)), (IOPTW, IOPTS(4)),
     +                (IOPTX, IOPTS(5))
*
*     ------------------------------------------------------------------
*
* *** Decode the character option
*
      CALL UOPTC (CHOPT, 'AEIWX', IOPTS)
      IF (IOPTA.NE.0.AND.IOPTW.NE.0) THEN
        NDAT = 0
        CALL DBBOOK (IDIVDB, LASTDX, LASTDX, 2, 'USER', 0, 0, NDAT,
     +               2, 0)
        IF (IQUEST(1).NE.0)   GO TO 999
        GO TO 10
      ENDIF
*
*  ** Insert Data ?
*
      CALL KUPROC ('Data Insert/Update ? (Y/N)', YESNO, LYN)
      IF (YESNO.EQ.'Y') THEN
        IF (IOPTE.NE.0) THEN
          CHOP = 'E'
        ELSE
          IF (IOPHDD.EQ.0) THEN
            CHOP = 'V'
          ELSE
            CHOP = 'H'
          ENDIF
        ENDIF
        CALL DBRDIO (PATHN, KEYX, NDAT, CHIDH, LCHID, CHOP)
        IF (IQUEST(1).NE.0)   GO TO 999
        IF (NDAT.GT.0) THEN
          CALL MZIOCH (IOWDS, 16, CHIDH(1:LCHID))
          CALL DBBOOK (IDIVDB, LASTDX, LASTDX, 2, 'USER', 0, 0, NDAT,
     +                 IOWDS, 0)
          IF (IQUEST(1).NE.0) GO TO 999
          CALL DBRDDA (Q(KOFUDB+LASTDX+1))
        ELSE
          NDAT = 0
          CALL DBBOOK (IDIVDB, LASTDX, LASTDX, 2, 'USER', 0, 0, NDAT,
     +                 2, 0)
          IF (IQUEST(1).NE.0) GO TO 999
        ENDIF
      ELSE
        NDAT = 0
        CALL DBBOOK (IDIVDB, LASTDX, LASTDX, 2, 'USER', 0, 0, NDAT,
     +               2, 0)
        IF (IQUEST(1).NE.0)   GO TO 999
      ENDIF
*
   10 CONTINUE
      IF (IOPTX.NE.0) CALL DBREPL (PATHN, LKVWDX(1), LDVWDX(1),
     +                IDIVDB, LASTDX, NWKYDK, KEYO, KEYX, 0, ' ')
      IF (IOPTI.NE.0) CALL DBENTR (PATHN, LKVWDX(1), LDVWDX(1),
     +                IDIVDB, LASTDX, NWKYDK, KEYX, 0, ' ')
      CALL MZDROP (IDIVDB, LASTDX, ' ')
      IQUEST(1) = 0
*                                                             END DBUPKY
  999 END
+DECK, DBVHEA.
      SUBROUTINE DBVHEA (IOKEY, CHTG, NK, CHEAD)
*     ==========================================
*
************************************************************************
*                                                                      *
*        SUBR. DBVHEA (IOKEY, CHTG, NK, *CHEAD)                        *
*                                                                      *
*   Writes the Header of the Display in Horizontal Mode into the       *
*   Character Variable CHEAD                                           *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IOKEY    Type of the Key                                         *
*          1 - Binary                                                  *
*          2   Integer                                                 *
*          3   Floating                                                *
*          4   Double Precision (not yet implemented)                  *
*          5   Hollerith                                               *
*          6   Hollerith concatenetad to previous hollerith            *
*          7   Packed integer - time packed upto seconds               *
*          8   Packed integer - time packed upto minutes               *
*          9   Data which should not be displayed                      *
*     CHTG     Vector containing the names of the keys                 *
*     NK       Number of Keys                                          *
*     CHEAD    Character variable containing the header                *
*                                                                      *
*   Called by DBPRES                                                   *
*                                                                      *
************************************************************************
*
+CDE, DDISPL.
      DIMENSION       IOKEY(NK)
      CHARACTER       CHEAD*(*), CHTG(*)*8
*
*     ------------------------------------------------------------------
*
      IPOS = 11
      DO 5 I = 1,NK
        IF (IOKEY(I).NE.9) THEN
          NSP = MAX0 ((NUMCDD(I)-8)/2,1)
          IW = IPOS + NSP
          CHEAD(IW:IW+7) = CHTG(I)
          IPOS = IPOS + NUMCDD(I)
        ENDIF
    5 CONTINUE
*                                                             END DBVHEA
      END
+DECK, DBVIEW.
      SUBROUTINE DBVIEW (CFNAM, PATHI)
*     ================================
*
************************************************************************
*                                                                      *
*        SUBR. DBVIEW (CFNAM, PATHI)                                   *
*                                                                      *
*   Routine to Create and Present "View" a la ORACLE                   *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     CFNAM    File-Name for Presentation                              *
*     PATHI    Pathname of the Table                                   *
*                                                                      *
*   Called by DBAUXI                                                   *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DKKEYS.
+CDE, DDISPL.
+CDE, DLINKS.
+CDE, DXLINK.
      DIMENSION       KEYI(100), IOTI(100), IOTO(100), IOTJ(100)
      DIMENSION       ICONI(100), ICONO(100), ICONJ(100)
      CHARACTER*80    PATHJ, PATHO
      CHARACTER       CHTI(100)*8, CHTO(100)*8, CHTJ(100)*8, CHMOD*1
      CHARACTER       PATHI*(*), CFNAM*(*)
*
*     ------------------------------------------------------------------
*
* *** Define the Mode to Present (Horizontal or Vertical)
*
      CALL KUPROC ('Which Mode ? (H/V) ', CHMOD, LCMOD)
      IF (CHMOD.NE.'H') THEN
        CHMOD = 'V'
        IOPHDD = 0
      ELSE
        IOPHDD = 1
      ENDIF
*
* *** Get the date and time (or Run# or last version)
*
      IDATE = 0
      CALL KUPROI ('Date in YYMMDD - if 0, next item is Run #', IDATE)
      IF (IDATE.NE.0) THEN
        ITIME = 0
        CALL KUPROI ('Time in HHMMSS ', ITIME)
        CALL DBPKTS (IDATE, ITIME, IDATM)
      ELSE
        NRUN = 0
        CALL KUPROI ('Run Number - if 0, Date = 991231 is set', NRUN)
        IF (NRUN.EQ.0) THEN
          IDATM = 773874975
        ELSE
          IDATM = NRUN
        ENDIF
      ENDIF
*
* *** Create the first view
*
      CALL DBVWPR (PATHI, IDATM, NI, CHTI(1), IOTI(1), ICONI(1),
     +             KEYI(1), NO, CHTO(1), IOTO(1), ICONO(1), NOBO)
      IF (IQUEST(1).NE.0) GO TO 999
*
* *** Present the View or Join New Tables before Presenting
*
      PATHO = PATHI
   10 CONTINUE
      CALL KUPROC ('Present view (|) or join Table (Pathname :) ',
     +             PATHJ, LPJ)
      IF (PATHJ.EQ.'|') THEN
        IF (NO*NOBO.GT.0) THEN
          CALL DBPRES (PATHI, PATHO, IOTI(1), IOTO(1), CHTI(1),
     +                 CHTO(1), KEYI(1), IQ(KOFUDB+LVIWDX+1), ICONI(1),
     +                 ICONO(1), NI, NO, NOBO, CFNAM)
          CALL MZDROP (IDIVDB, LVIWDX, ' ')
        ENDIF
      ELSE
        IF (NO*NOBO.GT.0) THEN
          CALL DBJOIN (PATHJ, IDATM, NO, NOBO, CHTO(1), IOTO(1),
     +                 ICONO(1), IQ(KOFUDB+LVIWDX+1), NJ, NOBJ, CHTJ(1),
     +                 IOTJ(1), ICONJ(1))
          IER    = IQUEST(1)
          CALL MZDROP (IDIVDB, LVIWDX, ' ')
          IF (IER.NE.0)   GO TO 999
          LVIWDX = LJOIDX
          NO = NJ
          NOBO = NOBJ
          DO 15  I = 1, NJ
            IOTO(I)  = IOTJ(I)
            CHTO(I)  = CHTJ(I)
            ICONO(I) = ICONJ(I)
   15     CONTINUE
          PATHO = PATHJ
          GO TO 10
        ENDIF
      ENDIF
*                                                             END DBVIEW
  999 END
+DECK, DBVWPR.
      SUBROUTINE DBVWPR (PATHN, IDATM, NI, CHTI, IOTI, ICONI, KEYI,
     +                                 NO, CHTO, IOTO, ICONO, NOBO)
*     =============================================================
*
************************************************************************
*                                                                      *
*        SUBR. DBVWPR (PATHN, IDATM, NI*, CHTI*, IOTI*, ICONI, KEYI,   *
*                                    NO*, CHTO*, IOTO*,ICONO*, NOBO*)  *
*                                                                      *
*   Routine to Prepare a View from a Table for Presentation or to      *
*              Join to a another Table                                 *
*   The values of the Keys to be presented/joined can be found at      *
*                 IQ(LVIWDX+1,..,NO,NO+1,...,NO*NOBO)                  *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     PATHN    Pathname of the Table                                   *
*     IDATM    Packed Date and Time (or Run #) at which the Table is   *
*              valid                                                   *
*     NI       Number of Keys to search                                *
*     CHTI     Name of Keys to search                                  *
*     IOTI     Type of Keys to search                                  *
*     ICONI    Number of concatenated keys in search                   *
*     KEYI     Value of the Keys to search                             *
*     NOBO     Number of Objects to be presented                       *
*     NO       Number of Keys to be Presented                          *
*     CHTO     Name of Keys to be presented                            *
*     IOTO     Type of Keys to be presented                            *
*     ICONO    Number of concatenated to be presented                  *
*     NOBO     Number of Objects to be presented                       *
*                                                                      *
*   Called by DBVIEW                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =101 : Illegal path name                               *
*               =102 : No key or data for the path name                *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, DLINKS.
+CDE, DKKEYS.
+CDE, DVIEWS.
+CDE, DXLINK.
      DIMENSION       IOTI(9), IOTO(9), KEYI(9), ICONI(9), ICONO(9)
      DIMENSION       IFLAG(100)
      CHARACTER       PATHN*(*), CHTI(*)*8, CHTO(*)*8
      CHARACTER       CHOPT*40, KYNAM*8, KYVAL*100, BLANK*20, KY10*10
      DATA            BLANK /' '/
*
*     ------------------------------------------------------------------
*
*   ** Set the current directory
*
      CALL RZCDIR (PATHN, ' ')
      IF (IQUEST(1).NE.0)   GO TO 991
      NKEYDK = IQUEST(7)
      NWKYDK = IQUEST(8)
      IF (NWKYDK.LE.NSYSDK) GO TO 992
      LCDRDB = IQUEST(11)
      IKDRDB = IQUEST(13)
      CALL DBKYTG
      IF (IQUEST(1).NE.0)   GO TO 999
*
*  ** Fill concatenation flag (if non-zero: number of concatenated keys
*
      CALL DBCONC (IOTYDK(1), NWKYDK, ICONDK(1), NSKPDK)
*
*  ** Get Key-Names and Key-Values to Search
*
      CALL VZERO (KEYSDV, NWKYDK)
      CALL VZERO (IFLAG, NWKYDK)
      IK = 0
   10 CONTINUE
      CALL KUPROC ('Key-Name to Search (if no more - |) ?', KYNAM, LKEY)
      IF (KYNAM.EQ.'|')     GO TO 20
      I = NSYSDK+1
   11 IF (I.GT.NWKYDK)      GO TO 13
        IF (KYNAM.EQ.CTAGDK(I).AND.IFLAG(I).EQ.0) THEN
          IFLAG(I) = 1
          IKEY = I
          IK = IK + 1
          IC = 2*IK
          IFKYDV(IK) = I
          WRITE (CHOPT(IC-1:IC), 1001) I
          CHTI(IK)  = CTAGDK(I)
          IOTI(IK)  = IOTYDK(I)
          ICONI(IK) = ICONDK(I)
          NREP = 0
          IF (ICONI(IK).GT.0) THEN
            NREP = ICONI(IK)
            DO 12 J = 1, NREP
              I = I + 1
              IC = IC + 2
              IFKYDV(IK+J) = I
              WRITE (CHOPT(IC-1:IC), 1001) I
              CHTI(IK+J)  = CTAGDK(I)
              IOTI(IK+J)  = IOTYDK(I)
              ICONI(IK+J) = ICONDK(I)
              IFLAG(I)    = 1
   12       CONTINUE
          ENDIF
          GO TO 15
        ENDIF
        I = I + 1
        GO TO 11
   13 CONTINUE
      GO TO 10
   15 CONTINUE
*    *      Key-Vector for DBUSE
      CALL KUPROC ('Key-Value ?', KYVAL, LKEY)
      IF (IOTYDK(IKEY).EQ.5) THEN
*  *        Hollerith
        LCDAT = (NREP+1)*4
        CALL UCTOH (KYVAL(1:LCDAT), KEYSDV(IKEY), 4, LCDAT)
        KEYI(IK) = KEYSDV(IKEY)
        IF (NREP.GT.0) THEN
          DO 16 J = 1, NREP
            IK = IK + 1
            KEYI(IK) = KEYSDV(IKEY+J)
   16     CONTINUE
        ENDIF
      ELSE IF (IOTYDK(IKEY).EQ.2) THEN
*  *        Integer
        LEN  = MIN (10,LKEY)
        KY10 = BLANK(1:10-LEN)//KYVAL(1:LEN)
        READ (KY10(1:10), 1002) KEYSDV(IKEY)
        KEYI(IK) = KEYSDV(IKEY)
      ELSE IF (IOTYDK(IKEY).EQ.1) THEN
*  *        Bit-string
        LEN  = MIN (8,LKEY)
        KY10 = BLANK(1:8-LEN)//KYVAL(1:LEN)
        READ (KY10(1:8), 1003) KEYSDV(IKEY)
        KEYI(IK) = KEYSDV(IKEY)
      ENDIF
      GO TO 10
   20 CONTINUE
      NI = IK
*
*   * Variable data-length and Search Options in CHOPT
*
      CHOPT(IC+1:IC+2) = 'VS'
*
*  ** Find the Objects Satisfying the Search
*
      CALL DBUSE (PATHN, LKVWDX(1), LDVWDX(1), IDATM, KEYSDV(1),
     +            CHOPT(1:IC+2))
*
*  ** Get the Key-Names to Present
*
      CALL VZERO (JFKYDV, NWKYDK)
      CALL VZERO (IFLAG, NWKYDK)
      IP = 1
      ICONO(I) = 0
      CHTO(1)  = CTAGDK(1)
      IOTO(1)  = IOTYDK(1)
      JFKYDV(1) = 1
   25 CALL KUPROC ('Key-Name to Present (if no more: |) ?', KYNAM, LKEY)
      IF (KYNAM.EQ.'|')     GO TO 30
      I = NSYSDK+1
   26 IF (I.GT.NWKYDK)      GO TO 28
        IF (KYNAM.EQ.CTAGDK(I).AND.IFLAG(I).EQ.0) THEN
          IFLAG(I) = 1
          IP = IP + 1
          CHTO(IP)  = CTAGDK(I)
          IOTO(IP)  = IOTYDK(I)
          ICONO(IP) = ICONDK(I)
          JFKYDV(IP) = I
          IF (ICONO(IP).LE.0) THEN
            GO TO 25
          ELSE
            NREP = ICONO(IP)
            DO 27 J = 1,NREP
              IP = IP + 1
              I = I + 1
              IFLAG(I) = 1
              CHTO(IP)  = CTAGDK(I)
              IOTO(IP)  = IOTYDK(I)
              ICONO(IP) = ICONDK(I)
              JFKYDV(IP) = I
   27       CONTINUE
          ENDIF
          GO TO 25
        ENDIF
        I = I + 1
        GO TO 26
   28 CONTINUE
      GO TO 25
   30 CONTINUE
*
*  ** Lift Bank for Output
*
      NO = IP
      IF (NO.LE.0)          GO TO 999
      NOBO = NZBANK (IDIVDB, LKVWDX(1))
      IF (NOBO.LE.0)        GO TO 999
      NDAT = NO *  NOBO
      CALL DBBOOK (IDIVDB, LVIWDX, LVIWDX, 2, 'VIEW', 0, 0, NDAT, 2, 0)
      IF (IQUEST(1).NE.0)   GO TO 999
*
*  ** Fill-Up 'VIEW' Bank and free LKVWDX
*
      IPOIN = LVIWDX
      NKOBJ = NZBANK (IDIVDB, LKVWDX(1))
      IF (NKOBJ.GT.0) THEN
        LFRSDX = LKVWDX(1)
        DO 40 K = 1, NKOBJ
          IF (LFRSDX.GT.0) THEN
            DO 35 J = 1, NO
              IPOIN = IPOIN + 1
              IQ(KOFUDB+IPOIN) = IQ(KOFUDB+LFRSDX+JFKYDV(J))
   35       CONTINUE
          ENDIF
          LFRSDX = LQ(KOFUDB+LFRSDX)
   40   CONTINUE
      ENDIF
      CALL MZDROP (IDIVDB, LKVWDX(1), ' ')
      GO TO 999
*
* *** Error messages
*
  991 IQUEST(1) = 101
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) THEN
        KYVAL  = PATHN
        NCH    = LENOCC (KYVAL)
        CALL DBPRNT (LPRTDB, '(/,'' DBVWPR : Illegal Path Name '//
     +       KYVAL(1:NCH)//''')', IARGDB, 0)
      ENDIF
+SELF.
      GO TO 999
*
  992 IQUEST(1) = 102
+SELF, IF=$DEBUG.
      IF (IDEBDB.GT.0) THEN
        KYVAL  = PATHN
        NCH    = LENOCC (KYVAL)
        CALL DBPRNT (LPRTDB, '(/,'' DBVWPR : Less than '',I5,'' key '//
     +       'for Path Name '//KYVAL(1:NCH)//''')', NSYSDK, 1)
      ENDIF
+SELF.
      GO TO 999
*
 1001 FORMAT (I2)
 1002 FORMAT (I10)
 1003 FORMAT (Z8)
*                                                             END DBVWPR
  999 END
+DECK, DBWRDP.
      SUBROUTINE DBWRDP (LUN, LAD)
*     ============================
*
************************************************************************
*                                                                      *
*        SUBR. DBWRDP (LUN, LAD)                                       *
*                                                                      *
*   Prepares the display the data on unit LUN and at address LAD       *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LUN      Unit number of file for display                         *
*     LAD      Address of the data in DBSTOR                           *
*                                                                      *
*   Called by DBDISD, DBPEEK                                           *
*                                                                      *
*   Original Code : J. Zoll                                            *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
+CDE, MZIOC.
+SEQ, L3BITS, T=PASS.
*
*     ------------------------------------------------------------------
*
*  ** No data to display
*
      NDAT = IQ(KOFUDB+LAD-1)
      IF (NDAT.LE.0)        GO TO 999
*
*  ** Crack I/O Words into the character description
*
      LIO = LAD - IQ(KOFUDB+LAD-3) - JBYT(IQ(KOFUDB+LAD),19,4) - 1
      CALL MZIOCR (LQ(KOFUDB+LIO))
*
*  ** This part (upto the RETURN) is by courtesy of J. Zoll
*
      NDONE = 0
      JFOCUR = 0
   10 ITYPE = MFO(JFOCUR+1)
      IF (ITYPE.EQ.7)       GO TO 31
      NWSEC = MFO(JFOCUR+2)
      NDO   = NWSEC
      IT    = ITYPE
      IF (NDO.GT.0)         GO TO 41
*
      IF (NDO.LT.0)  THEN
*
*  *    Rest of the bank
*
        NDO = NDAT
      ELSE
*
*  *    Dynamic sector
*
        NDONE = NDONE + 1
        NDO   = IQ(KOFUDB+LAD+NDONE)
      ENDIF
      GO TO 34
*
*  ** Self-describing sector
*
   31 NDONE = NDONE + 1
      IWORD = IQ(KOFUDB+LAD+NDONE)
      IT    = MOD (IWORD,16)
      NDO   = IWORD/16
*
   34 IF (IT.GE.8)          GO TO 999
      IF (NDO.LT.0)         GO TO 999
      IF (NDO.EQ.0)         GO TO 999
*
   41 JS = NDONE + 1
      JE = MIN (NDONE+NDO, NDAT)
      DO 47 J = JS, JE
        IF (IT.EQ.1) THEN
          WRITE (LUN, 1001) J, Q(KOFUDB+LAD+J)
        ELSE IF (IT.EQ.2) THEN
          WRITE (LUN, 1002) J,IQ(KOFUDB+LAD+J)
        ELSE IF (IT.EQ.3) THEN
          WRITE (LUN, 1003) J, Q(KOFUDB+LAD+J)
        ELSE IF (IT.EQ.5) THEN
          WRITE (LUN, 1004) J,IQ(KOFUDB+LAD+J)
        ENDIF
   47 CONTINUE
      NDONE = JE
      IF (NDONE.GE.NDAT)    GO TO 999
*
      JFOCUR = JFOCUR + 2
      IF (JFOCUR.LT.JFOEND) GO TO 10
      JFOCUR = JFOREP
      GO TO 10
*
 1001 FORMAT (1X,'B',I5,4X,Z10)
 1002 FORMAT (1X,'I',I5,4X,I10)
 1003 FORMAT (1X,'F',I5,4X,E12.4)
 1004 FORMAT (1X,'H',I5,4X,A4)
*                                                             END DBWRDP
  999 END
+DECK, DBXINI.
      SUBROUTINE DBXINI
*     =================
*
************************************************************************
*                                                                      *
*        SUBR. DBXINI                                                  *
*                                                                      *
*   Routine to Initialize the DB Interactive Run                       *
*                                                                      *
*   Called by DBMAIN                                                   *
*                                                                      *
************************************************************************
*
+CDE, DXLINK.
+CDE, DDISPL.
+CDE, L3CORES.
      PARAMETER       (NDIV1=5000)
      COMMON /GCBANK/ FENCDB(22), LQ(L3CORQ)
      DIMENSION       IAR(3)
*
*     ------------------------------------------------------------------
*
      LURZDX = 1
      L3PRDX = 6
*
      CALL MZSTOR (ISTODX, '/GCBANK/', ' ', FENCDB(1), LQ(1), LQ(1),
     +             LQ(1), LQ(NDIV1), LQ(L3CORQ))
      NDIV2  = 3*L3CORQ/4
*
      CALL MZDIV  (ISTODX, IDIV, 'DB-USERS', NDIV2/2, NDIV2, 'LC')
      CALL MZLINK (ISTODX, '/DXLINK/', LFRSDX, LFRSDX, LASTDX)
*
      IAR(1) = LURZDX
      IAR(2) = ISTODX
      IAR(3) = IDIV
      CALL DBPRNT (L3PRDX, '(/,''  ----- Interactive Session on DBL3 '//
     +     'Test-Run Starts -----'',//,10X,''RZ-Unit Number : '',I5'//
     +     ',''  DBL3_Store :'',I10,''  User-Division :'',I10,/)',IAR,3)
*
*  ** Set Default Display Range
*
      MXDPDD = 80
      WRITE (CFMTDD, '(''(A'',I3,'')'')') MXDPDD
      GO TO 999
*                                                             END DBXINI
  999 END
+PATCH, DBEXTRA.
+DECK, DBGETA.
      SUBROUTINE DBGETA (LSUP, NADMX, IADRS, NADRS)
*     =============================================
*
************************************************************************
*                                                                      *
*        SUBR. DBGETA (LSUP, NADMX, IADRS*, NADRS*)                    *
*                                                                      *
*   Gets all bank addresses where data are present from a ZEBRA        *
*   structure given by its support link                                *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LSUP     Support link of the ZEBRA data structure                *
*     NADMX    Maximum number of addresses to be stored                *
*     IADRS(*) Array containing the bank addresses                     *
*     NADRS(*) Number of addresses                                     *
*                                                                      *
*   Called by DBTSAD                                                   *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =121 : Store area in DBGETA is insufficient            *
*               =122 : NADMX is too small for the data structure       *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
      PARAMETER       (NPMAX=500)
      DIMENSION       LSTOR(NPMAX), IADRS(500)
*
*     ------------------------------------------------------------------
*
      NADRS = 0
      NPUSH = 0
*
* *** Top bank
*
      L = LSUP
   10 CONTINUE
      ND = IQ(KOFUDB+L-1)
      IF (ND.GT.0) THEN
        NADRS = NADRS + 1
        IF (NADRS.LE.NADMX) IADRS(NADRS) = L
      ENDIF
*
*  ** Linear structure
*
      LACT = LQ(KOFUDB+L)
      IF (LACT.GT.0) THEN
        IF (NPUSH.GE.NPMAX)  THEN
          IQUEST(1) = 121
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGETA : Too '//
     +    'many link addresses to be stored'')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
        NPUSH = NPUSH + 1
        LSTOR(NPUSH) = LACT
      ENDIF
*
*  ** Structural links
*
      NS = IQ(KOFUDB+L-2)
      IL = 1
   20 CONTINUE
      IF (IL.GT.NS) GO TO 30
      LACT = LQ(KOFUDB+L-IL)
      IF (LACT.GT.0) THEN
        IF (NPUSH.GE.NPMAX)  THEN
          IQUEST(1) = 121
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGETA : Too '//
     +    'many link addresses to be stored'')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
        NPUSH = NPUSH + 1
        LSTOR(NPUSH) = LACT
      ENDIF
      IL = IL + 1
      GO TO 20
   30 CONTINUE
*
*  ** Go to existing links
*
      IF (NPUSH.GT.0) THEN
        L = LSTOR(NPUSH)
        NPUSH = NPUSH - 1
        GO TO 10
      ENDIF
*
      IF (NADRS.GT.NADMX)  THEN
        IQUEST(1) = 122
        IQUEST(11)= NADRS
        IQUEST(12)= NADMX
+SELF, IF=$DEBUG.
        IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBGETA : Too man'//
     +  'y addresses '',I6,'' a maximum of '',I6,'' allowed'')',
     +  IQUEST(11), 2)
+SELF.
      ELSE
        IQUEST(1) = 0
      ENDIF
*                                                             END DBGETA
  999 END
+DECK, DBPKTR.
      SUBROUTINE DBPKTR (IDATE, ITIME, IDATM)
*     =======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBPKTR (IDATE, ITIME, IDATM*)                           *
*                                                                      *
*   Packs date and time into one word  (Version of R.Brun)             *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDATE    Date : 6 Decimal integer : YYMMDD                       *
*     ITIME    Time : 4 Decimal integer : HHMM                         *
*     IDATM*   Packed date-time                                        *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
************************************************************************
*
      IDATM = 0
      CALL RZDATE (IDATM, IDATE, ITIME, 3)
*                                                             END DBPKTR
      END
+DECK, DBTSAD.
      SUBROUTINE DBTSAD (LSUP)
*     ========================
*
************************************************************************
*                                                                      *
*        SUBR. DBTSAD (LSUP)                                           *
*                                                                      *
*   Prints the bank contents of a ZEBRA data structure                 *
*   (Only integer data type is permitted)                              *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     LSUP     Support link of the ZEBRA data structure                *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
*   Error Condition :                                                  *
*                                                                      *
*     IQUEST(1) =  0 : No error                                        *
*               =123 : Illegal data type                               *
*                                                                      *
************************************************************************
*
+CDE, DBSTOR.
      PARAMETER       (NADMX=500)
      DIMENSION       IADRS(NADMX)
*
*     ------------------------------------------------------------------
*
      CALL DBGETA (LSUP, NADMX, IADRS, NADRS)
      IF (IQUEST(1).NE.0) GO TO 999
      CALL DBPRNT (LPRTDB, '(//,'' DBTSAD : Number of addresses where'//
     +     ' data exist'',I5,/)', NADRS, 1)
      DO 10 IA = 1, NADRS
        LA   = IADRS(IA)
        ID   = IDBTYP (LA)
        IF (ID.NE.2)  THEN
          IQUEST(1) = 123
+SELF, IF=$DEBUG.
          IF (IDEBDB.GT.0) CALL DBPRNT (LPRTDB, '(/,'' DBTSAD : Illeg'//
     +    'al data type '')', IARGDB, 0)
+SELF.
          GO TO 999
        ENDIF
        NDA  = IQ(KOFUDB+LA-1)
        CALL DBPRNT (LPRTDB, '(/,'' DBTSAD : # of data '',I4)', NDA, 1)
        CALL DBPRNT (LPRTDB, '(2X,5I4)', IQ(KOFUDB+LA+1), NDA)
   10 CONTINUE
*                                                             END DBTSAD
  999 END
+DECK, DBUPTR.
      SUBROUTINE DBUPTR (IDATE, ITIME, IDATM)
*     =======================================
*
************************************************************************
*                                                                      *
*        SUBR. DBUPTR (IDATE*, ITIME*, IDATM)                          *
*                                                                      *
*   Unpacks date and time from one word  (Version of R.Brun)           *
*                                                                      *
*   Arguments :                                                        *
*                                                                      *
*     IDATE*   Date : 6 Decimal integer : YYMMDD                       *
*     ITIME*   Time : 4 Decimal integer : HHMM                         *
*     IDATM    Packed date-time                                        *
*                                                                      *
*   Called by user                                                     *
*                                                                      *
************************************************************************
*
      CALL RZDATE (IDATM, IDATE, ITIME, 1)
*                                                             END DBUPTR
      END
+PATCH, DBINSTAL, IF=$DOC.
+DECK, DBINSTAL.
 
The decks DBLIBxx, and DBL3EXxx are models of Patchy control cards to
respectively prepare the unique DBL3EX library and to execute the
programs DBEXAM1 and DBEXAM2.
  xx = AP for APOLLO
     = CY for CRAY
     = VM for IBM/VM
     = VX for VAX/VMS
 
 
+DECK, DBLIBAP.  For APOLLO      Turn & in column 1 to +
# ---------------------------- INSTALL_DBLIB ---------------------------
#
#  Command procedure for the creation of the basic library DBLIB308
#
# ----------------------------------------------------------------------
EON
 
/l3/com/ypatchy <<!
 - =dblib310.ftn TTY TTY .GO
&EXE.
&OPTION, MAP.
&USE, APOLLO, *ZAPO.
&USE, *DBLIB.
&PAM, 11, R=QCDE,  T=A      ./cern/pro/pam/zebra.pam
&PAM, 12,          T=A, T=C ./l3/pam/dbl3v310.car
&QUIT.
!
 
/l3/com/compile dblib310 -save -indexl -zero -dba
 
IF existf dblib310.lib THEN dlf dblib310.lib -l ENDIF
 
lbr -cre dblib310.lib dblib310/?*.bin
 
dlf dblib310/?*.bin -nq
 
EOFF
+DECK, DBLIBCY.  For CRAY        Turn & in column 1 to +
set -vx
# ---------------------------- INSTALL_DBLIB ---------------------------
#
#  Command procedure for the creation of the basic library DBLIB310
#
# ----------------------------------------------------------------------
if [ -f dblib310.l ] then rm dblib310.l fi
if [ -f dblib310.o ] then rm dblib310.o fi
ypatchy - =dblib310.f tty tty :go <<-EOF
&EXE.
&OPT, MAP.
&USE, CRAY, *ZCRU.
&USE, *DBLIB.
&PAM, 11, R=QCDE,      T=A. /cern/pro/pam/zebra.pam
&PAM, 12,         T=C, T=A. /u/xv/l3pams/dbl3v310.car
&QUIT.
EOF
echo 'patchy part is over'
if [ "$?" = "0" ]
then
echo 'ASM created successfully'
echo 'compilation starts'
else
echo "$?"
echo 'problem in patchy parts'
exit
fi
echo 'compilation starts..'
cft77 -es -V -A fast -o novector -m3 -- dblib310.f
if [ "$?" = "0" ]
then
echo 'compilation is over'
else
echo "$?"
echo 'problem in compilation'
exit
fi
if [ "$?" = "0" ]
then
echo 'library part starts'
bld rzv dblib310.a dblib310.o
else
echo "$?"
echo 'problem in library creation'
exit
fi
+DECK, DBLIBVM.  For IBM/VM
/* ------------------------------------------------------------------ */
/*                                                                    */
/* DBLIB    An exec to produce the basic library DBLIB310 from the    */
/*          pam file DBL3V310.                                        */
/*                                                                    */
/* ------------------------------------------------------------------ */
trace c
'GIME CERNPAMS'
/*             Patchy step                                            */
queue "+SELF."
queue "+SELF. This is the DBLIB310 cradle for VM. Used by DBLIB310 EXEC"
queue "+SELF."
queue "+EXE."
queue "+OPT, MAP."
queue "+USE, IBM, *ZIBM."
queue "+USE, *DBLIB."
queue "+PAM, 11, R=QCDE."
queue "+PAM, 12."
queue "+QUIT."
exec       ypatchy,
           'pam="ZEBRA PAM *"',
           'pam="DBL3V310 PAM *"',
           'asm="DBLIB310 FORTRAN A"',
       'listing="DBLIB310 LISTING A"'
If rc < 5  Then 'ERASE DBLIB310 LISTING A';   else   exit
/*             Compile                                   */
'EXEC VFORT' DBLIB310
If rc <  5 Then 'ERASE DBLIB310 LISTING A'; else   exit
'ERASE DBLIB310 FORTRAN A'
/*             Create the library                        */
'EDITLIB DBLIB310'
'TXTLIB GEN DBLIB310 DBLIB310'
'ERASE DBLIB310 EDITMAP'
'ERASE DBLIB310 TEXT'
Exit
+DECK, DBLIBVX.  For VAX         Turn & in column 1 to +
$!------------------------------ DBLIB.COM -----------------------------
$!
$! Command procedure for the creation of the basic library DBLIB310
$!
$!----------------------------------------------------------------------
$ DEL/LOG DBLIB310.FOR;*
$ YPATCHY
  - L3$LIB:DBLIB310 TTY TTY .GO
&EXE.
&USE, VAX, *ZVAX.
&USE, *DBLIB.
&PAM, 11, R=QCDE,  T=A.    CERN$LIBPAMS:ZEBRA.PAM
&PAM, 12,     T=C, T=A.    L3$PAM:DBL3V310.CAR
&QUIT.
$ FORTRAN/DEBUG/NOLIST/NOOPT L3$LIB:DBLIB310
$ DEL/LOG DBLIB310.OLB;*
$ LIBRARY/CREATE L3$LIB:DBLIB310 L3$LIB:DBLIB310
$ DEL/LOG DBLIB310.OBJ;*
+DECK, DBL3EXAP. For APOLLO      Turn & in column 1 to +
# -------------------------- INSTALL_DBL3EX ----------------------------
#
#  Command procedure for creating DBEXAM1 and DBEXAM2 and execute them
#
# ----------------------------------------------------------------------
EON
 
IF existf dbexam1.ftn THEN dlf dbexam1.ftn -l ENDIF
 
/l3/com/ypatchy <<!
  - dbexam1.ftn TTY TTY .GO
&EXE.
&OPT, MAP.
&SELF.
&USE, APOLLO.
&USE, DBEXAM1.
&SELF. +USE, $DEBUG.
&PAM, 11, R=DBMAIN, T=A, T=C. /l3/pam/dbl3v310.car
&QUIT.
!
 
/l3/com/compile dbexam1 -save -indexl -zero -dba
 
IF existf dbexam1.exe THEN dlf dbexam1.exe -l ENDIF
 
bind -b dbexam1.exe - <<!
dbexam1/?*.bin
/l3/lib/dblib310.lib
/cern/pro/lib/libpacklib.a
/cern/pro/lib/libkernlib.a
!
 
dlf dbexam1/?*.bin -nq
 
IF existf dbexam2.ftn THEN dlf dbexam2.ftn -l ENDIF
 
/l3/com/ypatchy <<!
  - dbexam2.ftn TTY TTY .GO
&EXE.
&OPT, MAP.
&SELF.
&USE, APOLLO.
&USE, DBEXAM2.
&SELF. +USE, $DEBUG.
&USE, $INIMODE.
&PAM, 11, R=DBMAIN, T=A, T=C. /l3/pam/dbl3v310.car
&QUIT.
!
 
/l3/com/compile dbexam2 -save -indexl -zero -dba
 
IF existf dbexam2.exe THEN dlf dbexam2.exe -l ENDIF
 
bind -b dbexam2.exe - <<!
dbexam2/?*.bin
/l3/lib/dblib310.lib
/cern/pro/lib/libpacklib.a
/cern/pro/lib/libkernlib.a
!
 
dlf dbexam2/?*.bin -nq
 
IF existf dbmuon.dat THEN dlf dbmuon.dat -l ENDIF
IF existf dbmufz.dat THEN dlf dbmufz.dat -l ENDIF
 
dbexam1.exe
 
IF existf dbmuom.dat THEN dlf dbmuom.dat -l ENDIF
 
dbexam2.exe
 
EOFF
+DECK, DBL3X1CY. For CRAY
# -------------------------- INSTALL_DBL3X1 ----------------------------
#
# This is dbexam1 script to run dbexam1 program given in DBL3.
#
# ----------------------------------------------------------------------
echo 'this is dbexam1 script'
ypatchy - =dbexam1.f tty tty .go <<\EOF
&EXE.
&OPT, MAP.
&USE, CRAY.
&USE, DBEXAM1.
&SELF. +USE, $DEBUG.
&PAM, 11, R=DBMAIN, T=C, T=A. /u/xv/l3pams/dbl3v310.car
&QUIT.
EOF
echo 'patchy part is over'
if [ "$?" = "0" ]
then
echo 'starting compilation..'
cft77 -esx -- dbexam1.f
fi
echo 'compilation is over'
if [ "$?" = "0" ]
then
echo 'compilation is ok'
else
echo "$?"
echo 'problem in compilation'
exit
fi
cat > segdir <<\EOF
LIB=/u/xv/l3libs/dblib310.a
LIB=/cern/pro/lib/npacklib.a
LIB=/cern/pro/lib/kernlib.a
EOF
segldr -i segdir -o exam1 dbexam1.o
exit
+DECK, DBL3X2CY. For CRAY
# -------------------------- INSTALL_DBL3X2----------------------------
#
# This is dbexam2 script to run dbexam2 program given in DBL3.
#
# ----------------------------------------------------------------------
echo 'this is dbexam2 script'
ypatchy - =dbexam2.f tty tty .go <<\EOF
&EXE.
&OPT, MAP.
&USE, CRAY.
&USE, DBEXAM2.
&SELF. +USE, $DEBUG.
&USE, $INIMODE.
&PAM, 11, R=DBMAIN, T=C, T=A. /u/xv/l3pams/dbl3v310.car
&QUIT.
EOF
echo 'patchy part is over'
if [ "$?" = "0" ]
then
echo 'starting compilation..'
cft77 -esx -- dbexam2.f
fi
echo 'compilation is over'
if [ "$?" = "0" ]
then
echo 'compilation is ok'
else
echo "$?"
echo 'problem in compilation'
exit
fi
cat > segdir <<\EOF
LIB=/u/xv/l3libs/dblib310.a
LIB=/cern/pro/lib/npacklib.a
LIB=/cern/pro/lib/kernlib.a
EOF
segldr -i segdir -o exam2 dbexam2.o
exit
+DECK, DBL3X1VM. For IBM/VM
/**********************************************************************/
/*                                                                    */
/* DBL3X1   An exec to produce the DBEXAM1 load module and run.       */
/*          Set the options you require in a private version          */
/*          of the cradle file. Note that the cradle file is          */
/*          taken from the first disk on which it is found.           */
/*                                                                    */
/**********************************************************************/
trace    c
xtent = 1000
fname = DBEXAM1
/*                                                                    */
'GIME CERNPAMS'
queue "+SELF."
queue "+SELF. This is a model for the DBEXAM1 cradle, VM version."
queue "+SELF."
queue "+EXE."
queue "+OPT, MAP."
queue "+SELF."
queue "+USE, IBM."
queue "+USE, DBEXAM1."
queue "+SELF. +USE, $DEBUG."
queue "+PAM, 11."
queue "+QUIT."
EXEC         YPATCHY,
             'LISTING="'fname' LISTING A"',
             'PAM="DBL3V310 PAM *"',
             'ASM="'fname' FORTRAN A"'
If rc < 5 Then 'ERASE 'fname' LISTING A'; Else Exit
'EXEC VFORT 'fname
/* Creation of the load module is complete. The following procedure   */
/* is to run the program and can be moved to a separate exec          */
/* if desired.                                                        */
'GIME CRNUDISK'
'CERNLIB DBLIB310'
/* This is the unit for the Geant datacards input */
'FILEDEF 6 DISK 'fname' OUTPUT A'
/* Initialize storage for safety */
'SETSTOR 00'
'LOAD 'fname' (START'
if rc = 0 then do
'ERASE 'fname' TEXT'
'ERASE 'fname' LISTING'
'ERASE LOAD MAP'
end
Exit 0
/*  End of DBL3X1 EXEC */
+DECK, DBL3X2VM. For IBM/VM
/**********************************************************************/
/*                                                                    */
/* DBL3X2   An exec to produce the DBEXAM2 load module and run.       */
/*          Set the options you require in a private version          */
/*          of the cradle file. Note that the cradle file is          */
/*          taken from the first disk on which it is found.           */
/*                                                                    */
/**********************************************************************/
trace    c
fname = DBEXAM2
/*                                                                    */
'GIME CERNPAMS'
queue "+SELF."
queue "+SELF. This is a model for the DBEXAM2 cradle, VM version."
queue "+SELF."
queue "+EXE."
queue "+OPT, MAP."
queue "+SELF."
queue "+USE, IBM."
queue "+USE, DBEXAM2."
queue "+SELF. +USE, $DEBUG."
queue "+USE, $INIMODE."
queue "+PAM, 11."
queue "+QUIT."
EXEC         YPATCHY,
             'LISTING="'fname' LISTING A"',
             'PAM="DBL3V310 PAM *"',
             'ASM="'fname' FORTRAN A"'
If rc < 5 Then 'ERASE 'fname' LISTING A'; Else Exit
'EXEC VFORT 'fname
/* Creation of the load module is complete. The following procedure   */
/* is to run the program and can be moved to a separate exec          */
/* if desired.                                                        */
'GIME CRNUDISK'
'CERNLIB DBLIB310'
/* This is the unit for the Geant datacards input */
'FILEDEF 6 DISK 'fname' OUTPUT A'
/* Initialize storage for safety */
'SETSTOR 00'
'LOAD 'fname' (START'
if rc = 0 then do
'ERASE 'fname' TEXT'
'ERASE 'fname' LISTING'
'ERASE LOAD MAP'
end
Exit 0
/*  End of DBL3X2 EXEC */
+DECK, DBL3EXVX. For VAX         Turn & in column 1 to +
$!---------------------------- DBL3EX.COM ------------------------------
$!
$! Command procedure for creating DBEXAM1.EXE and DBEXAM2.EXE
$!  and execute them
$!
$!----------------------------------------------------------------------
$ DEL/LOG DBEXAM1.FOR;*
$ YPATCHY
  - DBEXAM1 TTY TTY .GO
&EXE.
&OPT, MAP.
&SELF.
&USE, VAX.
&USE, DBEXAM1.
&SELF. +USE, $DEBUG.
&PAM, 11,     T=C, T=A.    L3$PAM:DBL3V310.CAR
&QUIT.
$ DEL/LOG DBEXAM1.OBJ;*
$ FORTRAN/DEBUG/NOLIST/NOOPT DBEXAM1
$ DEL/LOG DBEXAM1.EXE;*
$ CERNLIB L3$LIB:DBLIB310
$ LINK/DEBUG/NOMAP DBEXAM1,'LIB$'
$ DEL/LOG DBEXAM2.FOR;*
$ YPATCHY
  - DBEXAM2 TTY TTY .GO
&EXE.
&OPT, MAP.
&SELF.
&USE, VAX.
&USE, DBEXAM2.
&SELF. +USE, $DEBUG.
&USE, $INIMODE.
&PAM, 11,     T=C, T=A.    L3$PAM:DBL3V310.CAR
&QUIT.
$ DEL/LOG DBEXAM2.OBJ;*
$ FORTRAN/DEBUG/NOLIST/NOOPT DBEXAM2
$ DEL/LOG DBEXAM2.EXE;*
$ CERNLIB L3$LIB:DBLIB310
$ LINK/DEBUG/NOMAP DBEXAM2,'LIB$'
$ DEL/LOG DBMUON.DAT;*
$ DEL/LOG DBMUFZ.DAT;*
$ RUN/NODEB DBEXAM1
$ DEL/LOG DBMUOM.DAT;*
$ RUN/NODEB DBEXAM2
+DECK, DBXINTAP. For Apollo      Turn & in column 1 to +
# -------------------------- INSTALL_DBXINT ----------------------------
#
#  Command procedure for creation of the load module DBXINT
#  (User is supposed to use PAWINLIB by a previous command)
#
# ----------------------------------------------------------------------
#
EON
 
IF existf dbxint.ftn THEN dlf dbxint.ftn -l ENDIF
IF existf dblogn.kumac THEN dlf dblogn.kumac -l ENDIF
 
/l3/com/ypatchy <<!
  - dbxint.ftn TTY TTY - dblogn.kumac .GO
&EXE, CRA*.
&OPT, MAP.
&ASM, 21.
&ASM, 23.
&USE, APOLLO, *ZAPO.
&USE, *DBINT, T=EXE.
&PAM, 11, R=QCDE,   T=A.         /cern/pro/pam/zebra.pam
&PAM, 11, R=DBMAIN, T=A, T=C.    /l3/pam/dbl3v310.car
&QUIT.
!
 
/l3/com/compile dbxint -save -indexl -zero -dba
 
IF existf dbxint.exe THEN dlf dbxint.exe -l ENDIF
 
bind -b dbxint.exe - <<!
dbxint/?*.bin
/l3/lib/dblib310.lib
/l3/lib/intlib160.lib
/cern/pro/lib/npacklib.a
/cern/pro/lib/ngraflib.a
/cern/gks/pro/lib/gkslib_any.a
/cern/gks/pro/lib/gksdriv_any.a
/cern/pro/lib/genlib.a
/cern/pro/lib/npacklib.a
/cern/pro/lib/pawlib.a
/cern/pro/lib/kernlib.a
!
 
dlf dbxint/?*.bin -nq -l
 
EOFF
+DECK, DBXINTVM. For IBM/VM
/**********************************************************************/
/*                                                                    */
/* DBXINT   An exec to produce the DBL3 interactive load module.      */
/*                                                                    */
/**********************************************************************/
trace    c
Parse Arg int .
fname = DBXINT
/*                                                                    */
'GIME CERNPAMS H'
queue "+SELF."
queue "+SELF. This is a model for the DBXINT cradle, VM version."
queue "+SELF."
queue "+EXE, CRA*."
queue "+OPT, MAP."
queue "+SELF."
queue "+ASM, 21."
queue "+ASM, 23."
queue "+USE, IBM, *ZIBM."
queue "+USE, *DBINT, T=EXE."
queue "+PAM, 11, R=QCDE,   T=A. ZEBRA PAM *"
queue "+PAM, 11, R=DBMAIN, T=A. DBL3V310 PAM E"
queue "+QUIT."
EXEC         YPATCHY,
             'LISTING="'fname' LISTING A"',
             'dummy="DUMMY"',
             'ASM="'fname' FORTRAN A"',
             'ASMD="DBLOGN KUMAC A"'
If rc < 5 Then 'ERASE 'fname' LISTING A'; Else Exit
'VFORT 'fname
/*
If rc < 5 Then 'ERASE 'fname' FORTRAN A'; Else Exit
If rc < 5 Then 'ERASE 'fname' LISTING A'; Else Exit
*/
/* Creation of the load module is complete. The following procedure   */
/* is to run the program and can be moved to a separate exec          */
/* if desired.                                                        */
'GIME CRNUDISK'
'EXEC CERNLIB DBLIB310 INTLI160 GRAFLIB PAWLIB',
 'NPACKLIB GENLIB KERNLIB (GTS2D'
/* Initialize storage for safety */
'SETSTOR 00'
'LOAD 'fname' PAW (CLEAR NOAUTO'
'GENMOD 'fname'I'
If rc =0 Then 'ERASE LOAD MAP'
Exit
/*  End of DBXINT EXEC */
+DECK, DBXINTVX. For VAX         Turn & in column 1 to +
$!----------------------------- DBXINT.COM -----------------------------
$!
$! Command procedure for creation of the load module DBXINT
$!
$!----------------------------------------------------------------------
$ DEL/LOG DBXINT.FOR;*
$ DEL/LOG DBLOGN.KUMAC;*
$ YPATCHY
  - DBXINT TTY TTY - DBLOGN.KUMAC .GO
&EXE, CRA*.
&OPT, MAP.
&ASM, 21.
&ASM, 23.
&USE, VAX, *ZVAX.
&USE, *DBINT, T=EXE.
&PAM, 11, R=QCDE,   T=A.         CERN$LIBPAMS:ZEBRA.PAM
&PAM, 11, R=DBMAIN, T=A, T=C.    L3$PAM:DBL3V310.CAR
&QUIT.
$ FORTRAN/DEBUG/NOLIST/NOOPT/OBJECT=DBXINT DBXINT
$ DEL/LOG DBXINT.EXE;*
$ CERNLIB/GTS2D L3$LIB:INTLIB160,DBLIB310,PACKLIB,PAWLIB,GRAFLIB,-
  GENLIB,PACKLIB,KERNLIB
$ LINK/DEBUG/NOMAP/EXE=DBXINT DBXINT,'LIB$'
$ DEL/LOG DBXINT.OBJ;*
